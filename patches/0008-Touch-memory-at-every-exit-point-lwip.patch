From e1e600f857f515e484441a556e55228f6dd9f25e Mon Sep 17 00:00:00 2001
From: Mateusz Krajewski <mkrajewski413@gmail.com>
Date: Sun, 26 Feb 2023 12:29:38 +0000
Subject: [PATCH 1/1] Touch memory at every exit point lwip

Signed-off-by: Mateusz Krajewski <mkrajewski413@gmail.com>
---
 doc/NO_SYS_SampleCode.c                    |   7 ++
 doc/ZeroCopyRx.c                           |   4 +
 src/api/api_lib.c                          |  34 +++++++
 src/api/api_msg.c                          |  33 +++++++
 src/api/err.c                              |   6 ++
 src/api/if_api.c                           |   2 +
 src/api/netbuf.c                           |  16 ++++
 src/api/netdb.c                            |   8 ++
 src/api/netifapi.c                         |  12 +++
 src/api/tcpip.c                            |  24 +++++
 src/apps/altcp_tls/altcp_tls_mbedtls.c     |  79 ++++++++++++++++
 src/apps/altcp_tls/altcp_tls_mbedtls_mem.c |  13 +++
 src/apps/http/altcp_proxyconnect.c         |  51 +++++++++++
 src/apps/http/fs.c                         |   4 +
 src/apps/http/fsdata.c                     |   2 +
 src/apps/http/http_client.c                |  49 ++++++++++
 src/apps/http/httpd.c                      |  53 +++++++++++
 src/apps/http/makefsdata/makefsdata.c      |  32 +++++++
 src/apps/lwiperf/lwiperf.c                 |  34 +++++++
 src/apps/mdns/mdns.c                       | 101 +++++++++++++++++++++
 src/apps/mqtt/mqtt.c                       |  51 +++++++++++
 src/apps/netbiosns/netbiosns.c             |  10 ++
 src/apps/smtp/smtp.c                       |  48 ++++++++++
 src/apps/snmp/snmp_asn1.c                  |  21 +++++
 src/apps/snmp/snmp_core.c                  |  49 ++++++++++
 src/apps/snmp/snmp_mib2.c                  |   3 +
 src/apps/snmp/snmp_mib2_icmp.c             |  29 ++++++
 src/apps/snmp/snmp_mib2_interfaces.c       |  14 +++
 src/apps/snmp/snmp_mib2_ip.c               |  45 +++++++++
 src/apps/snmp/snmp_mib2_snmp.c             |   6 ++
 src/apps/snmp/snmp_mib2_system.c           |  18 ++++
 src/apps/snmp/snmp_mib2_tcp.c              |  17 ++++
 src/apps/snmp/snmp_mib2_udp.c              |  15 +++
 src/apps/snmp/snmp_msg.c                   |   2 +
 src/apps/snmp/snmp_netconn.c               |   5 +
 src/apps/snmp/snmp_pbuf_stream.c           |  18 ++++
 src/apps/snmp/snmp_raw.c                   |   5 +
 src/apps/snmp/snmp_scalar.c                |  13 +++
 src/apps/snmp/snmp_snmpv2_framework.c      |   7 ++
 src/apps/snmp/snmp_snmpv2_usm.c            |  28 ++++++
 src/apps/snmp/snmp_table.c                 |  13 +++
 src/apps/snmp/snmp_threadsync.c            |  18 ++++
 src/apps/snmp/snmp_traps.c                 |  15 +++
 src/apps/snmp/snmpv3.c                     |   7 ++
 src/apps/snmp/snmpv3_mbedtls.c             |   4 +
 src/apps/sntp/sntp.c                       |  26 ++++++
 src/apps/tftp/tftp_server.c                |  21 +++++
 src/core/altcp.c                           |  82 +++++++++++++++++
 src/core/altcp_alloc.c                     |   5 +
 src/core/altcp_tcp.c                       |  55 +++++++++++
 src/core/def.c                             |  11 +++
 src/core/dns.c                             |  25 +++++
 src/core/inet_chksum.c                     |  14 +++
 src/core/init.c                            |   3 +
 src/core/ip.c                              |   5 +
 src/core/ipv4/autoip.c                     |  17 ++++
 src/core/ipv4/dhcp.c                       |  45 +++++++++
 src/core/ipv4/etharp.c                     |  24 +++++
 src/core/ipv4/icmp.c                       |   4 +
 src/core/ipv4/igmp.c                       |  25 +++++
 src/core/ipv4/ip4.c                        |   2 +
 src/core/ipv4/ip4_addr.c                   |  10 ++
 src/core/ipv4/ip4_frag.c                   |  11 +++
 src/core/ipv6/dhcp6.c                      |   2 +
 src/core/ipv6/ethip6.c                     |   6 ++
 src/core/ipv6/icmp6.c                      |  11 +++
 src/core/ipv6/inet6.c                      |   2 +
 src/core/ipv6/ip6.c                        |  20 ++++
 src/core/ipv6/ip6_addr.c                   |   3 +
 src/core/ipv6/ip6_frag.c                   |  13 +++
 src/core/ipv6/mld6.c                       |  19 ++++
 src/core/ipv6/nd6.c                        |   2 +
 src/core/mem.c                             |  39 ++++++++
 src/core/memp.c                            |  15 +++
 src/core/netif.c                           |  54 +++++++++++
 src/core/pbuf.c                            |  67 ++++++++++++++
 src/core/raw.c                             |  14 +++
 src/core/stats.c                           |   9 ++
 src/core/sys.c                             |   3 +
 src/core/tcp.c                             |  70 ++++++++++++++
 src/core/tcp_in.c                          |  12 +++
 src/core/tcp_out.c                         |  49 ++++++++++
 src/core/timeouts.c                        |  20 ++++
 src/core/udp.c                             |   2 +
 src/netif/bridgeif.c                       |  21 +++++
 src/netif/bridgeif_fdb.c                   |  11 +++
 src/netif/ethernet.c                       |   7 ++
 src/netif/lowpan6.c                        |  11 +++
 src/netif/lowpan6_ble.c                    |  11 +++
 src/netif/lowpan6_common.c                 |   8 ++
 src/netif/ppp/auth.c                       |   2 +
 src/netif/ppp/ccp.c                        |  46 ++++++++--
 src/netif/ppp/chap-md5.c                   |   6 ++
 src/netif/ppp/chap-new.c                   |   2 +
 src/netif/ppp/chap_ms.c                    |  23 +++++
 src/netif/ppp/demand.c                     |  28 ++++--
 src/netif/ppp/eap.c                        |   2 +
 src/netif/ppp/ecp.c                        |   4 +
 src/netif/ppp/eui64.c                      |   3 +
 src/netif/ppp/fsm.c                        |  47 ++++++++--
 src/netif/ppp/ipcp.c                       |   2 +
 src/netif/ppp/ipv6cp.c                     |   2 +
 src/netif/ppp/lcp.c                        |  92 ++++++++++++++-----
 src/netif/ppp/magic.c                      |  11 +++
 src/netif/ppp/mppe.c                       |   9 ++
 src/netif/ppp/multilink.c                  |  84 +++++++++++++----
 src/netif/ppp/polarssl/arc4.c              |   4 +
 src/netif/ppp/polarssl/des.c               |   6 ++
 src/netif/ppp/polarssl/md4.c               |  13 ++-
 src/netif/ppp/polarssl/md5.c               |  13 ++-
 src/netif/ppp/polarssl/sha1.c              |  13 ++-
 src/netif/ppp/ppp.c                        |  74 +++++++++++++++
 src/netif/ppp/pppapi.c                     |  22 +++++
 src/netif/ppp/pppcrypt.c                   |   4 +
 src/netif/ppp/pppoe.c                      |   2 +
 src/netif/ppp/pppol2tp.c                   |  36 ++++++++
 src/netif/ppp/pppos.c                      |  30 ++++++
 src/netif/ppp/upap.c                       |  76 ++++++++++++----
 src/netif/ppp/utils.c                      |   2 +
 src/netif/ppp/vj.c                         |   6 ++
 src/netif/slipif.c                         |  20 ++++
 src/netif/zepif.c                          |  12 +++
 test/fuzz/fuzz.c                           |   7 ++
 test/sockets/sockets_stresstest.c          |  33 +++++++
 test/unit/api/test_sockets.c               |  18 ++++
 test/unit/arch/sys_arch.c                  |  25 +++++
 test/unit/core/test_def.c                  |   8 ++
 test/unit/core/test_mem.c                  |   9 ++
 test/unit/core/test_netif.c                |  10 ++
 test/unit/core/test_pbuf.c                 |  11 +++
 test/unit/core/test_timers.c               |  13 +++
 test/unit/dhcp/test_dhcp.c                 |  19 +++-
 test/unit/etharp/test_etharp.c             |  12 +++
 test/unit/ip4/test_ip4.c                   |   7 ++
 test/unit/ip6/test_ip6.c                   |  18 ++++
 test/unit/lwip_unittests.c                 |   4 +
 test/unit/mdns/test_mdns.c                 |  32 +++++++
 test/unit/mqtt/test_mqtt.c                 |  10 ++
 test/unit/tcp/tcp_helper.c                 |  18 ++++
 test/unit/tcp/test_tcp.c                   |  34 +++++++
 test/unit/tcp/test_tcp_oos.c               |  20 ++++
 test/unit/udp/test_udp.c                   |  15 +++
 142 files changed, 2849 insertions(+), 81 deletions(-)

diff --git a/doc/NO_SYS_SampleCode.c b/doc/NO_SYS_SampleCode.c
index 44ecc88..ba04d96 100644
--- a/doc/NO_SYS_SampleCode.c
+++ b/doc/NO_SYS_SampleCode.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 void
 eth_mac_irq()
 {
@@ -16,6 +18,7 @@ eth_mac_irq()
       pbuf_free(p);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t 
@@ -37,6 +40,7 @@ netif_output(struct netif *netif, struct pbuf *p)
   /* Start MAC transmit here */
   unlock_interrupts();
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -44,6 +48,7 @@ static void
 netif_status_callback(struct netif *netif)
 {
   printf("netif status changed %s\n", ip4addr_ntoa(netif_ip4_addr(netif)));
+  __A_VARIABLE = 1;
 }
 
 static err_t 
@@ -59,6 +64,7 @@ netif_init(struct netif *netif)
   SMEMCPY(netif->hwaddr, your_mac_address_goes_here, ETH_HWADDR_LEN);
   netif->hwaddr_len = ETH_HWADDR_LEN;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -119,4 +125,5 @@ main(void)
      
     /* your application goes here */
   }
+  __A_VARIABLE = 1;
 }
diff --git a/doc/ZeroCopyRx.c b/doc/ZeroCopyRx.c
index 24ebbae..b6add40 100644
--- a/doc/ZeroCopyRx.c
+++ b/doc/ZeroCopyRx.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 typedef struct my_custom_pbuf
 {
    struct pbuf_custom p;
@@ -20,6 +22,7 @@ void my_pbuf_free_custom(void* p)
   free_rx_dma_descriptor(my_pbuf->dma_descriptor);
   LWIP_MEMPOOL_FREE(RX_POOL, my_pbuf);
   SYS_ARCH_UNPROTECT(old_level);
+  __A_VARIABLE = 1;
 }
 
 void eth_rx_irq()
@@ -42,4 +45,5 @@ void eth_rx_irq()
   if(netif->input(p, netif) != ERR_OK) {
     pbuf_free(p);
   }
+  __A_VARIABLE = 1;
 }
diff --git a/src/api/api_lib.c b/src/api/api_lib.c
index 8b68382..0fd0bcd 100644
--- a/src/api/api_lib.c
+++ b/src/api/api_lib.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Sequential API External module
@@ -132,8 +134,10 @@ netconn_apimsg(tcpip_callback_fn fn, struct api_msg *apimsg)
 
   err = tcpip_send_msg_wait_sem(fn, apimsg, LWIP_API_MSG_SEM(apimsg));
   if (err == ERR_OK) {
+    __A_VARIABLE = 1;
     return apimsg->err;
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -174,10 +178,12 @@ netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_cal
       sys_mbox_free(&conn->recvmbox);
       flexos_free_whitelist(conn);
       API_MSG_VAR_FREE(msg);
+      __A_VARIABLE = 1;
       return NULL;
     }
   }
   API_MSG_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return conn;
 }
 
@@ -198,6 +204,7 @@ netconn_prepare_delete(struct netconn *conn)
 
   /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -217,8 +224,10 @@ netconn_prepare_delete(struct netconn *conn)
   API_MSG_VAR_FREE(msg);
 
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -238,6 +247,7 @@ netconn_delete(struct netconn *conn)
 
   /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -253,6 +263,7 @@ netconn_delete(struct netconn *conn)
   if (err == ERR_OK) {
     netconn_free(conn);
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -291,6 +302,7 @@ netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
 #endif /* LWIP_MPU_COMPATIBLE */
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -337,6 +349,7 @@ netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port)
   err = netconn_apimsg(lwip_netconn_do_bind, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -363,6 +376,7 @@ netconn_bind_if(struct netconn *conn, u8_t if_idx)
   err = netconn_apimsg(lwip_netconn_do_bind_if, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -397,6 +411,7 @@ netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port)
   err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -420,6 +435,7 @@ netconn_disconnect(struct netconn *conn)
   err = netconn_apimsg(lwip_netconn_do_disconnect, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -684,6 +700,7 @@ netconn_tcp_recvd_msg(struct netconn *conn, size_t len, struct api_msg *msg)
   msg->conn = conn;
   msg->msg.r.len = len;
 
+  __A_VARIABLE = 1;
   return netconn_apimsg(lwip_netconn_do_recv, msg);
 }
 
@@ -698,6 +715,7 @@ netconn_tcp_recvd(struct netconn *conn, size_t len)
   API_MSG_VAR_ALLOC(msg);
   err = netconn_tcp_recvd_msg(conn, len, &API_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -786,6 +804,7 @@ netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
   LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
              NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
 
+  __A_VARIABLE = 1;
   return netconn_recv_data_tcp(conn, new_buf, 0);
 }
 
@@ -807,6 +826,7 @@ netconn_recv_tcp_pbuf_flags(struct netconn *conn, struct pbuf **new_buf, u8_t ap
   LWIP_ERROR("netconn_recv_tcp_pbuf: invalid conn", (conn != NULL) &&
              NETCONNTYPE_GROUP(netconn_type(conn)) == NETCONN_TCP, return ERR_ARG;);
 
+  __A_VARIABLE = 1;
   return netconn_recv_data_tcp(conn, new_buf, apiflags);
 }
 #endif /* LWIP_TCP */
@@ -826,6 +846,7 @@ netconn_recv_udp_raw_netbuf(struct netconn *conn, struct netbuf **new_buf)
   LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
              NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);
 
+  __A_VARIABLE = 1;
   return netconn_recv_data(conn, (void **)new_buf, 0);
 }
 
@@ -846,6 +867,7 @@ netconn_recv_udp_raw_netbuf_flags(struct netconn *conn, struct netbuf **new_buf,
   LWIP_ERROR("netconn_recv_udp_raw_netbuf: invalid conn", (conn != NULL) &&
              NETCONNTYPE_GROUP(netconn_type(conn)) != NETCONN_TCP, return ERR_ARG;);
 
+  __A_VARIABLE = 1;
   return netconn_recv_data(conn, (void **)new_buf, apiflags);
 }
 
@@ -926,8 +948,10 @@ netconn_sendto(struct netconn *conn, struct netbuf *buf, const ip_addr_t *addr,
   if (buf != NULL) {
     ip_addr_set(&buf->addr, addr);
     buf->port = port;
+    __A_VARIABLE = 1;
     return netconn_send(conn, buf);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -955,6 +979,7 @@ netconn_send(struct netconn *conn, struct netbuf *buf)
   err = netconn_apimsg(lwip_netconn_do_send, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -979,6 +1004,7 @@ netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
   struct netvector vector;
   vector.ptr = dataptr;
   vector.len = size;
+  __A_VARIABLE = 1;
   return netconn_write_vectors_partly(conn, &vector, 1, apiflags, bytes_written);
 }
 
@@ -1113,6 +1139,7 @@ netconn_close_shutdown(struct netconn *conn, u8_t how)
   err = netconn_apimsg(lwip_netconn_do_close, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -1127,6 +1154,7 @@ err_t
 netconn_close(struct netconn *conn)
 {
   /* shutting down both ends is the same as closing */
+  __A_VARIABLE = 1;
   return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 }
 
@@ -1143,12 +1171,14 @@ netconn_err(struct netconn *conn)
   err_t err;
   SYS_ARCH_DECL_PROTECT(lev);
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
   SYS_ARCH_PROTECT(lev);
   err = conn->pending_err;
   conn->pending_err = ERR_OK;
   SYS_ARCH_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -1164,6 +1194,7 @@ netconn_err(struct netconn *conn)
 err_t
 netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
 {
+  __A_VARIABLE = 1;
   return netconn_close_shutdown(conn, (u8_t)((shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0)));
 }
 
@@ -1209,6 +1240,7 @@ netconn_join_leave_group(struct netconn *conn,
   err = netconn_apimsg(lwip_netconn_do_join_leave_group, &API_MSG_VAR_REF(msg));
   API_MSG_VAR_FREE(msg);
 
+  __A_VARIABLE = 1;
   return err;
 }
 /**
@@ -1353,6 +1385,7 @@ netconn_thread_init(void)
     LWIP_NETCONN_THREAD_SEM_ALLOC();
     LWIP_ASSERT("LWIP_NETCONN_THREAD_SEM_ALLOC() failed", sys_sem_valid(LWIP_NETCONN_THREAD_SEM_GET()));
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -1363,6 +1396,7 @@ netconn_thread_cleanup(void)
     /* call free only once */
     LWIP_NETCONN_THREAD_SEM_FREE();
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETCONN_SEM_PER_THREAD */
 
diff --git a/src/api/api_msg.c b/src/api/api_msg.c
index 7dbb3d4..f9f8bfb 100644
--- a/src/api/api_msg.c
+++ b/src/api/api_msg.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Sequential API Internal module
@@ -99,8 +101,10 @@ int
 lwip_netconn_is_deallocated_msg(void *msg)
 {
   if (msg == &netconn_deleted) {
+    __A_VARIABLE = 1;
     return 1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* LWIP_NETCONN_FULLDUPLEX */
@@ -116,13 +120,17 @@ lwip_netconn_err_to_msg(err_t err)
 {
   switch (err) {
     case ERR_ABRT:
+      __A_VARIABLE = 1;
       return LWIP_CONST_CAST(void *, &netconn_aborted);
     case ERR_RST:
+      __A_VARIABLE = 1;
       return LWIP_CONST_CAST(void *, &netconn_reset);
     case ERR_CLSD:
+      __A_VARIABLE = 1;
       return LWIP_CONST_CAST(void *, &netconn_closed);
     default:
       LWIP_ASSERT("unhandled error", err == ERR_OK);
+      __A_VARIABLE = 1;
       return NULL;
   }
 }
@@ -384,6 +392,7 @@ poll_tcp(void *arg, struct tcp_pcb *pcb)
     }
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -418,6 +427,7 @@ sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
     }
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -502,6 +512,7 @@ err_tcp(void *arg, err_t err)
   } else {
     LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -663,11 +674,13 @@ pcb_new(struct api_msg *msg)
     default:
       /* Unsupported netconn type, e.g. protocol disabled */
       msg->err = ERR_VAL;
+      __A_VARIABLE = 1;
       return;
   }
   if (msg->conn->pcb.ip == NULL) {
     msg->err = ERR_MEM;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -690,6 +703,7 @@ lwip_netconn_do_newconn(void *m)
   /* We currently just are happy and return. */
 
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 #include <flexos/isolation.h>
@@ -713,6 +727,7 @@ netconn_alloc(enum netconn_type t, netconn_callback callback)
   //conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
   conn = (struct netconn *)flexos_calloc_whitelist(1, sizeof(struct netconn));
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -781,9 +796,11 @@ netconn_alloc(enum netconn_type t, netconn_callback callback)
   conn->linger = -1;
 #endif /* LWIP_SO_LINGER */
   conn->flags = init_flags;
+  __A_VARIABLE = 1;
   return conn;
 free_and_return:
   flexos_free_whitelist(conn);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -816,6 +833,7 @@ netconn_free(struct netconn *conn)
 #endif
 
   flexos_free_whitelist(conn);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -888,6 +906,7 @@ netconn_drain(struct netconn *conn)
     sys_mbox_set_invalid(&conn->acceptmbox);
   }
 #endif /* LWIP_TCP */
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_NETCONN_FULLDUPLEX
@@ -1247,6 +1266,7 @@ lwip_netconn_do_bind(void *m)
   }
   msg->err = err;
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 /**
  * Bind a pcb contained in a netconn to an interface
@@ -1291,6 +1311,7 @@ lwip_netconn_do_bind_if(void *m)
   }
   msg->err = err;
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_TCP
@@ -1312,6 +1333,7 @@ lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
   conn = (struct netconn *)arg;
 
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1338,6 +1360,7 @@ lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
   if (was_blocking) {
     sys_sem_signal(op_completed_sem);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_TCP */
@@ -1439,6 +1462,7 @@ lwip_netconn_do_disconnect(void *m)
     msg->err = ERR_VAL;
   }
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_TCP
@@ -1522,6 +1546,7 @@ lwip_netconn_do_listen(void *m)
   }
   msg->err = err;
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_TCP */
 
@@ -1579,6 +1604,7 @@ lwip_netconn_do_send(void *m)
   }
   msg->err = err;
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_TCP
@@ -1605,6 +1631,7 @@ lwip_netconn_do_recv(void *m)
     }
   }
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 #if TCP_LISTEN_BACKLOG
@@ -1625,6 +1652,7 @@ lwip_netconn_do_accepted(void *m)
     }
   }
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_LISTEN_BACKLOG */
 
@@ -1924,6 +1952,7 @@ lwip_netconn_do_getaddr(void *m)
     msg->err = ERR_CONN;
   }
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2052,6 +2081,7 @@ lwip_netconn_do_join_leave_group(void *m)
     }
   }
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 /**
  * Join multicast groups for UDP netconns.
@@ -2107,6 +2137,7 @@ lwip_netconn_do_join_leave_group_netif(void *m)
 
 done:
   TCPIP_APIMSG_ACK(msg);
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
 
@@ -2134,6 +2165,7 @@ lwip_netconn_do_dns_found(const char *name, const ip_addr_t *ipaddr, void *arg)
   }
   /* wake up the application task waiting in netconn_gethostbyname */
   sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2170,6 +2202,7 @@ lwip_netconn_do_gethostbyname(void *arg)
     sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
   }
 #endif /* LWIP_TCPIP_CORE_LOCKING */
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_DNS */
 
diff --git a/src/api/err.c b/src/api/err.c
index f2d7180..e877e89 100644
--- a/src/api/err.c
+++ b/src/api/err.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Error Management module
@@ -69,8 +71,10 @@ int
 err_to_errno(err_t err)
 {
   if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_to_errno_table))) {
+    __A_VARIABLE = 1;
     return EIO;
   }
+  __A_VARIABLE = 1;
   return err_to_errno_table[-err];
 }
 #endif /* !NO_SYS */
@@ -107,8 +111,10 @@ const char *
 lwip_strerr(err_t err)
 {
   if ((err > 0) || (-err >= (err_t)LWIP_ARRAYSIZE(err_strerr))) {
+    __A_VARIABLE = 1;
     return "Unknown error.";
   }
+  __A_VARIABLE = 1;
   return err_strerr[-err];
 }
 
diff --git a/src/api/if_api.c b/src/api/if_api.c
index 2eda9f0..e801e44 100644
--- a/src/api/if_api.c
+++ b/src/api/if_api.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Interface Identification APIs from:
diff --git a/src/api/netbuf.c b/src/api/netbuf.c
index b464440..921292c 100644
--- a/src/api/netbuf.c
+++ b/src/api/netbuf.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Network buffer management
@@ -68,6 +70,7 @@ netbuf *netbuf_new(void)
   if (buf != NULL) {
     memset(buf, 0, sizeof(struct netbuf));
   }
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -87,6 +90,7 @@ netbuf_delete(struct netbuf *buf)
     }
     memp_free(MEMP_NETBUF, buf);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -109,11 +113,13 @@ netbuf_alloc(struct netbuf *buf, u16_t size)
   }
   buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
   if (buf->p == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   LWIP_ASSERT("check that first pbuf can hold size",
               (buf->p->len >= size));
   buf->ptr = buf->p;
+  __A_VARIABLE = 1;
   return buf->p->payload;
 }
 
@@ -135,6 +141,7 @@ netbuf_free(struct netbuf *buf)
   buf->flags = 0;
   buf->toport_chksum = 0;
 #endif /* LWIP_CHECKSUM_ON_COPY */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -157,11 +164,13 @@ netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
   buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
   if (buf->p == NULL) {
     buf->ptr = NULL;
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   ((struct pbuf_rom *)buf->p)->payload = dataptr;
   buf->p->len = buf->p->tot_len = size;
   buf->ptr = buf->p;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -180,6 +189,7 @@ netbuf_chain(struct netbuf *head, struct netbuf *tail)
   pbuf_cat(head->p, tail->p);
   head->ptr = head->p;
   memp_free(MEMP_NETBUF, tail);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -200,10 +210,12 @@ netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
   LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 
   if (buf->ptr == NULL) {
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
   *dataptr = buf->ptr->payload;
   *len = buf->ptr->len;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -223,12 +235,15 @@ netbuf_next(struct netbuf *buf)
 {
   LWIP_ERROR("netbuf_next: invalid buf", (buf != NULL), return -1;);
   if (buf->ptr->next == NULL) {
+    __A_VARIABLE = 1;
     return -1;
   }
   buf->ptr = buf->ptr->next;
   if (buf->ptr->next == NULL) {
+    __A_VARIABLE = 1;
     return 1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -245,6 +260,7 @@ netbuf_first(struct netbuf *buf)
 {
   LWIP_ERROR("netbuf_first: invalid buf", (buf != NULL), return;);
   buf->ptr = buf->p;
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_NETCONN */
diff --git a/src/api/netdb.c b/src/api/netdb.c
index a37178a..41e2d6a 100644
--- a/src/api/netdb.c
+++ b/src/api/netdb.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * API functions for name resolving
@@ -177,6 +179,7 @@ lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
   if (result == NULL) {
     /* not all arguments given */
     *h_errnop = EINVAL;
+    __A_VARIABLE = 1;
     return -1;
   }
   /* first thing to do: set *result to nothing */
@@ -184,6 +187,7 @@ lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
   if ((name == NULL) || (ret == NULL) || (buf == NULL)) {
     /* not all arguments given */
     *h_errnop = EINVAL;
+    __A_VARIABLE = 1;
     return -1;
   }
 
@@ -191,6 +195,7 @@ lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
   if (buflen < (sizeof(struct gethostbyname_r_helper) + LWIP_MEM_ALIGN_BUFFER(namelen + 1))) {
     /* buf can't hold the data needed + a copy of name */
     *h_errnop = ERANGE;
+    __A_VARIABLE = 1;
     return -1;
   }
 
@@ -202,6 +207,7 @@ lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
   if (err != ERR_OK) {
     LWIP_DEBUGF(DNS_DEBUG, ("lwip_gethostbyname(%s) failed, err=%d\n", name, err));
     *h_errnop = HOST_NOT_FOUND;
+    __A_VARIABLE = 1;
     return -1;
   }
 
@@ -223,6 +229,7 @@ lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
   *result = ret;
 
   /* return success */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -243,6 +250,7 @@ lwip_freeaddrinfo(struct addrinfo *ai)
     flexos_free_whitelist(ai);
     ai = next;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
diff --git a/src/api/netifapi.c b/src/api/netifapi.c
index 7c2011f..0eb8ac7 100644
--- a/src/api/netifapi.c
+++ b/src/api/netifapi.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Network Interface Sequential API module
@@ -94,6 +96,7 @@ netifapi_do_netif_set_addr(struct tcpip_api_call_data *m)
                   API_EXPR_REF(msg->msg.add.ipaddr),
                   API_EXPR_REF(msg->msg.add.netmask),
                   API_EXPR_REF(msg->msg.add.gw));
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_IPV4 */
@@ -109,6 +112,7 @@ netifapi_do_name_to_index(struct tcpip_api_call_data *m)
   struct netifapi_msg *msg = (struct netifapi_msg *)(void *)m;
 
   msg->msg.ifs.index = netif_name_to_index(msg->msg.ifs.name);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -126,6 +130,7 @@ netifapi_do_index_to_name(struct tcpip_api_call_data *m)
     /* return failure via empty name */
     msg->msg.ifs.name[0] = '\0';
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -178,6 +183,7 @@ netifapi_arp_add(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, enum netifa
   err = ERR_VAL;
 #endif /* ETHARP_SUPPORT_STATIC_ENTRIES && LWIP_TCPIP_CORE_LOCKING */
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -207,6 +213,7 @@ netifapi_arp_remove(const ip4_addr_t *ipaddr, enum netifapi_arp_entry type)
   err = ERR_VAL;
 #endif /* ETHARP_SUPPORT_STATIC_ENTRIES && LWIP_TCPIP_CORE_LOCKING */
 
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* LWIP_ARP && LWIP_IPV4 */
@@ -252,6 +259,7 @@ netifapi_netif_add(struct netif *netif,
   NETIFAPI_VAR_REF(msg).msg.add.input   = input;
   err = tcpip_api_call(netifapi_do_netif_add, &API_VAR_REF(msg).call);
   NETIFAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -289,6 +297,7 @@ netifapi_netif_set_addr(struct netif *netif,
   NETIFAPI_VAR_REF(msg).msg.add.gw      = NETIFAPI_VAR_REF(gw);
   err = tcpip_api_call(netifapi_do_netif_set_addr, &API_VAR_REF(msg).call);
   NETIFAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* LWIP_IPV4 */
@@ -312,6 +321,7 @@ netifapi_netif_common(struct netif *netif, netifapi_void_fn voidfunc,
   NETIFAPI_VAR_REF(msg).msg.common.errtfunc = errtfunc;
   err = tcpip_api_call(netifapi_do_netif_common, &API_VAR_REF(msg).call);
   NETIFAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -343,6 +353,7 @@ netifapi_netif_name_to_index(const char *name, u8_t *idx)
     *idx = NETIFAPI_VAR_REF(msg).msg.ifs.index;
   }
   NETIFAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -374,6 +385,7 @@ netifapi_netif_index_to_name(u8_t idx, char *name)
   }
 #endif /* LWIP_MPU_COMPATIBLE */
   NETIFAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
diff --git a/src/api/tcpip.c b/src/api/tcpip.c
index 05d809a..33cd420 100644
--- a/src/api/tcpip.c
+++ b/src/api/tcpip.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Sequential API Main thread module
@@ -151,6 +153,7 @@ _tcpip_thread(void *arg)
     }
     tcpip_thread_handle_msg(msg);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -160,6 +163,7 @@ tcpip_thread(void *arg)
   wrpkru(0x3ffffffc); /* EVIL HACK THIS SHOULD ALREADY BE SET */
 #endif
   _tcpip_thread(arg);
+  __A_VARIABLE = 1;
 }
 
 /* Handle a single tcpip_msg
@@ -220,6 +224,7 @@ tcpip_thread_handle_msg(struct tcpip_msg *msg)
       LWIP_ASSERT("tcpip_thread: invalid message", 0);
       break;
   }
+  __A_VARIABLE = 1;
 }
 
 #ifdef TCPIP_THREAD_TEST
@@ -238,6 +243,7 @@ tcpip_thread_poll_one(void)
     }
     UNLOCK_TCPIP_CORE();
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 #endif
@@ -327,6 +333,7 @@ tcpip_callback(tcpip_callback_fn function, void *ctx)
 
   msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   if (msg == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -335,6 +342,7 @@ tcpip_callback(tcpip_callback_fn function, void *ctx)
   msg->msg.cb.ctx = ctx;
 
   sys_mbox_post(&tcpip_mbox, msg);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -363,6 +371,7 @@ tcpip_try_callback(tcpip_callback_fn function, void *ctx)
 
   msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   if (msg == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -372,8 +381,10 @@ tcpip_try_callback(tcpip_callback_fn function, void *ctx)
 
   if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
     memp_free(MEMP_TCPIP_MSG_API, msg);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -395,6 +406,7 @@ tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
 
   msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   if (msg == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -403,6 +415,7 @@ tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
   msg->msg.tmo.h = h;
   msg->msg.tmo.arg = arg;
   sys_mbox_post(&tcpip_mbox, msg);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -422,6 +435,7 @@ tcpip_untimeout(sys_timeout_handler h, void *arg)
 
   msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   if (msg == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -429,6 +443,7 @@ tcpip_untimeout(sys_timeout_handler h, void *arg)
   msg->msg.tmo.h = h;
   msg->msg.tmo.arg = arg;
   sys_mbox_post(&tcpip_mbox, msg);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
@@ -545,11 +560,13 @@ tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
 {
   struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   if (msg == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   msg->type = TCPIP_MSG_CALLBACK_STATIC;
   msg->msg.cb.function = function;
   msg->msg.cb.ctx = ctx;
+  __A_VARIABLE = 1;
   return (struct tcpip_callback_msg *)msg;
 }
 
@@ -565,6 +582,7 @@ void
 tcpip_callbackmsg_delete(struct tcpip_callback_msg *msg)
 {
   memp_free(MEMP_TCPIP_MSG_API, msg);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -580,6 +598,7 @@ err_t
 tcpip_callbackmsg_trycallback(struct tcpip_callback_msg *msg)
 {
   LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
+  __A_VARIABLE = 1;
   return sys_mbox_trypost(&tcpip_mbox, msg);
 }
 
@@ -599,6 +618,7 @@ err_t
 tcpip_callbackmsg_trycallback_fromisr(struct tcpip_callback_msg *msg)
 {
   LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));
+  __A_VARIABLE = 1;
   return sys_mbox_trypost_fromisr(&tcpip_mbox, msg);
 }
 
@@ -628,6 +648,7 @@ tcpip_init(tcpip_init_done_fn initfunc, void *arg)
 #endif /* LWIP_TCPIP_CORE_LOCKING */
 
   sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -641,6 +662,7 @@ pbuf_free_int(void *p)
 {
   struct pbuf *q = (struct pbuf *)p;
   pbuf_free(q);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -652,6 +674,7 @@ pbuf_free_int(void *p)
 err_t
 pbuf_free_callback(struct pbuf *p)
 {
+  __A_VARIABLE = 1;
   return tcpip_try_callback(pbuf_free_int, p);
 }
 
@@ -665,6 +688,7 @@ pbuf_free_callback(struct pbuf *p)
 err_t
 mem_free_callback(void *m)
 {
+  __A_VARIABLE = 1;
   return tcpip_try_callback(mem_free, m);
 }
 
diff --git a/src/apps/altcp_tls/altcp_tls_mbedtls.c b/src/apps/altcp_tls/altcp_tls_mbedtls.c
index e629695..9049c56 100644
--- a/src/apps/altcp_tls/altcp_tls_mbedtls.c
+++ b/src/apps/altcp_tls/altcp_tls_mbedtls.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Application layered TCP/TLS connection API (to be used from TCPIP thread)
@@ -132,15 +134,19 @@ altcp_mbedtls_lower_accept(void *arg, struct altcp_pcb *accepted_conn, err_t err
     /* create a new altcp_conn to pass to the next 'accept' callback */
     struct altcp_pcb *new_conn = altcp_alloc();
     if (new_conn == NULL) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
     setup_err = altcp_mbedtls_setup(listen_state->conf, new_conn, accepted_conn);
     if (setup_err != ERR_OK) {
       altcp_free(new_conn);
+      __A_VARIABLE = 1;
       return setup_err;
     }
+    __A_VARIABLE = 1;
     return listen_conn->accept(listen_conn->arg, new_conn, err);
   }
+  __A_VARIABLE = 1;
   return ERR_ARG;
 }
 
@@ -157,11 +163,14 @@ altcp_mbedtls_lower_connected(void *arg, struct altcp_pcb *inner_conn, err_t err
     /* upper connected is called when handshake is done */
     if (err != ERR_OK) {
       if (conn->connected) {
+        __A_VARIABLE = 1;
         return conn->connected(conn->arg, conn, err);
       }
     }
+    __A_VARIABLE = 1;
     return altcp_mbedtls_lower_recv_process(conn, (altcp_mbedtls_state_t *)conn->state);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -174,6 +183,7 @@ altcp_mbedtls_lower_recved(struct altcp_pcb *inner_conn, int recvd_cnt)
     altcp_recved(inner_conn, recvd_part);
     recvd_cnt -= recvd_part;
   }
+  __A_VARIABLE = 1;
 }
 
 /** Recv callback from lower connection (i.e. TCP)
@@ -263,6 +273,7 @@ altcp_mbedtls_lower_recv_process(struct altcp_pcb *conn, altcp_mbedtls_state_t *
     if (ret == MBEDTLS_ERR_SSL_WANT_READ || ret == MBEDTLS_ERR_SSL_WANT_WRITE) {
       /* handshake not done, wait for more recv calls */
       LWIP_ASSERT("in this state, the rx chain should be empty", state->rx == NULL);
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
     if (ret != 0) {
@@ -275,6 +286,7 @@ altcp_mbedtls_lower_recv_process(struct altcp_pcb *conn, altcp_mbedtls_state_t *
       if (altcp_close(conn) != ERR_OK) {
         altcp_abort(conn);
       }
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
     /* If we come here, handshake succeeded. */
@@ -286,14 +298,17 @@ altcp_mbedtls_lower_recv_process(struct altcp_pcb *conn, altcp_mbedtls_state_t *
       err_t err;
       err = conn->connected(conn->arg, conn, ERR_OK);
       if (err != ERR_OK) {
+        __A_VARIABLE = 1;
         return err;
       }
     }
     if (state->rx == NULL) {
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
   /* handle application data */
+  __A_VARIABLE = 1;
   return altcp_mbedtls_handle_rx_appldata(conn, state);
 }
 
@@ -446,6 +461,7 @@ altcp_mbedtls_bio_recv(void *ctx, unsigned char *buf, size_t len)
 
   LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
   if ((conn == NULL) || (conn->state == NULL)) {
+    __A_VARIABLE = 1;
     return MBEDTLS_ERR_NET_INVALID_CONTEXT;
   }
   state = (altcp_mbedtls_state_t *)conn->state;
@@ -461,8 +477,10 @@ altcp_mbedtls_bio_recv(void *ctx, unsigned char *buf, size_t len)
     if ((state->flags & (ALTCP_MBEDTLS_FLAGS_RX_CLOSE_QUEUED | ALTCP_MBEDTLS_FLAGS_RX_CLOSED)) ==
         ALTCP_MBEDTLS_FLAGS_RX_CLOSE_QUEUED) {
       /* close queued but not passed up yet */
+      __A_VARIABLE = 1;
       return 0;
     }
+    __A_VARIABLE = 1;
     return MBEDTLS_ERR_SSL_WANT_READ;
   }
   /* limit number of bytes again to copy from first pbuf in a chain only */
@@ -481,6 +499,7 @@ altcp_mbedtls_bio_recv(void *ctx, unsigned char *buf, size_t len)
   }
 
   state->bio_bytes_read += (int)ret;
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -499,15 +518,18 @@ altcp_mbedtls_lower_sent(void *arg, struct altcp_pcb *inner_conn, u16_t len)
     LWIP_ASSERT("pcb mismatch", conn->inner_conn == inner_conn);
     if (!state || !(state->flags & ALTCP_MBEDTLS_FLAGS_HANDSHAKE_DONE)) {
       /* @todo: do something here? */
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
     /* try to send more if we failed before */
     mbedtls_ssl_flush_output(&state->ssl_context);
     /* call upper sent with len==0 if the application already sent data */
     if ((state->flags & ALTCP_MBEDTLS_FLAGS_APPLDATA_SENT) && conn->sent) {
+      __A_VARIABLE = 1;
       return conn->sent(conn->arg, conn, 0);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -528,13 +550,16 @@ altcp_mbedtls_lower_poll(void *arg, struct altcp_pcb *inner_conn)
       /* try to send more if we failed before */
       mbedtls_ssl_flush_output(&state->ssl_context);
       if (altcp_mbedtls_handle_rx_appldata(conn, state) == ERR_ABRT) {
+        __A_VARIABLE = 1;
         return ERR_ABRT;
       }
     }
     if (conn->poll) {
+      __A_VARIABLE = 1;
       return conn->poll(conn->arg, conn);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -549,6 +574,7 @@ altcp_mbedtls_lower_err(void *arg, err_t err)
     }
     altcp_free(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 /* setup functions */
@@ -561,6 +587,7 @@ altcp_mbedtls_remove_callbacks(struct altcp_pcb *inner_conn)
   altcp_sent(inner_conn, NULL);
   altcp_err(inner_conn, NULL);
   altcp_poll(inner_conn, NULL, inner_conn->pollinterval);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -572,6 +599,7 @@ altcp_mbedtls_setup_callbacks(struct altcp_pcb *conn, struct altcp_pcb *inner_co
   altcp_err(inner_conn, altcp_mbedtls_lower_err);
   /* tcp_poll is set when interval is set by application */
   /* listen is set totally different :-) */
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -581,6 +609,7 @@ altcp_mbedtls_setup(void *conf, struct altcp_pcb *conn, struct altcp_pcb *inner_
   struct altcp_tls_config *config = (struct altcp_tls_config *)conf;
   altcp_mbedtls_state_t *state;
   if (!conf) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   LWIP_ASSERT("invalid inner_conn", conn != inner_conn);
@@ -588,6 +617,7 @@ altcp_mbedtls_setup(void *conf, struct altcp_pcb *conn, struct altcp_pcb *inner_
   /* allocate mbedtls context */
   state = altcp_mbedtls_alloc(conf);
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   /* initialize mbedtls context: */
@@ -597,6 +627,7 @@ altcp_mbedtls_setup(void *conf, struct altcp_pcb *conn, struct altcp_pcb *inner_
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_setup failed\n"));
     /* @todo: convert 'ret' to err_t */
     altcp_mbedtls_free(conf, state);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   /* tell mbedtls about our I/O functions */
@@ -606,6 +637,7 @@ altcp_mbedtls_setup(void *conf, struct altcp_pcb *conn, struct altcp_pcb *inner_
   conn->inner_conn = inner_conn;
   conn->fns = &altcp_mbedtls_functions;
   conn->state = state;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -614,15 +646,18 @@ altcp_tls_wrap(struct altcp_tls_config *config, struct altcp_pcb *inner_pcb)
 {
   struct altcp_pcb *ret;
   if (inner_pcb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = altcp_alloc();
   if (ret != NULL) {
     if (altcp_mbedtls_setup(config, ret, inner_pcb) != ERR_OK) {
       altcp_free(ret);
+      __A_VARIABLE = 1;
       return NULL;
     }
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -631,8 +666,10 @@ altcp_tls_context(struct altcp_pcb *conn)
 {
   if (conn && conn->state) {
     altcp_mbedtls_state_t *state = (altcp_mbedtls_state_t *)conn->state;
+    __A_VARIABLE = 1;
     return &state->ssl_context;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -647,6 +684,7 @@ altcp_mbedtls_debug(void *ctx, int level, const char *file, int line, const char
   LWIP_UNUSED_ARG(str);
 
   LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("%s:%04d: %s", file, line, str));
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -661,6 +699,7 @@ dummy_rng(void *ctx, unsigned char *buffer, size_t len)
   for (i = 0; i < len; i++) {
     buffer[i] = (unsigned char)++ctr;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 #define ALTCP_MBEDTLS_RNG_FN dummy_rng
@@ -697,6 +736,7 @@ altcp_tls_create_config(int is_server, int have_cert, int have_pkey, int have_ca
 
   conf = (struct altcp_tls_config *)altcp_mbedtls_alloc_config(sz);
   if (conf == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   mem = (mbedtls_x509_crt *)(conf + 1);
@@ -721,6 +761,7 @@ altcp_tls_create_config(int is_server, int have_cert, int have_pkey, int have_ca
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ctr_drbg_seed failed: %d\n", ret));
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -730,6 +771,7 @@ altcp_tls_create_config(int is_server, int have_cert, int have_pkey, int have_ca
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_config_defaults failed: %d\n", ret));
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
   mbedtls_ssl_conf_authmode(&conf->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
@@ -744,6 +786,7 @@ altcp_tls_create_config(int is_server, int have_cert, int have_pkey, int have_ca
   mbedtls_ssl_cache_set_max_entries(&conf->cache, 30);
 #endif
 
+  __A_VARIABLE = 1;
   return conf;
 }
 
@@ -761,6 +804,7 @@ altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_
   mbedtls_pk_context *pkey;
   struct altcp_tls_config *conf = altcp_tls_create_config(1, 1, 1, 0);
   if (conf == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -775,6 +819,7 @@ altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_x509_crt_parse failed: %d\n", ret));
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -783,6 +828,7 @@ altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_pk_parse_public_key failed: %d\n", ret));
     mbedtls_x509_crt_free(srvcert);
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -793,8 +839,10 @@ altcp_tls_create_config_server_privkey_cert(const u8_t *privkey, size_t privkey_
     mbedtls_x509_crt_free(srvcert);
     mbedtls_pk_free(pkey);
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
+  __A_VARIABLE = 1;
   return conf;
 }
 
@@ -804,6 +852,7 @@ altcp_tls_create_config_client_common(const u8_t *ca, size_t ca_len, int is_2way
   int ret;
   struct altcp_tls_config *conf = altcp_tls_create_config(0, is_2wayauth, is_2wayauth, ca != NULL);
   if (conf == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -816,17 +865,20 @@ altcp_tls_create_config_client_common(const u8_t *ca, size_t ca_len, int is_2way
     if (ret != 0) {
       LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_x509_crt_parse ca failed: %d 0x%x", ret, -1*ret));
       altcp_mbedtls_free_config(conf);
+      __A_VARIABLE = 1;
       return NULL;
     }
 
     mbedtls_ssl_conf_ca_chain(&conf->conf, conf->ca, NULL);
   }
+  __A_VARIABLE = 1;
   return conf;
 }
 
 struct altcp_tls_config *
 altcp_tls_create_config_client(const u8_t *ca, size_t ca_len)
 {
+  __A_VARIABLE = 1;
   return altcp_tls_create_config_client_common(ca, ca_len, 0);
 }
 
@@ -840,11 +892,13 @@ altcp_tls_create_config_client_2wayauth(const u8_t *ca, size_t ca_len, const u8_
 
   if (!cert || !privkey) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("altcp_tls_create_config_client_2wayauth: certificate and priv key required"));
+    __A_VARIABLE = 1;
     return NULL;
   }
 
   conf = altcp_tls_create_config_client_common(ca, ca_len, 1);
   if (conf == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -854,6 +908,7 @@ altcp_tls_create_config_client_2wayauth(const u8_t *ca, size_t ca_len, const u8_
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_x509_crt_parse cert failed: %d 0x%x", ret, -1*ret));
     altcp_mbedtls_free_config(conf->cert);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -862,6 +917,7 @@ altcp_tls_create_config_client_2wayauth(const u8_t *ca, size_t ca_len, const u8_
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_pk_parse_key failed: %d 0x%x", ret, -1*ret));
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -869,9 +925,11 @@ altcp_tls_create_config_client_2wayauth(const u8_t *ca, size_t ca_len, const u8_
   if (ret != 0) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_DEBUG, ("mbedtls_ssl_conf_own_cert failed: %d 0x%x", ret, -1*ret));
     altcp_mbedtls_free_config(conf);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
+  __A_VARIABLE = 1;
   return conf;
 }
 
@@ -888,6 +946,7 @@ altcp_tls_free_config(struct altcp_tls_config *conf)
     mbedtls_x509_crt_free(conf->ca);
   }  
   altcp_mbedtls_free_config(conf);
+  __A_VARIABLE = 1;
 }
 
 /* "virtual" functions */
@@ -897,6 +956,7 @@ altcp_mbedtls_set_poll(struct altcp_pcb *conn, u8_t interval)
   if (conn != NULL) {
     altcp_poll(conn->inner_conn, altcp_mbedtls_lower_poll, interval);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -905,13 +965,16 @@ altcp_mbedtls_recved(struct altcp_pcb *conn, u16_t len)
   u16_t lower_recved;
   altcp_mbedtls_state_t *state;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
   state = (altcp_mbedtls_state_t *)conn->state;
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
   if (!(state->flags & ALTCP_MBEDTLS_FLAGS_HANDSHAKE_DONE)) {
+    __A_VARIABLE = 1;
     return;
   }
   lower_recved = len;
@@ -923,15 +986,18 @@ altcp_mbedtls_recved(struct altcp_pcb *conn, u16_t len)
   state->rx_passed_unrecved -= lower_recved;
 
   altcp_recved(conn->inner_conn, lower_recved);
+  __A_VARIABLE = 1;
 }
 
 static err_t
 altcp_mbedtls_connect(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port, altcp_connected_fn connected)
 {
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   conn->connected = connected;
+  __A_VARIABLE = 1;
   return altcp_connect(conn->inner_conn, ipaddr, port, altcp_mbedtls_lower_connected);
 }
 
@@ -940,14 +1006,17 @@ altcp_mbedtls_listen(struct altcp_pcb *conn, u8_t backlog, err_t *err)
 {
   struct altcp_pcb *lpcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   lpcb = altcp_listen_with_backlog_and_err(conn->inner_conn, backlog, err);
   if (lpcb != NULL) {
     conn->inner_conn = lpcb;
     altcp_accept(lpcb, altcp_mbedtls_lower_accept);
+    __A_VARIABLE = 1;
     return conn;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -957,6 +1026,7 @@ altcp_mbedtls_abort(struct altcp_pcb *conn)
   if (conn != NULL) {
     altcp_abort(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -964,6 +1034,7 @@ altcp_mbedtls_close(struct altcp_pcb *conn)
 {
   struct altcp_pcb *inner_conn;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   inner_conn = conn->inner_conn;
@@ -977,11 +1048,13 @@ altcp_mbedtls_close(struct altcp_pcb *conn)
       altcp_mbedtls_setup_callbacks(conn, inner_conn);
       /* poll callback is not included in the above */
       altcp_poll(inner_conn, oldpoll, inner_conn->pollinterval);
+      __A_VARIABLE = 1;
       return err;
     }
     conn->inner_conn = NULL;
   }
   altcp_free(conn);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -995,6 +1068,7 @@ altcp_mbedtls_sndbuf(struct altcp_pcb *conn)
     altcp_mbedtls_state_t *state;
     state = (altcp_mbedtls_state_t*)conn->state;
     if (!state || !(state->flags & ALTCP_MBEDTLS_FLAGS_HANDSHAKE_DONE)) {
+      __A_VARIABLE = 1;
       return 0;
     }
     if (conn->inner_conn) {
@@ -1015,12 +1089,14 @@ altcp_mbedtls_sndbuf(struct altcp_pcb *conn)
           /* Adjust sndbuf of inner_conn with what added by SSL */
           ret = LWIP_MIN(sndbuf - ssl_added, max_len);
           LWIP_ASSERT("sndbuf overflow", ret <= 0xFFFF);
+          __A_VARIABLE = 1;
           return (u16_t)ret;
         }
       }
     }
   }
   /* fallback: use sendbuf of the inner connection */
+  __A_VARIABLE = 1;
   return altcp_default_sndbuf(conn);
 }
 
@@ -1121,9 +1197,11 @@ static u16_t
 altcp_mbedtls_mss(struct altcp_pcb *conn)
 {
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   /* @todo: LWIP_MIN(mss, mbedtls_ssl_get_max_frag_len()) ? */
+  __A_VARIABLE = 1;
   return altcp_mss(conn->inner_conn);
 }
 
@@ -1145,6 +1223,7 @@ altcp_mbedtls_dealloc(struct altcp_pcb *conn)
       conn->state = NULL;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 const struct altcp_functions altcp_mbedtls_functions = {
diff --git a/src/apps/altcp_tls/altcp_tls_mbedtls_mem.c b/src/apps/altcp_tls/altcp_tls_mbedtls_mem.c
index 664347f..b0a21e2 100644
--- a/src/apps/altcp_tls/altcp_tls_mbedtls_mem.c
+++ b/src/apps/altcp_tls/altcp_tls_mbedtls_mem.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Application layered TCP connection API (to be used from TCPIP thread)
@@ -116,11 +118,13 @@ tls_malloc(size_t c, size_t len)
   if (alloc_size > MEM_SIZE) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_MEM_DEBUG, ("mbedtls allocation too big: %c * %d bytes vs MEM_SIZE=%d",
                                           (int)c, (int)len, (int)MEM_SIZE));
+    __A_VARIABLE = 1;
     return NULL;
   }
   hlpr = (altcp_mbedtls_malloc_helper_t *)mem_malloc((mem_size_t)alloc_size);
   if (hlpr == NULL) {
     LWIP_DEBUGF(ALTCP_MBEDTLS_MEM_DEBUG, ("mbedtls alloc callback failed for %c * %d bytes", (int)c, (int)len));
+    __A_VARIABLE = 1;
     return NULL;
   }
 #if ALTCP_MBEDTLS_PLATFORM_ALLOC_STATS
@@ -136,6 +140,7 @@ tls_malloc(size_t c, size_t len)
   ret = hlpr + 1;
   /* zeroing the allocated chunk is required by mbedTLS! */
   memset(ret, 0, c * len);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -145,6 +150,7 @@ tls_free(void *ptr)
   altcp_mbedtls_malloc_helper_t *hlpr;
   if (ptr == NULL) {
     /* this obviously happened in mbedtls... */
+    __A_VARIABLE = 1;
     return;
   }
   hlpr = ((altcp_mbedtls_malloc_helper_t *)ptr) - 1;
@@ -154,6 +160,7 @@ tls_free(void *ptr)
   }
 #endif
   mem_free(hlpr);
+  __A_VARIABLE = 1;
 }
 #endif /* ALTCP_MBEDTLS_PLATFORM_ALLOC*/
 
@@ -166,6 +173,7 @@ altcp_mbedtls_mem_init(void)
   /* set mbedtls allocation methods */
   mbedtls_platform_set_calloc_free(&tls_malloc, &tls_free);
 #endif
+  __A_VARIABLE = 1;
 }
 
 altcp_mbedtls_state_t *
@@ -175,6 +183,7 @@ altcp_mbedtls_alloc(void *conf)
   if (ret != NULL) {
     ret->conf = conf;
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -184,6 +193,7 @@ altcp_mbedtls_free(void *conf, altcp_mbedtls_state_t *state)
   LWIP_UNUSED_ARG(conf);
   LWIP_ASSERT("state != NULL", state != NULL);
   mem_free(state);
+  __A_VARIABLE = 1;
 }
 
 void *
@@ -193,9 +203,11 @@ altcp_mbedtls_alloc_config(size_t size)
   size_t checked_size = (mem_size_t)size;
   if (size != checked_size) {
     /* allocation too big (mem_size_t overflow) */
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = (altcp_mbedtls_state_t *)mem_calloc(1, (mem_size_t)size);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -204,6 +216,7 @@ altcp_mbedtls_free_config(void *item)
 {
   LWIP_ASSERT("item != NULL", item != NULL);
   mem_free(item);
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_ALTCP_TLS && LWIP_ALTCP_TLS_MBEDTLS */
diff --git a/src/apps/http/altcp_proxyconnect.c b/src/apps/http/altcp_proxyconnect.c
index 55d99c4..2c19438 100644
--- a/src/apps/http/altcp_proxyconnect.c
+++ b/src/apps/http/altcp_proxyconnect.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Application layered TCP connection API that executes a proxy-connect.
@@ -79,6 +81,7 @@ static altcp_proxyconnect_state_t *
 altcp_proxyconnect_state_alloc(void)
 {
   altcp_proxyconnect_state_t *ret = (altcp_proxyconnect_state_t *)mem_calloc(1, sizeof(altcp_proxyconnect_state_t));
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -87,6 +90,7 @@ altcp_proxyconnect_state_free(altcp_proxyconnect_state_t *state)
 {
   LWIP_ASSERT("state != NULL", state != NULL);
   mem_free(state);
+  __A_VARIABLE = 1;
 }
 
 /* helper functions */
@@ -102,6 +106,7 @@ altcp_proxyconnect_state_free(altcp_proxyconnect_state_t *state)
 static int
 altcp_proxyconnect_format_request(char *buffer, size_t bufsize, const char *host, int port)
 {
+  __A_VARIABLE = 1;
   return snprintf(buffer, bufsize, PROXY_CONNECT_FORMAT(host, port));
 }
 
@@ -115,11 +120,13 @@ altcp_proxyconnect_send_request(struct altcp_pcb *conn)
   altcp_proxyconnect_state_t *state = (altcp_proxyconnect_state_t *)conn->state;
 
   if (!state) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   /* Use printf with zero length to get the required allocation size */
   len = altcp_proxyconnect_format_request(NULL, 0, "", state->outer_port);
   if (len < 0) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   /* add allocation size for IP address strings */
@@ -131,11 +138,13 @@ altcp_proxyconnect_send_request(struct altcp_pcb *conn)
   alloc_len = (mem_size_t)len;
   if ((len < 0) || (int)alloc_len != len) {
     /* overflow */
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   /* Allocate a bufer for the request string */
   buffer = (char *)mem_malloc(alloc_len);
   if (buffer == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   host = ipaddr_ntoa(&state->outer_addr);
@@ -145,10 +154,12 @@ altcp_proxyconnect_send_request(struct altcp_pcb *conn)
     if (err != ERR_OK) {
       /* @todo: abort? */
       mem_free(buffer);
+      __A_VARIABLE = 1;
       return err;
     }
   }
   mem_free(buffer);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -168,14 +179,18 @@ altcp_proxyconnect_lower_connected(void *arg, struct altcp_pcb *inner_conn, err_
     if (err != ERR_OK) {
       if (conn->connected) {
         if (conn->connected(conn->arg, conn, err) == ERR_ABRT) {
+          __A_VARIABLE = 1;
           return ERR_ABRT;
         }
+        __A_VARIABLE = 1;
         return ERR_OK;
       }
     }
     /* send proxy connect request here */
+    __A_VARIABLE = 1;
     return altcp_proxyconnect_send_request(conn);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -258,13 +273,16 @@ altcp_proxyconnect_lower_sent(void *arg, struct altcp_pcb *inner_conn, u16_t len
     LWIP_UNUSED_ARG(inner_conn); /* for LWIP_NOASSERT */
     if (!state || !(state->flags & ALTCP_PROXYCONNECT_FLAGS_HANDSHAKE_DONE)) {
       /* @todo: do something here? */
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
     /* pass this on to upper sent */
     if (conn->sent) {
+      __A_VARIABLE = 1;
       return conn->sent(conn->arg, conn, len);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -280,9 +298,11 @@ altcp_proxyconnect_lower_poll(void *arg, struct altcp_pcb *inner_conn)
     LWIP_ASSERT("pcb mismatch", conn->inner_conn == inner_conn);
     LWIP_UNUSED_ARG(inner_conn); /* for LWIP_NOASSERT */
     if (conn->poll) {
+      __A_VARIABLE = 1;
       return conn->poll(conn->arg, conn);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -297,6 +317,7 @@ altcp_proxyconnect_lower_err(void *arg, err_t err)
     }
     altcp_free(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -311,6 +332,7 @@ altcp_proxyconnect_setup_callbacks(struct altcp_pcb *conn, struct altcp_pcb *inn
   altcp_err(inner_conn, altcp_proxyconnect_lower_err);
   /* tcp_poll is set when interval is set by application */
   /* listen is set totally different :-) */
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -318,6 +340,7 @@ altcp_proxyconnect_setup(struct altcp_proxyconnect_config *config, struct altcp_
 {
   altcp_proxyconnect_state_t *state;
   if (!config) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   LWIP_ASSERT("invalid inner_conn", conn != inner_conn);
@@ -325,6 +348,7 @@ altcp_proxyconnect_setup(struct altcp_proxyconnect_config *config, struct altcp_
   /* allocate proxyconnect context */
   state = altcp_proxyconnect_state_alloc();
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   state->flags = 0;
@@ -333,6 +357,7 @@ altcp_proxyconnect_setup(struct altcp_proxyconnect_config *config, struct altcp_
   conn->inner_conn = inner_conn;
   conn->fns = &altcp_proxyconnect_functions;
   conn->state = state;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -347,15 +372,18 @@ altcp_proxyconnect_new(struct altcp_proxyconnect_config *config, struct altcp_pc
 {
   struct altcp_pcb *ret;
   if (inner_pcb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = altcp_alloc();
   if (ret != NULL) {
     if (altcp_proxyconnect_setup(config, ret, inner_pcb) != ERR_OK) {
       altcp_free(ret);
+      __A_VARIABLE = 1;
       return NULL;
     }
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -374,12 +402,14 @@ altcp_proxyconnect_new_tcp(struct altcp_proxyconnect_config *config, u8_t ip_typ
   /* inner pcb is tcp */
   inner_pcb = altcp_tcp_new_ip_type(ip_type);
   if (inner_pcb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = altcp_proxyconnect_new(config, inner_pcb);
   if (ret == NULL) {
     altcp_close(inner_pcb);
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -396,6 +426,7 @@ altcp_proxyconnect_new_tcp(struct altcp_proxyconnect_config *config, u8_t ip_typ
 struct altcp_pcb *
 altcp_proxyconnect_alloc(void *arg, u8_t ip_type)
 {
+  __A_VARIABLE = 1;
   return altcp_proxyconnect_new_tcp((struct altcp_proxyconnect_config *)arg, ip_type);
 }
 
@@ -425,6 +456,7 @@ altcp_proxyconnect_tls_alloc(void *arg, u8_t ip_type)
   if (tls_pcb == NULL) {
     altcp_close(proxy_pcb);
   }
+  __A_VARIABLE = 1;
   return tls_pcb;
 }
 #endif /* LWIP_ALTCP_TLS */
@@ -436,6 +468,7 @@ altcp_proxyconnect_set_poll(struct altcp_pcb *conn, u8_t interval)
   if (conn != NULL) {
     altcp_poll(conn->inner_conn, altcp_proxyconnect_lower_poll, interval);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -443,16 +476,20 @@ altcp_proxyconnect_recved(struct altcp_pcb *conn, u16_t len)
 {
   altcp_proxyconnect_state_t *state;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
   state = (altcp_proxyconnect_state_t *)conn->state;
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
   if (!(state->flags & ALTCP_PROXYCONNECT_FLAGS_HANDSHAKE_DONE)) {
+    __A_VARIABLE = 1;
     return;
   }
   altcp_recved(conn->inner_conn, len);
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -461,13 +498,16 @@ altcp_proxyconnect_connect(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_
   altcp_proxyconnect_state_t *state;
 
   if ((conn == NULL) || (ipaddr == NULL)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   state = (altcp_proxyconnect_state_t *)conn->state;
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   if (state->flags & ALTCP_PROXYCONNECT_FLAGS_CONNECT_STARTED) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   state->flags |= ALTCP_PROXYCONNECT_FLAGS_CONNECT_STARTED;
@@ -477,6 +517,7 @@ altcp_proxyconnect_connect(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_
   ip_addr_copy(state->outer_addr, *ipaddr);
   state->outer_port = port;
 
+  __A_VARIABLE = 1;
   return altcp_connect(conn->inner_conn, &state->conf->proxy_addr, state->conf->proxy_port, altcp_proxyconnect_lower_connected);
 }
 
@@ -487,6 +528,7 @@ altcp_proxyconnect_listen(struct altcp_pcb *conn, u8_t backlog, err_t *err)
   LWIP_UNUSED_ARG(backlog);
   LWIP_UNUSED_ARG(err);
   /* listen not supported! */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -499,23 +541,27 @@ altcp_proxyconnect_abort(struct altcp_pcb *conn)
     }
     altcp_free(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t
 altcp_proxyconnect_close(struct altcp_pcb *conn)
 {
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   if (conn->inner_conn != NULL) {
     err_t err = altcp_close(conn->inner_conn);
     if (err != ERR_OK) {
       /* closing inner conn failed, return the error */
+      __A_VARIABLE = 1;
       return err;
     }
   }
   /* no inner conn or closing it succeeded, deallocate myself */
   altcp_free(conn);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -527,18 +573,22 @@ altcp_proxyconnect_write(struct altcp_pcb *conn, const void *dataptr, u16_t len,
   LWIP_UNUSED_ARG(apiflags);
 
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   state = (altcp_proxyconnect_state_t *)conn->state;
   if (state == NULL) {
     /* @todo: which error? */
+    __A_VARIABLE = 1;
     return ERR_CLSD;
   }
   if (!(state->flags & ALTCP_PROXYCONNECT_FLAGS_HANDSHAKE_DONE)) {
     /* @todo: which error? */
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
+  __A_VARIABLE = 1;
   return altcp_write(conn->inner_conn, dataptr, len, apiflags);
 }
 
@@ -553,6 +603,7 @@ altcp_proxyconnect_dealloc(struct altcp_pcb *conn)
       conn->state = NULL;
     }
   }
+  __A_VARIABLE = 1;
 }
 const struct altcp_functions altcp_proxyconnect_functions = {
   altcp_proxyconnect_set_poll,
diff --git a/src/apps/http/fs.c b/src/apps/http/fs.c
index c89b2ff..02a435b 100644
--- a/src/apps/http/fs.c
+++ b/src/apps/http/fs.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
  * All rights reserved.
@@ -104,6 +106,7 @@ fs_close(struct fs_file *file)
   fs_state_free(file, file->state);
 #endif /* #if LWIP_HTTPD_FILE_STATE */
   LWIP_UNUSED_ARG(file);
+  __A_VARIABLE = 1;
 }
 /*-----------------------------------------------------------------------------------*/
 #if LWIP_HTTPD_DYNAMIC_FILE_READ
@@ -170,5 +173,6 @@ fs_is_file_ready(struct fs_file *file, fs_wait_cb callback_fn, void *callback_ar
 int
 fs_bytes_left(struct fs_file *file)
 {
+  __A_VARIABLE = 1;
   return file->len - file->index;
 }
diff --git a/src/apps/http/fsdata.c b/src/apps/http/fsdata.c
index ba2a2cb..6dec87b 100644
--- a/src/apps/http/fsdata.c
+++ b/src/apps/http/fsdata.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "lwip/apps/fs.h"
 #include "lwip/def.h"
 
diff --git a/src/apps/http/http_client.c b/src/apps/http/http_client.c
index 6129cd5..33d3826 100644
--- a/src/apps/http/http_client.c
+++ b/src/apps/http/http_client.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * HTTP client
@@ -181,9 +183,11 @@ httpc_free_state(httpc_state_t* req)
     r = altcp_close(tpcb);
     if (r != ERR_OK) {
       altcp_abort(tpcb);
+      __A_VARIABLE = 1;
       return ERR_ABRT;
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -197,8 +201,10 @@ httpc_close(httpc_state_t* req, httpc_result_t result, u32_t server_response, er
         req->conn_settings->result_fn(req->callback_arg, result, req->rx_content_len, server_response, err);
       }
     }
+    __A_VARIABLE = 1;
     return httpc_free_state(req);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -234,12 +240,14 @@ http_parse_response_status(struct pbuf *p, u16_t *http_version, u16_t *http_stat
           int status = atoi(status_num);
           if ((status > 0) && (status <= 0xFFFF)) {
             *http_status = (u16_t)status;
+            __A_VARIABLE = 1;
             return ERR_OK;
           }
         }
       }
     }
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -270,8 +278,10 @@ http_wait_headers(struct pbuf *p, u32_t *content_length, u16_t *total_header_len
         }
       }
     }
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -358,6 +368,7 @@ httpc_tcp_err(void *arg, err_t err)
     req->pcb = NULL;
     httpc_close(req, HTTPC_RESULT_ERR_CLOSED, 0, err);
   }
+  __A_VARIABLE = 1;
 }
 
 /** http client tcp poll callback */
@@ -372,9 +383,11 @@ httpc_tcp_poll(void *arg, struct altcp_pcb *pcb)
       req->timeout_ticks--;
     }
     if (!req->timeout_ticks) {
+      __A_VARIABLE = 1;
       return httpc_close(req, HTTPC_RESULT_ERR_TIMEOUT, 0, ERR_OK);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -386,6 +399,7 @@ httpc_tcp_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
   LWIP_UNUSED_ARG(arg);
   LWIP_UNUSED_ARG(pcb);
   LWIP_UNUSED_ARG(len);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -402,6 +416,7 @@ httpc_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
   r = altcp_write(req->pcb, req->request->payload, req->request->len - 1, TCP_WRITE_FLAG_COPY);
   if (r != ERR_OK) {
      /* could not write the single small request -> fail, don't retry */
+     __A_VARIABLE = 1;
      return httpc_close(req, HTTPC_RESULT_ERR_MEM, 0, r);
   }
   /* everything written, we can free the request */
@@ -409,6 +424,7 @@ httpc_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
   req->request = NULL;
 
   altcp_output(req->pcb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -426,9 +442,11 @@ httpc_get_internal_addr(httpc_state_t* req, const ip_addr_t *ipaddr)
 
   err = altcp_connect(req->pcb, &req->remote_addr, req->remote_port, httpc_tcp_connected);
   if (err == ERR_OK) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
   LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("tcp_connect failed: %d\n", (int)err));
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -520,6 +538,7 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
   /* get request len */
   req_len = httpc_create_request_string(settings, server_name, server_port, uri, use_host, NULL, 0);
   if ((req_len < 0) || (req_len > 0xFFFF)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   /* alloc state and request in one block */
@@ -531,11 +550,13 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
 #endif
   mem_alloc_len = (mem_size_t)alloc_len;
   if ((mem_alloc_len < alloc_len) || (req_len + 1 > 0xFFFF)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   req = (httpc_state_t*)mem_malloc((mem_size_t)alloc_len);
   if(req == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(req, 0, sizeof(httpc_state_t));
@@ -543,11 +564,13 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
   req->request = pbuf_alloc(PBUF_RAW, (u16_t)(req_len + 1), PBUF_RAM);
   if (req->request == NULL) {
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   if (req->request->next != NULL) {
     /* need a pbuf in one piece */
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   req->hdr_content_len = HTTPC_CONTENT_LEN_INVALID;
@@ -562,6 +585,7 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
   req->pcb = altcp_new(settings->altcp_allocator);
   if(req->pcb == NULL) {
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   req->remote_port = settings->use_proxy ? settings->proxy_port : server_port;
@@ -576,6 +600,7 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
     (char *)req->request->payload, req_len + 1);
   if (req_len2 != req_len) {
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -584,6 +609,7 @@ httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_
   req->callback_arg = callback_arg;
 
   *connection = req;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -594,6 +620,7 @@ static err_t
 httpc_init_connection(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                       u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg)
 {
+  __A_VARIABLE = 1;
   return httpc_init_connection_common(connection, settings, server_name, server_port, uri, recv_fn, callback_arg, 1);
 }
 
@@ -608,8 +635,10 @@ httpc_init_connection_addr(httpc_state_t **connection, const httpc_connection_t
 {
   char *server_addr_str = ipaddr_ntoa(server_addr);
   if (server_addr_str == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
+  __A_VARIABLE = 1;
   return httpc_init_connection_common(connection, settings, server_addr_str, server_port, uri,
     recv_fn, callback_arg, 1);
 }
@@ -640,6 +669,7 @@ httpc_get_file(const ip_addr_t* server_addr, u16_t port, const char* uri, const
   err = httpc_init_connection_addr(&req, settings, server_addr, port,
     uri, recv_fn, callback_arg);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -650,12 +680,14 @@ httpc_get_file(const ip_addr_t* server_addr, u16_t port, const char* uri, const
   }
   if(err != ERR_OK) {
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return err;
   }
 
   if (connection != NULL) {
     *connection = req;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -684,6 +716,7 @@ httpc_get_file_dns(const char* server_name, u16_t port, const char* uri, const h
 
   err = httpc_init_connection(&req, settings, server_name, port, uri, recv_fn, callback_arg);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -694,12 +727,14 @@ httpc_get_file_dns(const char* server_name, u16_t port, const char* uri, const h
   }
   if(err != ERR_OK) {
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return err;
   }
 
   if (connection != NULL) {
     *connection = req;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -732,6 +767,7 @@ httpc_fs_init(httpc_filestate_t **filestate_out, const char* local_file_name,
 
   filestate = (httpc_filestate_t *)mem_malloc((mem_size_t)alloc_len);
   if (filestate == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(filestate, 0, sizeof(httpc_filestate_t));
@@ -748,10 +784,12 @@ httpc_fs_init(httpc_filestate_t **filestate_out, const char* local_file_name,
   if(f == NULL) {
     /* could not open file */
     mem_free(filestate);
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   filestate->file = f;
   *filestate_out = filestate;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -766,6 +804,7 @@ httpc_fs_free(httpc_filestate_t *filestate)
     }
     mem_free(filestate);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Connection closed (success or error) */
@@ -781,6 +820,7 @@ httpc_fs_result(void *arg, httpc_result_t httpc_result, u32_t rx_content_len,
     }
     httpc_fs_free(filestate);
   }
+  __A_VARIABLE = 1;
 }
 
 /** tcp recv callback */
@@ -798,6 +838,7 @@ httpc_fs_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t err)
   }
   altcp_recved(pcb, p->tot_len);
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -826,6 +867,7 @@ httpc_get_file_to_disk(const ip_addr_t* server_addr, u16_t port, const char* uri
 
   err = httpc_fs_init(&filestate, local_file_name, settings, callback_arg);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -833,6 +875,7 @@ httpc_get_file_to_disk(const ip_addr_t* server_addr, u16_t port, const char* uri
     uri, httpc_fs_tcp_recv, filestate);
   if (err != ERR_OK) {
     httpc_fs_free(filestate);
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -844,12 +887,14 @@ httpc_get_file_to_disk(const ip_addr_t* server_addr, u16_t port, const char* uri
   if(err != ERR_OK) {
     httpc_fs_free(filestate);
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return err;
   }
 
   if (connection != NULL) {
     *connection = req;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -878,6 +923,7 @@ httpc_get_file_dns_to_disk(const char* server_name, u16_t port, const char* uri,
 
   err = httpc_fs_init(&filestate, local_file_name, settings, callback_arg);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -885,6 +931,7 @@ httpc_get_file_dns_to_disk(const char* server_name, u16_t port, const char* uri,
     uri, httpc_fs_tcp_recv, filestate);
   if (err != ERR_OK) {
     httpc_fs_free(filestate);
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -896,12 +943,14 @@ httpc_get_file_dns_to_disk(const char* server_name, u16_t port, const char* uri,
   if(err != ERR_OK) {
     httpc_fs_free(filestate);
     httpc_free_state(req);
+    __A_VARIABLE = 1;
     return err;
   }
 
   if (connection != NULL) {
     *connection = req;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_HTTPC_HAVE_FILE_IO */
diff --git a/src/apps/http/httpd.c b/src/apps/http/httpd.c
index cbb0387..a702896 100644
--- a/src/apps/http/httpd.c
+++ b/src/apps/http/httpd.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * LWIP HTTP server implementation
@@ -356,6 +358,7 @@ http_add_connection(struct http_state *hs)
   /* add the connection to the list */
   hs->next = http_connections;
   http_connections = hs;
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -375,6 +378,7 @@ http_remove_connection(struct http_state *hs)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -404,6 +408,7 @@ http_kill_oldest_connection(u8_t ssi_required)
     /* send RST when killing a connection because of memory shortage */
     http_close_or_abort_conn(hs_free_next->next->pcb, hs_free_next->next, 1); /* this also unlinks the http_state from the list */
   }
+  __A_VARIABLE = 1;
 }
 #else /* LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED */
 
@@ -427,6 +432,7 @@ http_ssi_state_alloc(void)
   if (ret != NULL) {
     memset(ret, 0, sizeof(struct http_ssi_state));
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -437,6 +443,7 @@ http_ssi_state_free(struct http_ssi_state *ssi)
   if (ssi != NULL) {
     HTTP_FREE_SSI_STATE(ssi);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_SSI */
 
@@ -451,6 +458,7 @@ http_state_init(struct http_state *hs)
   /* Indicate that the headers are not yet valid */
   hs->hdr_index = NUM_FILE_HDR_STRINGS;
 #endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
+  __A_VARIABLE = 1;
 }
 
 /** Allocate a struct http_state. */
@@ -468,6 +476,7 @@ http_state_alloc(void)
     http_state_init(ret);
     http_add_connection(ret);
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -505,6 +514,7 @@ http_state_eof(struct http_state *hs)
     hs->req = NULL;
   }
 #endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
+  __A_VARIABLE = 1;
 }
 
 /** Free a struct http_state.
@@ -518,6 +528,7 @@ http_state_free(struct http_state *hs)
     http_remove_connection(hs);
     HTTP_FREE_HTTP_STATE(hs);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Call tcp_write() in a loop trying smaller and smaller length
@@ -537,6 +548,7 @@ http_write(struct altcp_pcb *pcb, const void *ptr, u16_t *length, u8_t apiflags)
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
   if (len == 0) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
   /* We cannot send more data than space available in the send buffer. */
@@ -582,6 +594,7 @@ http_write(struct altcp_pcb *pcb, const void *ptr, u16_t *length, u8_t apiflags)
   altcp_nagle_enable(pcb);
 #endif
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -624,6 +637,7 @@ http_close_or_abort_conn(struct altcp_pcb *pcb, struct http_state *hs, u8_t abor
 
   if (abort_conn) {
     altcp_abort(pcb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
   err = altcp_close(pcb);
@@ -632,6 +646,7 @@ http_close_or_abort_conn(struct altcp_pcb *pcb, struct http_state *hs, u8_t abor
     /* error closing, try again later in poll */
     altcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -645,6 +660,7 @@ http_close_or_abort_conn(struct altcp_pcb *pcb, struct http_state *hs, u8_t abor
 static err_t
 http_close_conn(struct altcp_pcb *pcb, struct http_state *hs)
 {
+  __A_VARIABLE = 1;
   return http_close_or_abort_conn(pcb, hs, 0);
 }
 
@@ -672,6 +688,7 @@ http_eof(struct altcp_pcb *pcb, struct http_state *hs)
   {
     http_close_conn(pcb, hs);
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI
@@ -695,6 +712,7 @@ extract_uri_parameters(struct http_state *hs, char *params)
 
   /* If we have no parameters at all, return immediately. */
   if (!params || (params[0] == '\0')) {
+    __A_VARIABLE = 1;
     return (0);
   }
 
@@ -740,6 +758,7 @@ extract_uri_parameters(struct http_state *hs, char *params)
     }
   }
 
+  __A_VARIABLE = 1;
   return loop;
 }
 #endif /* LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI */
@@ -807,6 +826,7 @@ get_tag_insert(struct http_state *hs)
         if (ssi->tag_insert_len != HTTPD_SSI_TAG_UNKNOWN)
 #endif /* LWIP_HTTPD_SSI_RAW */
         {
+          __A_VARIABLE = 1;
           return;
         }
       }
@@ -830,6 +850,7 @@ get_tag_insert(struct http_state *hs)
   len = strlen(ssi->tag_insert);
   LWIP_ASSERT("len <= 0xffff", len <= 0xffff);
   ssi->tag_insert_len = (u16_t)len;
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_SSI */
 
@@ -868,6 +889,7 @@ get_http_headers(struct http_state *hs, const char *uri)
     /* Set up to send the first header string. */
     hs->hdr_index = 0;
     hs->hdr_pos = 0;
+    __A_VARIABLE = 1;
     return;
   }
   /* We are dealing with a particular filename. Look for one other
@@ -924,6 +946,7 @@ get_http_headers(struct http_state *hs, const char *uri)
     /* Force the header index to a value indicating that all headers
        have already been sent. */
     hs->hdr_index = NUM_FILE_HDR_STRINGS;
+    __A_VARIABLE = 1;
     return;
   }
 #endif /* LWIP_HTTPD_OMIT_HEADER_FOR_EXTENSIONLESS_URI */
@@ -941,6 +964,7 @@ get_http_headers(struct http_state *hs, const char *uri)
   /* Set up to send the first header string. */
   hs->hdr_index = 0;
   hs->hdr_pos = 0;
+  __A_VARIABLE = 1;
 }
 
 /* Add content-length header? */
@@ -984,6 +1008,7 @@ get_http_content_length(struct http_state *hs)
     hs->hdrs[HDR_STRINGS_IDX_CONTENT_LEN_KEEPALIVE] = g_psHTTPHeaderStrings[HTTP_HDR_CONTENT_LENGTH];
   }
 #endif /* LWIP_HTTPD_SUPPORT_11_KEEPALIVE */
+  __A_VARIABLE = 1;
 }
 
 /** Sub-function of http_send(): send dynamic headers
@@ -1206,6 +1231,7 @@ http_send_data_nonssi(struct altcp_pcb *pcb, struct http_state *hs)
     hs->left -= len;
   }
 
+  __A_VARIABLE = 1;
   return data_to_send;
 }
 
@@ -1246,6 +1272,7 @@ http_send_data_ssi(struct altcp_pcb *pcb, struct http_state *hs)
 
     /* If the send buffer is full, return now. */
     if (altcp_sndbuf(pcb) == 0) {
+      __A_VARIABLE = 1;
       return data_to_send;
     }
   }
@@ -1256,6 +1283,7 @@ http_send_data_ssi(struct altcp_pcb *pcb, struct http_state *hs)
    * the buffer contents looking for SSI tags. */
   while (((ssi->tag_state == TAG_SENDING) || ssi->parse_left) && (err == ERR_OK)) {
     if (len == 0) {
+      __A_VARIABLE = 1;
       return data_to_send;
     }
     switch (ssi->tag_state) {
@@ -1545,6 +1573,7 @@ http_send_data_ssi(struct altcp_pcb *pcb, struct http_state *hs)
       hs->left -= len;
     }
   }
+  __A_VARIABLE = 1;
   return data_to_send;
 }
 #endif /* LWIP_HTTPD_SSI */
@@ -1565,12 +1594,14 @@ http_send(struct altcp_pcb *pcb, struct http_state *hs)
 
 #if LWIP_HTTPD_SUPPORT_POST && LWIP_HTTPD_POST_MANUAL_WND
   if (hs->unrecved_bytes != 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
 #endif /* LWIP_HTTPD_SUPPORT_POST && LWIP_HTTPD_POST_MANUAL_WND */
 
   /* If we were passed a NULL state structure pointer, ignore the call. */
   if (hs == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -1578,6 +1609,7 @@ http_send(struct altcp_pcb *pcb, struct http_state *hs)
   /* Check if we are allowed to read from this file.
      (e.g. SSI might want to delay sending until data is available) */
   if (!fs_is_file_ready(hs->handle, http_continue, hs)) {
+    __A_VARIABLE = 1;
     return 0;
   }
 #endif /* LWIP_HTTPD_FS_ASYNC_READ */
@@ -1589,6 +1621,7 @@ http_send(struct altcp_pcb *pcb, struct http_state *hs)
     if ((data_to_send == HTTP_DATA_TO_SEND_FREED) ||
         ((data_to_send != HTTP_DATA_TO_SEND_CONTINUE) &&
          (hs->hdr_index < NUM_FILE_HDR_STRINGS))) {
+      __A_VARIABLE = 1;
       return data_to_send;
     }
   }
@@ -1598,6 +1631,7 @@ http_send(struct altcp_pcb *pcb, struct http_state *hs)
    * block from the file. */
   if (hs->left == 0) {
     if (!http_check_eof(pcb, hs)) {
+      __A_VARIABLE = 1;
       return 0;
     }
   }
@@ -1616,9 +1650,11 @@ http_send(struct altcp_pcb *pcb, struct http_state *hs)
      * This adds the FIN flag right into the last data segment. */
     LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
     http_eof(pcb, hs);
+    __A_VARIABLE = 1;
     return 0;
   }
   LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("send_data end.\n"));
+  __A_VARIABLE = 1;
   return data_to_send;
 }
 
@@ -1689,11 +1725,13 @@ http_get_404_file(struct http_state *hs, const char **uri)
          * send back a default 404 page.
          */
         *uri = NULL;
+        __A_VARIABLE = 1;
         return NULL;
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return &hs->file_handle;
 }
 
@@ -1911,6 +1949,7 @@ void httpd_post_data_recved(void *connection, u16_t recved_len)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_POST_MANUAL_WND */
 
@@ -1934,6 +1973,7 @@ http_continue(void *connection)
       altcp_output(hs->pcb);
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_FS_ASYNC_READ */
 
@@ -2159,6 +2199,7 @@ http_uri_is_ssi(struct fs_file *file, const char *uri)
       *param = '?';
     }
   }
+  __A_VARIABLE = 1;
   return tag_check;
 }
 #endif /* LWIP_HTTPD_SSI */
@@ -2413,6 +2454,7 @@ http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const cha
     }
   }
 #endif /* LWIP_HTTPD_SUPPORT_11_KEEPALIVE */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2431,6 +2473,7 @@ http_err(void *arg, err_t err)
   if (hs != NULL) {
     http_state_free(hs);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2447,6 +2490,7 @@ http_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
   LWIP_UNUSED_ARG(len);
 
   if (hs == NULL) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -2454,6 +2498,7 @@ http_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
 
   http_send(pcb, hs);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2606,6 +2651,7 @@ http_accept(void *arg, struct altcp_pcb *pcb, err_t err)
   LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept %p / %p\n", (void *)pcb, arg));
 
   if ((err != ERR_OK) || (pcb == NULL)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -2617,6 +2663,7 @@ http_accept(void *arg, struct altcp_pcb *pcb, err_t err)
   hs = http_state_alloc();
   if (hs == NULL) {
     LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept: Out of memory, RST\n"));
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   hs->pcb = pcb;
@@ -2631,6 +2678,7 @@ http_accept(void *arg, struct altcp_pcb *pcb, err_t err)
   altcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
   altcp_sent(pcb, http_sent);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2649,6 +2697,7 @@ httpd_init_pcb(struct altcp_pcb *pcb, u16_t port)
     LWIP_ASSERT("httpd_init: tcp_listen failed", pcb != NULL);
     altcp_accept(pcb, http_accept);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2673,6 +2722,7 @@ httpd_init(void)
   pcb = altcp_tcp_new_ip_type(IPADDR_TYPE_ANY);
   LWIP_ASSERT("httpd_init: tcp_new failed", pcb != NULL);
   httpd_init_pcb(pcb, HTTPD_SERVER_PORT);
+  __A_VARIABLE = 1;
 }
 
 #if HTTPD_ENABLE_HTTPS
@@ -2691,6 +2741,7 @@ httpd_inits(struct altcp_tls_config *conf)
 #else /* LWIP_ALTCP_TLS */
   LWIP_UNUSED_ARG(conf);
 #endif /* LWIP_ALTCP_TLS */
+  __A_VARIABLE = 1;
 }
 #endif /* HTTPD_ENABLE_HTTPS */
 
@@ -2721,6 +2772,7 @@ http_set_ssi_handler(tSSIHandler ssi_handler, const char **tags, int num_tags)
   httpd_tags = tags;
   httpd_num_tags = num_tags;
 #endif /* !LWIP_HTTPD_SSI_RAW */
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_SSI */
 
@@ -2740,6 +2792,7 @@ http_set_cgi_handlers(const tCGI *cgis, int num_handlers)
 
   httpd_cgis = cgis;
   httpd_num_cgis = num_handlers;
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_HTTPD_CGI */
 
diff --git a/src/apps/http/makefsdata/makefsdata.c b/src/apps/http/makefsdata/makefsdata.c
index 1906ce2..eeb403a 100644
--- a/src/apps/http/makefsdata/makefsdata.c
+++ b/src/apps/http/makefsdata/makefsdata.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * makefsdata: Converts a directory structure for use with the lwIP httpd.
  *
@@ -174,6 +176,7 @@ static void print_usage(void)
 #endif
   printf("   if targetdir not specified, htmlgen will attempt to" NEWLINE);
   printf("   process files in subdirectory 'fs'" NEWLINE);
+  __A_VARIABLE = 1;
 }
 
 int main(int argc, char *argv[])
@@ -375,6 +378,7 @@ int main(int argc, char *argv[])
     free(ssi_file_lines);
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -383,11 +387,13 @@ int check_path(char *path, size_t size)
   size_t slen;
   if (path[0] == 0) {
     /* empty */
+    __A_VARIABLE = 1;
     return 0;
   }
   slen = strlen(path);
   if (slen >= size) {
     /* not NULL-terminated */
+    __A_VARIABLE = 1;
     return 0;
   }
   while ((slen > 0) && ((path[slen] == '\\') || (path[slen] == '/'))) {
@@ -396,8 +402,10 @@ int check_path(char *path, size_t size)
     slen--;
   }
   if (slen == 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -417,6 +425,7 @@ static void copy_file(const char *filename_in, FILE *fout)
   }
   free(buf);
   fclose(fin);
+  __A_VARIABLE = 1;
 }
 
 void concat_files(const char *file1, const char *file2, const char *targetfile)
@@ -430,6 +439,7 @@ void concat_files(const char *file1, const char *file2, const char *targetfile)
   copy_file(file1, fout);
   copy_file(file2, fout);
   fclose(fout);
+  __A_VARIABLE = 1;
 }
 
 int process_sub(FILE *data_file, FILE *struct_file)
@@ -517,6 +527,7 @@ int process_sub(FILE *data_file, FILE *struct_file)
 
             if (process_file(data_file, struct_file, curName) < 0) {
               printf(NEWLINE "Error... aborting" NEWLINE);
+              __A_VARIABLE = 1;
               return -1;
             }
             filesProcessed++;
@@ -526,6 +537,7 @@ int process_sub(FILE *data_file, FILE *struct_file)
     }
   }
 
+  __A_VARIABLE = 1;
   return filesProcessed;
 }
 
@@ -624,6 +636,7 @@ static u8_t *get_file_data(const char *filename, int *file_size, int can_be_comp
   LWIP_UNUSED_ARG(can_be_compressed);
 #endif
   fclose(inFile);
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -649,6 +662,7 @@ static void process_file_data(FILE *data_file, u8_t *file_data, size_t file_size
   }
   written = fwrite(file_buffer_c, 1, off, data_file);
   LWIP_ASSERT("written == off", written == off);
+  __A_VARIABLE = 1;
 }
 
 static int write_checksums(FILE *struct_file, const char *varname,
@@ -686,6 +700,7 @@ static int write_checksums(FILE *struct_file, const char *varname,
   }
   fprintf(struct_file, "};" NEWLINE);
   fprintf(struct_file, "#endif /* HTTPD_PRECALCULATED_CHECKSUM */" NEWLINE);
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -695,8 +710,10 @@ static int is_valid_char_for_c_var(char x)
       ((x >= 'a') && (x <= 'z')) ||
       ((x >= '0') && (x <= '9')) ||
       (x == '_')) {
+    __A_VARIABLE = 1;
     return 1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -736,6 +753,7 @@ static void fix_filename_for_c(char *qualifiedName, size_t max_len)
   }
   strcpy(qualifiedName, new_name);
   free(new_name);
+  __A_VARIABLE = 1;
 }
 
 static void register_filename(const char *qualifiedName)
@@ -749,6 +767,7 @@ static void register_filename(const char *qualifiedName)
     last_file->next = fe;
     last_file = fe;
   }
+  __A_VARIABLE = 1;
 }
 
 static int checkSsiByFilelist(const char* filename_listfile)
@@ -767,6 +786,7 @@ static int checkSsiByFilelist(const char* filename_listfile)
     if (rs < 0) {
       printf("ftell failed with %d\n", errno);
       fclose(f);
+      __A_VARIABLE = 1;
       return 0;
     }
     fsize = (size_t)rs;
@@ -775,6 +795,7 @@ static int checkSsiByFilelist(const char* filename_listfile)
     if (!buf) {
       printf("failed to allocate ssi file buffer\n");
       fclose(f);
+      __A_VARIABLE = 1;
       return 0;
     }
     memset(buf, 0, fsize);
@@ -783,6 +804,7 @@ static int checkSsiByFilelist(const char* filename_listfile)
     if ((readcount > fsize) || !readcount) {
       printf("failed to read data from ssi file\n");
       free(buf);
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -801,6 +823,7 @@ static int checkSsiByFilelist(const char* filename_listfile)
     if (!lines) {
       printf("failed to allocate ssi line buffer\n");
       free(buf);
+      __A_VARIABLE = 1;
       return 0;
     }
     memset(lines, 0, sizeof(char*) * num_lines);
@@ -828,6 +851,7 @@ static int checkSsiByFilelist(const char* filename_listfile)
     ssi_file_lines = lines;
     ssi_file_num_lines = l;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -871,6 +895,7 @@ static int ext_in_list(const char* filename, const char *ext_list)
   int found = 0;
   const char *ext = ext_list;
   if (ext_list == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   while(*ext != '\0') {
@@ -889,16 +914,19 @@ static int ext_in_list(const char* filename, const char *ext_list)
     ext = comma + 1;
   }
 
+  __A_VARIABLE = 1;
   return found;
 }
 
 static int file_to_exclude(const char *filename)
 {
+    __A_VARIABLE = 1;
     return (exclude_list != NULL) && ext_in_list(filename, exclude_list);
 }
 
 static int file_can_be_compressed(const char *filename)
 {
+    __A_VARIABLE = 1;
     return (ncompress_list == NULL) || !ext_in_list(filename, ncompress_list);
 }
 
@@ -1017,6 +1045,7 @@ int process_file(FILE *data_file, FILE *struct_file, const char *filename)
   process_file_data(data_file, file_data, file_size);
   fprintf(data_file, "};" NEWLINE NEWLINE);
   free(file_data);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1218,6 +1247,7 @@ int file_write_http_header(FILE *data_file, const char *filename, int file_size,
     *http_hdr_chksum = acc;
   }
 
+  __A_VARIABLE = 1;
   return written;
 }
 
@@ -1231,6 +1261,7 @@ int file_put_ascii(FILE *file, const char *ascii_string, int len, int *i)
       fprintf(file, NEWLINE);
     }
   }
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -1247,5 +1278,6 @@ int s_put_ascii(char *buf, const char *ascii_string, int len, int *i)
       idx += NEWLINE_LEN;
     }
   }
+  __A_VARIABLE = 1;
   return len;
 }
diff --git a/src/apps/lwiperf/lwiperf.c b/src/apps/lwiperf/lwiperf.c
index ec2c9bb..cff268e 100644
--- a/src/apps/lwiperf/lwiperf.c
+++ b/src/apps/lwiperf/lwiperf.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * lwIP iPerf server implementation
@@ -188,6 +190,7 @@ lwiperf_list_add(lwiperf_state_base_t *item)
 {
   item->next = lwiperf_all_connections;
   lwiperf_all_connections = item;
+  __A_VARIABLE = 1;
 }
 
 /** Remove an iperf session from the 'active' list */
@@ -210,6 +213,7 @@ lwiperf_list_remove(lwiperf_state_base_t *item)
       break;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static lwiperf_state_base_t *
@@ -218,9 +222,11 @@ lwiperf_list_find(lwiperf_state_base_t *item)
   lwiperf_state_base_t *iter;
   for (iter = lwiperf_all_connections; iter != NULL; iter = iter->next) {
     if (iter == item) {
+      __A_VARIABLE = 1;
       return item;
     }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -242,6 +248,7 @@ lwip_tcp_conn_report(lwiperf_state_tcp_t *conn, enum lwiperf_report_type report_
                     &conn->conn_pcb->remote_ip, conn->conn_pcb->remote_port,
                     conn->bytes_transferred, duration_ms, bandwidth_kbitpsec);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Close an iperf tcp session */
@@ -269,6 +276,7 @@ lwiperf_tcp_close(lwiperf_state_tcp_t *conn, enum lwiperf_report_type report_typ
     LWIP_ASSERT("error", err == ERR_OK);
   }
   LWIPERF_FREE(lwiperf_state_tcp_t, conn);
+  __A_VARIABLE = 1;
 }
 
 /** Try to send more data on an iperf tcp session */
@@ -361,6 +369,7 @@ lwiperf_tcp_client_sent(void *arg, struct tcp_pcb *tpcb, u16_t len)
 
   conn->poll_count = 0;
 
+  __A_VARIABLE = 1;
   return lwiperf_tcp_client_send_more(conn);
 }
 
@@ -373,10 +382,12 @@ lwiperf_tcp_client_connected(void *arg, struct tcp_pcb *tpcb, err_t err)
   LWIP_UNUSED_ARG(tpcb);
   if (err != ERR_OK) {
     lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_REMOTE);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
   conn->poll_count = 0;
   conn->time_started = sys_now();
+  __A_VARIABLE = 1;
   return lwiperf_tcp_client_send_more(conn);
 }
 
@@ -399,11 +410,13 @@ lwiperf_tx_start_impl(const ip_addr_t *remote_ip, u16_t remote_port, lwiperf_set
 
   client_conn = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
   if (client_conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   newpcb = tcp_new_ip_type(IP_GET_TYPE(remote_ip));
   if (newpcb == NULL) {
     LWIPERF_FREE(lwiperf_state_tcp_t, client_conn);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(client_conn, 0, sizeof(lwiperf_state_tcp_t));
@@ -428,10 +441,12 @@ lwiperf_tx_start_impl(const ip_addr_t *remote_ip, u16_t remote_port, lwiperf_set
   err = tcp_connect(newpcb, &remote_addr, remote_port, lwiperf_tcp_client_connected);
   if (err != ERR_OK) {
     lwiperf_tcp_close(client_conn, LWIPERF_TCP_ABORTED_LOCAL);
+    __A_VARIABLE = 1;
     return err;
   }
   lwiperf_list_add(&client_conn->base);
   *new_conn = client_conn;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -448,6 +463,7 @@ lwiperf_tx_start_passive(lwiperf_state_tcp_t *conn)
     LWIP_ASSERT("new_conn != NULL", new_conn != NULL);
     new_conn->settings.flags = 0; /* prevent the remote side starting back as client again */
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -566,6 +582,7 @@ lwiperf_tcp_err(void *arg, err_t err)
   lwiperf_state_tcp_t *conn = (lwiperf_state_tcp_t *)arg;
   LWIP_UNUSED_ARG(err);
   lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_REMOTE);
+  __A_VARIABLE = 1;
 }
 
 /** TCP poll callback, try to send more data */
@@ -577,6 +594,7 @@ lwiperf_tcp_poll(void *arg, struct tcp_pcb *tpcb)
   LWIP_UNUSED_ARG(tpcb);
   if (++conn->poll_count >= LWIPERF_TCP_MAX_IDLE_SEC) {
     lwiperf_tcp_close(conn, LWIPERF_TCP_ABORTED_LOCAL);
+    __A_VARIABLE = 1;
     return ERR_OK; /* lwiperf_tcp_close frees conn */
   }
 
@@ -584,6 +602,7 @@ lwiperf_tcp_poll(void *arg, struct tcp_pcb *tpcb)
     lwiperf_tcp_client_send_more(conn);
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -654,6 +673,7 @@ lwiperf_tcp_accept(void *arg, struct tcp_pcb *newpcb, err_t err)
 void *
 lwiperf_start_tcp_server_default(lwiperf_report_fn report_fn, void *report_arg)
 {
+  __A_VARIABLE = 1;
   return lwiperf_start_tcp_server(IP_ADDR_ANY, LWIPERF_TCP_PORT_DEFAULT,
                                   report_fn, report_arg);
 }
@@ -676,8 +696,10 @@ lwiperf_start_tcp_server(const ip_addr_t *local_addr, u16_t local_port,
   err = lwiperf_start_tcp_server_impl(local_addr, local_port, report_fn, report_arg,
     NULL, &state);
   if (err == ERR_OK) {
+    __A_VARIABLE = 1;
     return state;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -694,11 +716,13 @@ static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t lo
   LWIP_ASSERT("state != NULL", state != NULL);
 
   if (local_addr == NULL) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
   s = (lwiperf_state_tcp_t *)LWIPERF_ALLOC(lwiperf_state_tcp_t);
   if (s == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(s, 0, sizeof(lwiperf_state_tcp_t));
@@ -710,10 +734,12 @@ static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t lo
 
   pcb = tcp_new_ip_type(LWIPERF_SERVER_IP_TYPE);
   if (pcb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   err = tcp_bind(pcb, local_addr, local_port);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
   s->server_pcb = tcp_listen_with_backlog(pcb, 1);
@@ -722,6 +748,7 @@ static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t lo
       tcp_close(pcb);
     }
     LWIPERF_FREE(lwiperf_state_tcp_t, s);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   pcb = NULL;
@@ -731,6 +758,7 @@ static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t lo
 
   lwiperf_list_add(&s->base);
   *state = s;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -744,6 +772,7 @@ static err_t lwiperf_start_tcp_server_impl(const ip_addr_t *local_addr, u16_t lo
 void* lwiperf_start_tcp_client_default(const ip_addr_t* remote_addr,
                                lwiperf_report_fn report_fn, void* report_arg)
 {
+  __A_VARIABLE = 1;
   return lwiperf_start_tcp_client(remote_addr, LWIPERF_TCP_PORT_DEFAULT, LWIPERF_CLIENT,
                                   report_fn, report_arg);
 }
@@ -778,6 +807,7 @@ void* lwiperf_start_tcp_client(const ip_addr_t* remote_addr, u16_t remote_port,
     break;
   default:
     /* invalid argument */
+    __A_VARIABLE = 1;
     return NULL;
   }
   settings.num_threads = htonl(1);
@@ -796,6 +826,7 @@ void* lwiperf_start_tcp_client(const ip_addr_t* remote_addr, u16_t remote_port,
       if (ret != ERR_OK) {
         /* starting server failed, abort client */
         lwiperf_abort(state);
+        __A_VARIABLE = 1;
         return NULL;
       }
       /* make this server accept one connection only */
@@ -807,8 +838,10 @@ void* lwiperf_start_tcp_client(const ip_addr_t* remote_addr, u16_t remote_port,
         server->client_tradeoff_mode = 1;
       }
     }
+    __A_VARIABLE = 1;
     return state;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -836,6 +869,7 @@ lwiperf_abort(void *lwiperf_session)
       i = i->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_TCP && LWIP_CALLBACK_API */
diff --git a/src/apps/mdns/mdns.c b/src/apps/mdns/mdns.c
index 46314d2..92c46ba 100644
--- a/src/apps/mdns/mdns.c
+++ b/src/apps/mdns/mdns.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * MDNS responder implementation
@@ -291,17 +293,21 @@ static err_t
 mdns_domain_add_label_base(struct mdns_domain *domain, u8_t len)
 {
   if (len > MDNS_LABEL_MAXLEN) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   if (len > 0 && (1 + len + domain->length >= MDNS_DOMAIN_MAXLEN)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   /* Allow only zero marker on last byte */
   if (len == 0 && (1 + domain->length > MDNS_DOMAIN_MAXLEN)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   domain->name[domain->length] = len;
   domain->length++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -317,12 +323,14 @@ mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len)
 {
   err_t err = mdns_domain_add_label_base(domain, len);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
   if (len) {
     MEMCPY(&domain->name[domain->length], label, len);
     domain->length += len;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -334,16 +342,19 @@ mdns_domain_add_label_pbuf(struct mdns_domain *domain, const struct pbuf *p, u16
 {
   err_t err = mdns_domain_add_label_base(domain, len);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
   if (len) {
     if (pbuf_copy_partial(p, &domain->name[domain->length], len, offset) != len) {
       /* take back the ++ done before */
       domain->length--;
+      __A_VARIABLE = 1;
       return ERR_ARG;
     }
     domain->length += len;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -421,6 +432,7 @@ u16_t
 mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain)
 {
   memset(domain, 0, sizeof(struct mdns_domain));
+  __A_VARIABLE = 1;
   return mdns_readname_loop(p, offset, domain, 0);
 }
 
@@ -443,6 +455,7 @@ mdns_domain_debug_print(struct mdns_domain *domain)
     src += label_len;
     LWIP_DEBUGF(MDNS_DEBUG, ("."));
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -459,6 +472,7 @@ mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)
   int res;
 
   if (a->length != b->length) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -466,6 +480,7 @@ mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)
   ptrb = b->name;
   while (*ptra && *ptrb && ptra < &a->name[a->length]) {
     if (*ptra != *ptrb) {
+      __A_VARIABLE = 1;
       return 0;
     }
     len = *ptra;
@@ -473,14 +488,17 @@ mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b)
     ptrb++;
     res = lwip_strnicmp((char *) ptra, (char *) ptrb, len);
     if (res != 0) {
+      __A_VARIABLE = 1;
       return 0;
     }
     ptra += len;
     ptrb += len;
   }
   if (*ptra != *ptrb && ptra < &a->name[a->length]) {
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -495,6 +513,7 @@ mdns_prepare_txtdata(struct mdns_service *service)
   if (service->txt_fn) {
     service->txt_fn(service, service->txt_userdata);
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_IPV4
@@ -514,6 +533,7 @@ mdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr)
 
   LWIP_UNUSED_ARG(res);
   if (!domain || !addr) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   memset(domain, 0, sizeof(struct mdns_domain));
@@ -533,6 +553,7 @@ mdns_build_reverse_v4_domain(struct mdns_domain *domain, const ip4_addr_t *addr)
   res = mdns_domain_add_label(domain, NULL, 0);
   LWIP_ERROR("mdns_build_reverse_v4_domain: Failed to add label", (res == ERR_OK), return res);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif
@@ -553,6 +574,7 @@ mdns_build_reverse_v6_domain(struct mdns_domain *domain, const ip6_addr_t *addr)
   const u8_t *ptr;
   LWIP_UNUSED_ARG(res);
   if (!domain || !addr) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   memset(domain, 0, sizeof(struct mdns_domain));
@@ -579,6 +601,7 @@ mdns_build_reverse_v6_domain(struct mdns_domain *domain, const ip6_addr_t *addr)
   res = mdns_domain_add_label(domain, NULL, 0);
   LWIP_ERROR("mdns_build_reverse_v6_domain: Failed to add label", (res == ERR_OK), return res);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif
@@ -590,6 +613,7 @@ mdns_add_dotlocal(struct mdns_domain *domain)
   err_t res = mdns_domain_add_label(domain, TOPDOMAIN_LOCAL, (u8_t)(sizeof(TOPDOMAIN_LOCAL) - 1));
   LWIP_UNUSED_ARG(res);
   LWIP_ERROR("mdns_add_dotlocal: Failed to add label", (res == ERR_OK), return res);
+  __A_VARIABLE = 1;
   return mdns_domain_add_label(domain, NULL, 0);
 }
 
@@ -608,6 +632,7 @@ mdns_build_host_domain(struct mdns_domain *domain, struct mdns_host *mdns)
   LWIP_ERROR("mdns_build_host_domain: mdns != NULL", (mdns != NULL), return ERR_VAL);
   res = mdns_domain_add_label(domain, mdns->name, (u8_t)strlen(mdns->name));
   LWIP_ERROR("mdns_build_host_domain: Failed to add label", (res == ERR_OK), return res);
+  __A_VARIABLE = 1;
   return mdns_add_dotlocal(domain);
 }
 
@@ -628,6 +653,7 @@ mdns_build_dnssd_domain(struct mdns_domain *domain)
   LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
   res = mdns_domain_add_label(domain, dnssd_protos[DNSSD_PROTO_UDP], (u8_t)strlen(dnssd_protos[DNSSD_PROTO_UDP]));
   LWIP_ERROR("mdns_build_dnssd_domain: Failed to add label", (res == ERR_OK), return res);
+  __A_VARIABLE = 1;
   return mdns_add_dotlocal(domain);
 }
 
@@ -654,6 +680,7 @@ mdns_build_service_domain(struct mdns_domain *domain, struct mdns_service *servi
   LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
   res = mdns_domain_add_label(domain, dnssd_protos[service->proto], (u8_t)strlen(dnssd_protos[service->proto]));
   LWIP_ERROR("mdns_build_service_domain: Failed to add label", (res == ERR_OK), return res);
+  __A_VARIABLE = 1;
   return mdns_add_dotlocal(domain);
 }
 
@@ -676,6 +703,7 @@ check_host(struct netif *netif, struct mdns_rr_info *rr, u8_t *reverse_v6_reply)
 
   if (rr->klass != DNS_RRCLASS_IN && rr->klass != DNS_RRCLASS_ANY) {
     /* Invalid class */
+    __A_VARIABLE = 1;
     return replies;
   }
 
@@ -723,6 +751,7 @@ check_host(struct netif *netif, struct mdns_rr_info *rr, u8_t *reverse_v6_reply)
 #endif
   }
 
+  __A_VARIABLE = 1;
   return replies;
 }
 
@@ -741,6 +770,7 @@ check_service(struct mdns_service *service, struct mdns_rr_info *rr)
 
   if (rr->klass != DNS_RRCLASS_IN && rr->klass != DNS_RRCLASS_ANY) {
     /* Invalid class */
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -769,6 +799,7 @@ check_service(struct mdns_service *service, struct mdns_rr_info *rr)
     }
   }
 
+  __A_VARIABLE = 1;
   return replies;
 }
 
@@ -793,10 +824,12 @@ mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domai
   u8_t writelen = 0;
   u8_t *ptr;
   if (pbuf == NULL) {
+    __A_VARIABLE = 1;
     return domain->length;
   }
   target_end = mdns_readname(pbuf, *offset, &target);
   if (target_end == MDNS_READNAME_ERROR) {
+    __A_VARIABLE = 1;
     return domain->length;
   }
   target_len = (u8_t)(target_end - *offset);
@@ -814,6 +847,7 @@ mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domai
       if (target.length >= domainlen &&
           memcmp(&domain->name[writelen], &target.name[targetpos], domainlen) == 0) {
         *offset += targetpos;
+        __A_VARIABLE = 1;
         return writelen;
       }
     }
@@ -823,6 +857,7 @@ mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domai
     ptr += 1 + labellen;
   }
   /* Nothing found */
+  __A_VARIABLE = 1;
   return domain->length;
 }
 
@@ -859,6 +894,7 @@ mdns_write_domain(struct mdns_outpacket *outpkt, struct mdns_domain *domain)
     /* Write uncompressed part of name */
     res = pbuf_take_at(outpkt->pbuf, domain->name, writelen, outpkt->write_offset);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
 
@@ -877,10 +913,12 @@ mdns_write_domain(struct mdns_outpacket *outpkt, struct mdns_domain *domain)
     jump = lwip_htons(DOMAIN_JUMP | jump_offset);
     res = pbuf_take_at(outpkt->pbuf, &jump, DOMAIN_JUMP_SIZE, outpkt->write_offset);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
     outpkt->write_offset += DOMAIN_JUMP_SIZE;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -907,6 +945,7 @@ mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16
     /* If no pbuf is active, allocate one */
     outpkt->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
     if (!outpkt->pbuf) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
     outpkt->write_offset = SIZEOF_DNS_HDR;
@@ -916,12 +955,14 @@ mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16
   question_len = domain->length + sizeof(type) + sizeof(klass);
   if (outpkt->write_offset + question_len > outpkt->pbuf->tot_len) {
     /* No space */
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   /* Write name */
   res = mdns_write_domain(outpkt, domain);
   if (res != ERR_OK) {
+    __A_VARIABLE = 1;
     return res;
   }
 
@@ -929,6 +970,7 @@ mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16
   field16 = lwip_htons(type);
   res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
   if (res != ERR_OK) {
+    __A_VARIABLE = 1;
     return res;
   }
   outpkt->write_offset += sizeof(field16);
@@ -940,10 +982,12 @@ mdns_add_question(struct mdns_outpacket *outpkt, struct mdns_domain *domain, u16
   field16 = lwip_htons(klass);
   res = pbuf_take_at(outpkt->pbuf, &field16, sizeof(field16), outpkt->write_offset);
   if (res != ERR_OK) {
+    __A_VARIABLE = 1;
     return res;
   }
   outpkt->write_offset += sizeof(field16);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -979,6 +1023,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
     /* If no pbuf is active, allocate one */
     reply->pbuf = pbuf_alloc(PBUF_TRANSPORT, OUTPACKET_SIZE, PBUF_RAM);
     if (!reply->pbuf) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
     reply->write_offset = SIZEOF_DNS_HDR;
@@ -994,6 +1039,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
   }
   if (reply->write_offset + answer_len > reply->pbuf->tot_len) {
     /* No space */
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -1004,6 +1050,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
   field32 = lwip_htonl(ttl);
   res = pbuf_take_at(reply->pbuf, &field32, sizeof(field32), reply->write_offset);
   if (res != ERR_OK) {
+    __A_VARIABLE = 1;
     return res;
   }
   reply->write_offset += sizeof(field32);
@@ -1017,6 +1064,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
     /* Write static data */
     res = pbuf_take_at(reply->pbuf, buf, (u16_t)buf_length, reply->write_offset);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
     reply->write_offset += (u16_t)buf_length;
@@ -1026,6 +1074,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
     /* Write name answer (compressed if possible) */
     res = mdns_write_domain(reply, answer_domain);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
   }
@@ -1034,6 +1083,7 @@ mdns_add_answer(struct mdns_outpacket *reply, struct mdns_domain *domain, u16_t
   field16 = lwip_htons(reply->write_offset - answer_offset);
   res = pbuf_take_at(reply->pbuf, &field16, sizeof(field16), rdlen_offset);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -1051,11 +1101,13 @@ mdns_read_rr_info(struct mdns_packet *pkt, struct mdns_rr_info *info)
   u16_t field16, copied;
   pkt->parse_offset = mdns_readname(pkt->pbuf, pkt->parse_offset, &info->domain);
   if (pkt->parse_offset == MDNS_READNAME_ERROR) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
   if (copied != sizeof(field16)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   pkt->parse_offset += copied;
@@ -1063,11 +1115,13 @@ mdns_read_rr_info(struct mdns_packet *pkt, struct mdns_rr_info *info)
 
   copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
   if (copied != sizeof(field16)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   pkt->parse_offset += copied;
   info->klass = lwip_ntohs(field16);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1084,6 +1138,7 @@ mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
 {
   /* Safety check */
   if (pkt->pbuf->tot_len < pkt->parse_offset) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1094,6 +1149,7 @@ mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
     memset(question, 0, sizeof(struct mdns_question));
     res = mdns_read_rr_info(pkt, &question->info);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
 
@@ -1101,8 +1157,10 @@ mdns_read_question(struct mdns_packet *pkt, struct mdns_question *question)
     question->unicast = question->info.klass & 0x8000;
     question->info.klass &= 0x7FFF;
 
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -1119,11 +1177,13 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
 {
   /* Read questions first */
   if (pkt->questions_left) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   /* Safety check */
   if (pkt->pbuf->tot_len < pkt->parse_offset) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1136,6 +1196,7 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
     memset(answer, 0, sizeof(struct mdns_answer));
     res = mdns_read_rr_info(pkt, &answer->info);
     if (res != ERR_OK) {
+      __A_VARIABLE = 1;
       return res;
     }
 
@@ -1145,6 +1206,7 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
 
     copied = pbuf_copy_partial(pkt->pbuf, &ttl, sizeof(ttl), pkt->parse_offset);
     if (copied != sizeof(ttl)) {
+      __A_VARIABLE = 1;
       return ERR_VAL;
     }
     pkt->parse_offset += copied;
@@ -1152,6 +1214,7 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
 
     copied = pbuf_copy_partial(pkt->pbuf, &field16, sizeof(field16), pkt->parse_offset);
     if (copied != sizeof(field16)) {
+      __A_VARIABLE = 1;
       return ERR_VAL;
     }
     pkt->parse_offset += copied;
@@ -1160,8 +1223,10 @@ mdns_read_answer(struct mdns_packet *pkt, struct mdns_answer *answer)
     answer->rd_offset = pkt->parse_offset;
     pkt->parse_offset += answer->rd_length;
 
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -1173,6 +1238,7 @@ mdns_add_a_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct netif
   struct mdns_domain host;
   mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with A record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &host, DNS_RRTYPE_A, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, (const u8_t *) netif_ip4_addr(netif), sizeof(ip4_addr_t), NULL);
 }
 
@@ -1184,6 +1250,7 @@ mdns_add_hostv4_ptr_answer(struct mdns_outpacket *reply, u16_t cache_flush, stru
   mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
   mdns_build_reverse_v4_domain(&revhost, netif_ip4_addr(netif));
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v4 PTR record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, NULL, 0, &host);
 }
 #endif
@@ -1196,6 +1263,7 @@ mdns_add_aaaa_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct net
   struct mdns_domain host;
   mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with AAAA record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &host, DNS_RRTYPE_AAAA, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, (const u8_t *) netif_ip6_addr(netif, addrindex), sizeof(ip6_addr_p_t), NULL);
 }
 
@@ -1207,6 +1275,7 @@ mdns_add_hostv6_ptr_answer(struct mdns_outpacket *reply, u16_t cache_flush, stru
   mdns_build_host_domain(&host, NETIF_TO_HOST(netif));
   mdns_build_reverse_v6_domain(&revhost, netif_ip6_addr(netif, addrindex));
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with v6 PTR record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &revhost, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, cache_flush, (NETIF_TO_HOST(netif))->dns_ttl, NULL, 0, &host);
 }
 #endif
@@ -1219,6 +1288,7 @@ mdns_add_servicetype_ptr_answer(struct mdns_outpacket *reply, struct mdns_servic
   mdns_build_service_domain(&service_type, service, 0);
   mdns_build_dnssd_domain(&service_dnssd);
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service type PTR record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &service_dnssd, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0, service->dns_ttl, NULL, 0, &service_type);
 }
 
@@ -1230,6 +1300,7 @@ mdns_add_servicename_ptr_answer(struct mdns_outpacket *reply, struct mdns_servic
   mdns_build_service_domain(&service_type, service, 0);
   mdns_build_service_domain(&service_instance, service, 1);
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with service name PTR record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &service_type, DNS_RRTYPE_PTR, DNS_RRCLASS_IN, 0, service->dns_ttl, NULL, 0, &service_instance);
 }
 
@@ -1252,6 +1323,7 @@ mdns_add_srv_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct mdns
   srvdata[1] = lwip_htons(SRV_WEIGHT);
   srvdata[2] = lwip_htons(service->port);
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with SRV record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_SRV, DNS_RRCLASS_IN, cache_flush, service->dns_ttl,
                          (const u8_t *) &srvdata, sizeof(srvdata), &srvhost);
 }
@@ -1264,6 +1336,7 @@ mdns_add_txt_answer(struct mdns_outpacket *reply, u16_t cache_flush, struct mdns
   mdns_build_service_domain(&service_instance, service, 1);
   mdns_prepare_txtdata(service);
   LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Responding with TXT record\n"));
+  __A_VARIABLE = 1;
   return mdns_add_answer(reply, &service_instance, DNS_RRTYPE_TXT, DNS_RRCLASS_IN, cache_flush, service->dns_ttl,
                          (u8_t *) &service->txtdata.name, service->txtdata.length, NULL);
 }
@@ -1296,6 +1369,7 @@ mdns_init_outpacket(struct mdns_outpacket *out, struct mdns_packet *in)
   if (in->recv_unicast) {
     out->unicast_reply = 1;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1507,6 +1581,7 @@ cleanup:
     pbuf_free(outpkt->pbuf);
     outpkt->pbuf = NULL;
   }
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -1550,6 +1625,7 @@ mdns_announce(struct netif *netif, const ip_addr_t *destination)
   announce.dest_port = LWIP_IANA_PORT_MDNS;
   SMEMCPY(&announce.dest_addr, destination, sizeof(announce.dest_addr));
   mdns_send_outpacket(&announce, DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1571,6 +1647,7 @@ mdns_handle_question(struct mdns_packet *pkt)
   if (mdns->probing_state != MDNS_PROBING_COMPLETE) {
     /* Don't answer questions until we've verified our domains via probing */
     /* @todo we should check incoming questions during probing for tiebreaking */
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -1582,6 +1659,7 @@ mdns_handle_question(struct mdns_packet *pkt)
     res = mdns_read_question(pkt, &q);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping query packet\n"));
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -1773,6 +1851,7 @@ cleanup:
     pbuf_free(reply.pbuf);
     reply.pbuf = NULL;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1792,6 +1871,7 @@ mdns_handle_response(struct mdns_packet *pkt)
     res = mdns_read_question(pkt, &q);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse question, skipping response packet\n"));
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -1803,6 +1883,7 @@ mdns_handle_response(struct mdns_packet *pkt)
     res = mdns_read_answer(pkt, &ans);
     if (res != ERR_OK) {
       LWIP_DEBUGF(MDNS_DEBUG, ("MDNS: Failed to parse answer, skipping response packet\n"));
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -1843,6 +1924,7 @@ mdns_handle_response(struct mdns_packet *pkt)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1912,6 +1994,7 @@ mdns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
 
 dealloc:
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_NETIF_EXT_STATUS_CALLBACK && MDNS_RESP_USENETIF_EXTCALLBACK
@@ -1922,6 +2005,7 @@ mdns_netif_ext_status_callback(struct netif *netif, netif_nsc_reason_t reason, c
 
   /* MDNS enabled on netif? */
   if (NETIF_TO_HOST(netif) == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -1941,6 +2025,7 @@ mdns_netif_ext_status_callback(struct netif *netif, netif_nsc_reason_t reason, c
       LWIP_NSC_IPV6_SET | LWIP_NSC_IPV6_ADDR_STATE_CHANGED)) {
     mdns_resp_announce(netif);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETIF_EXT_STATUS_CALLBACK && MDNS_RESP_USENETIF_EXTCALLBACK */
 
@@ -2009,6 +2094,7 @@ cleanup:
     pbuf_free(pkt.pbuf);
     pkt.pbuf = NULL;
   }
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -2044,6 +2130,7 @@ mdns_probe(void* arg)
     }
     sys_timeout(MDNS_PROBE_DELAY_MS, mdns_probe, netif);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2093,11 +2180,13 @@ mdns_resp_add_netif(struct netif *netif, const char *hostname, u32_t dns_ttl)
 
   mdns_resp_restart(netif);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 
 cleanup:
   mem_free(mdns);
   netif_set_client_data(netif, mdns_netif_client_id, NULL);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -2140,6 +2229,7 @@ mdns_resp_remove_netif(struct netif *netif)
 
   mem_free(mdns);
   netif_set_client_data(netif, mdns_netif_client_id, NULL);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2170,6 +2260,7 @@ mdns_resp_rename_netif(struct netif *netif, const char *hostname)
 
   mdns_resp_restart(netif);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2228,6 +2319,7 @@ mdns_resp_add_service(struct netif *netif, const char *name, const char *service
 
   mdns_resp_restart(netif);
 
+  __A_VARIABLE = 1;
   return slot;
 }
 
@@ -2252,6 +2344,7 @@ mdns_resp_del_service(struct netif *netif, s8_t slot)
   srv = mdns->services[slot];
   mdns->services[slot] = NULL;
   mem_free(srv);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2286,6 +2379,7 @@ mdns_resp_rename_service(struct netif *netif, s8_t slot, const char *name)
 
   mdns_resp_restart(netif);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -2305,6 +2399,7 @@ mdns_resp_add_service_txtitem(struct mdns_service *service, const char *txt, u8_
   LWIP_ASSERT("mdns_resp_add_service_txtitem: service != NULL", service);
 
   /* Use a mdns_domain struct to store txt chunks since it is the same encoding */
+  __A_VARIABLE = 1;
   return mdns_domain_add_label(&service->txtdata, txt, txt_len);
 }
 
@@ -2322,6 +2417,7 @@ mdns_resp_announce(struct netif *netif)
 
   mdns = NETIF_TO_HOST(netif);
   if (mdns == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -2336,6 +2432,7 @@ mdns_resp_announce(struct netif *netif)
     }
 #endif
   } /* else: ip address changed while probing was ongoing? @todo reset counter to restart? */
+  __A_VARIABLE = 1;
 }
 
 /** Register a callback function that is called if probing is completed successfully
@@ -2344,6 +2441,7 @@ void
 mdns_resp_register_name_result_cb(mdns_name_result_cb_t cb)
 {
   mdns_name_result_cb = cb;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2361,6 +2459,7 @@ mdns_resp_restart(struct netif *netif)
 
   mdns = NETIF_TO_HOST(netif);
   if (mdns == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -2371,6 +2470,7 @@ mdns_resp_restart(struct netif *netif)
   mdns->probes_sent = 0;
   mdns->probing_state = MDNS_PROBING_ONGOING;
   sys_timeout(MDNS_INITIAL_PROBE_DELAY_MS, mdns_probe, netif);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2402,6 +2502,7 @@ mdns_resp_init(void)
   /* register for netif events when started on first netif */
   netif_add_ext_callback(&netif_callback, mdns_netif_ext_status_callback);
 #endif
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_MDNS_RESPONDER */
diff --git a/src/apps/mqtt/mqtt.c b/src/apps/mqtt/mqtt.c
index f785ebe..a71008b 100644
--- a/src/apps/mqtt/mqtt.c
+++ b/src/apps/mqtt/mqtt.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * MQTT client
@@ -155,6 +157,7 @@ mqtt_msg_type_to_str(u8_t msg_type)
   if (msg_type >= LWIP_ARRAYSIZE(mqtt_message_type_str)) {
     msg_type = 0;
   }
+  __A_VARIABLE = 1;
   return mqtt_message_type_str[msg_type];
 }
 
@@ -173,6 +176,7 @@ msg_generate_packet_id(mqtt_client_t *client)
   if (client->pkt_id_seq == 0) {
     client->pkt_id_seq++;
   }
+  __A_VARIABLE = 1;
   return client->pkt_id_seq;
 }
 
@@ -188,12 +192,14 @@ mqtt_ringbuf_put(struct mqtt_ringbuf_t *rb, u8_t item)
   if (rb->put >= MQTT_OUTPUT_RINGBUF_SIZE) {
     rb->put = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 /** Return pointer to ring buffer get position */
 static u8_t *
 mqtt_ringbuf_get_ptr(struct mqtt_ringbuf_t *rb)
 {
+  __A_VARIABLE = 1;
   return &rb->buf[rb->get];
 }
 
@@ -206,6 +212,7 @@ mqtt_ringbuf_advance_get_idx(struct mqtt_ringbuf_t *rb, u16_t len)
   if (rb->get >= MQTT_OUTPUT_RINGBUF_SIZE) {
     rb->get = rb->get - MQTT_OUTPUT_RINGBUF_SIZE;
   }
+  __A_VARIABLE = 1;
 }
 
 /** Return number of bytes in ring buffer */
@@ -216,6 +223,7 @@ mqtt_ringbuf_len(struct mqtt_ringbuf_t *rb)
   if (len > 0xFFFF) {
     len += MQTT_OUTPUT_RINGBUF_SIZE;
   }
+  __A_VARIABLE = 1;
   return (u16_t)len;
 }
 
@@ -240,6 +248,7 @@ mqtt_output_send(struct mqtt_ringbuf_t *rb, struct altcp_pcb *tpcb)
   LWIP_ASSERT("mqtt_output_send: tpcb != NULL", tpcb != NULL);
 
   if (send_len == 0 || ringbuf_lin_len == 0) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -267,6 +276,7 @@ mqtt_output_send(struct mqtt_ringbuf_t *rb, struct altcp_pcb *tpcb)
   } else {
     LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_output_send: Send failed with err %d (\"%s\")\n", err, lwip_strerr(err)));
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -300,6 +310,7 @@ mqtt_create_request(struct mqtt_request_t *r_objs, size_t r_objs_len, u16_t pkt_
       break;
     }
   }
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -331,6 +342,7 @@ mqtt_append_request(struct mqtt_request_t **tail, struct mqtt_request_t *r)
   } else {
     head->next = r;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -344,6 +356,7 @@ mqtt_delete_request(struct mqtt_request_t *r)
   if (r != NULL) {
     r->next = r;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -379,6 +392,7 @@ mqtt_take_request(struct mqtt_request_t **tail, u16_t pkt_id)
     }
     iter->next = NULL;
   }
+  __A_VARIABLE = 1;
   return iter;
 }
 
@@ -410,6 +424,7 @@ mqtt_request_time_elapsed(struct mqtt_request_t **tail, u8_t t)
       t = 0;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -426,6 +441,7 @@ mqtt_clear_requests(struct mqtt_request_t **tail)
     mqtt_delete_request(iter);
   }
   *tail = NULL;
+  __A_VARIABLE = 1;
 }
 /**
  * Initialize all request items
@@ -441,6 +457,7 @@ mqtt_init_requests(struct mqtt_request_t *r_objs, size_t r_objs_len)
     /* Item pointing to itself indicates unused */
     r_objs[n].next = &r_objs[n];
   }
+  __A_VARIABLE = 1;
 }
 
 /*--------------------------------------------------------------------------------------------------------------------- */
@@ -451,6 +468,7 @@ static void
 mqtt_output_append_u8(struct mqtt_ringbuf_t *rb, u8_t value)
 {
   mqtt_ringbuf_put(rb, value);
+  __A_VARIABLE = 1;
 }
 
 static
@@ -458,6 +476,7 @@ void mqtt_output_append_u16(struct mqtt_ringbuf_t *rb, u16_t value)
 {
   mqtt_ringbuf_put(rb, value >> 8);
   mqtt_ringbuf_put(rb, value & 0xff);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -467,6 +486,7 @@ mqtt_output_append_buf(struct mqtt_ringbuf_t *rb, const void *data, u16_t length
   for (n = 0; n < length; n++) {
     mqtt_ringbuf_put(rb, ((const u8_t *)data)[n]);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -478,6 +498,7 @@ mqtt_output_append_string(struct mqtt_ringbuf_t *rb, const char *str, u16_t leng
   for (n = 0; n < length; n++) {
     mqtt_ringbuf_put(rb, str[n]);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -501,6 +522,7 @@ mqtt_output_append_fixed_header(struct mqtt_ringbuf_t *rb, u8_t msg_type, u8_t f
     mqtt_output_append_u8(rb, (r_length & 0x7f) | (r_length >= 128 ? 0x80 : 0));
     r_length >>= 7;
   } while (r_length > 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -524,6 +546,7 @@ mqtt_output_check_space(struct mqtt_ringbuf_t *rb, u16_t r_length)
     r_length >>= 7;
   } while (r_length > 0);
 
+  __A_VARIABLE = 1;
   return (total_len <= mqtt_ringbuf_free(rb));
 }
 
@@ -565,6 +588,7 @@ mqtt_close(mqtt_client_t *client, mqtt_connection_status_t reason)
       client->connect_cb(client, client->connect_arg, reason);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -620,6 +644,7 @@ mqtt_cyclic_timer(void *arg)
   if (restart_timer) {
     sys_timeout(MQTT_CYCLIC_TIMER_INTERVAL * 1000, mqtt_cyclic_timer, arg);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -644,6 +669,7 @@ pub_ack_rec_rel_response(mqtt_client_t *client, u8_t msg, u16_t pkt_id, u8_t qos
                                    mqtt_msg_type_to_str(msg), pkt_id));
     err = ERR_MEM;
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -658,6 +684,7 @@ mqtt_incomming_suback(struct mqtt_request_t *r, u8_t result)
   if (r->cb != NULL) {
     r->cb(r->arg, result < 3 ? ERR_OK : ERR_ABRT);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -823,8 +850,10 @@ mqtt_message_received(mqtt_client_t *client, u8_t fixed_hdr_idx, u16_t length, u
       goto out_disconnect;
     }
   }
+  __A_VARIABLE = 1;
   return res;
 out_disconnect:
+  __A_VARIABLE = 1;
   return MQTT_CONNECT_DISCONNECTED;
 }
 
@@ -997,6 +1026,7 @@ mqtt_tcp_sent_cb(void *arg, struct altcp_pcb *tpcb, u16_t len)
     /* Try send any remaining buffers from output queue */
     mqtt_output_send(&client->output, client->conn);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1015,6 +1045,7 @@ mqtt_tcp_err_cb(void *arg, err_t err)
   /* Set conn to null before calling close as pcb is already deallocated*/
   client->conn = 0;
   mqtt_close(client, MQTT_CONNECT_DISCONNECTED);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1031,6 +1062,7 @@ mqtt_tcp_poll_cb(void *arg, struct altcp_pcb *tpcb)
     /* Try send any remaining buffers from output queue */
     mqtt_output_send(&client->output, tpcb);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1047,6 +1079,7 @@ mqtt_tcp_connect_cb(void *arg, struct altcp_pcb *tpcb, err_t err)
 
   if (err != ERR_OK) {
     LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_tcp_connect_cb: TCP connect error %d\n", err));
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -1069,6 +1102,7 @@ mqtt_tcp_connect_cb(void *arg, struct altcp_pcb *tpcb, err_t err)
   /* Start transmission from output queue, connect message is the first one out*/
   mqtt_output_send(&client->output, client->conn);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1129,11 +1163,13 @@ mqtt_publish(mqtt_client_t *client, const char *topic, const void *payload, u16_
 
   r = mqtt_create_request(client->req_list, LWIP_ARRAYSIZE(client->req_list), pkt_id, cb, arg);
   if (r == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
     mqtt_delete_request(r);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   /* Append fixed header */
@@ -1154,6 +1190,7 @@ mqtt_publish(mqtt_client_t *client, const char *topic, const void *payload, u16_
 
   mqtt_append_request(&client->pend_req_queue, r);
   mqtt_output_send(&client->output, client->conn);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1194,17 +1231,20 @@ mqtt_sub_unsub(mqtt_client_t *client, const char *topic, u8_t qos, mqtt_request_
   LWIP_ASSERT("mqtt_sub_unsub: qos < 3", qos < 3);
   if (client->conn_state == TCP_DISCONNECTED) {
     LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_sub_unsub: Can not (un)subscribe in disconnected state\n"));
+    __A_VARIABLE = 1;
     return ERR_CONN;
   }
 
   pkt_id = msg_generate_packet_id(client);
   r = mqtt_create_request(client->req_list, LWIP_ARRAYSIZE(client->req_list), pkt_id, cb, arg);
   if (r == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
     mqtt_delete_request(r);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -1222,6 +1262,7 @@ mqtt_sub_unsub(mqtt_client_t *client, const char *topic, u8_t qos, mqtt_request_
 
   mqtt_append_request(&client->pend_req_queue, r);
   mqtt_output_send(&client->output, client->conn);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1243,6 +1284,7 @@ mqtt_set_inpub_callback(mqtt_client_t *client, mqtt_incoming_publish_cb_t pub_cb
   client->data_cb = data_cb;
   client->pub_cb = pub_cb;
   client->inpub_arg = arg;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1254,6 +1296,7 @@ mqtt_client_t *
 mqtt_client_new(void)
 {
   LWIP_ASSERT_CORE_LOCKED();
+  __A_VARIABLE = 1;
   return (mqtt_client_t *)mem_calloc(1, sizeof(mqtt_client_t));
 }
 
@@ -1266,6 +1309,7 @@ void
 mqtt_client_free(mqtt_client_t *client)
 {
   mem_free(client);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1299,6 +1343,7 @@ mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port,
 
   if (client->conn_state != TCP_DISCONNECTED) {
     LWIP_DEBUGF(MQTT_DEBUG_WARN, ("mqtt_client_connect: Already connected\n"));
+    __A_VARIABLE = 1;
     return ERR_ISCONN;
   }
 
@@ -1359,6 +1404,7 @@ mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port,
   remaining_length = (u16_t)len;
 
   if (mqtt_output_check_space(&client->output, remaining_length) == 0) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -1371,6 +1417,7 @@ mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port,
     client->conn = altcp_tcp_new_ip_type(IP_GET_TYPE(ip_addr));
   }
   if (client->conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -1419,11 +1466,13 @@ mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ip_addr, u16_t port,
   if ((flags & MQTT_CONNECT_FLAG_PASSWORD) != 0) {
     mqtt_output_append_string(&client->output, client_info->client_pass, client_pass_len);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 
 tcp_fail:
   altcp_abort(client->conn);
   client->conn = NULL;
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -1444,6 +1493,7 @@ mqtt_disconnect(mqtt_client_t *client)
     client->conn_state = TCP_DISCONNECTED;
     mqtt_close(client, (mqtt_connection_status_t)0);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1457,6 +1507,7 @@ mqtt_client_is_connected(mqtt_client_t *client)
 {
   LWIP_ASSERT_CORE_LOCKED();
   LWIP_ASSERT("mqtt_client_is_connected: client != NULL", client);
+  __A_VARIABLE = 1;
   return client->conn_state == MQTT_CONNECTED;
 }
 
diff --git a/src/apps/netbiosns/netbiosns.c b/src/apps/netbiosns/netbiosns.c
index 6a605c8..f2e8138 100644
--- a/src/apps/netbiosns/netbiosns.c
+++ b/src/apps/netbiosns/netbiosns.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
   /**
  * @file
  * NetBIOS name service responder
@@ -263,6 +265,7 @@ netbiosns_name_decode(char *name_enc, char *name_dec, int name_dec_len)
     }
     if (!lwip_isupper(cname)) {
       /* Not legal. */
+      __A_VARIABLE = 1;
       return -1;
     }
     cname -= 'A';
@@ -272,6 +275,7 @@ netbiosns_name_decode(char *name_enc, char *name_dec, int name_dec_len)
     cname = *pname;
     if (!lwip_isupper(cname)) {
       /* Not legal. */
+      __A_VARIABLE = 1;
       return -1;
     }
     cname -= 'A';
@@ -285,6 +289,7 @@ netbiosns_name_decode(char *name_enc, char *name_dec, int name_dec_len)
     }
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -358,6 +363,7 @@ netbiosns_recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t
     if (p->len < (sizeof(struct netbios_hdr) + sizeof(struct netbios_question_hdr))) {
       /* packet too short */
       pbuf_free(p);
+      __A_VARIABLE = 1;
       return;
     }
     /* we only answer if we got a default interface */
@@ -468,6 +474,7 @@ netbiosns_recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t
     /* free the pbuf */
     pbuf_free(p);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -489,6 +496,7 @@ netbiosns_init(void)
     udp_bind(netbiosns_pcb, IP_ANY_TYPE, LWIP_IANA_PORT_NETBIOS);
     udp_recv(netbiosns_pcb, netbiosns_recv, netbiosns_pcb);
   }
+  __A_VARIABLE = 1;
 }
 
 #ifndef NETBIOS_LWIP_NAME
@@ -513,6 +521,7 @@ netbiosns_set_name(const char *hostname)
     netbiosns_local_name[i] = (char)lwip_toupper(hostname[i]);
   }
   netbiosns_local_name[copy_len] = '\0';
+  __A_VARIABLE = 1;
 }
 #endif /* NETBIOS_LWIP_NAME */
 
@@ -528,6 +537,7 @@ netbiosns_stop(void)
     udp_remove(netbiosns_pcb);
     netbiosns_pcb = NULL;
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_IPV4 && LWIP_UDP */
diff --git a/src/apps/smtp/smtp.c b/src/apps/smtp/smtp.c
index af2f053..0f55882 100644
--- a/src/apps/smtp/smtp.c
+++ b/src/apps/smtp/smtp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SMTP client module
@@ -320,8 +322,10 @@ const char*
 smtp_result_str(u8_t smtp_result)
 {
   if (smtp_result >= LWIP_ARRAYSIZE(smtp_result_strs)) {
+    __A_VARIABLE = 1;
     return "UNKNOWN";
   }
+  __A_VARIABLE = 1;
   return smtp_result_strs[smtp_result];
 }
 
@@ -333,9 +337,11 @@ static const char*
 smtp_pbuf_str(struct pbuf* p)
 {
   if ((p == NULL) || (p->len == 0)) {
+    __A_VARIABLE = 1;
     return "";
   }
   ((char*)p->payload)[p->len] = 0;
+  __A_VARIABLE = 1;
   return (const char*)p->payload;
 }
 #endif /* LWIP_DEBUG */
@@ -357,12 +363,14 @@ smtp_set_server_addr(const char* server)
     len = strlen(server);
   }
   if (len > SMTP_MAX_SERVERNAME_LEN) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   if (len != 0) {
     MEMCPY(smtp_server, server, len);
   }
   smtp_server[len] = 0; /* always OK because of smtp_server[SMTP_MAX_SERVERNAME_LEN + 1] */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -376,6 +384,7 @@ smtp_set_server_port(u16_t port)
 {
   LWIP_ASSERT_CORE_LOCKED();
   smtp_server_port = port;
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_ALTCP && LWIP_ALTCP_TLS
@@ -389,6 +398,7 @@ smtp_set_tls_config(struct altcp_tls_config *tls_config)
 {
   LWIP_ASSERT_CORE_LOCKED();
   smtp_server_tls_config = tls_config;
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -448,6 +458,7 @@ static void smtp_free_struct(struct smtp_session *s)
     SMTP_BODYDH_FREE(s->bodydh);
   }
   SMTP_STATE_FREE(s);
+  __A_VARIABLE = 1;
 }
 #else /* SMTP_BODYDH */
 #define smtp_free_struct(x) SMTP_STATE_FREE(x)
@@ -474,6 +485,7 @@ smtp_setup_pcb(struct smtp_session *s, const ip_addr_t* remote_ip)
     altcp_poll(pcb, smtp_tcp_poll, SMTP_POLL_INTERVAL);
     altcp_sent(pcb, smtp_tcp_sent);
   }
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -555,6 +567,7 @@ smtp_send_mail_alloced(struct smtp_session *s)
     LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, ("dns_gethostbyname failed: %d\n", (int)err));
     goto deallocate_and_leave;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 
 deallocate_and_leave:
@@ -565,6 +578,7 @@ deallocate_and_leave:
 leave:
   smtp_free_struct(s);
   /* no need to call the callback here since we return != ERR_OK */
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -598,12 +612,14 @@ smtp_send_mail(const char* from, const char* to, const char* subject, const char
   mem_len += from_len + to_len + subject_len + body_len + 4;
   if (mem_len > 0xffff) {
     /* too long! */
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   /* Allocate memory to keep this email's session state */
   s = (struct smtp_session *)SMTP_STATE_MALLOC((mem_size_t)mem_len);
   if (s == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   /* initialize the structure */
@@ -627,6 +643,7 @@ smtp_send_mail(const char* from, const char* to, const char* subject, const char
   s->callback_arg = callback_arg;
 
   /* call the actual implementation of this function */
+  __A_VARIABLE = 1;
   return smtp_send_mail_alloced(s);
 }
 
@@ -647,6 +664,7 @@ smtp_send_mail_static(const char *from, const char* to, const char* subject,
 
   s = (struct smtp_session*)SMTP_STATE_MALLOC(sizeof(struct smtp_session));
   if (s == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(s, 0, sizeof(struct smtp_session));
@@ -670,6 +688,7 @@ smtp_send_mail_static(const char *from, const char* to, const char* subject,
   s->callback_fn = callback_fn;
   s->callback_arg = callback_arg;
   /* call the actual implementation of this function */
+  __A_VARIABLE = 1;
   return smtp_send_mail_alloced(s);
 }
 
@@ -710,6 +729,7 @@ smtp_send_mail_int(void *arg)
   if ((err != ERR_OK) && (req->callback_fn != NULL)) {
     req->callback_fn(req->callback_arg, SMTP_RESULT_ERR_UNKNOWN, 0, err);
   }
+  __A_VARIABLE = 1;
 }
 
 #if SMTP_CHECK_DATA
@@ -765,6 +785,7 @@ smtp_free(struct smtp_session *s, u8_t result, u16_t srv_err, err_t err)
   if (fn != NULL) {
     fn(arg, result, srv_err, err);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Try to close a pcb and free the arg if successful */
@@ -787,6 +808,7 @@ smtp_close(struct smtp_session *s, struct altcp_pcb *pcb, u8_t result,
       smtp_free(s, result, srv_err, err);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** Raw API TCP err callback: pcb is already deallocated */
@@ -798,6 +820,7 @@ smtp_tcp_err(void *arg, err_t err)
     LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, ("smtp_tcp_err: connection reset by remote host\n"));
     smtp_free((struct smtp_session*)arg, SMTP_RESULT_ERR_CLOSED, 0, err);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Raw API TCP poll callback */
@@ -811,6 +834,7 @@ smtp_tcp_poll(void *arg, struct altcp_pcb *pcb)
     }
   }
   smtp_process(arg, pcb, NULL);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -822,6 +846,7 @@ smtp_tcp_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
 
   smtp_process(arg, pcb, NULL);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -837,6 +862,7 @@ smtp_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t err)
     LWIP_DEBUGF(SMTP_DEBUG_WARN_STATE, ("smtp_tcp_recv: connection closed by remote host\n"));
     smtp_close((struct smtp_session*)arg, pcb, SMTP_RESULT_ERR_CLOSED, 0, err);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -852,6 +878,7 @@ smtp_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
     LWIP_DEBUGF(SMTP_DEBUG_WARN, ("smtp_connected: %d\n", (int)err));
     smtp_close((struct smtp_session*)arg, pcb, SMTP_RESULT_ERR_CONNECT, 0, err);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -941,6 +968,7 @@ smtp_base64_encode(char* target, size_t target_len, const char* source, size_t s
   for (i = len - longer; i < len; i++) {
     target[i] = '=';
   }
+  __A_VARIABLE = 1;
   return len;
 }
 #endif /* SMTP_SUPPORT_AUTH_PLAIN || SMTP_SUPPORT_AUTH_LOGIN */
@@ -958,19 +986,23 @@ smtp_is_response(struct smtp_session *s)
   long num;
 
   if (s->p == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   /* copy three digits and convert them to int */
   if (pbuf_copy_partial(s->p, digits, 3, 0) != 3) {
     /* pbuf was too short */
+    __A_VARIABLE = 1;
     return 0;
   }
   digits[3] = 0;
   num = strtol(digits, NULL, 10);
   if ((num <= 0) || (num >= 1000)) {
     /* failed to find response code at start of line */
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return (u16_t)num;
 }
 
@@ -1042,6 +1074,7 @@ smtp_prepare_helo(struct smtp_session *s, u16_t *tx_buf_len, struct altcp_pcb *p
   SMEMCPY(s->tx_buf, SMTP_CMD_EHLO_1, SMTP_CMD_EHLO_1_LEN);
   MEMCPY(&s->tx_buf[SMTP_CMD_EHLO_1_LEN], ipa, ipa_len);
   SMEMCPY(&s->tx_buf[SMTP_CMD_EHLO_1_LEN + ipa_len], SMTP_CMD_EHLO_2, SMTP_CMD_EHLO_2_LEN);
+  __A_VARIABLE = 1;
   return SMTP_HELO;
 }
 
@@ -1116,6 +1149,7 @@ smtp_prepare_auth_login_uname(struct smtp_session *s, u16_t *tx_buf_len)
 
   SMEMCPY(&s->tx_buf[base64_len], SMTP_CRLF, SMTP_CRLF_LEN);
   s->tx_buf[*tx_buf_len] = 0;
+  __A_VARIABLE = 1;
   return SMTP_AUTH_LOGIN_PASS;
 }
 
@@ -1132,6 +1166,7 @@ smtp_prepare_auth_login_pass(struct smtp_session *s, u16_t *tx_buf_len)
 
   SMEMCPY(&s->tx_buf[base64_len], SMTP_CRLF, SMTP_CRLF_LEN);
   s->tx_buf[*tx_buf_len] = 0;
+  __A_VARIABLE = 1;
   return SMTP_AUTH_LOGIN;
 }
 #endif /* SMTP_SUPPORT_AUTH_LOGIN */
@@ -1150,6 +1185,7 @@ smtp_prepare_mail(struct smtp_session *s, u16_t *tx_buf_len)
   MEMCPY(target, s->from, s->from_len);
   target += s->from_len;
   SMEMCPY(target, SMTP_CMD_MAIL_2, SMTP_CMD_MAIL_2_LEN);
+  __A_VARIABLE = 1;
   return SMTP_MAIL;
 }
 
@@ -1167,6 +1203,7 @@ smtp_prepare_rcpt(struct smtp_session *s, u16_t *tx_buf_len)
   MEMCPY(target, s->to, s->to_len);
   target += s->to_len;
   SMEMCPY(target, SMTP_CMD_RCPT_2, SMTP_CMD_RCPT_2_LEN);
+  __A_VARIABLE = 1;
   return SMTP_RCPT;
 }
 
@@ -1196,6 +1233,7 @@ smtp_prepare_header(struct smtp_session *s, u16_t *tx_buf_len)
   target += s->subject_len;
   SMEMCPY(target, SMTP_CMD_HEADER_4, SMTP_CMD_HEADER_4_LEN);
 
+  __A_VARIABLE = 1;
   return SMTP_BODY;
 }
 
@@ -1207,6 +1245,7 @@ smtp_prepare_quit(struct smtp_session *s, u16_t *tx_buf_len)
   s->tx_buf[*tx_buf_len] = 0;
   SMEMCPY(s->tx_buf, SMTP_CMD_QUIT, SMTP_CMD_QUIT_LEN);
   LWIP_ASSERT("tx_buf overflow detected", *tx_buf_len <= SMTP_TX_BUF_LEN);
+  __A_VARIABLE = 1;
   return SMTP_CLOSED;
 }
 
@@ -1257,6 +1296,7 @@ smtp_send_body(struct smtp_session *s, struct altcp_pcb *pcb)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** State machine-like implementation of an SMTP client.
@@ -1455,10 +1495,13 @@ smtp_send_bodyh_data(struct altcp_pcb *pcb, const char **from, u16_t *howmany)
   if (err == ERR_OK) {
     *from += len;
     if ((*howmany -= len) > 0) {
+      __A_VARIABLE = 1;
       return BDHSOMEDATASENT;
     }
+    __A_VARIABLE = 1;
     return BDHALLDATASENT;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1475,12 +1518,14 @@ smtp_send_mail_bodycback(const char *from, const char* to, const char* subject,
 
   s = (struct smtp_session*)SMTP_STATE_MALLOC(sizeof(struct smtp_session));
   if (s == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(s, 0, sizeof(struct smtp_session));
   s->bodydh = (struct smtp_bodydh_state*)SMTP_BODYDH_MALLOC(sizeof(struct smtp_bodydh_state));
   if (s->bodydh == NULL) {
     SMTP_STATE_FREE(s);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(s->bodydh, 0, sizeof(struct smtp_bodydh_state));
@@ -1504,6 +1549,7 @@ smtp_send_mail_bodycback(const char *from, const char* to, const char* subject,
   s->bodydh->callback_fn = bodycback_fn;
   s->bodydh->state = BDH_SENDING;
   /* call the actual implementation of this function */
+  __A_VARIABLE = 1;
   return smtp_send_mail_alloced(s);
 }
 
@@ -1522,6 +1568,7 @@ smtp_send_body_data_handler(struct smtp_session *s, struct altcp_pcb *pcb)
     if((res = smtp_send_bodyh_data(pcb, (const char **)&s->body, &s->body_len))
         != BDHALLDATASENT) {
       s->body_sent = s->body_len - 1;
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -1549,6 +1596,7 @@ smtp_send_body_data_handler(struct smtp_session *s, struct altcp_pcb *pcb)
     LWIP_DEBUGF(SMTP_DEBUG_TRACE, ("smtp_send_body_data_handler: pause\n"));
     s->body_sent = s->body_len - 1;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* SMTP_BODYDH */
 
diff --git a/src/apps/snmp/snmp_asn1.c b/src/apps/snmp/snmp_asn1.c
index 8e91e75..9606806 100644
--- a/src/apps/snmp/snmp_asn1.c
+++ b/src/apps/snmp/snmp_asn1.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Abstract Syntax Notation One (ISO 8824, 8825) encoding
@@ -134,6 +136,7 @@ snmp_asn1_enc_raw(struct snmp_pbuf_stream *pbuf_stream, const u8_t *raw, u16_t r
 {
   PBUF_OP_EXEC(snmp_pbuf_stream_writebuf(pbuf_stream, raw, raw_len));
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -151,6 +154,7 @@ err_t
 snmp_asn1_enc_u32t(struct snmp_pbuf_stream *pbuf_stream, u16_t octets_needed, u32_t value)
 {
   if (octets_needed > 5) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   if (octets_needed == 5) {
@@ -167,6 +171,7 @@ snmp_asn1_enc_u32t(struct snmp_pbuf_stream *pbuf_stream, u16_t octets_needed, u3
   /* (only) one least significant octet */
   PBUF_OP_EXEC(snmp_pbuf_stream_write(pbuf_stream, (u8_t)value));
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 /**
@@ -191,6 +196,7 @@ snmp_asn1_enc_s32t(struct snmp_pbuf_stream *pbuf_stream, u16_t octets_needed, s3
   /* (only) one least significant octet */
   PBUF_OP_EXEC(snmp_pbuf_stream_write(pbuf_stream, (u8_t)value));
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -259,6 +265,7 @@ snmp_asn1_enc_length_cnt(u16_t length, u8_t *octets_needed)
   } else {
     *octets_needed = 3;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -285,6 +292,7 @@ snmp_asn1_enc_u32t_cnt(u32_t value, u16_t *octets_needed)
   } else {
     *octets_needed = 5;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -310,6 +318,7 @@ snmp_asn1_enc_s32t_cnt(s32_t value, u16_t *octets_needed)
   } else {
     *octets_needed = 4;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -343,6 +352,7 @@ snmp_asn1_enc_oid_cnt(const u32_t *oid, u16_t oid_len, u16_t *octets_needed)
     }
     oid++;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -438,10 +448,12 @@ snmp_asn1_dec_u32t(struct snmp_pbuf_stream *pbuf_stream, u16_t len, u32_t *value
         *value |= data;
       }
 
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
 
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -478,9 +490,11 @@ snmp_asn1_dec_s32t(struct snmp_pbuf_stream *pbuf_stream, u16_t len, s32_t *value
       *value = (*value << 8) | data;
       len--;
     }
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -590,6 +604,7 @@ snmp_asn1_dec_raw(struct snmp_pbuf_stream *pbuf_stream, u16_t len, u8_t *buf, u1
 {
   if (len > buf_max_len) {
     /* not enough dst space */
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   *buf_len = len;
@@ -600,6 +615,7 @@ snmp_asn1_dec_raw(struct snmp_pbuf_stream *pbuf_stream, u16_t len, u8_t *buf, u1
     len--;
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -626,6 +642,7 @@ snmp_asn1_enc_u64t_cnt(u64_t value, u16_t *octets_needed)
     snmp_asn1_enc_u32t_cnt((u32_t)(value >> 32), octets_needed);
     *octets_needed = *octets_needed + 4; /* add the 4 bytes of low u32 */
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -660,10 +677,12 @@ snmp_asn1_dec_u64t(struct snmp_pbuf_stream *pbuf_stream, u16_t len, u64_t *value
         len--;
       }
 
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
 
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -681,6 +700,7 @@ err_t
 snmp_asn1_enc_u64t(struct snmp_pbuf_stream *pbuf_stream, u16_t octets_needed, u64_t value)
 {
   if (octets_needed > 9) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   if (octets_needed == 9) {
@@ -697,6 +717,7 @@ snmp_asn1_enc_u64t(struct snmp_pbuf_stream *pbuf_stream, u16_t octets_needed, u6
   /* always write at least one octet (also in case of value == 0) */
   PBUF_OP_EXEC(snmp_pbuf_stream_write(pbuf_stream, (u8_t)(value)));
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif
diff --git a/src/apps/snmp/snmp_core.c b/src/apps/snmp/snmp_core.c
index 2b50716..0276240 100644
--- a/src/apps/snmp/snmp_core.c
+++ b/src/apps/snmp/snmp_core.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * MIB tree access/construction functions.
@@ -240,6 +242,7 @@ snmp_set_mibs(const struct snmp_mib **mibs, u8_t num_mibs)
   LWIP_ASSERT("num_mibs pointer must be != 0", (num_mibs != 0));
   snmp_mibs     = mibs;
   snmp_num_mibs = num_mibs;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -264,6 +267,7 @@ void snmp_set_device_enterprise_oid(const struct snmp_obj_id *device_enterprise_
   } else {
     snmp_device_enterprise_oid = device_enterprise_oid;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -273,6 +277,7 @@ void snmp_set_device_enterprise_oid(const struct snmp_obj_id *device_enterprise_
 const struct snmp_obj_id *snmp_get_device_enterprise_oid(void)
 {
   LWIP_ASSERT_CORE_LOCKED();
+  __A_VARIABLE = 1;
   return snmp_device_enterprise_oid;
 }
 
@@ -290,10 +295,12 @@ snmp_oid_to_ip4(const u32_t *oid, ip4_addr_t *ip)
       (oid[2] > 0xFF) ||
       (oid[3] > 0xFF)) {
     ip4_addr_copy(*ip, *IP4_ADDR_ANY4);
+    __A_VARIABLE = 1;
     return 0;
   }
 
   IP4_ADDR(ip, oid[0], oid[1], oid[2], oid[3]);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -309,6 +316,7 @@ snmp_ip4_to_oid(const ip4_addr_t *ip, u32_t *oid)
   oid[1] = ip4_addr2(ip);
   oid[2] = ip4_addr3(ip);
   oid[3] = ip4_addr4(ip);
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_IPV4 */
 
@@ -338,6 +346,7 @@ snmp_oid_to_ip6(const u32_t *oid, ip6_addr_t *ip)
       (oid[14] > 0xFF) ||
       (oid[15] > 0xFF)) {
     ip6_addr_set_any(ip);
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -345,6 +354,7 @@ snmp_oid_to_ip6(const u32_t *oid, ip6_addr_t *ip)
   ip->addr[1] = (oid[4]  << 24) | (oid[5]  << 16) | (oid[6]  << 8) | (oid[7]  << 0);
   ip->addr[2] = (oid[8]  << 24) | (oid[9]  << 16) | (oid[10] << 8) | (oid[11] << 0);
   ip->addr[3] = (oid[12] << 24) | (oid[13] << 16) | (oid[14] << 8) | (oid[15] << 0);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -372,6 +382,7 @@ snmp_ip6_to_oid(const ip6_addr_t *ip, u32_t *oid)
   oid[13] = (ip->addr[3] & 0x00FF0000) >> 16;
   oid[14] = (ip->addr[3] & 0x0000FF00) >>  8;
   oid[15] = (ip->addr[3] & 0x000000FF) >>  0;
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_IPV6 */
 
@@ -392,6 +403,7 @@ snmp_ip_port_to_oid(const ip_addr_t *ip, u16_t port, u32_t *oid)
   oid[idx] = port;
   idx++;
 
+  __A_VARIABLE = 1;
   return idx;
 }
 
@@ -520,19 +532,23 @@ snmp_oid_to_ip_port(const u32_t *oid, u8_t oid_len, ip_addr_t *ip, u16_t *port)
   /* InetAddressType + InetAddress */
   idx = snmp_oid_to_ip(&oid[0], oid_len, ip);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
   /* InetPortNumber */
   if (oid_len < (idx + 1)) {
+    __A_VARIABLE = 1;
     return 0;
   }
   if (oid[idx] > 0xffff) {
+    __A_VARIABLE = 1;
     return 0;
   }
   *port = (u16_t)oid[idx];
   idx++;
 
+  __A_VARIABLE = 1;
   return idx;
 }
 
@@ -554,6 +570,7 @@ snmp_oid_assign(struct snmp_obj_id *target, const u32_t *oid, u8_t oid_len)
   if (oid_len > 0) {
     MEMCPY(target->id, oid, oid_len * sizeof(u32_t));
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -577,6 +594,7 @@ snmp_oid_prefix(struct snmp_obj_id *target, const u32_t *oid, u8_t oid_len)
     /* paste oid at the beginning */
     MEMCPY(target->id, oid, oid_len * sizeof(u32_t));
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -592,6 +610,7 @@ snmp_oid_combine(struct snmp_obj_id *target, const u32_t *oid1, u8_t oid1_len, c
 {
   snmp_oid_assign(target, oid1, oid1_len);
   snmp_oid_append(target, oid2, oid2_len);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -609,6 +628,7 @@ snmp_oid_append(struct snmp_obj_id *target, const u32_t *oid, u8_t oid_len)
     MEMCPY(&target->id[target->len], oid, oid_len * sizeof(u32_t));
     target->len = (u8_t)(target->len + oid_len);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -628,9 +648,11 @@ snmp_oid_compare(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_
 
   while ((level < oid1_len) && (level < oid2_len)) {
     if (*oid1 < *oid2) {
+      __A_VARIABLE = 1;
       return -1;
     }
     if (*oid1 > *oid2) {
+      __A_VARIABLE = 1;
       return 1;
     }
 
@@ -641,13 +663,16 @@ snmp_oid_compare(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_
 
   /* common part of both OID's is equal, compare length */
   if (oid1_len < oid2_len) {
+    __A_VARIABLE = 1;
     return -1;
   }
   if (oid1_len > oid2_len) {
+    __A_VARIABLE = 1;
     return 1;
   }
 
   /* they are equal */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -663,6 +688,7 @@ snmp_oid_compare(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_
 u8_t
 snmp_oid_equal(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len)
 {
+  __A_VARIABLE = 1;
   return (snmp_oid_compare(oid1, oid1_len, oid2, oid2_len) == 0) ? 1 : 0;
 }
 
@@ -674,6 +700,7 @@ snmp_oid_equal(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_le
 u8_t
 netif_to_num(const struct netif *netif)
 {
+  __A_VARIABLE = 1;
   return netif_get_index(netif);
 }
 
@@ -690,6 +717,7 @@ snmp_get_mib_from_oid(const u32_t *oid, u8_t oid_len)
   LWIP_ASSERT("'oid' param must not be NULL!", (oid != NULL));
 
   if (oid_len == 0) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -719,6 +747,7 @@ snmp_get_mib_from_oid(const u32_t *oid, u8_t oid_len)
     }
   }
 
+  __A_VARIABLE = 1;
   return matched_mib;
 }
 
@@ -731,6 +760,7 @@ snmp_get_next_mib(const u32_t *oid, u8_t oid_len)
   LWIP_ASSERT("'oid' param must not be NULL!", (oid != NULL));
 
   if (oid_len == 0) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -747,6 +777,7 @@ snmp_get_next_mib(const u32_t *oid, u8_t oid_len)
     }
   }
 
+  __A_VARIABLE = 1;
   return next_mib;
 }
 
@@ -760,10 +791,12 @@ snmp_get_mib_between(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t o
 
   if (next_mib != NULL) {
     if (snmp_oid_compare(next_mib->base_oid, next_mib->base_oid_len, oid2, oid2_len) < 0) {
+      __A_VARIABLE = 1;
       return next_mib;
     }
   }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -804,6 +837,7 @@ snmp_get_node_instance_from_oid(const u32_t *oid, u8_t oid_len, struct snmp_node
     }
   }
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -969,9 +1003,11 @@ snmp_get_next_node_instance_from_oid(const u32_t *oid, u8_t oid_len, snmp_valida
 
   if (mib == NULL) {
     /* loop is only left when mib == null (error) or mib_node != NULL (success) */
+    __A_VARIABLE = 1;
     return SNMP_ERR_ENDOFMIBVIEW;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -998,6 +1034,7 @@ snmp_mib_tree_resolve_exact(const struct snmp_mib *mib, const u32_t *oid, u8_t o
 
     if (i == 0) {
       /* no matching subnode found */
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -1007,9 +1044,11 @@ snmp_mib_tree_resolve_exact(const struct snmp_mib *mib, const u32_t *oid, u8_t o
   if ((*node)->node_type != SNMP_NODE_TREE) {
     /* we found a leaf node */
     *oid_instance_len = oid_len - oid_offset;
+    __A_VARIABLE = 1;
     return (*node);
   }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -1120,6 +1159,7 @@ snmp_next_oid_init(struct snmp_next_oid_state *state,
   state->next_oid_len     = 0;
   state->next_oid_max_len = next_oid_max_len;
   state->status           = SNMP_NEXT_OID_STATUS_NO_MATCH;
+  __A_VARIABLE = 1;
 }
 
 /** checks if the passed incomplete OID may be a possible candidate for snmp_next_oid_check();
@@ -1136,11 +1176,13 @@ snmp_next_oid_precheck(struct snmp_next_oid_state *state, const u32_t *oid, u8_t
       /* check if new oid is located closer to start oid than current closest oid */
       if ((state->status == SNMP_NEXT_OID_STATUS_NO_MATCH) ||
           (snmp_oid_compare(oid, oid_len, state->next_oid, state->next_oid_len) < 0)) {
+        __A_VARIABLE = 1;
         return 1;
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1177,15 +1219,18 @@ snmp_oid_in_range(const u32_t *oid_in, u8_t oid_len, const struct snmp_oid_range
   u8_t i;
 
   if (oid_len != oid_ranges_len) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
   for (i = 0; i < oid_ranges_len; i++) {
     if ((oid_in[i] < oid_ranges[i].min) || (oid_in[i] > oid_ranges[i].max)) {
+      __A_VARIABLE = 1;
       return 0;
     }
   }
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1196,6 +1241,7 @@ snmp_set_test_ok(struct snmp_node_instance *instance, u16_t value_len, void *val
   LWIP_UNUSED_ARG(value_len);
   LWIP_UNUSED_ARG(value);
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -1323,6 +1369,7 @@ snmp_encode_bits(u8_t *buf, u32_t buf_len, u32_t bit_value, u8_t bit_count)
     }
   }
 
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -1338,6 +1385,7 @@ snmp_encode_truthvalue(s32_t *asn1_value, u32_t bool_value)
   */
 
   if (asn1_value == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -1347,6 +1395,7 @@ snmp_encode_truthvalue(s32_t *asn1_value, u32_t bool_value)
     *asn1_value = 2; /* defined by RFC1443 */
   }
 
+  __A_VARIABLE = 1;
   return sizeof(s32_t);
 }
 
diff --git a/src/apps/snmp/snmp_mib2.c b/src/apps/snmp/snmp_mib2.c
index dc49ae6..dfff66c 100644
--- a/src/apps/snmp/snmp_mib2.c
+++ b/src/apps/snmp/snmp_mib2.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) objects and functions.
@@ -68,6 +70,7 @@ snmp_mib2_lwip_synchronizer(snmp_threadsync_called_fn fn, void *arg)
 #else
   tcpip_callback(fn, arg);
 #endif
+  __A_VARIABLE = 1;
 }
 
 struct snmp_threadsync_instance snmp_mib2_lwip_locks;
diff --git a/src/apps/snmp/snmp_mib2_icmp.c b/src/apps/snmp/snmp_mib2_icmp.c
index 0a82375..0748fcc 100644
--- a/src/apps/snmp/snmp_mib2_icmp.c
+++ b/src/apps/snmp/snmp_mib2_icmp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) ICMP objects and functions.
@@ -63,87 +65,114 @@ icmp_get_value(const struct snmp_scalar_array_node_def *node, void *value)
   switch (node->oid) {
     case 1: /* icmpInMsgs */
       *uint_ptr = STATS_GET(mib2.icmpinmsgs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 2: /* icmpInErrors */
       *uint_ptr = STATS_GET(mib2.icmpinerrors);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 3: /* icmpInDestUnreachs */
       *uint_ptr = STATS_GET(mib2.icmpindestunreachs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 4: /* icmpInTimeExcds */
       *uint_ptr = STATS_GET(mib2.icmpintimeexcds);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 5: /* icmpInParmProbs */
       *uint_ptr = STATS_GET(mib2.icmpinparmprobs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 6: /* icmpInSrcQuenchs */
       *uint_ptr = STATS_GET(mib2.icmpinsrcquenchs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 7: /* icmpInRedirects */
       *uint_ptr = STATS_GET(mib2.icmpinredirects);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 8: /* icmpInEchos */
       *uint_ptr = STATS_GET(mib2.icmpinechos);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 9: /* icmpInEchoReps */
       *uint_ptr = STATS_GET(mib2.icmpinechoreps);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 10: /* icmpInTimestamps */
       *uint_ptr = STATS_GET(mib2.icmpintimestamps);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 11: /* icmpInTimestampReps */
       *uint_ptr = STATS_GET(mib2.icmpintimestampreps);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 12: /* icmpInAddrMasks */
       *uint_ptr = STATS_GET(mib2.icmpinaddrmasks);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 13: /* icmpInAddrMaskReps */
       *uint_ptr = STATS_GET(mib2.icmpinaddrmaskreps);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 14: /* icmpOutMsgs */
       *uint_ptr = STATS_GET(mib2.icmpoutmsgs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 15: /* icmpOutErrors */
       *uint_ptr = STATS_GET(mib2.icmpouterrors);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 16: /* icmpOutDestUnreachs */
       *uint_ptr = STATS_GET(mib2.icmpoutdestunreachs);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 17: /* icmpOutTimeExcds */
       *uint_ptr = STATS_GET(mib2.icmpouttimeexcds);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 18: /* icmpOutParmProbs: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 19: /* icmpOutSrcQuenchs: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 20: /* icmpOutRedirects: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 21: /* icmpOutEchos */
       *uint_ptr = STATS_GET(mib2.icmpoutechos);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 22: /* icmpOutEchoReps */
       *uint_ptr = STATS_GET(mib2.icmpoutechoreps);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 23: /* icmpOutTimestamps: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 24: /* icmpOutTimestampReps: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 25: /* icmpOutAddrMasks: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 26: /* icmpOutAddrMaskReps: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("icmp_get_value(): unknown id: %"S32_F"\n", node->oid));
       break;
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_interfaces.c b/src/apps/snmp/snmp_mib2_interfaces.c
index c53ce9e..0052a37 100644
--- a/src/apps/snmp/snmp_mib2_interfaces.c
+++ b/src/apps/snmp/snmp_mib2_interfaces.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) INTERFACES objects and functions.
@@ -71,9 +73,11 @@ interfaces_get_value(struct snmp_node_instance *instance, void *value)
     }
 
     *sint_ptr = num_netifs;
+    __A_VARIABLE = 1;
     return sizeof(*sint_ptr);
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -101,6 +105,7 @@ interfaces_Table_get_cell_instance(const u32_t *column, const u32_t *row_oid, u8
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(row_oid, row_oid_len, interfaces_Table_oid_ranges, LWIP_ARRAYSIZE(interfaces_Table_oid_ranges))) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -112,11 +117,13 @@ interfaces_Table_get_cell_instance(const u32_t *column, const u32_t *row_oid, u8
     if (netif_to_num(netif) == ifIndex) {
       /* store netif pointer for subsequent operations (get/test/set) */
       cell_instance->reference.ptr = netif;
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOERROR;
     }
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -146,10 +153,12 @@ interfaces_Table_get_next_cell_instance(const u32_t *column, struct snmp_obj_id
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* store netif pointer for subsequent operations (get/test/set) */
     cell_instance->reference.ptr = /* (struct netif*) */state.reference;
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOERROR;
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -264,9 +273,11 @@ interfaces_Table_get_value(struct snmp_node_instance *instance, void *value)
       MEMCPY(value, snmp_zero_dot_zero.id, value_len);
       break;
     default:
+      __A_VARIABLE = 1;
       return 0;
   }
 
+  __A_VARIABLE = 1;
   return value_len;
 }
 
@@ -283,9 +294,11 @@ interfaces_Table_set_test(struct snmp_node_instance *instance, u16_t len, void *
   LWIP_UNUSED_ARG(len);
 
   if (*sint_ptr == 1 || *sint_ptr == 2) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOERROR;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_WRONGVALUE;
 }
 
@@ -306,6 +319,7 @@ interfaces_Table_set_value(struct snmp_node_instance *instance, u16_t len, void
     netif_set_down(netif);
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_ip.c b/src/apps/snmp/snmp_mib2_ip.c
index de10990..d26b265 100644
--- a/src/apps/snmp/snmp_mib2_ip.c
+++ b/src/apps/snmp/snmp_mib2_ip.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) IP objects and functions.
@@ -73,39 +75,51 @@ ip_get_value(struct snmp_node_instance *instance, void *value)
       /* not-forwarding */
       *sint_ptr = 2;
 #endif
+      __A_VARIABLE = 1;
       return sizeof(*sint_ptr);
     case 2: /* ipDefaultTTL */
       *sint_ptr = IP_DEFAULT_TTL;
+      __A_VARIABLE = 1;
       return sizeof(*sint_ptr);
     case 3: /* ipInReceives */
       *uint_ptr = STATS_GET(mib2.ipinreceives);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 4: /* ipInHdrErrors */
       *uint_ptr = STATS_GET(mib2.ipinhdrerrors);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 5: /* ipInAddrErrors */
       *uint_ptr = STATS_GET(mib2.ipinaddrerrors);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 6: /* ipForwDatagrams */
       *uint_ptr = STATS_GET(mib2.ipforwdatagrams);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 7: /* ipInUnknownProtos */
       *uint_ptr = STATS_GET(mib2.ipinunknownprotos);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 8: /* ipInDiscards */
       *uint_ptr = STATS_GET(mib2.ipindiscards);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 9: /* ipInDelivers */
       *uint_ptr = STATS_GET(mib2.ipindelivers);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 10: /* ipOutRequests */
       *uint_ptr = STATS_GET(mib2.ipoutrequests);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 11: /* ipOutDiscards */
       *uint_ptr = STATS_GET(mib2.ipoutdiscards);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 12: /* ipOutNoRoutes */
       *uint_ptr = STATS_GET(mib2.ipoutnoroutes);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 13: /* ipReasmTimeout */
 #if IP_REASSEMBLY
@@ -113,33 +127,42 @@ ip_get_value(struct snmp_node_instance *instance, void *value)
 #else
       *sint_ptr = 0;
 #endif
+      __A_VARIABLE = 1;
       return sizeof(*sint_ptr);
     case 14: /* ipReasmReqds */
       *uint_ptr = STATS_GET(mib2.ipreasmreqds);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 15: /* ipReasmOKs */
       *uint_ptr = STATS_GET(mib2.ipreasmoks);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 16: /* ipReasmFails */
       *uint_ptr = STATS_GET(mib2.ipreasmfails);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 17: /* ipFragOKs */
       *uint_ptr = STATS_GET(mib2.ipfragoks);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 18: /* ipFragFails */
       *uint_ptr = STATS_GET(mib2.ipfragfails);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 19: /* ipFragCreates */
       *uint_ptr = STATS_GET(mib2.ipfragcreates);
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     case 23: /* ipRoutingDiscards: not supported -> always 0 */
       *uint_ptr = 0;
+      __A_VARIABLE = 1;
       return sizeof(*uint_ptr);
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("ip_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
       break;
   }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -183,6 +206,7 @@ ip_set_test(struct snmp_node_instance *instance, u16_t len, void *value)
       break;
   }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -193,6 +217,7 @@ ip_set_value(struct snmp_node_instance *instance, u16_t len, void *value)
   LWIP_UNUSED_ARG(len);
   LWIP_UNUSED_ARG(value);
   /* nothing to do here because in set_test we only accept values being the same as our own stored value -> no need to store anything */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -241,9 +266,11 @@ ip_AddrTable_get_cell_value_core(struct netif *netif, const u32_t *column, union
 #endif
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -255,6 +282,7 @@ ip_AddrTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row_
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(row_oid, row_oid_len, ip_AddrTable_oid_ranges, LWIP_ARRAYSIZE(ip_AddrTable_oid_ranges))) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -265,11 +293,13 @@ ip_AddrTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row_
   NETIF_FOREACH(netif) {
     if (ip4_addr_cmp(&ip, netif_ip4_addr(netif))) {
       /* fill in object properties */
+      __A_VARIABLE = 1;
       return ip_AddrTable_get_cell_value_core(netif, column, value, value_len);
     }
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -296,10 +326,12 @@ ip_AddrTable_get_next_cell_instance_and_value(const u32_t *column, struct snmp_o
   if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* fill in object properties */
+    __A_VARIABLE = 1;
     return ip_AddrTable_get_cell_value_core((struct netif *)state.reference, column, value, value_len);
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -386,9 +418,11 @@ ip_RouteTable_get_cell_value_core(struct netif *netif, u8_t default_route, const
       *value_len = snmp_zero_dot_zero.len * sizeof(u32_t);
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -400,6 +434,7 @@ ip_RouteTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(row_oid, row_oid_len, ip_RouteTable_oid_ranges, LWIP_ARRAYSIZE(ip_RouteTable_oid_ranges))) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -409,6 +444,7 @@ ip_RouteTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row
   /* default route is on default netif */
   if (ip4_addr_isany_val(test_ip) && (netif_default != NULL)) {
     /* fill in object properties */
+    __A_VARIABLE = 1;
     return ip_RouteTable_get_cell_value_core(netif_default, 1, column, value, value_len);
   }
 
@@ -419,11 +455,13 @@ ip_RouteTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row
 
     if (ip4_addr_cmp(&dst, &test_ip)) {
       /* fill in object properties */
+      __A_VARIABLE = 1;
       return ip_RouteTable_get_cell_value_core(netif, 0, column, value, value_len);
     }
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -506,9 +544,11 @@ ip_NetToMediaTable_get_cell_value_core(size_t arp_table_index, const u32_t *colu
       value->u32 = 3; /* dynamic*/
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -521,6 +561,7 @@ ip_NetToMediaTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(row_oid, row_oid_len, ip_NetToMediaTable_oid_ranges, LWIP_ARRAYSIZE(ip_NetToMediaTable_oid_ranges))) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -537,12 +578,14 @@ ip_NetToMediaTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_
     if (etharp_get_entry(i, &ip, &netif, &ethaddr)) {
       if ((netif_index == netif_to_num(netif)) && ip4_addr_cmp(&ip_in, ip)) {
         /* fill in object properties */
+        __A_VARIABLE = 1;
         return ip_NetToMediaTable_get_cell_value_core(i, column, value, value_len);
       }
     }
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -577,10 +620,12 @@ ip_NetToMediaTable_get_next_cell_instance_and_value(const u32_t *column, struct
   if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* fill in object properties */
+    __A_VARIABLE = 1;
     return ip_NetToMediaTable_get_cell_value_core(LWIP_PTR_NUMERIC_CAST(size_t, state.reference), column, value, value_len);
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_snmp.c b/src/apps/snmp/snmp_mib2_snmp.c
index 6661c83..c6da13e 100644
--- a/src/apps/snmp/snmp_mib2_snmp.c
+++ b/src/apps/snmp/snmp_mib2_snmp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) SNMP objects and functions.
@@ -146,9 +148,11 @@ snmp_get_value(const struct snmp_scalar_array_node_def *node, void *value)
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("snmp_get_value(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return 0;
   }
 
+  __A_VARIABLE = 1;
   return sizeof(*uint_ptr);
 }
 
@@ -167,6 +171,7 @@ snmp_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *va
       ret = SNMP_ERR_NOERROR;
     }
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -185,6 +190,7 @@ snmp_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *v
     }
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_system.c b/src/apps/snmp/snmp_mib2_system.c
index ce28892..303337d 100644
--- a/src/apps/snmp/snmp_mib2_system.c
+++ b/src/apps/snmp/snmp_mib2_system.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) SYSTEM objects and functions.
@@ -99,6 +101,7 @@ snmp_mib2_set_sysdescr(const u8_t *str, const u16_t *len)
     sysdescr     = str;
     sysdescr_len = len;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -124,6 +127,7 @@ snmp_mib2_set_syscontact(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize)
     syscontact_wr_len  = ocstrlen;
     syscontact_bufsize = bufsize;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -140,6 +144,7 @@ snmp_mib2_set_syscontact_readonly(const u8_t *ocstr, const u16_t *ocstrlen)
     syscontact_wr_len  = NULL;
     syscontact_bufsize = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -166,6 +171,7 @@ snmp_mib2_set_sysname(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize)
     sysname_wr_len  = ocstrlen;
     sysname_bufsize = bufsize;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -182,6 +188,7 @@ snmp_mib2_set_sysname_readonly(const u8_t *ocstr, const u16_t *ocstrlen)
     sysname_wr_len  = NULL;
     sysname_bufsize = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -207,6 +214,7 @@ snmp_mib2_set_syslocation(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize)
     syslocation_wr_len  = ocstrlen;
     syslocation_bufsize = bufsize;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -223,6 +231,7 @@ snmp_mib2_set_syslocation_readonly(const u8_t *ocstr, const u16_t *ocstrlen)
     syslocation_wr_len  = NULL;
     syslocation_bufsize = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -241,10 +250,12 @@ system_get_value(const struct snmp_scalar_array_node_def *node, void *value)
     case 2: { /* sysObjectID */
       const struct snmp_obj_id *dev_enterprise_oid = snmp_get_device_enterprise_oid();
       MEMCPY(value, dev_enterprise_oid->id, dev_enterprise_oid->len * sizeof(u32_t));
+      __A_VARIABLE = 1;
       return dev_enterprise_oid->len * sizeof(u32_t);
     }
     case 3: /* sysUpTime */
       MIB2_COPY_SYSUPTIME_TO((u32_t *)value);
+      __A_VARIABLE = 1;
       return sizeof(u32_t);
     case 4: /* sysContact */
       var     = syscontact;
@@ -260,9 +271,11 @@ system_get_value(const struct snmp_scalar_array_node_def *node, void *value)
       break;
     case 7: /* sysServices */
       *(s32_t *)value = SNMP_SYSSERVICES;
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("system_get_value(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return 0;
   }
 
@@ -274,6 +287,7 @@ system_get_value(const struct snmp_scalar_array_node_def *node, void *value)
     result = *var_len;
   }
   MEMCPY(value, var, result);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -301,6 +315,7 @@ system_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("system_set_test(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return ret;
   }
 
@@ -320,6 +335,7 @@ system_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *
     ret = SNMP_ERR_NOTWRITABLE;
   }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -344,6 +360,7 @@ system_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("system_set_value(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return SNMP_ERR_GENERROR;
   }
 
@@ -358,6 +375,7 @@ system_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void
     *var_wr_len = len;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_tcp.c b/src/apps/snmp/snmp_mib2_tcp.c
index 61cf2db..52dd888 100644
--- a/src/apps/snmp/snmp_mib2_tcp.c
+++ b/src/apps/snmp/snmp_mib2_tcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) TCP objects and functions.
@@ -193,9 +195,11 @@ tcp_ConnTable_get_cell_value_core(struct tcp_pcb *pcb, const u32_t *column, unio
       break;
     default:
       LWIP_ASSERT("invalid id", 0);
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -297,10 +301,12 @@ tcp_ConnTable_get_next_cell_instance_and_value(const u32_t *column, struct snmp_
   if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* fill in object properties */
+    __A_VARIABLE = 1;
     return tcp_ConnTable_get_cell_value_core((struct tcp_pcb *)state.reference, column, value, value_len);
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -320,9 +326,11 @@ tcp_ConnectionTable_get_cell_value_core(const u32_t *column, struct tcp_pcb *pcb
       value->u32 = 0; /* not supported */
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -341,12 +349,14 @@ tcp_ConnectionTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8
   /* tcpConnectionLocalAddressType + tcpConnectionLocalAddress + tcpConnectionLocalPort */
   idx += snmp_oid_to_ip_port(&row_oid[idx], row_oid_len - idx, &local_ip, &local_port);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   /* tcpConnectionRemAddressType + tcpConnectionRemAddress + tcpConnectionRemPort */
   idx += snmp_oid_to_ip_port(&row_oid[idx], row_oid_len - idx, &remote_ip, &remote_port);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -360,6 +370,7 @@ tcp_ConnectionTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8
           ip_addr_cmp(&remote_ip, &pcb->remote_ip) &&
           (remote_port == pcb->remote_port)) {
         /* fill in object properties */
+        __A_VARIABLE = 1;
         return tcp_ConnectionTable_get_cell_value_core(column, pcb, value);
       }
       pcb = pcb->next;
@@ -367,6 +378,7 @@ tcp_ConnectionTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -429,9 +441,11 @@ tcp_ListenerTable_get_cell_value_core(const u32_t *column, union snmp_variant_va
       value->u32 = 0; /* not supported */
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -448,6 +462,7 @@ tcp_ListenerTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t
   /* tcpListenerLocalAddressType + tcpListenerLocalAddress + tcpListenerLocalPort */
   idx += snmp_oid_to_ip_port(&row_oid[idx], row_oid_len - idx, &local_ip, &local_port);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -457,12 +472,14 @@ tcp_ListenerTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t
     if (ip_addr_cmp(&local_ip, &pcb->local_ip) &&
         (local_port == pcb->local_port)) {
       /* fill in object properties */
+      __A_VARIABLE = 1;
       return tcp_ListenerTable_get_cell_value_core(column, value);
     }
     pcb = pcb->next;
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
diff --git a/src/apps/snmp/snmp_mib2_udp.c b/src/apps/snmp/snmp_mib2_udp.c
index 3c89029..33d1700 100644
--- a/src/apps/snmp/snmp_mib2_udp.c
+++ b/src/apps/snmp/snmp_mib2_udp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Management Information Base II (RFC1213) UDP objects and functions.
@@ -108,9 +110,11 @@ udp_endpointTable_get_cell_value_core(const u32_t *column, union snmp_variant_va
       value->u32 = 0; /* not supported */
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -127,20 +131,24 @@ udp_endpointTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t
   /* udpEndpointLocalAddressType + udpEndpointLocalAddress + udpEndpointLocalPort */
   idx += snmp_oid_to_ip_port(&row_oid[idx], row_oid_len - idx, &local_ip, &local_port);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   /* udpEndpointRemoteAddressType + udpEndpointRemoteAddress + udpEndpointRemotePort */
   idx += snmp_oid_to_ip_port(&row_oid[idx], row_oid_len - idx, &remote_ip, &remote_port);
   if (idx == 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   /* udpEndpointInstance */
   if (row_oid_len < (idx + 1)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
   if (row_oid[idx] != 0) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -152,12 +160,14 @@ udp_endpointTable_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t
         ip_addr_cmp(&remote_ip, &pcb->remote_ip) &&
         (remote_port == pcb->remote_port)) {
       /* fill in object properties */
+      __A_VARIABLE = 1;
       return udp_endpointTable_get_cell_value_core(column, value);
     }
     pcb = pcb->next;
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -237,9 +247,11 @@ udp_Table_get_cell_value_core(struct udp_pcb *pcb, const u32_t *column, union sn
       value->u32 = pcb->local_port;
       break;
     default:
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -252,6 +264,7 @@ udp_Table_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row_oid
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(row_oid, row_oid_len, udp_Table_oid_ranges, LWIP_ARRAYSIZE(udp_Table_oid_ranges))) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -265,6 +278,7 @@ udp_Table_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row_oid
     if (IP_IS_V4_VAL(pcb->local_ip)) {
       if (ip4_addr_cmp(&ip, ip_2_ip4(&pcb->local_ip)) && (port == pcb->local_port)) {
         /* fill in object properties */
+        __A_VARIABLE = 1;
         return udp_Table_get_cell_value_core(pcb, column, value, value_len);
       }
     }
@@ -272,6 +286,7 @@ udp_Table_get_cell_value(const u32_t *column, const u32_t *row_oid, u8_t row_oid
   }
 
   /* not found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
diff --git a/src/apps/snmp/snmp_msg.c b/src/apps/snmp/snmp_msg.c
index a2e9057..11a71ae 100644
--- a/src/apps/snmp/snmp_msg.c
+++ b/src/apps/snmp/snmp_msg.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP message processing (RFC1157).
diff --git a/src/apps/snmp/snmp_netconn.c b/src/apps/snmp/snmp_netconn.c
index 57d98f6..9cfce3c 100644
--- a/src/apps/snmp/snmp_netconn.c
+++ b/src/apps/snmp/snmp_netconn.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP netconn frontend.
@@ -76,6 +78,7 @@ snmp_netconn_thread(void *arg)
       netbuf_delete(buf);
     }
   } while (1);
+  __A_VARIABLE = 1;
 }
 
 err_t
@@ -88,6 +91,7 @@ snmp_sendto(void *handle, struct pbuf *p, const ip_addr_t *dst, u16_t port)
   buf.p = p;
   result = netconn_sendto((struct netconn *)handle, &buf, dst, port);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -118,6 +122,7 @@ snmp_init(void)
 {
   LWIP_ASSERT_CORE_LOCKED();
   sys_thread_new("snmp_netconn", snmp_netconn_thread, NULL, SNMP_STACK_SIZE, SNMP_THREAD_PRIO);
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_SNMP && SNMP_USE_NETCONN */
diff --git a/src/apps/snmp/snmp_pbuf_stream.c b/src/apps/snmp/snmp_pbuf_stream.c
index e33c6ec..fa23c6e 100644
--- a/src/apps/snmp/snmp_pbuf_stream.c
+++ b/src/apps/snmp/snmp_pbuf_stream.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP pbuf stream wrapper implementation (internal API, do not use in client code).
@@ -50,6 +52,7 @@ snmp_pbuf_stream_init(struct snmp_pbuf_stream *pbuf_stream, struct pbuf *p, u16_
   pbuf_stream->length = length;
   pbuf_stream->pbuf   = p;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -57,22 +60,26 @@ err_t
 snmp_pbuf_stream_read(struct snmp_pbuf_stream *pbuf_stream, u8_t *data)
 {
   if (pbuf_stream->length == 0) {
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
   if (pbuf_copy_partial(pbuf_stream->pbuf, data, 1, pbuf_stream->offset) == 0) {
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
   pbuf_stream->offset++;
   pbuf_stream->length--;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
 err_t
 snmp_pbuf_stream_write(struct snmp_pbuf_stream *pbuf_stream, u8_t data)
 {
+  __A_VARIABLE = 1;
   return snmp_pbuf_stream_writebuf(pbuf_stream, &data, 1);
 }
 
@@ -80,16 +87,19 @@ err_t
 snmp_pbuf_stream_writebuf(struct snmp_pbuf_stream *pbuf_stream, const void *buf, u16_t buf_len)
 {
   if (pbuf_stream->length < buf_len) {
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
   if (pbuf_take_at(pbuf_stream->pbuf, buf, buf_len, pbuf_stream->offset) != ERR_OK) {
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
   pbuf_stream->offset += buf_len;
   pbuf_stream->length -= buf_len;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -98,9 +108,11 @@ snmp_pbuf_stream_writeto(struct snmp_pbuf_stream *pbuf_stream, struct snmp_pbuf_
 {
 
   if ((pbuf_stream == NULL) || (target_pbuf_stream == NULL)) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   if ((len > pbuf_stream->length) || (len > target_pbuf_stream->length)) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
@@ -115,12 +127,14 @@ snmp_pbuf_stream_writeto(struct snmp_pbuf_stream *pbuf_stream, struct snmp_pbuf_
     struct pbuf *pbuf = pbuf_skip(pbuf_stream->pbuf, pbuf_stream->offset, &target_offset);
 
     if ((pbuf == NULL) || (pbuf->len == 0)) {
+      __A_VARIABLE = 1;
       return ERR_BUF;
     }
 
     chunk_len = LWIP_MIN(len, pbuf->len);
     err = snmp_pbuf_stream_writebuf(target_pbuf_stream, &((u8_t *)pbuf->payload)[target_offset], chunk_len);
     if (err != ERR_OK) {
+      __A_VARIABLE = 1;
       return err;
     }
 
@@ -129,6 +143,7 @@ snmp_pbuf_stream_writeto(struct snmp_pbuf_stream *pbuf_stream, struct snmp_pbuf_
     len -= chunk_len;
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -137,12 +152,14 @@ snmp_pbuf_stream_seek(struct snmp_pbuf_stream *pbuf_stream, s32_t offset)
 {
   if ((offset < 0) || (offset > pbuf_stream->length)) {
     /* we cannot seek backwards or forward behind stream end */
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
   pbuf_stream->offset += (u16_t)offset;
   pbuf_stream->length -= (u16_t)offset;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -150,6 +167,7 @@ err_t
 snmp_pbuf_stream_seek_abs(struct snmp_pbuf_stream *pbuf_stream, u32_t offset)
 {
   s32_t rel_offset = offset - pbuf_stream->offset;
+  __A_VARIABLE = 1;
   return snmp_pbuf_stream_seek(pbuf_stream, rel_offset);
 }
 
diff --git a/src/apps/snmp/snmp_raw.c b/src/apps/snmp/snmp_raw.c
index 912606f..e5ad0e1 100644
--- a/src/apps/snmp/snmp_raw.c
+++ b/src/apps/snmp/snmp_raw.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP RAW API frontend.
@@ -51,11 +53,13 @@ snmp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   snmp_receive(pcb, p, addr, port);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 err_t
 snmp_sendto(void *handle, struct pbuf *p, const ip_addr_t *dst, u16_t port)
 {
+  __A_VARIABLE = 1;
   return udp_sendto((struct udp_pcb *)handle, p, dst, port);
 }
 
@@ -98,6 +102,7 @@ snmp_init(void)
   udp_recv(snmp_pcb, snmp_recv, NULL);
   err = udp_bind(snmp_pcb, IP_ANY_TYPE, LWIP_IANA_PORT_SNMP);
   LWIP_ERROR("snmp_raw: Unable to bind PCB", (err == ERR_OK), return;);
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_SNMP && SNMP_USE_RAW */
diff --git a/src/apps/snmp/snmp_scalar.c b/src/apps/snmp/snmp_scalar.c
index 51eaed1..72be6e1 100644
--- a/src/apps/snmp/snmp_scalar.c
+++ b/src/apps/snmp/snmp_scalar.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP scalar node support implementation.
@@ -56,6 +58,7 @@ snmp_scalar_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_n
 
   /* scalar only has one dedicated instance: .0 */
   if ((instance->instance_oid.len != 1) || (instance->instance_oid.id[0] != 0)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -64,6 +67,7 @@ snmp_scalar_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_n
   instance->get_value = scalar_node->get_value;
   instance->set_test  = scalar_node->set_test;
   instance->set_value = scalar_node->set_value;
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -75,9 +79,11 @@ snmp_scalar_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct s
     instance->instance_oid.len   = 1;
     instance->instance_oid.id[0] = 0;
 
+    __A_VARIABLE = 1;
     return snmp_scalar_get_instance(root_oid, root_oid_len, instance);
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -110,10 +116,12 @@ snmp_scalar_array_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct
       instance->set_value           = snmp_scalar_array_set_value;
       instance->reference.const_ptr = array_node_def;
 
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOERROR;
     }
   }
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOSUCHINSTANCE;
 }
 
@@ -173,6 +181,7 @@ snmp_scalar_array_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, st
 
   if (result == NULL) {
     /* nothing to return */
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -187,6 +196,7 @@ snmp_scalar_array_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, st
   instance->set_value           = snmp_scalar_array_set_value;
   instance->reference.const_ptr = result;
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -200,6 +210,7 @@ snmp_scalar_array_get_value(struct snmp_node_instance *instance, void *value)
   if (array_node->get_value != NULL) {
     result = array_node->get_value(array_node_def, value);
   }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -213,6 +224,7 @@ snmp_scalar_array_set_test(struct snmp_node_instance *instance, u16_t value_len,
   if (array_node->set_test != NULL) {
     result = array_node->set_test(array_node_def, value_len, value);
   }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -226,6 +238,7 @@ snmp_scalar_array_set_value(struct snmp_node_instance *instance, u16_t value_len
   if (array_node->set_value != NULL) {
     result = array_node->set_value(array_node_def, value_len, value);
   }
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/src/apps/snmp/snmp_snmpv2_framework.c b/src/apps/snmp/snmp_snmpv2_framework.c
index a19a26e..6fbf222 100644
--- a/src/apps/snmp/snmp_snmpv2_framework.c
+++ b/src/apps/snmp/snmp_snmpv2_framework.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
 Generated by LwipMibCompiler
 */
@@ -49,18 +51,23 @@ static s16_t snmpengine_scalars_get_value(const struct snmp_scalar_array_node_de
     case 1: /* snmpEngineID */
       snmpv3_get_engine_id(&engineid, &engineid_len);
       MEMCPY(value, engineid, engineid_len);
+      __A_VARIABLE = 1;
       return engineid_len;
     case 2: /* snmpEngineBoots */
       *(s32_t *)value = snmpv3_get_engine_boots_internal();
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     case 3: /* snmpEngineTime */
       *(s32_t *)value = snmpv3_get_engine_time_internal();
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     case 4: /* snmpEngineMaxMessageSize */
       *(s32_t *)value = SNMP_FRAMEWORKMIB_SNMPENGINEMAXMESSAGESIZE;
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("snmpengine_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return 0;
   }
 }
diff --git a/src/apps/snmp/snmp_snmpv2_usm.c b/src/apps/snmp/snmp_snmpv2_usm.c
index 940ca75..9eb82cc 100644
--- a/src/apps/snmp/snmp_snmpv2_usm.c
+++ b/src/apps/snmp/snmp_snmpv2_usm.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
 Generated by LwipMibCompiler
 */
@@ -37,6 +39,7 @@ static void snmp_engineid_to_oid(const char *engineid, u32_t *oid, u32_t len)
   for (i = 0; i < len; i++) {
     oid[i] = engineid[i];
   }
+  __A_VARIABLE = 1;
 }
 
 static void snmp_oid_to_name(char *name, const u32_t *oid, size_t len)
@@ -46,6 +49,7 @@ static void snmp_oid_to_name(char *name, const u32_t *oid, size_t len)
   for (i = 0; i < len; i++) {
     name[i] = (char)oid[i];
   }
+  __A_VARIABLE = 1;
 }
 
 static void snmp_name_to_oid(const char *name, u32_t *oid, size_t len)
@@ -55,6 +59,7 @@ static void snmp_name_to_oid(const char *name, u32_t *oid, size_t len)
   for (i = 0; i < len; i++) {
     oid[i] = name[i];
   }
+  __A_VARIABLE = 1;
 }
 
 static const struct snmp_obj_id *snmp_auth_algo_to_oid(snmpv3_auth_algo_t algo)
@@ -103,16 +108,19 @@ static snmp_err_t usmusertable_get_instance(const u32_t *column, const u32_t *ro
 
   if (engineid_len != eid_len) {
     /* EngineID length does not match! */
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   if (engineid_len > row_oid_len) {
     /* row OID doesn't contain enough data according to engineid_len.*/
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(&row_oid[engineid_start], engineid_len, usmUserTable_oid_ranges, engineid_len)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -120,6 +128,7 @@ static snmp_err_t usmusertable_get_instance(const u32_t *column, const u32_t *ro
 
   /* Verify EngineID */
   if (snmp_oid_equal(&row_oid[engineid_start], engineid_len, engineid_oid, engineid_len)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -128,16 +137,19 @@ static snmp_err_t usmusertable_get_instance(const u32_t *column, const u32_t *ro
 
   if (name_len > SNMP_V3_MAX_USER_LENGTH) {
     /* specified name is too long */
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   if (1 + engineid_len + 1 + name_len != row_oid_len) {
     /* Length of EngineID and name does not match row oid length. (+2 for length fields)*/
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
   /* check if incoming OID length and if values are in plausible range */
   if (!snmp_oid_in_range(&row_oid[name_start], name_len, usmUserTable_oid_ranges, name_len)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -145,6 +157,7 @@ static snmp_err_t usmusertable_get_instance(const u32_t *column, const u32_t *ro
   memset(username, 0, sizeof(username));
   snmp_oid_to_name(username, &row_oid[name_start], name_len);
   if (snmpv3_get_user(username, NULL, NULL, NULL, NULL) != ERR_OK) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -153,6 +166,7 @@ static snmp_err_t usmusertable_get_instance(const u32_t *column, const u32_t *ro
   cell_instance->reference_len = name_len;
 
   /* user was found */
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -283,9 +297,11 @@ static s16_t usmusertable_get_value(struct snmp_node_instance *cell_instance, vo
   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
     case 3: /* usmUserSecurityName */
       MEMCPY(value, cell_instance->reference.ptr, cell_instance->reference_len);
+      __A_VARIABLE = 1;
       return (s16_t)cell_instance->reference_len;
     case 4: /* usmUserCloneFrom */
       MEMCPY(value, snmp_zero_dot_zero.id, snmp_zero_dot_zero.len * sizeof(u32_t));
+      __A_VARIABLE = 1;
       return snmp_zero_dot_zero.len * sizeof(u32_t);
     case 5: { /* usmUserAuthProtocol */
       const struct snmp_obj_id *auth_algo;
@@ -293,11 +309,14 @@ static s16_t usmusertable_get_value(struct snmp_node_instance *cell_instance, vo
       snmpv3_get_user((const char *)cell_instance->reference.ptr, &auth_algo_val, NULL, NULL, NULL);
       auth_algo = snmp_auth_algo_to_oid(auth_algo_val);
       MEMCPY(value, auth_algo->id, auth_algo->len * sizeof(u32_t));
+      __A_VARIABLE = 1;
       return auth_algo->len * sizeof(u32_t);
     }
     case 6: /* usmUserAuthKeyChange */
+      __A_VARIABLE = 1;
       return 0;
     case 7: /* usmUserOwnAuthKeyChange */
+      __A_VARIABLE = 1;
       return 0;
     case 8: { /* usmUserPrivProtocol */
       const struct snmp_obj_id *priv_algo;
@@ -305,24 +324,31 @@ static s16_t usmusertable_get_value(struct snmp_node_instance *cell_instance, vo
       snmpv3_get_user((const char *)cell_instance->reference.ptr, NULL, NULL, &priv_algo_val, NULL);
       priv_algo = snmp_priv_algo_to_oid(priv_algo_val);
       MEMCPY(value, priv_algo->id, priv_algo->len * sizeof(u32_t));
+      __A_VARIABLE = 1;
       return priv_algo->len * sizeof(u32_t);
     }
     case 9: /* usmUserPrivKeyChange */
+      __A_VARIABLE = 1;
       return 0;
     case 10: /* usmUserOwnPrivKeyChange */
+      __A_VARIABLE = 1;
       return 0;
     case 11: /* usmUserPublic */
       /* TODO: Implement usmUserPublic */
+      __A_VARIABLE = 1;
       return 0;
     case 12: /* usmUserStorageType */
       snmpv3_get_user_storagetype((const char *)cell_instance->reference.ptr, &storage_type);
       *(s32_t *)value = storage_type;
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     case 13: /* usmUserStatus */
       *(s32_t *)value = 1; /* active */
+      __A_VARIABLE = 1;
       return sizeof(s32_t);
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("usmusertable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
+      __A_VARIABLE = 1;
       return 0;
   }
 }
@@ -352,9 +378,11 @@ static s16_t usmstats_scalars_get_value(const struct snmp_scalar_array_node_def
       break;
     default:
       LWIP_DEBUGF(SNMP_MIB_DEBUG, ("usmstats_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
+      __A_VARIABLE = 1;
       return 0;
   }
 
+  __A_VARIABLE = 1;
   return sizeof(*uint_ptr);
 }
 
diff --git a/src/apps/snmp/snmp_table.c b/src/apps/snmp/snmp_table.c
index 55d744b..aba658f 100644
--- a/src/apps/snmp/snmp_table.c
+++ b/src/apps/snmp/snmp_table.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP table support implementation.
@@ -82,6 +84,7 @@ snmp_err_t snmp_table_get_instance(const u32_t *root_oid, u8_t root_oid_len, str
     }
   }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -98,6 +101,7 @@ snmp_err_t snmp_table_get_next_instance(const u32_t *root_oid, u8_t root_oid_len
 
   /* check that first part of id is 0 or 1, referencing fixed row entry */
   if ((instance->instance_oid.len > 0) && (instance->instance_oid.id[0] > 1)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
   if (instance->instance_oid.len > 1) {
@@ -131,6 +135,7 @@ snmp_err_t snmp_table_get_next_instance(const u32_t *root_oid, u8_t root_oid_len
 
     if (next_col_def == NULL) {
       /* no further column found */
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
     }
 
@@ -157,6 +162,7 @@ snmp_err_t snmp_table_get_next_instance(const u32_t *root_oid, u8_t root_oid_len
   instance->instance_oid.id[1] = col_def->index;
   snmp_oid_append(&instance->instance_oid, row_oid.id, row_oid.len);
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -237,6 +243,7 @@ snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_
 
   /* check that first part of id is 0 or 1, referencing fixed row entry */
   if ((instance->instance_oid.len > 0) && (instance->instance_oid.id[0] > 1)) {
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
   if (instance->instance_oid.len > 1) {
@@ -267,6 +274,7 @@ snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_
 
     if (next_col_def == NULL) {
       /* no further column found */
+      __A_VARIABLE = 1;
       return SNMP_ERR_NOSUCHINSTANCE;
     }
 
@@ -303,6 +311,7 @@ snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_
       break;
     default:
       LWIP_DEBUGF(SNMP_DEBUG, ("snmp_table_simple_get_instance(): unknown column data_type: %d\n", col_def->data_type));
+      __A_VARIABLE = 1;
       return SNMP_ERR_GENERROR;
   }
 
@@ -312,6 +321,7 @@ snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_
   instance->instance_oid.id[1] = col_def->index;
   snmp_oid_append(&instance->instance_oid, row_oid.id, row_oid.len);
 
+  __A_VARIABLE = 1;
   return SNMP_ERR_NOERROR;
 }
 
@@ -321,6 +331,7 @@ snmp_table_extract_value_from_s32ref(struct snmp_node_instance *instance, void *
 {
   s32_t *dst = (s32_t *)value;
   *dst = instance->reference.s32;
+  __A_VARIABLE = 1;
   return sizeof(*dst);
 }
 
@@ -329,6 +340,7 @@ snmp_table_extract_value_from_u32ref(struct snmp_node_instance *instance, void *
 {
   u32_t *dst = (u32_t *)value;
   *dst = instance->reference.u32;
+  __A_VARIABLE = 1;
   return sizeof(*dst);
 }
 
@@ -336,6 +348,7 @@ s16_t
 snmp_table_extract_value_from_refconstptr(struct snmp_node_instance *instance, void *value)
 {
   MEMCPY(value, instance->reference.const_ptr, instance->reference_len);
+  __A_VARIABLE = 1;
   return (u16_t)instance->reference_len;
 }
 
diff --git a/src/apps/snmp/snmp_threadsync.c b/src/apps/snmp/snmp_threadsync.c
index 764856d..1cec510 100644
--- a/src/apps/snmp/snmp_threadsync.c
+++ b/src/apps/snmp/snmp_threadsync.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMP thread synchronization implementation.
@@ -48,6 +50,7 @@ call_synced_function(struct threadsync_data *call_data, snmp_threadsync_called_f
   call_data->threadsync_node->instance->sync_fn(fn, call_data);
   sys_sem_wait(&call_data->threadsync_node->instance->sem);
   sys_mutex_unlock(&call_data->threadsync_node->instance->sem_usage_mutex);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -62,6 +65,7 @@ threadsync_get_value_synced(void *ctx)
   }
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static s16_t
@@ -72,6 +76,7 @@ threadsync_get_value(struct snmp_node_instance *instance, void *value)
   call_data->arg1.value = value;
   call_synced_function(call_data, threadsync_get_value_synced);
 
+  __A_VARIABLE = 1;
   return call_data->retval.s16;
 }
 
@@ -87,6 +92,7 @@ threadsync_set_test_synced(void *ctx)
   }
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static snmp_err_t
@@ -98,6 +104,7 @@ threadsync_set_test(struct snmp_node_instance *instance, u16_t len, void *value)
   call_data->arg2.len = len;
   call_synced_function(call_data, threadsync_set_test_synced);
 
+  __A_VARIABLE = 1;
   return call_data->retval.err;
 }
 
@@ -113,6 +120,7 @@ threadsync_set_value_synced(void *ctx)
   }
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static snmp_err_t
@@ -124,6 +132,7 @@ threadsync_set_value(struct snmp_node_instance *instance, u16_t len, void *value
   call_data->arg2.len = len;
   call_synced_function(call_data, threadsync_set_value_synced);
 
+  __A_VARIABLE = 1;
   return call_data->retval.err;
 }
 
@@ -135,6 +144,7 @@ threadsync_release_instance_synced(void *ctx)
   call_data->proxy_instance.release_instance(&call_data->proxy_instance);
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -145,6 +155,7 @@ threadsync_release_instance(struct snmp_node_instance *instance)
   if (call_data->proxy_instance.release_instance != NULL) {
     call_synced_function(call_data, threadsync_release_instance_synced);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -156,6 +167,7 @@ get_instance_synced(void *ctx)
   call_data->retval.err = leaf->get_instance(call_data->arg1.root_oid, call_data->arg2.root_oid_len, &call_data->proxy_instance);
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -167,6 +179,7 @@ get_next_instance_synced(void *ctx)
   call_data->retval.err = leaf->get_next_instance(call_data->arg1.root_oid, call_data->arg2.root_oid_len, &call_data->proxy_instance);
 
   sys_sem_signal(&call_data->threadsync_node->instance->sem);
+  __A_VARIABLE = 1;
 }
 
 static snmp_err_t
@@ -177,6 +190,7 @@ do_sync(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance *ins
 
   if (threadsync_node->node.node.oid != threadsync_node->target->node.oid) {
     LWIP_DEBUGF(SNMP_DEBUG, ("Sync node OID does not match target node OID"));
+    __A_VARIABLE = 1;
     return SNMP_ERR_NOSUCHINSTANCE;
   }
 
@@ -202,18 +216,21 @@ do_sync(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance *ins
     snmp_oid_assign(&instance->instance_oid, call_data->proxy_instance.instance_oid.id, call_data->proxy_instance.instance_oid.len);
   }
 
+  __A_VARIABLE = 1;
   return call_data->retval.err;
 }
 
 snmp_err_t
 snmp_threadsync_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance *instance)
 {
+  __A_VARIABLE = 1;
   return do_sync(root_oid, root_oid_len, instance, get_instance_synced);
 }
 
 snmp_err_t
 snmp_threadsync_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance *instance)
 {
+  __A_VARIABLE = 1;
   return do_sync(root_oid, root_oid_len, instance, get_next_instance_synced);
 }
 
@@ -226,6 +243,7 @@ void snmp_threadsync_init(struct snmp_threadsync_instance *instance, snmp_thread
   LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
   LWIP_ASSERT("Failed to set up semaphore", err == ERR_OK);
   instance->sync_fn = sync_fn;
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_SNMP */
diff --git a/src/apps/snmp/snmp_traps.c b/src/apps/snmp/snmp_traps.c
index 002596a..85ef215 100644
--- a/src/apps/snmp/snmp_traps.c
+++ b/src/apps/snmp/snmp_traps.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMPv1 traps implementation.
@@ -115,6 +117,7 @@ snmp_trap_dst_enable(u8_t dst_idx, u8_t enable)
   if (dst_idx < SNMP_TRAP_DESTINATIONS) {
     trap_dst[dst_idx].enable = enable;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -130,6 +133,7 @@ snmp_trap_dst_ip_set(u8_t dst_idx, const ip_addr_t *dst)
   if (dst_idx < SNMP_TRAP_DESTINATIONS) {
     ip_addr_set(&trap_dst[dst_idx].dip, dst);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -140,6 +144,7 @@ void
 snmp_set_auth_traps_enabled(u8_t enable)
 {
   snmp_auth_traps_enabled = enable;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -149,6 +154,7 @@ snmp_set_auth_traps_enabled(u8_t enable)
 u8_t
 snmp_get_auth_traps_enabled(void)
 {
+  __A_VARIABLE = 1;
   return snmp_auth_traps_enabled;
 }
 
@@ -230,6 +236,7 @@ snmp_send_trap(const struct snmp_obj_id *eoid, s32_t generic_trap, s32_t specifi
       }
     }
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -241,6 +248,7 @@ err_t
 snmp_send_trap_generic(s32_t generic_trap)
 {
   static const struct snmp_obj_id oid = { 7, { 1, 3, 6, 1, 2, 1, 11 } };
+  __A_VARIABLE = 1;
   return snmp_send_trap(&oid, generic_trap, 0, NULL);
 }
 
@@ -251,6 +259,7 @@ snmp_send_trap_generic(s32_t generic_trap)
 err_t
 snmp_send_trap_specific(s32_t specific_trap, struct snmp_varbind *varbinds)
 {
+  __A_VARIABLE = 1;
   return snmp_send_trap(NULL, SNMP_GENTRAP_ENTERPRISE_SPECIFIC, specific_trap, varbinds);
 }
 
@@ -262,6 +271,7 @@ void
 snmp_coldstart_trap(void)
 {
   snmp_send_trap_generic(SNMP_GENTRAP_COLDSTART);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -274,6 +284,7 @@ snmp_authfail_trap(void)
   if (snmp_auth_traps_enabled != 0) {
     snmp_send_trap_generic(SNMP_GENTRAP_AUTH_FAILURE);
   }
+  __A_VARIABLE = 1;
 }
 
 static u16_t
@@ -299,6 +310,7 @@ snmp_trap_varbind_sum(struct snmp_msg_trap *trap, struct snmp_varbind *varbinds)
   snmp_asn1_enc_length_cnt(trap->vbseqlen, &tot_len_len);
   tot_len += 1 + tot_len_len;
 
+  __A_VARIABLE = 1;
   return tot_len;
 }
 
@@ -363,6 +375,7 @@ snmp_trap_header_sum(struct snmp_msg_trap *trap, u16_t vb_len)
   snmp_asn1_enc_length_cnt(trap->seqlen, &lenlen);
   tot_len += 1 + lenlen;
 
+  __A_VARIABLE = 1;
   return tot_len;
 }
 
@@ -383,6 +396,7 @@ snmp_trap_varbind_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_
     varbind = varbind->next;
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -452,6 +466,7 @@ snmp_trap_header_enc(struct snmp_msg_trap *trap, struct snmp_pbuf_stream *pbuf_s
   BUILD_EXEC( snmp_ans1_enc_tlv(pbuf_stream, &tlv) );
   BUILD_EXEC( snmp_asn1_enc_s32t(pbuf_stream, tlv.value_len, trap->ts) );
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
diff --git a/src/apps/snmp/snmpv3.c b/src/apps/snmp/snmpv3.c
index df7bb5c..0399982 100644
--- a/src/apps/snmp/snmpv3.c
+++ b/src/apps/snmp/snmpv3.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Additional SNMPv3 functionality RFC3414 and RFC3826.
@@ -50,6 +52,7 @@ void
 snmpv3_engine_id_changed(void)
 {
   snmpv3_set_engine_boots(0);
+  __A_VARIABLE = 1;
 }
 
 /** According to RFC3414 2.2.2.
@@ -63,10 +66,12 @@ snmpv3_get_engine_boots_internal(void)
 {
   if (snmpv3_get_engine_boots() == 0 ||
       snmpv3_get_engine_boots() < SNMP_MAX_TIME_BOOT) {
+    __A_VARIABLE = 1;
     return snmpv3_get_engine_boots();
   }
 
   snmpv3_set_engine_boots(SNMP_MAX_TIME_BOOT);
+  __A_VARIABLE = 1;
   return snmpv3_get_engine_boots();
 }
 
@@ -88,6 +93,7 @@ snmpv3_get_engine_time_internal(void)
     }
   }
 
+  __A_VARIABLE = 1;
   return snmpv3_get_engine_time();
 }
 
@@ -129,6 +135,7 @@ snmpv3_build_priv_param(u8_t *priv_param)
   SMEMCPY(&priv_param[4], &ctr, 4);
   ctr++;
 #endif
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_SNMP_V3_CRYPTO */
diff --git a/src/apps/snmp/snmpv3_mbedtls.c b/src/apps/snmp/snmpv3_mbedtls.c
index fe20f78..3a5754b 100644
--- a/src/apps/snmp/snmpv3_mbedtls.c
+++ b/src/apps/snmp/snmpv3_mbedtls.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNMPv3 crypto/auth functions implemented for ARM mbedtls.
@@ -283,6 +285,7 @@ snmpv3_password_to_key_md5(
   mbedtls_md5_finish(&MD, key);
 
   mbedtls_md5_free(&MD);
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -336,6 +339,7 @@ snmpv3_password_to_key_sha(
   mbedtls_sha1_finish(&SH, key);
 
   mbedtls_sha1_free(&SH);
+  __A_VARIABLE = 1;
   return;
 }
 
diff --git a/src/apps/sntp/sntp.c b/src/apps/sntp/sntp.c
index 0952a63..6a09779 100644
--- a/src/apps/sntp/sntp.c
+++ b/src/apps/sntp/sntp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SNTP client module
@@ -275,6 +277,7 @@ sntp_format_time(s32_t sec)
 {
   time_t ut;
   ut = (u32_t)((u32_t)sec + DIFF_SEC_1970_2036);
+  __A_VARIABLE = 1;
   return ctime(&ut);
 }
 #endif /* LWIP_DEBUG && !sntp_format_time */
@@ -327,6 +330,7 @@ sntp_process(const struct sntp_timestamps *timestamps)
   LWIP_UNUSED_ARG(frac); /* might be unused if only seconds are set */
   LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_process: %s, %" U32_F " us\n",
                                  sntp_format_time(sec), SNTP_FRAC_TO_US(frac)));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -355,6 +359,7 @@ sntp_initialize_request(struct sntp_msg *req)
     req->transmit_timestamp[1] = frac;
   }
 #endif /* SNTP_CHECK_RESPONSE >= 2 || SNTP_COMP_ROUNDTRIP */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -385,6 +390,7 @@ sntp_retry(void *arg)
     }
   }
 #endif /* SNTP_RETRY_TIMEOUT_EXP */
+  __A_VARIABLE = 1;
 }
 
 #if SNTP_SUPPORT_MULTIPLE_SERVERS
@@ -419,12 +425,14 @@ sntp_try_next_server(void *arg)
       SNTP_RESET_RETRY_TIMEOUT();
       /* instantly send a request to the next server */
       sntp_request(NULL);
+      __A_VARIABLE = 1;
       return;
     }
   }
   /* no other valid server found */
   sntp_current_server = old_server;
   sntp_retry(NULL);
+  __A_VARIABLE = 1;
 }
 #else /* SNTP_SUPPORT_MULTIPLE_SERVERS */
 /* Always retry on error if only one server is supported */
@@ -530,6 +538,7 @@ sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
   } else {
     /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
   }
+  __A_VARIABLE = 1;
 }
 
 /** Actually send an sntp request to a server.
@@ -569,6 +578,7 @@ sntp_send_request(const ip_addr_t *server_addr)
     /* out of memory: set up a timer to send a retry */
     sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
   }
+  __A_VARIABLE = 1;
 }
 
 #if SNTP_SERVER_DNS
@@ -591,6 +601,7 @@ sntp_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
     LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_dns_found: Failed to resolve server address resolved, trying next server\n"));
     sntp_try_next_server(NULL);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* SNTP_SERVER_DNS */
 
@@ -676,6 +687,7 @@ sntp_init(void)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -698,6 +710,7 @@ sntp_stop(void)
     udp_remove(sntp_pcb);
     sntp_pcb = NULL;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -706,6 +719,7 @@ sntp_stop(void)
  */
 u8_t sntp_enabled(void)
 {
+  __A_VARIABLE = 1;
   return (sntp_pcb != NULL) ? 1 : 0;
 }
 
@@ -721,6 +735,7 @@ sntp_setoperatingmode(u8_t operating_mode)
   LWIP_ASSERT("Invalid operating mode", operating_mode <= SNTP_OPMODE_LISTENONLY);
   LWIP_ASSERT("Operating mode must not be set while SNTP client is running", sntp_pcb == NULL);
   sntp_opmode = operating_mode;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -730,6 +745,7 @@ sntp_setoperatingmode(u8_t operating_mode)
 u8_t
 sntp_getoperatingmode(void)
 {
+  __A_VARIABLE = 1;
   return sntp_opmode;
 }
 
@@ -744,8 +760,10 @@ u8_t
 sntp_getreachability(u8_t idx)
 {
   if (idx < SNTP_MAX_SERVERS) {
+    __A_VARIABLE = 1;
     return sntp_servers[idx].reachability;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* SNTP_MONITOR_SERVER_REACHABILITY */
@@ -763,6 +781,7 @@ sntp_servermode_dhcp(int set_servers_from_dhcp)
   if (sntp_set_servers_from_dhcp != new_mode) {
     sntp_set_servers_from_dhcp = new_mode;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* SNTP_GET_SERVERS_FROM_DHCP */
 
@@ -787,6 +806,7 @@ sntp_setserver(u8_t idx, const ip_addr_t *server)
     sntp_servers[idx].name = NULL;
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_DHCP && SNTP_GET_SERVERS_FROM_DHCP
@@ -813,6 +833,7 @@ dhcp_set_ntp_servers(u8_t num, const ip4_addr_t *server)
       sntp_setserver(i, NULL);
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_DHCP && SNTP_GET_SERVERS_FROM_DHCP */
 
@@ -828,8 +849,10 @@ const ip_addr_t *
 sntp_getserver(u8_t idx)
 {
   if (idx < SNTP_MAX_SERVERS) {
+    __A_VARIABLE = 1;
     return &sntp_servers[idx].addr;
   }
+  __A_VARIABLE = 1;
   return IP_ADDR_ANY;
 }
 
@@ -847,6 +870,7 @@ sntp_setservername(u8_t idx, const char *server)
   if (idx < SNTP_MAX_SERVERS) {
     sntp_servers[idx].name = server;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -860,8 +884,10 @@ const char *
 sntp_getservername(u8_t idx)
 {
   if (idx < SNTP_MAX_SERVERS) {
+    __A_VARIABLE = 1;
     return sntp_servers[idx].name;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 #endif /* SNTP_SERVER_DNS */
diff --git a/src/apps/tftp/tftp_server.c b/src/apps/tftp/tftp_server.c
index d6c75b4..3af56c4 100644
--- a/src/apps/tftp/tftp_server.c
+++ b/src/apps/tftp/tftp_server.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  *
  * @file tftp_server.c
@@ -112,6 +114,7 @@ close_handle(void)
     tftp_state.handle = NULL;
     LWIP_DEBUGF(TFTP_DEBUG | LWIP_DBG_STATE, ("tftp: closing\n"));
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -123,6 +126,7 @@ send_error(const ip_addr_t *addr, u16_t port, enum tftp_error code, const char *
 
   p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(TFTP_HEADER_LENGTH + str_length + 1), PBUF_RAM);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -133,6 +137,7 @@ send_error(const ip_addr_t *addr, u16_t port, enum tftp_error code, const char *
 
   udp_sendto(tftp_state.upcb, p, addr, port);
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -143,6 +148,7 @@ send_ack(u16_t blknum)
 
   p = pbuf_alloc(PBUF_TRANSPORT, TFTP_HEADER_LENGTH, PBUF_RAM);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
   payload = (u16_t *) p->payload;
@@ -151,6 +157,7 @@ send_ack(u16_t blknum)
   payload[1] = lwip_htons(blknum);
   udp_sendto(tftp_state.upcb, p, &tftp_state.addr, tftp_state.port);
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -158,16 +165,19 @@ resend_data(void)
 {
   struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, tftp_state.last_data->len, PBUF_RAM);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
   if (pbuf_copy(p, tftp_state.last_data) != ERR_OK) {
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return;
   }
 
   udp_sendto(tftp_state.upcb, p, &tftp_state.addr, tftp_state.port);
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -182,6 +192,7 @@ send_data(void)
 
   tftp_state.last_data = pbuf_alloc(PBUF_TRANSPORT, TFTP_HEADER_LENGTH + TFTP_MAX_PAYLOAD_SIZE, PBUF_RAM);
   if (tftp_state.last_data == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -193,11 +204,13 @@ send_data(void)
   if (ret < 0) {
     send_error(&tftp_state.addr, tftp_state.port, TFTP_ERROR_ACCESS_VIOLATION, "Error occured while reading the file.");
     close_handle();
+    __A_VARIABLE = 1;
     return;
   }
 
   pbuf_realloc(tftp_state.last_data, (u16_t)(TFTP_HEADER_LENGTH + ret));
   resend_data();
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -213,6 +226,7 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
       (!ip_addr_isany_val(tftp_state.addr) && !ip_addr_cmp(&tftp_state.addr, addr))) {
     send_error(addr, port, TFTP_ERROR_ACCESS_VIOLATION, "Only one connection at a time is supported");
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -361,6 +375,7 @@ recv(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16
   }
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -371,6 +386,7 @@ tftp_tmr(void *arg)
   tftp_state.timer++;
 
   if (tftp_state.handle == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -386,6 +402,7 @@ tftp_tmr(void *arg)
       close_handle();
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** @ingroup tftp
@@ -400,12 +417,14 @@ tftp_init(const struct tftp_context *ctx)
   /* LWIP_ASSERT_CORE_LOCKED(); is checked by udp_new() */
   struct udp_pcb *pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
   if (pcb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   ret = udp_bind(pcb, IP_ANY_TYPE, TFTP_PORT);
   if (ret != ERR_OK) {
     udp_remove(pcb);
+    __A_VARIABLE = 1;
     return ret;
   }
 
@@ -418,6 +437,7 @@ tftp_init(const struct tftp_context *ctx)
 
   udp_recv(pcb, recv, NULL);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -430,6 +450,7 @@ void tftp_cleanup(void)
   udp_remove(tftp_state.upcb);
   close_handle();
   memset(&tftp_state, 0, sizeof(tftp_state));
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_UDP */
diff --git a/src/core/altcp.c b/src/core/altcp.c
index d42b727..2b9227a 100644
--- a/src/core/altcp.c
+++ b/src/core/altcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * @defgroup altcp Application layered TCP Functions
@@ -139,6 +141,7 @@ altcp_alloc(void)
   if (ret != NULL) {
     memset(ret, 0, sizeof(struct altcp_pcb));
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -154,6 +157,7 @@ altcp_free(struct altcp_pcb *conn)
     }
     memp_free(MEMP_ALTCP_PCB, conn);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -163,6 +167,7 @@ altcp_free(struct altcp_pcb *conn)
 struct altcp_pcb *
 altcp_new_ip6(altcp_allocator_t *allocator)
 {
+  __A_VARIABLE = 1;
   return altcp_new_ip_type(allocator, IPADDR_TYPE_V6);
 }
 
@@ -173,6 +178,7 @@ altcp_new_ip6(altcp_allocator_t *allocator)
 struct altcp_pcb *
 altcp_new(altcp_allocator_t *allocator)
 {
+  __A_VARIABLE = 1;
   return altcp_new_ip_type(allocator, IPADDR_TYPE_V4);
 }
 
@@ -191,17 +197,21 @@ altcp_new_ip_type(altcp_allocator_t *allocator, u8_t ip_type)
   struct altcp_pcb *conn;
   if (allocator == NULL) {
     /* no allocator given, create a simple TCP connection */
+    __A_VARIABLE = 1;
     return altcp_tcp_new_ip_type(ip_type);
   }
   if (allocator->alloc == NULL) {
     /* illegal allocator */
+    __A_VARIABLE = 1;
     return NULL;
   }
   conn = allocator->alloc(allocator->arg, ip_type);
   if (conn == NULL) {
     /* allocation failed */
+    __A_VARIABLE = 1;
     return NULL;
   }
+  __A_VARIABLE = 1;
   return conn;
 }
 
@@ -215,6 +225,7 @@ altcp_arg(struct altcp_pcb *conn, void *arg)
   if (conn) {
     conn->arg = arg;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -227,6 +238,7 @@ altcp_accept(struct altcp_pcb *conn, altcp_accept_fn accept)
   if (conn != NULL) {
     conn->accept = accept;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -239,6 +251,7 @@ altcp_recv(struct altcp_pcb *conn, altcp_recv_fn recv)
   if (conn) {
     conn->recv = recv;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -251,6 +264,7 @@ altcp_sent(struct altcp_pcb *conn, altcp_sent_fn sent)
   if (conn) {
     conn->sent = sent;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -267,6 +281,7 @@ altcp_poll(struct altcp_pcb *conn, altcp_poll_fn poll, u8_t interval)
       conn->fns->set_poll(conn, interval);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -279,6 +294,7 @@ altcp_err(struct altcp_pcb *conn, altcp_err_fn err)
   if (conn) {
     conn->err = err;
   }
+  __A_VARIABLE = 1;
 }
 
 /* Generic functions calling the "virtual" ones */
@@ -293,6 +309,7 @@ altcp_recved(struct altcp_pcb *conn, u16_t len)
   if (conn && conn->fns && conn->fns->recved) {
     conn->fns->recved(conn, len);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -303,8 +320,10 @@ err_t
 altcp_bind(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port)
 {
   if (conn && conn->fns && conn->fns->bind) {
+    __A_VARIABLE = 1;
     return conn->fns->bind(conn, ipaddr, port);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -316,8 +335,10 @@ err_t
 altcp_connect(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port, altcp_connected_fn connected)
 {
   if (conn && conn->fns && conn->fns->connect) {
+    __A_VARIABLE = 1;
     return conn->fns->connect(conn, ipaddr, port, connected);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -329,8 +350,10 @@ struct altcp_pcb *
 altcp_listen_with_backlog_and_err(struct altcp_pcb *conn, u8_t backlog, err_t *err)
 {
   if (conn && conn->fns && conn->fns->listen) {
+    __A_VARIABLE = 1;
     return conn->fns->listen(conn, backlog, err);
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -344,6 +367,7 @@ altcp_abort(struct altcp_pcb *conn)
   if (conn && conn->fns && conn->fns->abort) {
     conn->fns->abort(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -354,8 +378,10 @@ err_t
 altcp_close(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->close) {
+    __A_VARIABLE = 1;
     return conn->fns->close(conn);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -367,8 +393,10 @@ err_t
 altcp_shutdown(struct altcp_pcb *conn, int shut_rx, int shut_tx)
 {
   if (conn && conn->fns && conn->fns->shutdown) {
+    __A_VARIABLE = 1;
     return conn->fns->shutdown(conn, shut_rx, shut_tx);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -380,8 +408,10 @@ err_t
 altcp_write(struct altcp_pcb *conn, const void *dataptr, u16_t len, u8_t apiflags)
 {
   if (conn && conn->fns && conn->fns->write) {
+    __A_VARIABLE = 1;
     return conn->fns->write(conn, dataptr, len, apiflags);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -393,8 +423,10 @@ err_t
 altcp_output(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->output) {
+    __A_VARIABLE = 1;
     return conn->fns->output(conn);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -406,8 +438,10 @@ u16_t
 altcp_mss(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->mss) {
+    __A_VARIABLE = 1;
     return conn->fns->mss(conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -419,8 +453,10 @@ u16_t
 altcp_sndbuf(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->sndbuf) {
+    __A_VARIABLE = 1;
     return conn->fns->sndbuf(conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -432,8 +468,10 @@ u16_t
 altcp_sndqueuelen(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->sndqueuelen) {
+    __A_VARIABLE = 1;
     return conn->fns->sndqueuelen(conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -443,6 +481,7 @@ altcp_nagle_disable(struct altcp_pcb *conn)
   if (conn && conn->fns && conn->fns->nagle_disable) {
     conn->fns->nagle_disable(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -451,14 +490,17 @@ altcp_nagle_enable(struct altcp_pcb *conn)
   if (conn && conn->fns && conn->fns->nagle_enable) {
     conn->fns->nagle_enable(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 int
 altcp_nagle_disabled(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->nagle_disabled) {
+    __A_VARIABLE = 1;
     return conn->fns->nagle_disabled(conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -472,14 +514,17 @@ altcp_setprio(struct altcp_pcb *conn, u8_t prio)
   if (conn && conn->fns && conn->fns->setprio) {
     conn->fns->setprio(conn, prio);
   }
+  __A_VARIABLE = 1;
 }
 
 err_t
 altcp_get_tcp_addrinfo(struct altcp_pcb *conn, int local, ip_addr_t *addr, u16_t *port)
 {
   if (conn && conn->fns && conn->fns->addrinfo) {
+    __A_VARIABLE = 1;
     return conn->fns->addrinfo(conn, local, addr, port);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -487,8 +532,10 @@ ip_addr_t *
 altcp_get_ip(struct altcp_pcb *conn, int local)
 {
   if (conn && conn->fns && conn->fns->getip) {
+    __A_VARIABLE = 1;
     return conn->fns->getip(conn, local);
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -496,8 +543,10 @@ u16_t
 altcp_get_port(struct altcp_pcb *conn, int local)
 {
   if (conn && conn->fns && conn->fns->getport) {
+    __A_VARIABLE = 1;
     return conn->fns->getport(conn, local);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -506,8 +555,10 @@ enum tcp_state
 altcp_dbg_get_tcp_state(struct altcp_pcb *conn)
 {
   if (conn && conn->fns && conn->fns->dbg_get_tcp_state) {
+    __A_VARIABLE = 1;
     return conn->fns->dbg_get_tcp_state(conn);
   }
+  __A_VARIABLE = 1;
   return CLOSED;
 }
 #endif
@@ -520,6 +571,7 @@ altcp_default_set_poll(struct altcp_pcb *conn, u8_t interval)
   if (conn && conn->inner_conn) {
     altcp_poll(conn->inner_conn, conn->poll, interval);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -528,14 +580,17 @@ altcp_default_recved(struct altcp_pcb *conn, u16_t len)
   if (conn && conn->inner_conn) {
     altcp_recved(conn->inner_conn, len);
   }
+  __A_VARIABLE = 1;
 }
 
 err_t
 altcp_default_bind(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_bind(conn->inner_conn, ipaddr, port);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -545,12 +600,15 @@ altcp_default_shutdown(struct altcp_pcb *conn, int shut_rx, int shut_tx)
   if (conn) {
     if (shut_rx && shut_tx && conn->fns && conn->fns->close) {
       /* default shutdown for both sides is close */
+      __A_VARIABLE = 1;
       return conn->fns->close(conn);
     }
     if (conn->inner_conn) {
+      __A_VARIABLE = 1;
       return altcp_shutdown(conn->inner_conn, shut_rx, shut_tx);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -558,8 +616,10 @@ err_t
 altcp_default_write(struct altcp_pcb *conn, const void *dataptr, u16_t len, u8_t apiflags)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_write(conn->inner_conn, dataptr, len, apiflags);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -567,8 +627,10 @@ err_t
 altcp_default_output(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_output(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -576,8 +638,10 @@ u16_t
 altcp_default_mss(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_mss(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -585,8 +649,10 @@ u16_t
 altcp_default_sndbuf(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_sndbuf(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -594,8 +660,10 @@ u16_t
 altcp_default_sndqueuelen(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_sndqueuelen(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -605,6 +673,7 @@ altcp_default_nagle_disable(struct altcp_pcb *conn)
   if (conn && conn->inner_conn) {
     altcp_nagle_disable(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -613,14 +682,17 @@ altcp_default_nagle_enable(struct altcp_pcb *conn)
   if (conn && conn->inner_conn) {
     altcp_nagle_enable(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
 }
 
 int
 altcp_default_nagle_disabled(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_nagle_disabled(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -630,6 +702,7 @@ altcp_default_setprio(struct altcp_pcb *conn, u8_t prio)
   if (conn && conn->inner_conn) {
     altcp_setprio(conn->inner_conn, prio);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -637,14 +710,17 @@ altcp_default_dealloc(struct altcp_pcb *conn)
 {
   LWIP_UNUSED_ARG(conn);
   /* nothing to do */
+  __A_VARIABLE = 1;
 }
 
 err_t
 altcp_default_get_tcp_addrinfo(struct altcp_pcb *conn, int local, ip_addr_t *addr, u16_t *port)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_get_tcp_addrinfo(conn->inner_conn, local, addr, port);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -652,8 +728,10 @@ ip_addr_t *
 altcp_default_get_ip(struct altcp_pcb *conn, int local)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_get_ip(conn->inner_conn, local);
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -661,8 +739,10 @@ u16_t
 altcp_default_get_port(struct altcp_pcb *conn, int local)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_get_port(conn->inner_conn, local);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -671,8 +751,10 @@ enum tcp_state
 altcp_default_dbg_get_tcp_state(struct altcp_pcb *conn)
 {
   if (conn && conn->inner_conn) {
+    __A_VARIABLE = 1;
     return altcp_dbg_get_tcp_state(conn->inner_conn);
   }
+  __A_VARIABLE = 1;
   return CLOSED;
 }
 #endif
diff --git a/src/core/altcp_alloc.c b/src/core/altcp_alloc.c
index 8c2390e..7fc6b53 100644
--- a/src/core/altcp_alloc.c
+++ b/src/core/altcp_alloc.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Application layered TCP connection API (to be used from TCPIP thread)\n
@@ -65,12 +67,14 @@ altcp_tls_new(struct altcp_tls_config *config, u8_t ip_type)
 
   inner_conn = altcp_tcp_new_ip_type(ip_type);
   if (inner_conn == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = altcp_tls_wrap(config, inner_conn);
   if (ret == NULL) {
     altcp_close(inner_conn);
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -79,6 +83,7 @@ altcp_tls_new(struct altcp_tls_config *config, u8_t ip_type)
 struct altcp_pcb *
 altcp_tls_alloc(void *arg, u8_t ip_type)
 {
+  __A_VARIABLE = 1;
   return altcp_tls_new((struct altcp_tls_config *)arg, ip_type);
 }
 
diff --git a/src/core/altcp_tcp.c b/src/core/altcp_tcp.c
index f5b8e84..813703d 100644
--- a/src/core/altcp_tcp.c
+++ b/src/core/altcp_tcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Application layered TCP connection API (to be used from TCPIP thread)\n
@@ -77,11 +79,14 @@ altcp_tcp_accept(void *arg, struct tcp_pcb *new_tpcb, err_t err)
     /* create a new altcp_conn to pass to the next 'accept' callback */
     struct altcp_pcb *new_conn = altcp_alloc();
     if (new_conn == NULL) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
     altcp_tcp_setup(new_conn, new_tpcb);
+    __A_VARIABLE = 1;
     return listen_conn->accept(listen_conn->arg, new_conn, err);
   }
+  __A_VARIABLE = 1;
   return ERR_ARG;
 }
 
@@ -92,9 +97,11 @@ altcp_tcp_connected(void *arg, struct tcp_pcb *tpcb, err_t err)
   if (conn) {
     ALTCP_TCP_ASSERT_CONN_PCB(conn, tpcb);
     if (conn->connected) {
+      __A_VARIABLE = 1;
       return conn->connected(conn->arg, conn, err);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -105,6 +112,7 @@ altcp_tcp_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
   if (conn) {
     ALTCP_TCP_ASSERT_CONN_PCB(conn, tpcb);
     if (conn->recv) {
+      __A_VARIABLE = 1;
       return conn->recv(conn->arg, conn, p, err);
     }
   }
@@ -112,6 +120,7 @@ altcp_tcp_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
     /* prevent memory leaks */
     pbuf_free(p);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -122,9 +131,11 @@ altcp_tcp_sent(void *arg, struct tcp_pcb *tpcb, u16_t len)
   if (conn) {
     ALTCP_TCP_ASSERT_CONN_PCB(conn, tpcb);
     if (conn->sent) {
+      __A_VARIABLE = 1;
       return conn->sent(conn->arg, conn, len);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -135,9 +146,11 @@ altcp_tcp_poll(void *arg, struct tcp_pcb *tpcb)
   if (conn) {
     ALTCP_TCP_ASSERT_CONN_PCB(conn, tpcb);
     if (conn->poll) {
+      __A_VARIABLE = 1;
       return conn->poll(conn->arg, conn);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -152,6 +165,7 @@ altcp_tcp_err(void *arg, err_t err)
     }
     altcp_free(conn);
   }
+  __A_VARIABLE = 1;
 }
 
 /* setup functions */
@@ -164,6 +178,7 @@ altcp_tcp_remove_callbacks(struct tcp_pcb *tpcb)
   tcp_sent(tpcb, NULL);
   tcp_err(tpcb, NULL);
   tcp_poll(tpcb, NULL, tpcb->pollinterval);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -175,6 +190,7 @@ altcp_tcp_setup_callbacks(struct altcp_pcb *conn, struct tcp_pcb *tpcb)
   tcp_err(tpcb, altcp_tcp_err);
   /* tcp_poll is set when interval is set by application */
   /* listen is set totally different :-) */
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -183,6 +199,7 @@ altcp_tcp_setup(struct altcp_pcb *conn, struct tcp_pcb *tpcb)
   altcp_tcp_setup_callbacks(conn, tpcb);
   conn->state = tpcb;
   conn->fns = &altcp_tcp_functions;
+  __A_VARIABLE = 1;
 }
 
 struct altcp_pcb *
@@ -212,6 +229,7 @@ struct altcp_pcb *
 altcp_tcp_alloc(void *arg, u8_t ip_type)
 {
   LWIP_UNUSED_ARG(arg);
+  __A_VARIABLE = 1;
   return altcp_tcp_new_ip_type(ip_type);
 }
 
@@ -222,9 +240,11 @@ altcp_tcp_wrap(struct tcp_pcb *tpcb)
     struct altcp_pcb *ret = altcp_alloc();
     if (ret != NULL) {
       altcp_tcp_setup(ret, tpcb);
+      __A_VARIABLE = 1;
       return ret;
     }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -238,6 +258,7 @@ altcp_tcp_set_poll(struct altcp_pcb *conn, u8_t interval)
     ALTCP_TCP_ASSERT_CONN(conn);
     tcp_poll(pcb, altcp_tcp_poll, interval);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -248,6 +269,7 @@ altcp_tcp_recved(struct altcp_pcb *conn, u16_t len)
     ALTCP_TCP_ASSERT_CONN(conn);
     tcp_recved(pcb, len);
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -255,10 +277,12 @@ altcp_tcp_bind(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_bind(pcb, ipaddr, port);
 }
 
@@ -267,11 +291,13 @@ altcp_tcp_connect(struct altcp_pcb *conn, const ip_addr_t *ipaddr, u16_t port, a
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   conn->connected = connected;
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_connect(pcb, ipaddr, port, altcp_tcp_connected);
 }
 
@@ -281,6 +307,7 @@ altcp_tcp_listen(struct altcp_pcb *conn, u8_t backlog, err_t *err)
   struct tcp_pcb *pcb;
   struct tcp_pcb *lpcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
@@ -289,8 +316,10 @@ altcp_tcp_listen(struct altcp_pcb *conn, u8_t backlog, err_t *err)
   if (lpcb != NULL) {
     conn->state = lpcb;
     tcp_accept(lpcb, altcp_tcp_accept);
+    __A_VARIABLE = 1;
     return conn;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -304,6 +333,7 @@ altcp_tcp_abort(struct altcp_pcb *conn)
       tcp_abort(pcb);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -311,6 +341,7 @@ altcp_tcp_close(struct altcp_pcb *conn)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
@@ -325,11 +356,13 @@ altcp_tcp_close(struct altcp_pcb *conn)
       altcp_tcp_setup_callbacks(conn, pcb);
       /* poll callback is not included in the above */
       tcp_poll(pcb, oldpoll, pcb->pollinterval);
+      __A_VARIABLE = 1;
       return err;
     }
     conn->state = NULL; /* unsafe to reference pcb after tcp_close(). */
   }
   altcp_free(conn);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -338,10 +371,12 @@ altcp_tcp_shutdown(struct altcp_pcb *conn, int shut_rx, int shut_tx)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_shutdown(pcb, shut_rx, shut_tx);
 }
 
@@ -350,10 +385,12 @@ altcp_tcp_write(struct altcp_pcb *conn, const void *dataptr, u16_t len, u8_t api
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_write(pcb, dataptr, len, apiflags);
 }
 
@@ -362,10 +399,12 @@ altcp_tcp_output(struct altcp_pcb *conn)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_output(pcb);
 }
 
@@ -374,10 +413,12 @@ altcp_tcp_mss(struct altcp_pcb *conn)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_mss(pcb);
 }
 
@@ -386,10 +427,12 @@ altcp_tcp_sndbuf(struct altcp_pcb *conn)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_sndbuf(pcb);
 }
 
@@ -398,10 +441,12 @@ altcp_tcp_sndqueuelen(struct altcp_pcb *conn)
 {
   struct tcp_pcb *pcb;
   if (conn == NULL) {
+    __A_VARIABLE = 1;
     return 0;
   }
   ALTCP_TCP_ASSERT_CONN(conn);
   pcb = (struct tcp_pcb *)conn->state;
+  __A_VARIABLE = 1;
   return tcp_sndqueuelen(pcb);
 }
 
@@ -413,6 +458,7 @@ altcp_tcp_nagle_disable(struct altcp_pcb *conn)
     ALTCP_TCP_ASSERT_CONN(conn);
     tcp_nagle_disable(pcb);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -423,6 +469,7 @@ altcp_tcp_nagle_enable(struct altcp_pcb *conn)
     ALTCP_TCP_ASSERT_CONN(conn);
     tcp_nagle_enable(pcb);
   }
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -431,8 +478,10 @@ altcp_tcp_nagle_disabled(struct altcp_pcb *conn)
   if (conn && conn->state) {
     struct tcp_pcb *pcb = (struct tcp_pcb *)conn->state;
     ALTCP_TCP_ASSERT_CONN(conn);
+    __A_VARIABLE = 1;
     return tcp_nagle_disabled(pcb);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -444,6 +493,7 @@ altcp_tcp_setprio(struct altcp_pcb *conn, u8_t prio)
     ALTCP_TCP_ASSERT_CONN(conn);
     tcp_setprio(pcb, prio);
   }
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -452,6 +502,7 @@ altcp_tcp_dealloc(struct altcp_pcb *conn)
   LWIP_UNUSED_ARG(conn);
   ALTCP_TCP_ASSERT_CONN(conn);
   /* no private state to clean up */
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -460,8 +511,10 @@ altcp_tcp_get_tcp_addrinfo(struct altcp_pcb *conn, int local, ip_addr_t *addr, u
   if (conn) {
     struct tcp_pcb *pcb = (struct tcp_pcb *)conn->state;
     ALTCP_TCP_ASSERT_CONN(conn);
+    __A_VARIABLE = 1;
     return tcp_tcp_get_tcp_addrinfo(pcb, local, addr, port);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -507,9 +560,11 @@ altcp_tcp_dbg_get_tcp_state(struct altcp_pcb *conn)
     struct tcp_pcb *pcb = (struct tcp_pcb *)conn->state;
     ALTCP_TCP_ASSERT_CONN(conn);
     if (pcb) {
+      __A_VARIABLE = 1;
       return pcb->state;
     }
   }
+  __A_VARIABLE = 1;
   return CLOSED;
 }
 #endif
diff --git a/src/core/def.c b/src/core/def.c
index 004a528..9eec5ff 100644
--- a/src/core/def.c
+++ b/src/core/def.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Common functions used throughout the stack.
@@ -75,6 +77,7 @@
 u16_t
 lwip_htons(u16_t n)
 {
+  __A_VARIABLE = 1;
   return PP_HTONS(n);
 }
 #endif /* lwip_htons */
@@ -89,6 +92,7 @@ lwip_htons(u16_t n)
 u32_t
 lwip_htonl(u32_t n)
 {
+  __A_VARIABLE = 1;
   return PP_HTONL(n);
 }
 #endif /* lwip_htonl */
@@ -107,13 +111,16 @@ lwip_strnstr(const char *buffer, const char *token, size_t n)
   const char *p;
   size_t tokenlen = strlen(token);
   if (tokenlen == 0) {
+    __A_VARIABLE = 1;
     return LWIP_CONST_CAST(char *, buffer);
   }
   for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
     if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
+      __A_VARIABLE = 1;
       return LWIP_CONST_CAST(char *, p);
     }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 #endif
@@ -207,6 +214,7 @@ lwip_itoa(char *result, size_t bufsize, int number)
     if (bufsize == 1) {
       *result = 0;
     }
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -226,15 +234,18 @@ lwip_itoa(char *result, size_t bufsize, int number)
   if (n) {
     /* buffer is too small */
     *result = 0;
+    __A_VARIABLE = 1;
     return;
   }
   if (*tmp == 0) {
     /* Nothing added? */
     *res++ = '0';
     *res++ = 0;
+    __A_VARIABLE = 1;
     return;
   }
   /* move from temporary buffer to output buffer (sign is not moved) */
   memmove(res, tmp, (size_t)((result + bufsize) - tmp));
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/src/core/dns.c b/src/core/dns.c
index 737b339..bcd8154 100644
--- a/src/core/dns.c
+++ b/src/core/dns.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * DNS - host name to IP address resolver.
@@ -348,6 +350,7 @@ dns_init(void)
 #if DNS_LOCAL_HOSTLIST
   dns_init_local();
 #endif
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -367,6 +370,7 @@ dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
       dns_servers[numdns] = *IP_ADDR_ANY;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -396,6 +400,7 @@ dns_tmr(void)
 {
   LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
   dns_check_entries();
+  __A_VARIABLE = 1;
 }
 
 #if DNS_LOCAL_HOSTLIST
@@ -426,6 +431,7 @@ dns_init_local(void)
     }
   }
 #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT) */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -457,6 +463,7 @@ dns_local_iterate(dns_found_callback iterator_fn, void *iterator_arg)
     }
   }
 #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -477,6 +484,7 @@ err_t
 dns_local_lookup(const char *hostname, ip_addr_t *addr, u8_t dns_addrtype)
 {
   LWIP_UNUSED_ARG(dns_addrtype);
+  __A_VARIABLE = 1;
   return dns_lookup_local(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype));
 }
 
@@ -569,6 +577,7 @@ dns_local_addhost(const char *hostname, const ip_addr_t *addr)
   LWIP_ASSERT("namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN", namelen <= DNS_LOCAL_HOSTLIST_MAX_NAMELEN);
   entry = (struct local_hostlist_entry *)memp_malloc(MEMP_LOCALHOSTLIST);
   if (entry == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   entry_name = (char *)entry + sizeof(struct local_hostlist_entry);
@@ -578,6 +587,7 @@ dns_local_addhost(const char *hostname, const ip_addr_t *addr)
   ip_addr_copy(entry->addr, *addr);
   entry->next = local_hostlist_dynamic;
   local_hostlist_dynamic = entry;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC*/
@@ -770,6 +780,7 @@ dns_send(u8_t idx)
     dns_call_found(idx, NULL);
     /* flush this entry */
     entry->state = DNS_STATE_UNUSED;
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -855,9 +866,11 @@ dns_send(u8_t idx)
     err = ERR_MEM;
   }
 
+  __A_VARIABLE = 1;
   return err;
 overflow_return:
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -871,6 +884,7 @@ dns_alloc_random_port(void)
   pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
   if (pcb == NULL) {
     /* out of memory, have to reuse an existing pcb */
+    __A_VARIABLE = 1;
     return NULL;
   }
   do {
@@ -884,9 +898,11 @@ dns_alloc_random_port(void)
   } while (err == ERR_USE);
   if (err != ERR_OK) {
     udp_remove(pcb);
+    __A_VARIABLE = 1;
     return NULL;
   }
   udp_recv(pcb, dns_recv, NULL);
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -912,6 +928,7 @@ dns_alloc_pcb(void)
     if (dns_pcbs[i] != NULL) {
       /* succeeded */
       dns_last_pcb_idx = i;
+      __A_VARIABLE = 1;
       return i;
     }
   }
@@ -923,9 +940,11 @@ dns_alloc_pcb(void)
     }
     if (dns_pcbs[idx] != NULL) {
       dns_last_pcb_idx = idx;
+      __A_VARIABLE = 1;
       return idx;
     }
   }
+  __A_VARIABLE = 1;
   return DNS_MAX_SOURCE_PORTS;
 }
 #endif /* ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0) */
@@ -1014,6 +1033,7 @@ again:
     }
   }
 
+  __A_VARIABLE = 1;
   return txid;
 }
 
@@ -1031,6 +1051,7 @@ dns_backupserver_available(struct dns_table_entry *pentry)
     }
   }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -1115,6 +1136,7 @@ dns_check_entry(u8_t i)
       LWIP_ASSERT("unknown dns_table entry state:", 0);
       break;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1128,6 +1150,7 @@ dns_check_entries(void)
   for (i = 0; i < DNS_TABLE_SIZE; ++i) {
     dns_check_entry(i);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1161,6 +1184,7 @@ dns_correct_response(u8_t idx, u32_t ttl)
       entry->state = DNS_STATE_UNUSED;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1526,6 +1550,7 @@ err_t
 dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                   void *callback_arg)
 {
+  __A_VARIABLE = 1;
   return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 }
 
diff --git a/src/core/inet_chksum.c b/src/core/inet_chksum.c
index 25255b9..b41cf1a 100644
--- a/src/core/inet_chksum.c
+++ b/src/core/inet_chksum.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Internet checksum functions.\n
@@ -110,6 +112,7 @@ lwip_standard_chksum(const void *dataptr, int len)
   /* This maybe a little confusing: reorder sum using lwip_htons()
      instead of lwip_ntohs() since it has a little less call overhead.
      The caller must invert bits for Internet sum ! */
+  __A_VARIABLE = 1;
   return lwip_htons((u16_t)acc);
 }
 #endif
@@ -169,6 +172,7 @@ lwip_standard_chksum(const void *dataptr, int len)
     sum = SWAP_BYTES_IN_WORD(sum);
   }
 
+  __A_VARIABLE = 1;
   return (u16_t)sum;
 }
 #endif
@@ -251,6 +255,7 @@ lwip_standard_chksum(const void *dataptr, int len)
     sum = SWAP_BYTES_IN_WORD(sum);
   }
 
+  __A_VARIABLE = 1;
   return (u16_t)sum;
 }
 #endif
@@ -290,6 +295,7 @@ inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
   LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
+  __A_VARIABLE = 1;
   return (u16_t)~(acc & 0xffffUL);
 }
 
@@ -323,6 +329,7 @@ inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
 
+  __A_VARIABLE = 1;
   return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 }
 #endif /* LWIP_IPV4 */
@@ -359,6 +366,7 @@ ip6_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
 
+  __A_VARIABLE = 1;
   return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 }
 #endif /* LWIP_IPV6 */
@@ -436,6 +444,7 @@ inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
   LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
+  __A_VARIABLE = 1;
   return (u16_t)~(acc & 0xffffUL);
 }
 
@@ -469,6 +478,7 @@ inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
 
+  __A_VARIABLE = 1;
   return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 }
 #endif /* LWIP_IPV4 */
@@ -507,6 +517,7 @@ ip6_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
   acc = FOLD_U32T(acc);
   acc = FOLD_U32T(acc);
 
+  __A_VARIABLE = 1;
   return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 }
 #endif /* LWIP_IPV6 */
@@ -554,6 +565,7 @@ ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
 u16_t
 inet_chksum(const void *dataptr, u16_t len)
 {
+  __A_VARIABLE = 1;
   return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 }
 
@@ -584,6 +596,7 @@ inet_chksum_pbuf(struct pbuf *p)
   if (swapped) {
     acc = SWAP_BYTES_IN_WORD(acc);
   }
+  __A_VARIABLE = 1;
   return (u16_t)~(acc & 0xffffUL);
 }
 
@@ -603,6 +616,7 @@ u16_t
 lwip_chksum_copy(void *dst, const void *src, u16_t len)
 {
   MEMCPY(dst, src, len);
+  __A_VARIABLE = 1;
   return LWIP_CHKSUM(dst, len);
 }
 #endif /* (LWIP_CHKSUM_COPY_ALGORITHM == 1) */
diff --git a/src/core/init.c b/src/core/init.c
index b688536..2fdcc26 100644
--- a/src/core/init.c
+++ b/src/core/init.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Modules initialization
@@ -377,4 +379,5 @@ lwip_init(void)
 #if LWIP_TIMERS
   sys_timeouts_init();
 #endif /* LWIP_TIMERS */
+  __A_VARIABLE = 1;
 }
diff --git a/src/core/ip.c b/src/core/ip.c
index d611315..d313d89 100644
--- a/src/core/ip.c
+++ b/src/core/ip.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Common IPv4 and IPv6 code
@@ -155,10 +157,13 @@ ip_input(struct pbuf *p, struct netif *inp)
 {
   if (p != NULL) {
     if (IP_HDR_GET_VERSION(p->payload) == 6) {
+      __A_VARIABLE = 1;
       return ip6_input(p, inp);
     }
+    __A_VARIABLE = 1;
     return ip4_input(p, inp);
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
diff --git a/src/core/ipv4/autoip.c b/src/core/ipv4/autoip.c
index a454504..bdf42b9 100644
--- a/src/core/ipv4/autoip.c
+++ b/src/core/ipv4/autoip.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * AutoIP Automatic LinkLocal IP Configuration
@@ -115,6 +117,7 @@ autoip_set_struct(struct netif *netif, struct autoip *autoip)
   memset(autoip, 0, sizeof(struct autoip));
   /* autoip->state = AUTOIP_STATE_OFF; */
   netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, autoip);
+  __A_VARIABLE = 1;
 }
 
 /** Restart AutoIP client and check the next address (conflict detected)
@@ -127,6 +130,7 @@ autoip_restart(struct netif *netif)
   struct autoip *autoip = netif_autoip_data(netif);
   autoip->tried_llipaddr++;
   autoip_start(netif);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -157,6 +161,7 @@ autoip_handle_arp_conflict(struct netif *netif)
     autoip_arp_announce(netif);
     autoip->lastconflict = DEFEND_INTERVAL * AUTOIP_TICKS_PER_SECOND;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -193,6 +198,7 @@ autoip_create_addr(struct netif *netif, ip4_addr_t *ipaddr)
               ("autoip_create_addr(): tried_llipaddr=%"U16_F", %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                (u16_t)(autoip->tried_llipaddr), ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr),
                ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -205,6 +211,7 @@ autoip_arp_probe(struct netif *netif)
 {
   struct autoip *autoip = netif_autoip_data(netif);
   /* this works because netif->ip_addr is ANY */
+  __A_VARIABLE = 1;
   return etharp_request(netif, &autoip->llipaddr);
 }
 
@@ -216,6 +223,7 @@ autoip_arp_probe(struct netif *netif)
 static err_t
 autoip_arp_announce(struct netif *netif)
 {
+  __A_VARIABLE = 1;
   return etharp_gratuitous(netif);
 }
 
@@ -242,6 +250,7 @@ autoip_bind(struct netif *netif)
   netif_set_addr(netif, &autoip->llipaddr, &sn_mask, &gw_addr);
   /* interface is used by routing now that an address is set */
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -321,6 +330,7 @@ autoip_start_probing(struct netif *netif)
   if (autoip->tried_llipaddr > MAX_CONFLICTS) {
     autoip->ttw = RATE_LIMIT_INTERVAL * AUTOIP_TICKS_PER_SECOND;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -337,6 +347,7 @@ autoip_network_changed(struct netif *netif)
   if (autoip && (autoip->state != AUTOIP_STATE_OFF)) {
     autoip_start_probing(netif);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -357,6 +368,7 @@ autoip_stop(struct netif *netif)
       netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -441,6 +453,7 @@ autoip_tmr(void)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -499,6 +512,7 @@ autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** check if AutoIP supplied netif->ip_addr
@@ -512,8 +526,10 @@ autoip_supplied_address(const struct netif *netif)
 {
   if ((netif != NULL) && (netif_autoip_data(netif) != NULL)) {
     struct autoip *autoip = netif_autoip_data(netif);
+    __A_VARIABLE = 1;
     return (autoip->state == AUTOIP_STATE_BOUND) || (autoip->state == AUTOIP_STATE_ANNOUNCING);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -521,6 +537,7 @@ u8_t
 autoip_accept_packet(struct netif *netif, const ip4_addr_t *addr)
 {
   struct autoip *autoip = netif_autoip_data(netif);
+  __A_VARIABLE = 1;
   return (autoip != NULL) && ip4_addr_cmp(addr, &(autoip->llipaddr));
 }
 
diff --git a/src/core/ipv4/dhcp.c b/src/core/ipv4/dhcp.c
index 89f9c41..fa8bd0f 100644
--- a/src/core/ipv4/dhcp.c
+++ b/src/core/ipv4/dhcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Dynamic Host Configuration Protocol client
@@ -232,6 +234,7 @@ dhcp_inc_pcb_refcount(void)
     dhcp_pcb = udp_new();
 
     if (dhcp_pcb == NULL) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
 
@@ -245,6 +248,7 @@ dhcp_inc_pcb_refcount(void)
 
   dhcp_pcb_refcount++;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -259,6 +263,7 @@ dhcp_dec_pcb_refcount(void)
     udp_remove(dhcp_pcb);
     dhcp_pcb = NULL;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -287,6 +292,7 @@ dhcp_handle_nak(struct netif *netif)
   netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
   /* We can immediately restart discovery */
   dhcp_discover(netif);
+  __A_VARIABLE = 1;
 }
 
 #if DHCP_DOES_ARP_CHECK
@@ -320,6 +326,7 @@ dhcp_check(struct netif *netif)
   msecs = 500;
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
 }
 #endif /* DHCP_DOES_ARP_CHECK */
 
@@ -352,6 +359,7 @@ dhcp_handle_offer(struct netif *netif, struct dhcp_msg *msg_in)
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                 ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void *)netif));
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -419,6 +427,7 @@ dhcp_select(struct netif *netif)
   msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -455,6 +464,7 @@ dhcp_coarse_tmr(void)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -485,6 +495,7 @@ dhcp_fine_tmr(void)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -535,6 +546,7 @@ dhcp_timeout(struct netif *netif)
       dhcp_discover(netif);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -562,6 +574,7 @@ dhcp_t1_timeout(struct netif *netif)
       dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -588,6 +601,7 @@ dhcp_t2_timeout(struct netif *netif)
       dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -676,6 +690,7 @@ dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
     dns_setserver(n, &dns_addr);
   }
 #endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -698,6 +713,7 @@ dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
   memset(dhcp, 0, sizeof(struct dhcp));
   /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
   netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -718,6 +734,7 @@ void dhcp_cleanup(struct netif *netif)
     mem_free(netif_dhcp_data(netif));
     netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -821,6 +838,7 @@ dhcp_inform(struct netif *netif)
   LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 
   if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -847,6 +865,7 @@ dhcp_inform(struct netif *netif)
   }
 
   dhcp_dec_pcb_refcount(); /* delete DHCP PCB if not needed any more */
+  __A_VARIABLE = 1;
 }
 
 /** Handle a possible change in the network configuration.
@@ -860,6 +879,7 @@ dhcp_network_changed(struct netif *netif)
   struct dhcp *dhcp = netif_dhcp_data(netif);
 
   if (!dhcp) {
+    __A_VARIABLE = 1;
     return;
   }
   switch (dhcp->state) {
@@ -889,6 +909,7 @@ dhcp_network_changed(struct netif *netif)
       dhcp_discover(netif);
       break;
   }
+  __A_VARIABLE = 1;
 }
 
 #if DHCP_DOES_ARP_CHECK
@@ -920,6 +941,7 @@ dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
       dhcp_decline(netif);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -967,6 +989,7 @@ dhcp_decline(struct netif *netif)
   msecs = 10 * 1000;
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* DHCP_DOES_ARP_CHECK */
@@ -1027,6 +1050,7 @@ dhcp_discover(struct netif *netif)
   msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1138,6 +1162,7 @@ dhcp_bind(struct netif *netif)
 
   netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
   /* interface is used by routing now that an address is set */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1194,6 +1219,7 @@ dhcp_renew(struct netif *netif)
   msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1248,6 +1274,7 @@ dhcp_rebind(struct netif *netif)
   msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1305,6 +1332,7 @@ dhcp_reboot(struct netif *netif)
   msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
   dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1323,11 +1351,13 @@ dhcp_release_and_stop(struct netif *netif)
   LWIP_ASSERT_CORE_LOCKED();
   LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
   if (dhcp == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
   /* already off? -> nothing to do */
   if (dhcp->state == DHCP_STATE_OFF) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -1383,6 +1413,7 @@ dhcp_release_and_stop(struct netif *netif)
     dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
     dhcp->pcb_allocated = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1394,6 +1425,7 @@ err_t
 dhcp_release(struct netif *netif)
 {
   dhcp_release_and_stop(netif);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1406,6 +1438,7 @@ void
 dhcp_stop(struct netif *netif)
 {
   dhcp_release_and_stop(netif);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1421,6 +1454,7 @@ dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
     dhcp->tries = 0;
     dhcp->request_timeout = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1434,6 +1468,7 @@ dhcp_option(u16_t options_out_len, u8_t *options, u8_t option_type, u8_t option_
   LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
   options[options_out_len++] = option_type;
   options[options_out_len++] = option_len;
+  __A_VARIABLE = 1;
   return options_out_len;
 }
 /*
@@ -1445,6 +1480,7 @@ dhcp_option_byte(u16_t options_out_len, u8_t *options, u8_t value)
 {
   LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
   options[options_out_len++] = value;
+  __A_VARIABLE = 1;
   return options_out_len;
 }
 
@@ -1454,6 +1490,7 @@ dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
   LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
   options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
   options[options_out_len++] = (u8_t) (value & 0x00ffU);
+  __A_VARIABLE = 1;
   return options_out_len;
 }
 
@@ -1465,6 +1502,7 @@ dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
   options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
   options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
   options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
+  __A_VARIABLE = 1;
   return options_out_len;
 }
 
@@ -1489,6 +1527,7 @@ dhcp_option_hostname(u16_t options_out_len, u8_t *options, struct netif *netif)
       }
     }
   }
+  __A_VARIABLE = 1;
   return options_out_len;
 }
 #endif /* LWIP_NETIF_HOSTNAME */
@@ -1861,6 +1900,7 @@ dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr,
 
 free_pbuf_and_return:
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1900,6 +1940,7 @@ dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t
   if (p_out == NULL) {
     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                 ("dhcp_create_msg(): could not allocate pbuf\n"));
+    __A_VARIABLE = 1;
     return NULL;
   }
   LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
@@ -1947,6 +1988,7 @@ dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t
   if (options_out_len) {
     *options_out_len = options_out_len_loc;
   }
+  __A_VARIABLE = 1;
   return p_out;
 }
 
@@ -1968,6 +2010,7 @@ dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
   }
   /* shrink the pbuf to the actual content length */
   pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
+  __A_VARIABLE = 1;
 }
 
 /** check if DHCP supplied netif->ip_addr
@@ -1981,9 +2024,11 @@ dhcp_supplied_address(const struct netif *netif)
 {
   if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
     struct dhcp *dhcp = netif_dhcp_data(netif);
+    __A_VARIABLE = 1;
     return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
            (dhcp->state == DHCP_STATE_REBINDING);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/src/core/ipv4/etharp.c b/src/core/ipv4/etharp.c
index 570aaa3..21b4488 100644
--- a/src/core/ipv4/etharp.c
+++ b/src/core/ipv4/etharp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Address Resolution Protocol module for IP over Ethernet
@@ -155,6 +157,7 @@ free_etharp_q(struct etharp_q_entry *q)
     pbuf_free(r->p);
     memp_free(MEMP_ARP_QUEUE, r);
   }
+  __A_VARIABLE = 1;
 }
 #else /* ARP_QUEUEING */
 
@@ -185,6 +188,7 @@ etharp_free_entry(int i)
   ip4_addr_set_zero(&arp_table[i].ipaddr);
   arp_table[i].ethaddr = ethzero;
 #endif /* LWIP_DEBUG */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -229,6 +233,7 @@ etharp_tmr(void)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -511,9 +516,11 @@ etharp_add_static_entry(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr)
 
   netif = ip4_route(ipaddr);
   if (netif == NULL) {
+    __A_VARIABLE = 1;
     return ERR_RTE;
   }
 
+  __A_VARIABLE = 1;
   return etharp_update_arp_entry(netif, ipaddr, ethaddr, ETHARP_FLAG_TRY_HARD | ETHARP_FLAG_STATIC_ENTRY);
 }
 
@@ -537,15 +544,18 @@ etharp_remove_static_entry(const ip4_addr_t *ipaddr)
   i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY, NULL);
   /* bail out if no entry could be found */
   if (i < 0) {
+    __A_VARIABLE = 1;
     return (err_t)i;
   }
 
   if (arp_table[i].state != ETHARP_STATE_STATIC) {
     /* entry wasn't a static entry, cannot remove it */
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
   /* entry found, free it */
   etharp_free_entry(i);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
@@ -566,6 +576,7 @@ etharp_cleanup_netif(struct netif *netif)
       etharp_free_entry(i);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -594,8 +605,10 @@ etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
   if ((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
     *eth_ret = &arp_table[i].ethaddr;
     *ip_ret = &arp_table[i].ipaddr;
+    __A_VARIABLE = 1;
     return i;
   }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -662,6 +675,7 @@ etharp_input(struct pbuf *p, struct netif *netif)
     ETHARP_STATS_INC(etharp.proterr);
     ETHARP_STATS_INC(etharp.drop);
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return;
   }
   ETHARP_STATS_INC(etharp.recv);
@@ -739,6 +753,7 @@ etharp_input(struct pbuf *p, struct netif *netif)
   }
   /* free ARP packet */
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 /** Just a small helper function that sends a pbuf to an ethernet address
@@ -766,6 +781,7 @@ etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t
     }
   }
 
+  __A_VARIABLE = 1;
   return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 }
 
@@ -943,6 +959,7 @@ etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
       ip4_addr_ismulticast(ipaddr) ||
       ip4_addr_isany(ipaddr)) {
     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
@@ -956,6 +973,7 @@ etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
       ETHARP_STATS_INC(etharp.memerr);
     }
+    __A_VARIABLE = 1;
     return (err_t)i_err;
   }
   LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
@@ -985,6 +1003,7 @@ etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
          etharp_query again could lead to sending the queued packets. */
     }
     if (q == NULL) {
+      __A_VARIABLE = 1;
       return result;
     }
   }
@@ -1079,6 +1098,7 @@ etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
       result = ERR_MEM;
     }
   }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1117,6 +1137,7 @@ etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                 ("etharp_raw: could not allocate pbuf for ARP request.\n"));
     ETHARP_STATS_INC(etharp.memerr);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
@@ -1162,6 +1183,7 @@ etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
   p = NULL;
   /* could not allocate pbuf for ARP request */
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1180,6 +1202,7 @@ etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 static err_t
 etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
 {
+  __A_VARIABLE = 1;
   return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
                     (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
                     ipaddr, ARP_REQUEST);
@@ -1198,6 +1221,7 @@ err_t
 etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
 {
   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
+  __A_VARIABLE = 1;
   return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 }
 
diff --git a/src/core/ipv4/icmp.c b/src/core/ipv4/icmp.c
index fd9054b..44a10ee 100644
--- a/src/core/ipv4/icmp.c
+++ b/src/core/ipv4/icmp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * ICMP - Internet Control Message Protocol
@@ -309,6 +311,7 @@ icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
 {
   MIB2_STATS_INC(mib2.icmpoutdestunreachs);
   icmp_send_response(p, ICMP_DUR, t);
+  __A_VARIABLE = 1;
 }
 
 #if IP_FORWARD || IP_REASSEMBLY
@@ -324,6 +327,7 @@ icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
 {
   MIB2_STATS_INC(mib2.icmpouttimeexcds);
   icmp_send_response(p, ICMP_TE, t);
+  __A_VARIABLE = 1;
 }
 
 #endif /* IP_FORWARD || IP_REASSEMBLY */
diff --git a/src/core/ipv4/igmp.c b/src/core/ipv4/igmp.c
index 61f45d9..4310167 100644
--- a/src/core/ipv4/igmp.c
+++ b/src/core/ipv4/igmp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * IGMP - Internet Group Management Protocol
@@ -117,6 +119,7 @@ igmp_init(void)
 
   IP4_ADDR(&allsystems, 224, 0, 0, 1);
   IP4_ADDR(&allrouters, 224, 0, 0, 2);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -145,9 +148,11 @@ igmp_start(struct netif *netif)
       netif->igmp_mac_filter(netif, &allsystems, NETIF_ADD_MAC_FILTER);
     }
 
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
+  __A_VARIABLE = 1;
   return ERR_MEM;
 }
 
@@ -180,6 +185,7 @@ igmp_stop(struct netif *netif)
     /* move to "next" */
     group = next;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -204,6 +210,7 @@ igmp_report_groups(struct netif *netif)
     igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
     group = group->next;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -221,6 +228,7 @@ igmp_lookfor_group(struct netif *ifp, const ip4_addr_t *addr)
 
   while (group != NULL) {
     if (ip4_addr_cmp(&(group->group_address), addr)) {
+      __A_VARIABLE = 1;
       return group;
     }
     group = group->next;
@@ -229,6 +237,7 @@ igmp_lookfor_group(struct netif *ifp, const ip4_addr_t *addr)
   /* to be clearer, we return NULL here instead of
    * 'group' (which is also NULL at this point).
    */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -250,6 +259,7 @@ igmp_lookup_group(struct netif *ifp, const ip4_addr_t *addr)
   group = igmp_lookfor_group(ifp, addr);
   if (group != NULL) {
     /* Group already exists. */
+    __A_VARIABLE = 1;
     return group;
   }
 
@@ -282,6 +292,7 @@ igmp_lookup_group(struct netif *ifp, const ip4_addr_t *addr)
   ip4_addr_debug_print(IGMP_DEBUG, addr);
   LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", (void *)ifp));
 
+  __A_VARIABLE = 1;
   return group;
 }
 
@@ -309,6 +320,7 @@ igmp_remove_group(struct netif *netif, struct igmp_group *group)
     err = ERR_ARG;
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -333,6 +345,7 @@ igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest)
     pbuf_free(p);
     IGMP_STATS_INC(igmp.lenerr);
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: length error\n"));
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -348,6 +361,7 @@ igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest)
     pbuf_free(p);
     IGMP_STATS_INC(igmp.chkerr);
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: checksum error\n"));
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -359,6 +373,7 @@ igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest)
     pbuf_free(p);
     IGMP_STATS_INC(igmp.drop);
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP frame not for us\n"));
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -434,6 +449,7 @@ igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest)
   }
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -465,11 +481,13 @@ igmp_joingroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr)
       if (err != ERR_OK) {
         /* Return an error even if some network interfaces are joined */
         /** @todo undo any other netif already joined */
+        __A_VARIABLE = 1;
         return err;
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -566,6 +584,7 @@ igmp_leavegroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr)
     }
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -655,6 +674,7 @@ igmp_tmr(void)
       group = group->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -679,6 +699,7 @@ igmp_timeout(struct netif *netif, struct igmp_group *group)
     IGMP_STATS_INC(igmp.tx_report);
     igmp_send(netif, group, IGMP_V2_MEMB_REPORT);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -701,6 +722,7 @@ igmp_start_timer(struct igmp_group *group, u8_t max_time)
   if (group->timer == 0) {
     group->timer = 1;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -718,6 +740,7 @@ igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
     igmp_start_timer(group, maxresp);
     group->group_state = IGMP_GROUP_DELAYING_MEMBER;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -745,6 +768,7 @@ igmp_ip_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
   ra[0] = PP_HTONS(ROUTER_ALERT);
   ra[1] = 0x0000; /* Router shall examine packet */
   IGMP_STATS_INC(igmp.xmit);
+  __A_VARIABLE = 1;
   return ip4_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
 }
 
@@ -796,6 +820,7 @@ igmp_send(struct netif *netif, struct igmp_group *group, u8_t type)
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
     IGMP_STATS_INC(igmp.memerr);
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_IPV4 && LWIP_IGMP */
diff --git a/src/core/ipv4/ip4.c b/src/core/ipv4/ip4.c
index 00b09f9..7f32657 100644
--- a/src/core/ipv4/ip4.c
+++ b/src/core/ipv4/ip4.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * This is the IPv4 layer implementation for incoming and outgoing IP traffic.
diff --git a/src/core/ipv4/ip4_addr.c b/src/core/ipv4/ip4_addr.c
index 92077c2..562b2b7 100644
--- a/src/core/ipv4/ip4_addr.c
+++ b/src/core/ipv4/ip4_addr.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * This is the IPv4 address tools implementation.
@@ -105,10 +107,12 @@ ip4_addr_netmask_valid(u32_t netmask)
   for (; mask != 0; mask >>= 1) {
     if ((nm_hostorder & mask) != 0) {
       /* there is a one after the first zero -> invalid */
+      __A_VARIABLE = 1;
       return 0;
     }
   }
   /* no one after the first zero -> valid */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -125,8 +129,10 @@ ipaddr_addr(const char *cp)
   ip4_addr_t val;
 
   if (ip4addr_aton(cp, &val)) {
+    __A_VARIABLE = 1;
     return ip4_addr_get_u32(&val);
   }
+  __A_VARIABLE = 1;
   return (IPADDR_NONE);
 }
 
@@ -267,6 +273,7 @@ char *
 ip4addr_ntoa(const ip4_addr_t *addr)
 {
   static char str[IP4ADDR_STRLEN_MAX];
+  __A_VARIABLE = 1;
   return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 }
 
@@ -304,17 +311,20 @@ ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
     } while (*ap);
     while (i--) {
       if (len++ >= buflen) {
+        __A_VARIABLE = 1;
         return NULL;
       }
       *rp++ = inv[i];
     }
     if (len++ >= buflen) {
+      __A_VARIABLE = 1;
       return NULL;
     }
     *rp++ = '.';
     ap++;
   }
   *--rp = 0;
+  __A_VARIABLE = 1;
   return buf;
 }
 
diff --git a/src/core/ipv4/ip4_frag.c b/src/core/ipv4/ip4_frag.c
index b2fd14c..b3972bd 100644
--- a/src/core/ipv4/ip4_frag.c
+++ b/src/core/ipv4/ip4_frag.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * This is the IPv4 packet segmentation and reassembly implementation.
@@ -149,6 +151,7 @@ ip_reass_tmr(void)
       ip_reass_free_complete_datagram(tmp, prev);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -210,6 +213,7 @@ ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *p
   LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
   ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
 
+  __A_VARIABLE = 1;
   return pbufs_freed;
 }
 
@@ -264,6 +268,7 @@ ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
       pbufs_freed += pbufs_freed_current;
     }
   } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
+  __A_VARIABLE = 1;
   return pbufs_freed;
 }
 #endif /* IP_REASS_FREE_OLDEST */
@@ -294,6 +299,7 @@ ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
     {
       IPFRAG_STATS_INC(ip_frag.memerr);
       LWIP_DEBUGF(IP_REASS_DEBUG, ("Failed to alloc reassdata struct\n"));
+      __A_VARIABLE = 1;
       return NULL;
     }
   }
@@ -306,6 +312,7 @@ ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
   /* copy the ip header for later tests and input */
   /* @todo: no ip options supported? */
   SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
+  __A_VARIABLE = 1;
   return ipr;
 }
 
@@ -328,6 +335,7 @@ ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
 
   /* now we can free the ip_reassdata struct */
   memp_free(MEMP_REASSDATA, ipr);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -698,6 +706,7 @@ nullreturn:
 static struct pbuf_custom_ref *
 ip_frag_alloc_pbuf_custom_ref(void)
 {
+  __A_VARIABLE = 1;
   return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
 }
 
@@ -707,6 +716,7 @@ ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
 {
   LWIP_ASSERT("p != NULL", p != NULL);
   memp_free(MEMP_FRAG_PBUF, p);
+  __A_VARIABLE = 1;
 }
 
 /** Free-callback function to free a 'struct pbuf_custom_ref', called by
@@ -721,6 +731,7 @@ ipfrag_free_pbuf_custom(struct pbuf *p)
     pbuf_free(pcr->original);
   }
   ip_frag_free_pbuf_custom_ref(pcr);
+  __A_VARIABLE = 1;
 }
 #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
 
diff --git a/src/core/ipv6/dhcp6.c b/src/core/ipv6/dhcp6.c
index 1ae8742..4feef5c 100644
--- a/src/core/ipv6/dhcp6.c
+++ b/src/core/ipv6/dhcp6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
diff --git a/src/core/ipv6/ethip6.c b/src/core/ipv6/ethip6.c
index 0a616b6..d4c866b 100644
--- a/src/core/ipv6/ethip6.c
+++ b/src/core/ipv6/ethip6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -98,6 +100,7 @@ ethip6_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr)
     dest.addr[5] = ((const u8_t *)(&(ip6addr->addr[3])))[3];
 
     /* Send out. */
+    __A_VARIABLE = 1;
     return ethernet_output(netif, q, (const struct eth_addr*)(netif->hwaddr), &dest, ETHTYPE_IPV6);
   }
 
@@ -107,16 +110,19 @@ ethip6_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr)
   /* Ask ND6 what to do with the packet. */
   result = nd6_get_next_hop_addr_or_queue(netif, q, ip6addr, &hwaddr);
   if (result != ERR_OK) {
+    __A_VARIABLE = 1;
     return result;
   }
 
   /* If no hardware address is returned, nd6 has queued the packet for later. */
   if (hwaddr == NULL) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
   /* Send out the packet using the returned hardware address. */
   SMEMCPY(dest.addr, hwaddr, 6);
+  __A_VARIABLE = 1;
   return ethernet_output(netif, q, (const struct eth_addr*)(netif->hwaddr), &dest, ETHTYPE_IPV6);
 }
 
diff --git a/src/core/ipv6/icmp6.c b/src/core/ipv6/icmp6.c
index 7c93668..7500e7c 100644
--- a/src/core/ipv6/icmp6.c
+++ b/src/core/ipv6/icmp6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -220,6 +222,7 @@ void
 icmp6_dest_unreach(struct pbuf *p, enum icmp6_dur_code c)
 {
   icmp6_send_response(p, c, 0, ICMP6_TYPE_DUR);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -236,6 +239,7 @@ void
 icmp6_packet_too_big(struct pbuf *p, u32_t mtu)
 {
   icmp6_send_response(p, 0, mtu, ICMP6_TYPE_PTB);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -252,6 +256,7 @@ void
 icmp6_time_exceeded(struct pbuf *p, enum icmp6_te_code c)
 {
   icmp6_send_response(p, c, 0, ICMP6_TYPE_TE);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -274,6 +279,7 @@ icmp6_time_exceeded_with_addrs(struct pbuf *p, enum icmp6_te_code c,
     const ip6_addr_t *src_addr, const ip6_addr_t *dest_addr)
 {
   icmp6_send_response_with_addrs(p, c, 0, ICMP6_TYPE_TE, src_addr, dest_addr);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -293,6 +299,7 @@ icmp6_param_problem(struct pbuf *p, enum icmp6_pp_code c, const void *pointer)
 {
   u32_t pointer_u32 = (u32_t)((const u8_t *)pointer - (const u8_t *)ip6_current_header());
   icmp6_send_response(p, c, pointer_u32, ICMP6_TYPE_PP);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -318,9 +325,11 @@ icmp6_send_response(struct pbuf *p, u8_t code, u32_t data, u8_t type)
   reply_src = ip_2_ip6(ip6_select_source_address(netif, reply_dest));
   if (reply_src == NULL) {
     ICMP6_STATS_INC(icmp6.rterr);
+    __A_VARIABLE = 1;
     return;
   }
   icmp6_send_response_with_addrs_and_netif(p, code, data, type, reply_src, reply_dest, netif);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -363,10 +372,12 @@ icmp6_send_response_with_addrs(struct pbuf *p, u8_t code, u32_t data, u8_t type,
   netif = ip6_route(reply_src, reply_dest);
   if (netif == NULL) {
     ICMP6_STATS_INC(icmp6.rterr);
+    __A_VARIABLE = 1;
     return;
   }
   icmp6_send_response_with_addrs_and_netif(p, code, data, type, reply_src,
     reply_dest, netif);
+  __A_VARIABLE = 1;
 }
 
 /**
diff --git a/src/core/ipv6/inet6.c b/src/core/ipv6/inet6.c
index 7cb16aa..49072a7 100644
--- a/src/core/ipv6/inet6.c
+++ b/src/core/ipv6/inet6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
diff --git a/src/core/ipv6/ip6.c b/src/core/ipv6/ip6.c
index b0906a3..afbcbc1 100644
--- a/src/core/ipv6/ip6.c
+++ b/src/core/ipv6/ip6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -334,6 +336,7 @@ ip6_select_source_address(struct netif *netif, const ip6_addr_t *dest)
      * assignment, so do not compare zones in this case. */
     cand_bits = ip6_addr_netcmp_zoneless(cand_addr, dest); /* just 1 or 0 for now */
     if (cand_bits && ip6_addr_nethostcmp(cand_addr, dest)) {
+      __A_VARIABLE = 1;
       return netif_ip_addr6(netif, i); /* Rule 1 */
     }
     if ((best_addr == NULL) || /* no alternative yet */
@@ -349,6 +352,7 @@ ip6_select_source_address(struct netif *netif, const ip6_addr_t *dest)
     }
   }
 
+  __A_VARIABLE = 1;
   return best_addr; /* may be NULL */
 }
 
@@ -484,10 +488,12 @@ ip6_input_accept(struct netif *netif)
 #endif /* IPV6_CUSTOM_SCOPES */
       ) {
         /* accept on this netif */
+        __A_VARIABLE = 1;
         return 1;
       }
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -532,12 +538,14 @@ ip6_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     IP6_STATS_INC(ip6.err);
     IP6_STATS_INC(ip6.drop);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
 #ifdef LWIP_HOOK_IP6_INPUT
   if (LWIP_HOOK_IP6_INPUT(p, inp)) {
     /* the packet has been eaten */
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 #endif
@@ -558,6 +566,7 @@ ip6_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     IP6_STATS_INC(ip6.lenerr);
     IP6_STATS_INC(ip6.drop);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -578,6 +587,7 @@ ip6_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     IP6_STATS_INC(ip6.err);
     IP6_STATS_INC(ip6.drop);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -1115,6 +1125,7 @@ ip6_input_cleanup:
   ip6_addr_set_zero(ip6_current_src_addr());
   ip6_addr_set_zero(ip6_current_dest_addr());
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1158,10 +1169,12 @@ ip6_output_if(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
         /* No appropriate source address was found for this packet. */
         LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip6_output: No suitable source address for packet.\n"));
         IP6_STATS_INC(ip6.rterr);
+        __A_VARIABLE = 1;
         return ERR_RTE;
       }
     }
   }
+  __A_VARIABLE = 1;
   return ip6_output_if_src(p, src_used, dest, hl, tc, nexth, netif);
 }
 
@@ -1318,9 +1331,11 @@ ip6_output(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
         IP6_ADDR_BLOCK7(dest),
         IP6_ADDR_BLOCK8(dest)));
     IP6_STATS_INC(ip6.rterr);
+    __A_VARIABLE = 1;
     return ERR_RTE;
   }
 
+  __A_VARIABLE = 1;
   return ip6_output_if(p, src, dest, hl, tc, nexth, netif);
 }
 
@@ -1377,6 +1392,7 @@ ip6_output_hinted(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
         IP6_ADDR_BLOCK7(dest),
         IP6_ADDR_BLOCK8(dest)));
     IP6_STATS_INC(ip6.rterr);
+    __A_VARIABLE = 1;
     return ERR_RTE;
   }
 
@@ -1384,6 +1400,7 @@ ip6_output_hinted(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
   err = ip6_output_if(p, src, dest, hl, tc, nexth, netif);
   NETIF_RESET_HINTS(netif);
 
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* LWIP_NETIF_USE_HINTS*/
@@ -1413,6 +1430,7 @@ ip6_options_add_hbh_ra(struct pbuf *p, u8_t nexth, u8_t value)
   if (pbuf_add_header(p, sizeof(struct ip6_hbh_hdr) + hlen)) {
     LWIP_DEBUGF(IP6_DEBUG, ("ip6_options: no space for options header\n"));
     IP6_STATS_INC(ip6.err);
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
@@ -1439,6 +1457,7 @@ ip6_options_add_hbh_ra(struct pbuf *p, u8_t nexth, u8_t value)
   IP6_OPT_TYPE(opt_hdr) = IP6_PADN_OPTION;
   IP6_OPT_DLEN(opt_hdr) = 0;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_IPV6_MLD */
@@ -1486,6 +1505,7 @@ ip6_debug_print(struct pbuf *p)
                     IP6_ADDR_BLOCK7(&(ip6hdr->dest)),
                     IP6_ADDR_BLOCK8(&(ip6hdr->dest))));
   LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
+  __A_VARIABLE = 1;
 }
 #endif /* IP6_DEBUG */
 
diff --git a/src/core/ipv6/ip6_addr.c b/src/core/ipv6/ip6_addr.c
index aafba72..c3d45ca 100644
--- a/src/core/ipv6/ip6_addr.c
+++ b/src/core/ipv6/ip6_addr.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -206,6 +208,7 @@ char *
 ip6addr_ntoa(const ip6_addr_t *addr)
 {
   static char str[40];
+  __A_VARIABLE = 1;
   return ip6addr_ntoa_r(addr, str, 40);
 }
 
diff --git a/src/core/ipv6/ip6_frag.c b/src/core/ipv6/ip6_frag.c
index 0f277b6..268b910 100644
--- a/src/core/ipv6/ip6_frag.c
+++ b/src/core/ipv6/ip6_frag.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -135,6 +137,7 @@ ip6_reass_tmr(void)
       ip6_reass_free_complete_datagram(tmp);
      }
    }
+   __A_VARIABLE = 1;
 }
 
 /**
@@ -221,6 +224,7 @@ ip6_reass_free_complete_datagram(struct ip6_reassdata *ipr)
   /* Finally, update number of pbufs in reassembly queue */
   LWIP_ASSERT("ip_reass_pbufcount >= clen", ip6_reass_pbufcount >= pbufs_freed);
   ip6_reass_pbufcount = (u16_t)(ip6_reass_pbufcount - pbufs_freed);
+  __A_VARIABLE = 1;
 }
 
 #if IP_REASS_FREE_OLDEST
@@ -252,12 +256,14 @@ ip6_reass_remove_oldest_datagram(struct ip6_reassdata *ipr, int pbufs_needed)
     }
     if (oldest == ipr) {
       /* nothing to free, ipr is the only element on the list */
+      __A_VARIABLE = 1;
       return;
     }
     if (oldest != NULL) {
       ip6_reass_free_complete_datagram(oldest);
     }
   } while (((ip6_reass_pbufcount + pbufs_needed) > IP_REASS_MAX_PBUFS) && (reassdatagrams != NULL));
+  __A_VARIABLE = 1;
 }
 #endif /* IP_REASS_FREE_OLDEST */
 
@@ -654,18 +660,22 @@ ip6_reass(struct pbuf *p)
     if (pbuf_header_force(p, (s16_t)((u8_t*)p->payload - (u8_t*)iphdr_ptr))) {
       LWIP_ASSERT("ip6_reass: moving p->payload to ip6 header failed\n", 0);
       pbuf_free(p);
+      __A_VARIABLE = 1;
       return NULL;
     }
 
     /* Return the pbuf chain */
+    __A_VARIABLE = 1;
     return p;
   }
   /* the datagram is not (yet?) reassembled completely */
+  __A_VARIABLE = 1;
   return NULL;
 
 nullreturn:
   IP6_FRAG_STATS_INC(ip6_frag.drop);
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -678,6 +688,7 @@ nullreturn:
 static struct pbuf_custom_ref*
 ip6_frag_alloc_pbuf_custom_ref(void)
 {
+  __A_VARIABLE = 1;
   return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 }
 
@@ -687,6 +698,7 @@ ip6_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
 {
   LWIP_ASSERT("p != NULL", p != NULL);
   memp_free(MEMP_FRAG_PBUF, p);
+  __A_VARIABLE = 1;
 }
 
 /** Free-callback function to free a 'struct pbuf_custom_ref', called by
@@ -701,6 +713,7 @@ ip6_frag_free_pbuf_custom(struct pbuf *p)
     pbuf_free(pcr->original);
   }
   ip6_frag_free_pbuf_custom_ref(pcr);
+  __A_VARIABLE = 1;
 }
 #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
 
diff --git a/src/core/ipv6/mld6.c b/src/core/ipv6/mld6.c
index db1d09a..9a76df5 100644
--- a/src/core/ipv6/mld6.c
+++ b/src/core/ipv6/mld6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Multicast listener discovery
@@ -113,6 +115,7 @@ mld6_stop(struct netif *netif)
     /* move to "next" */
     group = next;
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -130,6 +133,7 @@ mld6_report_groups(struct netif *netif)
     mld6_delayed_report(group, MLD6_JOIN_DELAYING_MEMBER_TMR_MS);
     group = group->next;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -147,11 +151,13 @@ mld6_lookfor_group(struct netif *ifp, const ip6_addr_t *addr)
 
   while (group != NULL) {
     if (ip6_addr_cmp(&(group->group_address), addr)) {
+      __A_VARIABLE = 1;
       return group;
     }
     group = group->next;
   }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -181,6 +187,7 @@ mld6_new_group(struct netif *ifp, const ip6_addr_t *addr)
     netif_set_client_data(ifp, LWIP_NETIF_CLIENT_DATA_INDEX_MLD6, group);
   }
 
+  __A_VARIABLE = 1;
   return group;
 }
 
@@ -213,6 +220,7 @@ mld6_remove_group(struct netif *netif, struct mld_group *group)
     }
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -237,6 +245,7 @@ mld6_input(struct pbuf *p, struct netif *inp)
     pbuf_free(p);
     MLD6_STATS_INC(mld6.lenerr);
     MLD6_STATS_INC(mld6.drop);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -294,6 +303,7 @@ mld6_input(struct pbuf *p, struct netif *inp)
   }
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -326,11 +336,13 @@ mld6_joingroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr)
         netif_get_ip6_addr_match(netif, srcaddr) >= 0) {
       err = mld6_joingroup_netif(netif, groupaddr);
       if (err != ERR_OK) {
+        __A_VARIABLE = 1;
         return err;
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -369,6 +381,7 @@ mld6_joingroup_netif(struct netif *netif, const ip6_addr_t *groupaddr)
     /* Joining a new group. Create a new group entry. */
     group = mld6_new_group(netif, groupaddr);
     if (group == NULL) {
+      __A_VARIABLE = 1;
       return ERR_MEM;
     }
 
@@ -385,6 +398,7 @@ mld6_joingroup_netif(struct netif *netif, const ip6_addr_t *groupaddr)
 
   /* Increment group use */
   group->use++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -421,6 +435,7 @@ mld6_leavegroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr)
     }
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -478,10 +493,12 @@ mld6_leavegroup_netif(struct netif *netif, const ip6_addr_t *groupaddr)
     }
 
     /* Left group */
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
   /* Group not found */
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -515,6 +532,7 @@ mld6_tmr(void)
       group = group->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -548,6 +566,7 @@ mld6_delayed_report(struct mld_group *group, u16_t maxresp_in)
     group->timer = maxresp;
     group->group_state = MLD6_GROUP_DELAYING_MEMBER;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
diff --git a/src/core/ipv6/nd6.c b/src/core/ipv6/nd6.c
index 5deb3f1..e410c9e 100644
--- a/src/core/ipv6/nd6.c
+++ b/src/core/ipv6/nd6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
diff --git a/src/core/mem.c b/src/core/mem.c
index 16fd984..df97fa5 100644
--- a/src/core/mem.c
+++ b/src/core/mem.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Dynamic memory manager
@@ -126,6 +128,7 @@ mem_overflow_check_raw(void *p, size_t size, const char *descr1, const char *des
   LWIP_UNUSED_ARG(desc);
   LWIP_UNUSED_ARG(descr);
 #endif
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -148,6 +151,7 @@ mem_overflow_init_raw(void *p, size_t size)
   LWIP_UNUSED_ARG(p);
   LWIP_UNUSED_ARG(desc);
 #endif /* MEM_SANITY_REGION_BEFORE_ALIGNED > 0 || MEM_SANITY_REGION_AFTER_ALIGNED > 0 */
+  __A_VARIABLE = 1;
 }
 #endif /* MEM_OVERFLOW_CHECK || MEMP_OVERFLOW_CHECK */
 
@@ -159,6 +163,7 @@ mem_overflow_init_raw(void *p, size_t size)
 void
 mem_init(void)
 {
+	__A_VARIABLE = 1;
 }
 
 /** mem_trim is not used when using pools instead of a heap or using
@@ -169,6 +174,7 @@ void *
 mem_trim(void *mem, mem_size_t size)
 {
   LWIP_UNUSED_ARG(size);
+  __A_VARIABLE = 1;
   return mem;
 }
 #endif /* MEM_LIBC_MALLOC || MEM_USE_POOLS */
@@ -217,6 +223,7 @@ mem_malloc(mem_size_t size)
     MEM_STATS_INC_USED_LOCKED(used, size);
 #endif
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -234,6 +241,7 @@ mem_free(void *rmem)
   MEM_STATS_DEC_USED_LOCKED(used, *(mem_size_t *)rmem);
 #endif
   mem_clib_free(rmem);
+  __A_VARIABLE = 1;
 }
 
 #elif MEM_USE_POOLS
@@ -269,6 +277,7 @@ mem_malloc(mem_size_t size)
         }
 #endif /* MEM_USE_POOLS_TRY_BIGGER_POOL */
         MEM_STATS_INC_LOCKED(err);
+        __A_VARIABLE = 1;
         return NULL;
       }
       break;
@@ -277,6 +286,7 @@ mem_malloc(mem_size_t size)
   if (poolnr > MEMP_POOL_LAST) {
     LWIP_ASSERT("mem_malloc(): no pool is that big!", 0);
     MEM_STATS_INC_LOCKED(err);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -294,6 +304,7 @@ mem_malloc(mem_size_t size)
   /* initialize unused memory (diff between requested size and selected pool's size) */
   memset((u8_t *)ret + size, 0xcd, memp_pools[poolnr]->size - size);
 #endif /* MEMP_OVERFLOW_CHECK */
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -336,6 +347,7 @@ mem_free(void *rmem)
 
   /* and put it in the pool we saved earlier */
   memp_free(hmem->poolnr, hmem);
+  __A_VARIABLE = 1;
 }
 
 #else /* MEM_USE_POOLS */
@@ -434,6 +446,7 @@ mem_overflow_init_element(struct mem *mem, mem_size_t user_size)
   void *p = (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
   mem->user_size = user_size;
   mem_overflow_init_raw(p, user_size);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -441,6 +454,7 @@ mem_overflow_check_element(struct mem *mem)
 {
   void *p = (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
   mem_overflow_check_raw(p, mem->user_size, "heap", "");
+  __A_VARIABLE = 1;
 }
 #else /* MEM_OVERFLOW_CHECK */
 #define mem_overflow_init_element(mem, size)
@@ -450,12 +464,14 @@ mem_overflow_check_element(struct mem *mem)
 static struct mem *
 ptr_to_mem(mem_size_t ptr)
 {
+  __A_VARIABLE = 1;
   return (struct mem *)(void *)&ram[ptr];
 }
 
 static mem_size_t
 mem_to_ptr(void *mem)
 {
+  __A_VARIABLE = 1;
   return (mem_size_t)((u8_t *)mem - ram);
 }
 
@@ -507,6 +523,7 @@ plug_holes(struct mem *mem)
       ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -542,6 +559,7 @@ mem_init(void)
   if (sys_mutex_new(&mem_mutex) != ERR_OK) {
     LWIP_ASSERT("failed to create mem_mutex", 0);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Check if a struct mem is correctly linked.
@@ -558,8 +576,10 @@ mem_link_valid(struct mem *mem)
   if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
       ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
       ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -604,6 +624,7 @@ mem_sanity(void)
   LWIP_ASSERT("heap element used valid", mem->used == 1);
   LWIP_ASSERT("heap element prev ptr valid", mem->prev == MEM_SIZE_ALIGNED);
   LWIP_ASSERT("heap element next ptr valid", mem->next == MEM_SIZE_ALIGNED);
+  __A_VARIABLE = 1;
 }
 #endif /* MEM_SANITY_CHECK */
 
@@ -621,6 +642,7 @@ mem_free(void *rmem)
 
   if (rmem == NULL) {
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
+    __A_VARIABLE = 1;
     return;
   }
   if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
@@ -628,6 +650,7 @@ mem_free(void *rmem)
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
     /* protect mem stats from concurrent access */
     MEM_STATS_INC_LOCKED(illegal);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -640,6 +663,7 @@ mem_free(void *rmem)
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
     /* protect mem stats from concurrent access */
     MEM_STATS_INC_LOCKED(illegal);
+    __A_VARIABLE = 1;
     return;
   }
 #if MEM_OVERFLOW_CHECK
@@ -654,6 +678,7 @@ mem_free(void *rmem)
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
     /* protect mem stats from concurrent access */
     MEM_STATS_INC_LOCKED(illegal);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -663,6 +688,7 @@ mem_free(void *rmem)
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
     /* protect mem stats from concurrent access */
     MEM_STATS_INC_LOCKED(illegal);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -683,6 +709,7 @@ mem_free(void *rmem)
   mem_free_count = 1;
 #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
   LWIP_MEM_FREE_UNPROTECT();
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -715,6 +742,7 @@ mem_trim(void *rmem, mem_size_t new_size)
   newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
 #endif
   if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -725,6 +753,7 @@ mem_trim(void *rmem, mem_size_t new_size)
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
     /* protect mem stats from concurrent access */
     MEM_STATS_INC_LOCKED(illegal);
+    __A_VARIABLE = 1;
     return rmem;
   }
   /* Get the corresponding struct mem ... */
@@ -740,10 +769,12 @@ mem_trim(void *rmem, mem_size_t new_size)
   LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
   if (newsize > size) {
     /* not supported */
+    __A_VARIABLE = 1;
     return NULL;
   }
   if (newsize == size) {
     /* No change in size, simply return */
+    __A_VARIABLE = 1;
     return rmem;
   }
 
@@ -816,6 +847,7 @@ mem_trim(void *rmem, mem_size_t new_size)
   mem_free_count = 1;
 #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
   LWIP_MEM_FREE_UNPROTECT();
+  __A_VARIABLE = 1;
   return rmem;
 }
 
@@ -838,6 +870,7 @@ mem_malloc(mem_size_t size_in)
   LWIP_MEM_ALLOC_DECL_PROTECT();
 
   if (size_in == 0) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -852,6 +885,7 @@ mem_malloc(mem_size_t size_in)
   size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
 #endif
   if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -961,6 +995,7 @@ mem_malloc_adjust_lfree:
         mem_overflow_init_element(mem, size_in);
 #endif
         MEM_SANITY();
+        __A_VARIABLE = 1;
         return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
       }
     }
@@ -972,6 +1007,7 @@ mem_malloc_adjust_lfree:
   LWIP_MEM_ALLOC_UNPROTECT();
   sys_mutex_unlock(&mem_mutex);
   LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -981,6 +1017,7 @@ mem_malloc_adjust_lfree:
 void *
 mem_calloc(mem_size_t count, mem_size_t size)
 {
+  __A_VARIABLE = 1;
   return mem_clib_calloc(count, size);
 }
 
@@ -1003,6 +1040,7 @@ mem_calloc(mem_size_t count, mem_size_t size)
 
   if ((size_t)(mem_size_t)alloc_size != alloc_size) {
     LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_calloc: could not allocate %"SZT_F" bytes\n", alloc_size));
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -1012,6 +1050,7 @@ mem_calloc(mem_size_t count, mem_size_t size)
     /* zero the memory */
     memset(p, 0, alloc_size);
   }
+  __A_VARIABLE = 1;
   return p;
 }
 #endif /* MEM_LIBC_MALLOC && (!LWIP_STATS || !MEM_STATS) */
diff --git a/src/core/memp.c b/src/core/memp.c
index 18771f6..70eb8c7 100644
--- a/src/core/memp.c
+++ b/src/core/memp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Dynamic pool memory manager
@@ -107,11 +109,13 @@ memp_sanity(const struct memp_desc *desc)
     for (h = t->next; (t != NULL) && (h != NULL); t = t->next,
          h = ((h->next != NULL) ? h->next->next : NULL)) {
       if (t == h) {
+        __A_VARIABLE = 1;
         return 0;
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* MEMP_SANITY_CHECK && !MEMP_MEM_MALLOC */
@@ -128,6 +132,7 @@ static void
 memp_overflow_check_element(struct memp *p, const struct memp_desc *desc)
 {
   mem_overflow_check_raw((u8_t *)p + MEMP_SIZE, desc->size, "pool ", desc->desc);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -137,6 +142,7 @@ static void
 memp_overflow_init_element(struct memp *p, const struct memp_desc *desc)
 {
   mem_overflow_init_raw((u8_t *)p + MEMP_SIZE, desc->size);
+  __A_VARIABLE = 1;
 }
 
 #if MEMP_OVERFLOW_CHECK >= 2
@@ -161,6 +167,7 @@ memp_overflow_check_all(void)
     }
   }
   SYS_ARCH_UNPROTECT(old_level);
+  __A_VARIABLE = 1;
 }
 #endif /* MEMP_OVERFLOW_CHECK >= 2 */
 #endif /* MEMP_OVERFLOW_CHECK */
@@ -212,6 +219,7 @@ memp_init_pool(const struct memp_desc *desc)
 #if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
   desc->stats->name  = desc->desc;
 #endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -238,6 +246,7 @@ memp_init(void)
   /* check everything a first time to see if it worked */
   memp_overflow_check_all();
 #endif /* MEMP_OVERFLOW_CHECK >= 2 */
+  __A_VARIABLE = 1;
 }
 
 static void *
@@ -352,6 +361,7 @@ memp_malloc_fn(memp_t type, const char *file, const int line)
   memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
 #endif
 
+  __A_VARIABLE = 1;
   return memp;
 }
 
@@ -391,6 +401,7 @@ do_memp_free_pool(const struct memp_desc *desc, void *mem)
 
   SYS_ARCH_UNPROTECT(old_level);
 #endif /* !MEMP_MEM_MALLOC */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -404,10 +415,12 @@ memp_free_pool(const struct memp_desc *desc, void *mem)
 {
   LWIP_ASSERT("invalid pool desc", desc != NULL);
   if ((desc == NULL) || (mem == NULL)) {
+    __A_VARIABLE = 1;
     return;
   }
 
   do_memp_free_pool(desc, mem);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -426,6 +439,7 @@ memp_free(memp_t type, void *mem)
   LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 
   if (mem == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -444,4 +458,5 @@ memp_free(memp_t type, void *mem)
     LWIP_HOOK_MEMP_AVAILABLE(type);
   }
 #endif
+  __A_VARIABLE = 1;
 }
diff --git a/src/core/netif.c b/src/core/netif.c
index a19018c..4ae3d84 100644
--- a/src/core/netif.c
+++ b/src/core/netif.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * lwIP network interface abstraction
@@ -169,6 +171,7 @@ netif_loopif_init(struct netif *netif)
   netif_set_flags(netif, NETIF_FLAG_IGMP);
 #endif
   NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_DISABLE_ALL);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_HAVE_LOOPIF */
@@ -202,6 +205,7 @@ netif_init(void)
   netif_set_up(&loop_netif);
 
 #endif /* LWIP_HAVE_LOOPIF */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -238,6 +242,7 @@ netif_input(struct pbuf *p, struct netif *inp)
 struct netif *
 netif_add_noaddr(struct netif *netif, void *state, netif_init_fn init, netif_input_fn input)
 {
+  __A_VARIABLE = 1;
   return netif_add(netif,
 #if LWIP_IPV4
                    NULL, NULL, NULL,
@@ -288,6 +293,7 @@ netif_add(struct netif *netif,
 #if LWIP_SINGLE_NETIF
   if (netif_default != NULL) {
     LWIP_ASSERT("single netif already set", 0);
+    __A_VARIABLE = 1;
     return NULL;
   }
 #endif
@@ -369,6 +375,7 @@ netif_add(struct netif *netif,
 
   /* call user specified initialization function for netif */
   if (init(netif) != ERR_OK) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 #if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
@@ -435,6 +442,7 @@ netif_add(struct netif *netif,
 
   netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);
 
+  __A_VARIABLE = 1;
   return netif;
 }
 
@@ -450,6 +458,7 @@ netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
 #if LWIP_RAW
   raw_netif_ip_addr_changed(old_addr, new_addr);
 #endif /* LWIP_RAW */
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_IPV4
@@ -481,8 +490,10 @@ netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *ol
     netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 
     NETIF_STATUS_CALLBACK(netif);
+    __A_VARIABLE = 1;
     return 1; /* address changed */
   }
+  __A_VARIABLE = 1;
   return 0; /* address unchanged */
 }
 
@@ -517,6 +528,7 @@ netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
     netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_ADDRESS_CHANGED, &args);
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -541,8 +553,10 @@ netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *
                 ip4_addr2_16(netif_ip4_netmask(netif)),
                 ip4_addr3_16(netif_ip4_netmask(netif)),
                 ip4_addr4_16(netif_ip4_netmask(netif))));
+    __A_VARIABLE = 1;
     return 1; /* netmask changed */
   }
+  __A_VARIABLE = 1;
   return 0; /* netmask unchanged */
 }
 
@@ -581,6 +595,7 @@ netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask)
     netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_NETMASK_CHANGED, &args);
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -603,8 +618,10 @@ netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
                 ip4_addr2_16(netif_ip4_gw(netif)),
                 ip4_addr3_16(netif_ip4_gw(netif)),
                 ip4_addr4_16(netif_ip4_gw(netif))));
+    __A_VARIABLE = 1;
     return 1; /* gateway changed */
   }
+  __A_VARIABLE = 1;
   return 0; /* gateway unchanged */
 }
 
@@ -642,6 +659,7 @@ netif_set_gw(struct netif *netif, const ip4_addr_t *gw)
     netif_invoke_ext_callback(netif, LWIP_NSC_IPV4_GATEWAY_CHANGED, &args);
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -724,6 +742,7 @@ netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *
     netif_invoke_ext_callback(netif, change_reason, &cb_args);
   }
 #endif
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_IPV4*/
 
@@ -833,6 +852,7 @@ netif_set_default(struct netif *netif)
   netif_default = netif;
   LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                             netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -867,6 +887,7 @@ netif_set_up(struct netif *netif)
     nd6_restart_netif(netif);
 #endif /* LWIP_IPV6 */
   }
+  __A_VARIABLE = 1;
 }
 
 /** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
@@ -879,6 +900,7 @@ netif_issue_reports(struct netif *netif, u8_t report_type)
   /* Only send reports when both link and admin states are up */
   if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
       !(netif->flags & NETIF_FLAG_UP)) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -909,6 +931,7 @@ netif_issue_reports(struct netif *netif, u8_t report_type)
 #endif /* LWIP_IPV6_MLD */
   }
 #endif /* LWIP_IPV6 */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -946,6 +969,7 @@ netif_set_down(struct netif *netif)
 
     NETIF_STATUS_CALLBACK(netif);
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_NETIF_STATUS_CALLBACK
@@ -961,6 +985,7 @@ netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_c
   if (netif) {
     netif->status_callback = status_callback;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETIF_STATUS_CALLBACK */
 
@@ -977,6 +1002,7 @@ netif_set_remove_callback(struct netif *netif, netif_status_callback_fn remove_c
   if (netif) {
     netif->remove_callback = remove_callback;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETIF_REMOVE_CALLBACK */
 
@@ -1016,6 +1042,7 @@ netif_set_link_up(struct netif *netif)
     }
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1040,6 +1067,7 @@ netif_set_link_down(struct netif *netif)
     }
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_NETIF_LINK_CALLBACK
@@ -1055,6 +1083,7 @@ netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callb
   if (netif) {
     netif->link_callback = link_callback;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETIF_LINK_CALLBACK */
 
@@ -1173,6 +1202,7 @@ static err_t
 netif_loop_output_ipv4(struct netif *netif, struct pbuf *p, const ip4_addr_t *addr)
 {
   LWIP_UNUSED_ARG(addr);
+  __A_VARIABLE = 1;
   return netif_loop_output(netif, p);
 }
 #endif /* LWIP_IPV4 */
@@ -1182,6 +1212,7 @@ static err_t
 netif_loop_output_ipv6(struct netif *netif, struct pbuf *p, const ip6_addr_t *addr)
 {
   LWIP_UNUSED_ARG(addr);
+  __A_VARIABLE = 1;
   return netif_loop_output(netif, p);
 }
 #endif /* LWIP_IPV6 */
@@ -1258,6 +1289,7 @@ netif_poll(struct netif *netif)
     SYS_ARCH_PROTECT(lev);
   }
   SYS_ARCH_UNPROTECT(lev);
+  __A_VARIABLE = 1;
 }
 
 #if !LWIP_NETIF_LOOPBACK_MULTITHREADING
@@ -1272,6 +1304,7 @@ netif_poll_all(void)
   NETIF_FOREACH(netif) {
     netif_poll(netif);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
 #endif /* ENABLE_LOOPBACK */
@@ -1295,6 +1328,7 @@ netif_alloc_client_data_id(void)
 #error LWIP_NUM_NETIF_CLIENT_DATA must be <= 256
 #endif
   LWIP_ASSERT("Increase LWIP_NUM_NETIF_CLIENT_DATA in lwipopts.h", result < LWIP_NUM_NETIF_CLIENT_DATA);
+  __A_VARIABLE = 1;
   return (u8_t)(result + LWIP_NETIF_CLIENT_DATA_INDEX_MAX);
 }
 #endif
@@ -1320,6 +1354,7 @@ netif_ip6_addr_set(struct netif *netif, s8_t addr_idx, const ip6_addr_t *addr6)
 
   netif_ip6_addr_set_parts(netif, addr_idx, addr6->addr[0], addr6->addr[1],
                            addr6->addr[2], addr6->addr[3]);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1377,6 +1412,7 @@ netif_ip6_addr_set_parts(struct netif *netif, s8_t addr_idx, u32_t i0, u32_t i1,
   LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IPv6 address %d of interface %c%c set to %s/0x%"X8_F"\n",
               addr_idx, netif->name[0], netif->name[1], ip6addr_ntoa(netif_ip6_addr(netif, addr_idx)),
               netif_ip6_addr_state(netif, addr_idx)));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1444,6 +1480,7 @@ netif_ip6_addr_set_state(struct netif *netif, s8_t addr_idx, u8_t state)
   LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IPv6 address %d of interface %c%c set to %s/0x%"X8_F"\n",
               addr_idx, netif->name[0], netif->name[1], ip6addr_ntoa(netif_ip6_addr(netif, addr_idx)),
               netif_ip6_addr_state(netif, addr_idx)));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1549,6 +1586,7 @@ netif_create_ip6_linklocal_address(struct netif *netif, u8_t from_mac_48bit)
   /* Consider address valid. */
   netif_ip6_addr_set_state(netif, 0, IP6_ADDR_PREFERRED);
 #endif /* LWIP_IPV6_AUTOCONFIG */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1577,6 +1615,7 @@ netif_add_ip6_address(struct netif *netif, const ip6_addr_t *ip6addr, s8_t *chos
     if (chosen_idx != NULL) {
       *chosen_idx = i;
     }
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -1589,6 +1628,7 @@ netif_add_ip6_address(struct netif *netif, const ip6_addr_t *ip6addr, s8_t *chos
       if (chosen_idx != NULL) {
         *chosen_idx = i;
       }
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
@@ -1596,6 +1636,7 @@ netif_add_ip6_address(struct netif *netif, const ip6_addr_t *ip6addr, s8_t *chos
   if (chosen_idx != NULL) {
     *chosen_idx = -1;
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -1608,6 +1649,7 @@ netif_null_output_ip6(struct netif *netif, struct pbuf *p, const ip6_addr_t *ipa
   LWIP_UNUSED_ARG(p);
   LWIP_UNUSED_ARG(ipaddr);
 
+  __A_VARIABLE = 1;
   return ERR_IF;
 }
 #endif /* LWIP_IPV6 */
@@ -1622,6 +1664,7 @@ netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipa
   LWIP_UNUSED_ARG(p);
   LWIP_UNUSED_ARG(ipaddr);
 
+  __A_VARIABLE = 1;
   return ERR_IF;
 }
 #endif /* LWIP_IPV4 */
@@ -1638,9 +1681,11 @@ netif_name_to_index(const char *name)
 {
   struct netif *netif = netif_find(name);
   if (netif != NULL) {
+    __A_VARIABLE = 1;
     return netif_get_index(netif);
   }
   /* No name found, return invalid index */
+  __A_VARIABLE = 1;
   return NETIF_NO_INDEX;
 }
 
@@ -1661,8 +1706,10 @@ netif_index_to_name(u8_t idx, char *name)
     name[0] = netif->name[0];
     name[1] = netif->name[1];
     lwip_itoa(&name[2], NETIF_NAMESIZE - 2, netif_index_to_num(idx));
+    __A_VARIABLE = 1;
     return name;
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -1682,11 +1729,13 @@ netif_get_by_index(u8_t idx)
   if (idx != NETIF_NO_INDEX) {
     NETIF_FOREACH(netif) {
       if (idx == netif_get_index(netif)) {
+        __A_VARIABLE = 1;
         return netif; /* found! */
       }
     }
   }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -1706,6 +1755,7 @@ netif_find(const char *name)
   LWIP_ASSERT_CORE_LOCKED();
 
   if (name == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -1716,10 +1766,12 @@ netif_find(const char *name)
         name[0] == netif->name[0] &&
         name[1] == netif->name[1]) {
       LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
+      __A_VARIABLE = 1;
       return netif;
     }
   }
   LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -1740,6 +1792,7 @@ netif_add_ext_callback(netif_ext_callback_t *callback, netif_ext_callback_fn fn)
   callback->callback_fn = fn;
   callback->next        = ext_callback;
   ext_callback          = callback;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1791,5 +1844,6 @@ netif_invoke_ext_callback(struct netif *netif, netif_nsc_reason_t reason, const
     callback->callback_fn(netif, reason, args);
     callback = callback->next;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_NETIF_EXT_STATUS_CALLBACK */
diff --git a/src/core/pbuf.c b/src/core/pbuf.c
index 779415b..ab34530 100644
--- a/src/core/pbuf.c
+++ b/src/core/pbuf.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Packet buffer management
@@ -135,9 +137,11 @@ pbuf_free_ooseq(void)
       /** Free the ooseq pbufs of one PCB only */
       LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
       tcp_free_ooseq(pcb);
+      __A_VARIABLE = 1;
       return;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #if !NO_SYS
@@ -149,6 +153,7 @@ pbuf_free_ooseq_callback(void *arg)
 {
   LWIP_UNUSED_ARG(arg);
   pbuf_free_ooseq();
+  __A_VARIABLE = 1;
 }
 #endif /* !NO_SYS */
 
@@ -171,6 +176,7 @@ pbuf_pool_is_empty(void)
     PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
   }
 #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
+  __A_VARIABLE = 1;
 }
 #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
 
@@ -186,6 +192,7 @@ pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len,
   p->flags = flags;
   p->ref = 1;
   p->if_idx = NETIF_NO_INDEX;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -248,6 +255,7 @@ pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
             pbuf_free(p);
           }
           /* bail out unsuccessfully */
+          __A_VARIABLE = 1;
           return NULL;
         }
         qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
@@ -277,12 +285,14 @@ pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
       /* bug #50040: Check for integer overflow when calculating alloc_len */
       if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
           (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
+        __A_VARIABLE = 1;
         return NULL;
       }
 
       /* If pbuf is to be allocated in RAM, allocate memory for it. */
       p = (struct pbuf *)mem_malloc(alloc_len);
       if (p == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
       }
       pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
@@ -293,9 +303,11 @@ pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
     }
     default:
       LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
+      __A_VARIABLE = 1;
       return NULL;
   }
   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -334,9 +346,11 @@ pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                 ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
+    __A_VARIABLE = 1;
     return NULL;
   }
   pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -369,6 +383,7 @@ pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_cust
 
   if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -378,6 +393,7 @@ pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_cust
     payload = NULL;
   }
   pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
+  __A_VARIABLE = 1;
   return &p->pbuf;
 }
 #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
@@ -410,6 +426,7 @@ pbuf_realloc(struct pbuf *p, u16_t new_len)
   /* desired length larger than current length? */
   if (new_len >= p->tot_len) {
     /* enlarging not yet supported */
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -456,6 +473,7 @@ pbuf_realloc(struct pbuf *p, u16_t new_len)
   /* q is last packet in chain */
   q->next = NULL;
 
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -550,6 +568,7 @@ pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
 u8_t
 pbuf_add_header(struct pbuf *p, size_t header_size_increment)
 {
+  __A_VARIABLE = 1;
   return pbuf_add_header_impl(p, header_size_increment, 0);
 }
 
@@ -560,6 +579,7 @@ pbuf_add_header(struct pbuf *p, size_t header_size_increment)
 u8_t
 pbuf_add_header_force(struct pbuf *p, size_t header_size_increment)
 {
+  __A_VARIABLE = 1;
   return pbuf_add_header_impl(p, header_size_increment, 1);
 }
 
@@ -586,9 +606,11 @@ pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
 
   LWIP_ASSERT("p != NULL", p != NULL);
   if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
+    __A_VARIABLE = 1;
     return 1;
   }
   if (header_size_decrement == 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -609,6 +631,7 @@ pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
               (void *)payload, (void *)p->payload, increment_magnitude));
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -645,6 +668,7 @@ pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
 u8_t
 pbuf_header(struct pbuf *p, s16_t header_size_increment)
 {
+  __A_VARIABLE = 1;
   return pbuf_header_impl(p, header_size_increment, 0);
 }
 
@@ -655,6 +679,7 @@ pbuf_header(struct pbuf *p, s16_t header_size_increment)
 u8_t
 pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
 {
+  __A_VARIABLE = 1;
   return pbuf_header_impl(p, header_size_increment, 1);
 }
 
@@ -684,6 +709,7 @@ pbuf_free_header(struct pbuf *q, u16_t size)
       free_left = 0;
     }
   }
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -733,6 +759,7 @@ pbuf_free(struct pbuf *p)
     /* if assertions are disabled, proceed with debug output */
     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                 ("pbuf_free(p == NULL) was called.\n"));
+    __A_VARIABLE = 1;
     return 0;
   }
   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
@@ -796,6 +823,7 @@ pbuf_free(struct pbuf *p)
   }
   PERF_STOP("pbuf_free");
   /* return number of de-allocated pbufs */
+  __A_VARIABLE = 1;
   return count;
 }
 
@@ -815,6 +843,7 @@ pbuf_clen(const struct pbuf *p)
     ++len;
     p = p->next;
   }
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -833,6 +862,7 @@ pbuf_ref(struct pbuf *p)
     SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
     LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -872,6 +902,7 @@ pbuf_cat(struct pbuf *h, struct pbuf *t)
   /* p->next now references t, but the caller will drop its reference to t,
    * so netto there is no change to the reference count of t.
    */
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -898,6 +929,7 @@ pbuf_chain(struct pbuf *h, struct pbuf *t)
   /* t is now referenced by h */
   pbuf_ref(t);
   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -936,6 +968,7 @@ pbuf_dechain(struct pbuf *p)
   }
   /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
   LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
+  __A_VARIABLE = 1;
   return ((tail_gone > 0) ? NULL : q);
 }
 
@@ -1008,6 +1041,7 @@ pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
     }
   } while (p_from);
   LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1054,6 +1088,7 @@ pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset
       offset = 0;
     }
   }
+  __A_VARIABLE = 1;
   return copied_total;
 }
 
@@ -1085,16 +1120,20 @@ pbuf_get_contiguous(const struct pbuf *p, void *buffer, size_t bufsize, u16_t le
   if (q != NULL) {
     if (q->len >= (out_offset + len)) {
       /* all data in this pbuf, return zero-copy */
+      __A_VARIABLE = 1;
       return (u8_t *)q->payload + out_offset;
     }
     /* need to copy */
     if (pbuf_copy_partial(q, buffer, len, out_offset) != len) {
       /* copying failed: pbuf is too short */
+      __A_VARIABLE = 1;
       return NULL;
     }
+    __A_VARIABLE = 1;
     return buffer;
   }
   /* pbuf is too short (offset does not fit in) */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -1145,6 +1184,7 @@ void pbuf_split_64k(struct pbuf *p, struct pbuf **rest)
       *rest = r;
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
 
@@ -1163,6 +1203,7 @@ pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
   if (out_offset != NULL) {
     *out_offset = offset_left;
   }
+  __A_VARIABLE = 1;
   return q;
 }
 
@@ -1179,6 +1220,7 @@ struct pbuf *
 pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
 {
   const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
+  __A_VARIABLE = 1;
   return LWIP_CONST_CAST(struct pbuf *, out);
 }
 
@@ -1206,6 +1248,7 @@ pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
   LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 
   if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
@@ -1223,6 +1266,7 @@ pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
     copied_total += buf_copy_len;
   }
   LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1255,10 +1299,13 @@ pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
     remaining_len = (u16_t)(remaining_len - first_copy_len);
     src_ptr += first_copy_len;
     if (remaining_len > 0) {
+      __A_VARIABLE = 1;
       return pbuf_take(q->next, src_ptr, remaining_len);
     }
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_MEM;
 }
 
@@ -1280,14 +1327,17 @@ pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
 {
   struct pbuf *q;
   if (p->next == NULL) {
+    __A_VARIABLE = 1;
     return p;
   }
   q = pbuf_clone(layer, PBUF_RAM, p);
   if (q == NULL) {
     /* @todo: what do we do now? */
+    __A_VARIABLE = 1;
     return p;
   }
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return q;
 }
 
@@ -1310,11 +1360,13 @@ pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
   err_t err;
   q = pbuf_alloc(layer, p->tot_len, type);
   if (q == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   err = pbuf_copy(q, p);
   LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
   LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
+  __A_VARIABLE = 1;
   return q;
 }
 
@@ -1344,6 +1396,7 @@ pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
   LWIP_ASSERT("len != 0", len != 0);
 
   if ((start_offset >= p->len) || (start_offset + len > p->len)) {
+    __A_VARIABLE = 1;
     return ERR_ARG;
   }
 
@@ -1355,6 +1408,7 @@ pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
   acc = *chksum;
   acc += copy_chksum;
   *chksum = FOLD_U32T(acc);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_CHECKSUM_ON_COPY */
@@ -1373,8 +1427,10 @@ pbuf_get_at(const struct pbuf *p, u16_t offset)
 {
   int ret = pbuf_try_get_at(p, offset);
   if (ret >= 0) {
+    __A_VARIABLE = 1;
     return (u8_t)ret;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1394,8 +1450,10 @@ pbuf_try_get_at(const struct pbuf *p, u16_t offset)
 
   /* return requested data if pbuf is OK */
   if ((q != NULL) && (q->len > q_idx)) {
+    __A_VARIABLE = 1;
     return ((u8_t *)q->payload)[q_idx];
   }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -1418,6 +1476,7 @@ pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
   if ((q != NULL) && (q->len > q_idx)) {
     ((u8_t *)q->payload)[q_idx] = data;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1440,6 +1499,7 @@ pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
 
   /* pbuf long enough to perform check? */
   if (p->tot_len < (offset + n)) {
+    __A_VARIABLE = 1;
     return 0xffff;
   }
 
@@ -1455,9 +1515,11 @@ pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
     u8_t a = pbuf_get_at(q, (u16_t)(start + i));
     u8_t b = ((const u8_t *)s2)[i];
     if (a != b) {
+      __A_VARIABLE = 1;
       return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1482,10 +1544,12 @@ pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_o
     for (i = start_offset; i <= max_cmp_start; i++) {
       u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
       if (plus == 0) {
+        __A_VARIABLE = 1;
         return i;
       }
     }
   }
+  __A_VARIABLE = 1;
   return 0xFFFF;
 }
 
@@ -1505,11 +1569,14 @@ pbuf_strstr(const struct pbuf *p, const char *substr)
 {
   size_t substr_len;
   if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
+    __A_VARIABLE = 1;
     return 0xFFFF;
   }
   substr_len = strlen(substr);
   if (substr_len >= 0xFFFF) {
+    __A_VARIABLE = 1;
     return 0xFFFF;
   }
+  __A_VARIABLE = 1;
   return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 }
diff --git a/src/core/raw.c b/src/core/raw.c
index 7a42432..4cd8d6f 100644
--- a/src/core/raw.c
+++ b/src/core/raw.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Implementation of raw protocol PCBs for low-level handling of
@@ -222,6 +224,7 @@ raw_bind(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
 {
   LWIP_ASSERT_CORE_LOCKED();
   if ((pcb == NULL) || (ipaddr == NULL)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
@@ -234,6 +237,7 @@ raw_bind(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
     ip6_addr_select_zone(ip_2_ip6(&pcb->local_ip), ip_2_ip6(&pcb->local_ip));
   }
 #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -258,6 +262,7 @@ raw_bind_netif(struct raw_pcb *pcb, const struct netif *netif)
   } else {
     pcb->netif_idx = NETIF_NO_INDEX;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -279,6 +284,7 @@ raw_connect(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
 {
   LWIP_ASSERT_CORE_LOCKED();
   if ((pcb == NULL) || (ipaddr == NULL)) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
@@ -291,6 +297,7 @@ raw_connect(struct raw_pcb *pcb, const ip_addr_t *ipaddr)
   }
 #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
   raw_set_flags(pcb, RAW_FLAGS_CONNECTED);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -317,6 +324,7 @@ raw_disconnect(struct raw_pcb *pcb)
   pcb->netif_idx = NETIF_NO_INDEX;
   /* mark PCB as unconnected */
   raw_clear_flags(pcb, RAW_FLAGS_CONNECTED);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -337,6 +345,7 @@ raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
   /* remember recv() callback and user data */
   pcb->recv = recv;
   pcb->recv_arg = recv_arg;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -545,6 +554,7 @@ raw_sendto_if_src(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
 err_t
 raw_send(struct raw_pcb *pcb, struct pbuf *p)
 {
+  __A_VARIABLE = 1;
   return raw_sendto(pcb, p, &pcb->remote_ip);
 }
 
@@ -578,6 +588,7 @@ raw_remove(struct raw_pcb *pcb)
     }
   }
   memp_free(MEMP_RAW_PCB, pcb);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -612,6 +623,7 @@ raw_new(u8_t proto)
     pcb->next = raw_pcbs;
     raw_pcbs = pcb;
   }
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -644,6 +656,7 @@ raw_new_ip_type(u8_t type, u8_t proto)
 #else /* LWIP_IPV4 && LWIP_IPV6 */
   LWIP_UNUSED_ARG(type);
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -666,6 +679,7 @@ void raw_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_a
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_RAW */
diff --git a/src/core/stats.c b/src/core/stats.c
index 4602842..207e93f 100644
--- a/src/core/stats.c
+++ b/src/core/stats.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Statistics module
@@ -57,6 +59,7 @@ stats_init(void)
   lwip_stats.mem.name = "MEM";
 #endif /* MEM_STATS */
 #endif /* LWIP_DEBUG */
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_STATS_DISPLAY
@@ -76,6 +79,7 @@ stats_display_proto(struct stats_proto *proto, const char *name)
   LWIP_PLATFORM_DIAG(("opterr: %"STAT_COUNTER_F"\n\t", proto->opterr));
   LWIP_PLATFORM_DIAG(("err: %"STAT_COUNTER_F"\n\t", proto->err));
   LWIP_PLATFORM_DIAG(("cachehit: %"STAT_COUNTER_F"\n", proto->cachehit));
+  __A_VARIABLE = 1;
 }
 
 #if IGMP_STATS || MLD6_STATS
@@ -97,6 +101,7 @@ stats_display_igmp(struct stats_igmp *igmp, const char *name)
   LWIP_PLATFORM_DIAG(("tx_join: %"STAT_COUNTER_F"\n\t", igmp->tx_join));
   LWIP_PLATFORM_DIAG(("tx_leave: %"STAT_COUNTER_F"\n\t", igmp->tx_leave));
   LWIP_PLATFORM_DIAG(("tx_report: %"STAT_COUNTER_F"\n", igmp->tx_report));
+  __A_VARIABLE = 1;
 }
 #endif /* IGMP_STATS || MLD6_STATS */
 
@@ -109,6 +114,7 @@ stats_display_mem(struct stats_mem *mem, const char *name)
   LWIP_PLATFORM_DIAG(("used: %"MEM_SIZE_F"\n\t", mem->used));
   LWIP_PLATFORM_DIAG(("max: %"MEM_SIZE_F"\n\t", mem->max));
   LWIP_PLATFORM_DIAG(("err: %"STAT_COUNTER_F"\n", mem->err));
+  __A_VARIABLE = 1;
 }
 
 #if MEMP_STATS
@@ -118,6 +124,7 @@ stats_display_memp(struct stats_mem *mem, int idx)
   if (idx < MEMP_MAX) {
     stats_display_mem(mem, mem->name);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* MEMP_STATS */
 #endif /* MEM_STATS || MEMP_STATS */
@@ -136,6 +143,7 @@ stats_display_sys(struct stats_sys *sys)
   LWIP_PLATFORM_DIAG(("mbox.used:  %"STAT_COUNTER_F"\n\t", sys->mbox.used));
   LWIP_PLATFORM_DIAG(("mbox.max:   %"STAT_COUNTER_F"\n\t", sys->mbox.max));
   LWIP_PLATFORM_DIAG(("mbox.err:   %"STAT_COUNTER_F"\n", sys->mbox.err));
+  __A_VARIABLE = 1;
 }
 #endif /* SYS_STATS */
 
@@ -162,6 +170,7 @@ stats_display(void)
     MEMP_STATS_DISPLAY(i);
   }
   SYS_STATS_DISPLAY();
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_STATS_DISPLAY */
 
diff --git a/src/core/sys.c b/src/core/sys.c
index b95f4bd..833bfe6 100644
--- a/src/core/sys.c
+++ b/src/core/sys.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * lwIP Operating System abstraction
@@ -142,6 +144,7 @@ sys_msleep(u32_t ms)
       sys_sem_free(&delaysem);
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* sys_msleep */
 
diff --git a/src/core/tcp.c b/src/core/tcp.c
index 2ff37ef..45f514d 100644
--- a/src/core/tcp.c
+++ b/src/core/tcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Transmission Control Protocol for IP
@@ -203,6 +205,7 @@ tcp_init(void)
 #ifdef LWIP_RAND
   tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 #endif /* LWIP_RAND */
+  __A_VARIABLE = 1;
 }
 
 /** Free a tcp pcb */
@@ -214,6 +217,7 @@ tcp_free(struct tcp_pcb *pcb)
   tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
 #endif
   memp_free(MEMP_TCP_PCB, pcb);
+  __A_VARIABLE = 1;
 }
 
 /** Free a tcp listen pcb */
@@ -225,6 +229,7 @@ tcp_free_listen(struct tcp_pcb *pcb)
   tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
 #endif
   memp_free(MEMP_TCP_PCB_LISTEN, pcb);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -241,6 +246,7 @@ tcp_tmr(void)
        tcp_tmr() is called. */
     tcp_slowtmr();
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
@@ -259,6 +265,7 @@ tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
       pcb->listener = NULL;
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -277,6 +284,7 @@ tcp_listen_closed(struct tcp_pcb *pcb)
   }
 #endif
   LWIP_UNUSED_ARG(pcb);
+  __A_VARIABLE = 1;
 }
 
 #if TCP_LISTEN_BACKLOG
@@ -302,6 +310,7 @@ tcp_backlog_delayed(struct tcp_pcb *pcb)
       tcp_set_flags(pcb, TF_BACKLOGPEND);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** @ingroup tcp_raw
@@ -325,6 +334,7 @@ tcp_backlog_accepted(struct tcp_pcb *pcb)
       tcp_clear_flags(pcb, TF_BACKLOGPEND);
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_LISTEN_BACKLOG */
 
@@ -369,6 +379,7 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
       } else {
         tcp_free(pcb);
       }
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
@@ -400,8 +411,10 @@ tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
       MIB2_STATS_INC(mib2.tcpattemptfails);
       break;
     default:
+      __A_VARIABLE = 1;
       return tcp_close_shutdown_fin(pcb);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -495,6 +508,7 @@ tcp_close(struct tcp_pcb *pcb)
     tcp_set_flags(pcb, TF_RXCLOSED);
   }
   /* ... and close */
+  __A_VARIABLE = 1;
   return tcp_close_shutdown(pcb, 1);
 }
 
@@ -519,6 +533,7 @@ tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
   LWIP_ERROR("tcp_shutdown: invalid pcb", pcb != NULL, return ERR_ARG);
 
   if (pcb->state == LISTEN) {
+    __A_VARIABLE = 1;
     return ERR_CONN;
   }
   if (shut_rx) {
@@ -526,6 +541,7 @@ tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
     tcp_set_flags(pcb, TF_RXCLOSED);
     if (shut_tx) {
       /* shutting down the tx AND rx side is the same as closing for the raw API */
+      __A_VARIABLE = 1;
       return tcp_close_shutdown(pcb, 1);
     }
     /* ... and free buffered data */
@@ -541,13 +557,16 @@ tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
       case SYN_RCVD:
       case ESTABLISHED:
       case CLOSE_WAIT:
+        __A_VARIABLE = 1;
         return tcp_close_shutdown(pcb, (u8_t)shut_rx);
       default:
         /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
           into CLOSED state, where the PCB is deallocated. */
+        __A_VARIABLE = 1;
         return ERR_CONN;
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -621,6 +640,7 @@ tcp_abandon(struct tcp_pcb *pcb, int reset)
     tcp_free(pcb);
     TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -638,6 +658,7 @@ void
 tcp_abort(struct tcp_pcb *pcb)
 {
   tcp_abandon(pcb, 1);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -768,6 +789,7 @@ tcp_bind_netif(struct tcp_pcb *pcb, const struct netif *netif)
   } else {
     pcb->netif_idx = NETIF_NO_INDEX;
   }
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_CALLBACK_API
@@ -784,6 +806,7 @@ tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
 
   tcp_abort(pcb);
 
+  __A_VARIABLE = 1;
   return ERR_ABRT;
 }
 #endif /* LWIP_CALLBACK_API */
@@ -825,6 +848,7 @@ struct tcp_pcb *
 tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
 {
   LWIP_ASSERT_CORE_LOCKED();
+  __A_VARIABLE = 1;
   return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
 }
 
@@ -917,6 +941,7 @@ done:
   if (err != NULL) {
     *err = res;
   }
+  __A_VARIABLE = 1;
   return (struct tcp_pcb *)lpcb;
 }
 
@@ -1000,6 +1025,7 @@ tcp_recved(struct tcp_pcb *pcb, u16_t len)
 
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                           len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1025,12 +1051,14 @@ again:
       if (pcb->local_port == tcp_port) {
         n++;
         if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
+          __A_VARIABLE = 1;
           return 0;
         }
         goto again;
       }
     }
   }
+  __A_VARIABLE = 1;
   return tcp_port;
 }
 
@@ -1467,6 +1495,7 @@ tcp_slowtmr_start:
       pcb = pcb->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1519,6 +1548,7 @@ tcp_fasttmr_start:
       pcb = pcb->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** Call tcp_output for all active pcbs that have TF_NAGLEMEMERR set */
@@ -1532,6 +1562,7 @@ tcp_txnow(void)
       tcp_output(pcb);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** Pass pcb->refused_data to the recv callback */
@@ -1612,6 +1643,7 @@ tcp_segs_free(struct tcp_seg *seg)
     tcp_seg_free(seg);
     seg = next;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1631,6 +1663,7 @@ tcp_seg_free(struct tcp_seg *seg)
     }
     memp_free(MEMP_TCP_SEG, seg);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1648,6 +1681,7 @@ tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
   LWIP_ERROR("tcp_setprio: invalid pcb", pcb != NULL, return);
 
   pcb->prio = prio;
+  __A_VARIABLE = 1;
 }
 
 #if TCP_QUEUE_OOSEQ
@@ -1667,10 +1701,12 @@ tcp_seg_copy(struct tcp_seg *seg)
 
   cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
   if (cseg == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
   pbuf_ref(cseg->p);
+  __A_VARIABLE = 1;
   return cseg;
 }
 #endif /* TCP_QUEUE_OOSEQ */
@@ -1715,6 +1751,7 @@ tcp_kill_prio(u8_t prio)
    * supplied prio is 0 - there can never be a lower prio
    */
   if (mprio == 0) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -1742,6 +1779,7 @@ tcp_kill_prio(u8_t prio)
                             (void *)inactive, inactivity));
     tcp_abort(inactive);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1774,6 +1812,7 @@ tcp_kill_state(enum tcp_state state)
     /* Don't send a RST, since no data is lost. */
     tcp_abandon(inactive, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1800,6 +1839,7 @@ tcp_kill_timewait(void)
                             (void *)inactive, inactivity));
     tcp_abort(inactive);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Called when allocating a pcb fails.
@@ -1822,6 +1862,7 @@ tcp_handle_closepend(void)
     }
     pcb = next;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1924,6 +1965,7 @@ tcp_alloc(u8_t prio)
     pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 #endif /* LWIP_TCP_KEEPALIVE */
   }
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -1944,6 +1986,7 @@ tcp_alloc(u8_t prio)
 struct tcp_pcb *
 tcp_new(void)
 {
+  __A_VARIABLE = 1;
   return tcp_alloc(TCP_PRIO_NORMAL);
 }
 
@@ -1971,6 +2014,7 @@ tcp_new_ip_type(u8_t type)
 #else
   LWIP_UNUSED_ARG(type);
 #endif /* LWIP_IPV4 && LWIP_IPV6 */
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -1993,6 +2037,7 @@ tcp_arg(struct tcp_pcb *pcb, void *arg)
   if (pcb != NULL) {
     pcb->callback_arg = arg;
   }
+  __A_VARIABLE = 1;
 }
 #if LWIP_CALLBACK_API
 
@@ -2015,6 +2060,7 @@ tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
     pcb->recv = recv;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2035,6 +2081,7 @@ tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
     pcb->sent = sent;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2061,6 +2108,7 @@ tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
     pcb->errf = err;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2080,6 +2128,7 @@ tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
     struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
     lpcb->accept = accept;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_CALLBACK_API */
 
@@ -2115,6 +2164,7 @@ tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
   LWIP_UNUSED_ARG(poll);
 #endif /* LWIP_CALLBACK_API */
   pcb->pollinterval = interval;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2165,6 +2215,7 @@ tcp_pcb_purge(struct tcp_pcb *pcb)
     pcb->unsent_oversize = 0;
 #endif /* TCP_OVERSIZE */
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2204,6 +2255,7 @@ tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
   pcb->local_port = 0;
 
   LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2320,6 +2372,7 @@ tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb
       pcb = pcb->next;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** This function is called from netif.c when address is changed or netif is removed
@@ -2348,11 +2401,13 @@ tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 const char *
 tcp_debug_state_str(enum tcp_state s)
 {
+  __A_VARIABLE = 1;
   return tcp_state_str[s];
 }
 
@@ -2375,8 +2430,10 @@ tcp_tcp_get_tcp_addrinfo(struct tcp_pcb *pcb, int local, ip_addr_t *addr, u16_t
         *port = pcb->remote_port;
       }
     }
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -2392,6 +2449,7 @@ tcp_free_ooseq(struct tcp_pcb *pcb)
     memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
 #endif /* LWIP_TCP_SACK_OUT */
   }
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_QUEUE_OOSEQ */
 
@@ -2430,6 +2488,7 @@ tcp_debug_print(struct tcp_hdr *tcphdr)
   LWIP_DEBUGF(TCP_DEBUG, ("|    0x%04"X16_F"     |     %5"U16_F"     | (chksum, urgp)\n",
                           lwip_ntohs(tcphdr->chksum), lwip_ntohs(tcphdr->urgp)));
   LWIP_DEBUGF(TCP_DEBUG, ("+-------------------------------+\n"));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2441,6 +2500,7 @@ void
 tcp_debug_print_state(enum tcp_state s)
 {
   LWIP_DEBUGF(TCP_DEBUG, ("State: %s\n", tcp_state_str[s]));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2476,6 +2536,7 @@ tcp_debug_print_flags(u8_t flags)
     LWIP_DEBUGF(TCP_DEBUG, ("CWR "));
   }
   LWIP_DEBUGF(TCP_DEBUG, ("\n"));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2508,6 +2569,7 @@ tcp_debug_print_pcbs(void)
                             pcb->snd_nxt, pcb->rcv_nxt));
     tcp_debug_print_state(pcb->state);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2525,6 +2587,7 @@ tcp_pcbs_sane(void)
   for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
     LWIP_ASSERT("tcp_pcbs_sane: tw pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* TCP_DEBUG */
@@ -2579,6 +2642,7 @@ tcp_ext_arg_alloc_id(void)
 #error LWIP_TCP_PCB_NUM_EXT_ARGS
 #endif
   LWIP_ASSERT("Increase LWIP_TCP_PCB_NUM_EXT_ARGS in lwipopts.h", result < LWIP_TCP_PCB_NUM_EXT_ARGS);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -2600,6 +2664,7 @@ tcp_ext_arg_set_callbacks(struct tcp_pcb *pcb, uint8_t id, const struct tcp_ext_
   LWIP_ASSERT_CORE_LOCKED();
 
   pcb->ext_args[id].callbacks = callbacks;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2618,6 +2683,7 @@ void tcp_ext_arg_set(struct tcp_pcb *pcb, uint8_t id, void *arg)
   LWIP_ASSERT_CORE_LOCKED();
 
   pcb->ext_args[id].data = arg;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2635,6 +2701,7 @@ void *tcp_ext_arg_get(const struct tcp_pcb *pcb, uint8_t id)
 
   LWIP_ASSERT_CORE_LOCKED();
 
+  __A_VARIABLE = 1;
   return pcb->ext_args[id].data;
 }
 
@@ -2654,6 +2721,7 @@ tcp_ext_arg_invoke_callbacks_destroyed(struct tcp_pcb_ext_args *ext_args)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /** This function calls the "passive_open" callback for all ext_args if a connection
@@ -2674,11 +2742,13 @@ tcp_ext_arg_invoke_callbacks_passive_open(struct tcp_pcb_listen *lpcb, struct tc
       if (lpcb->ext_args[i].callbacks->passive_open != NULL) {
         err_t err = lpcb->ext_args[i].callbacks->passive_open((u8_t)i, lpcb, cpcb);
         if (err != ERR_OK) {
+          __A_VARIABLE = 1;
           return err;
         }
       }
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_TCP_PCB_NUM_EXT_ARGS */
diff --git a/src/core/tcp_in.c b/src/core/tcp_in.c
index 4670178..beac5e2 100644
--- a/src/core/tcp_in.c
+++ b/src/core/tcp_in.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Transmission Control Protocol, incoming traffic
@@ -612,8 +614,10 @@ tcp_input_delayed_close(struct tcp_pcb *pcb)
     }
     tcp_pcb_remove(&tcp_active_pcbs, pcb);
     tcp_free(pcb);
+    __A_VARIABLE = 1;
     return 1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1080,6 +1084,7 @@ tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
     }
   }
   cseg->next = next;
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_QUEUE_OOSEQ */
 
@@ -1122,6 +1127,7 @@ tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const cha
                   seg_list != NULL || dbg_other_seg_list != NULL);
     }
   }
+  __A_VARIABLE = 1;
   return seg_list;
 }
 
@@ -1882,6 +1888,7 @@ tcp_receive(struct tcp_pcb *pcb)
       tcp_ack_now(pcb);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static u8_t
@@ -2029,6 +2036,7 @@ void
 tcp_trigger_input_pcb_close(void)
 {
   recv_flags |= TF_CLOSED;
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_TCP_SACK_OUT
@@ -2050,6 +2058,7 @@ tcp_add_sack(struct tcp_pcb *pcb, u32_t left, u32_t right)
   u8_t unused_idx;
 
   if ((pcb->flags & TF_SACK) == 0 || !TCP_SEQ_LT(left, right)) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -2091,6 +2100,7 @@ tcp_add_sack(struct tcp_pcb *pcb, u32_t left, u32_t right)
   /* And now we can store the newest SACK */
   pcb->rcv_sacks[0].left = left;
   pcb->rcv_sacks[0].right = right;
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2130,6 +2140,7 @@ tcp_remove_sacks_lt(struct tcp_pcb *pcb, u32_t seq)
   for (i = unused_idx; i < LWIP_TCP_MAX_SACK_NUM; ++i) {
     pcb->rcv_sacks[i].left = pcb->rcv_sacks[i].right = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 #if defined(TCP_OOSEQ_BYTES_LIMIT) || defined(TCP_OOSEQ_PBUFS_LIMIT)
@@ -2170,6 +2181,7 @@ tcp_remove_sacks_gt(struct tcp_pcb *pcb, u32_t seq)
   for (i = unused_idx; i < LWIP_TCP_MAX_SACK_NUM; ++i) {
     pcb->rcv_sacks[i].left = pcb->rcv_sacks[i].right = 0;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
 
diff --git a/src/core/tcp_out.c b/src/core/tcp_out.c
index b3f3858..72ddfcf 100644
--- a/src/core/tcp_out.c
+++ b/src/core/tcp_out.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Transmission Control Protocol, outgoing traffic
@@ -170,6 +172,7 @@ tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32
   if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return NULL;
   }
   seg->flags = optflags;
@@ -193,6 +196,7 @@ tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32
     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
     TCP_STATS_INC(tcp.err);
     tcp_seg_free(seg);
+    __A_VARIABLE = 1;
     return NULL;
   }
   seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
@@ -203,6 +207,7 @@ tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32
   TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
   /* wnd and chksum are set in tcp_output */
   seg->tcphdr->urgp = 0;
+  __A_VARIABLE = 1;
   return seg;
 }
 
@@ -264,12 +269,14 @@ tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
 #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
   p = pbuf_alloc(layer, alloc, PBUF_RAM);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   LWIP_ASSERT("need unchained pbuf", p->next == NULL);
   *oversize = p->len - length;
   /* trim p->len to the currently used size */
   p->len = p->tot_len = length;
+  __A_VARIABLE = 1;
   return p;
 }
 #else /* TCP_OVERSIZE */
@@ -294,6 +301,7 @@ tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
     chksum = SWAP_BYTES_IN_WORD(chksum);
   }
   *seg_chksum = chksum;
+  __A_VARIABLE = 1;
 }
 #endif /* TCP_CHECKSUM_ON_COPY */
 
@@ -433,6 +441,7 @@ tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
 
   err = tcp_write_checks(pcb, len);
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
   queuelen = pcb->snd_queuelen;
@@ -795,6 +804,7 @@ tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
     TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 memerr:
   tcp_set_flags(pcb, TF_NAGLEMEMERR);
@@ -811,6 +821,7 @@ memerr:
                 pcb->unsent != NULL);
   }
   LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
+  __A_VARIABLE = 1;
   return ERR_MEM;
 }
 
@@ -847,15 +858,18 @@ tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
 
   useg = pcb->unsent;
   if (useg == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
   if (split == 0) {
     LWIP_ASSERT("Can't split segment into length 0", 0);
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   if (useg->len <= split) {
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -980,6 +994,7 @@ tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
   }
 #endif /* TCP_OVERSIZE */
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 memerr:
   TCP_STATS_INC(tcp.memerr);
@@ -989,6 +1004,7 @@ memerr:
     pbuf_free(p);
   }
 
+  __A_VARIABLE = 1;
   return ERR_MEM;
 }
 
@@ -1015,10 +1031,12 @@ tcp_send_fin(struct tcp_pcb *pcb)
       /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
       TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
       tcp_set_flags(pcb, TF_FIN);
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
   }
   /* no data, no length, flags, copy=1, no optdata */
+  __A_VARIABLE = 1;
   return tcp_enqueue_flags(pcb, TCP_FIN);
 }
 
@@ -1079,6 +1097,7 @@ tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
   if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
     tcp_set_flags(pcb, TF_NAGLEMEMERR);
     TCP_STATS_INC(tcp.memerr);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
@@ -1088,6 +1107,7 @@ tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
   if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
     tcp_set_flags(pcb, TF_NAGLEMEMERR);
     TCP_STATS_INC(tcp.memerr);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
@@ -1129,6 +1149,7 @@ tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
                 pcb->unacked != NULL || pcb->unsent != NULL);
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1147,6 +1168,7 @@ tcp_build_timestamp_option(const struct tcp_pcb *pcb, u32_t *opts)
   opts[0] = PP_HTONL(0x0101080A);
   opts[1] = lwip_htonl(sys_now());
   opts[2] = lwip_htonl(pcb->ts_recent);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -1183,6 +1205,7 @@ tcp_get_num_sacks(const struct tcp_pcb *pcb, u8_t optlen)
     }
   }
 
+  __A_VARIABLE = 1;
   return num_sacks;
 }
 
@@ -1209,6 +1232,7 @@ tcp_build_sack_option(const struct tcp_pcb *pcb, u32_t *opts, u8_t num_sacks)
     *(opts++) = lwip_htonl(pcb->rcv_sacks[i].left);
     *(opts++) = lwip_htonl(pcb->rcv_sacks[i].right);
   }
+  __A_VARIABLE = 1;
 }
 
 #endif
@@ -1225,6 +1249,7 @@ tcp_build_wnd_scale_option(u32_t *opts)
 
   /* Pad with one NOP option to make everything nicely aligned */
   opts[0] = PP_HTONL(0x01030300 | TCP_RCV_SCALE);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -1441,9 +1466,11 @@ tcp_output_segment_busy(const struct tcp_seg *seg)
      which only changes the ref count of the first pbuf */
   if (seg->p->ref != 1) {
     /* other reference found */
+    __A_VARIABLE = 1;
     return 1;
   }
   /* no other references found */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1638,6 +1665,7 @@ tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
   LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 
   if (pcb->unacked == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1648,11 +1676,13 @@ tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
   for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
     if (tcp_output_segment_busy(seg)) {
       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
+      __A_VARIABLE = 1;
       return ERR_VAL;
     }
   }
   if (tcp_output_segment_busy(seg)) {
     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   /* concatenate unsent queue after unacked queue */
@@ -1675,6 +1705,7 @@ tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
   /* Don't take any RTT measurements after retransmitting. */
   pcb->rttest = 0;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1696,6 +1727,7 @@ tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
   }
   /* Do the actual retransmission */
   tcp_output(pcb);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1714,6 +1746,7 @@ tcp_rexmit_rto(struct tcp_pcb *pcb)
   if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
     tcp_rexmit_rto_commit(pcb);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -1732,6 +1765,7 @@ tcp_rexmit(struct tcp_pcb *pcb)
   LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 
   if (pcb->unacked == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1741,6 +1775,7 @@ tcp_rexmit(struct tcp_pcb *pcb)
      due to deferred transmission. */
   if (tcp_output_segment_busy(seg)) {
     LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -1773,6 +1808,7 @@ tcp_rexmit(struct tcp_pcb *pcb)
   MIB2_STATS_INC(mib2.tcpretranssegs);
   /* No need to call tcp_output: we are always called from tcp_input()
      and thus tcp_output directly returns. */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -1815,6 +1851,7 @@ tcp_rexmit_fast(struct tcp_pcb *pcb)
       pcb->rtime = 0;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 static struct pbuf *
@@ -1839,6 +1876,7 @@ tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
     tcphdr->chksum = 0;
     tcphdr->urgp = 0;
   }
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -1867,6 +1905,7 @@ tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
     /* If we're sending a packet, update the announced right window edge */
     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   }
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -1912,6 +1951,7 @@ tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags
   LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
   LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
   LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
+  __A_VARIABLE = 1;
 }
 
 /** Output a control segment pbuf to IP.
@@ -2003,6 +2043,7 @@ tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
     remote_port, TCP_RST | TCP_ACK, wnd);
   if (p == NULL) {
     LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
+    __A_VARIABLE = 1;
     return;
   }
   tcp_output_fill_options(pcb, p, 0, optlen);
@@ -2011,6 +2052,7 @@ tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
 
   tcp_output_control_segment(pcb, p, local_ip, remote_ip);
   LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -2047,6 +2089,7 @@ tcp_send_empty_ack(struct tcp_pcb *pcb)
     /* let tcp_fasttmr retry sending this ACK */
     tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
   tcp_output_fill_options(pcb, p, optflags, num_sacks);
@@ -2066,6 +2109,7 @@ tcp_send_empty_ack(struct tcp_pcb *pcb)
     tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
   }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -2097,6 +2141,7 @@ tcp_keepalive(struct tcp_pcb *pcb)
   if (p == NULL) {
     LWIP_DEBUGF(TCP_DEBUG,
                 ("tcp_keepalive: could not allocate memory for pbuf\n"));
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   tcp_output_fill_options(pcb, p, 0, optlen);
@@ -2104,6 +2149,7 @@ tcp_keepalive(struct tcp_pcb *pcb)
 
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                           pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -2142,6 +2188,7 @@ tcp_zero_window_probe(struct tcp_pcb *pcb)
   seg = pcb->unsent;
   if (seg == NULL) {
     /* Not expected, persist timer should be off when the send buffer is empty */
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -2160,6 +2207,7 @@ tcp_zero_window_probe(struct tcp_pcb *pcb)
   p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
   if (p == NULL) {
     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   tcphdr = (struct tcp_hdr *)p->payload;
@@ -2188,6 +2236,7 @@ tcp_zero_window_probe(struct tcp_pcb *pcb)
   LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                           " ackno %"U32_F" err %d.\n",
                           pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* LWIP_TCP */
diff --git a/src/core/timeouts.c b/src/core/timeouts.c
index c3431e8..2eeca58 100644
--- a/src/core/timeouts.c
+++ b/src/core/timeouts.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Stack-internal timers implementation.
@@ -127,6 +129,7 @@ static u32_t current_timeout_due_time;
 struct sys_timeo**
 sys_timeouts_get_next_timeout(void)
 {
+  __A_VARIABLE = 1;
   return &next_timeout;
 }
 #endif
@@ -155,6 +158,7 @@ tcpip_tcp_timer(void *arg)
     /* disable timer */
     tcpip_tcp_timer_active = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -173,6 +177,7 @@ tcp_timer_needed(void)
     tcpip_tcp_timer_active = 1;
     sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_TCP */
 
@@ -188,6 +193,7 @@ sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
   timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
   if (timeout == NULL) {
     LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -204,6 +210,7 @@ sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
 
   if (next_timeout == NULL) {
     next_timeout = timeout;
+    __A_VARIABLE = 1;
     return;
   }
   if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
@@ -218,6 +225,7 @@ sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -258,6 +266,7 @@ lwip_cyclic_timer(void *arg)
     sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 #endif
   }
+  __A_VARIABLE = 1;
 }
 
 /** Initialize this module */
@@ -270,6 +279,7 @@ void sys_timeouts_init(void)
       (this is OK as cyclic_timer() casts back to const* */
     sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -303,6 +313,7 @@ sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
 #else
   sys_timeout_abs(next_timeout_time, handler, arg);
 #endif
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -321,6 +332,7 @@ sys_untimeout(sys_timeout_handler handler, void *arg)
   LWIP_ASSERT_CORE_LOCKED();
 
   if (next_timeout == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -334,9 +346,11 @@ sys_untimeout(sys_timeout_handler handler, void *arg)
         prev_t->next = t->next;
       }
       memp_free(MEMP_SYS_TIMEOUT, t);
+      __A_VARIABLE = 1;
       return;
     }
   }
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -367,10 +381,12 @@ sys_check_timeouts(void)
 
     tmptimeout = next_timeout;
     if (tmptimeout == NULL) {
+      __A_VARIABLE = 1;
       return;
     }
 
     if (TIME_LESS_THAN(now, tmptimeout->time)) {
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -393,6 +409,7 @@ sys_check_timeouts(void)
 
     /* Repeat until all expired timers have been called */
   } while (1);
+  __A_VARIABLE = 1;
 }
 
 /** Rebase the timeout times to the current time.
@@ -408,6 +425,7 @@ sys_restart_timeouts(void)
   struct sys_timeo *t;
 
   if (next_timeout == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -417,6 +435,7 @@ sys_restart_timeouts(void)
   for (t = next_timeout; t != NULL; t = t->next) {
     t->time = (t->time - base) + now;
   }
+  __A_VARIABLE = 1;
 }
 
 /** Return the time left before the next timeout is due. If no timeouts are
@@ -447,5 +466,6 @@ sys_timeouts_sleeptime(void)
 void
 tcp_timer_needed(void)
 {
+	__A_VARIABLE = 1;
 }
 #endif /* LWIP_TIMERS && !LWIP_TIMERS_CUSTOM */
diff --git a/src/core/udp.c b/src/core/udp.c
index 35efc67..07085d1 100644
--- a/src/core/udp.c
+++ b/src/core/udp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * User Datagram Protocol module\n
diff --git a/src/netif/bridgeif.c b/src/netif/bridgeif.c
index 1cdda12..dbf2018 100644
--- a/src/netif/bridgeif.c
+++ b/src/netif/bridgeif.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * lwIP netif implementing an IEEE 802.1D MAC Bridge
@@ -151,12 +153,14 @@ bridgeif_fdb_add(struct netif *bridgeif, const struct eth_addr *addr, bridgeif_p
         memcpy(&br->fdbs[i].addr, addr, sizeof(struct eth_addr));
         BRIDGEIF_WRITE_UNPROTECT(lev);
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return ERR_OK;
       }
       BRIDGEIF_WRITE_UNPROTECT(lev);
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return ERR_MEM;
 }
 
@@ -182,12 +186,14 @@ bridgeif_fdb_remove(struct netif *bridgeif, const struct eth_addr *addr)
         memset(&br->fdbs[i], 0, sizeof(bridgeif_fdb_static_entry_t));
         BRIDGEIF_WRITE_UNPROTECT(lev);
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return ERR_OK;
       }
       BRIDGEIF_WRITE_UNPROTECT(lev);
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -204,6 +210,7 @@ bridgeif_find_dst_ports(bridgeif_private_t *br, struct eth_addr *dst_addr)
       if (!memcmp(&br->fdbs[i].addr, dst_addr, sizeof(struct eth_addr))) {
         bridgeif_portmask_t ret = br->fdbs[i].dst_ports;
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return ret;
       }
     }
@@ -211,10 +218,12 @@ bridgeif_find_dst_ports(bridgeif_private_t *br, struct eth_addr *dst_addr)
   if (dst_addr->addr[0] & 1) {
     /* no match found: flood remaining group address */
     BRIDGEIF_READ_UNPROTECT(lev);
+    __A_VARIABLE = 1;
     return BR_FLOOD;
   }
   BRIDGEIF_READ_UNPROTECT(lev);
   /* no match found: check dynamic fdb for port or fall back to flooding */
+  __A_VARIABLE = 1;
   return bridgeif_fdb_get_dst_ports(br->fdbd, dst_addr);
 }
 
@@ -228,6 +237,7 @@ bridgeif_is_local_mac(bridgeif_private_t *br, struct eth_addr *addr)
   int i;
   BRIDGEIF_DECL_PROTECT(lev);
   if (!memcmp(br->netif->hwaddr, addr, sizeof(struct eth_addr))) {
+    __A_VARIABLE = 1;
     return 1;
   }
   BRIDGEIF_READ_PROTECT(lev);
@@ -236,11 +246,13 @@ bridgeif_is_local_mac(bridgeif_private_t *br, struct eth_addr *addr)
     if (portif != NULL) {
       if (!memcmp(portif->hwaddr, addr, sizeof(struct eth_addr))) {
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return 1;
       }
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -287,6 +299,7 @@ bridgeif_send_to_ports(bridgeif_private_t *br, struct pbuf *p, bridgeif_portmask
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return ret_err;
 }
 
@@ -316,6 +329,7 @@ bridgeif_output(struct netif *netif, struct pbuf *p)
 
   LINK_STATS_INC(link.xmit);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -392,6 +406,7 @@ bridgeif_input(struct pbuf *p, struct netif *netif)
 static err_t
 bridgeif_tcpip_input(struct pbuf *p, struct netif *netif)
 {
+  __A_VARIABLE = 1;
   return tcpip_inpkt(p, netif, bridgeif_input);
 }
 #endif /* BRIDGEIF_PORT_NETIFS_OUTPUT_DIRECT */
@@ -441,6 +456,7 @@ bridgeif_init(struct netif *netif)
   br = (bridgeif_private_t *)mem_calloc(1, alloc_len);
   if (br == NULL) {
     LWIP_DEBUGF(NETIF_DEBUG, ("bridgeif_init: out of memory\n"));
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memcpy(&br->ethaddr, &init_data->ethaddr, sizeof(br->ethaddr));
@@ -457,6 +473,7 @@ bridgeif_init(struct netif *netif)
   if (br->fdbd == NULL) {
     LWIP_DEBUGF(NETIF_DEBUG, ("bridgeif_init: out of memory in fdb_init\n"));
     mem_free(br);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -513,6 +530,7 @@ bridgeif_init(struct netif *netif)
   }
 #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -532,12 +550,14 @@ bridgeif_add_port(struct netif *bridgeif, struct netif *portif)
 
   if (!(portif->flags & NETIF_FLAG_ETHARP) || !(portif->flags & NETIF_FLAG_ETHERNET)) {
     /* can only add ETHERNET/ETHARP interfaces */
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
   br = (bridgeif_private_t *)bridgeif->state;
 
   if (br->num_ports >= br->max_ports) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   port = &br->ports[br->num_ports];
@@ -557,6 +577,7 @@ bridgeif_add_port(struct netif *bridgeif, struct netif *portif)
   /* remove ETHARP flag to prevent sending report events on netif-up */
   netif_clear_flags(portif, NETIF_FLAG_ETHARP);
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
diff --git a/src/netif/bridgeif_fdb.c b/src/netif/bridgeif_fdb.c
index fb4b094..b46467d 100644
--- a/src/netif/bridgeif_fdb.c
+++ b/src/netif/bridgeif_fdb.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * lwIP netif implementing an FDB for IEEE 802.1D MAC Bridge
@@ -91,6 +93,7 @@ bridgeif_fdb_update_src(void *fdb_ptr, struct eth_addr *src_addr, u8_t port_idx)
         e->port = port_idx;
         BRIDGEIF_WRITE_UNPROTECT(lev);
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return;
       }
     }
@@ -111,6 +114,7 @@ bridgeif_fdb_update_src(void *fdb_ptr, struct eth_addr *src_addr, u8_t port_idx)
         e->used = 1;
         BRIDGEIF_WRITE_UNPROTECT(lev);
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return;
       }
       BRIDGEIF_WRITE_UNPROTECT(lev);
@@ -118,6 +122,7 @@ bridgeif_fdb_update_src(void *fdb_ptr, struct eth_addr *src_addr, u8_t port_idx)
   }
   BRIDGEIF_READ_UNPROTECT(lev);
   /* not found, no free entry -> flood */
+  __A_VARIABLE = 1;
 }
 
 /** 
@@ -137,11 +142,13 @@ bridgeif_fdb_get_dst_ports(void *fdb_ptr, struct eth_addr *dst_addr)
       if (!memcmp(&e->addr, dst_addr, sizeof(struct eth_addr))) {
         bridgeif_portmask_t ret = (bridgeif_portmask_t)(1 << e->port);
         BRIDGEIF_READ_UNPROTECT(lev);
+        __A_VARIABLE = 1;
         return ret;
       }
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
   return BR_FLOOD;
 }
 
@@ -173,6 +180,7 @@ bridgeif_fdb_age_one_second(void *fdb_ptr)
     }
   }
   BRIDGEIF_READ_UNPROTECT(lev);
+  __A_VARIABLE = 1;
 }
 
 /** Timer callback for fdb aging, called once per second */
@@ -185,6 +193,7 @@ bridgeif_age_tmr(void *arg)
 
   bridgeif_fdb_age_one_second(fdb);
   sys_timeout(BRIDGEIF_AGE_TIMER_MS, bridgeif_age_tmr, arg);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -201,6 +210,7 @@ bridgeif_fdb_init(u16_t max_fdb_entries)
   LWIP_DEBUGF(BRIDGEIF_DEBUG, ("bridgeif_fdb_init: allocating %d bytes for private FDB data\n", (int)alloc_len));
   fdb = (bridgeif_dfdb_t *)mem_calloc(1, alloc_len);
   if (fdb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   fdb->max_fdb_entries = max_fdb_entries;
@@ -208,5 +218,6 @@ bridgeif_fdb_init(u16_t max_fdb_entries)
 
   sys_timeout(BRIDGEIF_AGE_TIMER_MS, bridgeif_age_tmr, fdb);
 
+  __A_VARIABLE = 1;
   return fdb;
 }
diff --git a/src/netif/ethernet.c b/src/netif/ethernet.c
index 3c9eb02..36bcc68 100644
--- a/src/netif/ethernet.c
+++ b/src/netif/ethernet.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Ethernet common functions
@@ -132,6 +134,7 @@ ethernet_input(struct pbuf *p, struct netif *netif)
 #endif
       /* silently ignore this packet: not for our VLAN */
       pbuf_free(p);
+      __A_VARIABLE = 1;
       return ERR_OK;
     }
 #endif /* defined(LWIP_HOOK_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
@@ -245,10 +248,12 @@ ethernet_input(struct pbuf *p, struct netif *netif)
 
   /* This means the pbuf is freed or consumed,
      so the caller doesn't have to free it again */
+  __A_VARIABLE = 1;
   return ERR_OK;
 
 free_and_return:
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -309,12 +314,14 @@ ethernet_output(struct netif * netif, struct pbuf * p,
               ("ethernet_output: sending packet %p\n", (void *)p));
 
   /* send the packet */
+  __A_VARIABLE = 1;
   return netif->linkoutput(netif, p);
 
 pbuf_header_failed:
   LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
               ("ethernet_output: could not allocate room for header.\n"));
   LINK_STATS_INC(link.lenerr);
+  __A_VARIABLE = 1;
   return ERR_BUF;
 }
 
diff --git a/src/netif/lowpan6.c b/src/netif/lowpan6.c
index 6c26f66..dc1ec68 100644
--- a/src/netif/lowpan6.c
+++ b/src/netif/lowpan6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -169,6 +171,7 @@ lowpan6_write_iee802154_header(struct ieee_802154_hdr *hdr, const struct lowpan6
   while (i-- > 0) {
     buffer[ieee_header_len++] = src->addr[i];
   }
+  __A_VARIABLE = 1;
   return ieee_header_len;
 }
 
@@ -279,6 +282,7 @@ lowpan6_calc_crc(const void* buf, u16_t len)
     }
     p++;
   }
+  __A_VARIABLE = 1;
   return crc;
 }
 
@@ -294,6 +298,7 @@ free_reass_datagram(struct lowpan6_reass_helper *lrh)
     pbuf_free(lrh->frags);
   }
   mem_free(lrh);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -309,6 +314,7 @@ dequeue_datagram(struct lowpan6_reass_helper *lrh, struct lowpan6_reass_helper *
     LWIP_ASSERT("sanity check linked list", prev != NULL);
     prev->next_packet = lrh->next_packet;
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -332,6 +338,7 @@ lowpan6_tmr(void)
     }
     lrh = lrh_next;
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -526,6 +533,7 @@ lowpan6_set_short_addr(u8_t addr_high, u8_t addr_low)
   short_mac_addr.addr[0] = addr_high;
   short_mac_addr.addr[1] = addr_low;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* LWIP_6LOWPAN_INFER_SHORT_ADDRESS */
@@ -886,6 +894,7 @@ lowpan6_if_init(struct netif *netif)
   /* broadcast capability */
   netif->flags = NETIF_FLAG_BROADCAST /* | NETIF_FLAG_LOWPAN6 */;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -898,6 +907,7 @@ lowpan6_set_pan_id(u16_t pan_id)
 {
   lowpan6_data.ieee_802154_pan_id = pan_id;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -913,6 +923,7 @@ lowpan6_set_pan_id(u16_t pan_id)
 err_t
 tcpip_6lowpan_input(struct pbuf *p, struct netif *inp)
 {
+  __A_VARIABLE = 1;
   return tcpip_inpkt(p, inp, lowpan6_input);
 }
 #endif /* !NO_SYS */
diff --git a/src/netif/lowpan6_ble.c b/src/netif/lowpan6_ble.c
index 37bd4ce..2ce44d2 100644
--- a/src/netif/lowpan6_ble.c
+++ b/src/netif/lowpan6_ble.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * 6LowPAN over BLE output for IPv6 (RFC7668).
@@ -123,6 +125,7 @@ ble_addr_to_eui64(uint8_t *dst, const uint8_t *src, int public_addr)
 #else
   LWIP_UNUSED_ARG(public_addr);
 #endif
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -141,6 +144,7 @@ eui64_to_ble_addr(uint8_t *dst, const uint8_t *src)
   /* according to RFC7668 ch 3.2.2. */
   memcpy(dst,src,3);
   memcpy(&dst[3],&src[5],3);
+  __A_VARIABLE = 1;
 }
 
 /** Set an address used for stateful compression.
@@ -177,6 +181,7 @@ rfc7668_set_local_addr_eui64(struct netif *netif, const u8_t *local_addr, size_t
 {
   /* netif not used for now, the address is stored globally... */
   LWIP_UNUSED_ARG(netif);
+  __A_VARIABLE = 1;
   return rfc7668_set_addr(&rfc7668_local_addr, local_addr, local_addr_len, 0, 0);
 }
 
@@ -188,6 +193,7 @@ rfc7668_set_local_addr_mac48(struct netif *netif, const u8_t *local_addr, size_t
 {
   /* netif not used for now, the address is stored globally... */
   LWIP_UNUSED_ARG(netif);
+  __A_VARIABLE = 1;
   return rfc7668_set_addr(&rfc7668_local_addr, local_addr, local_addr_len, 1, is_public_addr);
 }
 
@@ -199,6 +205,7 @@ rfc7668_set_peer_addr_eui64(struct netif *netif, const u8_t *peer_addr, size_t p
 {
   /* netif not used for now, the address is stored globally... */
   LWIP_UNUSED_ARG(netif);
+  __A_VARIABLE = 1;
   return rfc7668_set_addr(&rfc7668_peer_addr, peer_addr, peer_addr_len, 0, 0);
 }
 
@@ -210,6 +217,7 @@ rfc7668_set_peer_addr_mac48(struct netif *netif, const u8_t *peer_addr, size_t p
 {
   /* netif not used for now, the address is stored globally... */
   LWIP_UNUSED_ARG(netif);
+  __A_VARIABLE = 1;
   return rfc7668_set_addr(&rfc7668_peer_addr, peer_addr, peer_addr_len, 1, is_public_addr);
 }
 
@@ -330,6 +338,7 @@ rfc7668_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr)
   /* dst ip6addr is not used here, we only have one peer */
   LWIP_UNUSED_ARG(ip6addr);
 
+  __A_VARIABLE = 1;
   return rfc7668_compress(netif, q);
 }
 
@@ -423,6 +432,7 @@ rfc7668_if_init(struct netif *netif)
   netif->flags = 0;
 
   /* everything fine */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -440,6 +450,7 @@ err_t
 tcpip_rfc7668_input(struct pbuf *p, struct netif *inp)
 {
   /* send data to upper layer, return the result */
+  __A_VARIABLE = 1;
   return tcpip_inpkt(p, inp, rfc7668_input);
 }
 #endif /* !NO_SYS */
diff --git a/src/netif/lowpan6_common.c b/src/netif/lowpan6_common.c
index 4aba4a3..009a6ee 100644
--- a/src/netif/lowpan6_common.c
+++ b/src/netif/lowpan6_common.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -118,9 +120,11 @@ lowpan6_context_lookup(const ip6_addr_t *lowpan6_contexts, const ip6_addr_t *ip6
 
   for (i = 0; i < LWIP_6LOWPAN_NUM_CONTEXTS; i++) {
     if (ip6_addr_netcmp(&lowpan6_contexts[i], ip6addr)) {
+      __A_VARIABLE = 1;
       return i;
     }
   }
+  __A_VARIABLE = 1;
   return -1;
 }
 #endif /* LWIP_6LOWPAN_NUM_CONTEXTS > 0 */
@@ -794,12 +798,14 @@ lowpan6_decompress(struct pbuf *p, u16_t datagram_size, ip6_addr_t *lowpan6_cont
   q = pbuf_alloc(PBUF_IP, p->len + IP6_HLEN + UDP_HLEN_ALLOC, PBUF_POOL);
   if (q == NULL) {
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return NULL;
   }
   if (q->len < IP6_HLEN + UDP_HLEN_ALLOC) {
     /* The headers need to fit into the first pbuf */
     pbuf_free(p);
     pbuf_free(q);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -809,6 +815,7 @@ lowpan6_decompress(struct pbuf *p, u16_t datagram_size, ip6_addr_t *lowpan6_cont
   if (err != ERR_OK) {
     pbuf_free(p);
     pbuf_free(q);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -834,6 +841,7 @@ lowpan6_decompress(struct pbuf *p, u16_t datagram_size, ip6_addr_t *lowpan6_cont
   pbuf_free(p);
 
   /* all done */
+  __A_VARIABLE = 1;
   return q;
 }
 
diff --git a/src/netif/ppp/auth.c b/src/netif/ppp/auth.c
index fee01ae..f030336 100644
--- a/src/netif/ppp/auth.c
+++ b/src/netif/ppp/auth.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * auth.c - PPP authentication and phase control.
  *
diff --git a/src/netif/ppp/ccp.c b/src/netif/ppp/ccp.c
index b354a3f..89b062c 100644
--- a/src/netif/ppp/ccp.c
+++ b/src/netif/ppp/ccp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * ccp.c - PPP Compression Control Protocol.
  *
@@ -246,6 +248,7 @@ static const fsm_callbacks ccp_callbacks = {
  * Do we want / did we get any compression?
  */
 static int ccp_anycompress(ccp_options *opt) {
+    __A_VARIABLE = 1;
     return (0
 #if DEFLATE_SUPPORT
 	|| (opt)->deflate
@@ -289,12 +292,14 @@ setbsdcomp(argv)
     }
     if (*endp != 0 || endp == str) {
 	option_error("invalid parameter '%s' for bsdcomp option", *argv);
+	__A_VARIABLE = 1;
 	return 0;
     }
     if ((rbits != 0 && (rbits < BSD_MIN_BITS || rbits > BSD_MAX_BITS))
 	|| (abits != 0 && (abits < BSD_MIN_BITS || abits > BSD_MAX_BITS))) {
 	option_error("bsdcomp option values must be 0 or %d .. %d",
 		     BSD_MIN_BITS, BSD_MAX_BITS);
+	__A_VARIABLE = 1;
 	return 0;
     }
     if (rbits > 0) {
@@ -310,6 +315,7 @@ setbsdcomp(argv)
     ppp_slprintf(bsd_value, sizeof(bsd_value),
 	     rbits == abits? "%d": "%d,%d", rbits, abits);
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -328,6 +334,7 @@ setdeflate(argv)
     }
     if (*endp != 0 || endp == str) {
 	option_error("invalid parameter '%s' for deflate option", *argv);
+	__A_VARIABLE = 1;
 	return 0;
     }
     if ((rbits != 0 && (rbits < DEFLATE_MIN_SIZE || rbits > DEFLATE_MAX_SIZE))
@@ -335,6 +342,7 @@ setdeflate(argv)
 			  || abits > DEFLATE_MAX_SIZE))) {
 	option_error("deflate option values must be 0 or %d .. %d",
 		     DEFLATE_MIN_SIZE, DEFLATE_MAX_SIZE);
+	__A_VARIABLE = 1;
 	return 0;
     }
     if (rbits == DEFLATE_MIN_SIZE || abits == DEFLATE_MIN_SIZE) {
@@ -358,6 +366,7 @@ setdeflate(argv)
     ppp_slprintf(deflate_value, sizeof(deflate_value),
 	     rbits == abits? "%d": "%d,%d", rbits, abits);
 
+    __A_VARIABLE = 1;
     return 1;
 }
 #endif /* PPP_OPTIONS */
@@ -401,6 +410,7 @@ static void ccp_init(ppp_pcb *pcb) {
 #if PREDICTOR_SUPPORT
     ao->predictor_1 = 1;
 #endif /* PREDICTOR_SUPPORT */
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -422,6 +432,7 @@ static void ccp_open(ppp_pcb *pcb) {
 	f->flags |= OPT_SILENT;
 
     fsm_open(f);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -431,6 +442,7 @@ static void ccp_close(ppp_pcb *pcb, const char *reason) {
     fsm *f = &pcb->ccp_fsm;
     ccp_set(pcb, 0, 0, 0, 0);
     fsm_close(f, reason);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -439,6 +451,7 @@ static void ccp_close(ppp_pcb *pcb, const char *reason) {
 static void ccp_lowerup(ppp_pcb *pcb) {
     fsm *f = &pcb->ccp_fsm;
     fsm_lowerup(f);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -447,6 +460,7 @@ static void ccp_lowerup(ppp_pcb *pcb) {
 static void ccp_lowerdown(ppp_pcb *pcb) {
     fsm *f = &pcb->ccp_fsm;
     fsm_lowerdown(f);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -479,6 +493,7 @@ static void ccp_input(ppp_pcb *pcb, u_char *p, int len) {
     if (oldstate == PPP_FSM_REQSENT && p[0] == TERMACK
 	&& !ccp_anycompress(go))
 	ccp_close(pcb, "No compression negotiated");
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -508,9 +523,11 @@ static int ccp_extcode(fsm *f, int code, int id, u_char *p, int len) {
 	break;
 
     default:
+	__A_VARIABLE = 1;
 	return 0;
     }
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -533,6 +550,7 @@ static void ccp_protrej(ppp_pcb *pcb) {
     }
 #endif /* MPPE_SUPPORT */
 
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -744,6 +762,7 @@ static int ccp_cilen(fsm *f) {
     ppp_pcb *pcb = f->pcb;
     ccp_options *go = &pcb->ccp_gotoptions;
 
+    __A_VARIABLE = 1;
     return 0
 #if BSDCOMPRESS_SUPPORT
 	+ (go->bsd_compress? CILEN_BSD_COMPRESS: 0)
@@ -826,6 +845,7 @@ static void ccp_addci(fsm *f, u_char *p, int *lenp) {
     go->method = (p > p0)? p0[0]: 0;
 
     *lenp = p - p0;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -1012,6 +1032,7 @@ static int ccp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 
     if (f->state != PPP_FSM_OPENED)
 	*go = try_;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1379,6 +1400,7 @@ static int ccp_reqci(fsm *f, u_char *p, int *lenp, int dont_nak) {
 	lcp_close(pcb, "MPPE required but peer negotiation failed");
     }
 #endif /* MPPE_SUPPORT */
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -1481,6 +1503,7 @@ static void ccp_up(fsm *f) {
 	continue_networks(pcb);		/* Bring up IP et al */
     }
 #endif /* MPPE_SUPPORT */
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -1506,6 +1529,7 @@ static void ccp_down(fsm *f) {
 	}
     }
 #endif /* MPPE_SUPPORT */
+    __A_VARIABLE = 1;
 }
 
 #if PRINTPKT_SUPPORT
@@ -1525,13 +1549,17 @@ static int ccp_printpkt(const u_char *p, int plen, void (*printer) (void *, cons
     int optlen;
 
     p0 = p;
-    if (plen < HEADERLEN)
-	return 0;
+    if (plen < HEADERLEN){
+	__A_VARIABLE = 1;
+	return 0;
+    }
     code = p[0];
     id = p[1];
     len = (p[2] << 8) + p[3];
-    if (len < HEADERLEN || len > plen)
-	return 0;
+    if (len < HEADERLEN || len > plen){
+	__A_VARIABLE = 1;
+	return 0;
+    }
 
     if (code >= 1 && code <= (int)LWIP_ARRAYSIZE(ccp_codenames) && ccp_codenames[code-1] != NULL)
 	printer(arg, " %s", ccp_codenames[code-1]);
@@ -1640,6 +1668,7 @@ static int ccp_printpkt(const u_char *p, int plen, void (*printer) (void *, cons
     while (--len >= 0)
 	printer(arg, " %.2x", *p++);
 
+    __A_VARIABLE = 1;
     return p - p0;
 }
 #endif /* PRINTPKT_SUPPORT */
@@ -1696,6 +1725,7 @@ static void ccp_datainput(ppp_pcb *pcb, u_char *pkt, int len) {
 		pcb->ccp_localstate |= RREQ_REPEAT;
 	}
     }
+    __A_VARIABLE = 1;
 }
 #endif /* PPP_DATAINPUT */
 
@@ -1706,8 +1736,10 @@ static void ccp_datainput(ppp_pcb *pcb, u_char *pkt, int len) {
 void ccp_resetrequest(ppp_pcb *pcb) {
     fsm *f = &pcb->ccp_fsm;
 
-    if (f->state != PPP_FSM_OPENED)
-	return;
+    if (f->state != PPP_FSM_OPENED){
+	__A_VARIABLE = 1;
+	return;
+    }
 
     /*
      * Send a reset-request to reset the peer's compressor.
@@ -1720,6 +1752,7 @@ void ccp_resetrequest(ppp_pcb *pcb) {
 	pcb->ccp_localstate |= RACK_PENDING;
     } else
 	pcb->ccp_localstate |= RREQ_REPEAT;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -1735,6 +1768,7 @@ static void ccp_rack_timeout(void *arg) {
 	pcb->ccp_localstate &= ~RREQ_REPEAT;
     } else
 	pcb->ccp_localstate &= ~RACK_PENDING;
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && CCP_SUPPORT */
diff --git a/src/netif/ppp/chap-md5.c b/src/netif/ppp/chap-md5.c
index 5a78944..e6fb944 100644
--- a/src/netif/ppp/chap-md5.c
+++ b/src/netif/ppp/chap-md5.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * chap-md5.c - New CHAP/MD5 implementation.
  *
@@ -56,6 +58,7 @@ static void chap_md5_generate_challenge(ppp_pcb *pcb, unsigned char *cp) {
 	clen = MD5_MIN_CHALLENGE + magic_pow(MD5_MIN_MAX_POWER_OF_TWO_CHALLENGE);
 	*cp++ = clen;
 	magic_random_bytes(cp, clen);
+	__A_VARIABLE = 1;
 }
 
 static int chap_md5_verify_response(ppp_pcb *pcb, int id, const char *name,
@@ -84,10 +87,12 @@ static int chap_md5_verify_response(ppp_pcb *pcb, int id, const char *name,
 		/* Test if our hash matches the peer's response */
 		if (memcmp(hash, response, MD5_HASH_SIZE) == 0) {
 			ppp_slprintf(message, message_space, "Access granted");
+			__A_VARIABLE = 1;
 			return 1;
 		}
 	}
 	ppp_slprintf(message, message_space, "Access denied");
+	__A_VARIABLE = 1;
 	return 0;
 }
 #endif /* PPP_SERVER */
@@ -110,6 +115,7 @@ static void chap_md5_make_response(ppp_pcb *pcb, unsigned char *response, int id
 	lwip_md5_finish(&ctx, &response[1]);
 	lwip_md5_free(&ctx);
 	response[0] = MD5_HASH_SIZE;
+	__A_VARIABLE = 1;
 }
 
 const struct chap_digest_type md5_digest = {
diff --git a/src/netif/ppp/chap-new.c b/src/netif/ppp/chap-new.c
index 486d7e1..f99e858 100644
--- a/src/netif/ppp/chap-new.c
+++ b/src/netif/ppp/chap-new.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * chap-new.c - New CHAP implementation.
  *
diff --git a/src/netif/ppp/chap_ms.c b/src/netif/ppp/chap_ms.c
index c1533e0..c4148d7 100644
--- a/src/netif/ppp/chap_ms.c
+++ b/src/netif/ppp/chap_ms.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * chap_ms.c - Microsoft MS-CHAP compatible implementation.
  *
@@ -232,6 +234,7 @@ static void chapms_generate_challenge(ppp_pcb *pcb, unsigned char *challenge) {
 	else
 #endif
 		magic_random_bytes(challenge, 8);
+	__A_VARIABLE = 1;
 }
 
 static void chapms2_generate_challenge(ppp_pcb *pcb, unsigned char *challenge) {
@@ -244,6 +247,7 @@ static void chapms2_generate_challenge(ppp_pcb *pcb, unsigned char *challenge) {
 	else
 #endif
 		magic_random_bytes(challenge, 16);
+	__A_VARIABLE = 1;
 }
 
 static int chapms_verify_response(ppp_pcb *pcb, int id, const char *name,
@@ -284,6 +288,7 @@ static int chapms_verify_response(ppp_pcb *pcb, int id, const char *name,
 
 	if (diff == 0) {
 		ppp_slprintf(message, message_space, "Access granted");
+		__A_VARIABLE = 1;
 		return 1;
 	}
 
@@ -291,6 +296,7 @@ static int chapms_verify_response(ppp_pcb *pcb, int id, const char *name,
 	/* See comments below for MS-CHAP V2 */
 	ppp_slprintf(message, message_space, "E=691 R=1 C=%0.*B V=0",
 		 challenge_len, challenge);
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -340,6 +346,7 @@ static int chapms2_verify_response(ppp_pcb *pcb, int id, const char *name,
 		else
 			ppp_slprintf(message, message_space, "S=%s M=%s",
 				 saresponse, "Access granted");
+		__A_VARIABLE = 1;
 		return 1;
 	}
 
@@ -367,6 +374,7 @@ static int chapms2_verify_response(ppp_pcb *pcb, int id, const char *name,
 	 */
 	ppp_slprintf(message, message_space, "E=691 R=1 C=%0.*B V=0 M=%s",
 		 challenge_len, challenge, "Access denied");
+	__A_VARIABLE = 1;
 	return 0;
 }
 #endif /* PPP_SERVER */
@@ -380,6 +388,7 @@ static void chapms_make_response(ppp_pcb *pcb, unsigned char *response, int id,
 	challenge++;	/* skip length, should be 8 */
 	*response++ = MS_CHAP_RESPONSE_LEN;
 	ChapMS(pcb, challenge, secret, secret_len, response);
+	__A_VARIABLE = 1;
 }
 
 static void chapms2_make_response(ppp_pcb *pcb, unsigned char *response, int id, const char *our_name,
@@ -396,6 +405,7 @@ static void chapms2_make_response(ppp_pcb *pcb, unsigned char *response, int id,
 #endif
 		our_name, secret, secret_len, response, private_,
 		MS_CHAP2_AUTHENTICATEE);
+	__A_VARIABLE = 1;
 }
 
 static int chapms2_check_success(ppp_pcb *pcb, unsigned char *msg, int len, unsigned char *private_) {
@@ -529,6 +539,7 @@ static void ChallengeResponse(const u_char *challenge,
 #if 0
     dbglog("ChallengeResponse - response %.24B", response);
 #endif
+    __A_VARIABLE = 1;
 }
 
 static void ChallengeHash(const u_char PeerChallenge[16], const u_char *rchallenge,
@@ -552,6 +563,7 @@ static void ChallengeHash(const u_char PeerChallenge[16], const u_char *rchallen
     lwip_sha1_free(&sha1Context);
 
     MEMCPY(Challenge, sha1Hash, 8);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -567,6 +579,7 @@ static void ascii2unicode(const char ascii[], int ascii_len, u_char unicode[]) {
     BZERO(unicode, ascii_len * 2);
     for (i = 0; i < ascii_len; i++)
 	unicode[i * 2] = (u_char) ascii[i];
+    __A_VARIABLE = 1;
 }
 
 static void NTPasswordHash(u_char *secret, int secret_len, u_char hash[MD4_SIGNATURE_SIZE]) {
@@ -577,6 +590,7 @@ static void NTPasswordHash(u_char *secret, int secret_len, u_char hash[MD4_SIGNA
     lwip_md4_update(&md4Context, secret, secret_len);
     lwip_md4_finish(&md4Context, hash);
     lwip_md4_free(&md4Context);
+    __A_VARIABLE = 1;
 }
 
 static void ChapMS_NT(const u_char *rchallenge, const char *secret, int secret_len,
@@ -589,6 +603,7 @@ static void ChapMS_NT(const u_char *rchallenge, const char *secret, int secret_l
     NTPasswordHash(unicodePassword, secret_len * 2, PasswordHash);
 
     ChallengeResponse(rchallenge, PasswordHash, NTResponse);
+    __A_VARIABLE = 1;
 }
 
 static void ChapMS2_NT(const u_char *rchallenge, const u_char PeerChallenge[16], const char *username,
@@ -604,6 +619,7 @@ static void ChapMS2_NT(const u_char *rchallenge, const u_char PeerChallenge[16],
     NTPasswordHash(unicodePassword, secret_len * 2, PasswordHash);
 
     ChallengeResponse(Challenge, PasswordHash, NTResponse);
+    __A_VARIABLE = 1;
 }
 
 #ifdef MSLANMAN
@@ -635,6 +651,7 @@ static void ChapMS_LANMan(u_char *rchallenge, char *secret, int secret_len,
     lwip_des_free(&des);
 
     ChallengeResponse(rchallenge, PasswordHash, &response[MS_CHAP_LANMANRESP]);
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -684,6 +701,7 @@ static void GenerateAuthenticatorResponse(const u_char PasswordHashHash[MD4_SIGN
     /* Convert to ASCII hex string. */
     for (i = 0; i < LWIP_MAX((MS_AUTH_RESPONSE_LENGTH / 2), (int)sizeof(Digest)); i++)
 	sprintf((char *)&authResponse[i * 2], "%02X", Digest[i]);
+    __A_VARIABLE = 1;
 }
 
 
@@ -704,6 +722,7 @@ static void GenerateAuthenticatorResponsePlain(
 
     GenerateAuthenticatorResponse(PasswordHashHash, NTResponse, PeerChallenge,
 				  rchallenge, username, authResponse);
+    __A_VARIABLE = 1;
 }
 
 
@@ -736,6 +755,7 @@ static void Set_Start_Key(ppp_pcb *pcb, const u_char *rchallenge, const char *se
     mppe_set_key(pcb, &pcb->mppe_decomp, Digest);
 
     pcb->mppe_keys_set = 1;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -830,6 +850,7 @@ static void SetMasterKeys(ppp_pcb *pcb, const char *secret, int secret_len, u_ch
     mppe_set_key(pcb, &pcb->mppe_decomp, Digest);
 
     pcb->mppe_keys_set = 1;
+    __A_VARIABLE = 1;
 }
 
 #endif /* MPPE_SUPPORT */
@@ -857,6 +878,7 @@ static void ChapMS(ppp_pcb *pcb, const u_char *rchallenge, const char *secret, i
 #if MPPE_SUPPORT
     Set_Start_Key(pcb, rchallenge, secret, secret_len);
 #endif /* MPPE_SUPPORT */
+    __A_VARIABLE = 1;
 }
 
 
@@ -902,6 +924,7 @@ static void ChapMS2(ppp_pcb *pcb, const u_char *rchallenge, const u_char *PeerCh
     SetMasterKeys(pcb, secret, secret_len,
 		  &response[MS_CHAP2_NTRESP], authenticator);
 #endif /* MPPE_SUPPORT */
+    __A_VARIABLE = 1;
 }
 
 #if 0 /* UNUSED */
diff --git a/src/netif/ppp/demand.c b/src/netif/ppp/demand.c
index 0bd3598..4fb3eb1 100644
--- a/src/netif/ppp/demand.c
+++ b/src/netif/ppp/demand.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * demand.c - Support routines for demand-dialling.
  *
@@ -118,6 +120,7 @@ demand_conf()
 	    if (!((*protp->demand_conf)(pcb)))
 		die(1);
 #endif
+	    __A_VARIABLE = 1;
 }
 
 
@@ -134,6 +137,7 @@ demand_block()
 	if (protp->demand_conf != NULL)
 	    sifnpmode(pcb, protp->protocol & ~0x8000, NPMODE_QUEUE);
     get_loop_output();
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -162,6 +166,7 @@ demand_discard()
     flush_flag = 0;
     escape_flag = 0;
     fcs = PPP_INITFCS;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -176,6 +181,7 @@ demand_unblock()
     for (i = 0; (protp = protocols[i]) != NULL; ++i)
 	if (protp->demand_conf != NULL)
 	    sifnpmode(pcb, protp->protocol & ~0x8000, NPMODE_PASS);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -234,6 +240,7 @@ loop_chars(p, n)
 
     if ( (p[0] == 0xFF) && (p[1] == 0x03) ) {
         rv = loop_frame(p,n);
+        __A_VARIABLE = 1;
         return rv;
     }
 
@@ -268,6 +275,7 @@ loop_chars(p, n)
 	frame[framelen++] = c;
 	fcs = PPP_FCS(fcs, c);
     }
+    __A_VARIABLE = 1;
     return rv;
 }
 
@@ -289,12 +297,18 @@ loop_frame(frame, len)
     struct packet *pkt;
 
     /* dbglog("from loop: %P", frame, len); */
-    if (len < PPP_HDRLEN)
-	return 0;
-    if ((PPP_PROTOCOL(frame) & 0x8000) != 0)
-	return 0;		/* shouldn't get any of these anyway */
-    if (!active_packet(frame, len))
-	return 0;
+    if (len < PPP_HDRLEN){
+	__A_VARIABLE = 1;
+	return 0;
+    }
+    if ((PPP_PROTOCOL(frame) & 0x8000) != 0){
+	__A_VARIABLE = 1;
+	return 0;
+    }		/* shouldn't get any of these anyway */
+    if (!active_packet(frame, len)){
+	__A_VARIABLE = 1;
+	return 0;
+    }
 
     pkt = (struct packet *) malloc(sizeof(struct packet) + len);
     if (pkt != NULL) {
@@ -307,6 +321,7 @@ loop_frame(frame, len)
 	    pend_qtail->next = pkt;
 	pend_qtail = pkt;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -424,6 +439,7 @@ demand_rexmit(proto, newip)
     pend_qtail = prev;
     if (prev != NULL)
 	prev->next = NULL;
+    __A_VARIABLE = 1;
 }
 
 /*
diff --git a/src/netif/ppp/eap.c b/src/netif/ppp/eap.c
index 5000e26..0847ae3 100644
--- a/src/netif/ppp/eap.c
+++ b/src/netif/ppp/eap.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * eap.c - Extensible Authentication Protocol for PPP (RFC 2284)
  *
diff --git a/src/netif/ppp/ecp.c b/src/netif/ppp/ecp.c
index a22eda8..f9654f0 100644
--- a/src/netif/ppp/ecp.c
+++ b/src/netif/ppp/ecp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * ecp.c - PPP Encryption Control Protocol.
  *
@@ -173,6 +175,7 @@ ecp_init(unit)
     memset(&ecp_hisoptions[unit],   0, sizeof(ecp_options));
 #endif /* 0 */
 
+    __A_VARIABLE = 1;
 }
 
 
@@ -184,6 +187,7 @@ ecp_printpkt(p, plen, printer, arg)
     void (*printer) (void *, char *, ...);
     void *arg;
 {
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif /* PRINTPKT_SUPPORT */
diff --git a/src/netif/ppp/eui64.c b/src/netif/ppp/eui64.c
index 15af855..87eaee5 100644
--- a/src/netif/ppp/eui64.c
+++ b/src/netif/ppp/eui64.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * eui64.c - EUI64 routines for IPv6CP.
  *
@@ -50,6 +52,7 @@ char *eui64_ntoa(eui64_t e) {
     sprintf(buf, "%02x%02x:%02x%02x:%02x%02x:%02x%02x",
 	     e.e8[0], e.e8[1], e.e8[2], e.e8[3], 
 	     e.e8[4], e.e8[5], e.e8[6], e.e8[7]);
+    __A_VARIABLE = 1;
     return buf;
 }
 
diff --git a/src/netif/ppp/fsm.c b/src/netif/ppp/fsm.c
index 9d32e7c..ba1206a 100644
--- a/src/netif/ppp/fsm.c
+++ b/src/netif/ppp/fsm.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * fsm.c - {Link, IP} Control Protocol Finite State Machine.
  *
@@ -82,6 +84,7 @@ void fsm_init(fsm *f) {
     f->id = 0;				/* XXX Start with random id? */
     f->maxnakloops = pcb->settings.fsm_max_nak_loops;
     f->term_reason_len = 0;
+    __A_VARIABLE = 1;
 }
 
 
@@ -108,6 +111,7 @@ void fsm_lowerup(fsm *f) {
 	FSMDEBUG(("%s: Up event in state %d!", PROTO_NAME(f), f->state));
 	/* no break */
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -151,6 +155,7 @@ void fsm_lowerdown(fsm *f) {
 	FSMDEBUG(("%s: Down event in state %d!", PROTO_NAME(f), f->state));
 	/* no break */
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -189,6 +194,7 @@ void fsm_open(fsm *f) {
     default:
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -219,6 +225,7 @@ static void terminate_layer(fsm *f, int nextstate) {
 	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
 	if( f->callbacks->finished )
 	    (*f->callbacks->finished)(f);
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -226,6 +233,7 @@ static void terminate_layer(fsm *f, int nextstate) {
     --f->retransmits;
 
     f->state = nextstate;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -257,6 +265,7 @@ void fsm_close(fsm *f, const char *reason) {
     default:
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -309,6 +318,7 @@ static void fsm_timeout(void *arg) {
 	FSMDEBUG(("%s: Timeout event in state %d!", PROTO_NAME(f), f->state));
 	/* no break */
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -327,6 +337,7 @@ void fsm_input(fsm *f, u_char *inpacket, int l) {
     inp = inpacket;
     if (l < HEADERLEN) {
 	FSMDEBUG(("fsm_input(%x): Rcvd short header.", f->protocol));
+	__A_VARIABLE = 1;
 	return;
     }
     GETCHAR(code, inp);
@@ -334,10 +345,12 @@ void fsm_input(fsm *f, u_char *inpacket, int l) {
     GETSHORT(len, inp);
     if (len < HEADERLEN) {
 	FSMDEBUG(("fsm_input(%x): Rcvd illegal length.", f->protocol));
+	__A_VARIABLE = 1;
 	return;
     }
     if (len > l) {
 	FSMDEBUG(("fsm_input(%x): Rcvd short packet.", f->protocol));
+	__A_VARIABLE = 1;
 	return;
     }
     len -= HEADERLEN;		/* subtract header length */
@@ -345,6 +358,7 @@ void fsm_input(fsm *f, u_char *inpacket, int l) {
     if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
 	FSMDEBUG(("fsm_input(%x): Rcvd packet in state %d.",
 		  f->protocol, f->state));
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -383,6 +397,7 @@ void fsm_input(fsm *f, u_char *inpacket, int l) {
 	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -396,9 +411,11 @@ static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
     case PPP_FSM_CLOSED:
 	/* Go away, we're closed */
 	fsm_sdata(f, TERMACK, id, NULL, 0);
+	__A_VARIABLE = 1;
 	return;
     case PPP_FSM_CLOSING:
     case PPP_FSM_STOPPING:
+	__A_VARIABLE = 1;
 	return;
 
     case PPP_FSM_OPENED:
@@ -450,6 +467,7 @@ static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 	if( code == CONFNAK )
 	    ++f->nakloops;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -459,12 +477,15 @@ static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
     ppp_pcb *pcb = f->pcb;
 
-    if (id != f->reqid || f->seen_ack)		/* Expected id? */
-	return;					/* Nope, toss... */
+    if (id != f->reqid || f->seen_ack)		/* Expected id? */{
+	__A_VARIABLE = 1;
+	return;
+    }					/* Nope, toss... */
     if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
 	  (len == 0)) ){
 	/* Ack is bad - ignore it */
 	ppp_error("Received bad configure-ack: %P", inp, len);
+	__A_VARIABLE = 1;
 	return;
     }
     f->seen_ack = 1;
@@ -506,6 +527,7 @@ static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
     default:
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -602,6 +624,7 @@ static void fsm_rtermreq(fsm *f, int id, u_char *p, int len) {
     }
 
     fsm_sdata(f, TERMACK, id, NULL, 0);
+    __A_VARIABLE = 1;
 }
 
 
@@ -636,6 +659,7 @@ static void fsm_rtermack(fsm *f) {
     default:
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -647,6 +671,7 @@ static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 
     if (len < HEADERLEN) {
 	FSMDEBUG(("fsm_rcoderej: Rcvd short Code-Reject packet!"));
+	__A_VARIABLE = 1;
 	return;
     }
     GETCHAR(code, inp);
@@ -655,6 +680,7 @@ static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 
     if( f->state == PPP_FSM_ACKRCVD )
 	f->state = PPP_FSM_REQSENT;
+    __A_VARIABLE = 1;
 }
 
 
@@ -697,6 +723,7 @@ void fsm_protreject(fsm *f) {
 		  PROTO_NAME(f), f->state));
 	/* no break */
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -736,10 +763,13 @@ static void fsm_sconfreq(fsm *f, int retransmit) {
 	cilen = 0;
 
     p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
-    if(NULL == p)
-        return;
+    if(NULL == p){
+        __A_VARIABLE = 1;
+        return;
+    }
     if(p->tot_len != p->len) {
         pbuf_free(p);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -759,6 +789,7 @@ static void fsm_sconfreq(fsm *f, int retransmit) {
     /* start the retransmit timer */
     --f->retransmits;
     TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
+    __A_VARIABLE = 1;
 }
 
 
@@ -779,10 +810,13 @@ void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen)
     outlen = datalen + HEADERLEN;
 
     p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
-    if(NULL == p)
-        return;
+    if(NULL == p){
+        __A_VARIABLE = 1;
+        return;
+    }
     if(p->tot_len != p->len) {
         pbuf_free(p);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -794,6 +828,7 @@ void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen)
     PUTCHAR(id, outp);
     PUTSHORT(outlen, outp);
     ppp_write(pcb, p);
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT */
diff --git a/src/netif/ppp/ipcp.c b/src/netif/ppp/ipcp.c
index 3fba320..72e30ac 100644
--- a/src/netif/ppp/ipcp.c
+++ b/src/netif/ppp/ipcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * ipcp.c - PPP IP Control Protocol.
  *
diff --git a/src/netif/ppp/ipv6cp.c b/src/netif/ppp/ipv6cp.c
index e7d81c9..cbe42b9 100644
--- a/src/netif/ppp/ipv6cp.c
+++ b/src/netif/ppp/ipv6cp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * ipv6cp.c - PPP IPV6 Control Protocol.
  *
diff --git a/src/netif/ppp/lcp.c b/src/netif/ppp/lcp.c
index 1316918..f615e58 100644
--- a/src/netif/ppp/lcp.c
+++ b/src/netif/ppp/lcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * lcp.c - PPP Link Control Protocol.
  *
@@ -330,6 +332,7 @@ noopt(argv)
     BZERO((char *) &lcp_wantoptions[0], sizeof (struct lcp_options));
     BZERO((char *) &lcp_allowoptions[0], sizeof (struct lcp_options));
 
+    __A_VARIABLE = 1;
     return (1);
 }
 #endif /* PPP_OPTIONS */
@@ -341,9 +344,11 @@ setendpoint(argv)
 {
     if (str_to_epdisc(&lcp_wantoptions[0].endpoint, *argv)) {
 	lcp_wantoptions[0].neg_endpoint = 1;
+	__A_VARIABLE = 1;
 	return 1;
     }
     option_error("Can't parse '%s' as an endpoint discriminator", *argv);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -354,6 +359,7 @@ printendpoint(opt, printer, arg)
     void *arg;
 {
 	printer(arg, "%s", epdisc_to_str(&lcp_wantoptions[0].endpoint));
+	__A_VARIABLE = 1;
 }
 #endif /* HAVE_MULTILINK */
 
@@ -397,6 +403,7 @@ static void lcp_init(ppp_pcb *pcb) {
     ao->neg_pcompression = 1;
     ao->neg_accompression = 1;
     ao->neg_endpoint = 1;
+    __A_VARIABLE = 1;
 }
 
 
@@ -413,6 +420,7 @@ void lcp_open(ppp_pcb *pcb) {
     if (wo->silent)
 	f->flags |= OPT_SILENT;
     fsm_open(f);
+    __A_VARIABLE = 1;
 }
 
 
@@ -448,6 +456,7 @@ void lcp_close(ppp_pcb *pcb, const char *reason) {
 	f->flags &= ~DELAYED_UP;
 	lcp_finished(f);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -464,8 +473,10 @@ void lcp_lowerup(ppp_pcb *pcb) {
      */
     if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
 	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
-			   wo->neg_pcompression, wo->neg_accompression) < 0)
-	    return;
+			   wo->neg_pcompression, wo->neg_accompression) < 0){
+	    __A_VARIABLE = 1;
+	    return;
+    }
     pcb->peer_mru = PPP_MRU;
 
     if (pcb->settings.listen_time != 0) {
@@ -473,6 +484,7 @@ void lcp_lowerup(ppp_pcb *pcb) {
 	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
     } else
 	fsm_lowerup(f);
+    __A_VARIABLE = 1;
 }
 
 
@@ -487,6 +499,7 @@ void lcp_lowerdown(ppp_pcb *pcb) {
 	UNTIMEOUT(lcp_delayed_up, f);
     } else
 	fsm_lowerdown(f);
+    __A_VARIABLE = 1;
 }
 
 
@@ -515,6 +528,7 @@ static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
 	fsm_lowerup(f);
     }
     fsm_input(f, p, len);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -548,8 +562,10 @@ static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
 	break;
 
     default:
+	__A_VARIABLE = 1;
 	return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -569,6 +585,7 @@ static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 
     if (len < 2) {
 	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -580,6 +597,7 @@ static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
      */
     if( f->state != PPP_FSM_OPENED ){
 	LCPDEBUG(("Protocol-Reject discarded: LCP in state %d", f->state));
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -600,6 +618,7 @@ static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 #endif /* PPP_PROTOCOLNAME */
 		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
 	    (*protp->protrej)(f->pcb);
+	    __A_VARIABLE = 1;
 	    return;
 	}
 
@@ -610,6 +629,7 @@ static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
     else
 #endif /* #if PPP_PROTOCOLNAME */
 	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
+    __A_VARIABLE = 1;
 }
 
 
@@ -623,6 +643,7 @@ static void lcp_protrej(ppp_pcb *pcb) {
      */
     ppp_error("Received Protocol-Reject for LCP!");
     fsm_protreject(&pcb->lcp_fsm);
+    __A_VARIABLE = 1;
 }
 
 
@@ -642,6 +663,7 @@ void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
 
     fsm_sdata(f, PROTREJ, ++f->id,
 	      p, len);
+    __A_VARIABLE = 1;
 }
 
 
@@ -761,6 +783,7 @@ static void lcp_resetci(fsm *f) {
 #if 0 /* UNUSED */
     auth_reset(pcb);
 #endif /* UNUSED */
+    __A_VARIABLE = 1;
 }
 
 
@@ -786,45 +809,46 @@ static int lcp_cilen(fsm *f) {
      * accept more than one.  We prefer EAP first, then CHAP, then
      * PAP.
      */
+    __A_VARIABLE = 1;
     return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
-	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
+            LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 #if EAP_SUPPORT
-	    LENCISHORT(go->neg_eap) +
+            LENCISHORT(go->neg_eap) +
 #endif /* EAP_SUPPORT */
 #if CHAP_SUPPORT /* cannot be improved, embedding a directive within macro arguments is not portable */
 #if EAP_SUPPORT
-	    LENCICHAP(!go->neg_eap && go->neg_chap) +
+            LENCICHAP(!go->neg_eap && go->neg_chap) +
 #endif /* EAP_SUPPORT */
 #if !EAP_SUPPORT
-	    LENCICHAP(go->neg_chap) +
+            LENCICHAP(go->neg_chap) +
 #endif /* !EAP_SUPPORT */
 #endif /* CHAP_SUPPORT */
 #if PAP_SUPPORT /* cannot be improved, embedding a directive within macro arguments is not portable */
 #if EAP_SUPPORT && CHAP_SUPPORT
-	    LENCISHORT(!go->neg_eap && !go->neg_chap && go->neg_upap) +
+            LENCISHORT(!go->neg_eap && !go->neg_chap && go->neg_upap) +
 #endif /* EAP_SUPPORT && CHAP_SUPPORT */
 #if EAP_SUPPORT && !CHAP_SUPPORT
-	    LENCISHORT(!go->neg_eap && go->neg_upap) +
+            LENCISHORT(!go->neg_eap && go->neg_upap) +
 #endif /* EAP_SUPPORT && !CHAP_SUPPORT */
 #if !EAP_SUPPORT && CHAP_SUPPORT
-	    LENCISHORT(!go->neg_chap && go->neg_upap) +
+            LENCISHORT(!go->neg_chap && go->neg_upap) +
 #endif /* !EAP_SUPPORT && CHAP_SUPPORT */
 #if !EAP_SUPPORT && !CHAP_SUPPORT
-	    LENCISHORT(go->neg_upap) +
+            LENCISHORT(go->neg_upap) +
 #endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
 #endif /* PAP_SUPPORT */
 #if LQR_SUPPORT
-	    LENCILQR(go->neg_lqr) +
+            LENCILQR(go->neg_lqr) +
 #endif /* LQR_SUPPORT */
-	    LENCICBCP(go->neg_cbcp) +
-	    LENCILONG(go->neg_magicnumber) +
-	    LENCIVOID(go->neg_pcompression) +
-	    LENCIVOID(go->neg_accompression) +
+            LENCICBCP(go->neg_cbcp) +
+            LENCILONG(go->neg_magicnumber) +
+            LENCIVOID(go->neg_pcompression) +
+            LENCIVOID(go->neg_accompression) +
 #ifdef HAVE_MULTILINK
-	    LENCISHORT(go->neg_mrru) +
+            LENCISHORT(go->neg_mrru) +
 #endif /* HAVE_MULTILINK */
-	    LENCIVOID(go->neg_ssnhf) +
-	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
+            LENCIVOID(go->neg_ssnhf) +
+            (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
 }
 
 
@@ -933,6 +957,7 @@ static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
 	/* this should never happen, because peer_mtu should be 1500 */
 	ppp_error("Bug in lcp_addci: wrong length");
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -1108,9 +1133,11 @@ static int lcp_ackci(fsm *f, u_char *p, int len) {
      */
     if (len != 0)
 	goto bad;
+    __A_VARIABLE = 1;
     return (1);
 bad:
     LCPDEBUG(("lcp_acki: received bad Ack!"));
+    __A_VARIABLE = 1;
     return (0);
 }
 
@@ -1569,10 +1596,12 @@ static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 	*go = try_;
     }
 
+    __A_VARIABLE = 1;
     return 1;
 
 bad:
     LCPDEBUG(("lcp_nakci: received bad Nak!"));
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1799,10 +1828,12 @@ static int lcp_rejci(fsm *f, u_char *p, int len) {
      */
     if (f->state != PPP_FSM_OPENED)
 	*go = try_;
+    __A_VARIABLE = 1;
     return 1;
 
 bad:
     LCPDEBUG(("lcp_rejci: received bad Reject!"));
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1844,10 +1875,13 @@ static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
      */
     next = inp;
     nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
-    if(NULL == nakp)
-        return 0;
+    if(NULL == nakp){
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if(nakp->tot_len != nakp->len) {
         pbuf_free(nakp);
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -2280,6 +2314,7 @@ endswitch:
 
     pbuf_free(nakp);
     LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
+    __A_VARIABLE = 1;
     return (rc);			/* Return final code */
 }
 
@@ -2328,6 +2363,7 @@ static void lcp_up(fsm *f) {
     lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
 
     link_established(pcb);
+    __A_VARIABLE = 1;
 }
 
 
@@ -2349,6 +2385,7 @@ static void lcp_down(fsm *f) {
 		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 		    go->neg_pcompression, go->neg_accompression);
     pcb->peer_mru = PPP_MRU;
+    __A_VARIABLE = 1;
 }
 
 
@@ -2358,6 +2395,7 @@ static void lcp_down(fsm *f) {
 static void lcp_starting(fsm *f) {
     ppp_pcb *pcb = f->pcb;
     link_required(pcb);
+    __A_VARIABLE = 1;
 }
 
 
@@ -2367,6 +2405,7 @@ static void lcp_starting(fsm *f) {
 static void lcp_finished(fsm *f) {
     ppp_pcb *pcb = f->pcb;
     link_terminated(pcb);
+    __A_VARIABLE = 1;
 }
 
 
@@ -2644,6 +2683,7 @@ static void LcpLinkFailure(fsm *f) {
 	pcb->err_code = PPPERR_PEERDEAD;
 	lcp_close(pcb, "Peer not responding");
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -2654,8 +2694,10 @@ static void LcpEchoCheck(fsm *f) {
     ppp_pcb *pcb = f->pcb;
 
     LcpSendEchoRequest (f);
-    if (f->state != PPP_FSM_OPENED)
-	return;
+    if (f->state != PPP_FSM_OPENED){
+	__A_VARIABLE = 1;
+	return;
+    }
 
     /*
      * Start the timer for the next interval.
@@ -2664,6 +2706,7 @@ static void LcpEchoCheck(fsm *f) {
 	ppp_warn("assertion lcp_echo_timer_running==0 failed");
     TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
     pcb->lcp_echo_timer_running = 1;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -2692,17 +2735,20 @@ static void lcp_received_echo_reply(fsm *f, int id, u_char *inp, int len) {
     /* Check the magic number - don't count replies from ourselves. */
     if (len < 4) {
 	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
+	__A_VARIABLE = 1;
 	return;
     }
     GETLONG(magic_val, inp);
     if (go->neg_magicnumber
 	&& magic_val == go->magicnumber) {
 	ppp_warn("appear to have received our own echo-reply!");
+	__A_VARIABLE = 1;
 	return;
     }
 
     /* Reset the number of outstanding echo frames */
     pcb->lcp_echos_pending = 0;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -2772,6 +2818,7 @@ static void lcp_echo_lowerup(ppp_pcb *pcb) {
     /* If a timeout interval is specified then start the timer */
     if (pcb->settings.lcp_echo_interval != 0)
         LcpEchoCheck (f);
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -2785,6 +2832,7 @@ static void lcp_echo_lowerdown(ppp_pcb *pcb) {
         UNTIMEOUT (LcpEchoTimeout, f);
         pcb->lcp_echo_timer_running = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT */
diff --git a/src/netif/ppp/magic.c b/src/netif/ppp/magic.c
index 32cfa26..ae0b1cc 100644
--- a/src/netif/ppp/magic.c
+++ b/src/netif/ppp/magic.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * magic.c - PPP Magic Number routines.
  *
@@ -125,6 +127,7 @@ static void magic_churnrand(char *rand_data, u32_t rand_len) {
   lwip_md5_finish(&md5_ctx, (u_char *)magic_randpool);
   lwip_md5_free(&md5_ctx);
 /*  LWIP_DEBUGF(LOG_INFO, ("magic_churnrand: -> 0\n")); */
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -132,6 +135,7 @@ static void magic_churnrand(char *rand_data, u32_t rand_len) {
  */
 void magic_init(void) {
   magic_churnrand(NULL, 0);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -139,6 +143,7 @@ void magic_init(void) {
  */
 void magic_randomize(void) {
   magic_churnrand(NULL, 0);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -177,6 +182,7 @@ void magic_random_bytes(unsigned char *buf, u32_t buf_len) {
     buf += n;
     buf_len -= n;
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -187,6 +193,7 @@ u32_t magic(void) {
 
   magic_random_bytes((unsigned char *)&new_rand, sizeof(new_rand));
 
+  __A_VARIABLE = 1;
   return new_rand;
 }
 
@@ -225,6 +232,7 @@ void magic_init(void) {
   /* Initialize the Borland random number generator. */
   srand((unsigned)magic_randomseed);
 #endif /* LWIP_RAND */
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -248,6 +256,7 @@ void magic_randomize(void) {
 #ifndef LWIP_RAND
   }
 #endif /* LWIP_RAND */
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -281,6 +290,7 @@ void magic_random_bytes(unsigned char *buf, u32_t buf_len) {
     buf += n;
     buf_len -= n;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_MD5_RANDM */
 
@@ -288,6 +298,7 @@ void magic_random_bytes(unsigned char *buf, u32_t buf_len) {
  * Return a new random number between 0 and (2^pow)-1 included.
  */
 u32_t magic_pow(u8_t pow) {
+  __A_VARIABLE = 1;
   return magic() & ~(~0UL<<pow);
 }
 
diff --git a/src/netif/ppp/mppe.c b/src/netif/ppp/mppe.c
index 83b8b31..640f362 100644
--- a/src/netif/ppp/mppe.c
+++ b/src/netif/ppp/mppe.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * mppe.c - interface MPPE to the PPP code.
  *
@@ -91,6 +93,7 @@ static void mppe_rekey(ppp_mppe_state * state, int initial_key)
 	}
 	lwip_arc4_init(&state->arc4);
 	lwip_arc4_setup(&state->arc4, state->session_key, state->keylen);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -100,6 +103,7 @@ static void mppe_rekey(ppp_mppe_state * state, int initial_key)
 void mppe_set_key(ppp_pcb *pcb, ppp_mppe_state *state, u8_t *key) {
 	LWIP_UNUSED_ARG(pcb);
 	MEMCPY(state->master_key, key, MPPE_MAX_KEY_LEN);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -182,6 +186,7 @@ void mppe_comp_reset(ppp_pcb *pcb, ppp_mppe_state *state)
 {
 	LWIP_UNUSED_ARG(pcb);
 	state->bits |= MPPE_BIT_FLUSHED;
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -203,6 +208,7 @@ mppe_compress(ppp_pcb *pcb, ppp_mppe_state *state, struct pbuf **pb, u16_t proto
 	 */
 	np = pbuf_alloc(PBUF_RAW, MPPE_OVHD + sizeof(protocol) + (*pb)->tot_len, PBUF_RAM);
 	if (!np) {
+		__A_VARIABLE = 1;
 		return ERR_MEM;
 	}
 
@@ -211,6 +217,7 @@ mppe_compress(ppp_pcb *pcb, ppp_mppe_state *state, struct pbuf **pb, u16_t proto
 
 	if ((err = pbuf_copy(np, *pb)) != ERR_OK) {
 		pbuf_free(np);
+		__A_VARIABLE = 1;
 		return err;
 	}
 
@@ -259,6 +266,7 @@ mppe_compress(ppp_pcb *pcb, ppp_mppe_state *state, struct pbuf **pb, u16_t proto
 	/* Reveal MPPE header */
 	pbuf_add_header(np, MPPE_OVHD);
 
+	__A_VARIABLE = 1;
 	return ERR_OK;
 }
 
@@ -269,6 +277,7 @@ void mppe_decomp_reset(ppp_pcb *pcb, ppp_mppe_state *state)
 {
 	LWIP_UNUSED_ARG(pcb);
 	LWIP_UNUSED_ARG(state);
+	__A_VARIABLE = 1;
 	return;
 }
 
diff --git a/src/netif/ppp/multilink.c b/src/netif/ppp/multilink.c
index 9153dea..d696e0e 100644
--- a/src/netif/ppp/multilink.c
+++ b/src/netif/ppp/multilink.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * multilink.c - support routines for multilink.
  *
@@ -94,8 +96,10 @@ mp_check_options()
 	lcp_options *ao = &lcp_allowoptions[0];
 
 	doing_multilink = 0;
-	if (!multilink)
-		return;
+	if (!multilink){
+		__A_VARIABLE = 1;
+		return;
+	}
 	/* if we're doing multilink, we have to negotiate MRRU */
 	if (!wo->neg_mrru) {
 		/* mrru not specified, default to mru */
@@ -109,6 +113,7 @@ mp_check_options()
 		/* get a default endpoint value */
 		wo->neg_endpoint = get_default_epdisc(&wo->endpoint);
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -131,10 +136,12 @@ mp_join_bundle()
 		if (!go->neg_mrru || !ho->neg_mrru) {
 			notice("oops, didn't get multilink on renegotiation");
 			lcp_close(pcb, "multilink required");
+			__A_VARIABLE = 1;
 			return 0;
 		}
 		/* XXX should check the peer_authname and ho->endpoint
 		   are the same as previously */
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -149,11 +156,13 @@ mp_join_bundle()
 			/* already have a bundle */
 			cfg_bundle(0, 0, 0, 0);
 			netif_set_mtu(pcb, mtu);
+			__A_VARIABLE = 1;
 			return 0;
 		}
 		make_new_bundle(0, 0, 0, 0);
 		set_ifunit(1);
 		netif_set_mtu(pcb, mtu);
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -200,6 +209,7 @@ mp_join_bundle()
 		cfg_bundle(go->mrru, ho->mrru, go->neg_ssnhf, ho->neg_ssnhf);
 		netif_set_mtu(pcb, mtu);
 		script_setenv("BUNDLE", bundle_id + 7, 1);
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -237,6 +247,7 @@ mp_join_bundle()
 			make_bundle_links(1);
 			unlock_db();
 			info("Link attached to %s", ifname);
+			__A_VARIABLE = 1;
 			return 1;
 		}
 		/* attach failed because bundle doesn't exist */
@@ -251,6 +262,7 @@ mp_join_bundle()
 	unlock_db();
 	info("New bundle %s created", ifname);
 	multilink_master = 1;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -259,6 +271,7 @@ void mp_exit_bundle()
 	lock_db();
 	remove_bundle_link();
 	unlock_db();
+	__A_VARIABLE = 1;
 }
 
 static void sendhup(char *str)
@@ -270,6 +283,7 @@ static void sendhup(char *str)
 			dbglog("sending SIGHUP to process %d", pid);
 		kill(pid, SIGHUP);
 	}
+	__A_VARIABLE = 1;
 }
 
 void mp_bundle_terminated()
@@ -299,6 +313,7 @@ void mp_bundle_terminated()
 
 	doing_multilink = 0;
 	multilink_master = 0;
+	__A_VARIABLE = 1;
 }
 
 static void make_bundle_links(int append)
@@ -356,6 +371,7 @@ static void remove_bundle_link()
 	if (rec.dptr == NULL || rec.dsize <= 0) {
 		if (rec.dptr != NULL)
 			free(rec.dptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 	rec.dptr[rec.dsize-1] = 0;
@@ -369,6 +385,7 @@ static void remove_bundle_link()
 			error("couldn't update bundle link list (removal)");
 	}
 	free(rec.dptr);
+	__A_VARIABLE = 1;
 }
 
 static void iterate_bundle_links(void (*func)(char *))
@@ -383,6 +400,7 @@ static void iterate_bundle_links(void (*func)(char *))
 		error("bundle link list not found (iterating list)");
 		if (rec.dptr != NULL)
 			free(rec.dptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 	p = rec.dptr;
@@ -401,6 +419,7 @@ static void iterate_bundle_links(void (*func)(char *))
 		p = q + 1;
 	}
 	free(rec.dptr);
+	__A_VARIABLE = 1;
 }
 
 static int
@@ -418,9 +437,11 @@ parse_num(str, key, valp)
 		i = strtol(p, &endp, 10);
 		if (endp != p && (*endp == 0 || *endp == ';')) {
 			*valp = i;
+			__A_VARIABLE = 1;
 			return 1;
 		}
 	}
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -445,6 +466,7 @@ owns_unit(key, unit)
 			&& memcmp(vd.dptr, key.dptr, vd.dsize) == 0;
 		free(vd.dptr);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -461,6 +483,7 @@ get_default_epdisc(ep)
 	if (p != 0 && get_if_hwaddr(ep->value, p) >= 0) {
 		ep->class = EPD_MAC;
 		ep->length = 6;
+		__A_VARIABLE = 1;
 		return 1;
 	}
 
@@ -473,11 +496,13 @@ get_default_epdisc(ep)
 			if (!LOCAL_IP_ADDR(addr)) {
 				ep->class = EPD_IP;
 				set_ip_epdisc(ep, addr);
+				__A_VARIABLE = 1;
 				return 1;
 			}
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -498,13 +523,16 @@ epdisc_to_str(ep)
 	int i, mask = 0;
 	char *q, c, c2;
 
-	if (ep->class == EPD_NULL && ep->length == 0)
-		return "null";
+	if (ep->class == EPD_NULL && ep->length == 0){
+		__A_VARIABLE = 1;
+		return "null";
+	}
 	if (ep->class == EPD_IP && ep->length == 4) {
 		u32_t addr;
 
 		GETLONG(addr, p);
 		slprintf(str, sizeof(str), "IP:%I", lwip_htonl(addr));
+		__A_VARIABLE = 1;
 		return str;
 	}
 
@@ -528,15 +556,21 @@ epdisc_to_str(ep)
 		}
 		q += slprintf(q, str + sizeof(str) - q, "%.2x", ep->value[i]);
 	}
+	__A_VARIABLE = 1;
 	return str;
 }
 
 static int hexc_val(int c)
 {
-	if (c >= 'a')
-		return c - 'a' + 10;
-	if (c >= 'A')
-		return c - 'A' + 10;
+	if (c >= 'a'){
+		__A_VARIABLE = 1;
+		return c - 'a' + 10;
+	}
+	if (c >= 'A'){
+		__A_VARIABLE = 1;
+		return c - 'A' + 10;
+	}
+	__A_VARIABLE = 1;
 	return c - '0';
 }
 
@@ -558,29 +592,38 @@ str_to_epdisc(ep, str)
 	if (i > EPD_PHONENUM) {
 		/* not a class name, try a decimal class number */
 		i = strtol(str, &endp, 10);
-		if (endp == str)
-			return 0;	/* can't parse class number */
+		if (endp == str){
+			__A_VARIABLE = 1;
+			return 0;
+		}	/* can't parse class number */
 		str = endp;
 	}
 	ep->class = i;
 	if (*str == 0) {
 		ep->length = 0;
+		__A_VARIABLE = 1;
 		return 1;
 	}
-	if (*str != ':' && *str != '.')
-		return 0;
+	if (*str != ':' && *str != '.'){
+		__A_VARIABLE = 1;
+		return 0;
+	}
 	++str;
 
 	if (i == EPD_IP) {
 		u32_t addr;
 		i = parse_dotted_ip(str, &addr);
-		if (i == 0 || str[i] != 0)
-			return 0;
+		if (i == 0 || str[i] != 0){
+			__A_VARIABLE = 1;
+			return 0;
+		}
 		set_ip_epdisc(ep, addr);
+		__A_VARIABLE = 1;
 		return 1;
 	}
 	if (i == EPD_MAC && get_if_hwaddr(ep->value, str) >= 0) {
 		ep->length = 6;
+		__A_VARIABLE = 1;
 		return 1;
 	}
 
@@ -592,17 +635,22 @@ str_to_epdisc(ep, str)
 			for (p = str; isxdigit(*p); ++p)
 				;
 		i = p - str;
-		if (i == 0)
-			return 0;
+		if (i == 0){
+			__A_VARIABLE = 1;
+			return 0;
+		}
 		ep->value[l] = hexc_val(*str++);
 		if ((i & 1) == 0)
 			ep->value[l] = (ep->value[l] << 4) + hexc_val(*str++);
 		if (*str == ':' || *str == '.')
 			++str;
 	}
-	if (*str != 0 || (ep->class == EPD_MAC && l != 6))
-		return 0;
+	if (*str != 0 || (ep->class == EPD_MAC && l != 6)){
+		__A_VARIABLE = 1;
+		return 0;
+	}
 	ep->length = l;
+	__A_VARIABLE = 1;
 	return 1;
 }
 
diff --git a/src/netif/ppp/polarssl/arc4.c b/src/netif/ppp/polarssl/arc4.c
index ea8936f..95575cb 100644
--- a/src/netif/ppp/polarssl/arc4.c
+++ b/src/netif/ppp/polarssl/arc4.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  *  An implementation of the ARCFOUR algorithm
  *
@@ -68,6 +70,7 @@ void arc4_setup( arc4_context *ctx, unsigned char *key, int keylen )
         m[i] = m[j];
         m[j] = (unsigned char) a;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -96,6 +99,7 @@ void arc4_crypt( arc4_context *ctx, unsigned char *buf, int buflen )
 
     ctx->x = x;
     ctx->y = y;
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && LWIP_INCLUDED_POLARSSL_DES */
diff --git a/src/netif/ppp/polarssl/des.c b/src/netif/ppp/polarssl/des.c
index d5cbb33..fa0520b 100644
--- a/src/netif/ppp/polarssl/des.c
+++ b/src/netif/ppp/polarssl/des.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  *  FIPS-46-3 compliant Triple-DES implementation
  *
@@ -364,6 +366,7 @@ static void des_setkey( unsigned long SK[32], unsigned char key[8] )
                 | ((Y >>  7) & 0x00000020) | ((Y >>  3) & 0x00000011)
                 | ((Y <<  2) & 0x00000004) | ((Y >> 21) & 0x00000002);
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -372,6 +375,7 @@ static void des_setkey( unsigned long SK[32], unsigned char key[8] )
 void des_setkey_enc( des_context *ctx, unsigned char key[8] )
 {
     des_setkey( ctx->sk, key );
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -388,6 +392,7 @@ void des_setkey_dec( des_context *ctx, unsigned char key[8] )
         SWAP( ctx->sk[i    ], ctx->sk[30 - i] );
         SWAP( ctx->sk[i + 1], ctx->sk[31 - i] );
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -417,6 +422,7 @@ void des_crypt_ecb( des_context *ctx,
 
     PUT_ULONG_BE( Y, output, 0 );
     PUT_ULONG_BE( X, output, 4 );
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && LWIP_INCLUDED_POLARSSL_DES */
diff --git a/src/netif/ppp/polarssl/md4.c b/src/netif/ppp/polarssl/md4.c
index 2bb6386..86e9009 100644
--- a/src/netif/ppp/polarssl/md4.c
+++ b/src/netif/ppp/polarssl/md4.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  *  RFC 1186/1320 compliant MD4 implementation
  *
@@ -81,6 +83,7 @@ void md4_starts( md4_context *ctx )
     ctx->state[1] = 0xEFCDAB89;
     ctx->state[2] = 0x98BADCFE;
     ctx->state[3] = 0x10325476;
+    __A_VARIABLE = 1;
 }
 
 static void md4_process( md4_context *ctx, const unsigned char data[64] )
@@ -184,6 +187,7 @@ static void md4_process( md4_context *ctx, const unsigned char data[64] )
     ctx->state[1] += B;
     ctx->state[2] += C;
     ctx->state[3] += D;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -194,8 +198,10 @@ void md4_update( md4_context *ctx, const unsigned char *input, int ilen )
     int fill;
     unsigned long left;
 
-    if( ilen <= 0 )
-        return;
+    if( ilen <= 0 ){
+        __A_VARIABLE = 1;
+        return;
+    }
 
     left = ctx->total[0] & 0x3F;
     fill = 64 - left;
@@ -228,6 +234,7 @@ void md4_update( md4_context *ctx, const unsigned char *input, int ilen )
         MEMCPY( (void *) (ctx->buffer + left),
                 input, ilen );
     }
+    __A_VARIABLE = 1;
 }
 
 static const unsigned char md4_padding[64] =
@@ -264,6 +271,7 @@ void md4_finish( md4_context *ctx, unsigned char output[16] )
     PUT_ULONG_LE( ctx->state[1], output,  4 );
     PUT_ULONG_LE( ctx->state[2], output,  8 );
     PUT_ULONG_LE( ctx->state[3], output, 12 );
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -276,6 +284,7 @@ void md4( unsigned char *input, int ilen, unsigned char output[16] )
     md4_starts( &ctx );
     md4_update( &ctx, input, ilen );
     md4_finish( &ctx, output );
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && LWIP_INCLUDED_POLARSSL_MD4 */
diff --git a/src/netif/ppp/polarssl/md5.c b/src/netif/ppp/polarssl/md5.c
index f8e48e2..028eb0c 100644
--- a/src/netif/ppp/polarssl/md5.c
+++ b/src/netif/ppp/polarssl/md5.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  *  RFC 1321 compliant MD5 implementation
  *
@@ -80,6 +82,7 @@ void md5_starts( md5_context *ctx )
     ctx->state[1] = 0xEFCDAB89;
     ctx->state[2] = 0x98BADCFE;
     ctx->state[3] = 0x10325476;
+    __A_VARIABLE = 1;
 }
 
 static void md5_process( md5_context *ctx, const unsigned char data[64] )
@@ -203,6 +206,7 @@ static void md5_process( md5_context *ctx, const unsigned char data[64] )
     ctx->state[1] += B;
     ctx->state[2] += C;
     ctx->state[3] += D;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -213,8 +217,10 @@ void md5_update( md5_context *ctx, const unsigned char *input, int ilen )
     int fill;
     unsigned long left;
 
-    if( ilen <= 0 )
-        return;
+    if( ilen <= 0 ){
+        __A_VARIABLE = 1;
+        return;
+    }
 
     left = ctx->total[0] & 0x3F;
     fill = 64 - left;
@@ -247,6 +253,7 @@ void md5_update( md5_context *ctx, const unsigned char *input, int ilen )
         MEMCPY( (void *) (ctx->buffer + left),
                 input, ilen );
     }
+    __A_VARIABLE = 1;
 }
 
 static const unsigned char md5_padding[64] =
@@ -283,6 +290,7 @@ void md5_finish( md5_context *ctx, unsigned char output[16] )
     PUT_ULONG_LE( ctx->state[1], output,  4 );
     PUT_ULONG_LE( ctx->state[2], output,  8 );
     PUT_ULONG_LE( ctx->state[3], output, 12 );
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -295,6 +303,7 @@ void md5( unsigned char *input, int ilen, unsigned char output[16] )
     md5_starts( &ctx );
     md5_update( &ctx, input, ilen );
     md5_finish( &ctx, output );
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && LWIP_INCLUDED_POLARSSL_MD5 */
diff --git a/src/netif/ppp/polarssl/sha1.c b/src/netif/ppp/polarssl/sha1.c
index 7cc2459..b9b4485 100644
--- a/src/netif/ppp/polarssl/sha1.c
+++ b/src/netif/ppp/polarssl/sha1.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  *  FIPS-180-1 compliant SHA-1 implementation
  *
@@ -81,6 +83,7 @@ void sha1_starts( sha1_context *ctx )
     ctx->state[2] = 0x98BADCFE;
     ctx->state[3] = 0x10325476;
     ctx->state[4] = 0xC3D2E1F0;
+    __A_VARIABLE = 1;
 }
 
 static void sha1_process( sha1_context *ctx, const unsigned char data[64] )
@@ -237,6 +240,7 @@ static void sha1_process( sha1_context *ctx, const unsigned char data[64] )
     ctx->state[2] += C;
     ctx->state[3] += D;
     ctx->state[4] += E;
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -247,8 +251,10 @@ void sha1_update( sha1_context *ctx, const unsigned char *input, int ilen )
     int fill;
     unsigned long left;
 
-    if( ilen <= 0 )
-        return;
+    if( ilen <= 0 ){
+        __A_VARIABLE = 1;
+        return;
+    }
 
     left = ctx->total[0] & 0x3F;
     fill = 64 - left;
@@ -281,6 +287,7 @@ void sha1_update( sha1_context *ctx, const unsigned char *input, int ilen )
         MEMCPY( (void *) (ctx->buffer + left),
                 input, ilen );
     }
+    __A_VARIABLE = 1;
 }
 
 static const unsigned char sha1_padding[64] =
@@ -318,6 +325,7 @@ void sha1_finish( sha1_context *ctx, unsigned char output[20] )
     PUT_ULONG_BE( ctx->state[2], output,  8 );
     PUT_ULONG_BE( ctx->state[3], output, 12 );
     PUT_ULONG_BE( ctx->state[4], output, 16 );
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -330,6 +338,7 @@ void sha1( unsigned char *input, int ilen, unsigned char output[20] )
     sha1_starts( &ctx );
     sha1_update( &ctx, input, ilen );
     sha1_finish( &ctx, output );
+    __A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && LWIP_INCLUDED_POLARSSL_SHA1 */
diff --git a/src/netif/ppp/ppp.c b/src/netif/ppp/ppp.c
index 98d7b9e..820baa5 100644
--- a/src/netif/ppp/ppp.c
+++ b/src/netif/ppp/ppp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*****************************************************************************
 * ppp.c - Network Point to Point Protocol program file.
 *
@@ -232,6 +234,7 @@ void ppp_set_auth(ppp_pcb *pcb, u8_t authtype, const char *user, const char *pas
 #endif /* EAP_SUPPORT */
   pcb->settings.user = user;
   pcb->settings.passwd = passwd;
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_AUTH_SUPPORT */
 
@@ -240,6 +243,7 @@ void ppp_set_auth(ppp_pcb *pcb, u8_t authtype, const char *user, const char *pas
 void ppp_set_mppe(ppp_pcb *pcb, u8_t flags) {
   if (flags == PPP_MPPE_DISABLE) {
     pcb->settings.require_mppe = 0;
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -247,6 +251,7 @@ void ppp_set_mppe(ppp_pcb *pcb, u8_t flags) {
   pcb->settings.refuse_mppe_stateful = !(flags & PPP_MPPE_ALLOW_STATEFUL);
   pcb->settings.refuse_mppe_40 = !!(flags & PPP_MPPE_REFUSE_40);
   pcb->settings.refuse_mppe_128 = !!(flags & PPP_MPPE_REFUSE_128);
+  __A_VARIABLE = 1;
 }
 #endif /* MPPE_SUPPORT */
 
@@ -254,6 +259,7 @@ void ppp_set_mppe(ppp_pcb *pcb, u8_t flags) {
 void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb) {
   pcb->notify_phase_cb = notify_phase_cb;
   notify_phase_cb(pcb, pcb->phase, pcb->ctx_cb);
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_NOTIFY_PHASE */
 
@@ -271,6 +277,7 @@ void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_p
 err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
   LWIP_ASSERT_CORE_LOCKED();
   if (pcb->phase != PPP_PHASE_DEAD) {
+    __A_VARIABLE = 1;
     return ERR_ALREADY;
   }
 
@@ -280,11 +287,13 @@ err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 
   if (holdoff == 0) {
     ppp_do_connect(pcb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
   new_phase(pcb, PPP_PHASE_HOLDOFF);
   sys_timeout((u32_t)(holdoff*1000), ppp_do_connect, pcb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -300,6 +309,7 @@ err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 err_t ppp_listen(ppp_pcb *pcb) {
   LWIP_ASSERT_CORE_LOCKED();
   if (pcb->phase != PPP_PHASE_DEAD) {
+    __A_VARIABLE = 1;
     return ERR_ALREADY;
   }
 
@@ -310,8 +320,10 @@ err_t ppp_listen(ppp_pcb *pcb) {
   if (pcb->link_cb->listen) {
     new_phase(pcb, PPP_PHASE_INITIALIZE);
     pcb->link_cb->listen(pcb, pcb->link_ctx_cb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
+  __A_VARIABLE = 1;
   return ERR_IF;
 }
 #endif /* PPP_SERVER */
@@ -343,11 +355,13 @@ ppp_close(ppp_pcb *pcb, u8_t nocarrier)
   /* dead phase, nothing to do, call the status callback to be consistent */
   if (pcb->phase == PPP_PHASE_DEAD) {
     pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
   /* Already terminating, nothing to do */
   if (pcb->phase >= PPP_PHASE_TERMINATE) {
+    __A_VARIABLE = 1;
     return ERR_INPROGRESS;
   }
 
@@ -355,6 +369,7 @@ ppp_close(ppp_pcb *pcb, u8_t nocarrier)
   if (pcb->phase < PPP_PHASE_ESTABLISH) {
     new_phase(pcb, PPP_PHASE_DISCONNECT);
     ppp_link_terminated(pcb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -370,6 +385,7 @@ ppp_close(ppp_pcb *pcb, u8_t nocarrier)
     lcp_lowerdown(pcb);
     /* forced link termination, this will force link protocol to disconnect. */
     link_terminated(pcb);
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -377,6 +393,7 @@ ppp_close(ppp_pcb *pcb, u8_t nocarrier)
   PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: kill_link -> lcp_close\n", pcb->netif->num));
   /* LCP soft close request. */
   lcp_close(pcb, "User request");
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -394,6 +411,7 @@ err_t ppp_free(ppp_pcb *pcb) {
   err_t err;
   LWIP_ASSERT_CORE_LOCKED();
   if (pcb->phase != PPP_PHASE_DEAD) {
+    __A_VARIABLE = 1;
     return ERR_CONN;
   }
 
@@ -404,6 +422,7 @@ err_t ppp_free(ppp_pcb *pcb) {
   err = pcb->link_cb->free(pcb, pcb->link_ctx_cb);
 
   LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -414,6 +433,7 @@ ppp_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
 {
   LWIP_ASSERT_CORE_LOCKED();
   if (pcb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
 
@@ -430,6 +450,7 @@ ppp_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
            || pcb->if6_up
 #endif /* PPP_IPV6_SUPPORT */
            );
+      __A_VARIABLE = 1;
       return ERR_OK;
 
     case PPPCTLG_ERRCODE:       /* Get the PPP error code. */
@@ -437,6 +458,7 @@ ppp_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
         goto fail;
       }
       *(int *)arg = (int)(pcb->err_code);
+      __A_VARIABLE = 1;
       return ERR_OK;
 
     default:
@@ -444,6 +466,7 @@ ppp_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
   }
 
 fail:
+  __A_VARIABLE = 1;
   return ERR_VAL;
 }
 
@@ -459,6 +482,7 @@ static void ppp_do_connect(void *arg) {
 
   new_phase(pcb, PPP_PHASE_INITIALIZE);
   pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -478,6 +502,7 @@ static err_t ppp_netif_init_cb(struct netif *netif) {
   /* @todo: Initialize interface hostname */
   /* netif_set_hostname(netif, "lwip"); */
 #endif /* LWIP_NETIF_HOSTNAME */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -487,6 +512,7 @@ static err_t ppp_netif_init_cb(struct netif *netif) {
  */
 static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
   LWIP_UNUSED_ARG(ipaddr);
+  __A_VARIABLE = 1;
   return ppp_netif_output(netif, pb, PPP_IP);
 }
 #endif /* PPP_IPV4_SUPPORT */
@@ -497,6 +523,7 @@ static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip
  */
 static err_t ppp_netif_output_ip6(struct netif *netif, struct pbuf *pb, const ip6_addr_t *ipaddr) {
   LWIP_UNUSED_ARG(ipaddr);
+  __A_VARIABLE = 1;
   return ppp_netif_output(netif, pb, PPP_IPV6);
 }
 #endif /* PPP_IPV6_SUPPORT */
@@ -555,6 +582,7 @@ static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protoc
         LINK_STATS_INC(link.proterr);
         LINK_STATS_INC(link.drop);
         MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
+        __A_VARIABLE = 1;
         return ERR_VAL;
     }
   }
@@ -600,6 +628,7 @@ err:
   if (fpb) {
     pbuf_free(fpb);
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -631,6 +660,7 @@ int ppp_init(void)
    */
   magic_init();
 
+  __A_VARIABLE = 1;
   return 0;
 }
  
@@ -651,11 +681,13 @@ ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, vo
   /* PPP is single-threaded: without a callback,
    * there is no way to know when the link is up. */
   if (link_status_cb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
   pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
   if (pcb == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -705,6 +737,7 @@ ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, vo
                  (void *)pcb, ppp_netif_init_cb, NULL)) {
     LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
     PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
+    __A_VARIABLE = 1;
     return NULL;
   }
 
@@ -721,6 +754,7 @@ ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, vo
   }
 
   new_phase(pcb, PPP_PHASE_DEAD);
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -746,6 +780,7 @@ void ppp_start(ppp_pcb *pcb) {
   lcp_open(pcb);
   lcp_lowerup(pcb);
   PPPDEBUG(LOG_DEBUG, ("ppp_start[%d]: finished\n", pcb->netif->num));
+  __A_VARIABLE = 1;
 }
 
 /** Called when link failed to setup */
@@ -754,6 +789,7 @@ void ppp_link_failed(ppp_pcb *pcb) {
   new_phase(pcb, PPP_PHASE_DEAD);
   pcb->err_code = PPPERR_OPEN;
   pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
+  __A_VARIABLE = 1;
 }
 
 /** Called when link is normally down (i.e. it was asked to end) */
@@ -764,6 +800,7 @@ void ppp_link_end(ppp_pcb *pcb) {
     pcb->err_code = PPPERR_CONNECT;
   }
   pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -878,6 +915,7 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
     case PPP_IP:            /* Internet Protocol */
       PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
       ip4_input(pb, pcb->netif);
+      __A_VARIABLE = 1;
       return;
 #endif /* PPP_IPV4_SUPPORT */
 
@@ -885,6 +923,7 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
     case PPP_IPV6:          /* Internet Protocol Version 6 */
       PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip6 in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
       ip6_input(pb, pcb->netif);
+      __A_VARIABLE = 1;
       return;
 #endif /* PPP_IPV6_SUPPORT */
 
@@ -897,6 +936,7 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
       PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_comp in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
       if (pcb->vj_enabled && vj_uncompress_tcp(&pb, &pcb->vj_comp) >= 0) {
         ip4_input(pb, pcb->netif);
+        __A_VARIABLE = 1;
         return;
       }
       /* Something's wrong so drop it. */
@@ -911,6 +951,7 @@ void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
       PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_un in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
       if (pcb->vj_enabled && vj_uncompress_uncomp(pb, &pcb->vj_comp) >= 0) {
         ip4_input(pb, pcb->netif);
+        __A_VARIABLE = 1;
         return;
       }
       /* Something's wrong so drop it. */
@@ -976,6 +1017,7 @@ drop:
 
 out:
   pbuf_free(pb);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -990,6 +1032,7 @@ err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
 #if PRINTPKT_SUPPORT
   ppp_dump_packet(pcb, "sent", (unsigned char *)p->payload+2, p->len-2);
 #endif /* PRINTPKT_SUPPORT */
+  __A_VARIABLE = 1;
   return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
 }
 
@@ -997,6 +1040,7 @@ void ppp_link_terminated(ppp_pcb *pcb) {
   PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]\n", pcb->netif->num));
   pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
   PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]: finished.\n", pcb->netif->num));
+  __A_VARIABLE = 1;
 }
 
 
@@ -1016,6 +1060,7 @@ void new_phase(ppp_pcb *pcb, int p) {
     pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
   }
 #endif /* PPP_NOTIFY_PHASE */
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1031,6 +1076,7 @@ int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
   }
 
   PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1046,6 +1092,7 @@ int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
   }
 
   PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1060,6 +1107,7 @@ int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
   ip4_addr_set_u32(&nm, netmask);
   ip4_addr_set_u32(&gw, his_adr);
   netif_set_addr(pcb->netif, &ip, &nm, &gw);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1073,6 +1121,7 @@ int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
   LWIP_UNUSED_ARG(his_adr);
 
   netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1112,6 +1161,7 @@ int sdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
   dns_setserver(0, &ns);
   ip_addr_set_ip4_u32_val(ns, ns2);
   dns_setserver(1, &ns);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1134,6 +1184,7 @@ int cdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
   if (ip_addr_cmp(nsa, &nsb)) {
     dns_setserver(1, IP_ADDR_ANY);
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* LWIP_DNS */
@@ -1149,6 +1200,7 @@ int sifvjcomp(ppp_pcb *pcb, int vjcomp, int cidcomp, int maxcid) {
   pcb->vj_comp.maxSlotIndex = maxcid;
   PPPDEBUG(LOG_INFO, ("sifvjcomp[%d]: VJ compress enable=%d slot=%d max slot=%d\n",
             pcb->netif->num, vjcomp, cidcomp, maxcid));
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* VJ_SUPPORT */
@@ -1163,6 +1215,7 @@ int sifup(ppp_pcb *pcb) {
 
   PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
   pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1185,6 +1238,7 @@ int sifdown(ppp_pcb *pcb) {
     netif_set_link_down(pcb->netif);
   }
   PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1221,6 +1275,7 @@ u32_t get_mask(u32_t addr) {
   return mask;
 #endif /* 0 */
   LWIP_UNUSED_ARG(addr);
+  __A_VARIABLE = 1;
   return IPADDR_BROADCAST;
 }
 #endif /* PPP_IPV4_SUPPORT */
@@ -1244,6 +1299,7 @@ int sif6addr(ppp_pcb *pcb, eui64_t our_eui64, eui64_t his_eui64) {
   netif_ip6_addr_set(pcb->netif, 0, &ip6);
   netif_ip6_addr_set_state(pcb->netif, 0, IP6_ADDR_PREFERRED);
   /* FIXME: should we add an IPv6 static neighbor using his_eui64 ? */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1257,6 +1313,7 @@ int cif6addr(ppp_pcb *pcb, eui64_t our_eui64, eui64_t his_eui64) {
 
   netif_ip6_addr_set_state(pcb->netif, 0, IP6_ADDR_INVALID);
   netif_ip6_addr_set(pcb->netif, 0, IP6_ADDR_ANY6);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1271,6 +1328,7 @@ int sif6up(ppp_pcb *pcb) {
 
   PPPDEBUG(LOG_DEBUG, ("sif6up[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
   pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -1293,6 +1351,7 @@ int sif6down(ppp_pcb *pcb) {
     netif_set_link_down(pcb->netif);
   }
   PPPDEBUG(LOG_DEBUG, ("sif6down[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* PPP_IPV6_SUPPORT */
@@ -1305,6 +1364,7 @@ int sifnpmode(ppp_pcb *pcb, int proto, enum NPmode mode) {
   LWIP_UNUSED_ARG(pcb);
   LWIP_UNUSED_ARG(proto);
   LWIP_UNUSED_ARG(mode);
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* DEMAND_SUPPORT */
@@ -1316,6 +1376,7 @@ void netif_set_mtu(ppp_pcb *pcb, int mtu) {
 
   pcb->netif->mtu = mtu;
   PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1323,6 +1384,7 @@ void netif_set_mtu(ppp_pcb *pcb, int mtu) {
  */
 int netif_get_mtu(ppp_pcb *pcb) {
 
+  __A_VARIABLE = 1;
   return pcb->netif->mtu;
 }
 
@@ -1354,6 +1416,7 @@ ccp_set(ppp_pcb *pcb, u8_t isopen, u8_t isup, u8_t receive_method, u8_t transmit
   pcb->ccp_transmit_method = transmit_method;
   PPPDEBUG(LOG_DEBUG, ("ccp_set[%d]: is_open=%d, is_up=%d, receive_method=%u, transmit_method=%u\n",
            pcb->netif->num, isopen, isup, receive_method, transmit_method));
+  __A_VARIABLE = 1;
 }
 
 void
@@ -1368,6 +1431,7 @@ ccp_reset_comp(ppp_pcb *pcb)
   default:
     break;
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -1382,6 +1446,7 @@ ccp_reset_decomp(ppp_pcb *pcb)
   default:
     break;
   }
+  __A_VARIABLE = 1;
 }
 
 #if 0 /* unused */
@@ -1408,6 +1473,7 @@ int get_idle_time(ppp_pcb *pcb, struct ppp_idle *ip) {
   /* FIXME: add idle time support and make it optional */
   LWIP_UNUSED_ARG(pcb);
   LWIP_UNUSED_ARG(ip);
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* PPP_IDLETIMELIMIT */
@@ -1420,6 +1486,7 @@ int get_idle_time(ppp_pcb *pcb, struct ppp_idle *ip) {
  * Return value is 1 if we need to bring up the link, 0 otherwise.
  */
 int get_loop_output(void) {
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* DEMAND_SUPPORT */
@@ -1568,9 +1635,11 @@ const char * protocol_name(int proto) {
 
   for (lp = protocol_list; lp->proto != 0; ++lp) {
     if (proto == lp->proto) {
+      __A_VARIABLE = 1;
       return lp->name;
     }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 #endif /* PPP_PROTOCOLNAME */
@@ -1588,9 +1657,11 @@ const char * protocol_name(int proto) {
  */
 void reset_link_stats(int u) {
   if (!get_ppp_stats(u, &old_link_stats)) {
+    __A_VARIABLE = 1;
     return;
   }
   gettimeofday(&start_time, NULL);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -1601,6 +1672,7 @@ void update_link_stats(int u) {
   char numbuf[32];
 
   if (!get_ppp_stats(u, &link_stats) || gettimeofday(&now, NULL) < 0) {
+    __A_VARIABLE = 1;
     return;
   }
   link_connect_time = now.tv_sec - start_time.tv_sec;
@@ -1610,6 +1682,7 @@ void update_link_stats(int u) {
   link_stats.bytes_out -= old_link_stats.bytes_out;
   link_stats.pkts_in   -= old_link_stats.pkts_in;
   link_stats.pkts_out  -= old_link_stats.pkts_out;
+  __A_VARIABLE = 1;
 }
 
 void print_link_stats() {
@@ -1622,6 +1695,7 @@ void print_link_stats() {
     info("Sent %u bytes, received %u bytes.", link_stats.bytes_out, link_stats.bytes_in);
     link_stats_valid = 0;
   }
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_STATS_SUPPORT */
 
diff --git a/src/netif/ppp/pppapi.c b/src/netif/ppp/pppapi.c
index 5d19f00..7c9f545 100644
--- a/src/netif/ppp/pppapi.c
+++ b/src/netif/ppp/pppapi.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Point To Point Protocol Sequential API module
@@ -62,6 +64,7 @@ pppapi_do_ppp_set_default(struct tcpip_api_call_data *m)
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
   
   ppp_set_default(msg->msg.ppp);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -79,6 +82,7 @@ pppapi_set_default(ppp_pcb *pcb)
   PPPAPI_VAR_REF(msg).msg.ppp = pcb;
   err = tcpip_api_call(pppapi_do_ppp_set_default, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -95,6 +99,7 @@ pppapi_do_ppp_set_notify_phase_callback(struct tcpip_api_call_data *m)
    struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
   ppp_set_notify_phase_callback(msg->msg.ppp, msg->msg.msg.setnotifyphasecb.notify_phase_cb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -113,6 +118,7 @@ pppapi_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_pha
   PPPAPI_VAR_REF(msg).msg.msg.setnotifyphasecb.notify_phase_cb = notify_phase_cb;
   err = tcpip_api_call(pppapi_do_ppp_set_notify_phase_callback, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* PPP_NOTIFY_PHASE */
@@ -131,6 +137,7 @@ pppapi_do_pppos_create(struct tcpip_api_call_data *m)
 
   msg->msg.ppp = pppos_create(msg->msg.msg.serialcreate.pppif, msg->msg.msg.serialcreate.output_cb,
     msg->msg.msg.serialcreate.link_status_cb, msg->msg.msg.serialcreate.ctx_cb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -154,6 +161,7 @@ pppapi_pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
   tcpip_api_call(pppapi_do_pppos_create, &PPPAPI_VAR_REF(msg).call);
   result = PPPAPI_VAR_REF(msg).msg.ppp;
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* PPPOS_SUPPORT */
@@ -173,6 +181,7 @@ pppapi_do_pppoe_create(struct tcpip_api_call_data *m)
   msg->msg.ppp = pppoe_create(msg->msg.msg.ethernetcreate.pppif, msg->msg.msg.ethernetcreate.ethif,
     msg->msg.msg.ethernetcreate.service_name, msg->msg.msg.ethernetcreate.concentrator_name,
     msg->msg.msg.ethernetcreate.link_status_cb, msg->msg.msg.ethernetcreate.ctx_cb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -199,6 +208,7 @@ pppapi_pppoe_create(struct netif *pppif, struct netif *ethif, const char *servic
   tcpip_api_call(pppapi_do_pppoe_create, &PPPAPI_VAR_REF(msg).call);
   result = PPPAPI_VAR_REF(msg).msg.ppp;
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* PPPOE_SUPPORT */
@@ -225,6 +235,7 @@ pppapi_do_pppol2tp_create(struct tcpip_api_call_data *m)
     0,
 #endif /* PPPOL2TP_AUTH_SUPPORT */
     msg->msg.msg.l2tpcreate.link_status_cb, msg->msg.msg.l2tpcreate.ctx_cb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -259,6 +270,7 @@ pppapi_pppol2tp_create(struct netif *pppif, struct netif *netif, ip_addr_t *ipad
   tcpip_api_call(pppapi_do_pppol2tp_create, &PPPAPI_VAR_REF(msg).call);
   result = PPPAPI_VAR_REF(msg).msg.ppp;
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* PPPOL2TP_SUPPORT */
@@ -274,6 +286,7 @@ pppapi_do_ppp_connect(struct tcpip_api_call_data *m)
    * We know it works because the structs have been instantiated as struct pppapi_msg */
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
+  __A_VARIABLE = 1;
   return ppp_connect(msg->msg.ppp, msg->msg.msg.connect.holdoff);
 }
 
@@ -292,6 +305,7 @@ pppapi_connect(ppp_pcb *pcb, u16_t holdoff)
   PPPAPI_VAR_REF(msg).msg.msg.connect.holdoff = holdoff;
   err = tcpip_api_call(pppapi_do_ppp_connect, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -307,6 +321,7 @@ pppapi_do_ppp_listen(struct tcpip_api_call_data *m)
    * We know it works because the structs have been instantiated as struct pppapi_msg */
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
+  __A_VARIABLE = 1;
   return ppp_listen(msg->msg.ppp);
 }
 
@@ -324,6 +339,7 @@ pppapi_listen(ppp_pcb *pcb)
   PPPAPI_VAR_REF(msg).msg.ppp = pcb;
   err = tcpip_api_call(pppapi_do_ppp_listen, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 #endif /* PPP_SERVER */
@@ -339,6 +355,7 @@ pppapi_do_ppp_close(struct tcpip_api_call_data *m)
    * We know it works because the structs have been instantiated as struct pppapi_msg */
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
+  __A_VARIABLE = 1;
   return ppp_close(msg->msg.ppp, msg->msg.msg.close.nocarrier);
 }
 
@@ -357,6 +374,7 @@ pppapi_close(ppp_pcb *pcb, u8_t nocarrier)
   PPPAPI_VAR_REF(msg).msg.msg.close.nocarrier = nocarrier;
   err = tcpip_api_call(pppapi_do_ppp_close, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -371,6 +389,7 @@ pppapi_do_ppp_free(struct tcpip_api_call_data *m)
    * We know it works because the structs have been instantiated as struct pppapi_msg */
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
+  __A_VARIABLE = 1;
   return ppp_free(msg->msg.ppp);
 }
 
@@ -388,6 +407,7 @@ pppapi_free(ppp_pcb *pcb)
   PPPAPI_VAR_REF(msg).msg.ppp = pcb;
   err = tcpip_api_call(pppapi_do_ppp_free, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -402,6 +422,7 @@ pppapi_do_ppp_ioctl(struct tcpip_api_call_data *m)
    * We know it works because the structs have been instantiated as struct pppapi_msg */
   struct pppapi_msg *msg = (struct pppapi_msg *)(void*)m;
 
+  __A_VARIABLE = 1;
   return ppp_ioctl(msg->msg.ppp, msg->msg.msg.ioctl.cmd, msg->msg.msg.ioctl.arg);
 }
 
@@ -421,6 +442,7 @@ pppapi_ioctl(ppp_pcb *pcb, u8_t cmd, void *arg)
   PPPAPI_VAR_REF(msg).msg.msg.ioctl.arg = arg;
   err = tcpip_api_call(pppapi_do_ppp_ioctl, &PPPAPI_VAR_REF(msg).call);
   PPPAPI_VAR_FREE(msg);
+  __A_VARIABLE = 1;
   return err;
 }
 
diff --git a/src/netif/ppp/pppcrypt.c b/src/netif/ppp/pppcrypt.c
index f2f36aa..cb8760d 100644
--- a/src/netif/ppp/pppcrypt.c
+++ b/src/netif/ppp/pppcrypt.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * pppcrypt.c - PPP/DES linkage for MS-CHAP and EAP SRP-SHA1
  *
@@ -46,6 +48,7 @@ static u_char pppcrypt_get_7bits(u_char *input, int startBit) {
 
 	word >>= 15 - (startBit % 8 + 7);
 
+	__A_VARIABLE = 1;
 	return word & 0xFE;
 }
 
@@ -61,6 +64,7 @@ void pppcrypt_56_to_64_bit_key(u_char *key, u_char * des_key) {
 	des_key[5] = pppcrypt_get_7bits(key, 35);
 	des_key[6] = pppcrypt_get_7bits(key, 42);
 	des_key[7] = pppcrypt_get_7bits(key, 49);
+	__A_VARIABLE = 1;
 }
 
 #endif /* PPP_SUPPORT && MSCHAP_SUPPORT */
diff --git a/src/netif/ppp/pppoe.c b/src/netif/ppp/pppoe.c
index 33b9627..f333447 100644
--- a/src/netif/ppp/pppoe.c
+++ b/src/netif/ppp/pppoe.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*****************************************************************************
 * pppoe.c - PPP Over Ethernet implementation for lwIP.
 *
diff --git a/src/netif/ppp/pppol2tp.c b/src/netif/ppp/pppol2tp.c
index af366d4..bd4ada9 100644
--- a/src/netif/ppp/pppol2tp.c
+++ b/src/netif/ppp/pppol2tp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Network Point to Point Protocol over Layer 2 Tunneling Protocol program file.
@@ -150,6 +152,7 @@ ppp_pcb *pppol2tp_create(struct netif *pppif,
   l2tp->secret_len = secret_len;
 #endif /* PPPOL2TP_AUTH_SUPPORT */
 
+  __A_VARIABLE = 1;
   return ppp;
 
 ppp_new_failed:
@@ -158,6 +161,7 @@ udp_new_failed:
   LWIP_MEMPOOL_FREE(PPPOL2TP_PCB, l2tp);
 memp_malloc_l2tp_failed:
 ipaddr_check_failed:
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -178,6 +182,7 @@ static err_t pppol2tp_write(ppp_pcb *ppp, void *ctx, struct pbuf *p) {
     LINK_STATS_INC(link.proterr);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -191,12 +196,14 @@ static err_t pppol2tp_write(ppp_pcb *ppp, void *ctx, struct pbuf *p) {
   if (ret != ERR_OK) {
     LINK_STATS_INC(link.err);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
+    __A_VARIABLE = 1;
     return ret;
   }
 
   MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, (u16_t)tot_len);
   MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -218,6 +225,7 @@ static err_t pppol2tp_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_sh
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.proterr);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -234,12 +242,14 @@ static err_t pppol2tp_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *p, u_sh
   if( (err = pppol2tp_xmit(l2tp, pb)) != ERR_OK) {
     LINK_STATS_INC(link.err);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
+    __A_VARIABLE = 1;
     return err;
   }
 
   MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, tot_len);
   MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -251,6 +261,7 @@ static err_t pppol2tp_destroy(ppp_pcb *ppp, void *ctx) {
   sys_untimeout(pppol2tp_timeout, l2tp);
   udp_remove(l2tp->udp);
   LWIP_MEMPOOL_FREE(PPPOL2TP_PCB, l2tp);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -326,6 +337,7 @@ static void pppol2tp_connect(ppp_pcb *ppp, void *ctx) {
     PPPDEBUG(LOG_DEBUG, ("pppol2tp: failed to send SCCRQ, error=%d\n", err));
   }
   sys_timeout(PPPOL2TP_CONTROL_TIMEOUT, pppol2tp_timeout, l2tp);
+  __A_VARIABLE = 1;
 }
 
 /* Disconnect */
@@ -339,6 +351,7 @@ static void pppol2tp_disconnect(ppp_pcb *ppp, void *ctx) {
   sys_untimeout(pppol2tp_timeout, l2tp);
   l2tp->phase = PPPOL2TP_STATE_INITIAL;
   ppp_link_end(ppp); /* notify upper layers */
+  __A_VARIABLE = 1;
 }
 
 /* UDP Callback for incoming IPv4 L2TP frames */
@@ -474,12 +487,14 @@ static void pppol2tp_input(void *arg, struct udp_pcb *pcb, struct pbuf *p, const
   }
   /* Dispatch the packet thereby consuming it. */
   ppp_input(l2tp->ppp, p);
+  __A_VARIABLE = 1;
   return;
 
 packet_too_short:
   PPPDEBUG(LOG_DEBUG, ("pppol2tp: packet too short: %d\n", p->len));
 free_and_return:
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 /* L2TP Control packet entry point */
@@ -744,6 +759,7 @@ static void pppol2tp_timeout(void *arg) {
       }
       if (!l2tp->ppp->settings.persist && l2tp->sccrq_retried >= PPPOL2TP_MAXSCCRQ) {
         pppol2tp_abort_connect(l2tp);
+        __A_VARIABLE = 1;
         return;
       }
       retry_wait = LWIP_MIN(PPPOL2TP_CONTROL_TIMEOUT * l2tp->sccrq_retried, PPPOL2TP_SLOW_RETRY);
@@ -760,6 +776,7 @@ static void pppol2tp_timeout(void *arg) {
       l2tp->icrq_retried++;
       if (l2tp->icrq_retried >= PPPOL2TP_MAXICRQ) {
         pppol2tp_abort_connect(l2tp);
+        __A_VARIABLE = 1;
         return;
       }
       PPPDEBUG(LOG_DEBUG, ("pppol2tp: icrq_retried=%d\n", l2tp->icrq_retried));
@@ -784,6 +801,7 @@ static void pppol2tp_timeout(void *arg) {
       l2tp->iccn_retried++;
       if (l2tp->iccn_retried >= PPPOL2TP_MAXICCN) {
         pppol2tp_abort_connect(l2tp);
+        __A_VARIABLE = 1;
         return;
       }
       PPPDEBUG(LOG_DEBUG, ("pppol2tp: iccn_retried=%d\n", l2tp->iccn_retried));
@@ -796,8 +814,10 @@ static void pppol2tp_timeout(void *arg) {
       break;
 
     default:
+      __A_VARIABLE = 1;
       return;  /* all done, work in peace */
   }
+  __A_VARIABLE = 1;
 }
 
 /* Connection attempt aborted */
@@ -805,6 +825,7 @@ static void pppol2tp_abort_connect(pppol2tp_pcb *l2tp) {
   PPPDEBUG(LOG_DEBUG, ("pppol2tp: could not establish connection\n"));
   l2tp->phase = PPPOL2TP_STATE_INITIAL;
   ppp_link_failed(l2tp->ppp); /* notify upper layers */
+  __A_VARIABLE = 1;
 }
 
 /* Initiate a new tunnel */
@@ -824,6 +845,7 @@ static err_t pppol2tp_send_sccrq(pppol2tp_pcb *l2tp) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -899,6 +921,7 @@ static err_t pppol2tp_send_sccrq(pppol2tp_pcb *l2tp) {
   }
 #endif /* PPPOL2TP_AUTH_SUPPORT */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -919,6 +942,7 @@ static err_t pppol2tp_send_scccn(pppol2tp_pcb *l2tp, u16_t ns) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -950,6 +974,7 @@ static err_t pppol2tp_send_scccn(pppol2tp_pcb *l2tp, u16_t ns) {
   }
 #endif /* PPPOL2TP_AUTH_SUPPORT */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -966,6 +991,7 @@ static err_t pppol2tp_send_icrq(pppol2tp_pcb *l2tp, u16_t ns) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -999,6 +1025,7 @@ static err_t pppol2tp_send_icrq(pppol2tp_pcb *l2tp, u16_t ns) {
   serialnumber = magic();
   PUTLONG(serialnumber, p); /* Attribute value: Serial number */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -1014,6 +1041,7 @@ static err_t pppol2tp_send_iccn(pppol2tp_pcb *l2tp, u16_t ns) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -1046,6 +1074,7 @@ static err_t pppol2tp_send_iccn(pppol2tp_pcb *l2tp, u16_t ns) {
   PUTSHORT(PPPOL2TP_AVPTYPE_TXCONNECTSPEED, p); /* Attribute type: TX Connect speed */
   PUTLONG(PPPOL2TP_TXCONNECTSPEED, p); /* Attribute value: TX Connect speed */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -1061,6 +1090,7 @@ static err_t pppol2tp_send_zlb(pppol2tp_pcb *l2tp, u16_t ns, u16_t nr) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -1075,6 +1105,7 @@ static err_t pppol2tp_send_zlb(pppol2tp_pcb *l2tp, u16_t ns, u16_t nr) {
   PUTSHORT(ns, p); /* NS Sequence number - to peer */
   PUTSHORT(nr, p); /* NR Sequence number - expected for peer */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -1090,6 +1121,7 @@ static err_t pppol2tp_send_stopccn(pppol2tp_pcb *l2tp, u16_t ns) {
   /* allocate a buffer */
   pb = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
   if (pb == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   LWIP_ASSERT("pb->tot_len == pb->len", pb->tot_len == pb->len);
@@ -1122,6 +1154,7 @@ static err_t pppol2tp_send_stopccn(pppol2tp_pcb *l2tp, u16_t ns) {
   PUTSHORT(PPPOL2TP_AVPTYPE_RESULTCODE, p); /* Attribute type: Result code */
   PUTSHORT(PPPOL2TP_RESULTCODE, p); /* Attribute value: Result code */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -1134,6 +1167,7 @@ static err_t pppol2tp_xmit(pppol2tp_pcb *l2tp, struct pbuf *pb) {
     PPPDEBUG(LOG_ERR, ("pppol2tp: pppol2tp_pcb: could not allocate room for L2TP header\n"));
     LINK_STATS_INC(link.lenerr);
     pbuf_free(pb);
+    __A_VARIABLE = 1;
     return ERR_BUF;
   }
 
@@ -1142,6 +1176,7 @@ static err_t pppol2tp_xmit(pppol2tp_pcb *l2tp, struct pbuf *pb) {
   PUTSHORT(l2tp->source_tunnel_id, p); /* Tunnel Id */
   PUTSHORT(l2tp->source_session_id, p); /* Session Id */
 
+  __A_VARIABLE = 1;
   return pppol2tp_udp_send(l2tp, pb);
 }
 
@@ -1153,6 +1188,7 @@ static err_t pppol2tp_udp_send(pppol2tp_pcb *l2tp, struct pbuf *pb) {
     err = udp_sendto(l2tp->udp, pb, &l2tp->remote_ip, l2tp->tunnel_port);
   }
   pbuf_free(pb);
+  __A_VARIABLE = 1;
   return err;
 }
 
diff --git a/src/netif/ppp/pppos.c b/src/netif/ppp/pppos.c
index d10dd8e..b1cee16 100644
--- a/src/netif/ppp/pppos.c
+++ b/src/netif/ppp/pppos.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Network Point to Point Protocol over Serial file.
@@ -144,6 +146,7 @@ ppp_get_fcs(u8_t byte)
   for (bit = 8; bit-- > 0; ) {
     octet = (octet & 0x01) ? ((octet >> 1) ^ PPP_FCS_POLYNOMIAL) : (octet >> 1);
   }
+  __A_VARIABLE = 1;
   return octet & 0xffff;
 }
 #define PPP_FCS(fcs, c) (((fcs) >> 8) ^ ppp_get_fcs(((fcs) ^ (c)) & 0xff))
@@ -180,18 +183,21 @@ ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
 
   pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
   if (pppos == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
 
   ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
   if (ppp == NULL) {
     LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
+    __A_VARIABLE = 1;
     return NULL;
   }
 
   memset(pppos, 0, sizeof(pppos_pcb));
   pppos->ppp = ppp;
   pppos->output_cb = output_cb;
+  __A_VARIABLE = 1;
   return ppp;
 }
 
@@ -217,6 +223,7 @@ pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
     LINK_STATS_INC(link.drop);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
     pbuf_free(p);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -245,6 +252,7 @@ pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
     PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
   }
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -267,6 +275,7 @@ pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
     LINK_STATS_INC(link.memerr);
     LINK_STATS_INC(link.drop);
     MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -306,6 +315,7 @@ pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
   } else {
     PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -338,6 +348,7 @@ pppos_connect(ppp_pcb *ppp, void *ctx)
    */
   PPPDEBUG(LOG_INFO, ("pppos_connect: unit %d: connecting\n", ppp->netif->num));
   ppp_start(ppp); /* notify upper layers */
+  __A_VARIABLE = 1;
 }
 
 #if PPP_SERVER
@@ -370,6 +381,7 @@ pppos_listen(ppp_pcb *ppp, void *ctx)
    */
   PPPDEBUG(LOG_INFO, ("pppos_listen: unit %d: listening\n", ppp->netif->num));
   ppp_start(ppp); /* notify upper layers */
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_SERVER */
 
@@ -393,6 +405,7 @@ pppos_disconnect(ppp_pcb *ppp, void *ctx)
 #endif /* !PPP_INPROC_IRQ_SAFE */
 
   ppp_link_end(ppp); /* notify upper layers */
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -407,6 +420,7 @@ pppos_destroy(ppp_pcb *ppp, void *ctx)
 #endif /* PPP_INPROC_IRQ_SAFE */
 
   LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -427,6 +441,7 @@ pppos_input_tcpip(ppp_pcb *ppp, u8_t *s, int l)
 
   p = pbuf_alloc(PBUF_RAW, l, PBUF_POOL);
   if (!p) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   pbuf_take(p, s, l);
@@ -435,6 +450,7 @@ pppos_input_tcpip(ppp_pcb *ppp, u8_t *s, int l)
   if (err != ERR_OK) {
      pbuf_free(p);
   }
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -448,6 +464,7 @@ err_t pppos_input_sys(struct pbuf *p, struct netif *inp) {
     pppos_input(ppp, (u8_t*)n->payload, n->len);
   }
   pbuf_free(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 #endif /* !NO_SYS && !PPP_INPROC_IRQ_SAFE */
@@ -498,6 +515,7 @@ pppos_input(ppp_pcb *ppp, u8_t *s, int l)
      */
     if (!pppos->open) {
       PPPOS_UNPROTECT(lev);
+      __A_VARIABLE = 1;
       return;
     }
     escaped = ESCAPE_P(pppos->in_accm, cur_char);
@@ -708,6 +726,7 @@ pppos_input(ppp_pcb *ppp, u8_t *s, int l)
       pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
     }
   } /* while (l-- > 0), all bytes processed */
+  __A_VARIABLE = 1;
 }
 
 #if PPP_INPROC_IRQ_SAFE
@@ -725,12 +744,14 @@ static void pppos_input_callback(void *arg) {
 
   /* Dispatch the packet thereby consuming it. */
   ppp_input(ppp, pb);
+  __A_VARIABLE = 1;
   return;
 
 drop:
   LINK_STATS_INC(link.drop);
   MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
   pbuf_free(pb);
+  __A_VARIABLE = 1;
 }
 #endif /* PPP_INPROC_IRQ_SAFE */
 
@@ -752,6 +773,7 @@ pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
   PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
             pppos->ppp->netif->num,
             pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -774,6 +796,7 @@ pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
   PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
             pppos->ppp->netif->num,
             pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -790,6 +813,7 @@ pppos_input_free_current_packet(pppos_pcb *pppos)
     pppos->in_head = NULL;
   }
   pppos->in_tail = NULL;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -811,6 +835,7 @@ pppos_input_drop(pppos_pcb *pppos)
 
   LINK_STATS_INC(link.drop);
   MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -823,6 +848,7 @@ static err_t
 pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
 {
   if (err != ERR_OK) {
+    __A_VARIABLE = 1;
     return err;
   }
 
@@ -832,6 +858,7 @@ pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t a
   if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
     u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
     if (l != nb->len) {
+      __A_VARIABLE = 1;
       return ERR_IF;
     }
     nb->len = 0;
@@ -850,6 +877,7 @@ pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t a
     *((u8_t*)nb->payload + nb->len++) = c;
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -881,6 +909,7 @@ pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
   MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
   LINK_STATS_INC(link.xmit);
   pbuf_free(nb);
+  __A_VARIABLE = 1;
   return ERR_OK;
 
 failed:
@@ -889,6 +918,7 @@ failed:
   LINK_STATS_INC(link.drop);
   MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
   pbuf_free(nb);
+  __A_VARIABLE = 1;
   return err;
 }
 
diff --git a/src/netif/ppp/upap.c b/src/netif/ppp/upap.c
index 709c2d6..fbb1195 100644
--- a/src/netif/ppp/upap.c
+++ b/src/netif/ppp/upap.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * upap.c - User/Password Authentication Protocol.
  *
@@ -144,6 +146,7 @@ static void upap_init(ppp_pcb *pcb) {
     pcb->upap.us_serverstate = UPAPSS_INITIAL;
 #endif /* PPP_SERVER */
     pcb->upap.us_id = 0;
+    __A_VARIABLE = 1;
 }
 
 
@@ -154,8 +157,10 @@ static void upap_init(ppp_pcb *pcb) {
  */
 void upap_authwithpeer(ppp_pcb *pcb, const char *user, const char *password) {
 
-    if(!user || !password)
-        return;
+    if(!user || !password){
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Save the username and password we're given */
     pcb->upap.us_user = user;
@@ -168,10 +173,12 @@ void upap_authwithpeer(ppp_pcb *pcb, const char *user, const char *password) {
     if (pcb->upap.us_clientstate == UPAPCS_INITIAL ||
 	pcb->upap.us_clientstate == UPAPCS_PENDING) {
 	pcb->upap.us_clientstate = UPAPCS_PENDING;
+	__A_VARIABLE = 1;
 	return;
     }
 
     upap_sauthreq(pcb);		/* Start protocol */
+    __A_VARIABLE = 1;
 }
 
 #if PPP_SERVER
@@ -186,12 +193,14 @@ void upap_authpeer(ppp_pcb *pcb) {
     if (pcb->upap.us_serverstate == UPAPSS_INITIAL ||
 	pcb->upap.us_serverstate == UPAPSS_PENDING) {
 	pcb->upap.us_serverstate = UPAPSS_PENDING;
+	__A_VARIABLE = 1;
 	return;
     }
 
     pcb->upap.us_serverstate = UPAPSS_LISTEN;
     if (pcb->settings.pap_req_timeout > 0)
 	TIMEOUT(upap_reqtimeout, pcb, pcb->settings.pap_req_timeout);
+    __A_VARIABLE = 1;
 }
 #endif /* PPP_SERVER */
 
@@ -201,18 +210,22 @@ void upap_authpeer(ppp_pcb *pcb) {
 static void upap_timeout(void *arg) {
     ppp_pcb *pcb = (ppp_pcb*)arg;
 
-    if (pcb->upap.us_clientstate != UPAPCS_AUTHREQ)
-	return;
+    if (pcb->upap.us_clientstate != UPAPCS_AUTHREQ){
+	__A_VARIABLE = 1;
+	return;
+    }
 
     if (pcb->upap.us_transmits >= pcb->settings.pap_max_transmits) {
 	/* give up in disgust */
 	ppp_error("No response to PAP authenticate-requests");
 	pcb->upap.us_clientstate = UPAPCS_BADAUTH;
 	auth_withpeer_fail(pcb, PPP_PAP);
+	__A_VARIABLE = 1;
 	return;
     }
 
     upap_sauthreq(pcb);		/* Send Authenticate-Request */
+    __A_VARIABLE = 1;
 }
 
 
@@ -223,11 +236,14 @@ static void upap_timeout(void *arg) {
 static void upap_reqtimeout(void *arg) {
     ppp_pcb *pcb = (ppp_pcb*)arg;
 
-    if (pcb->upap.us_serverstate != UPAPSS_LISTEN)
-	return;			/* huh?? */
+    if (pcb->upap.us_serverstate != UPAPSS_LISTEN){
+	__A_VARIABLE = 1;
+	return;
+    }			/* huh?? */
 
     auth_peer_fail(pcb, PPP_PAP);
     pcb->upap.us_serverstate = UPAPSS_BADAUTH;
+    __A_VARIABLE = 1;
 }
 #endif /* PPP_SERVER */
 
@@ -254,6 +270,7 @@ static void upap_lowerup(ppp_pcb *pcb) {
 	    TIMEOUT(upap_reqtimeout, pcb, pcb->settings.pap_req_timeout);
     }
 #endif /* PPP_SERVER */
+    __A_VARIABLE = 1;
 }
 
 
@@ -275,6 +292,7 @@ static void upap_lowerdown(ppp_pcb *pcb) {
 #if PPP_SERVER
     pcb->upap.us_serverstate = UPAPSS_INITIAL;
 #endif /* PPP_SERVER */
+    __A_VARIABLE = 1;
 }
 
 
@@ -296,6 +314,7 @@ static void upap_protrej(ppp_pcb *pcb) {
     }
 #endif /* PPP_SERVER */
     upap_lowerdown(pcb);
+    __A_VARIABLE = 1;
 }
 
 
@@ -314,6 +333,7 @@ static void upap_input(ppp_pcb *pcb, u_char *inpacket, int l) {
     inp = inpacket;
     if (l < UPAP_HEADERLEN) {
 	UPAPDEBUG(("pap_input: rcvd short header."));
+	__A_VARIABLE = 1;
 	return;
     }
     GETCHAR(code, inp);
@@ -321,10 +341,12 @@ static void upap_input(ppp_pcb *pcb, u_char *inpacket, int l) {
     GETSHORT(len, inp);
     if (len < UPAP_HEADERLEN) {
 	UPAPDEBUG(("pap_input: rcvd illegal length."));
+	__A_VARIABLE = 1;
 	return;
     }
     if (len > l) {
 	UPAPDEBUG(("pap_input: rcvd short packet."));
+	__A_VARIABLE = 1;
 	return;
     }
     len -= UPAP_HEADERLEN;
@@ -350,6 +372,7 @@ static void upap_input(ppp_pcb *pcb, u_char *inpacket, int l) {
     default:				/* XXX Need code reject */
 	break;
     }
+    __A_VARIABLE = 1;
 }
 
 #if PPP_SERVER
@@ -365,8 +388,10 @@ static void upap_rauthreq(ppp_pcb *pcb, u_char *inp, int id, int len) {
     const char *msg;
     int msglen;
 
-    if (pcb->upap.us_serverstate < UPAPSS_LISTEN)
-	return;
+    if (pcb->upap.us_serverstate < UPAPSS_LISTEN){
+	__A_VARIABLE = 1;
+	return;
+    }
 
     /*
      * If we receive a duplicate authenticate-request, we are
@@ -374,10 +399,12 @@ static void upap_rauthreq(ppp_pcb *pcb, u_char *inp, int id, int len) {
      */
     if (pcb->upap.us_serverstate == UPAPSS_OPEN) {
 	upap_sresp(pcb, UPAP_AUTHACK, id, "", 0);	/* return auth-ack */
+	__A_VARIABLE = 1;
 	return;
     }
     if (pcb->upap.us_serverstate == UPAPSS_BADAUTH) {
 	upap_sresp(pcb, UPAP_AUTHNAK, id, "", 0);	/* return auth-nak */
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -386,12 +413,14 @@ static void upap_rauthreq(ppp_pcb *pcb, u_char *inp, int id, int len) {
      */
     if (len < 1) {
 	UPAPDEBUG(("pap_rauth: rcvd short packet."));
+	__A_VARIABLE = 1;
 	return;
     }
     GETCHAR(ruserlen, inp);
     len -= sizeof (u_char) + ruserlen + sizeof (u_char);
     if (len < 0) {
 	UPAPDEBUG(("pap_rauth: rcvd short packet."));
+	__A_VARIABLE = 1;
 	return;
     }
     ruser = (char *) inp;
@@ -399,6 +428,7 @@ static void upap_rauthreq(ppp_pcb *pcb, u_char *inp, int id, int len) {
     GETCHAR(rpasswdlen, inp);
     if (len < rpasswdlen) {
 	UPAPDEBUG(("pap_rauth: rcvd short packet."));
+	__A_VARIABLE = 1;
 	return;
     }
 
@@ -449,6 +479,7 @@ static void upap_rauthreq(ppp_pcb *pcb, u_char *inp, int id, int len) {
 
     if (pcb->settings.pap_req_timeout > 0)
 	UNTIMEOUT(upap_reqtimeout, pcb);
+    __A_VARIABLE = 1;
 }
 #endif /* PPP_SERVER */
 
@@ -534,10 +565,13 @@ static void upap_sauthreq(ppp_pcb *pcb) {
     outlen = UPAP_HEADERLEN + 2 * sizeof (u_char) +
 	pcb->upap.us_userlen + pcb->upap.us_passwdlen;
     p = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_HDRLEN +outlen), PPP_CTRL_PBUF_TYPE);
-    if(NULL == p)
-        return;
+    if(NULL == p){
+        __A_VARIABLE = 1;
+        return;
+    }
     if(p->tot_len != p->len) {
         pbuf_free(p);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -558,6 +592,7 @@ static void upap_sauthreq(ppp_pcb *pcb) {
     TIMEOUT(upap_timeout, pcb, pcb->settings.pap_timeout_time);
     ++pcb->upap.us_transmits;
     pcb->upap.us_clientstate = UPAPCS_AUTHREQ;
+    __A_VARIABLE = 1;
 }
 
 #if PPP_SERVER
@@ -571,10 +606,13 @@ static void upap_sresp(ppp_pcb *pcb, u_char code, u_char id, const char *msg, in
 
     outlen = UPAP_HEADERLEN + sizeof (u_char) + msglen;
     p = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_HDRLEN +outlen), PPP_CTRL_PBUF_TYPE);
-    if(NULL == p)
-        return;
+    if(NULL == p){
+        __A_VARIABLE = 1;
+        return;
+    }
     if(p->tot_len != p->len) {
         pbuf_free(p);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -588,6 +626,7 @@ static void upap_sresp(ppp_pcb *pcb, u_char code, u_char id, const char *msg, in
     MEMCPY(outp, msg, msglen);
 
     ppp_write(pcb, p);
+    __A_VARIABLE = 1;
 }
 #endif /* PPP_SERVER */
 
@@ -605,14 +644,18 @@ static int upap_printpkt(const u_char *p, int plen, void (*printer) (void *, con
     const u_char *user, *pwd, *msg;
     const u_char *pstart;
 
-    if (plen < UPAP_HEADERLEN)
-	return 0;
+    if (plen < UPAP_HEADERLEN){
+	__A_VARIABLE = 1;
+	return 0;
+    }
     pstart = p;
     GETCHAR(code, p);
     GETCHAR(id, p);
     GETSHORT(len, p);
-    if (len < UPAP_HEADERLEN || len > plen)
-	return 0;
+    if (len < UPAP_HEADERLEN || len > plen){
+	__A_VARIABLE = 1;
+	return 0;
+    }
 
     if (code >= 1 && code <= (int)LWIP_ARRAYSIZE(upap_codenames))
 	printer(arg, " %s", upap_codenames[code-1]);
@@ -670,6 +713,7 @@ static int upap_printpkt(const u_char *p, int plen, void (*printer) (void *, con
 	printer(arg, " %.2x", code);
     }
 
+    __A_VARIABLE = 1;
     return p - pstart;
 }
 #endif /* PRINTPKT_SUPPORT */
diff --git a/src/netif/ppp/utils.c b/src/netif/ppp/utils.c
index be7a3b0..e558426 100644
--- a/src/netif/ppp/utils.c
+++ b/src/netif/ppp/utils.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * utils.c - various utility functions used in pppd.
  *
diff --git a/src/netif/ppp/vj.c b/src/netif/ppp/vj.c
index 8ba94ba..1612bb7 100644
--- a/src/netif/ppp/vj.c
+++ b/src/netif/ppp/vj.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * Routines to compress and uncompess tcp packets (for transmission
  * over low speed serial lines.
@@ -65,6 +67,7 @@ vj_compress_init(struct vjcompress *comp)
   comp->last_recv = 255;
   comp->last_xmit = 255;
   comp->flags = VJF_TOSS;
+  __A_VARIABLE = 1;
 }
 
 
@@ -449,6 +452,7 @@ vj_uncompress_err(struct vjcompress *comp)
 {
   comp->flags |= VJF_TOSS;
   INCR(vjs_errorin);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -472,6 +476,7 @@ vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
     PPPDEBUG(LOG_INFO, ("vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",
       IPH_PROTO(ip), hlen, nb->len));
     vj_uncompress_err(comp);
+    __A_VARIABLE = 1;
     return -1;
   }
   cs = &comp->rstate[comp->last_recv = IPH_PROTO(ip)];
@@ -482,6 +487,7 @@ vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
   MEMCPY(&cs->cs_hdr, nb->payload, hlen);
   cs->cs_hlen = (u16_t)hlen;
   INCR(vjs_uncompressedin);
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/src/netif/slipif.c b/src/netif/slipif.c
index 037ed9c..f2b1da7 100644
--- a/src/netif/slipif.c
+++ b/src/netif/slipif.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * SLIP Interface
@@ -154,6 +156,7 @@ slipif_output(struct netif *netif, struct pbuf *p)
   }
   /* End with packet delimiter. */
   sio_send(SLIP_END, priv->sd);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -172,6 +175,7 @@ static err_t
 slipif_output_v4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
 {
   LWIP_UNUSED_ARG(ipaddr);
+  __A_VARIABLE = 1;
   return slipif_output(netif, p);
 }
 #endif /* LWIP_IPV4 */
@@ -191,6 +195,7 @@ static err_t
 slipif_output_v6(struct netif *netif, struct pbuf *p, const ip6_addr_t *ipaddr)
 {
   LWIP_UNUSED_ARG(ipaddr);
+  __A_VARIABLE = 1;
   return slipif_output(netif, p);
 }
 #endif /* LWIP_IPV6 */
@@ -229,11 +234,14 @@ slipif_rxbyte(struct netif *netif, u8_t c)
             t = priv->q;
             priv->p = priv->q = NULL;
             priv->i = priv->recved = 0;
+            __A_VARIABLE = 1;
             return t;
           }
+          __A_VARIABLE = 1;
           return NULL;
         case SLIP_ESC:
           priv->state = SLIP_RECV_ESCAPE;
+          __A_VARIABLE = 1;
           return NULL;
         default:
           break;
@@ -268,6 +276,7 @@ slipif_rxbyte(struct netif *netif, u8_t c)
       LINK_STATS_INC(link.drop);
       LWIP_DEBUGF(SLIP_DEBUG, ("slipif_input: no new pbuf! (DROP)\n"));
       /* don't process any further since we got no pbuf to receive to */
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -298,6 +307,7 @@ slipif_rxbyte(struct netif *netif, u8_t c)
       }
     }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -316,6 +326,7 @@ slipif_rxbyte_input(struct netif *netif, u8_t c)
       pbuf_free(p);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #if SLIP_USE_RX_THREAD
@@ -338,6 +349,7 @@ slipif_loop_thread(void *nf)
       slipif_rxbyte_input(netif, c);
     }
   }
+  __A_VARIABLE = 1;
 }
 #endif /* SLIP_USE_RX_THREAD */
 
@@ -372,6 +384,7 @@ slipif_init(struct netif *netif)
   /* Allocate private data */
   priv = (struct slipif_priv *)mem_malloc(sizeof(struct slipif_priv));
   if (!priv) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
 
@@ -390,6 +403,7 @@ slipif_init(struct netif *netif)
   if (!priv->sd) {
     /* Opening the serial port failed. */
     mem_free(priv);
+    __A_VARIABLE = 1;
     return ERR_IF;
   }
 
@@ -413,6 +427,7 @@ slipif_init(struct netif *netif)
   sys_thread_new(SLIPIF_THREAD_NAME, slipif_loop_thread, netif,
                  SLIPIF_THREAD_STACKSIZE, SLIPIF_THREAD_PRIO);
 #endif /* SLIP_USE_RX_THREAD */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -436,6 +451,7 @@ slipif_poll(struct netif *netif)
   while (sio_tryread(priv->sd, &c, 1) > 0) {
     slipif_rxbyte_input(netif, c);
   }
+  __A_VARIABLE = 1;
 }
 
 #if SLIP_RX_FROM_ISR
@@ -477,6 +493,7 @@ slipif_process_rxqueue(struct netif *netif)
     SYS_ARCH_PROTECT(old_level);
   }
   SYS_ARCH_UNPROTECT(old_level);
+  __A_VARIABLE = 1;
 }
 
 /** Like slipif_rxbyte, but queues completed packets.
@@ -512,6 +529,7 @@ slipif_rxbyte_enqueue(struct netif *netif, u8_t data)
     }
     SYS_ARCH_UNPROTECT(old_level);
   }
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -530,6 +548,7 @@ slipif_received_byte(struct netif *netif, u8_t data)
   LWIP_ASSERT("netif != NULL", (netif != NULL));
   LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));
   slipif_rxbyte_enqueue(netif, data);
+  __A_VARIABLE = 1;
 }
 
 /**
@@ -554,5 +573,6 @@ slipif_received_bytes(struct netif *netif, u8_t *data, u8_t len)
   for (i = 0; i < len; i++, rxdata++) {
     slipif_rxbyte_enqueue(netif, *rxdata);
   }
+  __A_VARIABLE = 1;
 }
 #endif /* SLIP_RX_FROM_ISR */
diff --git a/src/netif/zepif.c b/src/netif/zepif.c
index b7c9b9c..454a134 100644
--- a/src/netif/zepif.c
+++ b/src/netif/zepif.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  *
@@ -101,6 +103,7 @@ zep_lowpan_timer(void *arg)
   if (zep_lowpan_timer_running) {
     sys_timeout(LOWPAN6_TMR_INTERVAL, zep_lowpan_timer, arg);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Pass received pbufs into 6LowPAN netif */
@@ -118,6 +121,7 @@ zepif_udp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   LWIP_UNUSED_ARG(addr);
   LWIP_UNUSED_ARG(port);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -157,10 +161,12 @@ zepif_udp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   /* Call into 6LoWPAN code. */
   err = netif_lowpan6->input(p, netif_lowpan6);
   if (err == ERR_OK) {
+    __A_VARIABLE = 1;
     return;
   }
 err_return:
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 
 /* Send 6LoWPAN TX packets as UDP broadcast */
@@ -176,6 +182,7 @@ zepif_linkoutput(struct netif *netif, struct pbuf *p)
   LWIP_ASSERT("invalid pbuf", p != NULL);
 
   if (p->tot_len > ZEP_MAX_DATA_LEN) {
+    __A_VARIABLE = 1;
     return ERR_VAL;
   }
   LWIP_ASSERT("TODO: support chained pbufs", p->next == NULL);
@@ -185,6 +192,7 @@ zepif_linkoutput(struct netif *netif, struct pbuf *p)
 
   q = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct zep_hdr) + p->tot_len, PBUF_RAM);
   if (q == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   zep = (struct zep_hdr *)q->payload;
@@ -210,6 +218,7 @@ zepif_linkoutput(struct netif *netif, struct pbuf *p)
   }
   pbuf_free(q);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -228,6 +237,7 @@ zepif_init(struct netif *netif)
   LWIP_ASSERT("zepif needs an input callback", netif->input != NULL);
 
   if (state == NULL) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   memset(state, 0, sizeof(struct zepif_state));
@@ -286,6 +296,7 @@ zepif_init(struct netif *netif)
       zep_lowpan_timer_running = 1;
     }
 
+    __A_VARIABLE = 1;
     return ERR_OK;
   }
 
@@ -294,6 +305,7 @@ err_ret:
     udp_remove(state->pcb);
   }
   mem_free(state);
+  __A_VARIABLE = 1;
   return err;
 }
 
diff --git a/test/fuzz/fuzz.c b/test/fuzz/fuzz.c
index 858665c..2e242d3 100644
--- a/test/fuzz/fuzz.c
+++ b/test/fuzz/fuzz.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
  * All rights reserved. 
@@ -62,6 +64,7 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
 {
   LWIP_UNUSED_ARG(netif);
   LWIP_UNUSED_ARG(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -89,6 +92,7 @@ static err_t testif_init(struct netif *netif)
   netif->flags |= NETIF_FLAG_MLD6;
 #endif
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -108,6 +112,7 @@ static void input_pkt(struct netif *netif, const u8_t *data, size_t len)
   if (err != ERR_OK) {
     pbuf_free(p);
   }
+  __A_VARIABLE = 1;
 }
 
 static void input_pkts(struct netif *netif, const u8_t *data, size_t len)
@@ -136,6 +141,7 @@ static void input_pkts(struct netif *netif, const u8_t *data, size_t len)
 #else /* LWIP_FUZZ_MULTI_PACKET */
   input_pkt(netif, data, len);
 #endif /* LWIP_FUZZ_MULTI_PACKET */
+  __A_VARIABLE = 1;
 }
 
 int main(int argc, char** argv)
@@ -185,5 +191,6 @@ int main(int argc, char** argv)
   }
   input_pkts(&net_test, pktbuf, len);
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/test/sockets/sockets_stresstest.c b/test/sockets/sockets_stresstest.c
index 63698ea..314bfdb 100644
--- a/test/sockets/sockets_stresstest.c
+++ b/test/sockets/sockets_stresstest.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /**
  * @file
  * Sockets stresstest
@@ -117,6 +119,7 @@ fill_test_data(void *buf, size_t buf_len_bytes)
   /* store checksum */
   p[2] = (u8_t)(chk >> 8);
   p[3] = (u8_t)chk;
+  __A_VARIABLE = 1;
 }
 
 static size_t
@@ -131,6 +134,7 @@ check_test_data(const void *buf, size_t buf_len_bytes)
   if (len_rx > buf_len_bytes) {
     /* not all data received in this segment */
     LWIP_DEBUGF(TEST_SOCKETS_STRESS | LWIP_DBG_TRACE, ("check-\n"));
+    __A_VARIABLE = 1;
     return buf_len_bytes;
   }
   chk_rx = (((u16_t)p[2]) << 8) | p[3];
@@ -143,10 +147,12 @@ check_test_data(const void *buf, size_t buf_len_bytes)
   if (len_rx < buf_len_bytes) {
     size_t data_left = buf_len_bytes - len_rx;
     memmove(p, &p[len_rx], data_left);
+    __A_VARIABLE = 1;
     return data_left;
   }
   /* if we come here, we received exactly one chunk
      -> next offset is 0 */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -158,6 +164,7 @@ recv_and_check_data_return_offset(int s, char *rxbuf, size_t rxbufsize, size_t r
   ret = lwip_read(s, &rxbuf[rxoff], rxbufsize - rxoff);
   if (ret == 0) {
     *closed = 1;
+    __A_VARIABLE = 1;
     return rxoff;
   }
   *closed = 0;
@@ -167,11 +174,13 @@ recv_and_check_data_return_offset(int s, char *rxbuf, size_t rxbufsize, size_t r
     int err = errno;
     if (err == ENOTCONN) {
       *closed = 1;
+      __A_VARIABLE = 1;
       return 0;
     }
     LWIP_ASSERT("err == 0", err == 0);
   }
   LWIP_ASSERT("ret > 0", ret > 0);
+  __A_VARIABLE = 1;
   return check_test_data(rxbuf, rxoff + ret);
 }
 
@@ -208,8 +217,10 @@ sockets_stresstest_wait_readable_select(int s, int timeout_ms)
     if (FD_ISSET(s, &fs_e)) {
       ret |= TEST_SOCK_ERR;
     }
+    __A_VARIABLE = 1;
     return ret;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif
@@ -238,8 +249,10 @@ sockets_stresstest_wait_readable_poll(int s, int timeout_ms)
     if (pfd.revents & POLLERR) {
       ret |= TEST_SOCK_ERR;
     }
+    __A_VARIABLE = 1;
     return ret;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif
@@ -273,15 +286,19 @@ sockets_stresstest_wait_readable_recvtimeo(int s, int timeout_ms)
   LWIP_ASSERT("setsockopt error", ret == 0);
 
   if (ret == 1) {
+    __A_VARIABLE = 1;
     return TEST_SOCK_READABLE;
   }
   if (ret == 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
   if (ret == -1) {
+    __A_VARIABLE = 1;
     return TEST_SOCK_ERR;
   }
   LWIP_ASSERT("invalid return value", 0);
+  __A_VARIABLE = 1;
   return TEST_SOCK_ERR;
 }
 #endif
@@ -298,15 +315,19 @@ sockets_stresstest_wait_readable_wait_peek(int s, int timeout_ms)
   ret = lwip_recv(s, &buf, 1, MSG_PEEK);
 
   if (ret == 1) {
+    __A_VARIABLE = 1;
     return TEST_SOCK_READABLE;
   }
   if (ret == 0) {
+    __A_VARIABLE = 1;
     return 0;
   }
   if (ret == -1) {
+    __A_VARIABLE = 1;
     return TEST_SOCK_ERR;
   }
   LWIP_ASSERT("invalid return value", 0);
+  __A_VARIABLE = 1;
   return TEST_SOCK_ERR;
 }
 
@@ -322,17 +343,20 @@ sockets_stresstest_wait_readable_nonblock(int s, int timeout_ms)
     ret = lwip_recv(s, &buf, 1, MSG_PEEK | MSG_DONTWAIT);
 
     if (ret == 1) {
+      __A_VARIABLE = 1;
       return TEST_SOCK_READABLE;
     }
     if (ret == -1) {
       /* TODO: for this to work, 'errno' has to support multithreading... */
       int err = errno;
       if (err != EWOULDBLOCK) {
+        __A_VARIABLE = 1;
         return TEST_SOCK_ERR;
       }
     }
     /* TODO: sleep? */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -424,6 +448,7 @@ sockets_stresstest_conn_client_r(void *arg)
 
   SYS_ARCH_DEC(sockets_stresstest_numthreads, 1);
   LWIP_ASSERT("", sockets_stresstest_numthreads >= 0);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -504,6 +529,7 @@ sockets_stresstest_conn_client(void *arg)
 
   SYS_ARCH_DEC(sockets_stresstest_numthreads, 1);
   LWIP_ASSERT("", sockets_stresstest_numthreads >= 0);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -557,6 +583,7 @@ sockets_stresstest_conn_server(void *arg)
 
   SYS_ARCH_DEC(sockets_stresstest_numthreads, 1);
   LWIP_ASSERT("", sockets_stresstest_numthreads >= 0);
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -572,6 +599,7 @@ sockets_stresstest_start_clients(const struct sockaddr_storage *remote_addr)
     t = sys_thread_new("sockets_stresstest_conn_client", sockets_stresstest_conn_client, (void*)remote_addr, 0, 0);
     LWIP_ASSERT("thread != NULL", t != 0);
   }
+  __A_VARIABLE = 1;
   return max_connections;
 }
 
@@ -629,6 +657,7 @@ sockets_stresstest_listener(void *arg)
   LWIP_ASSERT("ret == 0", ret == 0);
 
   LWIP_DEBUGF(TEST_SOCKETS_STRESS |LWIP_DBG_STATE, ("sockets_stresstest_listener: done\n"));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -651,6 +680,7 @@ sockets_stresstest_listener_loop(void *arg)
       sys_msleep(2);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -670,6 +700,7 @@ sockets_stresstest_init_loopback(int addr_family)
 
   t = sys_thread_new("sockets_stresstest_listener_loop", sockets_stresstest_listener_loop, settings, 0, 0);
   LWIP_ASSERT("thread != NULL", t != 0);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -689,6 +720,7 @@ sockets_stresstest_init_server(int addr_family, u16_t server_port)
 
   t = sys_thread_new("sockets_stresstest_listener", sockets_stresstest_listener, settings, 0, 0);
   LWIP_ASSERT("thread != NULL", t != 0);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -721,6 +753,7 @@ sockets_stresstest_init_client(const char *remote_ip, u16_t remote_port)
 #endif
   ((struct sockaddr_in *)addr)->sin_port = remote_port;
   sockets_stresstest_start_clients(addr);
+  __A_VARIABLE = 1;
 }
 
 #endif /* LWIP_SOCKET && LWIP_IPV4 */
diff --git a/test/unit/api/test_sockets.c b/test/unit/api/test_sockets.c
index 66acc7e..c524b3b 100644
--- a/test/unit/api/test_sockets.c
+++ b/test/unit/api/test_sockets.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_sockets.h"
 
 #include "lwip/mem.h"
@@ -25,6 +27,7 @@ test_sockets_get_used_count(void)
       }
     }
   }
+  __A_VARIABLE = 1;
   return used;
 }
 
@@ -36,6 +39,7 @@ sockets_setup(void)
 {
   /* expect full free heap */
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -51,6 +55,7 @@ sockets_teardown(void)
   tcpip_thread_poll_one();
   /* ensure full free heap */
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 #ifndef NUM_SOCKETS
@@ -66,6 +71,7 @@ test_sockets_alloc_socket_nonblocking(int domain, int type)
     int ret = lwip_fcntl(s, F_SETFL, O_NONBLOCK);
     fail_unless(ret == 0);
   }
+  __A_VARIABLE = 1;
   return s;
 }
 
@@ -101,6 +107,7 @@ START_TEST(test_sockets_basics)
     ret = lwip_close(s2[i]);
     fail_unless(ret == 0);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -213,6 +220,7 @@ START_TEST(test_sockets_allfunctions_basic)
 #if LWIP_IPV6
   test_sockets_allfunctions_basic_domain(AF_INET6);
 #endif
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -273,6 +281,7 @@ static void test_sockets_msgapi_update_iovs(struct msghdr *msg, size_t bytes)
   /* update new first vector with any remaining amount */
   msg->msg_iov[0].iov_base = ((u8_t *)msg->msg_iov[0].iov_base + bytes);
   msg->msg_iov[0].iov_len -= bytes;
+  __A_VARIABLE = 1;
 }
 
 static void test_sockets_msgapi_tcp(int domain)
@@ -439,6 +448,7 @@ static void test_sockets_msgapi_tcp(int domain)
   fail_unless(ret == 0);
   mem_free(snd_buf);
   mem_free(rcv_buf);
+  __A_VARIABLE = 1;
 }
 
 static void test_sockets_msgapi_udp_send_recv_loop(int s, struct msghdr *smsg, struct msghdr *rmsg)
@@ -468,6 +478,7 @@ static void test_sockets_msgapi_udp_send_recv_loop(int s, struct msghdr *smsg, s
     *((u8_t*)rmsg->msg_iov[2].iov_base) = 0x00;
     *((u8_t*)rmsg->msg_iov[3].iov_base) = 0x00;
   }
+  __A_VARIABLE = 1;
 }
 
 static void test_sockets_msgapi_udp(int domain)
@@ -542,6 +553,7 @@ static void test_sockets_msgapi_udp(int domain)
 
   ret = lwip_close(s);
   fail_unless(ret == 0);
+  __A_VARIABLE = 1;
 }
 
 #if LWIP_IPV4
@@ -631,6 +643,7 @@ static void test_sockets_msgapi_cmsg(int domain)
 
   ret = lwip_close(s);
   fail_unless(ret == 0);
+  __A_VARIABLE = 1;
 }
 #endif /* LWIP_IPV4 */
 
@@ -646,6 +659,7 @@ START_TEST(test_sockets_msgapis)
   test_sockets_msgapi_udp(AF_INET6);
   test_sockets_msgapi_tcp(AF_INET6);
 #endif
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -682,6 +696,7 @@ START_TEST(test_sockets_select)
 
 #endif
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -825,6 +840,7 @@ cleanup:
     ret = lwip_close(spass);
     fail_unless(ret == 0);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -839,6 +855,7 @@ sockets_suite(void)
     TESTFUNC(test_sockets_select),
     TESTFUNC(test_sockets_recv_after_rst),
   };
+  __A_VARIABLE = 1;
   return create_suite("SOCKETS", tests, sizeof(tests)/sizeof(testfunc), sockets_setup, sockets_teardown);
 }
 
@@ -847,6 +864,7 @@ sockets_suite(void)
 Suite *
 sockets_suite(void)
 {
+  __A_VARIABLE = 1;
   return create_suite("SOCKETS", NULL, 0, NULL, NULL);
 }
 #endif /* LWIP_SOCKET */
diff --git a/test/unit/arch/sys_arch.c b/test/unit/arch/sys_arch.c
index ae93cba..0703a29 100644
--- a/test/unit/arch/sys_arch.c
+++ b/test/unit/arch/sys_arch.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * Copyright (c) 2017 Simon Goldschmidt
  * All rights reserved. 
@@ -47,18 +49,21 @@ u32_t lwip_sys_now;
 u32_t
 sys_jiffies(void)
 {
+  __A_VARIABLE = 1;
   return lwip_sys_now;
 }
 
 u32_t
 sys_now(void)
 {
+  __A_VARIABLE = 1;
   return lwip_sys_now;
 }
 
 void
 sys_init(void)
 {
+	__A_VARIABLE = 1;
 }
 
 #if !NO_SYS
@@ -69,6 +74,7 @@ void
 test_sys_arch_wait_callback(test_sys_arch_waiting_fn waiting_fn)
 {
   the_waiting_fn = waiting_fn;
+  __A_VARIABLE = 1;
 }
 
 err_t
@@ -76,6 +82,7 @@ sys_sem_new(sys_sem_t *sem, u8_t count)
 {
   LWIP_ASSERT("sem != NULL", sem != NULL);
   *sem = count + 1;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -84,6 +91,7 @@ sys_sem_free(sys_sem_t *sem)
 {
   LWIP_ASSERT("sem != NULL", sem != NULL);
   *sem = 0;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -91,6 +99,7 @@ sys_sem_set_invalid(sys_sem_t *sem)
 {
   LWIP_ASSERT("sem != NULL", sem != NULL);
   *sem = 0;
+  __A_VARIABLE = 1;
 }
 
 /* semaphores are 1-based because RAM is initialized as 0, which would be valid */
@@ -143,6 +152,7 @@ sys_sem_signal(sys_sem_t *sem)
   LWIP_ASSERT("*sem > 0", *sem > 0);
   (*sem)++;
   LWIP_ASSERT("*sem > 0", *sem > 0);
+  __A_VARIABLE = 1;
 }
 
 err_t
@@ -150,6 +160,7 @@ sys_mutex_new(sys_mutex_t *mutex)
 {
   LWIP_ASSERT("mutex != NULL", mutex != NULL);
   *mutex = 1; /* 1 allocated */
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -160,6 +171,7 @@ sys_mutex_free(sys_mutex_t *mutex)
   LWIP_ASSERT("mutex != NULL", mutex != NULL);
   LWIP_ASSERT("*mutex >= 1", *mutex >= 1);
   *mutex = 0;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -167,6 +179,7 @@ sys_mutex_set_invalid(sys_mutex_t *mutex)
 {
   LWIP_ASSERT("mutex != NULL", mutex != NULL);
   *mutex = 0;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -179,6 +192,7 @@ sys_mutex_lock(sys_mutex_t *mutex)
   /* we count up just to check the correct pairing of lock/unlock */
   (*mutex)++;
   LWIP_ASSERT("*mutex >= 1", *mutex >= 1);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -190,6 +204,7 @@ sys_mutex_unlock(sys_mutex_t *mutex)
   /* we count down just to check the correct pairing of lock/unlock */
   (*mutex)--;
   LWIP_ASSERT("*mutex >= 1", *mutex >= 1);
+  __A_VARIABLE = 1;
 }
 
 
@@ -202,6 +217,7 @@ sys_thread_new(const char *name, lwip_thread_fn function, void *arg, int stacksi
   LWIP_UNUSED_ARG(stacksize);
   LWIP_UNUSED_ARG(prio);
   /* threads not supported */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -221,6 +237,7 @@ sys_mbox_new(sys_mbox_t *mbox, int size)
   mbox->used = 0;
 
   memset(mbox->q_mem, 0, sizeof(void*)*mboxsize);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -235,6 +252,7 @@ sys_mbox_free(sys_mbox_t *mbox)
   mbox->sem = NULL;
   free(mbox->q_mem);
   mbox->q_mem = NULL;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -244,6 +262,7 @@ sys_mbox_set_invalid(sys_mbox_t *mbox)
   LWIP_ASSERT("mbox->q_mem == NULL", mbox->q_mem == NULL);
   mbox->sem = NULL;
   mbox->q_mem = NULL;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -264,6 +283,7 @@ sys_mbox_post(sys_mbox_t *q, void *msg)
   }
   LWIP_ASSERT("mbox is full!", q->head != q->tail);
   q->used++;
+  __A_VARIABLE = 1;
 }
 
 err_t
@@ -277,15 +297,18 @@ sys_mbox_trypost(sys_mbox_t *q, void *msg)
   LWIP_ASSERT("q->used <= q->size", q->used <= q->size);
 
   if (q->used == q->size) {
+    __A_VARIABLE = 1;
     return ERR_MEM;
   }
   sys_mbox_post(q, msg);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
 err_t
 sys_mbox_trypost_fromisr(sys_mbox_t *q, void *msg)
 {
+  __A_VARIABLE = 1;
   return sys_mbox_trypost(q, msg);
 }
 
@@ -349,6 +372,7 @@ sys_arch_mbox_tryfetch(sys_mbox_t *q, void **msg)
   LWIP_ASSERT("q->size > 0", q->size > 0);
 
   if (!q->used) {
+    __A_VARIABLE = 1;
     return SYS_ARCH_TIMEOUT;
   }
   if(msg) {
@@ -361,6 +385,7 @@ sys_arch_mbox_tryfetch(sys_mbox_t *q, void **msg)
   }
   q->used--;
   LWIP_ASSERT("q->used >= 0", q->used >= 0);
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/test/unit/core/test_def.c b/test/unit/core/test_def.c
index 33dcfcf..10f6c22 100644
--- a/test/unit/core/test_def.c
+++ b/test/unit/core/test_def.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_def.h"
 
 #include "lwip/def.h"
@@ -11,11 +13,13 @@
 static void
 def_setup(void)
 {
+	__A_VARIABLE = 1;
 }
 
 static void
 def_teardown(void)
 {
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -26,6 +30,7 @@ def_check_range_untouched(const char *buf, size_t len)
   for (i = 0; i < len; i++) {
     fail_unless(buf[i] == (char)MAGIC_UNTOUCHED_BYTE);
   }
+  __A_VARIABLE = 1;
 }
 
 static void test_def_itoa(int number, const char *expected)
@@ -56,6 +61,7 @@ static void test_def_itoa(int number, const char *expected)
   fail_unless(test_buf[exp_len] == 0);
   fail_unless(!memcmp(test_buf, expected, exp_len));
   def_check_range_untouched(&test_buf[exp_len + 4], TEST_BUFSIZE - GUARD_SIZE - exp_len - 4);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_def_lwip_itoa)
@@ -70,6 +76,7 @@ START_TEST(test_def_lwip_itoa)
   test_def_itoa(156, "156");
   test_def_itoa(1192, "1192");
   test_def_itoa(-156, "-156");
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -80,5 +87,6 @@ def_suite(void)
   testfunc tests[] = {
     TESTFUNC(test_def_lwip_itoa)
   };
+  __A_VARIABLE = 1;
   return create_suite("DEF", tests, sizeof(tests)/sizeof(testfunc), def_setup, def_teardown);
 }
diff --git a/test/unit/core/test_mem.c b/test/unit/core/test_mem.c
index 789f720..16f2a68 100644
--- a/test/unit/core/test_mem.c
+++ b/test/unit/core/test_mem.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_mem.h"
 
 #include "lwip/mem.h"
@@ -16,12 +18,14 @@ static void
 mem_setup(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
 mem_teardown(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -56,6 +60,7 @@ START_TEST(test_mem_one)
 
   mem_free(p1);
   fail_unless(lwip_stats.mem.used == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -108,6 +113,7 @@ START_TEST(test_mem_random)
         }
      }
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -136,6 +142,7 @@ START_TEST(test_mem_invalid_free)
   mem_free(ptr);
   fail_unless(lwip_stats.mem.illegal == 0);
   fail_unless(lwip_stats.mem.used == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -207,6 +214,7 @@ START_TEST(test_mem_double_free)
   mem_free(ptr1b);
   fail_unless(lwip_stats.mem.illegal == 0);
   fail_unless(lwip_stats.mem.used == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -220,5 +228,6 @@ mem_suite(void)
     TESTFUNC(test_mem_invalid_free),
     TESTFUNC(test_mem_double_free)
   };
+  __A_VARIABLE = 1;
   return create_suite("MEM", tests, sizeof(tests)/sizeof(testfunc), mem_setup, mem_teardown);
 }
diff --git a/test/unit/core/test_netif.c b/test/unit/core/test_netif.c
index 081a70f..6639ee2 100644
--- a/test/unit/core/test_netif.c
+++ b/test/unit/core/test_netif.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_netif.h"
 
 #include "lwip/netif.h"
@@ -18,12 +20,14 @@ static void
 netif_setup(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
 netif_teardown(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 /* test helper functions */
@@ -33,6 +37,7 @@ testif_tx_func(struct netif *netif, struct pbuf *p)
 {
   LWIP_UNUSED_ARG(netif);
   LWIP_UNUSED_ARG(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -54,6 +59,7 @@ testif_init(struct netif *netif)
   netif->hwaddr[4] = 0x06;
   netif->hwaddr[5] = 0x07;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -71,6 +77,7 @@ test_netif_ext_callback_dummy(struct netif* netif, netif_nsc_reason_t reason, co
   LWIP_UNUSED_ARG(args);
 
   fail_unless(dummy_active);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -82,6 +89,7 @@ test_netif_ext_callback(struct netif* netif, netif_nsc_reason_t reason, const ne
   fail_unless(netif == &net_test);
 
   fail_unless(expected_reasons == reason);
+  __A_VARIABLE = 1;
 }
 
 /* Test functions */
@@ -212,6 +220,7 @@ START_TEST(test_netif_extcallbacks)
   netif_remove_ext_callback(&netif_callback_3);
   netif_remove_ext_callback(&netif_callback_1);
   dummy_active = 0;
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -223,5 +232,6 @@ netif_suite(void)
   testfunc tests[] = {
     TESTFUNC(test_netif_extcallbacks)
   };
+  __A_VARIABLE = 1;
   return create_suite("NETIF", tests, sizeof(tests)/sizeof(testfunc), netif_setup, netif_teardown);
 }
diff --git a/test/unit/core/test_pbuf.c b/test/unit/core/test_pbuf.c
index dc94274..2e63174 100644
--- a/test/unit/core/test_pbuf.c
+++ b/test/unit/core/test_pbuf.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_pbuf.h"
 
 #include "lwip/pbuf.h"
@@ -19,12 +21,14 @@ static void
 pbuf_setup(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
 pbuf_teardown(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -67,6 +71,7 @@ START_TEST(test_pbuf_alloc_zero_pbufs)
   if (p != NULL) {
     pbuf_free(p);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -103,6 +108,7 @@ START_TEST(test_pbuf_copy_zero_pbuf)
 
   fail_unless(lwip_stats.mem.used == 0);
   fail_unless(MEMP_STATS_GET(used, MEMP_PBUF_POOL) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -115,6 +121,7 @@ START_TEST(test_pbuf_split_64k_on_small_pbufs)
   pbuf_split_64k(p, &rest);
   fail_unless(p->tot_len == 1);
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -168,6 +175,7 @@ START_TEST(test_pbuf_queueing_bigger_than_64k)
   pbuf_free(p1);
   pbuf_free(rest2);
   pbuf_free(rest3);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -222,6 +230,7 @@ START_TEST(test_pbuf_take_at_edge)
       "Bad data at pos %d, was %02X, expected %02X", p->len+i, out[i], testdata[i]);
   }
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -252,6 +261,7 @@ START_TEST(test_pbuf_get_put_at_edge)
   fail_unless(*out == getdata,
     "pbuf_get_at() returned bad data at pos %d, was %02X, expected %02X", p->len, getdata, *out);
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -267,5 +277,6 @@ pbuf_suite(void)
     TESTFUNC(test_pbuf_take_at_edge),
     TESTFUNC(test_pbuf_get_put_at_edge)
   };
+  __A_VARIABLE = 1;
   return create_suite("PBUF", tests, sizeof(tests)/sizeof(testfunc), pbuf_setup, pbuf_teardown);
 }
diff --git a/test/unit/core/test_timers.c b/test/unit/core/test_timers.c
index b3c6994..49b5f7f 100644
--- a/test/unit/core/test_timers.c
+++ b/test/unit/core/test_timers.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_timers.h"
 
 #include "lwip/def.h"
@@ -14,6 +16,7 @@ timers_setup(void)
   struct sys_timeo** list_head = sys_timeouts_get_next_timeout();
   old_list_head = *list_head;
   *list_head = NULL;
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -22,6 +25,7 @@ timers_teardown(void)
   struct sys_timeo** list_head = sys_timeouts_get_next_timeout();
   *list_head = old_list_head;
   lwip_sys_now = 0;
+  __A_VARIABLE = 1;
 }
 
 static int fired[3];
@@ -30,6 +34,7 @@ dummy_handler(void* arg)
 {
   int index = LWIP_PTR_NUMERIC_CAST(int, arg);
   fired[index] = 1;
+  __A_VARIABLE = 1;
 }
 
 #define HANDLER_EXECUTION_TIME 5
@@ -39,6 +44,7 @@ dummy_cyclic_handler(void)
 {
    cyclic_fired = 1;
    lwip_sys_now += HANDLER_EXECUTION_TIME;
+   __A_VARIABLE = 1;
 }
 
 struct lwip_cyclic_timer test_cyclic = {10, dummy_cyclic_handler};
@@ -78,6 +84,7 @@ do_test_cyclic_timers(u32_t offset)
   fail_unless(cyclic_fired == 1);
 
   fail_unless((*list_head)->time == (u32_t)(lwip_sys_now + test_cyclic.interval_ms));
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_cyclic_timers)
@@ -89,6 +96,7 @@ START_TEST(test_cyclic_timers)
 
   /* check with u32_t wraparound */
   do_test_cyclic_timers(0xfffffff0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -121,6 +129,7 @@ START_TEST(test_bug52748)
   fail_unless(fired[0] == 1);
   fail_unless(fired[1] == 1);
   fail_unless(fired[2] == 1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -173,6 +182,7 @@ do_test_timers(u32_t offset)
   sys_untimeout(dummy_handler, LWIP_PTR_NUMERIC_CAST(void*, 0));
   sys_untimeout(dummy_handler, LWIP_PTR_NUMERIC_CAST(void*, 1));
   sys_untimeout(dummy_handler, LWIP_PTR_NUMERIC_CAST(void*, 2));
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_timers)
@@ -184,6 +194,7 @@ START_TEST(test_timers)
 
   /* check with u32_t wraparound */
   do_test_timers(0xfffffff0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -216,6 +227,7 @@ START_TEST(test_long_timer)
   fail_unless(fired[0] == 1);
 
   sys_untimeout(dummy_handler, LWIP_PTR_NUMERIC_CAST(void*, 0));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -229,5 +241,6 @@ timers_suite(void)
     TESTFUNC(test_timers),
     TESTFUNC(test_long_timer),
   };
+  __A_VARIABLE = 1;
   return create_suite("TIMERS", tests, LWIP_ARRAYSIZE(tests), timers_setup, timers_teardown);
 }
diff --git a/test/unit/dhcp/test_dhcp.c b/test/unit/dhcp/test_dhcp.c
index 4837c14..2feb060 100644
--- a/test/unit/dhcp/test_dhcp.c
+++ b/test/unit/dhcp/test_dhcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_dhcp.h"
 
 #include "lwip/netif.h"
@@ -126,7 +128,8 @@ static enum tcase {
 } tcase;
 
 static int debug = 0;
-static void setdebug(int a) {debug = a;}
+static void setdebug(int a) {debug = a;__A_VARIABLE = 1;
+}
 
 static int tick = 0;
 static void tick_lwip(void)
@@ -138,6 +141,7 @@ static void tick_lwip(void)
   if (tick % 600 == 0) {
     dhcp_coarse_tmr();
   }
+  __A_VARIABLE = 1;
 }
 
 static void send_pkt(struct netif *netif, const u8_t *data, size_t len)
@@ -162,6 +166,7 @@ static void send_pkt(struct netif *netif, const u8_t *data, size_t len)
     data += q->len;
   }
   netif->input(p, netif);
+  __A_VARIABLE = 1;
 }
 
 static err_t lwip_tx_func(struct netif *netif, struct pbuf *p);
@@ -183,6 +188,7 @@ static err_t testif_init(struct netif *netif)
   netif->hwaddr[4] = 0xD0;
   netif->hwaddr[5] = 0x0D;
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -190,11 +196,13 @@ static void dhcp_setup(void)
 {
   txpacket = 0;
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void dhcp_teardown(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void check_pkt(struct pbuf *p, u32_t pos, const u8_t *mem, u32_t len)
@@ -211,6 +219,7 @@ static void check_pkt(struct pbuf *p, u32_t pos, const u8_t *mem, u32_t len)
 
   data = (u8_t*)p->payload;
   fail_if(memcmp(&data[pos], mem, len), "data at pos %d, len %d in packet %d did not match", pos, len, txpacket);
+  __A_VARIABLE = 1;
 }
 
 static void check_pkt_fuzzy(struct pbuf *p, u32_t startpos, const u8_t *mem, u32_t len)
@@ -236,6 +245,7 @@ static void check_pkt_fuzzy(struct pbuf *p, u32_t startpos, const u8_t *mem, u32
     }
   }
   fail_unless(found);
+  __A_VARIABLE = 1;
 }
 
 static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
@@ -424,6 +434,7 @@ static err_t lwip_tx_func(struct netif *netif, struct pbuf *p)
     break;
   }
 
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -498,6 +509,7 @@ START_TEST(test_dhcp)
   dhcp_stop(&net_test);
   dhcp_cleanup(&net_test);
   netif_remove(&net_test);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -564,6 +576,7 @@ START_TEST(test_dhcp_nak)
   dhcp_stop(&net_test);
   dhcp_cleanup(&net_test);
   netif_remove(&net_test);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -813,6 +826,7 @@ START_TEST(test_dhcp_relayed)
   dhcp_cleanup(&net_test);
   netif_remove(&net_test);
 
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -929,6 +943,7 @@ START_TEST(test_dhcp_nak_no_endmarker)
   dhcp_stop(&net_test);
   dhcp_cleanup(&net_test);
   netif_remove(&net_test);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1039,6 +1054,7 @@ START_TEST(test_dhcp_invalid_overload)
   dhcp_stop(&net_test);
   dhcp_cleanup(&net_test);
   netif_remove(&net_test);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1053,5 +1069,6 @@ dhcp_suite(void)
     TESTFUNC(test_dhcp_nak_no_endmarker),
     TESTFUNC(test_dhcp_invalid_overload)
   };
+  __A_VARIABLE = 1;
   return create_suite("DHCP", tests, sizeof(tests)/sizeof(testfunc), dhcp_setup, dhcp_teardown);
 }
diff --git a/test/unit/etharp/test_etharp.c b/test/unit/etharp/test_etharp.c
index 5d481f1..6242b05 100644
--- a/test/unit/etharp/test_etharp.c
+++ b/test/unit/etharp/test_etharp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_etharp.h"
 
 #include "lwip/udp.h"
@@ -30,6 +32,7 @@ etharp_remove_all(void)
   for(i = 0; i < 0xff; i++) {
     etharp_tmr();
   }
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -38,6 +41,7 @@ default_netif_linkoutput(struct netif *netif, struct pbuf *p)
   fail_unless(netif == &test_netif);
   fail_unless(p != NULL);
   linkoutput_ctr++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -50,6 +54,7 @@ default_netif_init(struct netif *netif)
   netif->mtu = 1500;
   netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
   netif->hwaddr_len = ETHARP_HWADDR_LEN;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -64,6 +69,7 @@ default_netif_add(void)
   netif_set_default(netif_add(&test_netif, &test_ipaddr, &test_netmask,
                               &test_gw, NULL, default_netif_init, NULL));
   netif_set_up(&test_netif);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -71,6 +77,7 @@ default_netif_remove(void)
 {
   fail_unless(netif_default == &test_netif);
   netif_remove(&test_netif);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -111,6 +118,7 @@ create_arp_response(ip4_addr_t *adr)
   }
 
   ethernet_input(p, &test_netif);
+  __A_VARIABLE = 1;
 }
 
 /* Setups/teardown functions */
@@ -121,6 +129,7 @@ etharp_setup(void)
   etharp_remove_all();
   default_netif_add();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -129,6 +138,7 @@ etharp_teardown(void)
   etharp_remove_all();
   default_netif_remove();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -257,6 +267,7 @@ START_TEST(test_etharp_table)
 
     udp_remove(pcb);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -268,5 +279,6 @@ etharp_suite(void)
   testfunc tests[] = {
     TESTFUNC(test_etharp_table)
   };
+  __A_VARIABLE = 1;
   return create_suite("ETHARP", tests, sizeof(tests)/sizeof(testfunc), etharp_setup, etharp_teardown);
 }
diff --git a/test/unit/ip4/test_ip4.c b/test/unit/ip4/test_ip4.c
index c4ba2f6..87aad41 100644
--- a/test/unit/ip4/test_ip4.c
+++ b/test/unit/ip4/test_ip4.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_ip4.h"
 
 #include "lwip/ip4.h"
@@ -50,6 +52,7 @@ create_ip4_input_fragment(u16_t ip_id, u16_t start, u16_t len, int last)
     }
     fail_unless(err == ERR_OK);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Setups/teardown functions */
@@ -58,6 +61,7 @@ static void
 ip4_setup(void)
 {
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -71,6 +75,7 @@ ip4_teardown(void)
   /* poll until all memory is released... */
   tcpip_thread_poll_one();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -145,6 +150,7 @@ START_TEST(test_ip4_reass)
   fail_unless(lwip_stats.ip_frag.memerr == 0);
   fail_unless(lwip_stats.ip_frag.drop == 0);
   fail_unless(lwip_stats.mib2.ipreasmoks == 1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -156,5 +162,6 @@ ip4_suite(void)
   testfunc tests[] = {
     TESTFUNC(test_ip4_reass),
   };
+  __A_VARIABLE = 1;
   return create_suite("IPv4", tests, sizeof(tests)/sizeof(testfunc), ip4_setup, ip4_teardown);
 }
diff --git a/test/unit/ip6/test_ip6.c b/test/unit/ip6/test_ip6.c
index f0b8a21..f2e92a4 100644
--- a/test/unit/ip6/test_ip6.c
+++ b/test/unit/ip6/test_ip6.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_ip6.h"
 
 #include "lwip/ethip6.h"
@@ -22,6 +24,7 @@ default_netif_linkoutput(struct netif *netif, struct pbuf *p)
   fail_unless(netif == &test_netif6);
   fail_unless(p != NULL);
   linkoutput_ctr++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -34,6 +37,7 @@ default_netif_init(struct netif *netif)
   netif->mtu = 1500;
   netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHERNET | NETIF_FLAG_MLD6;
   netif->hwaddr_len = ETH_HWADDR_LEN;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -45,6 +49,7 @@ default_netif_add(void)
   n = netif_add_noaddr(&test_netif6, NULL, default_netif_init, NULL);
   fail_unless(n == &test_netif6);
   netif_set_default(&test_netif6);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -52,6 +57,7 @@ default_netif_remove(void)
 {
   fail_unless(netif_default == &test_netif6);
   netif_remove(&test_netif6);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -61,6 +67,7 @@ ip6_test_handle_timers(int count)
   for (i = 0; i < count; i++) {
     nd6_tmr();
   }
+  __A_VARIABLE = 1;
 }
 
 /* Setups/teardown functions */
@@ -70,6 +77,7 @@ ip6_setup(void)
 {
   default_netif_add();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -84,6 +92,7 @@ ip6_teardown(void)
   tcpip_thread_poll_one();
   default_netif_remove();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -126,6 +135,7 @@ test_ip6_ll_addr_iter(int expected_ctr1, int expected_ctr2)
   netif_set_down(&test_netif6);
   fail_unless(linkoutput_ctr == expected_ctr2);
   linkoutput_ctr = 0;
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_ip6_ll_addr)
@@ -138,6 +148,7 @@ START_TEST(test_ip6_ll_addr)
   /* test with link-local address */
   netif_create_ip6_linklocal_address(&test_netif6, 1);
   test_ip6_ll_addr_iter(3 + LWIP_IPV6_DUP_DETECT_ATTEMPTS + LWIP_IPV6_MLD, 3);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -201,6 +212,7 @@ START_TEST(test_ip6_aton_ipv4mapped)
   memset(&addr, 0, sizeof(addr));
   ret = ipaddr_aton(bogus_ipv4_mapped_addr, &addr);
   fail_unless(ret == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -214,6 +226,7 @@ START_TEST(test_ip6_ntoa_ipv4mapped)
   str = ip6addr_ntoa_r(ip_2_ip6(&addr), buf, sizeof(buf));
   fail_unless(str == buf);
   fail_unless(!strcmp(str, "::FFFF:212.204.101.210"));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -239,6 +252,7 @@ START_TEST(test_ip6_ntoa)
     fail_unless(str == buf);
     fail_unless(!strcmp(str, tests[i].str));
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -284,6 +298,7 @@ START_TEST(test_ip6_lladdr)
 
   /* reset mac address */
   memset(&test_netif6.hwaddr, 0, sizeof(test_netif6.hwaddr));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -298,6 +313,7 @@ ip6_suite(void)
     TESTFUNC(test_ip6_ntoa),
     TESTFUNC(test_ip6_lladdr)
   };
+  __A_VARIABLE = 1;
   return create_suite("IPv6", tests, sizeof(tests)/sizeof(testfunc), ip6_setup, ip6_teardown);
 }
 
@@ -307,6 +323,7 @@ ip6_suite(void)
 START_TEST(test_ip6_dummy)
 {
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -316,6 +333,7 @@ ip6_suite(void)
   testfunc tests[] = {
     TESTFUNC(test_ip6_dummy),
   };
+  __A_VARIABLE = 1;
   return create_suite("IPv6", tests, sizeof(tests)/sizeof(testfunc), NULL, NULL);
 }
 #endif /* LWIP_IPV6 */
diff --git a/test/unit/lwip_unittests.c b/test/unit/lwip_unittests.c
index 864c5ec..18a50bd 100644
--- a/test/unit/lwip_unittests.c
+++ b/test/unit/lwip_unittests.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "lwip_check.h"
 
 #include "ip4/test_ip4.h"
@@ -34,6 +36,7 @@ Suite* create_suite(const char* name, testfunc *tests, size_t num_tests, SFun se
     tcase_add_named_test(tc_core, tests[i]);
     suite_add_tcase(s, tc_core);
   }
+  __A_VARIABLE = 1;
   return s;
 }
 
@@ -50,6 +53,7 @@ void lwip_check_ensure_no_alloc(unsigned int skip)
       fail_unless(lwip_stats.memp[i]->used == 0);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #ifdef LWIP_UNITTESTS_LIB
diff --git a/test/unit/mdns/test_mdns.c b/test/unit/mdns/test_mdns.c
index 14e3af6..16b67d4 100644
--- a/test/unit/mdns/test_mdns.c
+++ b/test/unit/mdns/test_mdns.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 /*
  * Copyright (c) 2015 Verisure Innovation AB
  * All rights reserved.
@@ -52,6 +54,7 @@ START_TEST(readname_basic)
   fail_unless(offset == sizeof(data));
   fail_unless(domain.length == sizeof(data));
   fail_if(memcmp(&domain.name, data, sizeof(data)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -71,6 +74,7 @@ START_TEST(readname_anydata)
   fail_unless(offset == sizeof(data));
   fail_unless(domain.length == sizeof(data));
   fail_if(memcmp(&domain.name, data, sizeof(data)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -88,6 +92,7 @@ START_TEST(readname_short_buf)
   offset = mdns_readname(p, 0, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -113,6 +118,7 @@ START_TEST(readname_long_label)
   offset = mdns_readname(p, 0, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -169,6 +175,7 @@ START_TEST(readname_overflow)
   offset = mdns_readname(p, 0, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -197,6 +204,7 @@ START_TEST(readname_jump_earlier)
   fail_unless(domain.length == sizeof(fullname));
 
   fail_if(memcmp(&domain.name, fullname, sizeof(fullname)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -226,6 +234,7 @@ START_TEST(readname_jump_earlier_jump)
   fail_unless(domain.length == sizeof(fullname));
 
   fail_if(memcmp(&domain.name, fullname, sizeof(fullname)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -260,6 +269,7 @@ START_TEST(readname_jump_maxdepth)
   fail_unless(domain.length == sizeof(fullname));
 
   fail_if(memcmp(&domain.name, fullname, sizeof(fullname)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -286,6 +296,7 @@ START_TEST(readname_jump_later)
   fail_unless(domain.length == sizeof(fullname));
 
   fail_if(memcmp(&domain.name, fullname, sizeof(fullname)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -305,6 +316,7 @@ START_TEST(readname_half_jump)
   offset = mdns_readname(p, 0, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -324,6 +336,7 @@ START_TEST(readname_jump_toolong)
   offset = mdns_readname(p, 0, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -344,6 +357,7 @@ START_TEST(readname_jump_loop_label)
   offset = mdns_readname(p, 10, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -364,6 +378,7 @@ START_TEST(readname_jump_loop_jump)
   offset = mdns_readname(p, 10, &domain);
   pbuf_free(p);
   fail_unless(offset == MDNS_READNAME_ERROR);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -383,6 +398,7 @@ START_TEST(add_label_basic)
   fail_unless(res == ERR_OK);
   fail_unless(domain.length == sizeof(data));
   fail_if(memcmp(&domain.name, data, sizeof(data)));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -398,6 +414,7 @@ START_TEST(add_label_long_label)
   fail_unless(res == ERR_OK);
   res = mdns_domain_add_label(&domain, toolong, (u8_t)strlen(toolong));
   fail_unless(res == ERR_VAL);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -448,6 +465,7 @@ START_TEST(add_label_full)
   res = mdns_domain_add_label(&domain, NULL, 0);
   fail_unless(res == ERR_VAL);
   fail_unless(domain.length == 256);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -478,6 +496,7 @@ START_TEST(domain_eq_basic)
   fail_unless(res == ERR_OK);
 
   fail_unless(mdns_domain_eq(&domain1, &domain2));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -504,6 +523,7 @@ START_TEST(domain_eq_diff)
   fail_unless(res == ERR_OK);
 
   fail_if(mdns_domain_eq(&domain1, &domain2));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -530,6 +550,7 @@ START_TEST(domain_eq_case)
   fail_unless(res == ERR_OK);
 
   fail_unless(mdns_domain_eq(&domain1, &domain2));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -562,6 +583,7 @@ START_TEST(domain_eq_anydata)
   fail_unless(res == ERR_OK);
 
   fail_unless(mdns_domain_eq(&domain1, &domain2));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -586,6 +608,7 @@ START_TEST(domain_eq_length)
   fail_unless(res == ERR_OK);
 
   fail_unless(mdns_domain_eq(&domain1, &domain2));
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -621,6 +644,7 @@ START_TEST(compress_full_match)
   fail_unless(offset == 2);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -656,6 +680,7 @@ START_TEST(compress_full_match_subset)
   fail_unless(offset == 5);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -693,6 +718,7 @@ START_TEST(compress_full_match_jump)
   fail_unless(offset == 0x20);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -727,6 +753,7 @@ START_TEST(compress_no_match)
   fail_unless(length == domain.length);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -762,6 +789,7 @@ START_TEST(compress_2nd_label)
   fail_unless(offset == 9);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -797,6 +825,7 @@ START_TEST(compress_2nd_label_short)
   fail_unless(offset == 7);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -839,6 +868,7 @@ START_TEST(compress_jump_to_jump)
   fail_unless(offset == 0x15);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -872,6 +902,7 @@ START_TEST(compress_long_match)
   fail_unless(length == domain.length);
 
   pbuf_free(p);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -911,5 +942,6 @@ Suite* mdns_suite(void)
     TESTFUNC(compress_jump_to_jump),
     TESTFUNC(compress_long_match),
   };
+  __A_VARIABLE = 1;
   return create_suite("MDNS", tests, sizeof(tests)/sizeof(testfunc), NULL, NULL);
 }
diff --git a/test/unit/mqtt/test_mqtt.c b/test/unit/mqtt/test_mqtt.c
index f9079d3..05b1782 100644
--- a/test/unit/mqtt/test_mqtt.c
+++ b/test/unit/mqtt/test_mqtt.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_mqtt.h"
 
 #include "lwip/pbuf.h"
@@ -15,6 +17,7 @@ static err_t test_mqtt_netif_output(struct netif *netif, struct pbuf *p,
   LWIP_UNUSED_ARG(netif);
   LWIP_UNUSED_ARG(ipaddr);
   LWIP_UNUSED_ARG(p);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -29,11 +32,13 @@ test_mqtt_init_netif(struct netif *netif, const ip_addr_t *ip_addr, const ip_add
   ip_addr_copy_from_ip4(netif->ip_addr, *ip_2_ip4(ip_addr));
   for (n = netif_list; n != NULL; n = n->next) {
     if (n == netif) {
+      __A_VARIABLE = 1;
       return;
     }
   }
   netif->next = NULL;
   netif_list = netif;
+  __A_VARIABLE = 1;
 }
 
 /* Setups/teardown functions */
@@ -48,6 +53,7 @@ mqtt_setup(void)
   netif_list = NULL;
   netif_default = NULL;
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -59,6 +65,7 @@ mqtt_teardown(void)
   netif_list = old_netif_list;
   netif_default = old_netif_default;
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void test_mqtt_connection_cb(mqtt_client_t *client, void *arg, mqtt_connection_status_t status)
@@ -66,6 +73,7 @@ static void test_mqtt_connection_cb(mqtt_client_t *client, void *arg, mqtt_conne
   LWIP_UNUSED_ARG(client);
   LWIP_UNUSED_ARG(arg);
   LWIP_UNUSED_ARG(status);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(basic_connect)
@@ -103,6 +111,7 @@ START_TEST(basic_connect)
   mqtt_disconnect(client);
   /* fixme: mqtt_client_fre() is missing... */
   mem_free(client);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -111,5 +120,6 @@ Suite* mqtt_suite(void)
   testfunc tests[] = {
     TESTFUNC(basic_connect),
   };
+  __A_VARIABLE = 1;
   return create_suite("MQTT", tests, sizeof(tests)/sizeof(testfunc), mqtt_setup, mqtt_teardown);
 }
diff --git a/test/unit/tcp/tcp_helper.c b/test/unit/tcp/tcp_helper.c
index abc5fad..c372271 100644
--- a/test/unit/tcp/tcp_helper.c
+++ b/test/unit/tcp/tcp_helper.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "tcp_helper.h"
 
 #include "lwip/priv/tcp_priv.h"
@@ -26,6 +28,7 @@ tcp_remove(struct tcp_pcb* pcb_list)
     pcb = pcb->next;
     tcp_abort(pcb2);
   }
+  __A_VARIABLE = 1;
 }
 
 /** Remove all pcbs on listen-, active- and time-wait-list (bound- isn't exported). */
@@ -40,6 +43,7 @@ tcp_remove_all(void)
   fail_unless(MEMP_STATS_GET(used, MEMP_TCP_PCB_LISTEN) == 0);
   fail_unless(MEMP_STATS_GET(used, MEMP_TCP_SEG) == 0);
   fail_unless(MEMP_STATS_GET(used, MEMP_PBUF_POOL) == 0);
+  __A_VARIABLE = 1;
 }
 
 /** Create a TCP segment usable for passing to tcp_input */
@@ -104,6 +108,7 @@ tcp_create_segment_wnd(ip_addr_t* src_ip, ip_addr_t* dst_ip,
 
   pbuf_header(p, sizeof(struct ip_hdr));
 
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -113,6 +118,7 @@ tcp_create_segment(ip_addr_t* src_ip, ip_addr_t* dst_ip,
                    u16_t src_port, u16_t dst_port, void* data, size_t data_len,
                    u32_t seqno, u32_t ackno, u8_t headerflags)
 {
+  __A_VARIABLE = 1;
   return tcp_create_segment_wnd(src_ip, dst_ip, src_port, dst_port, data,
     data_len, seqno, ackno, headerflags, TCP_WND);
 }
@@ -125,6 +131,7 @@ struct pbuf*
 tcp_create_rx_segment(struct tcp_pcb* pcb, void* data, size_t data_len, u32_t seqno_offset,
                       u32_t ackno_offset, u8_t headerflags)
 {
+  __A_VARIABLE = 1;
   return tcp_create_segment(&pcb->remote_ip, &pcb->local_ip, pcb->remote_port, pcb->local_port,
     data, data_len, pcb->rcv_nxt + seqno_offset, pcb->lastack + ackno_offset, headerflags);
 }
@@ -137,6 +144,7 @@ tcp_create_rx_segment(struct tcp_pcb* pcb, void* data, size_t data_len, u32_t se
 struct pbuf* tcp_create_rx_segment_wnd(struct tcp_pcb* pcb, void* data, size_t data_len,
                    u32_t seqno_offset, u32_t ackno_offset, u8_t headerflags, u16_t wnd)
 {
+  __A_VARIABLE = 1;
   return tcp_create_segment_wnd(&pcb->remote_ip, &pcb->local_ip, pcb->remote_port, pcb->local_port,
     data, data_len, pcb->rcv_nxt + seqno_offset, pcb->lastack + ackno_offset, headerflags, wnd);
 }
@@ -177,6 +185,7 @@ tcp_set_state(struct tcp_pcb* pcb, enum tcp_state state, const ip_addr_t* local_
   } else {
     fail();
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -186,6 +195,7 @@ test_tcp_counters_err(void* arg, err_t err)
   EXPECT_RET(arg != NULL);
   counters->err_calls++;
   counters->last_err = err;
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -195,6 +205,7 @@ test_tcp_counters_check_rxdata(struct test_tcp_counters* counters, struct pbuf*
   u32_t i, received;
   if(counters->expected_data == NULL) {
     /* no data to compare */
+    __A_VARIABLE = 1;
     return;
   }
   EXPECT_RET(counters->recved_bytes + p->tot_len <= counters->expected_data_len);
@@ -207,6 +218,7 @@ test_tcp_counters_check_rxdata(struct test_tcp_counters* counters, struct pbuf*
     }
   }
   EXPECT(received == counters->recved_bytes + p->tot_len);
+  __A_VARIABLE = 1;
 }
 
 err_t
@@ -231,6 +243,7 @@ test_tcp_counters_recv(void* arg, struct tcp_pcb* pcb, struct pbuf* p, err_t err
     counters->close_calls++;
   }
   EXPECT(counters->recv_calls_after_close == 0 && counters->recved_bytes_after_close == 0);
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -247,6 +260,7 @@ test_tcp_new_counters_pcb(struct test_tcp_counters* counters)
     pcb->snd_wnd = TCP_WND;
     pcb->snd_wnd_max = TCP_WND;
   }
+  __A_VARIABLE = 1;
   return pcb;
 }
 
@@ -269,6 +283,7 @@ void test_tcp_input(struct pbuf *p, struct netif *inp)
   ip_addr_set_zero(ip_current_src_addr());
   ip_current_netif() = NULL;
   ip_data.current_ip4_header = NULL;
+  __A_VARIABLE = 1;
 }
 
 static err_t test_tcp_netif_output(struct netif *netif, struct pbuf *p,
@@ -293,6 +308,7 @@ static err_t test_tcp_netif_output(struct netif *netif, struct pbuf *p,
       }
     }
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -311,9 +327,11 @@ void test_tcp_init_netif(struct netif *netif, struct test_tcp_txcounters *txcoun
   ip_addr_copy_from_ip4(netif->ip_addr, *ip_2_ip4(ip_addr));
   for (n = netif_list; n != NULL; n = n->next) {
     if (n == netif) {
+      __A_VARIABLE = 1;
       return;
     }
   }
   netif->next = NULL;
   netif_list = netif;
+  __A_VARIABLE = 1;
 }
diff --git a/test/unit/tcp/test_tcp.c b/test/unit/tcp/test_tcp.c
index e5cddf1..c854b7e 100644
--- a/test/unit/tcp/test_tcp.c
+++ b/test/unit/tcp/test_tcp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_tcp.h"
 
 #include "lwip/priv/tcp_priv.h"
@@ -37,6 +39,7 @@ test_tcp_tmr(void)
   if (++test_tcp_timer & 1) {
     tcp_slowtmr();
   }
+  __A_VARIABLE = 1;
 }
 
 /* Setups/teardown functions */
@@ -61,6 +64,7 @@ tcp_setup(void)
   test_tcp_timer = 0;
   tcp_remove_all();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -73,6 +77,7 @@ tcp_teardown(void)
   netif_list = old_netif_list;
   netif_default = old_netif_default;
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -93,6 +98,7 @@ START_TEST(test_tcp_new_abort)
     tcp_abort(pcb);
     fail_unless(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -152,6 +158,7 @@ START_TEST(test_tcp_listen_passive_open)
   }
 
   tcp_close(pcbl);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -197,6 +204,7 @@ START_TEST(test_tcp_recv_inseq)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -251,6 +259,7 @@ START_TEST(test_tcp_recv_inseq_trim)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -272,6 +281,7 @@ test_tcp_recv_expectclose(void* arg, struct tcp_pcb* pcb, struct pbuf* p, err_t
     /* set back to some other rx function, just to not get here again */
     tcp_recv(pcb, test_tcp_recv_expect1byte);
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -292,6 +302,7 @@ test_tcp_recv_expect1byte(void* arg, struct tcp_pcb* pcb, struct pbuf* p, err_t
   } else {
     fail();
   }
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -327,6 +338,7 @@ START_TEST(test_tcp_passive_close)
     test_tcp_input(p, &netif);
   }
   /* don't free the pcb here (part of the test!) */
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -374,6 +386,7 @@ START_TEST(test_tcp_active_abort)
   }
 
   /* don't free the pcb here (part of the test!) */
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -436,6 +449,7 @@ START_TEST(test_tcp_malformed_header)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -604,6 +618,7 @@ START_TEST(test_tcp_fast_retx_recover)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -619,6 +634,7 @@ check_seqnos(struct tcp_seg *segs, int num_expected, u32_t *seqnos_expected)
     EXPECT(s->tcphdr->seqno == htonl(seqnos_expected[i]));
   }
   EXPECT(s == NULL);
+  __A_VARIABLE = 1;
 }
 
 /** Send data with sequence numbers that wrap around the u32_t range.
@@ -706,6 +722,7 @@ START_TEST(test_tcp_fast_rexmit_wraparound)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -783,6 +800,7 @@ START_TEST(test_tcp_rto_rexmit_wraparound)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -925,12 +943,14 @@ static void test_tcp_tx_full_window_lost(u8_t zero_window_probe_from_unsent)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_tcp_tx_full_window_lost_from_unsent)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_tx_full_window_lost(1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -938,6 +958,7 @@ START_TEST(test_tcp_tx_full_window_lost_from_unacked)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_tx_full_window_lost(0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1059,6 +1080,7 @@ START_TEST(test_tcp_retx_add_to_sent)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1181,6 +1203,7 @@ START_TEST(test_tcp_rto_tracking)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1265,12 +1288,14 @@ static void test_tcp_rto_timeout_impl(int link_down)
     EXPECT(cur != pcb);
   }  
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_tcp_rto_timeout)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_rto_timeout_impl(0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1278,6 +1303,7 @@ START_TEST(test_tcp_rto_timeout_link_down)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_rto_timeout_impl(1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1361,12 +1387,14 @@ static void test_tcp_rto_timeout_syn_sent_impl(int link_down)
     EXPECT(cur != pcb);
   }  
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_tcp_rto_timeout_syn_sent)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_rto_timeout_syn_sent_impl(0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1374,6 +1402,7 @@ START_TEST(test_tcp_rto_timeout_syn_sent_link_down)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_rto_timeout_syn_sent_impl(1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1490,12 +1519,14 @@ static void test_tcp_zwp_timeout_impl(int link_down)
     EXPECT(cur != pcb);
   }  
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 START_TEST(test_tcp_zwp_timeout)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_zwp_timeout_impl(0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1503,6 +1534,7 @@ START_TEST(test_tcp_zwp_timeout_link_down)
 {
   LWIP_UNUSED_ARG(_i);
   test_tcp_zwp_timeout_impl(1);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1661,6 +1693,7 @@ START_TEST(test_tcp_persist_split)
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT_RET(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -1691,5 +1724,6 @@ tcp_suite(void)
     TESTFUNC(test_tcp_zwp_timeout_link_down),
     TESTFUNC(test_tcp_persist_split)
   };
+  __A_VARIABLE = 1;
   return create_suite("TCP", tests, sizeof(tests)/sizeof(testfunc), tcp_setup, tcp_teardown);
 }
diff --git a/test/unit/tcp/test_tcp_oos.c b/test/unit/tcp/test_tcp_oos.c
index dbe1423..d48a415 100644
--- a/test/unit/tcp/test_tcp_oos.c
+++ b/test/unit/tcp/test_tcp_oos.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_tcp_oos.h"
 
 #include "lwip/priv/tcp_priv.h"
@@ -33,6 +35,7 @@ static int tcp_oos_count(struct tcp_pcb* pcb)
     num++;
     seg = seg->next;
   }
+  __A_VARIABLE = 1;
   return num;
 }
 
@@ -46,6 +49,7 @@ static int tcp_oos_pbuf_count(struct tcp_pcb* pcb)
     num += pbuf_clen(seg->p);
     seg = seg->next;
   }
+  __A_VARIABLE = 1;
   return num;
 }
 #endif
@@ -65,12 +69,14 @@ tcp_oos_seg_seqno(struct tcp_pcb* pcb, int seg_index)
   /* then check the actual segment */
   while(seg != NULL) {
     if(num == seg_index) {
+      __A_VARIABLE = 1;
       return seg->tcphdr->seqno;
     }
     num++;
     seg = seg->next;
   }
   fail();
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -89,12 +95,14 @@ tcp_oos_seg_tcplen(struct tcp_pcb* pcb, int seg_index)
   /* then check the actual segment */
   while(seg != NULL) {
     if(num == seg_index) {
+      __A_VARIABLE = 1;
       return TCP_TCPLEN(seg);
     }
     num++;
     seg = seg->next;
   }
   fail();
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -114,6 +122,7 @@ tcp_oos_tcplen(struct tcp_pcb* pcb)
     len += TCP_TCPLEN(seg);
     seg = seg->next;
   }
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -130,6 +139,7 @@ tcp_oos_setup(void)
   netif_default = NULL;
   tcp_remove_all();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -142,6 +152,7 @@ tcp_oos_teardown(void)
   netif_list = old_netif_list;
   netif_default = old_netif_default;
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -280,6 +291,7 @@ START_TEST(test_tcp_recv_ooseq_FIN_OOSEQ)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -450,6 +462,7 @@ START_TEST(test_tcp_recv_ooseq_FIN_INSEQ)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -540,6 +553,7 @@ START_TEST(test_tcp_recv_ooseq_overrun_rxwin)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
 #endif /* !TCP_OOSEQ_MAX_BYTES && !TCP_OOSEQ_MAX_PBUFS */
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -627,6 +641,7 @@ START_TEST(test_tcp_recv_ooseq_overrun_rxwin_edge)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
 #endif /* !TCP_OOSEQ_MAX_BYTES && !TCP_OOSEQ_MAX_PBUFS */
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -702,6 +717,7 @@ START_TEST(test_tcp_recv_ooseq_max_bytes)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
 #endif /* TCP_OOSEQ_MAX_BYTES && (TCP_OOSEQ_MAX_BYTES < (TCP_WND + 1)) && (PBUF_POOL_BUFSIZE >= (TCP_MSS + PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN)) */
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -777,6 +793,7 @@ START_TEST(test_tcp_recv_ooseq_max_pbufs)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
 #endif /* TCP_OOSEQ_MAX_PBUFS && (TCP_OOSEQ_MAX_BYTES < (TCP_WND + 1)) && (PBUF_POOL_BUFSIZE >= (TCP_MSS + PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN)) */
   LWIP_UNUSED_ARG(_i);
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -793,6 +810,7 @@ check_rx_counters(struct tcp_pcb *pcb, struct test_tcp_counters *counters, u32_t
   EXPECT_OOSEQ(tcp_oos_count(pcb) == exp_oos_count);
   oos_len = tcp_oos_tcplen(pcb);
   EXPECT_OOSEQ(exp_oos_len == oos_len);
+  __A_VARIABLE = 1;
 }
 
 /* this test uses 4 packets:
@@ -957,6 +975,7 @@ static void test_tcp_recv_ooseq_double_FINs(int delay_packet)
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 1);
   tcp_abort(pcb);
   EXPECT(MEMP_STATS_GET(used, MEMP_TCP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 /** create multiple segments and pass them to tcp_input with the first segment missing
@@ -1014,5 +1033,6 @@ tcp_oos_suite(void)
     TESTFUNC(test_tcp_recv_ooseq_double_FIN_14),
     TESTFUNC(test_tcp_recv_ooseq_double_FIN_15)
   };
+  __A_VARIABLE = 1;
   return create_suite("TCP_OOS", tests, sizeof(tests)/sizeof(testfunc), tcp_oos_setup, tcp_oos_teardown);
 }
diff --git a/test/unit/udp/test_udp.c b/test/unit/udp/test_udp.c
index b45ce25..d29fb13 100644
--- a/test/unit/udp/test_udp.c
+++ b/test/unit/udp/test_udp.c
@@ -1,3 +1,5 @@
+#include <flexos/isolation.h>
+static volatile int __A_VARIABLE __attribute__((flexos_whitelist));
 #include "test_udp.h"
 
 #include "lwip/udp.h"
@@ -32,6 +34,7 @@ udp_remove_all(void)
     udp_remove(pcb2);
   }
   fail_unless(MEMP_STATS_GET(used, MEMP_UDP_PCB) == 0);
+  __A_VARIABLE = 1;
 }
 
 static err_t
@@ -41,6 +44,7 @@ default_netif_output(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipad
   fail_unless(p != NULL);
   fail_unless(ipaddr != NULL);
   output_ctr++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -50,6 +54,7 @@ default_netif_linkoutput(struct netif *netif, struct pbuf *p)
   fail_unless((netif == &test_netif1) || (netif == &test_netif2));
   fail_unless(p != NULL);
   linkoutput_ctr++;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -62,6 +67,7 @@ default_netif_init(struct netif *netif)
   netif->mtu = 1500;
   netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
   netif->hwaddr_len = 6;
+  __A_VARIABLE = 1;
   return ERR_OK;
 }
 
@@ -95,6 +101,7 @@ default_netif_add(void)
   netif_set_default(&test_netif1);
   netif_set_up(&test_netif1);
   netif_set_up(&test_netif2);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -110,6 +117,7 @@ default_netif_remove(void)
 #else
   fail_unless(netif_list == NULL);
 #endif
+  __A_VARIABLE = 1;
 }
 /* Setups/teardown functions */
 
@@ -119,6 +127,7 @@ udp_setup(void)
   udp_remove_all();
   default_netif_add();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -127,6 +136,7 @@ udp_teardown(void)
   udp_remove_all();
   default_netif_remove();
   lwip_check_ensure_no_alloc(SKIP_POOL(MEMP_SYS_TIMEOUT));
+  __A_VARIABLE = 1;
 }
 
 
@@ -146,6 +156,7 @@ START_TEST(test_udp_new_remove)
     udp_remove(pcb);
     fail_unless(MEMP_STATS_GET(used, MEMP_UDP_PCB) == 0);
   }
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -181,6 +192,7 @@ test_udp_create_test_packet(u16_t length, u16_t port, u32_t dst_addr)
   p = pbuf_alloc(PBUF_TRANSPORT, length, PBUF_POOL);
   fail_unless(p != NULL);
   if (p == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
   }
   fail_unless(p->next == NULL);
@@ -205,6 +217,7 @@ test_udp_create_test_packet(u16_t length, u16_t port, u32_t dst_addr)
   ih->_proto = IP_PROTO_UDP;
   IPH_VHL_SET(ih, 4, sizeof(struct ip_hdr) / 4);
   IPH_CHKSUM_SET(ih, inet_chksum(ih, sizeof(struct ip_hdr)));
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -332,6 +345,7 @@ START_TEST(test_udp_broadcast_rx_with_2_netifs)
   fail_unless(ctr_any.rx_cnt == 0);
 #endif
   ctr2.rx_cnt = ctr2.rx_bytes = 0;
+  __A_VARIABLE = 1;
 }
 END_TEST
 
@@ -343,5 +357,6 @@ udp_suite(void)
     TESTFUNC(test_udp_new_remove),
     TESTFUNC(test_udp_broadcast_rx_with_2_netifs)
   };
+  __A_VARIABLE = 1;
   return create_suite("UDP", tests, sizeof(tests)/sizeof(testfunc), udp_setup, udp_teardown);
 }
-- 
2.34.1

