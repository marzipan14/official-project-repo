From d13e75cb24e99fb435c7b86d9c6b25bd5e6983a8 Mon Sep 17 00:00:00 2001
From: Mateusz Krajewski <mkrajewski413@gmail.com>
Date: Sat, 25 Feb 2023 20:58:26 +0000
Subject: [PATCH 1/1] Touch memory at every exit point newlib

Signed-off-by: Mateusz Krajewski <mkrajewski413@gmail.com>
---
 libgloss/aarch64/_exit.c                      |   2 +
 libgloss/aarch64/_kill.c                      |   1 +
 libgloss/aarch64/ftruncate.c                  |   2 +
 libgloss/aarch64/libcfunc.c                   |   7 +
 libgloss/aarch64/syscalls.c                   |  92 ++++++-
 libgloss/aarch64/truncate.c                   |   2 +
 libgloss/arc/libcfunc.c                       |   7 +
 libgloss/arc/mcount.c                         |  10 +-
 libgloss/arc/nsim-syscalls.c                  |  12 +
 libgloss/arc/sbrk.c                           |   3 +
 libgloss/arm/_exit.c                          |   2 +
 libgloss/arm/_kill.c                          |   2 +
 libgloss/arm/ftruncate.c                      |   2 +
 libgloss/arm/libcfunc.c                       |   7 +
 libgloss/arm/linux-crt0.c                     |   3 +
 libgloss/arm/linux-syscalls1.c                |  17 +-
 libgloss/arm/redboot-syscalls.c               |  33 +++
 libgloss/arm/syscalls.c                       |  79 +++++-
 libgloss/arm/truncate.c                       |   2 +
 libgloss/bfin/_exit.c                         |   2 +
 libgloss/bfin/clear_cache_range.c             |   2 +
 libgloss/bfin/syscalls.c                      |  27 ++-
 libgloss/close.c                              |   2 +
 libgloss/cr16/_exit.c                         |   2 +
 libgloss/cr16/_getenv.c                       |   2 +
 libgloss/cr16/_rename.c                       |   2 +
 libgloss/cr16/close.c                         |   2 +
 libgloss/cr16/dvz_hndl.c                      |   2 +
 libgloss/cr16/flg_hndl.c                      |   2 +
 libgloss/cr16/fstat.c                         |   2 +
 libgloss/cr16/getpid.c                        |   2 +
 libgloss/cr16/iad_hndl.c                      |   2 +
 libgloss/cr16/intable.c                       |   1 +
 libgloss/cr16/isatty.c                        |   2 +
 libgloss/cr16/kill.c                          |   2 +
 libgloss/cr16/lseek.c                         |   2 +
 libgloss/cr16/open.c                          |   3 +
 libgloss/cr16/putnum.c                        |   2 +
 libgloss/cr16/read.c                          |   2 +
 libgloss/cr16/sbrk.c                          |   3 +
 libgloss/cr16/stat.c                          |   2 +
 libgloss/cr16/svc_hndl.c                      |   2 +
 libgloss/cr16/time.c                          |   5 +
 libgloss/cr16/und_hndl.c                      |   2 +
 libgloss/cr16/unlink.c                        |   2 +
 libgloss/cr16/write.c                         |   2 +
 libgloss/cris/crti.c                          |   1 +
 libgloss/cris/crtn.c                          |   1 +
 libgloss/cris/lcrt0.c                         |   2 +
 libgloss/cris/outbyte.c                       |   2 +
 libgloss/crx/_exit.c                          |   2 +
 libgloss/crx/_getenv.c                        |   2 +
 libgloss/crx/_rename.c                        |   2 +
 libgloss/crx/close.c                          |   2 +
 libgloss/crx/dvz_hndl.c                       |   2 +
 libgloss/crx/flg_hndl.c                       |   2 +
 libgloss/crx/fstat.c                          |   2 +
 libgloss/crx/getpid.c                         |   2 +
 libgloss/crx/iad_hndl.c                       |   2 +
 libgloss/crx/intable.c                        |   1 +
 libgloss/crx/isatty.c                         |   2 +
 libgloss/crx/kill.c                           |   2 +
 libgloss/crx/lseek.c                          |   2 +
 libgloss/crx/open.c                           |   3 +
 libgloss/crx/putnum.c                         |   2 +
 libgloss/crx/read.c                           |   2 +
 libgloss/crx/sbrk.c                           |   3 +
 libgloss/crx/stat.c                           |   2 +
 libgloss/crx/svc_hndl.c                       |   2 +
 libgloss/crx/time.c                           |   5 +
 libgloss/crx/und_hndl.c                       |   2 +
 libgloss/crx/unlink.c                         |   2 +
 libgloss/crx/write.c                          |   2 +
 libgloss/d30v/inbyte.c                        |   6 +-
 libgloss/d30v/outbyte.c                       |   2 +
 libgloss/d30v/syscalls.c                      |  19 ++
 libgloss/debug.c                              |   1 +
 libgloss/epiphany/_exit.c                     |   1 +
 libgloss/epiphany/_isatty.c                   |   7 +-
 libgloss/epiphany/access.c                    |  15 +-
 libgloss/epiphany/close.c                     |   1 +
 libgloss/epiphany/environ.c                   |   1 +
 libgloss/epiphany/epiphany-syscalls.c         |   1 +
 libgloss/epiphany/execve.c                    |   1 +
 libgloss/epiphany/fork.c                      |   1 +
 libgloss/epiphany/fstat.c                     |   1 +
 libgloss/epiphany/getpid.c                    |   1 +
 libgloss/epiphany/gettimeofday.c              |   2 +
 libgloss/epiphany/kill.c                      |   1 +
 libgloss/epiphany/link.c                      |   1 +
 libgloss/epiphany/lseek.c                     |   1 +
 libgloss/epiphany/open.c                      |   1 +
 libgloss/epiphany/read.c                      |   1 +
 libgloss/epiphany/sbrk.c                      |   1 +
 libgloss/epiphany/stat.c                      |   1 +
 libgloss/epiphany/times.c                     |   1 +
 libgloss/epiphany/unlink.c                    |   1 +
 libgloss/epiphany/wait.c                      |   1 +
 libgloss/epiphany/write.c                     |   1 +
 libgloss/fr30/syscalls.c                      |  15 ++
 libgloss/frv/fstat.c                          |   2 +
 libgloss/frv/getpid.c                         |   2 +
 libgloss/frv/isatty.c                         |   2 +
 libgloss/frv/kill.c                           |   2 +
 libgloss/frv/print.c                          |   2 +
 libgloss/frv/putnum.c                         |   2 +
 libgloss/frv/sbrk.c                           |   2 +
 libgloss/frv/sim-inbyte.c                     |   6 +-
 libgloss/frv/sim-time.c                       |   4 +
 libgloss/frv/stat.c                           |   2 +
 libgloss/fstat.c                              |   2 +
 libgloss/ft32/fstat.c                         |   2 +
 libgloss/ft32/getpid.c                        |   2 +
 libgloss/ft32/isatty.c                        |   2 +
 libgloss/ft32/kill.c                          |   2 +
 libgloss/ft32/sbrk.c                          |   1 +
 libgloss/ft32/sim-inbyte.c                    |   6 +-
 libgloss/ft32/sim-lseek.c                     |   2 +
 libgloss/ft32/sim-time.c                      |   3 +
 libgloss/ft32/stat.c                          |   2 +
 libgloss/getpid.c                             |   2 +
 libgloss/hp74x/checksum.c                     |   1 +
 libgloss/hp74x/io.c                           |  21 +-
 libgloss/hp74x/pa_stub.c                      |  44 +++-
 libgloss/hp74x/test.c                         |   3 +
 libgloss/i386/cygmon-gmon.c                   |  11 +-
 libgloss/i386/cygmon-salib.c                  |  18 +-
 libgloss/i960/crt0.c                          |   5 +
 libgloss/i960/mon-read.c                      |   1 +
 libgloss/i960/mon-write.c                     |   3 +
 libgloss/i960/mon960.c                        |  11 +
 libgloss/iq2000/_exit.c                       |   3 +
 libgloss/iq2000/access.c                      |  15 +-
 libgloss/iq2000/chmod.c                       |   2 +
 libgloss/iq2000/chown.c                       |   2 +
 libgloss/iq2000/close.c                       |   2 +
 libgloss/iq2000/creat.c                       |   2 +
 libgloss/iq2000/crt1.c                        |   2 +
 libgloss/iq2000/execv.c                       |   2 +
 libgloss/iq2000/execve.c                      |   2 +
 libgloss/iq2000/fork.c                        |   2 +
 libgloss/iq2000/fstat.c                       |   2 +
 libgloss/iq2000/getpid.c                      |   2 +
 libgloss/iq2000/gettime.c                     |   2 +
 libgloss/iq2000/isatty.c                      |   1 +
 libgloss/iq2000/kill.c                        |   1 +
 libgloss/iq2000/lseek.c                       |   2 +
 libgloss/iq2000/open.c                        |   2 +
 libgloss/iq2000/pipe.c                        |   2 +
 libgloss/iq2000/read.c                        |   2 +
 libgloss/iq2000/sbrk.c                        |   3 +
 libgloss/iq2000/stat.c                        |   2 +
 libgloss/iq2000/test.c                        |   5 +
 libgloss/iq2000/time.c                        |   2 +
 libgloss/iq2000/times.c                       |   2 +
 libgloss/iq2000/trap.c                        |   2 +
 libgloss/iq2000/unlink.c                      |   2 +
 libgloss/iq2000/utime.c                       |   2 +
 libgloss/iq2000/wait.c                        |   2 +
 libgloss/iq2000/write.c                       |   2 +
 libgloss/isatty.c                             |   2 +
 libgloss/kill.c                               |   2 +
 libgloss/libnosys/_exit.c                     |   2 +
 libgloss/libnosys/chown.c                     |   2 +
 libgloss/libnosys/close.c                     |   2 +
 libgloss/libnosys/environ.c                   |   1 +
 libgloss/libnosys/errno.c                     |   1 +
 libgloss/libnosys/execve.c                    |   2 +
 libgloss/libnosys/fork.c                      |   2 +
 libgloss/libnosys/fstat.c                     |   2 +
 libgloss/libnosys/getpid.c                    |   2 +
 libgloss/libnosys/gettod.c                    |   2 +
 libgloss/libnosys/isatty.c                    |   2 +
 libgloss/libnosys/kill.c                      |   2 +
 libgloss/libnosys/link.c                      |   2 +
 libgloss/libnosys/lseek.c                     |   2 +
 libgloss/libnosys/open.c                      |   2 +
 libgloss/libnosys/read.c                      |   2 +
 libgloss/libnosys/readlink.c                  |   2 +
 libgloss/libnosys/sbrk.c                      |   2 +
 libgloss/libnosys/stat.c                      |   2 +
 libgloss/libnosys/symlink.c                   |   2 +
 libgloss/libnosys/times.c                     |   2 +
 libgloss/libnosys/unlink.c                    |   2 +
 libgloss/libnosys/wait.c                      |   2 +
 libgloss/libnosys/write.c                     |   2 +
 libgloss/lm32/isatty.c                        |   1 +
 libgloss/lseek.c                              |   2 +
 libgloss/m32c/sample.c                        |   5 +
 libgloss/m32c/sbrk.c                          |   2 +
 libgloss/m32r/chmod.c                         |   2 +
 libgloss/m32r/close.c                         |   2 +
 libgloss/m32r/exit.c                          |   2 +
 libgloss/m32r/fstat.c                         |   2 +
 libgloss/m32r/getpid.c                        |   2 +
 libgloss/m32r/isatty.c                        |   2 +
 libgloss/m32r/kill.c                          |   1 +
 libgloss/m32r/lseek.c                         |   2 +
 libgloss/m32r/m32r-lib.c                      |   9 +
 libgloss/m32r/m32r-stub.c                     | 131 ++++++++--
 libgloss/m32r/open.c                          |   2 +
 libgloss/m32r/raise.c                         |   2 +
 libgloss/m32r/read.c                          |   2 +
 libgloss/m32r/sbrk.c                          |   1 +
 libgloss/m32r/stat.c                          |   2 +
 libgloss/m32r/trapmon0.c                      |   2 +
 libgloss/m32r/unlink.c                        |   2 +
 libgloss/m32r/utime.c                         |   2 +
 libgloss/m32r/write.c                         |   2 +
 libgloss/m68hc11/syscalls.c                   |   4 +
 libgloss/m68k/cf-crt1.c                       |   3 +
 libgloss/m68k/cf-exit.c                       |   2 +
 libgloss/m68k/cf-isrs.c                       |   1 +
 libgloss/m68k/cf-sbrk.c                       |   3 +
 libgloss/m68k/fido-_exit.c                    |   2 +
 libgloss/m68k/fido-handler.c                  |   2 +
 libgloss/m68k/fido-sbrk.c                     |   6 +-
 libgloss/m68k/idp-inbyte.c                    |   2 +
 libgloss/m68k/idp-outbyte.c                   |   3 +
 libgloss/m68k/io-close.c                      |   1 +
 libgloss/m68k/io-exit.c                       |   2 +
 libgloss/m68k/io-fstat.c                      |   1 +
 libgloss/m68k/io-gdb.c                        |  66 ++++--
 libgloss/m68k/io-gettimeofday.c               |   1 +
 libgloss/m68k/io-isatty.c                     |   1 +
 libgloss/m68k/io-lseek.c                      |   1 +
 libgloss/m68k/io-open.c                       |   1 +
 libgloss/m68k/io-read.c                       |   1 +
 libgloss/m68k/io-rename.c                     |   1 +
 libgloss/m68k/io-stat.c                       |   1 +
 libgloss/m68k/io-system.c                     |   1 +
 libgloss/m68k/io-time.c                       |   1 +
 libgloss/m68k/io-unlink.c                     |   1 +
 libgloss/m68k/io-write.c                      |   1 +
 libgloss/m68k/leds.c                          |   2 +
 libgloss/m68k/mc68ec.c                        |   3 +
 libgloss/m68k/mvme-stub.c                     |  35 ++-
 libgloss/m68k/sim-abort.c                     |   2 +
 libgloss/m68k/sim-errno.c                     |   2 +
 libgloss/m68k/sim-funcs.c                     |   3 +
 libgloss/m68k/sim-inbyte.c                    |   6 +-
 libgloss/m68k/sim-print.c                     |   3 +
 libgloss/m68k/sim-sbrk.c                      |   6 +-
 libgloss/m68k/test.c                          |   2 +
 libgloss/mcore/close.c                        |   2 +
 libgloss/mcore/cmb-exit.c                     |   2 +
 libgloss/mcore/cmb-inbyte.c                   |   2 +
 libgloss/mcore/cmb-outbyte.c                  |   2 +
 libgloss/mcore/fstat.c                        |   2 +
 libgloss/mcore/getpid.c                       |   2 +
 libgloss/mcore/kill.c                         |   2 +
 libgloss/mcore/lseek.c                        |   2 +
 libgloss/mcore/open.c                         |   2 +
 libgloss/mcore/print.c                        |   2 +
 libgloss/mcore/putnum.c                       |   2 +
 libgloss/mcore/raise.c                        |   2 +
 libgloss/mcore/read.c                         |   2 +
 libgloss/mcore/sbrk.c                         |   2 +
 libgloss/mcore/stat.c                         |   2 +
 libgloss/mcore/unlink.c                       |   2 +
 libgloss/mcore/write.c                        |   2 +
 libgloss/mep/h_reset.c                        |   1 +
 libgloss/mep/handlers.c                       |  41 ++++
 libgloss/mep/isatty.c                         |   1 +
 libgloss/mep/mep-bb.c                         |  33 ++-
 libgloss/mep/mep-gmon.c                       |  12 +-
 libgloss/mep/read.c                           |   3 +
 libgloss/mep/sbrk.c                           |   3 +
 libgloss/mep/write.c                          |   3 +
 libgloss/microblaze/linux-inbyte.c            |   2 +
 libgloss/microblaze/linux-outbyte.c           |   2 +
 libgloss/microblaze/linux-syscalls-wrap.c     |   2 +
 libgloss/microblaze/sbrk.c                    |   1 +
 libgloss/microblaze/timer.c                   |   2 +
 libgloss/microblaze/xil_malloc.c              |  69 ++++--
 libgloss/microblaze/xil_printf.c              |   6 +
 libgloss/microblaze/xil_sbrk.c                |   6 +-
 libgloss/mips/array-io.c                      |   5 +
 libgloss/mips/cfe.c                           |   6 +
 libgloss/mips/cfe_api.c                       |  61 ++++-
 libgloss/mips/cfe_mem.c                       |   4 +
 libgloss/mips/cma101.c                        |  19 +-
 libgloss/mips/cygmon.c                        |   7 +
 libgloss/mips/dvemon.c                        |   4 +
 libgloss/mips/jmr3904-io.c                    |   6 +
 libgloss/mips/nullmon.c                       |  11 +-
 libgloss/mips/syscalls.c                      |   6 +-
 libgloss/mips/test.c                          |   2 +
 libgloss/mn10200/_exit.c                      |   3 +
 libgloss/mn10200/access.c                     |  15 +-
 libgloss/mn10200/chmod.c                      |   2 +
 libgloss/mn10200/chown.c                      |   2 +
 libgloss/mn10200/close.c                      |   2 +
 libgloss/mn10200/creat.c                      |   2 +
 libgloss/mn10200/crt1.c                       |   2 +
 libgloss/mn10200/execv.c                      |   2 +
 libgloss/mn10200/execve.c                     |   2 +
 libgloss/mn10200/fork.c                       |   2 +
 libgloss/mn10200/fstat.c                      |   2 +
 libgloss/mn10200/getpid.c                     |   2 +
 libgloss/mn10200/gettime.c                    |   2 +
 libgloss/mn10200/isatty.c                     |   1 +
 libgloss/mn10200/kill.c                       |   1 +
 libgloss/mn10200/lseek.c                      |   2 +
 libgloss/mn10200/open.c                       |   2 +
 libgloss/mn10200/pipe.c                       |   2 +
 libgloss/mn10200/read.c                       |   2 +
 libgloss/mn10200/sbrk.c                       |   2 +
 libgloss/mn10200/stat.c                       |   2 +
 libgloss/mn10200/test.c                       |   5 +
 libgloss/mn10200/time.c                       |   2 +
 libgloss/mn10200/times.c                      |   2 +
 libgloss/mn10200/unlink.c                     |   2 +
 libgloss/mn10200/utime.c                      |   2 +
 libgloss/mn10200/wait.c                       |   2 +
 libgloss/mn10200/write.c                      |   2 +
 libgloss/mn10300/_exit.c                      |   3 +
 libgloss/mn10300/access.c                     |  15 +-
 libgloss/mn10300/chmod.c                      |   2 +
 libgloss/mn10300/chown.c                      |   2 +
 libgloss/mn10300/close.c                      |   2 +
 libgloss/mn10300/creat.c                      |   2 +
 libgloss/mn10300/crt1.c                       |   2 +
 libgloss/mn10300/cygmon.c                     |   3 +
 libgloss/mn10300/execv.c                      |   2 +
 libgloss/mn10300/execve.c                     |   2 +
 libgloss/mn10300/fork.c                       |   2 +
 libgloss/mn10300/fstat.c                      |   2 +
 libgloss/mn10300/getpid.c                     |   2 +
 libgloss/mn10300/gettime.c                    |   2 +
 libgloss/mn10300/isatty.c                     |   1 +
 libgloss/mn10300/kill.c                       |   1 +
 libgloss/mn10300/lseek.c                      |   2 +
 libgloss/mn10300/open.c                       |   2 +
 libgloss/mn10300/pipe.c                       |   2 +
 libgloss/mn10300/read.c                       |   2 +
 libgloss/mn10300/sbrk.c                       |   2 +
 libgloss/mn10300/stat.c                       |   2 +
 libgloss/mn10300/test.c                       |   5 +
 libgloss/mn10300/time.c                       |   2 +
 libgloss/mn10300/times.c                      |   2 +
 libgloss/mn10300/unlink.c                     |   2 +
 libgloss/mn10300/utime.c                      |   2 +
 libgloss/mn10300/wait.c                       |   2 +
 libgloss/mn10300/write.c                      |   2 +
 libgloss/moxie/fstat.c                        |   2 +
 libgloss/moxie/getpid.c                       |   2 +
 libgloss/moxie/isatty.c                       |   2 +
 libgloss/moxie/kill.c                         |   2 +
 libgloss/moxie/print.c                        |   2 +
 libgloss/moxie/putnum.c                       |   2 +
 libgloss/moxie/qemu-time.c                    |   6 +
 libgloss/moxie/qemu-write.c                   |   2 +
 libgloss/moxie/sbrk.c                         |   2 +
 libgloss/moxie/sim-inbyte.c                   |   6 +-
 libgloss/moxie/sim-lseek.c                    |   2 +
 libgloss/moxie/sim-time.c                     |   4 +
 libgloss/moxie/stat.c                         |   2 +
 libgloss/msp430/sbrk.c                        |   2 +
 libgloss/msp430/unlink.c                      |   6 +-
 libgloss/msp430/write.c                       |   7 +-
 libgloss/mt/access.c                          |  15 +-
 libgloss/mt/chmod.c                           |   2 +
 libgloss/mt/close.c                           |   2 +
 libgloss/mt/exit-16-002.c                     |   2 +
 libgloss/mt/exit-16-003.c                     |   2 +
 libgloss/mt/exit-64-001.c                     |   2 +
 libgloss/mt/exit-ms2.c                        |   2 +
 libgloss/mt/exit.c                            |   2 +
 libgloss/mt/fstat.c                           |   2 +
 libgloss/mt/getpid.c                          |   2 +
 libgloss/mt/gettime.c                         |   2 +
 libgloss/mt/isatty.c                          |   1 +
 libgloss/mt/kill.c                            |   1 +
 libgloss/mt/lseek.c                           |   2 +
 libgloss/mt/open.c                            |   2 +
 libgloss/mt/read.c                            |   2 +
 libgloss/mt/sbrk.c                            |   2 +
 libgloss/mt/stat.c                            |   2 +
 libgloss/mt/time.c                            |   2 +
 libgloss/mt/times.c                           |   2 +
 libgloss/mt/unlink.c                          |   2 +
 libgloss/mt/utime.c                           |   2 +
 libgloss/mt/write.c                           |   2 +
 libgloss/open.c                               |   2 +
 libgloss/or1k/boards/tmpl.c                   |   3 +
 libgloss/or1k/exceptions.c                    |   2 +
 libgloss/or1k/impure.c                        |   4 +
 libgloss/or1k/interrupts.c                    |   5 +
 libgloss/or1k/or1k_uart.c                     |   7 +
 libgloss/or1k/sbrk.c                          |   2 +
 libgloss/or1k/syscalls.c                      |  18 ++
 libgloss/or1k/timer.c                         |  14 ++
 libgloss/or1k/util.c                          |   4 +
 libgloss/pa/op50nled.c                        |   4 +
 libgloss/pa/test.c                            |   2 +
 libgloss/pa/w89k-io.c                         |   5 +
 libgloss/print.c                              |   2 +
 libgloss/putnum.c                             |   2 +
 libgloss/read.c                               |   2 +
 libgloss/riscv/syscalls.c                     |  43 +++-
 libgloss/rl78/mcount.c                        |  10 +-
 libgloss/rl78/sbrk.c                          |   3 +
 libgloss/rl78/write.c                         |   8 +-
 libgloss/rs6000/ads-io.c                      |   6 +
 libgloss/rs6000/mbx-exit.c                    |   2 +
 libgloss/rs6000/mbx-inbyte.c                  |   6 +-
 libgloss/rs6000/mbx-outbyte.c                 |   3 +
 libgloss/rs6000/mbx-print.c                   |   2 +
 libgloss/rs6000/mvme-errno.c                  |   2 +
 libgloss/rs6000/mvme-print.c                  |   3 +
 libgloss/rs6000/mvme-read.c                   |   1 +
 libgloss/rs6000/sim-abort.c                   |   2 +
 libgloss/rs6000/sim-errno.c                   |   2 +
 libgloss/rs6000/sim-inbyte.c                  |   6 +-
 libgloss/rs6000/sim-print.c                   |   3 +
 libgloss/rs6000/sim-sbrk.c                    |   6 +-
 libgloss/rs6000/sim-times.c                   |   2 +
 libgloss/rs6000/sol-cfuncs.c                  |  21 +-
 libgloss/rs6000/test.c                        |   2 +
 libgloss/rx/mcount.c                          |  10 +-
 libgloss/rx/sbrk.c                            |   2 +
 libgloss/sbrk.c                               |   2 +
 libgloss/sparc/cache.c                        |   4 +
 libgloss/sparc/cygmon-salib.c                 |  32 ++-
 libgloss/sparc/erc32-io.c                     |   3 +
 libgloss/sparc/erc32-stub.c                   |  12 +-
 libgloss/sparc/fixctors.c                     |   4 +
 libgloss/sparc/libsys/isatty.c                |  10 +-
 libgloss/sparc/salib-701.c                    |  13 +
 libgloss/sparc/salib.c                        |   8 +
 libgloss/sparc/sparc-stub.c                   |  45 +++-
 libgloss/sparc/sparcl-stub.c                  |  49 +++-
 libgloss/sparc/sparclet-stub.c                |  48 +++-
 libgloss/sparc/sysc-701.c                     |   8 +
 libgloss/sparc/syscalls.c                     |  10 +
 libgloss/sparc/test.c                         |   3 +
 libgloss/sparc_leon/_exit.c                   |   2 +
 libgloss/sparc_leon/amba.c                    |   5 +
 libgloss/sparc_leon/amba_dbg.c                |   3 +
 libgloss/sparc_leon/amba_driver.c             |   3 +
 libgloss/sparc_leon/amba_scan.c               |   6 +
 libgloss/sparc_leon/catch_interrupt.c         |   9 +-
 libgloss/sparc_leon/catch_interrupt_mvt.c     |   4 +
 libgloss/sparc_leon/catch_interrupt_pending.c |   3 +
 libgloss/sparc_leon/catch_interrupt_svt.c     |   6 +
 libgloss/sparc_leon/console.c                 |   1 +
 libgloss/sparc_leon/console_dbg.c             |   6 +
 libgloss/sparc_leon/console_init.c            |   2 +
 libgloss/sparc_leon/contextswitch.c           |   3 +
 libgloss/sparc_leon/gettimeofday.c            |  16 +-
 libgloss/sparc_leon/initcalls.c               |   2 +
 libgloss/sparc_leon/io.c                      |   7 +-
 libgloss/sparc_leon/jiffies.c                 |   1 +
 libgloss/sparc_leon/kernel.c                  |   5 +
 libgloss/sparc_leon/kernel_debug.c            |   4 +
 libgloss/sparc_leon/kernel_debug_var.c        |   1 +
 libgloss/sparc_leon/kernel_mm.c               |   1 +
 libgloss/sparc_leon/kernel_mutex.c            |   4 +
 libgloss/sparc_leon/kernel_queue.c            |   1 +
 libgloss/sparc_leon/kernel_sched.c            |   3 +
 libgloss/sparc_leon/kernel_thread.c           |   6 +
 libgloss/sparc_leon/locore_atexit.c           |   3 +
 libgloss/sparc_leon/mutex.c                   |  15 ++
 libgloss/sparc_leon/pnpinit.c                 |  14 +-
 libgloss/sparc_leon/pnpinit_malloc.c          |  77 ++++--
 libgloss/sparc_leon/pnpinit_simple.c          |   2 +
 libgloss/sparc_leon/regwin_patch.c            |   4 +
 libgloss/sparc_leon/rtc.c                     |   1 +
 libgloss/sparc_leon/timer.c                   |   5 +
 libgloss/sparc_leon/times.c                   |   7 +-
 libgloss/spu/access.c                         |   2 +
 libgloss/spu/chdir.c                          |   2 +
 libgloss/spu/chmod.c                          |   2 +
 libgloss/spu/chown.c                          |   2 +
 libgloss/spu/close.c                          |   2 +
 libgloss/spu/conv_stat.c                      |   2 +
 libgloss/spu/dirfuncs.c                       |   8 +
 libgloss/spu/dup.c                            |   2 +
 libgloss/spu/dup2.c                           |   2 +
 libgloss/spu/exit.c                           |   2 +
 libgloss/spu/fchdir.c                         |   2 +
 libgloss/spu/fchmod.c                         |   2 +
 libgloss/spu/fchown.c                         |   2 +
 libgloss/spu/fdatasync.c                      |   2 +
 libgloss/spu/fstat.c                          |   2 +
 libgloss/spu/fsync.c                          |   2 +
 libgloss/spu/ftruncate.c                      |   2 +
 libgloss/spu/getcwd.c                         |   4 +
 libgloss/spu/getitimer.c                      |   2 +
 libgloss/spu/getpagesize.c                    |   1 +
 libgloss/spu/getpid.c                         |   2 +
 libgloss/spu/gettimeofday.c                   |   2 +
 libgloss/spu/isatty.c                         |   2 +
 libgloss/spu/kill.c                           |   2 +
 libgloss/spu/lchown.c                         |   2 +
 libgloss/spu/link.c                           |   2 +
 libgloss/spu/linux_getpid.c                   |   2 +
 libgloss/spu/linux_gettid.c                   |   2 +
 libgloss/spu/linux_syscalls.c                 |   1 +
 libgloss/spu/lockf.c                          |   2 +
 libgloss/spu/lseek.c                          |   2 +
 libgloss/spu/lstat.c                          |   2 +
 libgloss/spu/mkdir.c                          |   2 +
 libgloss/spu/mknod.c                          |   2 +
 libgloss/spu/mkstemp.c                        |   2 +
 libgloss/spu/mktemp.c                         |   2 +
 libgloss/spu/mmap_eaddr.c                     |   2 +
 libgloss/spu/mremap_eaddr.c                   |   2 +
 libgloss/spu/msync_eaddr.c                    |   2 +
 libgloss/spu/munmap_eaddr.c                   |   2 +
 libgloss/spu/nanosleep.c                      |   2 +
 libgloss/spu/open.c                           |   2 +
 libgloss/spu/pread.c                          |   2 +
 libgloss/spu/pwrite.c                         |   2 +
 libgloss/spu/read.c                           |   2 +
 libgloss/spu/readlink.c                       |   2 +
 libgloss/spu/readv.c                          |   2 +
 libgloss/spu/rmdir.c                          |   2 +
 libgloss/spu/sbrk.c                           |   1 +
 libgloss/spu/sched_yield.c                    |   2 +
 libgloss/spu/setitimer.c                      |   2 +
 libgloss/spu/shm_open.c                       |   2 +
 libgloss/spu/shm_unlink.c                     |   2 +
 libgloss/spu/stat.c                           |   2 +
 libgloss/spu/symlink.c                        |   2 +
 libgloss/spu/sync.c                           |   2 +
 libgloss/spu/syscalls.c                       |   1 +
 libgloss/spu/times.c                          |   2 +
 libgloss/spu/truncate.c                       |   2 +
 libgloss/spu/umask.c                          |   2 +
 libgloss/spu/unlink.c                         |   2 +
 libgloss/spu/utime.c                          |   2 +
 libgloss/spu/utimes.c                         |   2 +
 libgloss/spu/write.c                          |   2 +
 libgloss/spu/writev.c                         |   2 +
 libgloss/stat.c                               |   2 +
 libgloss/testsuite/config/support.c           |   1 +
 libgloss/testsuite/libgloss.all/array.c       |   2 +
 libgloss/testsuite/libgloss.all/div.c         |   2 +
 libgloss/testsuite/libgloss.all/double.c      |   3 +
 libgloss/testsuite/libgloss.all/float.c       |   2 +
 libgloss/testsuite/libgloss.all/func.c        |   3 +
 libgloss/testsuite/libgloss.all/io.c          |   2 +
 libgloss/testsuite/libgloss.all/math.c        |   3 +
 libgloss/testsuite/libgloss.all/memory.c      |   2 +
 libgloss/testsuite/libgloss.all/misc.c        |   6 +
 libgloss/testsuite/libgloss.all/printf.c      |   2 +
 libgloss/testsuite/libgloss.all/struct.c      |   5 +
 libgloss/testsuite/libgloss.all/varargs.c     |   4 +
 libgloss/testsuite/libgloss.all/varargs2.c    |   3 +
 libgloss/tic6x/getpid.c                       |   2 +
 libgloss/tic6x/kill.c                         |   2 +
 libgloss/tic6x/sbrk.c                         |   3 +
 libgloss/tic6x/syscalls.c                     |  19 +-
 libgloss/unlink.c                             |   2 +
 libgloss/v850/_exit.c                         |   3 +
 libgloss/v850/access.c                        |  15 +-
 libgloss/v850/chmod.c                         |   2 +
 libgloss/v850/chown.c                         |   2 +
 libgloss/v850/close.c                         |   2 +
 libgloss/v850/creat.c                         |   2 +
 libgloss/v850/crt1.c                          |   2 +
 libgloss/v850/execv.c                         |   2 +
 libgloss/v850/execve.c                        |   2 +
 libgloss/v850/fork.c                          |   2 +
 libgloss/v850/fstat.c                         |   2 +
 libgloss/v850/getpid.c                        |   2 +
 libgloss/v850/gettime.c                       |   2 +
 libgloss/v850/isatty.c                        |   1 +
 libgloss/v850/kill.c                          |   1 +
 libgloss/v850/link.c                          |   2 +
 libgloss/v850/lseek.c                         |   2 +
 libgloss/v850/open.c                          |   2 +
 libgloss/v850/pipe.c                          |   2 +
 libgloss/v850/read.c                          |   2 +
 libgloss/v850/sbrk.c                          |   2 +
 libgloss/v850/stat.c                          |   2 +
 libgloss/v850/time.c                          |   2 +
 libgloss/v850/times.c                         |   2 +
 libgloss/v850/unlink.c                        |   2 +
 libgloss/v850/utime.c                         |   2 +
 libgloss/v850/wait.c                          |   2 +
 libgloss/v850/write.c                         |   2 +
 libgloss/visium/_exit.c                       |   2 +
 libgloss/visium/gettod.c                      |   3 +
 libgloss/visium/io-gdb.c                      |  66 ++++--
 libgloss/visium/io-stubs.c                    |  21 ++
 libgloss/visium/sbrk.c                        |   3 +
 libgloss/visium/serial-inbyte.c               |   2 +
 libgloss/visium/serial-outbyte.c              |   2 +
 libgloss/visium/syscalls.c                    |  17 ++
 libgloss/write.c                              |   2 +
 libgloss/xc16x/create.c                       |   2 +
 libgloss/xc16x/getchar1.c                     |   2 +
 libgloss/xc16x/isatty.c                       |   2 +
 libgloss/xc16x/lseek.c                        |   2 +
 libgloss/xc16x/mem-layout.c                   |   1 +
 libgloss/xc16x/misc.c                         |   4 +
 libgloss/xc16x/open.c                         |   2 +
 libgloss/xc16x/read.c                         |   2 +
 libgloss/xc16x/sbrk.c                         |   2 +
 libgloss/xc16x/syscalls.c                     |   3 +
 libgloss/xc16x/trap_handle.c                  |   6 +
 libgloss/xc16x/write.c                        |   2 +
 libgloss/xstormy16/close.c                    |   2 +
 libgloss/xstormy16/eva_app.c                  |  10 +-
 libgloss/xstormy16/fstat.c                    |   2 +
 libgloss/xstormy16/getpid.c                   |   2 +
 libgloss/xstormy16/isatty.c                   |   2 +
 libgloss/xstormy16/kill.c                     |   2 +
 libgloss/xstormy16/lseek.c                    |   2 +
 libgloss/xstormy16/open.c                     |   2 +
 libgloss/xstormy16/stat.c                     |   2 +
 libgloss/xstormy16/unlink.c                   |   2 +
 libgloss/xstormy16/xstormy16_stub.c           |  84 +++++--
 newlib/doc/makedoc.c                          |  62 ++++-
 newlib/iconvdata/dummy.c                      |   1 +
 newlib/iconvdata/euc-jp.c                     |   1 +
 newlib/iconvdata/jis0201.c                    |   1 +
 newlib/iconvdata/jis0208.c                    |   1 +
 newlib/iconvdata/jis0212.c                    |   1 +
 newlib/iconvdata/sjis.c                       |   1 +
 newlib/libc/argz/argz_add.c                   |  10 +-
 newlib/libc/argz/argz_add_sep.c               |   6 +-
 newlib/libc/argz/argz_append.c                |   6 +-
 newlib/libc/argz/argz_count.c                 |   2 +
 newlib/libc/argz/argz_create.c                |   7 +-
 newlib/libc/argz/argz_create_sep.c            |   7 +-
 newlib/libc/argz/argz_delete.c                |   6 +-
 newlib/libc/argz/argz_extract.c               |   2 +
 newlib/libc/argz/argz_insert.c                |  14 +-
 newlib/libc/argz/argz_next.c                  |   1 +
 newlib/libc/argz/argz_replace.c               |   7 +-
 newlib/libc/argz/argz_stringify.c             |   2 +
 newlib/libc/argz/buf_findstr.c                |   3 +
 newlib/libc/argz/dummy.c                      |   1 +
 newlib/libc/argz/envz_add.c                   |   1 +
 newlib/libc/argz/envz_entry.c                 |   3 +
 newlib/libc/argz/envz_get.c                   |   1 +
 newlib/libc/argz/envz_merge.c                 |   2 +
 newlib/libc/argz/envz_remove.c                |   2 +
 newlib/libc/argz/envz_strip.c                 |   2 +
 newlib/libc/ctype/ctype_.c                    |   2 +
 newlib/libc/ctype/isalnum.c                   |   2 +
 newlib/libc/ctype/isalnum_l.c                 |   2 +
 newlib/libc/ctype/isalpha.c                   |   2 +
 newlib/libc/ctype/isalpha_l.c                 |   2 +
 newlib/libc/ctype/isascii.c                   |   2 +
 newlib/libc/ctype/isascii_l.c                 |   2 +
 newlib/libc/ctype/isblank.c                   |   2 +
 newlib/libc/ctype/isblank_l.c                 |   2 +
 newlib/libc/ctype/iscntrl.c                   |   2 +
 newlib/libc/ctype/iscntrl_l.c                 |   2 +
 newlib/libc/ctype/isdigit.c                   |   2 +
 newlib/libc/ctype/isdigit_l.c                 |   2 +
 newlib/libc/ctype/islower.c                   |   2 +
 newlib/libc/ctype/islower_l.c                 |   2 +
 newlib/libc/ctype/isprint.c                   |   3 +
 newlib/libc/ctype/isprint_l.c                 |   3 +
 newlib/libc/ctype/ispunct.c                   |   2 +
 newlib/libc/ctype/ispunct_l.c                 |   2 +
 newlib/libc/ctype/isspace.c                   |   2 +
 newlib/libc/ctype/isspace_l.c                 |   2 +
 newlib/libc/ctype/isupper.c                   |   2 +
 newlib/libc/ctype/isupper_l.c                 |   2 +
 newlib/libc/ctype/iswalnum.c                  |   2 +
 newlib/libc/ctype/iswalnum_l.c                |   2 +
 newlib/libc/ctype/iswalpha.c                  |  20 +-
 newlib/libc/ctype/iswalpha_l.c                |   2 +
 newlib/libc/ctype/iswblank.c                  |   2 +
 newlib/libc/ctype/iswblank_l.c                |   2 +
 newlib/libc/ctype/iswcntrl.c                  |   2 +
 newlib/libc/ctype/iswcntrl_l.c                |   2 +
 newlib/libc/ctype/iswctype.c                  |  14 ++
 newlib/libc/ctype/iswctype_l.c                |   2 +
 newlib/libc/ctype/iswdigit.c                  |   2 +
 newlib/libc/ctype/iswdigit_l.c                |   2 +
 newlib/libc/ctype/iswgraph.c                  |   2 +
 newlib/libc/ctype/iswgraph_l.c                |   2 +
 newlib/libc/ctype/iswlower.c                  |   2 +
 newlib/libc/ctype/iswlower_l.c                |   2 +
 newlib/libc/ctype/iswprint.c                  |  20 +-
 newlib/libc/ctype/iswprint_l.c                |   2 +
 newlib/libc/ctype/iswpunct.c                  |   2 +
 newlib/libc/ctype/iswpunct_l.c                |   2 +
 newlib/libc/ctype/iswspace.c                  |   2 +
 newlib/libc/ctype/iswspace_l.c                |   2 +
 newlib/libc/ctype/iswupper.c                  |   2 +
 newlib/libc/ctype/iswupper_l.c                |   2 +
 newlib/libc/ctype/iswxdigit.c                 |   2 +
 newlib/libc/ctype/iswxdigit_l.c               |   2 +
 newlib/libc/ctype/isxdigit.c                  |   2 +
 newlib/libc/ctype/isxdigit_l.c                |   2 +
 newlib/libc/ctype/jp2uc.c                     |   2 +
 newlib/libc/ctype/toascii.c                   |   2 +
 newlib/libc/ctype/toascii_l.c                 |   2 +
 newlib/libc/ctype/tolower.c                   |   1 +
 newlib/libc/ctype/tolower_l.c                 |   1 +
 newlib/libc/ctype/toupper.c                   |   1 +
 newlib/libc/ctype/toupper_l.c                 |   1 +
 newlib/libc/ctype/towctrans.c                 |   2 +
 newlib/libc/ctype/towctrans_l.c               |   2 +
 newlib/libc/ctype/towlower.c                  |   1 +
 newlib/libc/ctype/towlower_l.c                |   2 +
 newlib/libc/ctype/towupper.c                  |   1 +
 newlib/libc/ctype/towupper_l.c                |   2 +
 newlib/libc/ctype/wctrans.c                   |   2 +
 newlib/libc/ctype/wctrans_l.c                 |   2 +
 newlib/libc/ctype/wctype.c                    |   2 +
 newlib/libc/ctype/wctype_l.c                  |   2 +
 newlib/libc/errno/errno.c                     |   2 +
 newlib/libc/iconv/ccs/big5.c                  |   1 +
 newlib/libc/iconv/ccs/ccsbi.c                 |   1 +
 newlib/libc/iconv/ccs/cns11643_plane1.c       |   1 +
 newlib/libc/iconv/ccs/cns11643_plane14.c      |   1 +
 newlib/libc/iconv/ccs/cns11643_plane2.c       |   1 +
 newlib/libc/iconv/ccs/cp775.c                 |   1 +
 newlib/libc/iconv/ccs/cp850.c                 |   1 +
 newlib/libc/iconv/ccs/cp852.c                 |   1 +
 newlib/libc/iconv/ccs/cp855.c                 |   1 +
 newlib/libc/iconv/ccs/cp866.c                 |   1 +
 newlib/libc/iconv/ccs/iso_8859_1.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_10.c           |   1 +
 newlib/libc/iconv/ccs/iso_8859_11.c           |   1 +
 newlib/libc/iconv/ccs/iso_8859_13.c           |   1 +
 newlib/libc/iconv/ccs/iso_8859_14.c           |   1 +
 newlib/libc/iconv/ccs/iso_8859_15.c           |   1 +
 newlib/libc/iconv/ccs/iso_8859_2.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_3.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_4.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_5.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_6.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_7.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_8.c            |   1 +
 newlib/libc/iconv/ccs/iso_8859_9.c            |   1 +
 newlib/libc/iconv/ccs/iso_ir_111.c            |   1 +
 newlib/libc/iconv/ccs/jis_x0201_1976.c        |   1 +
 newlib/libc/iconv/ccs/jis_x0208_1990.c        |   1 +
 newlib/libc/iconv/ccs/jis_x0212_1990.c        |   1 +
 newlib/libc/iconv/ccs/koi8_r.c                |   1 +
 newlib/libc/iconv/ccs/koi8_ru.c               |   1 +
 newlib/libc/iconv/ccs/koi8_u.c                |   1 +
 newlib/libc/iconv/ccs/koi8_uni.c              |   1 +
 newlib/libc/iconv/ccs/ksx1001.c               |   1 +
 newlib/libc/iconv/ccs/win_1250.c              |   1 +
 newlib/libc/iconv/ccs/win_1251.c              |   1 +
 newlib/libc/iconv/ccs/win_1252.c              |   1 +
 newlib/libc/iconv/ccs/win_1253.c              |   1 +
 newlib/libc/iconv/ccs/win_1254.c              |   1 +
 newlib/libc/iconv/ccs/win_1255.c              |   1 +
 newlib/libc/iconv/ccs/win_1256.c              |   1 +
 newlib/libc/iconv/ccs/win_1257.c              |   1 +
 newlib/libc/iconv/ccs/win_1258.c              |   1 +
 newlib/libc/iconv/ces/cesbi.c                 |   1 +
 newlib/libc/iconv/ces/euc.c                   |  32 ++-
 newlib/libc/iconv/ces/table-pcs.c             |  19 +-
 newlib/libc/iconv/ces/table.c                 |  35 ++-
 newlib/libc/iconv/ces/ucs-2-internal.c        |  20 +-
 newlib/libc/iconv/ces/ucs-2.c                 |  26 +-
 newlib/libc/iconv/ces/ucs-4-internal.c        |  20 +-
 newlib/libc/iconv/ces/ucs-4.c                 |  28 ++-
 newlib/libc/iconv/ces/us-ascii.c              |  16 +-
 newlib/libc/iconv/ces/utf-16.c                |  24 +-
 newlib/libc/iconv/ces/utf-8.c                 |  11 +-
 newlib/libc/iconv/lib/aliasesbi.c             |   1 +
 newlib/libc/iconv/lib/aliasesi.c              |  28 ++-
 newlib/libc/iconv/lib/iconv.c                 |  32 ++-
 newlib/libc/iconv/lib/iconvnls.c              |  27 ++-
 newlib/libc/iconv/lib/nullconv.c              |   8 +
 newlib/libc/iconv/lib/ucsconv.c               |  14 +-
 newlib/libc/locale/duplocale.c                |   3 +
 newlib/libc/locale/freelocale.c               |   2 +
 newlib/libc/locale/lctype.c                   |   1 +
 newlib/libc/locale/lmessages.c                |   1 +
 newlib/libc/locale/lmonetary.c                |   2 +
 newlib/libc/locale/lnumeric.c                 |   1 +
 newlib/libc/locale/locale.c                   |  11 +-
 newlib/libc/locale/localeconv.c               |   8 +-
 newlib/libc/locale/newlocale.c                |   3 +
 newlib/libc/locale/nl_langinfo.c              |   5 +
 newlib/libc/locale/timelocal.c                |   1 +
 newlib/libc/locale/uselocale.c                |   3 +
 newlib/libc/machine/aarch64/memchr-stub.c     |   1 +
 newlib/libc/machine/aarch64/memcmp-stub.c     |   1 +
 newlib/libc/machine/aarch64/memcpy-stub.c     |   1 +
 newlib/libc/machine/aarch64/memmove-stub.c    |   1 +
 newlib/libc/machine/aarch64/memset-stub.c     |   1 +
 newlib/libc/machine/aarch64/rawmemchr-stub.c  |   1 +
 newlib/libc/machine/aarch64/stpcpy-stub.c     |   1 +
 newlib/libc/machine/aarch64/strchr-stub.c     |   1 +
 newlib/libc/machine/aarch64/strchrnul-stub.c  |   1 +
 newlib/libc/machine/aarch64/strcmp-stub.c     |   1 +
 newlib/libc/machine/aarch64/strcpy-stub.c     |   1 +
 newlib/libc/machine/aarch64/strlen-stub.c     |   1 +
 newlib/libc/machine/aarch64/strncmp-stub.c    |   1 +
 newlib/libc/machine/aarch64/strnlen-stub.c    |   1 +
 newlib/libc/machine/aarch64/strrchr-stub.c    |   1 +
 newlib/libc/machine/arc/memcmp-stub.c         |   1 +
 newlib/libc/machine/arc/memcpy-stub.c         |   1 +
 newlib/libc/machine/arc/memset-stub.c         |   1 +
 newlib/libc/machine/arc/strchr-stub.c         |   1 +
 newlib/libc/machine/arc/strcmp-stub.c         |   1 +
 newlib/libc/machine/arc/strcpy-stub.c         |   1 +
 newlib/libc/machine/arc/strlen-stub.c         |   1 +
 newlib/libc/machine/arc/strncpy-stub.c        |   1 +
 newlib/libc/machine/arm/aeabi_memclr.c        |   2 +
 newlib/libc/machine/arm/aeabi_memcpy.c        |   2 +
 newlib/libc/machine/arm/aeabi_memmove.c       |   2 +
 newlib/libc/machine/arm/aeabi_memset.c        |   2 +
 newlib/libc/machine/arm/memchr-stub.c         |   1 +
 newlib/libc/machine/arm/memcpy-stub.c         |   1 +
 newlib/libc/machine/arm/strcpy.c              |   2 +
 newlib/libc/machine/arm/strlen-stub.c         |   2 +
 newlib/libc/machine/cr16/getenv.c             |   2 +
 newlib/libc/machine/cris/libcdtor.c           |   3 +
 newlib/libc/machine/cris/memcpy.c             |   2 +
 newlib/libc/machine/cris/memmove.c            |   3 +
 newlib/libc/machine/cris/memset.c             |   2 +
 newlib/libc/machine/cris/setjmp.c             |   3 +
 newlib/libc/machine/crx/getenv.c              |   2 +
 newlib/libc/machine/h8500/cmpsi.c             |  53 ++++-
 newlib/libc/machine/h8500/divsi3.c            |  16 +-
 newlib/libc/machine/h8500/mulhi3.c            |   2 +
 newlib/libc/machine/h8500/mulsi3.c            |   5 +
 newlib/libc/machine/h8500/negsi2.c            |   2 +
 newlib/libc/machine/h8500/shifts.c            |   9 +
 newlib/libc/machine/m68k/strcpy.c             |   2 +
 newlib/libc/machine/m68k/strlen.c             |   2 +
 newlib/libc/machine/microblaze/abort.c        |   2 +
 newlib/libc/machine/microblaze/strcmp.c       |   2 +
 newlib/libc/machine/microblaze/strcpy.c       |   2 +
 newlib/libc/machine/microblaze/strlen.c       |   2 +
 newlib/libc/machine/mips/strlen.c             |   2 +
 newlib/libc/machine/mips/strncpy.c            |   2 +
 newlib/libc/machine/nds32/abort.c             |   2 +
 newlib/libc/machine/powerpc/atosfix16.c       |   3 +
 newlib/libc/machine/powerpc/atosfix32.c       |   3 +
 newlib/libc/machine/powerpc/atosfix64.c       |   3 +
 newlib/libc/machine/powerpc/atoufix16.c       |   3 +
 newlib/libc/machine/powerpc/atoufix32.c       |   3 +
 newlib/libc/machine/powerpc/atoufix64.c       |   3 +
 newlib/libc/machine/powerpc/simdldtoa.c       |  22 +-
 newlib/libc/machine/powerpc/strtosfix16.c     |   2 +
 newlib/libc/machine/powerpc/strtosfix32.c     |   2 +
 newlib/libc/machine/powerpc/strtosfix64.c     |   2 +
 newlib/libc/machine/powerpc/strtoufix16.c     |   2 +
 newlib/libc/machine/powerpc/strtoufix32.c     |   2 +
 newlib/libc/machine/powerpc/strtoufix64.c     |   2 +
 newlib/libc/machine/powerpc/ufix64toa.c       |   2 +
 newlib/libc/machine/powerpc/vec_calloc.c      |   2 +
 newlib/libc/machine/powerpc/vec_free.c        |   2 +
 newlib/libc/machine/powerpc/vec_malloc.c      |   2 +
 newlib/libc/machine/powerpc/vec_mallocr.c     |  14 +-
 newlib/libc/machine/powerpc/vec_realloc.c     |   2 +
 newlib/libc/machine/powerpc/vfprintf.c        |   8 +
 newlib/libc/machine/powerpc/vfscanf.c         |   4 +
 newlib/libc/machine/riscv/ffs.c               |   1 +
 newlib/libc/machine/riscv/ieeefp.c            |  20 +-
 newlib/libc/machine/riscv/memcpy.c            |   3 +
 newlib/libc/machine/riscv/strcpy.c            |   1 +
 newlib/libc/machine/riscv/strlen.c            |   1 +
 newlib/libc/machine/sparc/scan.c              |   2 +
 newlib/libc/machine/sparc/shuffle.c           |   2 +
 newlib/libc/machine/spu/assert.c              |   3 +
 newlib/libc/machine/spu/calloc_ea.c           |   2 +
 newlib/libc/machine/spu/clearerr.c            |   2 +
 newlib/libc/machine/spu/creat.c               |   2 +
 newlib/libc/machine/spu/fclose.c              |   2 +
 newlib/libc/machine/spu/fdopen.c              |   2 +
 newlib/libc/machine/spu/feof.c                |   2 +
 newlib/libc/machine/spu/ferror.c              |   2 +
 newlib/libc/machine/spu/fflush.c              |   2 +
 newlib/libc/machine/spu/fgetc.c               |   2 +
 newlib/libc/machine/spu/fgetpos.c             |   2 +
 newlib/libc/machine/spu/fgets.c               |   2 +
 newlib/libc/machine/spu/fileno.c              |   2 +
 newlib/libc/machine/spu/fopen.c               |   1 +
 newlib/libc/machine/spu/fputc.c               |   2 +
 newlib/libc/machine/spu/fputs.c               |   2 +
 newlib/libc/machine/spu/fread.c               |   2 +
 newlib/libc/machine/spu/free_ea.c             |   2 +
 newlib/libc/machine/spu/freopen.c             |   1 +
 newlib/libc/machine/spu/fseek.c               |   2 +
 newlib/libc/machine/spu/fsetpos.c             |   2 +
 newlib/libc/machine/spu/ftell.c               |   2 +
 newlib/libc/machine/spu/fwrite.c              |   2 +
 newlib/libc/machine/spu/getc.c                |   2 +
 newlib/libc/machine/spu/getchar.c             |   2 +
 newlib/libc/machine/spu/gets.c                |   2 +
 newlib/libc/machine/spu/impure.c              |   1 +
 newlib/libc/machine/spu/malloc_ea.c           |   2 +
 newlib/libc/machine/spu/memchr_ea.c           |   3 +
 newlib/libc/machine/spu/memcmp.c              |   2 +
 newlib/libc/machine/spu/memcmp_ea.c           |   6 +-
 newlib/libc/machine/spu/memcpy.c              |   2 +
 newlib/libc/machine/spu/memcpy_ea.c           |   2 +
 newlib/libc/machine/spu/memmove.c             |   2 +
 newlib/libc/machine/spu/memmove_ea.c          |   2 +
 newlib/libc/machine/spu/memset.c              |   2 +
 newlib/libc/machine/spu/memset_ea.c           |   2 +
 newlib/libc/machine/spu/mmap_ea.c             |   1 +
 newlib/libc/machine/spu/mremap_ea.c           |   1 +
 newlib/libc/machine/spu/msync_ea.c            |   2 +
 newlib/libc/machine/spu/munmap_ea.c           |   2 +
 newlib/libc/machine/spu/perror.c              |   2 +
 newlib/libc/machine/spu/posix_memalign_ea.c   |   2 +
 newlib/libc/machine/spu/pread_ea.c            |   2 +
 newlib/libc/machine/spu/putc.c                |   2 +
 newlib/libc/machine/spu/putchar.c             |   2 +
 newlib/libc/machine/spu/puts.c                |   2 +
 newlib/libc/machine/spu/pwrite_ea.c           |   2 +
 newlib/libc/machine/spu/read_ea.c             |   2 +
 newlib/libc/machine/spu/readv_ea.c            |   1 +
 newlib/libc/machine/spu/realloc_ea.c          |   2 +
 newlib/libc/machine/spu/remove.c              |   2 +
 newlib/libc/machine/spu/rename.c              |   2 +
 newlib/libc/machine/spu/rewind.c              |   2 +
 newlib/libc/machine/spu/setbuf.c              |   2 +
 newlib/libc/machine/spu/setvbuf.c             |   2 +
 newlib/libc/machine/spu/sleep.c               |  12 +-
 newlib/libc/machine/spu/spu-gmon.c            |  21 +-
 newlib/libc/machine/spu/spu_clock_stop.c      |  14 +-
 newlib/libc/machine/spu/spu_clock_svcs.c      |  11 +-
 newlib/libc/machine/spu/spu_timebase.c        |   2 +
 newlib/libc/machine/spu/spu_timer_free.c      |   7 +-
 newlib/libc/machine/spu/spu_timer_slih.c      |   5 +
 newlib/libc/machine/spu/spu_timer_slih_reg.c  |   3 +
 newlib/libc/machine/spu/spu_timer_stop.c      |  11 +-
 newlib/libc/machine/spu/spu_timer_svcs.c      |  23 +-
 newlib/libc/machine/spu/stdio.c               |   6 +
 newlib/libc/machine/spu/strcat.c              |   2 +
 newlib/libc/machine/spu/strcat_ea.c           |   2 +
 newlib/libc/machine/spu/strchr.c              |   2 +
 newlib/libc/machine/spu/strchr_ea.c           |   2 +
 newlib/libc/machine/spu/strcmp.c              |   2 +
 newlib/libc/machine/spu/strcmp_ea.c           |   6 +-
 newlib/libc/machine/spu/strcpy.c              |   2 +
 newlib/libc/machine/spu/strcpy_ea.c           |   2 +
 newlib/libc/machine/spu/strcspn.c             |   2 +
 newlib/libc/machine/spu/strcspn_ea.c          |   2 +
 newlib/libc/machine/spu/strlen.c              |   2 +
 newlib/libc/machine/spu/strlen_ea.c           |   3 +
 newlib/libc/machine/spu/strncat.c             |   2 +
 newlib/libc/machine/spu/strncat_ea.c          |   2 +
 newlib/libc/machine/spu/strncmp.c             |   2 +
 newlib/libc/machine/spu/strncmp_ea.c          |   6 +-
 newlib/libc/machine/spu/strncpy.c             |   2 +
 newlib/libc/machine/spu/strncpy_ea.c          |   2 +
 newlib/libc/machine/spu/strpbrk.c             |   2 +
 newlib/libc/machine/spu/strpbrk_ea.c          |   2 +
 newlib/libc/machine/spu/strrchr.c             |   2 +
 newlib/libc/machine/spu/strrchr_ea.c          |  11 +-
 newlib/libc/machine/spu/strspn.c              |   2 +
 newlib/libc/machine/spu/strspn_ea.c           |   1 +
 newlib/libc/machine/spu/strstr_ea.c           |   1 +
 newlib/libc/machine/spu/strxfrm.c             |   2 +
 newlib/libc/machine/spu/tmpfile.c             |   1 +
 newlib/libc/machine/spu/tmpnam.c              |   2 +
 newlib/libc/machine/spu/ungetc.c              |   2 +
 newlib/libc/machine/spu/usleep.c              |  12 +-
 newlib/libc/machine/spu/vfiprintf.c           |   1 +
 newlib/libc/machine/spu/vfiscanf.c            |   1 +
 newlib/libc/machine/spu/vfprintf.c            |   2 +
 newlib/libc/machine/spu/vfscanf.c             |   2 +
 newlib/libc/machine/spu/viprintf.c            |   1 +
 newlib/libc/machine/spu/viscanf.c             |   1 +
 newlib/libc/machine/spu/vprintf.c             |   2 +
 newlib/libc/machine/spu/vscanf.c              |   2 +
 newlib/libc/machine/spu/vsiprintf.c           |   1 +
 newlib/libc/machine/spu/vsiscanf.c            |   1 +
 newlib/libc/machine/spu/vsniprintf.c          |   1 +
 newlib/libc/machine/spu/vsnprintf.c           |   2 +
 newlib/libc/machine/spu/vsprintf.c            |   2 +
 newlib/libc/machine/spu/vsscanf.c             |   2 +
 newlib/libc/machine/spu/write_ea.c            |   2 +
 newlib/libc/machine/spu/writev_ea.c           |   1 +
 newlib/libc/machine/visium/memcpy.c           |   5 +
 newlib/libc/machine/visium/memmove.c          |   3 +
 newlib/libc/machine/visium/memset.c           |   5 +
 newlib/libc/machine/w65/cmpsi.c               |  14 +-
 newlib/libc/machine/w65/divsi3.c              |  16 +-
 newlib/libc/machine/w65/mulsi3.c              |   2 +
 newlib/libc/machine/xc16x/putchar.c           |   2 +
 newlib/libc/machine/xc16x/puts.c              |   2 +
 newlib/libc/machine/xscale/memchr.c           |   1 +
 newlib/libc/machine/xscale/memcmp.c           |   2 +
 newlib/libc/machine/xscale/memcpy.c           |   2 +
 newlib/libc/machine/xscale/memmove.c          |   2 +
 newlib/libc/machine/xscale/memset.c           |   2 +
 newlib/libc/machine/xscale/strchr.c           |   1 +
 newlib/libc/machine/xscale/strcmp.c           |   1 +
 newlib/libc/machine/xscale/strcpy.c           |   1 +
 newlib/libc/machine/xscale/strlen.c           |   2 +
 newlib/libc/machine/xstormy16/mallocr.c       |   5 +
 newlib/libc/machine/xstormy16/tiny-malloc.c   |  19 +-
 newlib/libc/misc/__dprintf.c                  |   9 +
 newlib/libc/misc/ffs.c                        |   2 +
 newlib/libc/misc/fini.c                       |   2 +
 newlib/libc/misc/init.c                       |   2 +
 newlib/libc/misc/lock.c                       |  11 +
 newlib/libc/misc/unctrl.c                     |   1 +
 newlib/libc/posix/_isatty.c                   |   7 +-
 newlib/libc/posix/closedir.c                  |   2 +
 newlib/libc/posix/collate.c                   |  20 +-
 newlib/libc/posix/collcmp.c                   |   1 +
 newlib/libc/posix/creat.c                     |   2 +
 newlib/libc/posix/engine.c                    |   1 +
 newlib/libc/posix/execl.c                     |   2 +
 newlib/libc/posix/execle.c                    |   1 +
 newlib/libc/posix/execlp.c                    |   2 +
 newlib/libc/posix/execv.c                     |   2 +
 newlib/libc/posix/execve.c                    |   2 +
 newlib/libc/posix/execvp.c                    |  15 +-
 newlib/libc/posix/fnmatch.c                   |   1 +
 newlib/libc/posix/glob.c                      |  86 +++++--
 newlib/libc/posix/isatty.c                    |   2 +
 newlib/libc/posix/opendir.c                   |   8 +-
 newlib/libc/posix/popen.c                     |  14 +-
 newlib/libc/posix/posix_spawn.c               |  62 ++++-
 newlib/libc/posix/readdir.c                   |   5 +
 newlib/libc/posix/readdir_r.c                 |   5 +
 newlib/libc/posix/regcomp.c                   |   1 +
 newlib/libc/posix/regerror.c                  |   1 +
 newlib/libc/posix/regexec.c                   |   1 +
 newlib/libc/posix/regfree.c                   |   1 +
 newlib/libc/posix/rewinddir.c                 |   2 +
 newlib/libc/posix/scandir.c                   |   7 +-
 newlib/libc/posix/seekdir.c                   |   2 +
 newlib/libc/posix/sleep.c                     |  12 +-
 newlib/libc/posix/telldir.c                   |   7 +-
 newlib/libc/posix/usleep.c                    |  12 +-
 newlib/libc/posix/wordexp.c                   |   1 +
 newlib/libc/posix/wordfree.c                  |  10 +-
 newlib/libc/reent/closer.c                    |   2 +
 newlib/libc/reent/execr.c                     |   4 +
 newlib/libc/reent/fcntlr.c                    |   2 +
 newlib/libc/reent/fstat64r.c                  |   2 +
 newlib/libc/reent/fstatr.c                    |   2 +
 newlib/libc/reent/getreent.c                  |   2 +
 newlib/libc/reent/gettimeofdayr.c             |   2 +
 newlib/libc/reent/impure.c                    |   1 +
 newlib/libc/reent/isattyr.c                   |   2 +
 newlib/libc/reent/linkr.c                     |   2 +
 newlib/libc/reent/lseek64r.c                  |   2 +
 newlib/libc/reent/lseekr.c                    |   2 +
 newlib/libc/reent/mkdirr.c                    |   2 +
 newlib/libc/reent/open64r.c                   |   2 +
 newlib/libc/reent/openr.c                     |   2 +
 newlib/libc/reent/readr.c                     |   2 +
 newlib/libc/reent/reent.c                     |   3 +
 newlib/libc/reent/renamer.c                   |   7 +-
 newlib/libc/reent/sbrkr.c                     |   2 +
 newlib/libc/reent/signalr.c                   |   3 +
 newlib/libc/reent/signgam.c                   |   2 +
 newlib/libc/reent/stat64r.c                   |   2 +
 newlib/libc/reent/statr.c                     |   2 +
 newlib/libc/reent/timesr.c                    |   2 +
 newlib/libc/reent/unlinkr.c                   |   2 +
 newlib/libc/reent/writer.c                    |   2 +
 newlib/libc/search/bsd_qsort_r.c              |   1 +
 newlib/libc/search/bsearch.c                  |   1 +
 newlib/libc/search/hash.c                     |  57 ++++-
 newlib/libc/search/hash_bigkey.c              |  13 +-
 newlib/libc/search/hash_buf.c                 |  12 +-
 newlib/libc/search/hash_func.c                |   2 +
 newlib/libc/search/hash_log2.c                |   2 +
 newlib/libc/search/hash_page.c                |  56 ++++-
 newlib/libc/search/hcreate.c                  |   4 +
 newlib/libc/search/hcreate_r.c                |   9 +-
 newlib/libc/search/qsort.c                    |   6 +
 newlib/libc/search/qsort_r.c                  |   1 +
 newlib/libc/search/tdelete.c                  |  12 +-
 newlib/libc/search/tdestroy.c                 |   3 +
 newlib/libc/search/tfind.c                    |  12 +-
 newlib/libc/search/tsearch.c                  |  12 +-
 newlib/libc/search/twalk.c                    |   3 +
 newlib/libc/signal/psignal.c                  |   2 +
 newlib/libc/signal/raise.c                    |   3 +
 newlib/libc/signal/signal.c                   |  16 +-
 newlib/libc/stdio/asiprintf.c                 |   3 +
 newlib/libc/stdio/asniprintf.c                |  13 +-
 newlib/libc/stdio/asnprintf.c                 |  13 +-
 newlib/libc/stdio/asprintf.c                  |   3 +
 newlib/libc/stdio/clearerr.c                  |   2 +
 newlib/libc/stdio/clearerr_u.c                |   2 +
 newlib/libc/stdio/diprintf.c                  |   3 +
 newlib/libc/stdio/dprintf.c                   |   3 +
 newlib/libc/stdio/fclose.c                    |  10 +-
 newlib/libc/stdio/fcloseall.c                 |   3 +
 newlib/libc/stdio/fdopen.c                    |  16 +-
 newlib/libc/stdio/feof.c                      |   2 +
 newlib/libc/stdio/feof_u.c                    |   2 +
 newlib/libc/stdio/ferror.c                    |   2 +
 newlib/libc/stdio/ferror_u.c                  |   2 +
 newlib/libc/stdio/fflush.c                    |   7 +-
 newlib/libc/stdio/fflush_u.c                  |   1 +
 newlib/libc/stdio/fgetc.c                     |   2 +
 newlib/libc/stdio/fgetc_u.c                   |   2 +
 newlib/libc/stdio/fgetpos.c                   |   4 +
 newlib/libc/stdio/fgets.c                     |  11 +-
 newlib/libc/stdio/fgets_u.c                   |   1 +
 newlib/libc/stdio/fgetwc.c                    |   3 +
 newlib/libc/stdio/fgetwc_u.c                  |   3 +
 newlib/libc/stdio/fgetws.c                    |   4 +
 newlib/libc/stdio/fgetws_u.c                  |   1 +
 newlib/libc/stdio/fileno.c                    |   2 +
 newlib/libc/stdio/fileno_u.c                  |   2 +
 newlib/libc/stdio/findfp.c                    |  20 +-
 newlib/libc/stdio/fiprintf.c                  |   3 +
 newlib/libc/stdio/fiscanf.c                   |   3 +
 newlib/libc/stdio/flags.c                     |   3 +
 newlib/libc/stdio/fmemopen.c                  |  21 +-
 newlib/libc/stdio/fopen.c                     |  12 +-
 newlib/libc/stdio/fopencookie.c               |  18 +-
 newlib/libc/stdio/fprintf.c                   |   3 +
 newlib/libc/stdio/fpurge.c                    |   5 +
 newlib/libc/stdio/fputc.c                     |   2 +
 newlib/libc/stdio/fputc_u.c                   |   2 +
 newlib/libc/stdio/fputs.c                     |   3 +
 newlib/libc/stdio/fputs_u.c                   |   1 +
 newlib/libc/stdio/fputwc.c                    |   3 +
 newlib/libc/stdio/fputwc_u.c                  |   3 +
 newlib/libc/stdio/fputws.c                    |   2 +
 newlib/libc/stdio/fputws_u.c                  |   1 +
 newlib/libc/stdio/fread.c                     |  11 +-
 newlib/libc/stdio/fread_u.c                   |   1 +
 newlib/libc/stdio/freopen.c                   |   5 +
 newlib/libc/stdio/fscanf.c                    |   3 +
 newlib/libc/stdio/fseek.c                     |   3 +
 newlib/libc/stdio/fseeko.c                    |   2 +
 newlib/libc/stdio/fsetlocking.c               |   2 +
 newlib/libc/stdio/fsetpos.c                   |   7 +-
 newlib/libc/stdio/ftell.c                     |   3 +
 newlib/libc/stdio/ftello.c                    |   2 +
 newlib/libc/stdio/funopen.c                   |  14 +-
 newlib/libc/stdio/fvwrite.c                   |   1 +
 newlib/libc/stdio/fwalk.c                     |   3 +
 newlib/libc/stdio/fwide.c                     |   3 +
 newlib/libc/stdio/fwprintf.c                  |   3 +
 newlib/libc/stdio/fwrite.c                    |   4 +
 newlib/libc/stdio/fwrite_u.c                  |   1 +
 newlib/libc/stdio/fwscanf.c                   |   3 +
 newlib/libc/stdio/getc.c                      |   3 +
 newlib/libc/stdio/getc_u.c                    |   3 +
 newlib/libc/stdio/getchar.c                   |   3 +
 newlib/libc/stdio/getchar_u.c                 |   3 +
 newlib/libc/stdio/getdelim.c                  |   8 +-
 newlib/libc/stdio/getline.c                   |   2 +
 newlib/libc/stdio/gets.c                      |   2 +
 newlib/libc/stdio/getw.c                      |   6 +-
 newlib/libc/stdio/getwc.c                     |   3 +
 newlib/libc/stdio/getwc_u.c                   |   3 +
 newlib/libc/stdio/getwchar.c                  |   3 +
 newlib/libc/stdio/getwchar_u.c                |   3 +
 newlib/libc/stdio/iprintf.c                   |   3 +
 newlib/libc/stdio/iscanf.c                    |   3 +
 newlib/libc/stdio/makebuf.c                   |   3 +
 newlib/libc/stdio/mktemp.c                    |  13 +
 newlib/libc/stdio/nano-vfprintf.c             |  12 +
 newlib/libc/stdio/nano-vfprintf_float.c       |   5 +
 newlib/libc/stdio/nano-vfprintf_i.c           |   4 +
 newlib/libc/stdio/nano-vfscanf.c              |  20 +-
 newlib/libc/stdio/nano-vfscanf_float.c        |   1 +
 newlib/libc/stdio/nano-vfscanf_i.c            |   6 +-
 newlib/libc/stdio/open_memstream.c            |  24 +-
 newlib/libc/stdio/perror.c                    |   3 +
 newlib/libc/stdio/printf.c                    |   3 +
 newlib/libc/stdio/putc.c                      |   2 +
 newlib/libc/stdio/putc_u.c                    |   3 +
 newlib/libc/stdio/putchar.c                   |   3 +
 newlib/libc/stdio/putchar_u.c                 |   3 +
 newlib/libc/stdio/puts.c                      |   3 +
 newlib/libc/stdio/putw.c                      |   6 +-
 newlib/libc/stdio/putwc.c                     |   3 +
 newlib/libc/stdio/putwc_u.c                   |   3 +
 newlib/libc/stdio/putwchar.c                  |   3 +
 newlib/libc/stdio/putwchar_u.c                |   3 +
 newlib/libc/stdio/refill.c                    |   6 +-
 newlib/libc/stdio/remove.c                    |   7 +-
 newlib/libc/stdio/rename.c                    |   2 +
 newlib/libc/stdio/rewind.c                    |   3 +
 newlib/libc/stdio/rget.c                      |   4 +
 newlib/libc/stdio/scanf.c                     |   3 +
 newlib/libc/stdio/sccl.c                      |   1 +
 newlib/libc/stdio/setbuf.c                    |   2 +
 newlib/libc/stdio/setbuffer.c                 |   2 +
 newlib/libc/stdio/setlinebuf.c                |   2 +
 newlib/libc/stdio/setvbuf.c                   |   7 +-
 newlib/libc/stdio/siprintf.c                  |   3 +
 newlib/libc/stdio/siscanf.c                   |   3 +
 newlib/libc/stdio/sniprintf.c                 |   5 +
 newlib/libc/stdio/snprintf.c                  |   5 +
 newlib/libc/stdio/sprintf.c                   |   3 +
 newlib/libc/stdio/sscanf.c                    |   3 +
 newlib/libc/stdio/stdio.c                     |   6 +
 newlib/libc/stdio/stdio_ext.c                 |   8 +
 newlib/libc/stdio/swprintf.c                  |   5 +
 newlib/libc/stdio/swscanf.c                   |   3 +
 newlib/libc/stdio/tmpfile.c                   |  11 +-
 newlib/libc/stdio/tmpnam.c                    |  12 +-
 newlib/libc/stdio/ungetc.c                    |  22 +-
 newlib/libc/stdio/ungetwc.c                   |   3 +
 newlib/libc/stdio/vasiprintf.c                |   3 +
 newlib/libc/stdio/vasniprintf.c               |   8 +-
 newlib/libc/stdio/vasnprintf.c                |   8 +-
 newlib/libc/stdio/vasprintf.c                 |   3 +
 newlib/libc/stdio/vdiprintf.c                 |   7 +-
 newlib/libc/stdio/vdprintf.c                  |   7 +-
 newlib/libc/stdio/vfprintf.c                  |  16 ++
 newlib/libc/stdio/vfscanf.c                   |  21 +-
 newlib/libc/stdio/vfwprintf.c                 |   9 +
 newlib/libc/stdio/vfwscanf.c                  |  18 +-
 newlib/libc/stdio/viprintf.c                  |   3 +
 newlib/libc/stdio/viscanf.c                   |   3 +
 newlib/libc/stdio/vprintf.c                   |   3 +
 newlib/libc/stdio/vscanf.c                    |   3 +
 newlib/libc/stdio/vsiprintf.c                 |   3 +
 newlib/libc/stdio/vsiscanf.c                  |   3 +
 newlib/libc/stdio/vsniprintf.c                |   4 +
 newlib/libc/stdio/vsnprintf.c                 |   4 +
 newlib/libc/stdio/vsprintf.c                  |   3 +
 newlib/libc/stdio/vsscanf.c                   |   3 +
 newlib/libc/stdio/vswprintf.c                 |   4 +
 newlib/libc/stdio/vswscanf.c                  |   3 +
 newlib/libc/stdio/vwprintf.c                  |   3 +
 newlib/libc/stdio/vwscanf.c                   |   3 +
 newlib/libc/stdio/wbuf.c                      |  15 +-
 newlib/libc/stdio/wprintf.c                   |   3 +
 newlib/libc/stdio/wscanf.c                    |   3 +
 newlib/libc/stdio/wsetup.c                    |   4 +
 newlib/libc/stdio64/dummy.c                   |   1 +
 newlib/libc/stdio64/fdopen64.c                |  16 +-
 newlib/libc/stdio64/fgetpos64.c               |   4 +
 newlib/libc/stdio64/fopen64.c                 |  12 +-
 newlib/libc/stdio64/freopen64.c               |   5 +
 newlib/libc/stdio64/fseeko64.c                |   2 +
 newlib/libc/stdio64/fsetpos64.c               |   7 +-
 newlib/libc/stdio64/ftello64.c                |   2 +
 newlib/libc/stdio64/stdio64.c                 |   3 +
 newlib/libc/stdio64/tmpfile64.c               |  11 +-
 newlib/libc/stdlib/_Exit.c                    |   2 +
 newlib/libc/stdlib/__adjust.c                 |   1 +
 newlib/libc/stdlib/__atexit.c                 |   1 +
 newlib/libc/stdlib/__call_atexit.c            |   1 +
 newlib/libc/stdlib/__exp10.c                  |   1 +
 newlib/libc/stdlib/__ten_mu.c                 |   2 +
 newlib/libc/stdlib/a64l.c                     |  10 +-
 newlib/libc/stdlib/abort.c                    |   2 +
 newlib/libc/stdlib/abs.c                      |   2 +
 newlib/libc/stdlib/aligned_alloc.c            |   2 +
 newlib/libc/stdlib/arc4random.c               |  13 +-
 newlib/libc/stdlib/arc4random_uniform.c       |   6 +-
 newlib/libc/stdlib/assert.c                   |   3 +
 newlib/libc/stdlib/atexit.c                   |   2 +
 newlib/libc/stdlib/atof.c                     |   2 +
 newlib/libc/stdlib/atoff.c                    |   2 +
 newlib/libc/stdlib/atoi.c                     |   3 +
 newlib/libc/stdlib/atol.c                     |   3 +
 newlib/libc/stdlib/atoll.c                    |   3 +
 newlib/libc/stdlib/btowc.c                    |  10 +-
 newlib/libc/stdlib/calloc.c                   |   2 +
 newlib/libc/stdlib/cxa_atexit.c               |   1 +
 newlib/libc/stdlib/cxa_finalize.c             |   2 +
 newlib/libc/stdlib/div.c                      |   2 +
 newlib/libc/stdlib/drand48.c                  |   3 +
 newlib/libc/stdlib/dtoa.c                     |   9 +-
 newlib/libc/stdlib/dtoastub.c                 |   2 +
 newlib/libc/stdlib/ecvtbuf.c                  |  16 +-
 newlib/libc/stdlib/efgcvt.c                   |   7 +
 newlib/libc/stdlib/environ.c                  |   1 +
 newlib/libc/stdlib/envlock.c                  |   3 +
 newlib/libc/stdlib/eprintf.c                  |   2 +
 newlib/libc/stdlib/erand48.c                  |   3 +
 newlib/libc/stdlib/exit.c                     |   2 +
 newlib/libc/stdlib/gdtoa-gethex.c             |   8 +-
 newlib/libc/stdlib/gdtoa-hexnan.c             |   7 +-
 newlib/libc/stdlib/getenv.c                   |   3 +
 newlib/libc/stdlib/getenv_r.c                 |   5 +
 newlib/libc/stdlib/getopt.c                   |  12 +
 newlib/libc/stdlib/getsubopt.c                |  11 +-
 newlib/libc/stdlib/imaxabs.c                  |   2 +
 newlib/libc/stdlib/imaxdiv.c                  |   2 +
 newlib/libc/stdlib/itoa.c                     |   4 +
 newlib/libc/stdlib/jrand48.c                  |   3 +
 newlib/libc/stdlib/l64a.c                     |   3 +
 newlib/libc/stdlib/labs.c                     |   2 +
 newlib/libc/stdlib/lcong48.c                  |   3 +
 newlib/libc/stdlib/ldiv.c                     |   2 +
 newlib/libc/stdlib/ldtoa.c                    |  27 ++-
 newlib/libc/stdlib/llabs.c                    |   2 +
 newlib/libc/stdlib/lldiv.c                    |   2 +
 newlib/libc/stdlib/lrand48.c                  |   3 +
 newlib/libc/stdlib/malign.c                   |   2 +
 newlib/libc/stdlib/malloc.c                   |   3 +
 newlib/libc/stdlib/mallocr.c                  |  31 ++-
 newlib/libc/stdlib/mblen.c                    |   1 +
 newlib/libc/stdlib/mblen_r.c                  |   3 +
 newlib/libc/stdlib/mbrlen.c                   |   2 +
 newlib/libc/stdlib/mbrtowc.c                  |   1 +
 newlib/libc/stdlib/mbsinit.c                  |   1 +
 newlib/libc/stdlib/mbsnrtowcs.c               |   2 +
 newlib/libc/stdlib/mbsrtowcs.c                |   3 +
 newlib/libc/stdlib/mbstowcs.c                 |   2 +
 newlib/libc/stdlib/mbstowcs_r.c               |   1 +
 newlib/libc/stdlib/mbtowc.c                   |   3 +
 newlib/libc/stdlib/mbtowc_r.c                 | 133 +++++++++--
 newlib/libc/stdlib/mlock.c                    |   3 +
 newlib/libc/stdlib/mprec.c                    |  49 +++-
 newlib/libc/stdlib/mrand48.c                  |   3 +
 newlib/libc/stdlib/msize.c                    |   2 +
 newlib/libc/stdlib/mstats.c                   |   6 +
 newlib/libc/stdlib/mtrim.c                    |   2 +
 newlib/libc/stdlib/nano-mallocr.c             |  45 +++-
 newlib/libc/stdlib/nrand48.c                  |   3 +
 newlib/libc/stdlib/on_exit.c                  |   2 +
 newlib/libc/stdlib/on_exit_args.c             |   1 +
 newlib/libc/stdlib/putenv.c                   |   2 +
 newlib/libc/stdlib/putenv_r.c                 |   7 +-
 newlib/libc/stdlib/quick_exit.c               |   7 +-
 newlib/libc/stdlib/rand.c                     |   3 +
 newlib/libc/stdlib/rand48.c                   |   2 +
 newlib/libc/stdlib/rand_r.c                   |   2 +
 newlib/libc/stdlib/random.c                   |   3 +
 newlib/libc/stdlib/realloc.c                  |   2 +
 newlib/libc/stdlib/reallocarray.c             |   3 +
 newlib/libc/stdlib/reallocf.c                 |   3 +
 newlib/libc/stdlib/rpmatch.c                  |   7 +-
 newlib/libc/stdlib/sb_charsets.c              |  15 +-
 newlib/libc/stdlib/seed48.c                   |   3 +
 newlib/libc/stdlib/setenv.c                   |   3 +
 newlib/libc/stdlib/setenv_r.c                 |   3 +
 newlib/libc/stdlib/srand48.c                  |   3 +
 newlib/libc/stdlib/strtod.c                   |  22 +-
 newlib/libc/stdlib/strtodg.c                  |   1 +
 newlib/libc/stdlib/strtoimax.c                |   5 +
 newlib/libc/stdlib/strtol.c                   |   5 +
 newlib/libc/stdlib/strtold.c                  |   2 +
 newlib/libc/stdlib/strtoll.c                  |   5 +
 newlib/libc/stdlib/strtoll_r.c                |   1 +
 newlib/libc/stdlib/strtorx.c                  |   3 +
 newlib/libc/stdlib/strtoul.c                  |   5 +
 newlib/libc/stdlib/strtoull.c                 |   5 +
 newlib/libc/stdlib/strtoull_r.c               |   1 +
 newlib/libc/stdlib/strtoumax.c                |   5 +
 newlib/libc/stdlib/system.c                   |   3 +
 newlib/libc/stdlib/utoa.c                     |   4 +
 newlib/libc/stdlib/valloc.c                   |   3 +
 newlib/libc/stdlib/wcrtomb.c                  |   1 +
 newlib/libc/stdlib/wcsnrtombs.c               |   3 +
 newlib/libc/stdlib/wcsrtombs.c                |   3 +
 newlib/libc/stdlib/wcstod.c                   |  25 +-
 newlib/libc/stdlib/wcstoimax.c                |   5 +
 newlib/libc/stdlib/wcstol.c                   |   5 +
 newlib/libc/stdlib/wcstold.c                  |   1 +
 newlib/libc/stdlib/wcstoll.c                  |   5 +
 newlib/libc/stdlib/wcstoll_r.c                |   1 +
 newlib/libc/stdlib/wcstombs.c                 |   2 +
 newlib/libc/stdlib/wcstombs_r.c               |   1 +
 newlib/libc/stdlib/wcstoul.c                  |   5 +
 newlib/libc/stdlib/wcstoull.c                 |   6 +
 newlib/libc/stdlib/wcstoull_r.c               |   1 +
 newlib/libc/stdlib/wcstoumax.c                |   5 +
 newlib/libc/stdlib/wctob.c                    |   6 +-
 newlib/libc/stdlib/wctomb.c                   |   2 +
 newlib/libc/stdlib/wctomb_r.c                 |  89 ++++++-
 newlib/libc/string/bcmp.c                     |   2 +
 newlib/libc/string/bcopy.c                    |   2 +
 newlib/libc/string/bzero.c                    |   2 +
 newlib/libc/string/explicit_bzero.c           |   2 +
 newlib/libc/string/ffsl.c                     |   2 +
 newlib/libc/string/ffsll.c                    |   2 +
 newlib/libc/string/fls.c                      |   6 +-
 newlib/libc/string/flsl.c                     |   6 +-
 newlib/libc/string/flsll.c                    |   6 +-
 newlib/libc/string/gnu_basename.c             |   6 +-
 newlib/libc/string/index.c                    |   2 +
 newlib/libc/string/memccpy.c                  |   2 +
 newlib/libc/string/memchr.c                   |   1 +
 newlib/libc/string/memcmp.c                   |   3 +
 newlib/libc/string/memcpy.c                   |   2 +
 newlib/libc/string/memmem.c                   |  10 +-
 newlib/libc/string/memmove.c                  |   2 +
 newlib/libc/string/mempcpy.c                  |   2 +
 newlib/libc/string/memrchr.c                  |   1 +
 newlib/libc/string/memset.c                   |   1 +
 newlib/libc/string/rawmemchr.c                |   1 +
 newlib/libc/string/rindex.c                   |   2 +
 newlib/libc/string/stpcpy.c                   |   2 +
 newlib/libc/string/stpncpy.c                  |   2 +
 newlib/libc/string/strcasecmp.c               |   2 +
 newlib/libc/string/strcasecmp_l.c             |   2 +
 newlib/libc/string/strcasestr.c               |   6 +-
 newlib/libc/string/strcat.c                   |   2 +
 newlib/libc/string/strchr.c                   |   1 +
 newlib/libc/string/strchrnul.c                |   2 +
 newlib/libc/string/strcmp.c                   |   2 +
 newlib/libc/string/strcoll.c                  |   2 +
 newlib/libc/string/strcoll_l.c                |   2 +
 newlib/libc/string/strcpy.c                   |   2 +
 newlib/libc/string/strcspn.c                  |   2 +
 newlib/libc/string/strdup.c                   |   2 +
 newlib/libc/string/strdup_r.c                 |   2 +
 newlib/libc/string/strerror.c                 |   4 +
 newlib/libc/string/strerror_r.c               |   6 +-
 newlib/libc/string/strlcat.c                  |   6 +-
 newlib/libc/string/strlcpy.c                  |   2 +
 newlib/libc/string/strlen.c                   |   6 +-
 newlib/libc/string/strlwr.c                   |   2 +
 newlib/libc/string/strncasecmp.c              |   2 +
 newlib/libc/string/strncasecmp_l.c            |   2 +
 newlib/libc/string/strncat.c                  |   2 +
 newlib/libc/string/strncmp.c                  |   6 +-
 newlib/libc/string/strncpy.c                  |   2 +
 newlib/libc/string/strndup.c                  |   2 +
 newlib/libc/string/strndup_r.c                |   2 +
 newlib/libc/string/strnlen.c                  |   2 +
 newlib/libc/string/strnstr.c                  |   6 +-
 newlib/libc/string/strpbrk.c                  |   6 +-
 newlib/libc/string/strrchr.c                  |   2 +
 newlib/libc/string/strsep.c                   |   2 +
 newlib/libc/string/strsignal.c                |   3 +
 newlib/libc/string/strspn.c                   |   2 +
 newlib/libc/string/strstr.c                   |   8 +-
 newlib/libc/string/strtok.c                   |   2 +
 newlib/libc/string/strtok_r.c                 |   2 +
 newlib/libc/string/strupr.c                   |   2 +
 newlib/libc/string/strverscmp.c               |   1 +
 newlib/libc/string/strxfrm.c                  |   1 +
 newlib/libc/string/strxfrm_l.c                |   1 +
 newlib/libc/string/swab.c                     |   2 +
 newlib/libc/string/timingsafe_bcmp.c          |   2 +
 newlib/libc/string/timingsafe_memcmp.c        |   2 +
 newlib/libc/string/u_strerr.c                 |   2 +
 newlib/libc/string/wcpcpy.c                   |   2 +
 newlib/libc/string/wcpncpy.c                  |   2 +
 newlib/libc/string/wcscasecmp.c               |   2 +
 newlib/libc/string/wcscasecmp_l.c             |   2 +
 newlib/libc/string/wcscat.c                   |   2 +
 newlib/libc/string/wcschr.c                   |   3 +
 newlib/libc/string/wcscmp.c                   |   6 +-
 newlib/libc/string/wcscoll.c                  |   2 +
 newlib/libc/string/wcscoll_l.c                |   2 +
 newlib/libc/string/wcscpy.c                   |   2 +
 newlib/libc/string/wcscspn.c                  |   2 +
 newlib/libc/string/wcsdup.c                   |   3 +
 newlib/libc/string/wcslcat.c                  |   6 +-
 newlib/libc/string/wcslcpy.c                  |   2 +
 newlib/libc/string/wcslen.c                   |   2 +
 newlib/libc/string/wcsncasecmp.c              |   2 +
 newlib/libc/string/wcsncasecmp_l.c            |   2 +
 newlib/libc/string/wcsncat.c                  |   2 +
 newlib/libc/string/wcsncmp.c                  |   7 +-
 newlib/libc/string/wcsncpy.c                  |   2 +
 newlib/libc/string/wcsnlen.c                  |   2 +
 newlib/libc/string/wcspbrk.c                  |   3 +
 newlib/libc/string/wcsrchr.c                  |   3 +
 newlib/libc/string/wcsspn.c                   |   2 +
 newlib/libc/string/wcsstr.c                   |   8 +-
 newlib/libc/string/wcstok.c                   |   9 +-
 newlib/libc/string/wcswidth.c                 |  14 +-
 newlib/libc/string/wcsxfrm.c                  |   2 +
 newlib/libc/string/wcsxfrm_l.c                |   2 +
 newlib/libc/string/wcwidth.c                  |  27 ++-
 newlib/libc/string/wmemchr.c                  |   3 +
 newlib/libc/string/wmemcmp.c                  |   3 +
 newlib/libc/string/wmemcpy.c                  |   2 +
 newlib/libc/string/wmemmove.c                 |   2 +
 newlib/libc/string/wmemset.c                  |   2 +
 newlib/libc/string/xpg_strerror_r.c           |   7 +-
 newlib/libc/sys/a29khif/getpid.c              |   2 +
 newlib/libc/sys/a29khif/kill.c                |   7 +-
 newlib/libc/sys/arm/access.c                  |  15 +-
 newlib/libc/sys/arm/aeabi_atexit.c            |   2 +
 newlib/libc/sys/arm/libcfunc.c                |   2 +
 newlib/libc/sys/arm/syscalls.c                |  57 ++++-
 newlib/libc/sys/d10v/creat.c                  |   2 +
 newlib/libc/sys/d10v/syscalls.c               |  22 ++
 newlib/libc/sys/decstation/_main.c            |   2 +
 newlib/libc/sys/epiphany/e_printf.c           |   4 +
 newlib/libc/sys/h8300hms/crt1.c               |   2 +
 newlib/libc/sys/h8300hms/misc.c               |   4 +
 newlib/libc/sys/h8300hms/sbrk.c               |   2 +
 newlib/libc/sys/h8300hms/syscalls.c           |   3 +
 newlib/libc/sys/h8500hms/crt0.c               |   3 +
 newlib/libc/sys/h8500hms/misc.c               |   4 +
 newlib/libc/sys/h8500hms/syscalls.c           |  11 +
 newlib/libc/sys/linux/aio.c                   |  10 +
 newlib/libc/sys/linux/aio64.c                 |   9 +
 newlib/libc/sys/linux/argp/argp-ba.c          |   1 +
 newlib/libc/sys/linux/argp/argp-eexst.c       |   1 +
 newlib/libc/sys/linux/argp/argp-fmtstream.c   |   9 +-
 newlib/libc/sys/linux/argp/argp-fs-xinl.c     |   1 +
 newlib/libc/sys/linux/argp/argp-help.c        |  47 +++-
 newlib/libc/sys/linux/argp/argp-parse.c       |  27 ++-
 newlib/libc/sys/linux/argp/argp-pv.c          |   1 +
 newlib/libc/sys/linux/argp/argp-pvh.c         |   1 +
 newlib/libc/sys/linux/argp/argp-xinl.c        |   1 +
 newlib/libc/sys/linux/brk.c                   |   7 +-
 newlib/libc/sys/linux/calloc.c                |   1 +
 newlib/libc/sys/linux/callocr.c               |   2 +
 newlib/libc/sys/linux/cfreer.c                |   2 +
 newlib/libc/sys/linux/cfspeed.c               |   7 +
 newlib/libc/sys/linux/clock_getres.c          |   1 +
 newlib/libc/sys/linux/clock_gettime.c         |   1 +
 newlib/libc/sys/linux/clock_settime.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cacos.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cacosf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_cacosh.c        |   1 +
 newlib/libc/sys/linux/cmath/s_cacoshf.c       |   1 +
 newlib/libc/sys/linux/cmath/s_cacoshl.c       |   1 +
 newlib/libc/sys/linux/cmath/s_cacosl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_casin.c         |   1 +
 newlib/libc/sys/linux/cmath/s_casinf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_casinh.c        |   1 +
 newlib/libc/sys/linux/cmath/s_casinhf.c       |   1 +
 newlib/libc/sys/linux/cmath/s_casinhl.c       |   1 +
 newlib/libc/sys/linux/cmath/s_casinl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_catan.c         |   1 +
 newlib/libc/sys/linux/cmath/s_catanf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_catanh.c        |   1 +
 newlib/libc/sys/linux/cmath/s_catanhf.c       |   1 +
 newlib/libc/sys/linux/cmath/s_catanhl.c       |   1 +
 newlib/libc/sys/linux/cmath/s_catanl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_cbrtl.c         |   2 +
 newlib/libc/sys/linux/cmath/s_ccos.c          |   1 +
 newlib/libc/sys/linux/cmath/s_ccosf.c         |   1 +
 newlib/libc/sys/linux/cmath/s_ccosh.c         |   1 +
 newlib/libc/sys/linux/cmath/s_ccoshf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_ccoshl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_ccosl.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cexp.c          |   1 +
 newlib/libc/sys/linux/cmath/s_cexpf.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cexpl.c         |   1 +
 newlib/libc/sys/linux/cmath/s_clog.c          |   1 +
 newlib/libc/sys/linux/cmath/s_clog10.c        |   1 +
 newlib/libc/sys/linux/cmath/s_clog10f.c       |   1 +
 newlib/libc/sys/linux/cmath/s_clog10l.c       |   1 +
 newlib/libc/sys/linux/cmath/s_clogf.c         |   1 +
 newlib/libc/sys/linux/cmath/s_clogl.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cpow.c          |   2 +
 newlib/libc/sys/linux/cmath/s_cpowf.c         |   2 +
 newlib/libc/sys/linux/cmath/s_cpowl.c         |   2 +
 newlib/libc/sys/linux/cmath/s_cproj.c         |   1 +
 newlib/libc/sys/linux/cmath/s_cprojf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_cprojl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_csin.c          |   1 +
 newlib/libc/sys/linux/cmath/s_csinf.c         |   1 +
 newlib/libc/sys/linux/cmath/s_csinh.c         |   1 +
 newlib/libc/sys/linux/cmath/s_csinhf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_csinhl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_csinl.c         |   1 +
 newlib/libc/sys/linux/cmath/s_csqrt.c         |   1 +
 newlib/libc/sys/linux/cmath/s_csqrtf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_csqrtl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_ctan.c          |   1 +
 newlib/libc/sys/linux/cmath/s_ctanf.c         |   1 +
 newlib/libc/sys/linux/cmath/s_ctanh.c         |   1 +
 newlib/libc/sys/linux/cmath/s_ctanhf.c        |   1 +
 newlib/libc/sys/linux/cmath/s_ctanhl.c        |   1 +
 newlib/libc/sys/linux/cmath/s_ctanl.c         |   1 +
 newlib/libc/sys/linux/confstr.c               |   3 +
 newlib/libc/sys/linux/crt1.c                  |   1 +
 newlib/libc/sys/linux/ctermid.c               |   6 +-
 newlib/libc/sys/linux/dl/dl-addr.c            |   1 +
 newlib/libc/sys/linux/dl/dl-cache.c           |   7 +-
 newlib/libc/sys/linux/dl/dl-close.c           |   2 +
 newlib/libc/sys/linux/dl/dl-debug.c           |   3 +
 newlib/libc/sys/linux/dl/dl-deps.c            |   2 +
 newlib/libc/sys/linux/dl/dl-error.c           |   6 +
 newlib/libc/sys/linux/dl/dl-fini.c            |   1 +
 newlib/libc/sys/linux/dl/dl-init.c            |   1 +
 newlib/libc/sys/linux/dl/dl-iteratephdr.c     |   2 +
 newlib/libc/sys/linux/dl/dl-libc.c            |   9 +
 newlib/libc/sys/linux/dl/dl-load.c            |  29 ++-
 newlib/libc/sys/linux/dl/dl-lookup.c          |  13 +-
 newlib/libc/sys/linux/dl/dl-minimal.c         |  15 +-
 newlib/libc/sys/linux/dl/dl-misc.c            |   7 +
 newlib/libc/sys/linux/dl/dl-object.c          |   6 +-
 newlib/libc/sys/linux/dl/dl-open.c            |  10 +-
 newlib/libc/sys/linux/dl/dl-profile.c         |   6 +-
 newlib/libc/sys/linux/dl/dl-profstub.c        |   3 +
 newlib/libc/sys/linux/dl/dl-reloc.c           |   2 +
 newlib/libc/sys/linux/dl/dl-runtime.c         |   1 +
 newlib/libc/sys/linux/dl/dl-support.c         |   4 +
 newlib/libc/sys/linux/dl/dl-sym.c             |   1 +
 newlib/libc/sys/linux/dl/dl-version.c         |  11 +-
 newlib/libc/sys/linux/fclean.c                |   2 +
 newlib/libc/sys/linux/flockfile.c             |   2 +
 newlib/libc/sys/linux/fpathconf.c             |  16 +-
 newlib/libc/sys/linux/free.c                  |   1 +
 newlib/libc/sys/linux/freer.c                 |   2 +
 newlib/libc/sys/linux/fstab.c                 |  33 ++-
 newlib/libc/sys/linux/fstatvfs.c              |   6 +-
 newlib/libc/sys/linux/fstatvfs64.c            |   6 +-
 newlib/libc/sys/linux/ftok.c                  |   6 +-
 newlib/libc/sys/linux/ftw.c                   |  41 +++-
 newlib/libc/sys/linux/ftw64.c                 |   1 +
 newlib/libc/sys/linux/funlockfile.c           |   2 +
 newlib/libc/sys/linux/getdate.c               |  51 +++-
 newlib/libc/sys/linux/getdate_err.c           |   2 +
 newlib/libc/sys/linux/gethostid.c             |   6 +-
 newlib/libc/sys/linux/gethostname.c           |   7 +-
 newlib/libc/sys/linux/getlogin.c              |   2 +
 newlib/libc/sys/linux/getopt.c                |   1 +
 newlib/libc/sys/linux/getopt1.c               |   4 +
 newlib/libc/sys/linux/getpwent.c              |   4 +
 newlib/libc/sys/linux/getreent.c              |   2 +
 newlib/libc/sys/linux/getrlimit64.c           |   6 +-
 newlib/libc/sys/linux/getwd.c                 |   7 +-
 .../libc/sys/linux/iconv/dummy-repertoire.c   |   3 +
 newlib/libc/sys/linux/iconv/gconv.c           |   6 +-
 newlib/libc/sys/linux/iconv/gconv_builtin.c   |   2 +
 newlib/libc/sys/linux/iconv/gconv_cache.c     |  20 +-
 newlib/libc/sys/linux/iconv/gconv_close.c     |   2 +
 newlib/libc/sys/linux/iconv/gconv_conf.c      |  19 +-
 newlib/libc/sys/linux/iconv/gconv_db.c        |  24 +-
 newlib/libc/sys/linux/iconv/gconv_dl.c        |  13 +-
 newlib/libc/sys/linux/iconv/gconv_open.c      |   2 +
 newlib/libc/sys/linux/iconv/gconv_simple.c    |  33 ++-
 newlib/libc/sys/linux/iconv/gconv_trans.c     |  10 +-
 newlib/libc/sys/linux/iconv/iconv.c           |   2 +
 newlib/libc/sys/linux/iconv/iconv_charmap.c   |  26 +-
 newlib/libc/sys/linux/iconv/iconv_close.c     |   3 +
 newlib/libc/sys/linux/iconv/iconv_open.c      |   3 +
 newlib/libc/sys/linux/iconv/loop.c            |   8 +-
 newlib/libc/sys/linux/iconv/skeleton.c        |   1 +
 newlib/libc/sys/linux/ids.c                   |   1 +
 newlib/libc/sys/linux/inode.c                 |   3 +
 newlib/libc/sys/linux/internal_statvfs.c      |   1 +
 newlib/libc/sys/linux/intl/bindtextdom.c      |   5 +
 newlib/libc/sys/linux/intl/catgets.c          |  19 +-
 newlib/libc/sys/linux/intl/dcgettext.c        |   2 +
 newlib/libc/sys/linux/intl/dcigettext.c       |  16 +-
 newlib/libc/sys/linux/intl/dcngettext.c       |   2 +
 newlib/libc/sys/linux/intl/dgettext.c         |   2 +
 newlib/libc/sys/linux/intl/dngettext.c        |   2 +
 newlib/libc/sys/linux/intl/explodename.c      |   3 +
 newlib/libc/sys/linux/intl/finddomain.c       |   2 +
 newlib/libc/sys/linux/intl/gettext.c          |   2 +
 newlib/libc/sys/linux/intl/l10nflist.c        |  16 +-
 newlib/libc/sys/linux/intl/lcl_stpcpy.c       |   2 +
 newlib/libc/sys/linux/intl/loadmsgcat.c       |  26 +-
 newlib/libc/sys/linux/intl/localealias.c      |  21 +-
 newlib/libc/sys/linux/intl/ngettext.c         |   2 +
 newlib/libc/sys/linux/intl/open_catalog.c     |   6 +-
 newlib/libc/sys/linux/intl/plural.c           |  17 +-
 newlib/libc/sys/linux/intl/textdomain.c       |   6 +-
 newlib/libc/sys/linux/io.c                    |   1 +
 newlib/libc/sys/linux/io64.c                  |   2 +
 newlib/libc/sys/linux/ipc.c                   |   8 +
 newlib/libc/sys/linux/isatty.c                |   2 +
 newlib/libc/sys/linux/linux.c                 |   1 +
 newlib/libc/sys/linux/linuxthreads/attr.c     |  57 ++++-
 newlib/libc/sys/linux/linuxthreads/barrier.c  |  21 +-
 newlib/libc/sys/linux/linuxthreads/cancel.c   |  20 +-
 newlib/libc/sys/linux/linuxthreads/condvar.c  |  35 ++-
 newlib/libc/sys/linux/linuxthreads/ecmutex.c  |   3 +
 newlib/libc/sys/linux/linuxthreads/events.c   |   4 +
 .../sys/linux/linuxthreads/getcpuclockid.c    |   1 +
 newlib/libc/sys/linux/linuxthreads/getreent.c |   2 +
 newlib/libc/sys/linux/linuxthreads/join.c     |  12 +
 newlib/libc/sys/linux/linuxthreads/joinrace.c |   5 +
 newlib/libc/sys/linux/linuxthreads/lockfile.c |   7 +
 .../linuxthreads/machine/i386/pspinlock.c     |   6 +
 newlib/libc/sys/linux/linuxthreads/manager.c  |  31 ++-
 .../libc/sys/linux/linuxthreads/mq_notify.c   |   6 +
 newlib/libc/sys/linux/linuxthreads/mutex.c    |  84 ++++++-
 newlib/libc/sys/linux/linuxthreads/no-tsd.c   |   1 +
 .../sys/linux/linuxthreads/oldsemaphore.c     |  14 ++
 newlib/libc/sys/linux/linuxthreads/prio.c     |   7 +
 .../libc/sys/linux/linuxthreads/pt-machine.c  |   1 +
 .../sys/linux/linuxthreads/ptclock_gettime.c  |   2 +
 .../sys/linux/linuxthreads/ptclock_settime.c  |   2 +
 newlib/libc/sys/linux/linuxthreads/ptfork.c   |  16 +-
 newlib/libc/sys/linux/linuxthreads/pthread.c  |  71 +++++-
 .../libc/sys/linux/linuxthreads/ptlongjmp.c   |   4 +
 newlib/libc/sys/linux/linuxthreads/reent.c    |   3 +
 .../libc/sys/linux/linuxthreads/reqsyscalls.c |   1 +
 newlib/libc/sys/linux/linuxthreads/rwlock.c   |  75 +++++-
 .../libc/sys/linux/linuxthreads/semaphore.c   |  18 ++
 newlib/libc/sys/linux/linuxthreads/signals.c  |  15 +-
 newlib/libc/sys/linux/linuxthreads/specific.c |  27 ++-
 newlib/libc/sys/linux/linuxthreads/spinlock.c |  45 +++-
 newlib/libc/sys/linux/linuxthreads/sysctl.c   |   1 +
 newlib/libc/sys/linux/linuxthreads/td_init.c  |   2 +
 newlib/libc/sys/linux/linuxthreads/td_log.c   |   2 +
 .../sys/linux/linuxthreads/td_symbol_list.c   |   3 +
 .../linux/linuxthreads/td_ta_clear_event.c    |  18 +-
 .../sys/linux/linuxthreads/td_ta_delete.c     |   1 +
 .../linux/linuxthreads/td_ta_enable_stats.c   |   6 +-
 .../sys/linux/linuxthreads/td_ta_event_addr.c |   6 +-
 .../linux/linuxthreads/td_ta_event_getmsg.c   |  48 ++--
 .../linux/linuxthreads/td_ta_get_nthreads.c   |  18 +-
 .../sys/linux/linuxthreads/td_ta_get_ph.c     |   6 +-
 .../sys/linux/linuxthreads/td_ta_get_stats.c  |   6 +-
 .../sys/linux/linuxthreads/td_ta_map_id2thr.c |  30 ++-
 .../linux/linuxthreads/td_ta_map_lwp2thr.c    |   1 +
 .../libc/sys/linux/linuxthreads/td_ta_new.c   |  12 +-
 .../linux/linuxthreads/td_ta_reset_stats.c    |   6 +-
 .../sys/linux/linuxthreads/td_ta_set_event.c  |  18 +-
 .../linux/linuxthreads/td_ta_setconcurrency.c |   6 +-
 .../sys/linux/linuxthreads/td_ta_thr_iter.c   |  28 ++-
 .../sys/linux/linuxthreads/td_ta_tsd_iter.c   |  16 +-
 .../linux/linuxthreads/td_thr_clear_event.c   |  14 +-
 .../sys/linux/linuxthreads/td_thr_dbresume.c  |   2 +
 .../sys/linux/linuxthreads/td_thr_dbsuspend.c |   2 +
 .../linux/linuxthreads/td_thr_event_enable.c  |   8 +-
 .../linux/linuxthreads/td_thr_event_getmsg.c  |  18 +-
 .../sys/linux/linuxthreads/td_thr_get_info.c  |   8 +-
 .../sys/linux/linuxthreads/td_thr_getfpregs.c |   1 +
 .../sys/linux/linuxthreads/td_thr_getgregs.c  |   1 +
 .../sys/linux/linuxthreads/td_thr_getxregs.c  |   2 +
 .../linux/linuxthreads/td_thr_getxregsize.c   |   2 +
 .../sys/linux/linuxthreads/td_thr_set_event.c |  14 +-
 .../sys/linux/linuxthreads/td_thr_setfpregs.c |  10 +-
 .../sys/linux/linuxthreads/td_thr_setgregs.c  |  10 +-
 .../sys/linux/linuxthreads/td_thr_setprio.c   |   2 +
 .../linux/linuxthreads/td_thr_setsigpending.c |   2 +
 .../sys/linux/linuxthreads/td_thr_setxregs.c  |   2 +
 .../linux/linuxthreads/td_thr_sigsetmask.c    |   2 +
 .../libc/sys/linux/linuxthreads/td_thr_tsd.c  |  30 ++-
 .../sys/linux/linuxthreads/td_thr_validate.c  |  15 +-
 .../sys/linux/linuxthreads/timer_create.c     |   4 +
 .../sys/linux/linuxthreads/timer_delete.c     |   2 +
 .../sys/linux/linuxthreads/timer_getoverr.c   |   2 +
 .../sys/linux/linuxthreads/timer_gettime.c    |   2 +
 .../sys/linux/linuxthreads/timer_routines.c   |  32 +++
 .../sys/linux/linuxthreads/timer_settime.c    |   2 +
 .../libc/sys/linux/linuxthreads/tst-cancel.c  |  14 +-
 .../libc/sys/linux/linuxthreads/tst-context.c |   3 +
 newlib/libc/sys/linux/linuxthreads/tststack.c |   5 +
 newlib/libc/sys/linux/linuxthreads/unload.c   |   2 +
 newlib/libc/sys/linux/linuxthreads/weaks.c    |   5 +
 .../libc/sys/linux/linuxthreads/wrapsyscall.c |   1 +
 newlib/libc/sys/linux/machine/i386/crt0.c     |   2 +
 .../libc/sys/linux/machine/i386/dl-procinfo.c |   1 +
 .../sys/linux/machine/i386/get_clockfreq.c    |   6 +-
 .../libc/sys/linux/machine/i386/getpagesize.c |   2 +
 .../libc/sys/linux/machine/i386/hp-timing.c   |   1 +
 .../libc/sys/linux/machine/i386/sigaction.c   |   1 +
 newlib/libc/sys/linux/malign.c                |   1 +
 newlib/libc/sys/linux/malignr.c               |   2 +
 newlib/libc/sys/linux/mallinfor.c             |   2 +
 newlib/libc/sys/linux/malloc.c                | 166 ++++++++++---
 newlib/libc/sys/linux/mallocr.c               |   2 +
 newlib/libc/sys/linux/malloptr.c              |   2 +
 newlib/libc/sys/linux/mallstatsr.c            |   2 +
 newlib/libc/sys/linux/mcheck.c                |  23 +-
 newlib/libc/sys/linux/mmap.c                  |   1 +
 newlib/libc/sys/linux/mntent.c                |   8 +-
 newlib/libc/sys/linux/mntent_r.c              |  16 +-
 newlib/libc/sys/linux/mq_close.c              |   3 +
 newlib/libc/sys/linux/mq_getattr.c            |   3 +
 newlib/libc/sys/linux/mq_notify.c             |   2 +
 newlib/libc/sys/linux/mq_open.c               |   7 +
 newlib/libc/sys/linux/mq_receive.c            |   4 +
 newlib/libc/sys/linux/mq_send.c               |   5 +
 newlib/libc/sys/linux/mq_setattr.c            |   3 +
 newlib/libc/sys/linux/mq_unlink.c             |   7 +-
 newlib/libc/sys/linux/msize.c                 |   1 +
 newlib/libc/sys/linux/msizer.c                |   2 +
 newlib/libc/sys/linux/mstats.c                |   1 +
 newlib/libc/sys/linux/mtrim.c                 |   1 +
 newlib/libc/sys/linux/mtrimr.c                |   2 +
 newlib/libc/sys/linux/net/XXX-lookup.c        |   1 +
 newlib/libc/sys/linux/net/addr2ascii.c        |   4 +
 newlib/libc/sys/linux/net/alias-lookup.c      |   1 +
 newlib/libc/sys/linux/net/ascii2addr.c        |   6 +-
 newlib/libc/sys/linux/net/base64.c            |  14 +-
 newlib/libc/sys/linux/net/check_pf.c          |  14 +-
 newlib/libc/sys/linux/net/digits_dots.c       |   4 +
 newlib/libc/sys/linux/net/ether_aton.c        |   2 +
 newlib/libc/sys/linux/net/ether_aton_r.c      |  14 +-
 newlib/libc/sys/linux/net/ether_hton.c        |   2 +
 newlib/libc/sys/linux/net/ether_line.c        |  18 +-
 newlib/libc/sys/linux/net/ether_ntoa.c        |   2 +
 newlib/libc/sys/linux/net/ether_ntoa_r.c      |   2 +
 newlib/libc/sys/linux/net/ether_ntoh.c        |   2 +
 newlib/libc/sys/linux/net/ethers-lookup.c     |   1 +
 newlib/libc/sys/linux/net/getXXbyYY.c         |   1 +
 newlib/libc/sys/linux/net/getXXbyYY_r.c       |   1 +
 newlib/libc/sys/linux/net/getXXent.c          |   2 +
 newlib/libc/sys/linux/net/getXXent_r.c        |   4 +
 newlib/libc/sys/linux/net/getaddrinfo.c       |  54 ++++-
 newlib/libc/sys/linux/net/getaliasent.c       |   1 +
 newlib/libc/sys/linux/net/getaliasent_r.c     |   1 +
 newlib/libc/sys/linux/net/getaliasname.c      |   1 +
 newlib/libc/sys/linux/net/getaliasname_r.c    |   1 +
 newlib/libc/sys/linux/net/gethstbyad.c        |   1 +
 newlib/libc/sys/linux/net/gethstbyad_r.c      |   1 +
 newlib/libc/sys/linux/net/gethstbynm.c        |   1 +
 newlib/libc/sys/linux/net/gethstbynm2.c       |   1 +
 newlib/libc/sys/linux/net/gethstbynm2_r.c     |   1 +
 newlib/libc/sys/linux/net/gethstbynm_r.c      |   1 +
 newlib/libc/sys/linux/net/gethstent.c         |   1 +
 newlib/libc/sys/linux/net/gethstent_r.c       |   1 +
 newlib/libc/sys/linux/net/getnameinfo.c       |   2 +
 newlib/libc/sys/linux/net/getnetbyad.c        |   1 +
 newlib/libc/sys/linux/net/getnetbyad_r.c      |   1 +
 newlib/libc/sys/linux/net/getnetbynm.c        |   1 +
 newlib/libc/sys/linux/net/getnetbynm_r.c      |   1 +
 newlib/libc/sys/linux/net/getnetent.c         |   1 +
 newlib/libc/sys/linux/net/getnetent_r.c       |   1 +
 newlib/libc/sys/linux/net/getnetgrent.c       |   4 +
 newlib/libc/sys/linux/net/getnetgrent_r.c     |  10 +
 newlib/libc/sys/linux/net/getnssent.c         |   2 +
 newlib/libc/sys/linux/net/getnssent_r.c       |   7 +
 newlib/libc/sys/linux/net/getproto.c          |   1 +
 newlib/libc/sys/linux/net/getproto_r.c        |   1 +
 newlib/libc/sys/linux/net/getprtent.c         |   1 +
 newlib/libc/sys/linux/net/getprtent_r.c       |   1 +
 newlib/libc/sys/linux/net/getprtname.c        |   1 +
 newlib/libc/sys/linux/net/getprtname_r.c      |   1 +
 newlib/libc/sys/linux/net/getrpcbyname.c      |   1 +
 newlib/libc/sys/linux/net/getrpcbyname_r.c    |   1 +
 newlib/libc/sys/linux/net/getrpcbynumber.c    |   1 +
 newlib/libc/sys/linux/net/getrpcbynumber_r.c  |   1 +
 newlib/libc/sys/linux/net/getrpcent.c         |   1 +
 newlib/libc/sys/linux/net/getrpcent_r.c       |   1 +
 newlib/libc/sys/linux/net/getservent.c        |   1 +
 newlib/libc/sys/linux/net/getservent_r.c      |   1 +
 newlib/libc/sys/linux/net/getsrvbynm.c        |   1 +
 newlib/libc/sys/linux/net/getsrvbynm_r.c      |   1 +
 newlib/libc/sys/linux/net/getsrvbypt.c        |   1 +
 newlib/libc/sys/linux/net/getsrvbypt_r.c      |   1 +
 newlib/libc/sys/linux/net/grp-lookup.c        |   1 +
 newlib/libc/sys/linux/net/herrno.c            |   2 +
 newlib/libc/sys/linux/net/hosts-lookup.c      |   1 +
 newlib/libc/sys/linux/net/ifname.c            |  27 ++-
 newlib/libc/sys/linux/net/ifreq.c             |   4 +
 newlib/libc/sys/linux/net/in6_addr.c          |   1 +
 newlib/libc/sys/linux/net/inet6_option.c      |  32 ++-
 newlib/libc/sys/linux/net/inet_addr.c         |   6 +-
 newlib/libc/sys/linux/net/inet_lnaof.c        |   1 +
 newlib/libc/sys/linux/net/inet_mkadr.c        |   2 +
 newlib/libc/sys/linux/net/inet_net.c          |  22 +-
 newlib/libc/sys/linux/net/inet_net_ntop.c     |   6 +
 newlib/libc/sys/linux/net/inet_net_pton.c     |   6 +
 newlib/libc/sys/linux/net/inet_neta.c         |   3 +
 newlib/libc/sys/linux/net/inet_netof.c        |   1 +
 newlib/libc/sys/linux/net/inet_ntoa.c         |   4 +
 newlib/libc/sys/linux/net/inet_ntop.c         |  12 +-
 newlib/libc/sys/linux/net/inet_pton.c         |  30 ++-
 newlib/libc/sys/linux/net/issetugid-stub.c    |   2 +
 newlib/libc/sys/linux/net/key-lookup.c        |   1 +
 newlib/libc/sys/linux/net/netgrp-lookup.c     |   1 +
 newlib/libc/sys/linux/net/network-lookup.c    |   1 +
 newlib/libc/sys/linux/net/ns_name.c           |  41 +++-
 newlib/libc/sys/linux/net/ns_netint.c         |   5 +
 newlib/libc/sys/linux/net/ns_parse.c          |  12 +-
 newlib/libc/sys/linux/net/ns_print.c          |  14 +-
 newlib/libc/sys/linux/net/ns_samedomain.c     |  29 ++-
 newlib/libc/sys/linux/net/ns_ttl.c            |   9 +-
 newlib/libc/sys/linux/net/nsap_addr.c         |   3 +
 newlib/libc/sys/linux/net/nsswitch.c          |  47 +++-
 newlib/libc/sys/linux/net/opensock.c          |   7 +-
 newlib/libc/sys/linux/net/proto-lookup.c      |   1 +
 newlib/libc/sys/linux/net/pwd-lookup.c        |   1 +
 newlib/libc/sys/linux/net/rcmd.c              |  55 ++++-
 newlib/libc/sys/linux/net/rcmdsh.c            |   1 +
 newlib/libc/sys/linux/net/recv.c              |   2 +
 newlib/libc/sys/linux/net/res_comp.c          |  47 +++-
 newlib/libc/sys/linux/net/res_data.c          |  34 ++-
 newlib/libc/sys/linux/net/res_debug.c         |  24 +-
 newlib/libc/sys/linux/net/res_hconf.c         |  54 ++++-
 newlib/libc/sys/linux/net/res_init.c          |   6 +
 newlib/libc/sys/linux/net/res_libc.c          |   2 +
 newlib/libc/sys/linux/net/res_mkquery.c       |  23 +-
 newlib/libc/sys/linux/net/res_query.c         |  36 ++-
 newlib/libc/sys/linux/net/res_send.c          |  49 +++-
 newlib/libc/sys/linux/net/rexec.c             |   2 +
 newlib/libc/sys/linux/net/rpc-lookup.c        |   1 +
 newlib/libc/sys/linux/net/ruserpass.c         |  22 +-
 newlib/libc/sys/linux/net/send.c              |   2 +
 newlib/libc/sys/linux/net/service-lookup.c    |   1 +
 newlib/libc/sys/linux/net/spwd-lookup.c       |   1 +
 newlib/libc/sys/linux/ntp_gettime.c           |   2 +
 newlib/libc/sys/linux/pathconf.c              |  16 +-
 newlib/libc/sys/linux/pread.c                 |  15 +-
 newlib/libc/sys/linux/pread64.c               |  14 +-
 newlib/libc/sys/linux/process.c               |   1 +
 newlib/libc/sys/linux/prof-freq.c             |   6 +-
 newlib/libc/sys/linux/profile.c               |   1 +
 newlib/libc/sys/linux/pvallocr.c              |   2 +
 newlib/libc/sys/linux/pwrite.c                |  15 +-
 newlib/libc/sys/linux/pwrite64.c              |  14 +-
 newlib/libc/sys/linux/raise.c                 |   1 +
 newlib/libc/sys/linux/readdir64.c             |   1 +
 newlib/libc/sys/linux/realloc.c               |   1 +
 newlib/libc/sys/linux/reallocr.c              |   2 +
 newlib/libc/sys/linux/realpath.c              |  23 +-
 newlib/libc/sys/linux/rename.c                |   1 +
 newlib/libc/sys/linux/resource.c              |   1 +
 newlib/libc/sys/linux/scandir64.c             |  12 +-
 newlib/libc/sys/linux/sched.c                 |   1 +
 newlib/libc/sys/linux/select.c                |   1 +
 newlib/libc/sys/linux/seteuid.c               |   3 +
 newlib/libc/sys/linux/sethostid.c             |   1 +
 newlib/libc/sys/linux/sethostname.c           |   1 +
 newlib/libc/sys/linux/setrlimit64.c           |   2 +
 newlib/libc/sys/linux/shm_open.c              |   2 +
 newlib/libc/sys/linux/shm_unlink.c            |   2 +
 newlib/libc/sys/linux/sig.c                   |   8 +
 newlib/libc/sys/linux/sigaction.c             |   1 +
 newlib/libc/sys/linux/siglongjmp.c            |   2 +
 newlib/libc/sys/linux/signal.c                |  11 +-
 newlib/libc/sys/linux/sigqueue.c              |   1 +
 newlib/libc/sys/linux/sigset.c                |   9 +
 newlib/libc/sys/linux/sigwait.c               |   3 +
 newlib/libc/sys/linux/sleep.c                 |  12 +-
 newlib/libc/sys/linux/socket.c                |   1 +
 newlib/libc/sys/linux/stack.c                 |   1 +
 newlib/libc/sys/linux/statvfs.c               |   6 +-
 newlib/libc/sys/linux/statvfs64.c             |   6 +-
 newlib/libc/sys/linux/strsignal.c             |   1 +
 newlib/libc/sys/linux/strverscmp.c            |  12 +-
 newlib/libc/sys/linux/sysconf.c               |  54 +++++
 newlib/libc/sys/linux/sysctl.c                |   1 +
 newlib/libc/sys/linux/systat.c                |   1 +
 newlib/libc/sys/linux/system.c                |   1 +
 newlib/libc/sys/linux/tcdrain.c               |   2 +
 newlib/libc/sys/linux/tcsendbrk.c             |   6 +-
 newlib/libc/sys/linux/termios.c               |  12 +-
 newlib/libc/sys/linux/time.c                  |   1 +
 newlib/libc/sys/linux/ttyname_r.c             |  15 +-
 newlib/libc/sys/linux/usleep.c                |  12 +-
 newlib/libc/sys/linux/utimes.c                |   2 +
 newlib/libc/sys/linux/vallocr.c               |   2 +
 newlib/libc/sys/linux/versionsort.c           |   2 +
 newlib/libc/sys/linux/versionsort64.c         |   2 +
 newlib/libc/sys/linux/wait.c                  |   3 +
 newlib/libc/sys/m88kbug/crt0.c                |   2 +
 newlib/libc/sys/m88kbug/syscalls.c            |  21 ++
 newlib/libc/sys/mmixware/_exit.c              |   2 +
 newlib/libc/sys/mmixware/access.c             |   3 +
 newlib/libc/sys/mmixware/chmod.c              |   2 +
 newlib/libc/sys/mmixware/chown.c              |   2 +
 newlib/libc/sys/mmixware/close.c              |   4 +
 newlib/libc/sys/mmixware/creat.c              |   2 +
 newlib/libc/sys/mmixware/crt0.c               |   1 +
 newlib/libc/sys/mmixware/execv.c              |   2 +
 newlib/libc/sys/mmixware/execve.c             |   2 +
 newlib/libc/sys/mmixware/fork.c               |   2 +
 newlib/libc/sys/mmixware/fstat.c              |   2 +
 newlib/libc/sys/mmixware/getpid.c             |   2 +
 newlib/libc/sys/mmixware/gettime.c            |   2 +
 newlib/libc/sys/mmixware/isatty.c             |   2 +
 newlib/libc/sys/mmixware/kill.c               |   1 +
 newlib/libc/sys/mmixware/link.c               |   2 +
 newlib/libc/sys/mmixware/lseek.c              |   1 +
 newlib/libc/sys/mmixware/open.c               |   1 +
 newlib/libc/sys/mmixware/pipe.c               |   2 +
 newlib/libc/sys/mmixware/read.c               |  13 +-
 newlib/libc/sys/mmixware/sbrk.c               |   2 +
 newlib/libc/sys/mmixware/stat.c               |   2 +
 newlib/libc/sys/mmixware/time.c               |   2 +
 newlib/libc/sys/mmixware/times.c              |   2 +
 newlib/libc/sys/mmixware/unlink.c             |   2 +
 newlib/libc/sys/mmixware/utime.c              |   2 +
 newlib/libc/sys/mmixware/wait.c               |   2 +
 newlib/libc/sys/mmixware/write.c              |   4 +
 newlib/libc/sys/netware/crt0.c                |   1 +
 newlib/libc/sys/netware/getpid.c              |   2 +
 newlib/libc/sys/netware/link.c                |   2 +
 newlib/libc/sys/or1k/mlock.c                  |   3 +
 newlib/libc/sys/phoenix/alarm.c               |   2 +
 newlib/libc/sys/phoenix/chmod.c               |   5 +
 newlib/libc/sys/phoenix/chown.c               |   7 +
 newlib/libc/sys/phoenix/clocks.c              |   5 +
 newlib/libc/sys/phoenix/dup.c                 |   5 +
 newlib/libc/sys/phoenix/endmntent.c           |   2 +
 newlib/libc/sys/phoenix/exec.c                |   6 +
 newlib/libc/sys/phoenix/fcntl.c               |   3 +
 newlib/libc/sys/phoenix/fork.c                |  10 +-
 newlib/libc/sys/phoenix/fs.c                  |  18 ++
 newlib/libc/sys/phoenix/getentropy.c          |   3 +
 newlib/libc/sys/phoenix/getmntent.c           |   6 +
 newlib/libc/sys/phoenix/getpagesize.c         |   2 +
 newlib/libc/sys/phoenix/groups.c              |  13 +
 newlib/libc/sys/phoenix/ids.c                 |  21 ++
 newlib/libc/sys/phoenix/io.c                  |  12 +
 newlib/libc/sys/phoenix/ioctl.c               |   3 +
 newlib/libc/sys/phoenix/mmap.c                |   3 +
 newlib/libc/sys/phoenix/mount.c               |   6 +
 newlib/libc/sys/phoenix/nanosleep.c           |   3 +
 newlib/libc/sys/phoenix/net/domainname.c      |   5 +
 newlib/libc/sys/phoenix/net/freeaddrinfo.c    |   2 +
 newlib/libc/sys/phoenix/net/getaddrinfo.c     |   3 +
 newlib/libc/sys/phoenix/net/gethostbyaddr.c   |   2 +
 newlib/libc/sys/phoenix/net/gethostbyname.c   |   2 +
 newlib/libc/sys/phoenix/net/getnameinfo.c     |   2 +
 newlib/libc/sys/phoenix/net/getservbyname.c   |   2 +
 newlib/libc/sys/phoenix/net/getservbyport.c   |   2 +
 newlib/libc/sys/phoenix/net/herror.c          |   3 +
 newlib/libc/sys/phoenix/net/hostname.c        |   5 +
 newlib/libc/sys/phoenix/net/inet_addr.c       |   6 +-
 newlib/libc/sys/phoenix/net/inet_aton.c       |   1 +
 newlib/libc/sys/phoenix/net/inet_lnaof.c      |   1 +
 newlib/libc/sys/phoenix/net/inet_makeaddr.c   |   2 +
 newlib/libc/sys/phoenix/net/inet_net_ntop.c   |   6 +
 newlib/libc/sys/phoenix/net/inet_net_pton.c   |   6 +
 newlib/libc/sys/phoenix/net/inet_netof.c      |   1 +
 newlib/libc/sys/phoenix/net/inet_network.c    |  22 +-
 newlib/libc/sys/phoenix/net/inet_ntoa.c       |   2 +
 newlib/libc/sys/phoenix/net/inet_ntop.c       |  12 +-
 newlib/libc/sys/phoenix/net/inet_pton.c       |  30 ++-
 newlib/libc/sys/phoenix/net/nametoindex.c     |   5 +
 newlib/libc/sys/phoenix/net/network.c         |   5 +
 newlib/libc/sys/phoenix/phoenix.c             |   1 +
 newlib/libc/sys/phoenix/pid.c                 |   3 +
 newlib/libc/sys/phoenix/pipe.c                |   3 +
 newlib/libc/sys/phoenix/poll.c                |   3 +
 newlib/libc/sys/phoenix/realpath.c            |  19 +-
 newlib/libc/sys/phoenix/reboot.c              |   3 +
 newlib/libc/sys/phoenix/resource.c            |  10 +
 newlib/libc/sys/phoenix/sbrk.c                |   3 +
 newlib/libc/sys/phoenix/sched.c               |  15 ++
 newlib/libc/sys/phoenix/select.c              |   3 +
 newlib/libc/sys/phoenix/semaphore.c           |  16 ++
 newlib/libc/sys/phoenix/setmntent.c           |   2 +
 newlib/libc/sys/phoenix/shm.c                 |   5 +
 newlib/libc/sys/phoenix/signal.c              |   8 +
 newlib/libc/sys/phoenix/socket.c              |  20 ++
 newlib/libc/sys/phoenix/sockopt.c             |   7 +
 newlib/libc/sys/phoenix/stat.c                |   8 +
 newlib/libc/sys/phoenix/statfs.c              |   3 +
 newlib/libc/sys/phoenix/symlink.c             |   6 +
 newlib/libc/sys/phoenix/sync.c                |   5 +
 newlib/libc/sys/phoenix/sysconf.c             |   2 +
 newlib/libc/sys/phoenix/syslog.c              |  14 +-
 newlib/libc/sys/phoenix/time.c                |  11 +
 newlib/libc/sys/phoenix/truncate.c            |   5 +
 newlib/libc/sys/phoenix/tty.c                 |  16 ++
 newlib/libc/sys/phoenix/uname.c               |   3 +
 newlib/libc/sys/phoenix/utime.c               |   5 +
 newlib/libc/sys/phoenix/wait.c                |   6 +
 newlib/libc/sys/rdos/chown.c                  |   2 +
 newlib/libc/sys/rdos/close.c                  |   2 +
 newlib/libc/sys/rdos/execve.c                 |   2 +
 newlib/libc/sys/rdos/fork.c                   |   2 +
 newlib/libc/sys/rdos/fstat.c                  |   1 +
 newlib/libc/sys/rdos/getenv.c                 |   2 +
 newlib/libc/sys/rdos/getpid.c                 |   2 +
 newlib/libc/sys/rdos/gettod.c                 |   2 +
 newlib/libc/sys/rdos/isatty.c                 |   2 +
 newlib/libc/sys/rdos/kill.c                   |   2 +
 newlib/libc/sys/rdos/link.c                   |   2 +
 newlib/libc/sys/rdos/lseek.c                  |   5 +
 newlib/libc/sys/rdos/open.c                   |   1 +
 newlib/libc/sys/rdos/rdoshelp.c               |  12 +-
 newlib/libc/sys/rdos/read.c                   |   2 +
 newlib/libc/sys/rdos/readlink.c               |   2 +
 newlib/libc/sys/rdos/sbrk.c                   |   2 +
 newlib/libc/sys/rdos/stat.c                   |   2 +
 newlib/libc/sys/rdos/symlink.c                |   2 +
 newlib/libc/sys/rdos/times.c                  |   2 +
 newlib/libc/sys/rdos/unlink.c                 |   2 +
 newlib/libc/sys/rdos/wait.c                   |   2 +
 newlib/libc/sys/rdos/write.c                  |   2 +
 newlib/libc/sys/rtems/cpusetalloc.c           |   2 +
 newlib/libc/sys/rtems/cpusetfree.c            |   2 +
 newlib/libc/sys/rtems/crt0.c                  |   1 +
 newlib/libc/sys/rtems/dummysys.c              |   4 +-
 newlib/libc/sys/sh/creat.c                    |   2 +
 newlib/libc/sys/sh/ftruncate.c                |   2 +
 newlib/libc/sys/sh/syscalls.c                 |  26 ++
 newlib/libc/sys/sh/truncate.c                 |   2 +
 newlib/libc/sys/sparc64/_main.c               |   2 +
 newlib/libc/sys/sparc64/closedir.c            |   2 +
 newlib/libc/sys/sparc64/creat.c               |   2 +
 newlib/libc/sys/sparc64/ieee.c                |  29 ++-
 newlib/libc/sys/sparc64/isatty.c              |  10 +-
 newlib/libc/sys/sparc64/opendir.c             |   8 +-
 newlib/libc/sys/sparc64/readdir.c             |   1 +
 newlib/libc/sys/sparc64/rewinddir.c           |   2 +
 newlib/libc/sys/sparc64/scandir.c             |  29 ++-
 newlib/libc/sys/sparc64/seekdir.c             |   2 +
 newlib/libc/sys/sparc64/telldir.c             |  11 +-
 newlib/libc/sys/sparc64/utime2.c              |   3 +
 newlib/libc/sys/sun4/_main.c                  |   2 +
 newlib/libc/sys/sun4/ieee.c                   |  29 ++-
 newlib/libc/sys/sysmec/_exit.c                |   3 +
 newlib/libc/sys/sysmec/access.c               |  15 +-
 newlib/libc/sys/sysmec/chmod.c                |   2 +
 newlib/libc/sys/sysmec/chown.c                |   2 +
 newlib/libc/sys/sysmec/close.c                |   2 +
 newlib/libc/sys/sysmec/creat.c                |   2 +
 newlib/libc/sys/sysmec/crt1.c                 |   2 +
 newlib/libc/sys/sysmec/execv.c                |   2 +
 newlib/libc/sys/sysmec/execve.c               |   2 +
 newlib/libc/sys/sysmec/fork.c                 |   2 +
 newlib/libc/sys/sysmec/fstat.c                |   2 +
 newlib/libc/sys/sysmec/getpid.c               |   2 +
 newlib/libc/sys/sysmec/gettime.c              |   2 +
 newlib/libc/sys/sysmec/isatty.c               |   1 +
 newlib/libc/sys/sysmec/kill.c                 |   1 +
 newlib/libc/sys/sysmec/lseek.c                |   2 +
 newlib/libc/sys/sysmec/open.c                 |   2 +
 newlib/libc/sys/sysmec/pipe.c                 |   2 +
 newlib/libc/sys/sysmec/read.c                 |   2 +
 newlib/libc/sys/sysmec/sbrk.c                 |   2 +
 newlib/libc/sys/sysmec/stat.c                 |   2 +
 newlib/libc/sys/sysmec/time.c                 |   2 +
 newlib/libc/sys/sysmec/times.c                |   2 +
 newlib/libc/sys/sysmec/unlink.c               |   2 +
 newlib/libc/sys/sysmec/utime.c                |   2 +
 newlib/libc/sys/sysmec/wait.c                 |   2 +
 newlib/libc/sys/sysmec/write.c                |   2 +
 newlib/libc/sys/sysnec810/misc.c              |   7 +
 newlib/libc/sys/sysnec810/sbrk.c              |   2 +
 newlib/libc/sys/sysnec810/write.c             |   4 +
 newlib/libc/sys/sysnecv850/_exit.c            |   3 +
 newlib/libc/sys/sysnecv850/access.c           |  15 +-
 newlib/libc/sys/sysnecv850/chmod.c            |   2 +
 newlib/libc/sys/sysnecv850/chown.c            |   2 +
 newlib/libc/sys/sysnecv850/close.c            |   2 +
 newlib/libc/sys/sysnecv850/creat.c            |   2 +
 newlib/libc/sys/sysnecv850/crt1.c             |   2 +
 newlib/libc/sys/sysnecv850/execv.c            |   2 +
 newlib/libc/sys/sysnecv850/execve.c           |   2 +
 newlib/libc/sys/sysnecv850/fork.c             |   2 +
 newlib/libc/sys/sysnecv850/fstat.c            |   2 +
 newlib/libc/sys/sysnecv850/getpid.c           |   2 +
 newlib/libc/sys/sysnecv850/gettime.c          |   2 +
 newlib/libc/sys/sysnecv850/isatty.c           |   1 +
 newlib/libc/sys/sysnecv850/kill.c             |   1 +
 newlib/libc/sys/sysnecv850/link.c             |   2 +
 newlib/libc/sys/sysnecv850/lseek.c            |   2 +
 newlib/libc/sys/sysnecv850/open.c             |   2 +
 newlib/libc/sys/sysnecv850/pipe.c             |   2 +
 newlib/libc/sys/sysnecv850/read.c             |   2 +
 newlib/libc/sys/sysnecv850/rename.c           |   2 +
 newlib/libc/sys/sysnecv850/sbrk.c             |   2 +
 newlib/libc/sys/sysnecv850/stat.c             |   2 +
 newlib/libc/sys/sysnecv850/time.c             |   2 +
 newlib/libc/sys/sysnecv850/times.c            |   2 +
 newlib/libc/sys/sysnecv850/unlink.c           |   2 +
 newlib/libc/sys/sysnecv850/utime.c            |   2 +
 newlib/libc/sys/sysnecv850/wait.c             |   2 +
 newlib/libc/sys/sysnecv850/write.c            |   2 +
 newlib/libc/sys/sysvi386/closedir.c           |   2 +
 newlib/libc/sys/sysvi386/crt0.c               |   1 +
 newlib/libc/sys/sysvi386/dup.c                |   2 +
 newlib/libc/sys/sysvi386/dup2.c               |   2 +
 newlib/libc/sys/sysvi386/exec.c               |  10 +-
 newlib/libc/sys/sysvi386/fpx.c                |   7 +
 newlib/libc/sys/sysvi386/isatty.c             |   1 +
 newlib/libc/sys/sysvi386/opendir.c            |   8 +-
 newlib/libc/sys/sysvi386/readdir.c            |   1 +
 newlib/libc/sys/sysvi386/rewinddir.c          |   2 +
 newlib/libc/sys/sysvi386/sbrk.c               |   1 +
 newlib/libc/sys/sysvi386/scandir.c            |   2 +
 newlib/libc/sys/sysvi386/seekdir.c            |   2 +
 newlib/libc/sys/sysvi386/sleep.c              |   2 +
 newlib/libc/sys/sysvi386/speed.c              |   5 +
 newlib/libc/sys/sysvi386/tcgetattr.c          |   2 +
 newlib/libc/sys/sysvi386/tcline.c             |   8 +-
 newlib/libc/sys/sysvi386/tcsetattr.c          |   2 +
 newlib/libc/sys/sysvi386/telldir.c            |  11 +-
 newlib/libc/sys/sysvnecv70/fpx.c              |   7 +
 newlib/libc/sys/tic80/crt0.c                  |   2 +
 newlib/libc/sys/tirtos/lock.c                 |  11 +
 newlib/libc/sys/w65/crt0.c                    |   2 +
 newlib/libc/sys/w65/syscalls.c                |  22 ++
 newlib/libc/sys/w65/trap.c                    |   2 +
 newlib/libc/sys/z8ksim/crt0.c                 |   5 +
 newlib/libc/sys/z8ksim/glue.c                 |  15 ++
 newlib/libc/syscalls/sysclose.c               |   2 +
 newlib/libc/syscalls/sysexecve.c              |   2 +
 newlib/libc/syscalls/sysfcntl.c               |   2 +
 newlib/libc/syscalls/sysfork.c                |   2 +
 newlib/libc/syscalls/sysfstat.c               |   2 +
 newlib/libc/syscalls/sysgetpid.c              |   2 +
 newlib/libc/syscalls/sysgettod.c              |   2 +
 newlib/libc/syscalls/sysisatty.c              |   2 +
 newlib/libc/syscalls/syskill.c                |   2 +
 newlib/libc/syscalls/syslink.c                |   2 +
 newlib/libc/syscalls/syslseek.c               |   2 +
 newlib/libc/syscalls/sysopen.c                |   3 +
 newlib/libc/syscalls/sysread.c                |   2 +
 newlib/libc/syscalls/syssbrk.c                |   2 +
 newlib/libc/syscalls/sysstat.c                |   2 +
 newlib/libc/syscalls/systimes.c               |   2 +
 newlib/libc/syscalls/sysunlink.c              |   2 +
 newlib/libc/syscalls/syswait.c                |   2 +
 newlib/libc/syscalls/syswrite.c               |   2 +
 newlib/libc/time/asctime.c                    |   2 +
 newlib/libc/time/asctime_r.c                  |   2 +
 newlib/libc/time/clock.c                      |   2 +
 newlib/libc/time/ctime.c                      |   2 +
 newlib/libc/time/ctime_r.c                    |   2 +
 newlib/libc/time/difftime.c                   |   2 +
 newlib/libc/time/gettzinfo.c                  |   2 +
 newlib/libc/time/gmtime.c                     |   2 +
 newlib/libc/time/gmtime_r.c                   |   2 +
 newlib/libc/time/lcltime.c                    |   2 +
 newlib/libc/time/lcltime_r.c                  |   2 +
 newlib/libc/time/mktime.c                     |   7 +-
 newlib/libc/time/month_lengths.c              |   1 +
 newlib/libc/time/strftime.c                   |  23 +-
 newlib/libc/time/strptime.c                   |   9 +
 newlib/libc/time/time.c                       |   2 +
 newlib/libc/time/tzcalc_limits.c              |   6 +-
 newlib/libc/time/tzlock.c                     |   3 +
 newlib/libc/time/tzset.c                      |   3 +
 newlib/libc/time/tzset_r.c                    |   2 +
 newlib/libc/time/tzvars.c                     |   1 +
 newlib/libc/time/wcsftime.c                   |   1 +
 newlib/libc/unix/basename.c                   |  10 +-
 newlib/libc/unix/dirname.c                    |  12 +-
 newlib/libc/unix/getcwd.c                     |   1 +
 newlib/libc/unix/getlogin.c                   |  11 +-
 newlib/libc/unix/getpass.c                    |   2 +
 newlib/libc/unix/getpwent.c                   |  18 +-
 newlib/libc/unix/getut.c                      |  23 +-
 newlib/libc/unix/pread.c                      |  15 +-
 newlib/libc/unix/pwrite.c                     |  15 +-
 newlib/libc/unix/sigset.c                     |   7 +
 newlib/libc/unix/ttyname.c                    |   2 +
 newlib/libc/unix/ttyname_r.c                  |   1 +
 newlib/libc/xdr/dummy.c                       |   1 +
 newlib/libc/xdr/xdr.c                         | 224 +++++++++++++++---
 newlib/libc/xdr/xdr_array.c                   |  12 +-
 newlib/libc/xdr/xdr_float.c                   |   5 +
 newlib/libc/xdr/xdr_float_vax.c               |  17 +-
 newlib/libc/xdr/xdr_mem.c                     |  61 ++++-
 newlib/libc/xdr/xdr_private.c                 |   5 +
 newlib/libc/xdr/xdr_rec.c                     | 123 ++++++++--
 newlib/libc/xdr/xdr_reference.c               |   7 +
 newlib/libc/xdr/xdr_sizeof.c                  |   9 +
 newlib/libc/xdr/xdr_stdio.c                   |  36 ++-
 newlib/libm/common/acoshl.c                   |   2 +
 newlib/libm/common/acosl.c                    |   2 +
 newlib/libm/common/asinhl.c                   |   2 +
 newlib/libm/common/asinl.c                    |   2 +
 newlib/libm/common/atan2l.c                   |   2 +
 newlib/libm/common/atanhl.c                   |   2 +
 newlib/libm/common/atanl.c                    |   2 +
 newlib/libm/common/cbrtl.c                    |   2 +
 newlib/libm/common/ceill.c                    |   2 +
 newlib/libm/common/copysignl.c                |   2 +
 newlib/libm/common/coshl.c                    |   2 +
 newlib/libm/common/cosl.c                     |   2 +
 newlib/libm/common/erfcl.c                    |   2 +
 newlib/libm/common/erfl.c                     |   2 +
 newlib/libm/common/exp2l.c                    |   2 +
 newlib/libm/common/expl.c                     |   2 +
 newlib/libm/common/expm1l.c                   |   2 +
 newlib/libm/common/fabsl.c                    |   2 +
 newlib/libm/common/fdiml.c                    |   2 +
 newlib/libm/common/floorl.c                   |   2 +
 newlib/libm/common/fmal.c                     |   2 +
 newlib/libm/common/fmaxl.c                    |   2 +
 newlib/libm/common/fminl.c                    |   2 +
 newlib/libm/common/fmodl.c                    |   2 +
 newlib/libm/common/frexpl.c                   |   2 +
 newlib/libm/common/hypotl.c                   |   1 +
 newlib/libm/common/ilogbl.c                   |   2 +
 newlib/libm/common/isgreater.c                |   1 +
 newlib/libm/common/ldexpl.c                   |   2 +
 newlib/libm/common/lgammal.c                  |   2 +
 newlib/libm/common/llrintl.c                  |   2 +
 newlib/libm/common/llroundl.c                 |   2 +
 newlib/libm/common/log10l.c                   |   2 +
 newlib/libm/common/log1pl.c                   |   2 +
 newlib/libm/common/log2l.c                    |   2 +
 newlib/libm/common/logbl.c                    |   2 +
 newlib/libm/common/logl.c                     |   2 +
 newlib/libm/common/lrintl.c                   |   2 +
 newlib/libm/common/lroundl.c                  |   2 +
 newlib/libm/common/modfl.c                    |   2 +
 newlib/libm/common/nanl.c                     |   2 +
 newlib/libm/common/nearbyintl.c               |   2 +
 newlib/libm/common/nextafterl.c               |   2 +
 newlib/libm/common/nexttoward.c               |   2 +
 newlib/libm/common/nexttowardf.c              |  10 +-
 newlib/libm/common/nexttowardl.c              |   2 +
 newlib/libm/common/powl.c                     |   2 +
 newlib/libm/common/remainderl.c               |   2 +
 newlib/libm/common/remquol.c                  |   2 +
 newlib/libm/common/rintl.c                    |   2 +
 newlib/libm/common/roundl.c                   |   2 +
 newlib/libm/common/s_cbrt.c                   |  13 +-
 newlib/libm/common/s_copysign.c               |   2 +
 newlib/libm/common/s_exp10.c                  |   2 +
 newlib/libm/common/s_expm1.c                  |   1 +
 newlib/libm/common/s_fdim.c                   |  16 +-
 newlib/libm/common/s_finite.c                 |   2 +
 newlib/libm/common/s_fma.c                    |   2 +
 newlib/libm/common/s_fmax.c                   |  10 +-
 newlib/libm/common/s_fmin.c                   |  10 +-
 newlib/libm/common/s_fpclassify.c             |   1 +
 newlib/libm/common/s_ilogb.c                  |   1 +
 newlib/libm/common/s_infinity.c               |   2 +
 newlib/libm/common/s_isinf.c                  |   2 +
 newlib/libm/common/s_isinfd.c                 |   2 +
 newlib/libm/common/s_isnan.c                  |   2 +
 newlib/libm/common/s_isnand.c                 |   2 +
 newlib/libm/common/s_lib_ver.c                |   1 +
 newlib/libm/common/s_llrint.c                 |   1 +
 newlib/libm/common/s_llround.c                |   1 +
 newlib/libm/common/s_log1p.c                  |   1 +
 newlib/libm/common/s_log2.c                   |   2 +
 newlib/libm/common/s_logb.c                   |   1 +
 newlib/libm/common/s_lrint.c                  |   1 +
 newlib/libm/common/s_lround.c                 |   1 +
 newlib/libm/common/s_matherr.c                |   7 +-
 newlib/libm/common/s_modf.c                   |   1 +
 newlib/libm/common/s_nan.c                    |   2 +
 newlib/libm/common/s_nearbyint.c              |   2 +
 newlib/libm/common/s_nextafter.c              |   1 +
 newlib/libm/common/s_pow10.c                  |   2 +
 newlib/libm/common/s_remquo.c                 |   1 +
 newlib/libm/common/s_rint.c                   |   1 +
 newlib/libm/common/s_round.c                  |   1 +
 newlib/libm/common/s_scalbln.c                |  32 ++-
 newlib/libm/common/s_scalbn.c                 |   1 +
 newlib/libm/common/s_signbit.c                |   3 +
 newlib/libm/common/s_trunc.c                  |   1 +
 newlib/libm/common/scalblnl.c                 |   2 +
 newlib/libm/common/scalbnl.c                  |   2 +
 newlib/libm/common/sf_cbrt.c                  |  15 +-
 newlib/libm/common/sf_copysign.c              |   3 +
 newlib/libm/common/sf_exp10.c                 |   3 +
 newlib/libm/common/sf_expm1.c                 |   2 +
 newlib/libm/common/sf_fdim.c                  |  17 +-
 newlib/libm/common/sf_finite.c                |   3 +
 newlib/libm/common/sf_fma.c                   |   3 +
 newlib/libm/common/sf_fmax.c                  |  11 +-
 newlib/libm/common/sf_fmin.c                  |  11 +-
 newlib/libm/common/sf_fpclassify.c            |   1 +
 newlib/libm/common/sf_ilogb.c                 |   2 +
 newlib/libm/common/sf_infinity.c              |   3 +
 newlib/libm/common/sf_isinf.c                 |   3 +
 newlib/libm/common/sf_isinff.c                |   3 +
 newlib/libm/common/sf_isnan.c                 |   3 +
 newlib/libm/common/sf_isnanf.c                |   3 +
 newlib/libm/common/sf_llrint.c                |   2 +
 newlib/libm/common/sf_llround.c               |   2 +
 newlib/libm/common/sf_log1p.c                 |   2 +
 newlib/libm/common/sf_log2.c                  |   3 +
 newlib/libm/common/sf_logb.c                  |   2 +
 newlib/libm/common/sf_lrint.c                 |   2 +
 newlib/libm/common/sf_lround.c                |   2 +
 newlib/libm/common/sf_modf.c                  |   2 +
 newlib/libm/common/sf_nan.c                   |   3 +
 newlib/libm/common/sf_nearbyint.c             |   3 +
 newlib/libm/common/sf_nextafter.c             |   2 +
 newlib/libm/common/sf_pow10.c                 |   3 +
 newlib/libm/common/sf_remquo.c                |   1 +
 newlib/libm/common/sf_rint.c                  |   2 +
 newlib/libm/common/sf_round.c                 |   2 +
 newlib/libm/common/sf_scalbln.c               |  34 ++-
 newlib/libm/common/sf_scalbn.c                |   2 +
 newlib/libm/common/sf_trunc.c                 |   2 +
 newlib/libm/common/sinhl.c                    |   2 +
 newlib/libm/common/sinl.c                     |   2 +
 newlib/libm/common/sl_finite.c                |   1 +
 newlib/libm/common/sqrtl.c                    |   4 +
 newlib/libm/common/tanhl.c                    |   2 +
 newlib/libm/common/tanl.c                     |   2 +
 newlib/libm/common/tgammal.c                  |   2 +
 newlib/libm/common/truncl.c                   |   2 +
 newlib/libm/complex/cabs.c                    |   2 +
 newlib/libm/complex/cabsf.c                   |   2 +
 newlib/libm/complex/cabsl.c                   |   1 +
 newlib/libm/complex/cacos.c                   |   2 +
 newlib/libm/complex/cacosf.c                  |   2 +
 newlib/libm/complex/cacosh.c                  |   2 +
 newlib/libm/complex/cacoshf.c                 |   2 +
 newlib/libm/complex/cacoshl.c                 |   2 +
 newlib/libm/complex/cacosl.c                  |   2 +
 newlib/libm/complex/carg.c                    |   2 +
 newlib/libm/complex/cargf.c                   |   2 +
 newlib/libm/complex/cargl.c                   |   1 +
 newlib/libm/complex/casin.c                   |   2 +
 newlib/libm/complex/casinf.c                  |   2 +
 newlib/libm/complex/casinh.c                  |   2 +
 newlib/libm/complex/casinhf.c                 |   2 +
 newlib/libm/complex/casinhl.c                 |   2 +
 newlib/libm/complex/casinl.c                  |   2 +
 newlib/libm/complex/catan.c                   |   3 +
 newlib/libm/complex/catanf.c                  |   3 +
 newlib/libm/complex/catanh.c                  |   2 +
 newlib/libm/complex/catanhf.c                 |   2 +
 newlib/libm/complex/catanhl.c                 |   2 +
 newlib/libm/complex/catanl.c                  |   3 +
 newlib/libm/complex/ccos.c                    |   2 +
 newlib/libm/complex/ccosf.c                   |   2 +
 newlib/libm/complex/ccosh.c                   |   2 +
 newlib/libm/complex/ccoshf.c                  |   2 +
 newlib/libm/complex/ccoshl.c                  |   2 +
 newlib/libm/complex/ccosl.c                   |   2 +
 newlib/libm/complex/cephes_subr.c             |   4 +
 newlib/libm/complex/cephes_subrf.c            |   4 +
 newlib/libm/complex/cephes_subrl.c            |   4 +
 newlib/libm/complex/cexp.c                    |   2 +
 newlib/libm/complex/cexpf.c                   |   2 +
 newlib/libm/complex/cexpl.c                   |   2 +
 newlib/libm/complex/cimag.c                   |   2 +
 newlib/libm/complex/cimagf.c                  |   2 +
 newlib/libm/complex/cimagl.c                  |   2 +
 newlib/libm/complex/clog.c                    |   2 +
 newlib/libm/complex/clog10.c                  |   2 +
 newlib/libm/complex/clog10f.c                 |   2 +
 newlib/libm/complex/clogf.c                   |   2 +
 newlib/libm/complex/clogl.c                   |   2 +
 newlib/libm/complex/conj.c                    |   2 +
 newlib/libm/complex/conjf.c                   |   2 +
 newlib/libm/complex/conjl.c                   |   2 +
 newlib/libm/complex/cpow.c                    |   3 +
 newlib/libm/complex/cpowf.c                   |   3 +
 newlib/libm/complex/cpowl.c                   |   3 +
 newlib/libm/complex/cproj.c                   |   2 +
 newlib/libm/complex/cprojf.c                  |   2 +
 newlib/libm/complex/cprojl.c                  |   2 +
 newlib/libm/complex/creal.c                   |   2 +
 newlib/libm/complex/crealf.c                  |   2 +
 newlib/libm/complex/creall.c                  |   2 +
 newlib/libm/complex/csin.c                    |   2 +
 newlib/libm/complex/csinf.c                   |   2 +
 newlib/libm/complex/csinh.c                   |   2 +
 newlib/libm/complex/csinhf.c                  |   2 +
 newlib/libm/complex/csinhl.c                  |   2 +
 newlib/libm/complex/csinl.c                   |   2 +
 newlib/libm/complex/csqrt.c                   |   4 +
 newlib/libm/complex/csqrtf.c                  |   1 +
 newlib/libm/complex/csqrtl.c                  |   1 +
 newlib/libm/complex/ctan.c                    |   3 +
 newlib/libm/complex/ctanf.c                   |   3 +
 newlib/libm/complex/ctanh.c                   |   2 +
 newlib/libm/complex/ctanhf.c                  |   2 +
 newlib/libm/complex/ctanhl.c                  |   2 +
 newlib/libm/complex/ctanl.c                   |   3 +
 newlib/libm/machine/aarch64/e_sqrt.c          |   2 +
 newlib/libm/machine/aarch64/ef_sqrt.c         |   2 +
 newlib/libm/machine/aarch64/s_ceil.c          |   2 +
 newlib/libm/machine/aarch64/s_fabs.c          |   2 +
 newlib/libm/machine/aarch64/s_floor.c         |   2 +
 newlib/libm/machine/aarch64/s_fma.c           |   2 +
 newlib/libm/machine/aarch64/s_fmax.c          |   2 +
 newlib/libm/machine/aarch64/s_fmin.c          |   2 +
 newlib/libm/machine/aarch64/s_llrint.c        |   2 +
 newlib/libm/machine/aarch64/s_llround.c       |   2 +
 newlib/libm/machine/aarch64/s_lrint.c         |   2 +
 newlib/libm/machine/aarch64/s_lround.c        |   2 +
 newlib/libm/machine/aarch64/s_nearbyint.c     |   2 +
 newlib/libm/machine/aarch64/s_rint.c          |   2 +
 newlib/libm/machine/aarch64/s_round.c         |   2 +
 newlib/libm/machine/aarch64/s_trunc.c         |   2 +
 newlib/libm/machine/aarch64/sf_ceil.c         |   2 +
 newlib/libm/machine/aarch64/sf_fabs.c         |   2 +
 newlib/libm/machine/aarch64/sf_floor.c        |   2 +
 newlib/libm/machine/aarch64/sf_fma.c          |   2 +
 newlib/libm/machine/aarch64/sf_fmax.c         |   2 +
 newlib/libm/machine/aarch64/sf_fmin.c         |   2 +
 newlib/libm/machine/aarch64/sf_llrint.c       |   2 +
 newlib/libm/machine/aarch64/sf_llround.c      |   2 +
 newlib/libm/machine/aarch64/sf_lrint.c        |   2 +
 newlib/libm/machine/aarch64/sf_lround.c       |   2 +
 newlib/libm/machine/aarch64/sf_nearbyint.c    |   2 +
 newlib/libm/machine/aarch64/sf_rint.c         |   2 +
 newlib/libm/machine/aarch64/sf_round.c        |   2 +
 newlib/libm/machine/aarch64/sf_trunc.c        |   2 +
 newlib/libm/machine/arm/e_sqrt.c              |   2 +
 newlib/libm/machine/arm/ef_sqrt.c             |   2 +
 newlib/libm/machine/arm/s_ceil.c              |   2 +
 newlib/libm/machine/arm/s_floor.c             |   2 +
 newlib/libm/machine/arm/s_nearbyint.c         |   2 +
 newlib/libm/machine/arm/s_rint.c              |   2 +
 newlib/libm/machine/arm/s_round.c             |   2 +
 newlib/libm/machine/arm/s_trunc.c             |   2 +
 newlib/libm/machine/arm/sf_ceil.c             |   2 +
 newlib/libm/machine/arm/sf_floor.c            |   2 +
 newlib/libm/machine/arm/sf_nearbyint.c        |   2 +
 newlib/libm/machine/arm/sf_rint.c             |   2 +
 newlib/libm/machine/arm/sf_round.c            |   2 +
 newlib/libm/machine/arm/sf_trunc.c            |   2 +
 newlib/libm/machine/i386/f_exp.c              |   1 +
 newlib/libm/machine/i386/f_expf.c             |   1 +
 newlib/libm/machine/i386/f_llrint.c           |   2 +
 newlib/libm/machine/i386/f_llrintf.c          |   2 +
 newlib/libm/machine/i386/f_llrintl.c          |   3 +
 newlib/libm/machine/i386/f_lrint.c            |   2 +
 newlib/libm/machine/i386/f_lrintf.c           |   2 +
 newlib/libm/machine/i386/f_lrintl.c           |   3 +
 newlib/libm/machine/i386/f_pow.c              |   1 +
 newlib/libm/machine/i386/f_powf.c             |   1 +
 newlib/libm/machine/i386/f_rint.c             |   2 +
 newlib/libm/machine/i386/f_rintf.c            |   2 +
 newlib/libm/machine/i386/f_rintl.c            |   3 +
 newlib/libm/machine/riscv/fe_dfl_env.c        |   1 +
 newlib/libm/machine/riscv/feclearexcept.c     |   2 +
 newlib/libm/machine/riscv/fegetenv.c          |   2 +
 newlib/libm/machine/riscv/fegetexceptflag.c   |   2 +
 newlib/libm/machine/riscv/fegetround.c        |   1 +
 newlib/libm/machine/riscv/feholdexcept.c      |   2 +
 newlib/libm/machine/riscv/feraiseexcept.c     |   2 +
 newlib/libm/machine/riscv/fesetenv.c          |   2 +
 newlib/libm/machine/riscv/fesetexceptflag.c   |   2 +
 newlib/libm/machine/riscv/fesetround.c        |   2 +
 newlib/libm/machine/riscv/fetestexcept.c      |   1 +
 newlib/libm/machine/riscv/feupdateenv.c       |   1 +
 newlib/libm/machine/spu/fe_dfl_env.c          |   1 +
 newlib/libm/machine/spu/feclearexcept.c       |   2 +
 newlib/libm/machine/spu/fegetenv.c            |   2 +
 newlib/libm/machine/spu/fegetexceptflag.c     |   2 +
 newlib/libm/machine/spu/fegetround.c          |   2 +
 newlib/libm/machine/spu/feholdexcept.c        |   2 +
 newlib/libm/machine/spu/feraiseexcept.c       |   2 +
 newlib/libm/machine/spu/fesetenv.c            |   2 +
 newlib/libm/machine/spu/fesetexceptflag.c     |   2 +
 newlib/libm/machine/spu/fesetround.c          |   2 +
 newlib/libm/machine/spu/fetestexcept.c        |   2 +
 newlib/libm/machine/spu/feupdateenv.c         |   2 +
 newlib/libm/machine/spu/llrint.c              |   2 +
 newlib/libm/machine/spu/llrintf.c             |   2 +
 newlib/libm/machine/spu/llround.c             |   2 +
 newlib/libm/machine/spu/llroundf.c            |   2 +
 newlib/libm/machine/spu/log2.c                |   2 +
 newlib/libm/machine/spu/log2f.c               |   2 +
 newlib/libm/machine/spu/s_asinh.c             |   2 +
 newlib/libm/machine/spu/s_atan.c              |   2 +
 newlib/libm/machine/spu/s_cbrt.c              |   2 +
 newlib/libm/machine/spu/s_ceil.c              |   2 +
 newlib/libm/machine/spu/s_copysign.c          |   2 +
 newlib/libm/machine/spu/s_cos.c               |   2 +
 newlib/libm/machine/spu/s_erf.c               |   3 +
 newlib/libm/machine/spu/s_expm1.c             |   2 +
 newlib/libm/machine/spu/s_fabs.c              |   2 +
 newlib/libm/machine/spu/s_fdim.c              |   2 +
 newlib/libm/machine/spu/s_floor.c             |   2 +
 newlib/libm/machine/spu/s_fma.c               |   2 +
 newlib/libm/machine/spu/s_fmax.c              |   2 +
 newlib/libm/machine/spu/s_fmin.c              |   2 +
 newlib/libm/machine/spu/s_frexp.c             |   2 +
 newlib/libm/machine/spu/s_ilogb.c             |   2 +
 newlib/libm/machine/spu/s_isnan.c             |   2 +
 newlib/libm/machine/spu/s_ldexp.c             |   2 +
 newlib/libm/machine/spu/s_log1p.c             |   2 +
 newlib/libm/machine/spu/s_lrint.c             |   2 +
 newlib/libm/machine/spu/s_lround.c            |   2 +
 newlib/libm/machine/spu/s_nearbyint.c         |   2 +
 newlib/libm/machine/spu/s_nextafter.c         |   2 +
 newlib/libm/machine/spu/s_remquo.c            |   2 +
 newlib/libm/machine/spu/s_rint.c              |   2 +
 newlib/libm/machine/spu/s_round.c             |   2 +
 newlib/libm/machine/spu/s_scalbn.c            |   2 +
 newlib/libm/machine/spu/s_sin.c               |   2 +
 newlib/libm/machine/spu/s_tan.c               |   2 +
 newlib/libm/machine/spu/s_tanh.c              |   2 +
 newlib/libm/machine/spu/s_trunc.c             |   2 +
 newlib/libm/machine/spu/sf_asinh.c            |   2 +
 newlib/libm/machine/spu/sf_atan.c             |   2 +
 newlib/libm/machine/spu/sf_cbrt.c             |   2 +
 newlib/libm/machine/spu/sf_ceil.c             |   2 +
 newlib/libm/machine/spu/sf_copysign.c         |   2 +
 newlib/libm/machine/spu/sf_cos.c              |   2 +
 newlib/libm/machine/spu/sf_erf.c              |   3 +
 newlib/libm/machine/spu/sf_expm1.c            |   2 +
 newlib/libm/machine/spu/sf_fabs.c             |   2 +
 newlib/libm/machine/spu/sf_fdim.c             |   2 +
 newlib/libm/machine/spu/sf_finite.c           |   2 +
 newlib/libm/machine/spu/sf_floor.c            |   2 +
 newlib/libm/machine/spu/sf_fma.c              |   2 +
 newlib/libm/machine/spu/sf_fmax.c             |   2 +
 newlib/libm/machine/spu/sf_fmin.c             |   2 +
 newlib/libm/machine/spu/sf_fpclassify.c       |   6 +-
 newlib/libm/machine/spu/sf_frexp.c            |   2 +
 newlib/libm/machine/spu/sf_ilogb.c            |   2 +
 newlib/libm/machine/spu/sf_isinf.c            |   2 +
 newlib/libm/machine/spu/sf_isinff.c           |   2 +
 newlib/libm/machine/spu/sf_isnan.c            |   2 +
 newlib/libm/machine/spu/sf_isnanf.c           |   2 +
 newlib/libm/machine/spu/sf_ldexp.c            |   2 +
 newlib/libm/machine/spu/sf_log1p.c            |   2 +
 newlib/libm/machine/spu/sf_logb.c             |   2 +
 newlib/libm/machine/spu/sf_lrint.c            |   2 +
 newlib/libm/machine/spu/sf_lround.c           |   2 +
 newlib/libm/machine/spu/sf_nan.c              |   2 +
 newlib/libm/machine/spu/sf_nearbyint.c        |   2 +
 newlib/libm/machine/spu/sf_nextafter.c        |   2 +
 newlib/libm/machine/spu/sf_remquo.c           |   2 +
 newlib/libm/machine/spu/sf_rint.c             |   2 +
 newlib/libm/machine/spu/sf_round.c            |   2 +
 newlib/libm/machine/spu/sf_scalbn.c           |   2 +
 newlib/libm/machine/spu/sf_sin.c              |   2 +
 newlib/libm/machine/spu/sf_tan.c              |   2 +
 newlib/libm/machine/spu/sf_tanh.c             |   2 +
 newlib/libm/machine/spu/sf_trunc.c            |   2 +
 newlib/libm/machine/spu/w_acos.c              |   2 +
 newlib/libm/machine/spu/w_acosh.c             |   2 +
 newlib/libm/machine/spu/w_asin.c              |   2 +
 newlib/libm/machine/spu/w_atan2.c             |   2 +
 newlib/libm/machine/spu/w_atanh.c             |   2 +
 newlib/libm/machine/spu/w_cosh.c              |   2 +
 newlib/libm/machine/spu/w_exp.c               |   2 +
 newlib/libm/machine/spu/w_exp2.c              |   2 +
 newlib/libm/machine/spu/w_fmod.c              |   2 +
 newlib/libm/machine/spu/w_hypot.c             |   2 +
 newlib/libm/machine/spu/w_lgamma.c            |   2 +
 newlib/libm/machine/spu/w_log.c               |   2 +
 newlib/libm/machine/spu/w_log10.c             |   2 +
 newlib/libm/machine/spu/w_pow.c               |   2 +
 newlib/libm/machine/spu/w_remainder.c         |   2 +
 newlib/libm/machine/spu/w_sincos.c            |   2 +
 newlib/libm/machine/spu/w_sinh.c              |   2 +
 newlib/libm/machine/spu/w_sqrt.c              |   2 +
 newlib/libm/machine/spu/w_tgamma.c            |   2 +
 newlib/libm/machine/spu/wf_acos.c             |   2 +
 newlib/libm/machine/spu/wf_acosh.c            |   2 +
 newlib/libm/machine/spu/wf_asin.c             |   2 +
 newlib/libm/machine/spu/wf_atan2.c            |   2 +
 newlib/libm/machine/spu/wf_atanh.c            |   2 +
 newlib/libm/machine/spu/wf_cosh.c             |   2 +
 newlib/libm/machine/spu/wf_exp.c              |   2 +
 newlib/libm/machine/spu/wf_exp2.c             |   2 +
 newlib/libm/machine/spu/wf_fmod.c             |   2 +
 newlib/libm/machine/spu/wf_hypot.c            |   2 +
 newlib/libm/machine/spu/wf_lgamma.c           |   2 +
 newlib/libm/machine/spu/wf_log.c              |   2 +
 newlib/libm/machine/spu/wf_log10.c            |   2 +
 newlib/libm/machine/spu/wf_pow.c              |   2 +
 newlib/libm/machine/spu/wf_remainder.c        |   2 +
 newlib/libm/machine/spu/wf_sincos.c           |   2 +
 newlib/libm/machine/spu/wf_sinh.c             |   2 +
 newlib/libm/machine/spu/wf_sqrt.c             |   2 +
 newlib/libm/machine/spu/wf_tgamma.c           |   2 +
 newlib/libm/math/e_acos.c                     |   1 +
 newlib/libm/math/e_acosh.c                    |   1 +
 newlib/libm/math/e_asin.c                     |   1 +
 newlib/libm/math/e_atan2.c                    |   1 +
 newlib/libm/math/e_atanh.c                    |   1 +
 newlib/libm/math/e_cosh.c                     |  20 +-
 newlib/libm/math/e_exp.c                      |   1 +
 newlib/libm/math/e_fmod.c                     |   1 +
 newlib/libm/math/e_hypot.c                    |   1 +
 newlib/libm/math/e_j0.c                       |  21 +-
 newlib/libm/math/e_j1.c                       |  21 +-
 newlib/libm/math/e_jn.c                       |   1 +
 newlib/libm/math/e_log.c                      |   1 +
 newlib/libm/math/e_log10.c                    |  18 +-
 newlib/libm/math/e_pow.c                      |   1 +
 newlib/libm/math/e_rem_pio2.c                 |   1 +
 newlib/libm/math/e_remainder.c                |  16 +-
 newlib/libm/math/e_scalb.c                    |   1 +
 newlib/libm/math/e_sinh.c                     |  24 +-
 newlib/libm/math/e_sqrt.c                     |   1 +
 newlib/libm/math/ef_acos.c                    |   1 +
 newlib/libm/math/ef_acosh.c                   |   1 +
 newlib/libm/math/ef_asin.c                    |   1 +
 newlib/libm/math/ef_atan2.c                   |   1 +
 newlib/libm/math/ef_atanh.c                   |   1 +
 newlib/libm/math/ef_cosh.c                    |  19 +-
 newlib/libm/math/ef_exp.c                     |   1 +
 newlib/libm/math/ef_fmod.c                    |   1 +
 newlib/libm/math/ef_hypot.c                   |   1 +
 newlib/libm/math/ef_j0.c                      |  21 +-
 newlib/libm/math/ef_j1.c                      |  21 +-
 newlib/libm/math/ef_jn.c                      |   1 +
 newlib/libm/math/ef_log.c                     |   1 +
 newlib/libm/math/ef_log10.c                   |  18 +-
 newlib/libm/math/ef_pow.c                     |   1 +
 newlib/libm/math/ef_rem_pio2.c                |   1 +
 newlib/libm/math/ef_remainder.c               |  11 +-
 newlib/libm/math/ef_scalb.c                   |   1 +
 newlib/libm/math/ef_sinh.c                    |  24 +-
 newlib/libm/math/ef_sqrt.c                    |  18 +-
 newlib/libm/math/el_hypot.c                   |   1 +
 newlib/libm/math/er_gamma.c                   |   2 +
 newlib/libm/math/er_lgamma.c                  |   7 +-
 newlib/libm/math/erf_gamma.c                  |   2 +
 newlib/libm/math/erf_lgamma.c                 |   7 +-
 newlib/libm/math/k_cos.c                      |   1 +
 newlib/libm/math/k_rem_pio2.c                 |   2 +
 newlib/libm/math/k_sin.c                      |   1 +
 newlib/libm/math/k_standard.c                 |   2 +
 newlib/libm/math/k_tan.c                      |   1 +
 newlib/libm/math/kf_cos.c                     |   1 +
 newlib/libm/math/kf_rem_pio2.c                |   2 +
 newlib/libm/math/kf_sin.c                     |   1 +
 newlib/libm/math/kf_tan.c                     |   1 +
 newlib/libm/math/s_asinh.c                    |   1 +
 newlib/libm/math/s_atan.c                     |   1 +
 newlib/libm/math/s_ceil.c                     |   1 +
 newlib/libm/math/s_cos.c                      |   1 +
 newlib/libm/math/s_erf.c                      |   1 +
 newlib/libm/math/s_fabs.c                     |   2 +
 newlib/libm/math/s_floor.c                    |   1 +
 newlib/libm/math/s_frexp.c                    |   7 +-
 newlib/libm/math/s_ldexp.c                    |   7 +-
 newlib/libm/math/s_signif.c                   |   2 +
 newlib/libm/math/s_sin.c                      |   1 +
 newlib/libm/math/s_tan.c                      |   1 +
 newlib/libm/math/s_tanh.c                     |   1 +
 newlib/libm/math/sf_asinh.c                   |   2 +
 newlib/libm/math/sf_atan.c                    |   2 +
 newlib/libm/math/sf_ceil.c                    |   2 +
 newlib/libm/math/sf_cos.c                     |   2 +
 newlib/libm/math/sf_erf.c                     |   3 +
 newlib/libm/math/sf_fabs.c                    |   3 +
 newlib/libm/math/sf_floor.c                   |   2 +
 newlib/libm/math/sf_frexp.c                   |   8 +-
 newlib/libm/math/sf_ldexp.c                   |   8 +-
 newlib/libm/math/sf_signif.c                  |   3 +
 newlib/libm/math/sf_sin.c                     |   2 +
 newlib/libm/math/sf_tan.c                     |   2 +
 newlib/libm/math/sf_tanh.c                    |   2 +
 newlib/libm/math/w_acos.c                     |   1 +
 newlib/libm/math/w_acosh.c                    |   1 +
 newlib/libm/math/w_asin.c                     |   1 +
 newlib/libm/math/w_atan2.c                    |   2 +
 newlib/libm/math/w_atanh.c                    |   1 +
 newlib/libm/math/w_cosh.c                     |   1 +
 newlib/libm/math/w_drem.c                     |   2 +
 newlib/libm/math/w_exp.c                      |   1 +
 newlib/libm/math/w_exp2.c                     |   2 +
 newlib/libm/math/w_fmod.c                     |   1 +
 newlib/libm/math/w_gamma.c                    |   1 +
 newlib/libm/math/w_hypot.c                    |   1 +
 newlib/libm/math/w_j0.c                       |   1 +
 newlib/libm/math/w_j1.c                       |   1 +
 newlib/libm/math/w_jn.c                       |   1 +
 newlib/libm/math/w_lgamma.c                   |   1 +
 newlib/libm/math/w_log.c                      |   1 +
 newlib/libm/math/w_log10.c                    |   1 +
 newlib/libm/math/w_pow.c                      |   1 +
 newlib/libm/math/w_remainder.c                |   1 +
 newlib/libm/math/w_scalb.c                    |   1 +
 newlib/libm/math/w_sincos.c                   |   2 +
 newlib/libm/math/w_sinh.c                     |   1 +
 newlib/libm/math/w_sqrt.c                     |   1 +
 newlib/libm/math/w_tgamma.c                   |   1 +
 newlib/libm/math/wf_acos.c                    |   2 +
 newlib/libm/math/wf_acosh.c                   |   2 +
 newlib/libm/math/wf_asin.c                    |   2 +
 newlib/libm/math/wf_atan2.c                   |   3 +
 newlib/libm/math/wf_atanh.c                   |   2 +
 newlib/libm/math/wf_cosh.c                    |   2 +
 newlib/libm/math/wf_drem.c                    |   2 +
 newlib/libm/math/wf_exp.c                     |   2 +
 newlib/libm/math/wf_exp2.c                    |   3 +
 newlib/libm/math/wf_fmod.c                    |   2 +
 newlib/libm/math/wf_gamma.c                   |   2 +
 newlib/libm/math/wf_hypot.c                   |   2 +
 newlib/libm/math/wf_j0.c                      |   3 +
 newlib/libm/math/wf_j1.c                      |   3 +
 newlib/libm/math/wf_jn.c                      |   3 +
 newlib/libm/math/wf_lgamma.c                  |   2 +
 newlib/libm/math/wf_log.c                     |   2 +
 newlib/libm/math/wf_log10.c                   |   2 +
 newlib/libm/math/wf_pow.c                     |   2 +
 newlib/libm/math/wf_remainder.c               |   2 +
 newlib/libm/math/wf_scalb.c                   |   1 +
 newlib/libm/math/wf_sincos.c                  |   3 +
 newlib/libm/math/wf_sinh.c                    |   2 +
 newlib/libm/math/wf_sqrt.c                    |   2 +
 newlib/libm/math/wf_tgamma.c                  |   2 +
 newlib/libm/math/wr_gamma.c                   |   1 +
 newlib/libm/math/wr_lgamma.c                  |   1 +
 newlib/libm/math/wrf_gamma.c                  |   1 +
 newlib/libm/math/wrf_lgamma.c                 |   1 +
 newlib/libm/mathfp/e_acosh.c                  |   1 +
 newlib/libm/mathfp/e_atanh.c                  |   1 +
 newlib/libm/mathfp/e_hypot.c                  |   1 +
 newlib/libm/mathfp/e_j0.c                     |  21 +-
 newlib/libm/mathfp/e_j1.c                     |  21 +-
 newlib/libm/mathfp/e_remainder.c              |  16 +-
 newlib/libm/mathfp/e_scalb.c                  |   1 +
 newlib/libm/mathfp/ef_acosh.c                 |   1 +
 newlib/libm/mathfp/ef_atanh.c                 |   1 +
 newlib/libm/mathfp/ef_hypot.c                 |   1 +
 newlib/libm/mathfp/ef_j0.c                    |  21 +-
 newlib/libm/mathfp/ef_j1.c                    |  21 +-
 newlib/libm/mathfp/ef_remainder.c             |  16 +-
 newlib/libm/mathfp/ef_scalb.c                 |   1 +
 newlib/libm/mathfp/er_gamma.c                 |   3 +
 newlib/libm/mathfp/er_lgamma.c                |   8 +-
 newlib/libm/mathfp/erf_gamma.c                |   3 +
 newlib/libm/mathfp/erf_lgamma.c               |   8 +-
 newlib/libm/mathfp/s_acos.c                   |   2 +
 newlib/libm/mathfp/s_asin.c                   |   2 +
 newlib/libm/mathfp/s_asine.c                  |   1 +
 newlib/libm/mathfp/s_asinh.c                  |   1 +
 newlib/libm/mathfp/s_atan.c                   |   5 +
 newlib/libm/mathfp/s_atan2.c                  |   2 +
 newlib/libm/mathfp/s_atangent.c               |   1 +
 newlib/libm/mathfp/s_ceil.c                   |   1 +
 newlib/libm/mathfp/s_cos.c                    |   2 +
 newlib/libm/mathfp/s_cosh.c                   |   2 +
 newlib/libm/mathfp/s_erf.c                    |   1 +
 newlib/libm/mathfp/s_exp.c                    |   1 +
 newlib/libm/mathfp/s_exp2.c                   |   2 +
 newlib/libm/mathfp/s_fabs.c                   |   5 +
 newlib/libm/mathfp/s_floor.c                  |  10 +-
 newlib/libm/mathfp/s_fmod.c                   |   1 +
 newlib/libm/mathfp/s_frexp.c                  |   3 +
 newlib/libm/mathfp/s_ispos.c                  |   1 +
 newlib/libm/mathfp/s_ldexp.c                  |   2 +
 newlib/libm/mathfp/s_log.c                    |   2 +
 newlib/libm/mathfp/s_log10.c                  |   2 +
 newlib/libm/mathfp/s_logarithm.c              |   1 +
 newlib/libm/mathfp/s_mathcnst.c               |   1 +
 newlib/libm/mathfp/s_numtest.c                |   1 +
 newlib/libm/mathfp/s_pow.c                    |   1 +
 newlib/libm/mathfp/s_signif.c                 |   2 +
 newlib/libm/mathfp/s_sin.c                    |   2 +
 newlib/libm/mathfp/s_sincos.c                 |   2 +
 newlib/libm/mathfp/s_sine.c                   |   5 +
 newlib/libm/mathfp/s_sineh.c                  |   1 +
 newlib/libm/mathfp/s_sinf.c                   |   3 +
 newlib/libm/mathfp/s_sinh.c                   |   2 +
 newlib/libm/mathfp/s_sqrt.c                   |   1 +
 newlib/libm/mathfp/s_tan.c                    |   5 +
 newlib/libm/mathfp/s_tanh.c                   |   2 +
 newlib/libm/mathfp/s_tgamma.c                 |   1 +
 newlib/libm/mathfp/sf_acos.c                  |   3 +
 newlib/libm/mathfp/sf_asin.c                  |   3 +
 newlib/libm/mathfp/sf_asine.c                 |   1 +
 newlib/libm/mathfp/sf_asinh.c                 |   2 +
 newlib/libm/mathfp/sf_atan.c                  |   6 +
 newlib/libm/mathfp/sf_atan2.c                 |   3 +
 newlib/libm/mathfp/sf_atangent.c              |   1 +
 newlib/libm/mathfp/sf_ceil.c                  |   2 +
 newlib/libm/mathfp/sf_cos.c                   |   3 +
 newlib/libm/mathfp/sf_cosh.c                  |   3 +
 newlib/libm/mathfp/sf_erf.c                   |   3 +
 newlib/libm/mathfp/sf_exp.c                   |   2 +
 newlib/libm/mathfp/sf_exp2.c                  |   3 +
 newlib/libm/mathfp/sf_fabs.c                  |   6 +
 newlib/libm/mathfp/sf_floor.c                 |  11 +-
 newlib/libm/mathfp/sf_fmod.c                  |   1 +
 newlib/libm/mathfp/sf_frexp.c                 |   4 +
 newlib/libm/mathfp/sf_ispos.c                 |   2 +
 newlib/libm/mathfp/sf_ldexp.c                 |   3 +
 newlib/libm/mathfp/sf_log.c                   |   3 +
 newlib/libm/mathfp/sf_log10.c                 |   3 +
 newlib/libm/mathfp/sf_logarithm.c             |   1 +
 newlib/libm/mathfp/sf_numtest.c               |   2 +
 newlib/libm/mathfp/sf_pow.c                   |   2 +
 newlib/libm/mathfp/sf_signif.c                |   3 +
 newlib/libm/mathfp/sf_sin.c                   |   3 +
 newlib/libm/mathfp/sf_sincos.c                |   3 +
 newlib/libm/mathfp/sf_sine.c                  |   5 +
 newlib/libm/mathfp/sf_sineh.c                 |   1 +
 newlib/libm/mathfp/sf_sinh.c                  |   3 +
 newlib/libm/mathfp/sf_sqrt.c                  |   2 +
 newlib/libm/mathfp/sf_tan.c                   |   6 +
 newlib/libm/mathfp/sf_tanh.c                  |   3 +
 newlib/libm/mathfp/sf_tgamma.c                |   1 +
 newlib/libm/mathfp/w_cabs.c                   |   2 +
 newlib/libm/mathfp/w_drem.c                   |   2 +
 newlib/libm/mathfp/w_jn.c                     |   1 +
 newlib/libm/mathfp/wf_cabs.c                  |   2 +
 newlib/libm/mathfp/wf_drem.c                  |   2 +
 newlib/libm/mathfp/wf_jn.c                    |   3 +
 newlib/libm/test/acos_vec.c                   |   4 +-
 newlib/libm/test/acosf_vec.c                  |   4 +-
 newlib/libm/test/acosh_vec.c                  |   4 +-
 newlib/libm/test/acoshf_vec.c                 |   4 +-
 newlib/libm/test/asin_vec.c                   |   4 +-
 newlib/libm/test/asinf_vec.c                  |   4 +-
 newlib/libm/test/asinh_vec.c                  |   4 +-
 newlib/libm/test/asinhf_vec.c                 |   4 +-
 newlib/libm/test/atan2_vec.c                  |   4 +-
 newlib/libm/test/atan2f_vec.c                 |   4 +-
 newlib/libm/test/atan_vec.c                   |   4 +-
 newlib/libm/test/atanf_vec.c                  |   4 +-
 newlib/libm/test/atanh_vec.c                  |   4 +-
 newlib/libm/test/atanhf_vec.c                 |   4 +-
 newlib/libm/test/ceil_vec.c                   |   4 +-
 newlib/libm/test/ceilf_vec.c                  |   4 +-
 newlib/libm/test/conv_vec.c                   |   1 +
 newlib/libm/test/convert.c                    |  21 ++
 newlib/libm/test/cos_vec.c                    |   4 +-
 newlib/libm/test/cosf_vec.c                   |   4 +-
 newlib/libm/test/cosh_vec.c                   |   4 +-
 newlib/libm/test/coshf_vec.c                  |   4 +-
 newlib/libm/test/dcvt.c                       |  14 ++
 newlib/libm/test/dvec.c                       |   1 +
 newlib/libm/test/erf_vec.c                    |   4 +-
 newlib/libm/test/erfc_vec.c                   |   4 +-
 newlib/libm/test/erfcf_vec.c                  |   4 +-
 newlib/libm/test/erff_vec.c                   |   4 +-
 newlib/libm/test/exp_vec.c                    |   4 +-
 newlib/libm/test/expf_vec.c                   |   4 +-
 newlib/libm/test/fabs_vec.c                   |   4 +-
 newlib/libm/test/fabsf_vec.c                  |   4 +-
 newlib/libm/test/floor_vec.c                  |   4 +-
 newlib/libm/test/floorf_vec.c                 |   4 +-
 newlib/libm/test/fmod_vec.c                   |   4 +-
 newlib/libm/test/fmodf_vec.c                  |   4 +-
 newlib/libm/test/gamma_vec.c                  |   4 +-
 newlib/libm/test/gammaf_vec.c                 |   4 +-
 newlib/libm/test/hypot_vec.c                  |   4 +-
 newlib/libm/test/hypotf_vec.c                 |   4 +-
 newlib/libm/test/iconv_vec.c                  |   1 +
 newlib/libm/test/j0_vec.c                     |   4 +-
 newlib/libm/test/j0f_vec.c                    |   4 +-
 newlib/libm/test/j1_vec.c                     |   4 +-
 newlib/libm/test/j1f_vec.c                    |   4 +-
 newlib/libm/test/jn_vec.c                     |   4 +-
 newlib/libm/test/jnf_vec.c                    |   4 +-
 newlib/libm/test/log10_vec.c                  |   4 +-
 newlib/libm/test/log10f_vec.c                 |   4 +-
 newlib/libm/test/log1p_vec.c                  |   4 +-
 newlib/libm/test/log1pf_vec.c                 |   4 +-
 newlib/libm/test/log2_vec.c                   |   4 +-
 newlib/libm/test/log2f_vec.c                  |   4 +-
 newlib/libm/test/log_vec.c                    |   4 +-
 newlib/libm/test/logf_vec.c                   |   4 +-
 newlib/libm/test/math.c                       |  11 +
 newlib/libm/test/math2.c                      |   8 +
 newlib/libm/test/sin_vec.c                    |   4 +-
 newlib/libm/test/sinf_vec.c                   |   4 +-
 newlib/libm/test/sinh_vec.c                   |   4 +-
 newlib/libm/test/sinhf_vec.c                  |   4 +-
 newlib/libm/test/sprint_ivec.c                |   1 +
 newlib/libm/test/sprint_vec.c                 |   1 +
 newlib/libm/test/sqrt_vec.c                   |   4 +-
 newlib/libm/test/sqrtf_vec.c                  |   4 +-
 newlib/libm/test/string.c                     |   9 +-
 newlib/libm/test/tan_vec.c                    |   4 +-
 newlib/libm/test/tanf_vec.c                   |   4 +-
 newlib/libm/test/tanh_vec.c                   |   4 +-
 newlib/libm/test/tanhf_vec.c                  |   4 +-
 newlib/libm/test/test.c                       |  36 ++-
 newlib/libm/test/test_ieee.c                  |   8 +
 newlib/libm/test/test_is.c                    |  56 +++--
 newlib/libm/test/y0_vec.c                     |   4 +-
 newlib/libm/test/y0f_vec.c                    |   4 +-
 newlib/libm/test/y1_vec.c                     |   4 +-
 newlib/libm/test/y1f_vec.c                    |   4 +-
 newlib/libm/test/yn_vec.c                     |   4 +-
 newlib/libm/test/ynf_vec.c                    |   4 +-
 newlib/testsuite/newlib.elix/tmmap.c          |   2 +
 newlib/testsuite/newlib.iconv/iconvjp.c       |   4 +
 newlib/testsuite/newlib.iconv/iconvnm.c       |   3 +
 newlib/testsuite/newlib.iconv/iconvru.c       |   4 +
 newlib/testsuite/newlib.locale/UTF-8.c        |   1 +
 newlib/testsuite/newlib.search/hsearchtest.c  |   3 +
 newlib/testsuite/newlib.stdio/nulprintf.c     |   2 +
 newlib/testsuite/newlib.stdio/swprintf.c      |   2 +
 newlib/testsuite/newlib.stdlib/atexit.c       |   6 +
 newlib/testsuite/newlib.stdlib/size_max.c     |   2 +
 newlib/testsuite/newlib.string/memcpy-1.c     |   3 +
 newlib/testsuite/newlib.string/memmove1.c     |   5 +
 newlib/testsuite/newlib.string/strcmp-1.c     |   4 +
 newlib/testsuite/newlib.string/tstring.c      |   5 +
 newlib/testsuite/newlib.wctype/tiswctype.c    |   2 +
 newlib/testsuite/newlib.wctype/twctrans.c     |   2 +
 newlib/testsuite/newlib.wctype/twctype.c      |   2 +
 2953 files changed, 13334 insertions(+), 1425 deletions(-)

diff --git a/libgloss/aarch64/_exit.c b/libgloss/aarch64/_exit.c
index 1a6b015..0cb382b 100644
--- a/libgloss/aarch64/_exit.c
+++ b/libgloss/aarch64/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -44,4 +45,5 @@ _exit (int status)
 #endif
 	 do_AngelSVC (AngelSVC_Reason_ReportException, block);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/aarch64/_kill.c b/libgloss/aarch64/_kill.c
index 1d42371..c0ef026 100644
--- a/libgloss/aarch64/_kill.c
+++ b/libgloss/aarch64/_kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
diff --git a/libgloss/aarch64/ftruncate.c b/libgloss/aarch64/ftruncate.c
index 41a64d2..8cd31bf 100644
--- a/libgloss/aarch64/ftruncate.c
+++ b/libgloss/aarch64/ftruncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -30,5 +31,6 @@ int
 ftruncate (int file, off_t length)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/aarch64/libcfunc.c b/libgloss/aarch64/libcfunc.c
index 8af3a6c..701d8b5 100644
--- a/libgloss/aarch64/libcfunc.c
+++ b/libgloss/aarch64/libcfunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -46,18 +47,21 @@ unsigned __attribute__((weak))
 alarm (unsigned seconds)
 {
   (void) seconds;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 clock_t __attribute__((weak))
 clock (void)
 {
+  __A_VARIABLE = 1;
   return _clock ();
 }
 
 int __attribute__((weak))
 isatty (int fildes)
 {
+  __A_VARIABLE = 1;
   return _isatty (fildes);
 }
 
@@ -65,6 +69,7 @@ int __attribute__((weak))
 pause (void)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -76,6 +81,7 @@ sleep (unsigned seconds)
 
   while (_clock () - t0 < dt)
     ;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -87,5 +93,6 @@ usleep (useconds_t useconds)
 
   while (_clock () - t0 < dt)
     ;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/aarch64/syscalls.c b/libgloss/aarch64/syscalls.c
index af206a1..6243ea1 100644
--- a/libgloss/aarch64/syscalls.c
+++ b/libgloss/aarch64/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -144,14 +145,19 @@ findslot (int fd)
   CHECK_INIT (_REENT);
 
   /* User file descriptor is out of range. */
-  if ((unsigned int) fd >= MAX_OPEN_FILES)
+  if ((unsigned int) fd >= MAX_OPEN_FILES) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* User file descriptor is open? */
-  if (openfiles[fd].handle == -1)
+  if (openfiles[fd].handle == -1) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* Valid. */
+  __A_VARIABLE = 1;
   return &openfiles[fd];
 }
 
@@ -166,9 +172,12 @@ newslot (void)
     if (openfiles[i].handle == -1)
       break;
 
-  if (i == MAX_OPEN_FILES)
+  if (i == MAX_OPEN_FILES) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -227,6 +236,7 @@ initialise_monitor_handles (void)
     openfiles[0].flags = _FWRITE;
     openfiles[2].pos = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 int
@@ -237,6 +247,7 @@ _has_ext_exit_extended (void)
     initialise_semihosting_exts ();
   }
 
+  __A_VARIABLE = 1;
   return supports_ext_exit_extended;
 }
 
@@ -248,6 +259,7 @@ _has_ext_stdout_stderr (void)
     initialise_semihosting_exts ();
   }
 
+  __A_VARIABLE = 1;
   return supports_ext_stdout_stderr;
 }
 
@@ -267,6 +279,7 @@ initialise_semihosting_exts (void)
        = features[0] & (1 << SH_EXT_STDOUT_STDERR_BITNUM);
   }
 #endif
+  __A_VARIABLE = 1;
 }
 
 int
@@ -277,6 +290,7 @@ _get_semihosting_exts (char* features, int offset, int num)
 
   if (fd == -1)
   {
+    __A_VARIABLE = 1;
     return -1;
   }
 
@@ -292,6 +306,7 @@ _get_semihosting_exts (char* features, int offset, int num)
       || num > (len - NUM_SHFB_MAGIC))
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
@@ -305,12 +320,14 @@ _get_semihosting_exts (char* features, int offset, int num)
       || buffer[3] != SHFB_MAGIC_3)
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
   if (_lseek (fd, offset, SEEK_CUR) < 0)
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
@@ -318,12 +335,14 @@ _get_semihosting_exts (char* features, int offset, int num)
 
   _close (fd);
 
+  __A_VARIABLE = 1;
   return checkerror (n_read);
 }
 
 static int
 get_errno (void)
 {
+  __A_VARIABLE = 1;
   return do_AngelSVC (AngelSVC_Reason_Errno, NULL);
 }
 
@@ -332,6 +351,7 @@ static int
 error (int result)
 {
   errno = get_errno ();
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -339,8 +359,11 @@ error (int result)
 static int
 checkerror (int result)
 {
-  if (result == -1)
+  if (result == -1) {
+    __A_VARIABLE = 1;
     return error (-1);
+  }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -357,6 +380,7 @@ _swiread (int fh, char *ptr, int len)
   block[1] = POINTER_TO_PARAM_BLOCK_T (ptr);
   block[2] = len;
 
+  __A_VARIABLE = 1;
   return checkerror (do_AngelSVC (AngelSVC_Reason_Read, block));
 }
 
@@ -373,18 +397,22 @@ _read (int fd, char *ptr, int len)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   res = _swiread (pfd->handle, ptr, len);
 
-  if (res == -1)
+  if (res == -1) {
+    __A_VARIABLE = 1;
     return res;
+  }
 
   pfd->pos += len - res;
 
   /* res == len is not an error,
      at least if we want feof() to work.  */
+  __A_VARIABLE = 1;
   return len - res;
 }
 
@@ -451,6 +479,7 @@ _swilseek (int fd, int ptr, int dir)
 
 _lseek (int fd, int ptr, int dir)
 {
+  __A_VARIABLE = 1;
   return _swilseek (fd, ptr, dir);
 }
 
@@ -465,6 +494,7 @@ _swiwrite (int fh, char *ptr, int len)
   block[1] = POINTER_TO_PARAM_BLOCK_T (ptr);
   block[2] = len;
 
+  __A_VARIABLE = 1;
   return checkerror (do_AngelSVC (AngelSVC_Reason_Write, block));
 }
 
@@ -479,22 +509,28 @@ _write (int fd, char *ptr, int len)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   res = _swiwrite (pfd->handle, ptr, len);
 
   /* Clearly an error. */
-  if (res < 0)
+  if (res < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   pfd->pos += len - res;
 
   /* We wrote 0 bytes?
      Retrieve errno just in case. */
-  if ((len - res) == 0)
+  if ((len - res) == 0) {
+    __A_VARIABLE = 1;
     return error (0);
+  }
 
+  __A_VARIABLE = 1;
   return (len - res);
 }
 
@@ -576,6 +612,7 @@ _swiopen (const char *path, int flags)
 int
 _open (const char *path, int flags, ...)
 {
+  __A_VARIABLE = 1;
   return _swiopen (path, flags);
 }
 
@@ -585,6 +622,7 @@ _swiclose (int fh)
 {
   param_block_t param[1];
   param[0] = fh;
+  __A_VARIABLE = 1;
   return checkerror (do_AngelSVC (AngelSVC_Reason_Close, param));
 }
 
@@ -599,6 +637,7 @@ _close (int fd)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -606,6 +645,7 @@ _close (int fd)
   if ((fd == 1 || fd == 2) && (openfiles[1].handle == openfiles[2].handle))
     {
       pfd->handle = -1;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -616,12 +656,14 @@ _close (int fd)
   if (res == 0)
     pfd->handle = -1;
 
+  __A_VARIABLE = 1;
   return res;
 }
 
 int __attribute__((weak))
 _getpid (int n __attribute__ ((unused)))
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -642,11 +684,13 @@ _sbrk (int incr)
       /* Some of the libstdc++-v3 tests rely upon detecting
          out of memory errors, so do not abort here.  */
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return (caddr_t) - 1;
     }
 
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -701,6 +745,7 @@ _swistat (int fd, struct stat *st)
 int __attribute__((weak))
 _fstat (int fd, struct stat * st)
 {
+  __A_VARIABLE = 1;
   return _swistat (fd, st);
 }
 
@@ -710,11 +755,14 @@ _stat (const char *fname, struct stat *st)
   int fd, res;
   /* The best we can do is try to open the file readonly.
      If it exists, then we can guess a few things about it. */
-  if ((fd = _open (fname, O_RDONLY)) == -1)
+  if ((fd = _open (fname, O_RDONLY)) == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   res = _swistat (fd, st);
   /* Not interested in the error. */
   _close (fd);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -722,6 +770,7 @@ int __attribute__((weak))
 _link (void)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -733,8 +782,11 @@ _unlink (const char *path)
   block[0] = POINTER_TO_PARAM_BLOCK_T (path);
   block[1] = strlen (path);
   res = do_AngelSVC (AngelSVC_Reason_Remove, block);
-  if (res == -1)
+  if (res == -1) {
+    __A_VARIABLE = 1;
     return error (res);
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -756,6 +808,7 @@ _gettimeofday (struct timeval *tp, void *tzvp)
       tzp->tz_dsttime = 0;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -766,6 +819,7 @@ _clock (void)
   clock_t timeval;
 
   timeval = do_AngelSVC (AngelSVC_Reason_Clock, NULL);
+  __A_VARIABLE = 1;
   return timeval;
 }
 
@@ -783,6 +837,7 @@ _times (struct tms * tp)
       tp->tms_cstime = 0;	/* system time, children */
     }
 
+  __A_VARIABLE = 1;
   return timeval;
 };
 
@@ -801,14 +856,18 @@ _isatty (int fd)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return 0;
     }
 
   param[0] = pfd->handle;
   res = do_AngelSVC (AngelSVC_Reason_IsTTY, param);
 
-  if (res != 1)
+  if (res != 1) {
+    __A_VARIABLE = 1;
     return error (0);
+  }
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -821,8 +880,10 @@ _system (const char *s)
   /* Hmmm.  The ARM debug interface specification doesn't say whether
      SYS_SYSTEM does the right thing with a null argument, or assign any
      meaning to its return value.  Try to do something reasonable....  */
-  if (!s)
-    return 1;			/* maybe there is a shell available? we can hope. :-P */
+  if (!s) {
+    __A_VARIABLE = 1;
+    return 1;
+  }			/* maybe there is a shell available? we can hope. :-P */
   block[0] = POINTER_TO_PARAM_BLOCK_T (s);
   block[1] = strlen (s);
   e = checkerror (do_AngelSVC (AngelSVC_Reason_System, block));
@@ -836,6 +897,7 @@ _system (const char *s)
       for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
 	continue;
     }
+  __A_VARIABLE = 1;
   return e;
 }
 
@@ -847,6 +909,7 @@ _rename (const char *oldpath, const char *newpath)
   block[1] = strlen (oldpath);
   block[2] = POINTER_TO_PARAM_BLOCK_T (newpath);
   block[3] = strlen (newpath);
+  __A_VARIABLE = 1;
   return checkerror (do_AngelSVC (AngelSVC_Reason_Rename, block)) ? -1 : 0;
 }
 
@@ -858,7 +921,10 @@ __aarch64_angel_elapsed (void)
   int result;
   param_block_t block[2];
   result = checkerror (do_AngelSVC (AngelSVC_Reason_Elapsed, block));
-  if (result == -1)
+  if (result == -1) {
+    __A_VARIABLE = 1;
     return result;
+  }
+  __A_VARIABLE = 1;
   return block[0];
 }
diff --git a/libgloss/aarch64/truncate.c b/libgloss/aarch64/truncate.c
index 92c0fca..ca6fe3f 100644
--- a/libgloss/aarch64/truncate.c
+++ b/libgloss/aarch64/truncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -30,5 +31,6 @@ int
 truncate (const char *path, off_t length)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/arc/libcfunc.c b/libgloss/arc/libcfunc.c
index c6e64f2..127a874 100644
--- a/libgloss/arc/libcfunc.c
+++ b/libgloss/arc/libcfunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
@@ -47,6 +48,7 @@ unsigned __attribute__((weak))
 alarm (unsigned seconds)
 {
 	(void)seconds;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -54,6 +56,7 @@ clock_t _clock (void);
 clock_t __attribute__((weak))
 clock (void)
 {
+      __A_VARIABLE = 1;
       return _clock ();
 }
 
@@ -61,6 +64,7 @@ int _isatty (int fildes);
 int __attribute__((weak))
 isatty (int fildes)
 {
+	__A_VARIABLE = 1;
 	return _isatty (fildes);
 }
 
@@ -68,6 +72,7 @@ int __attribute__((weak))
 pause (void)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -78,6 +83,7 @@ sleep (unsigned seconds)
 	clock_t dt = seconds * CLOCKS_PER_SEC;
 
 	while (_clock () - t0  < dt);
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -88,5 +94,6 @@ usleep (useconds_t useconds)
 	clock_t dt = useconds / (1000000/CLOCKS_PER_SEC);
 
 	while (_clock () - t0  < dt);
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/libgloss/arc/mcount.c b/libgloss/arc/mcount.c
index 6bfa3d8..745cb53 100644
--- a/libgloss/arc/mcount.c
+++ b/libgloss/arc/mcount.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1983, 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -184,8 +185,10 @@ _mcount_internal (unsigned long frompc)
 
   /* Check that we are profiling and that we aren't recursively invoked.
      NB/ This version is not thread-safe.  */
-  if (p->state != GMON_PROF_ON)
+  if (p->state != GMON_PROF_ON) {
+    __A_VARIABLE = 1;
     return;
+  }
   p->state = GMON_PROF_BUSY;
 
   /* Check that frompcindex is a reasonable pc value.
@@ -268,10 +271,12 @@ _mcount_internal (unsigned long frompc)
 
  done:
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
   return;
 
  overflow:
   p->state = GMON_PROF_ERROR;
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -310,6 +315,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
       write (2, "monstartup: out of memory\n", 26);
       p->tos = NULL;
       p->state = GMON_PROF_ERROR;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -321,6 +327,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
 
   p->tos[0].link = 0;
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
 }
 
 
@@ -419,4 +426,5 @@ _mcleanup (void)
       free (_gmonparam.tos);
       _gmonparam.tos = NULL;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/arc/nsim-syscalls.c b/libgloss/arc/nsim-syscalls.c
index 7dd0af1..81102fa 100644
--- a/libgloss/arc/nsim-syscalls.c
+++ b/libgloss/arc/nsim-syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
@@ -96,6 +97,7 @@ _open (const char * pathname, int flags, int mode)
 
   long __res;
   _naked_syscall3 (__res, open, pathname, nsim_flags, mode)
+  __A_VARIABLE = 1;
   return __res;
 }
 
@@ -110,6 +112,7 @@ _exit (int ret)
      _exit_halt, which will do a CPU halt is more universal and will work in
      many other cases as well, including an FPGA/SoC.  */
   _exit_halt ();
+  __A_VARIABLE = 1;
 }
 
 /* This is a copy of newlib/libc/posix/_isatty.c.  It is needed because nSIM
@@ -124,13 +127,16 @@ _isatty (int fd)
   if (fstat (fd, &buf) < 0)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return 0;
     }
   if (S_ISCHR (buf.st_mode))
     {
+      __A_VARIABLE = 1;
       return 1;
     }
   errno = ENOTTY;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -139,6 +145,7 @@ _isatty (int fd)
 int
 _getpid (void)
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
 
@@ -153,6 +160,7 @@ _kill (int pid, int sig)
       _exit (sig);
     }
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -174,6 +182,7 @@ translate_stat (struct nsim_stat *nsim, struct stat *buf)
   TR (blksize, long);
   TR (blocks, long);
   #undef TR
+  __A_VARIABLE = 1;
 }
 
 /* stat/fstat implementation.  Situation is similiar to open and its flags -
@@ -188,6 +197,7 @@ _stat (const char * path, struct stat *buf)
   long __res;
   _naked_syscall2 (__res, stat, path, &nsim_stat)
   translate_stat (&nsim_stat, buf);
+  __A_VARIABLE = 1;
   return __res;
 }
 
@@ -198,6 +208,7 @@ _lstat (const char * path, struct stat *buf)
   long __res;
   _naked_syscall2 (__res, stat, path, &nsim_stat)
   translate_stat (&nsim_stat, buf);
+  __A_VARIABLE = 1;
   return __res;
 }
 
@@ -208,6 +219,7 @@ _fstat (int fd, struct stat *buf)
   long __res;
   _naked_syscall2 (__res, stat, fd, &nsim_stat)
   translate_stat (&nsim_stat, buf);
+  __A_VARIABLE = 1;
   return __res;
 }
 
diff --git a/libgloss/arc/sbrk.c b/libgloss/arc/sbrk.c
index 8cb8461..be86079 100644
--- a/libgloss/arc/sbrk.c
+++ b/libgloss/arc/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
@@ -53,9 +54,11 @@ _sbrk (size_t nbytes)
   if ((heap_ptr + nbytes) < &__end_heap)
     {
       heap_ptr += nbytes;
+      __A_VARIABLE = 1;
       return (caddr_t) prev_heap_ptr;
     }
 
   errno = ENOMEM;
+  __A_VARIABLE = 1;
   return (caddr_t) -1;
 }
diff --git a/libgloss/arm/_exit.c b/libgloss/arm/_exit.c
index ed00876..516bb15 100644
--- a/libgloss/arm/_exit.c
+++ b/libgloss/arm/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 
 int _kill _PARAMS ((int, int));
@@ -12,4 +13,5 @@ _exit (int status)
      Note: The RDI implementation of _kill throws away both its
      arguments.  */
   _kill (status, -1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/arm/_kill.c b/libgloss/arm/_kill.c
index 8871d3c..d0d4978 100644
--- a/libgloss/arm/_kill.c
+++ b/libgloss/arm/_kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <signal.h>
 #include "swi.h"
@@ -39,6 +40,7 @@ _kill (int pid, int sig)
       }
     }
 
+  __A_VARIABLE = 1;
   return do_AngelSWI (insn, block);
 #else
   asm ("swi %a0" :: "i" (SWI_Exit));
diff --git a/libgloss/arm/ftruncate.c b/libgloss/arm/ftruncate.c
index 41a64d2..8cd31bf 100644
--- a/libgloss/arm/ftruncate.c
+++ b/libgloss/arm/ftruncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -30,5 +31,6 @@ int
 ftruncate (int file, off_t length)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/arm/libcfunc.c b/libgloss/arm/libcfunc.c
index c8cedad..32a2846 100644
--- a/libgloss/arm/libcfunc.c
+++ b/libgloss/arm/libcfunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support files for GNU libc.  Files in the C namespace go here.
    Files in the system namespace (ie those that start with an underscore)
    go in syscalls.c.
@@ -14,6 +15,7 @@ unsigned __attribute__((weak))
 alarm (unsigned seconds)
 {
 	(void)seconds;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -21,6 +23,7 @@ clock_t _clock(void);
 clock_t __attribute__((weak))
 clock(void)
 {
+      __A_VARIABLE = 1;
       return _clock();
 }
 
@@ -28,6 +31,7 @@ int _isatty(int fildes);
 int __attribute__((weak))
 isatty(int fildes)
 {
+	__A_VARIABLE = 1;
 	return _isatty(fildes);
 }
 
@@ -35,6 +39,7 @@ int __attribute__((weak))
 pause(void)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -48,6 +53,7 @@ sleep(unsigned seconds)
 	clock_t dt = seconds * CLOCKS_PER_SEC;
 
 	while (_clock() - t0  < dt);
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -58,5 +64,6 @@ usleep(useconds_t useconds)
 	clock_t dt = useconds / (1000000/CLOCKS_PER_SEC);
 
 	while (_clock() - t0  < dt);
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/libgloss/arm/linux-crt0.c b/libgloss/arm/linux-crt0.c
index 878ece7..7f66bd6 100644
--- a/libgloss/arm/linux-crt0.c
+++ b/libgloss/arm/linux-crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /** Linux startup code for the ARM processor.
  * Written by Shaun Jackman <sjackman@gmail.com>.
  * Copyright 2006 Pathway Connectivity
@@ -33,10 +34,12 @@ void _start(void)
 {
 	register int *sp asm("sp");
 	_main(*sp, (char **)(sp + 1));
+	__A_VARIABLE = 1;
 }
 
 static int _main(int argc, char *argv[])
 {
 	environ = argv + argc + 1;
 	exit(main(argc, argv, environ));
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/arm/linux-syscalls1.c b/libgloss/arm/linux-syscalls1.c
index a196352..8a7ba0a 100644
--- a/libgloss/arm/linux-syscalls1.c
+++ b/libgloss/arm/linux-syscalls1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /** Linux system call interface.
  * Written by Shaun Jackman <sjackman@gmail.com>.
  * Copyright 2006 Pathway Connectivity
@@ -17,22 +18,29 @@ extern void *_brk(void *addr);
 int brk(void *addr)
 {
 	void *newbrk;
-	if (curbrk == addr)
+	if (curbrk == addr) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 	newbrk = _brk(addr);
 	curbrk = newbrk;
 	if (newbrk < addr) {
 		errno = ENOMEM;
+		__A_VARIABLE = 1;
 		return -1;
 	}
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 void *_sbrk(intptr_t incr)
 {
 	void *oldbrk = curbrk;
-	if (brk(oldbrk + incr) == -1)
+	if (brk(oldbrk + incr) == -1) {
+		__A_VARIABLE = 1;
 		return (void *)-1;
+	}
+	__A_VARIABLE = 1;
 	return oldbrk;
 }
 
@@ -42,8 +50,10 @@ int _set_errno(int n)
 {
 	if (n < 0) {
 		errno = -n;
+		__A_VARIABLE = 1;
 		return -1;
 	}
+	__A_VARIABLE = 1;
 	return n;
 }
 
@@ -55,11 +65,13 @@ pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
 
 pid_t _wait(int *status)
 {
+	__A_VARIABLE = 1;
 	return wait4(-1, status, 0, NULL);
 }
 
 pid_t waitpid(pid_t pid, int *status, int options)
 {
+	__A_VARIABLE = 1;
 	return wait4(pid, status, options, NULL);
 }
 
@@ -67,5 +79,6 @@ extern int _reboot(int magic, int magic2, int flag, void *arg);
 
 int reboot(int flag)
 {
+	__A_VARIABLE = 1;
 	return _reboot(0xfee1dead, 0x28121969, flag, NULL);
 }
diff --git a/libgloss/arm/redboot-syscalls.c b/libgloss/arm/redboot-syscalls.c
index c6b743e..f9c2669 100644
--- a/libgloss/arm/redboot-syscalls.c
+++ b/libgloss/arm/redboot-syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * redboot-syscalls.c -- provide system call support for RedBoot
  *
@@ -31,6 +32,7 @@ static int __attribute__ ((naked)) __syscall(int func_no, ...)
     asm ("swi 0x180001\n");
 #endif
     asm ("mov	pc, r12\n");
+    __A_VARIABLE = 1;
 }
 
 int
@@ -41,8 +43,10 @@ _close(int fd)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -52,6 +56,7 @@ _exit(int stat)
 {
     while (1)
         __syscall(SYS_exit, stat);
+    __A_VARIABLE = 1;
 }
 
 
@@ -63,8 +68,10 @@ _stat (const char *filename, struct stat *st)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -76,14 +83,17 @@ _fstat (int file, struct stat *st)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
 int
 _getpid(void)
 {
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -96,8 +106,10 @@ _gettimeofday (void * tp, void * tzp)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -110,8 +122,10 @@ _isatty(int fd)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -121,6 +135,7 @@ _kill(int pid, int sig)
 {
   if(pid == 1)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -133,8 +148,10 @@ _lseek(int fd, off_t offset, int whence)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return (off_t)-1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -147,8 +164,10 @@ _open(const char *buf, int flags, int mode)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -162,8 +181,10 @@ _write(int fd, const char *buf, int nbytes)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -177,11 +198,13 @@ print(char *ptr)
     p++;
 
   _write (1, ptr, p-ptr);
+  __A_VARIABLE = 1;
 }
 
 void
 _raise (void)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -194,8 +217,10 @@ _read(int fd, char *buf, int nbytes)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -214,6 +239,7 @@ _sbrk (int nbytes)
     base = heap_ptr;
     heap_ptr += nbytes;
 
+    __A_VARIABLE = 1;
     return base;
 }
 
@@ -234,6 +260,7 @@ _times(struct tms * tp)
 	tp->tms_cstime = 0;
     }
 
+    __A_VARIABLE = 1;
     return utime;
 }
 
@@ -245,8 +272,10 @@ _rename (const char *oldpath, const char *newpath)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -258,8 +287,10 @@ _unlink (const char *pathname)
     if (err<0)
       {
         errno = -err;
+        __A_VARIABLE = 1;
         return -1;
       }
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -268,6 +299,7 @@ _system (const char *command)
 {
     int err ;
     err = __syscall(SYS_system, command);
+    __A_VARIABLE = 1;
     return err;
 }
 
@@ -280,5 +312,6 @@ __get_memtop(void)
   int numbanks;
 
   __syscall(SYS_meminfo, (unsigned long)&totmem, (unsigned long)&topmem, 0);
+  __A_VARIABLE = 1;
   return (void*)topmem;
 }
diff --git a/libgloss/arm/syscalls.c b/libgloss/arm/syscalls.c
index 8071368..16f0179 100644
--- a/libgloss/arm/syscalls.c
+++ b/libgloss/arm/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support files for GNU libc.  Files in the system namespace go here.
    Files in the C namespace (ie those that do not start with an
    underscore) go in .c.  */
@@ -109,14 +110,19 @@ findslot (int fd)
   CHECK_INIT(_REENT);
 
   /* User file descriptor is out of range. */
-  if ((unsigned int)fd >= MAX_OPEN_FILES)
+  if ((unsigned int)fd >= MAX_OPEN_FILES) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* User file descriptor is open? */
-  if (openfiles[fd].handle == -1)
+  if (openfiles[fd].handle == -1) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* Valid. */
+  __A_VARIABLE = 1;
   return &openfiles[fd];
 }
 
@@ -131,9 +137,12 @@ newslot (void)
     if (openfiles[i].handle == -1)
       break;
 
-  if (i == MAX_OPEN_FILES)
+  if (i == MAX_OPEN_FILES) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -218,6 +227,7 @@ initialise_monitor_handles (void)
     openfiles[2].handle = monitor_stderr;
     openfiles[2].pos = 0;
   }
+  __A_VARIABLE = 1;
 }
 
 int
@@ -228,6 +238,7 @@ _has_ext_exit_extended (void)
     initialise_semihosting_exts ();
   }
 
+  __A_VARIABLE = 1;
   return supports_ext_exit_extended;
 }
 
@@ -239,6 +250,7 @@ _has_ext_stdout_stderr (void)
     initialise_semihosting_exts ();
   }
 
+  __A_VARIABLE = 1;
   return supports_ext_stdout_stderr;
 }
 
@@ -258,6 +270,7 @@ initialise_semihosting_exts (void)
        = features[0] & (1 << SH_EXT_STDOUT_STDERR_BITNUM);
   }
 #endif
+  __A_VARIABLE = 1;
 }
 
 int
@@ -270,6 +283,7 @@ _get_semihosting_exts (char* features, int offset, int num)
 
   if (fd == -1)
   {
+    __A_VARIABLE = 1;
     return -1;
   }
 
@@ -288,6 +302,7 @@ _get_semihosting_exts (char* features, int offset, int num)
       || num > (len - NUM_SHFB_MAGIC))
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
@@ -301,12 +316,14 @@ _get_semihosting_exts (char* features, int offset, int num)
       || buffer[3] != SHFB_MAGIC_3)
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
   if (_lseek (fd, offset, SEEK_CUR) < 0)
   {
      _close (fd);
+     __A_VARIABLE = 1;
      return -1;
   }
 
@@ -314,6 +331,7 @@ _get_semihosting_exts (char* features, int offset, int num)
 
   _close (fd);
 
+  __A_VARIABLE = 1;
   return checkerror (n_read);
 }
 
@@ -334,6 +352,7 @@ static int
 error (int result)
 {
   errno = get_errno ();
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -341,8 +360,11 @@ error (int result)
 static int
 checkerror (int result)
 {
-  if (result == -1)
+  if (result == -1) {
+    __A_VARIABLE = 1;
     return error (-1);
+  }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -392,18 +414,22 @@ _read (int fd,
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   res = _swiread (pfd->handle, ptr, len);
 
-  if (res == -1)
+  if (res == -1) {
+    __A_VARIABLE = 1;
     return res;
+  }
 
   pfd->pos += len - res;
 
   /* res == len is not an error, 
      at least if we want feof() to work.  */
+  __A_VARIABLE = 1;
   return len - res;
 }
 
@@ -497,6 +523,7 @@ _lseek (int fd,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return _swilseek (fd, ptr, dir);
 }
 
@@ -543,22 +570,28 @@ _write (int    fd,
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   res = _swiwrite (pfd->handle, ptr,len);
 
   /* Clearly an error. */
-  if (res < 0)
+  if (res < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   pfd->pos += len - res;
 
   /* We wrote 0 bytes? 
      Retrieve errno just in case. */
-  if ((len - res) == 0)
+  if ((len - res) == 0) {
+    __A_VARIABLE = 1;
     return error (0);
+  }
   
+  __A_VARIABLE = 1;
   return (len - res);
 }
 
@@ -643,6 +676,7 @@ _swiopen (const char * path, int flags)
 int
 _open (const char * path, int flags, ...)
 {
+  __A_VARIABLE = 1;
   return _swiopen (path, flags);
 }
 
@@ -673,6 +707,7 @@ _close (int fd)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -681,6 +716,7 @@ _close (int fd)
       && (openfiles[1].handle == openfiles[2].handle))
     {
       pfd->handle = -1;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -691,12 +727,14 @@ _close (int fd)
   if (res == 0)
     pfd->handle = -1;
 
+  __A_VARIABLE = 1;
   return res;
 }
 
 int __attribute__((weak))
 _getpid (int n __attribute__ ((unused)))
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -748,6 +786,7 @@ _swistat (int fd, struct stat * st)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -764,10 +803,13 @@ _swistat (int fd, struct stat * st)
        : "r0");
   checkerror (res);
 #endif
-  if (res == -1)
+  if (res == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   /* Return the file size. */
   st->st_size = res;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -775,6 +817,7 @@ int __attribute__((weak))
 _fstat (int fd, struct stat * st)
 {
   memset (st, 0, sizeof (* st));
+  __A_VARIABLE = 1;
   return _swistat (fd, st);
 }
 
@@ -785,12 +828,15 @@ _stat (const char *fname, struct stat *st)
   memset (st, 0, sizeof (* st));
   /* The best we can do is try to open the file readonly.  
      If it exists, then we can guess a few things about it. */
-  if ((fd = _open (fname, O_RDONLY)) == -1)
+  if ((fd = _open (fname, O_RDONLY)) == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   st->st_mode |= S_IFREG | S_IREAD;
   res = _swistat (fd, st);
   /* Not interested in the error. */
   _close (fd); 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -798,6 +844,7 @@ int __attribute__((weak))
 _link (void)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -818,8 +865,11 @@ _unlink (const char *path)
        : "0"(r0), "i" (SWI_Remove));
   res = r0;
 #endif
-  if (res == -1) 
+  if (res == -1) {
+    __A_VARIABLE = 1;
     return error (res);
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -849,6 +899,7 @@ _gettimeofday (struct timeval * tp, void * tzvp)
       tzp->tz_dsttime = 0;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -863,6 +914,7 @@ _clock (void)
 #else
   asm ("swi %a1; mov %0, r0" : "=r" (timeval): "i" (SWI_Clock) : "r0");
 #endif
+  __A_VARIABLE = 1;
   return timeval;
 }
 
@@ -880,6 +932,7 @@ _times (struct tms * tp)
       tp->tms_cstime = 0;	/* system time, children */
     }
   
+  __A_VARIABLE = 1;
   return timeval;
 };
 
@@ -894,6 +947,7 @@ _isatty (int fd)
   if (pfd == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -908,9 +962,12 @@ _isatty (int fd)
   tty = r0;
 #endif
 
-  if (tty == 1)
+  if (tty == 1) {
+    __A_VARIABLE = 1;
     return 1;
+  }
   errno = get_errno ();
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/arm/truncate.c b/libgloss/arm/truncate.c
index 92c0fca..ca6fe3f 100644
--- a/libgloss/arm/truncate.c
+++ b/libgloss/arm/truncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 ARM Ltd.  All rights reserved.
 
  Redistribution and use in source and binary forms, with or without
@@ -30,5 +31,6 @@ int
 truncate (const char *path, off_t length)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/bfin/_exit.c b/libgloss/bfin/_exit.c
index d7fb9e0..69f2bb6 100644
--- a/libgloss/bfin/_exit.c
+++ b/libgloss/bfin/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * C library support files for the Blackfin processor
  *
@@ -22,4 +23,5 @@ _DEFUN (_exit, (rc),
 {
   while (1)
     asm volatile ("EXCPT 0;");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/bfin/clear_cache_range.c b/libgloss/bfin/clear_cache_range.c
index c4173eb..0c70758 100644
--- a/libgloss/bfin/clear_cache_range.c
+++ b/libgloss/bfin/clear_cache_range.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * C library support files for the Blackfin processor
  *
@@ -30,4 +31,5 @@ void __clear_cache_range (char *beg, char *end)
   do {
     __asm__ __volatile__ ("IFLUSH [%0++];" : "+a" (ptr) : : "memory");
   } while (ptr <= end);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/bfin/syscalls.c b/libgloss/bfin/syscalls.c
index 2dea8c5..abc418c 100644
--- a/libgloss/bfin/syscalls.c
+++ b/libgloss/bfin/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * C library support files for the Blackfin processor
  *
@@ -41,6 +42,7 @@ do_syscall (int reason, void *arg)
 		  "q0" (arg)
 		: "memory", "CC");
   errno = errcode;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -53,6 +55,7 @@ _read (int file, char *ptr, int len)
   block[1] = (int) ptr;
   block[2] = len;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_read, block);
 }
 
@@ -65,6 +68,7 @@ _lseek (int file, int ptr, int whence)
   block[1] = ptr;
   block[2] = whence;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_lseek, block);
 }
 
@@ -77,6 +81,7 @@ _write (int file, char *ptr, int len)
   block[1] = (int) ptr;
   block[2] = len;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_write, block);
 }
 
@@ -88,12 +93,14 @@ _open (const char *path, int flags)
   block[0] = (int) path;
   block[1] = flags;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_open, block);
 }
 
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return do_syscall (SYS_close, &file);
 }
 
@@ -101,6 +108,7 @@ void
 _exit (int n)
 {
   do_syscall (SYS_exit, &n);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -111,12 +119,14 @@ _kill (int n, int m)
   block[0] = n;
   block[1] = m;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_kill, block);
 }
 
 int
 _getpid (int n)
 {
+  __A_VARIABLE = 1;
   return do_syscall (SYS_getpid, &n);
 }
 
@@ -144,12 +154,14 @@ _sbrk (int incr)
       abort ();
 #else
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return (caddr_t) -1;
 #endif
     }
 
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -163,6 +175,7 @@ _fstat (int file, struct stat *st)
   block[0] = file;
   block[1] = (int) st;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_fstat, block);
 }
 
@@ -173,6 +186,7 @@ int _stat (const char *fname, struct stat *st)
   block[0] = (int) fname;
   block[1] = (int) st;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_stat, block);
 }
 
@@ -184,18 +198,21 @@ _link (const char *existing, const char *new)
   block[0] = (int) existing;
   block[1] = (int) new;
 
+  __A_VARIABLE = 1;
   return do_syscall (SYS_link, block);
 }
 
 int
 _unlink (const char *path)
 {
+  __A_VARIABLE = 1;
   return do_syscall (SYS_unlink, path);
 }
 
 void
 _raise (void)
 {
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -204,6 +221,7 @@ _gettimeofday (struct timeval *tv, void *tz)
 {
   tv->tv_usec = 0;
   tv->tv_sec = do_syscall (SYS_time, 0);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -211,21 +229,26 @@ _gettimeofday (struct timeval *tv, void *tz)
 clock_t
 _times (struct tms * tp)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 _isatty (int fd)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int
 _system (const char *s)
 {
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -233,6 +256,7 @@ int
 _rename (const char * oldpath, const char * newpath)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -253,6 +277,7 @@ __setup_argv_for_main (int argc)
     do_syscall (SYS_argn, (void *)block);
   }
 
+  __A_VARIABLE = 1;
   return main (argc, argv);
 }
 
diff --git a/libgloss/close.c b/libgloss/close.c
index 7aafcea..8919272 100644
--- a/libgloss/close.c
+++ b/libgloss/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close.c -- close a file descriptor.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (close ,(fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/cr16/_exit.c b/libgloss/cr16/_exit.c
index 9a3cfa6..7765e27 100644
--- a/libgloss/cr16/_exit.c
+++ b/libgloss/cr16/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _exit.c -- Implementation of the low-level _exit() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@
 void _exit (int stat)
 {
   HOST_SERVICE (SVC_EOP);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/_getenv.c b/libgloss/cr16/_getenv.c
index c43555d..b62cdee 100644
--- a/libgloss/cr16/_getenv.c
+++ b/libgloss/cr16/_getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _getenv.c -- Implementation of the low-level _getenv() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -32,5 +33,6 @@ char * _getenv (const char *name)
   R2 = x;
  
   HOST_SERVICE (SVC_GETENV);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/cr16/_rename.c b/libgloss/cr16/_rename.c
index b3d7bd0..ae254c6 100644
--- a/libgloss/cr16/_rename.c
+++ b/libgloss/cr16/_rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _rename.c -- Implementation of the low-level rename() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _rename (char *from, char *to)
 {
   HOST_SERVICE (SVC_RENAME);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/close.c b/libgloss/cr16/close.c
index 86a2926..5cb292b 100644
--- a/libgloss/cr16/close.c
+++ b/libgloss/cr16/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close.c -- Implementation of the low-level close() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _close (int fd)
 {
   HOST_SERVICE (SVC_CLOSE);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/dvz_hndl.c b/libgloss/cr16/dvz_hndl.c
index a9bde40..9d4ffa4 100644
--- a/libgloss/cr16/dvz_hndl.c
+++ b/libgloss/cr16/dvz_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* dvz_hndl.c -- Implementation of the DVZ trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void dvz_handler (void) __attribute__ ((interrupt ()));
 void dvz_handler (void)
 {
   HOST_SERVICE (SVC_DVZ);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/flg_hndl.c b/libgloss/cr16/flg_hndl.c
index 0bb9c86..3a83edd 100644
--- a/libgloss/cr16/flg_hndl.c
+++ b/libgloss/cr16/flg_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* flg_hndl.c -- Implementation of the FLG trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void flg_handler (void) __attribute__ ((interrupt ()));
 void flg_handler (void)
 {
   HOST_SERVICE (SVC_FLG);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/fstat.c b/libgloss/cr16/fstat.c
index 637f87d..b6f06b1 100644
--- a/libgloss/cr16/fstat.c
+++ b/libgloss/cr16/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/cr16/getpid.c b/libgloss/cr16/getpid.c
index d254c9b..c0f8f5f 100644
--- a/libgloss/cr16/getpid.c
+++ b/libgloss/cr16/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -22,5 +23,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/cr16/iad_hndl.c b/libgloss/cr16/iad_hndl.c
index 875dbe6..829e088 100644
--- a/libgloss/cr16/iad_hndl.c
+++ b/libgloss/cr16/iad_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* iad_hndl.c -- Implementation of the IAD trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void iad_handler (void) __attribute__ ((interrupt ()));
 void iad_handler (void)
 {
   HOST_SERVICE (SVC_IAD);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/intable.c b/libgloss/cr16/intable.c
index 02ca66b..ac50be2 100644
--- a/libgloss/cr16/intable.c
+++ b/libgloss/cr16/intable.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* intable.c -- CompactRISC default dispatch table definition
  *
  * Copyright (c) 2004 National Semiconductor Corporation
diff --git a/libgloss/cr16/isatty.c b/libgloss/cr16/isatty.c
index 1cb32e5..b6eb9e0 100644
--- a/libgloss/cr16/isatty.c
+++ b/libgloss/cr16/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -23,5 +24,6 @@ int
 _DEFUN (_isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/cr16/kill.c b/libgloss/cr16/kill.c
index b375844..c14ddf6 100644
--- a/libgloss/cr16/kill.c
+++ b/libgloss/cr16/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/cr16/lseek.c b/libgloss/cr16/lseek.c
index 605be6c..93f5edb 100644
--- a/libgloss/cr16/lseek.c
+++ b/libgloss/cr16/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek.c -- Implementation of the low-level lseek() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 long _lseek (int fd, long offset, int whence)
 {
   HOST_SERVICE (SVC_LSEEK);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/open.c b/libgloss/cr16/open.c
index a7cd6e9..f6e4447 100644
--- a/libgloss/cr16/open.c
+++ b/libgloss/cr16/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open.c -- Implementation of the low-level open() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -32,10 +33,12 @@ int _open (char *path, int flags, ...)
   mode = va_arg(ap, int);
   open_aux (path, flags, mode);
   va_end(ap);
+  __A_VARIABLE = 1;
 }
 
 int open_aux (char *path, int flags, int mode)
 {
   HOST_SERVICE (SVC_OPEN);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/cr16/putnum.c b/libgloss/cr16/putnum.c
index 3317bbf..a34c45f 100644
--- a/libgloss/cr16/putnum.c
+++ b/libgloss/cr16/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -38,4 +39,5 @@ _DEFUN (putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/read.c b/libgloss/cr16/read.c
index 766a6b1..e3d29c0 100644
--- a/libgloss/cr16/read.c
+++ b/libgloss/cr16/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read.c -- Implementation of the low-level read() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _read (int fd, char *buffer, int nbytes)
 {
   HOST_SERVICE (SVC_READ);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/sbrk.c b/libgloss/cr16/sbrk.c
index 7c96047..3e2f5ec 100644
--- a/libgloss/cr16/sbrk.c
+++ b/libgloss/cr16/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- Implementation of the low-level sbrk() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -47,10 +48,12 @@ void * _sbrk (ptrdiff_t size)
   { 
     /* top of heap is bigger than _HEAP_MAX */
     errno = ENOMEM;
+    __A_VARIABLE = 1;
     return (void *) -1;
   }
 
   /* success: update heap_ptr and return previous value */
   heap_ptr += size;
+  __A_VARIABLE = 1;
   return (void *)old_heap_ptr;
 }
diff --git a/libgloss/cr16/stat.c b/libgloss/cr16/stat.c
index f1769cd..e6b16a8 100644
--- a/libgloss/cr16/stat.c
+++ b/libgloss/cr16/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/cr16/svc_hndl.c b/libgloss/cr16/svc_hndl.c
index ab93a4d..f7c3aac 100644
--- a/libgloss/cr16/svc_hndl.c
+++ b/libgloss/cr16/svc_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* svc_hndl.c -- Implementation of the SVC trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void svc_handler (void) __attribute__ ((interrupt ()));
 void svc_handler (void)
 {
   HOST_SERVICE (SVC_SVC);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/time.c b/libgloss/cr16/time.c
index f8be74c..2f640a2 100644
--- a/libgloss/cr16/time.c
+++ b/libgloss/cr16/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* time.c -- Implementation of the low-level time() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -23,6 +24,7 @@
 time_t _Time (time_t *timer)
 {
   HOST_SERVICE (SVC_TIME);
+  __A_VARIABLE = 1;
 }
 
 time_t _time (time_t *tod)
@@ -32,6 +34,7 @@ time_t _time (time_t *tod)
   if (tod)
     *tod = t;
   
+  __A_VARIABLE = 1;
   return (t);
 }
 
@@ -39,6 +42,7 @@ time_t _time (time_t *tod)
 clock_t _times (struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -51,6 +55,7 @@ int _gettimeofday (struct timeval *tv, void *tzvp)
 
   tv->tv_usec = 0;
   tv->tv_sec = _time (0);
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/cr16/und_hndl.c b/libgloss/cr16/und_hndl.c
index 4c5cca3..7b01ed2 100644
--- a/libgloss/cr16/und_hndl.c
+++ b/libgloss/cr16/und_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* und_hndl.c -- Implementation of the UND trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void und_handler (void) __attribute__ ((interrupt ()));
 void und_handler (void)
 {
   HOST_SERVICE (SVC_UND);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/unlink.c b/libgloss/cr16/unlink.c
index c39e319..e1a14c8 100644
--- a/libgloss/cr16/unlink.c
+++ b/libgloss/cr16/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink.c -- Implementation of the low-level unlink() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _unlink (char *path)
 {
   HOST_SERVICE (SVC_UNLINK);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cr16/write.c b/libgloss/cr16/write.c
index 61fc2eb..5a59c8f 100644
--- a/libgloss/cr16/write.c
+++ b/libgloss/cr16/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write.c -- Implementation of the low-level write() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _write (int fd, char *buffer, int nbytes)
 {
   HOST_SERVICE (SVC_WRITE);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cris/crti.c b/libgloss/cris/crti.c
index ceb71e5..f840c74 100644
--- a/libgloss/cris/crti.c
+++ b/libgloss/cris/crti.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Executable and DSO init/fini start for cris*-axis-linux-gnu and simulators
    Copyright (C) 2000, 2001, 2004, 2005 Axis Communications.
    All rights reserved.
diff --git a/libgloss/cris/crtn.c b/libgloss/cris/crtn.c
index a819daa..88d100f 100644
--- a/libgloss/cris/crtn.c
+++ b/libgloss/cris/crtn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Executable and DSO init/fini end for cris*-axis-linux-gnu and simulators
    Copyright (C) 2000, 2001, 2004, 2005, 2007 Axis Communications.
    All rights reserved.
diff --git a/libgloss/cris/lcrt0.c b/libgloss/cris/lcrt0.c
index 8b8cc0b..4ddbc6a 100644
--- a/libgloss/cris/lcrt0.c
+++ b/libgloss/cris/lcrt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support for cris*-axis-linux-gnu and src/sim/cris simulator.
    Copyright (C) 2000-2005, 2017 Axis Communications.
    All rights reserved.
@@ -131,4 +132,5 @@ start1 (int argc, char **argv, char **env)
 
   /* Call the user program.  */
   exit (main (argc, argv, env));
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/cris/outbyte.c b/libgloss/cris/outbyte.c
index 1cb686b..459b85c 100644
--- a/libgloss/cris/outbyte.c
+++ b/libgloss/cris/outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Low-level kind-of-support for CRIS.  Mostly used as a placeholder
    function.  Too small and obvious to warrant a copyright notice.  */
 
@@ -6,4 +7,5 @@ void
 outbyte (int ch)
 {
   write (1, &ch, 1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/_exit.c b/libgloss/crx/_exit.c
index 9a3cfa6..7765e27 100644
--- a/libgloss/crx/_exit.c
+++ b/libgloss/crx/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _exit.c -- Implementation of the low-level _exit() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@
 void _exit (int stat)
 {
   HOST_SERVICE (SVC_EOP);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/_getenv.c b/libgloss/crx/_getenv.c
index c43555d..b62cdee 100644
--- a/libgloss/crx/_getenv.c
+++ b/libgloss/crx/_getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _getenv.c -- Implementation of the low-level _getenv() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -32,5 +33,6 @@ char * _getenv (const char *name)
   R2 = x;
  
   HOST_SERVICE (SVC_GETENV);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/crx/_rename.c b/libgloss/crx/_rename.c
index b3d7bd0..ae254c6 100644
--- a/libgloss/crx/_rename.c
+++ b/libgloss/crx/_rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _rename.c -- Implementation of the low-level rename() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int _rename (char *from, char *to)
 {
   HOST_SERVICE (SVC_RENAME);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/close.c b/libgloss/crx/close.c
index 72ce4bd..e88e07a 100644
--- a/libgloss/crx/close.c
+++ b/libgloss/crx/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close.c -- Implementation of the low-level close() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int close (int fd)
 {
   HOST_SERVICE (SVC_CLOSE);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/dvz_hndl.c b/libgloss/crx/dvz_hndl.c
index a9bde40..9d4ffa4 100644
--- a/libgloss/crx/dvz_hndl.c
+++ b/libgloss/crx/dvz_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* dvz_hndl.c -- Implementation of the DVZ trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void dvz_handler (void) __attribute__ ((interrupt ()));
 void dvz_handler (void)
 {
   HOST_SERVICE (SVC_DVZ);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/flg_hndl.c b/libgloss/crx/flg_hndl.c
index 0bb9c86..3a83edd 100644
--- a/libgloss/crx/flg_hndl.c
+++ b/libgloss/crx/flg_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* flg_hndl.c -- Implementation of the FLG trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void flg_handler (void) __attribute__ ((interrupt ()));
 void flg_handler (void)
 {
   HOST_SERVICE (SVC_FLG);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/fstat.c b/libgloss/crx/fstat.c
index 380fc2a..5ac1501 100644
--- a/libgloss/crx/fstat.c
+++ b/libgloss/crx/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/crx/getpid.c b/libgloss/crx/getpid.c
index 3c1a7b8..cf584d4 100644
--- a/libgloss/crx/getpid.c
+++ b/libgloss/crx/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -22,5 +23,6 @@ int
 _DEFUN (getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/crx/iad_hndl.c b/libgloss/crx/iad_hndl.c
index 875dbe6..829e088 100644
--- a/libgloss/crx/iad_hndl.c
+++ b/libgloss/crx/iad_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* iad_hndl.c -- Implementation of the IAD trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void iad_handler (void) __attribute__ ((interrupt ()));
 void iad_handler (void)
 {
   HOST_SERVICE (SVC_IAD);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/intable.c b/libgloss/crx/intable.c
index 02ca66b..ac50be2 100644
--- a/libgloss/crx/intable.c
+++ b/libgloss/crx/intable.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* intable.c -- CompactRISC default dispatch table definition
  *
  * Copyright (c) 2004 National Semiconductor Corporation
diff --git a/libgloss/crx/isatty.c b/libgloss/crx/isatty.c
index 927d754..55c39e6 100644
--- a/libgloss/crx/isatty.c
+++ b/libgloss/crx/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -23,5 +24,6 @@ int
 _DEFUN (isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/crx/kill.c b/libgloss/crx/kill.c
index 3ed228f..b47ecfd 100644
--- a/libgloss/crx/kill.c
+++ b/libgloss/crx/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,5 +26,6 @@ _DEFUN (kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/crx/lseek.c b/libgloss/crx/lseek.c
index 6c4354c..03c96c4 100644
--- a/libgloss/crx/lseek.c
+++ b/libgloss/crx/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek.c -- Implementation of the low-level lseek() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 long lseek (int fd, long offset, int whence)
 {
   HOST_SERVICE (SVC_LSEEK);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/open.c b/libgloss/crx/open.c
index abe7bbf..cf26943 100644
--- a/libgloss/crx/open.c
+++ b/libgloss/crx/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open.c -- Implementation of the low-level open() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -32,10 +33,12 @@ int open (char *path, int flags, ...)
   mode = va_arg(ap, int);
   open_aux (path, flags, mode);
   va_end(ap);
+  __A_VARIABLE = 1;
 }
 
 int open_aux (char *path, int flags, int mode)
 {
   HOST_SERVICE (SVC_OPEN);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/crx/putnum.c b/libgloss/crx/putnum.c
index 3317bbf..a34c45f 100644
--- a/libgloss/crx/putnum.c
+++ b/libgloss/crx/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -38,4 +39,5 @@ _DEFUN (putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/read.c b/libgloss/crx/read.c
index f0cb43a..8de76fc 100644
--- a/libgloss/crx/read.c
+++ b/libgloss/crx/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read.c -- Implementation of the low-level read() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int read (int fd, char *buffer, int nbytes)
 {
   HOST_SERVICE (SVC_READ);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/sbrk.c b/libgloss/crx/sbrk.c
index 70d5d4f..1f8d885 100644
--- a/libgloss/crx/sbrk.c
+++ b/libgloss/crx/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- Implementation of the low-level sbrk() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -47,10 +48,12 @@ void * sbrk (ptrdiff_t size)
   { 
     /* top of heap is bigger than _HEAP_MAX */
     errno = ENOMEM;
+    __A_VARIABLE = 1;
     return (void *) -1;
   }
 
   /* success: update heap_ptr and return previous value */
   heap_ptr += size;
+  __A_VARIABLE = 1;
   return (void *)old_heap_ptr;
 }
diff --git a/libgloss/crx/stat.c b/libgloss/crx/stat.c
index 6ffef82..8307eb9 100644
--- a/libgloss/crx/stat.c
+++ b/libgloss/crx/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,6 +26,7 @@ _DEFUN (stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/crx/svc_hndl.c b/libgloss/crx/svc_hndl.c
index ab93a4d..f7c3aac 100644
--- a/libgloss/crx/svc_hndl.c
+++ b/libgloss/crx/svc_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* svc_hndl.c -- Implementation of the SVC trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void svc_handler (void) __attribute__ ((interrupt ()));
 void svc_handler (void)
 {
   HOST_SERVICE (SVC_SVC);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/time.c b/libgloss/crx/time.c
index e82468c..249a1c1 100644
--- a/libgloss/crx/time.c
+++ b/libgloss/crx/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* time.c -- Implementation of the low-level time() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -23,6 +24,7 @@
 time_t _Time (time_t *timer)
 {
   HOST_SERVICE (SVC_TIME);
+  __A_VARIABLE = 1;
 }
 
 time_t time (time_t *tod)
@@ -32,6 +34,7 @@ time_t time (time_t *tod)
   if (tod)
     *tod = t;
   
+  __A_VARIABLE = 1;
   return (t);
 }
 
@@ -39,6 +42,7 @@ time_t time (time_t *tod)
 clock_t times (struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -51,6 +55,7 @@ int gettimeofday (struct timeval *tv, void *tzvp)
 
   tv->tv_usec = 0;
   tv->tv_sec = time (0);
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/crx/und_hndl.c b/libgloss/crx/und_hndl.c
index 4c5cca3..7b01ed2 100644
--- a/libgloss/crx/und_hndl.c
+++ b/libgloss/crx/und_hndl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* und_hndl.c -- Implementation of the UND trap handler
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -20,4 +21,5 @@ void und_handler (void) __attribute__ ((interrupt ()));
 void und_handler (void)
 {
   HOST_SERVICE (SVC_UND);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/unlink.c b/libgloss/crx/unlink.c
index 3a93471..18b50ce 100644
--- a/libgloss/crx/unlink.c
+++ b/libgloss/crx/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink.c -- Implementation of the low-level unlink() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int unlink (char *path)
 {
   HOST_SERVICE (SVC_UNLINK);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/crx/write.c b/libgloss/crx/write.c
index a9a7ff4..04b2679 100644
--- a/libgloss/crx/write.c
+++ b/libgloss/crx/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write.c -- Implementation of the low-level write() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -18,4 +19,5 @@
 int write (int fd, char *buffer, int nbytes)
 {
   HOST_SERVICE (SVC_WRITE);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/d30v/inbyte.c b/libgloss/d30v/inbyte.c
index 8a2001c..4c64e4d 100644
--- a/libgloss/d30v/inbyte.c
+++ b/libgloss/d30v/inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* inbyte -- read a single byte.
  *
  * Copyright (c) 1997 Cygnus Support
@@ -17,8 +18,11 @@ int
 inbyte (void)
 {
   char ch;
-  if (read (0, &ch, 1) == 1)
+  if (read (0, &ch, 1) == 1) {
+    __A_VARIABLE = 1;
     return ch;
+  }
 
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/d30v/outbyte.c b/libgloss/d30v/outbyte.c
index 4421eff..5b790a6 100644
--- a/libgloss/d30v/outbyte.c
+++ b/libgloss/d30v/outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* outbyte -- write a single byte.
  *
  * Copyright (c) 1997 Cygnus Support
@@ -18,4 +19,5 @@ outbyte (int byte)
 {
   char ch = byte;
   write (1, &ch, 1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/d30v/syscalls.c b/libgloss/d30v/syscalls.c
index 64fbcf9..5244184 100644
--- a/libgloss/d30v/syscalls.c
+++ b/libgloss/d30v/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * syscalls.c -- provide system call support via trap 31
  *
@@ -37,6 +38,7 @@ __set_errno (int new_errno)
 {
   errno = new_errno;
   *(__errno)() = errno;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -44,95 +46,111 @@ void
 _exit (int status)
 {
   __syscall (status, 0, 0, 0, SYS_exit);
+  __A_VARIABLE = 1;
 }
 
 int
 open (const char *filename, int flags, int mode)
 {
+  __A_VARIABLE = 1;
   return __syscall (filename, flags, mode, 0, SYS_open);
 }
 
 int
 close (int filedes)
 {
+  __A_VARIABLE = 1;
   return __syscall (filedes, 0, 0, 0, SYS_close);
 }
 
 int
 read (int filedes, void *buffer, size_t length)
 {
+  __A_VARIABLE = 1;
   return __syscall (filedes, buffer, length, 0, SYS_read);
 }
 
 int
 write (int filedes, void *buffer, size_t length)
 {
+  __A_VARIABLE = 1;
   return __syscall (filedes, buffer, length, 0, SYS_write);
 }
 
 long
 lseek (int filedes, long offset, int whence)
 {
+  __A_VARIABLE = 1;
   return __syscall (filedes, offset, whence, 0, SYS_lseek);
 }
 
 int
 unlink (const char *filename)
 {
+  __A_VARIABLE = 1;
   return __syscall (filename, 0, 0, 0, SYS_unlink);
 }
 
 int
 getpid (void)
 {
+  __A_VARIABLE = 1;
   return __syscall (0, 0, 0, 0, SYS_getpid);
 }
 
 int
 kill (int signal, int pid)
 {
+  __A_VARIABLE = 1;
   return __syscall (signal, pid, 0, 0, SYS_kill);
 }
 
 int
 fstat (int filedes, void *info)
 {
+  __A_VARIABLE = 1;
   return __syscall (filedes, info, 0, 0, SYS_fstat);
 }
 
 int
 __argvlen (void)
 {
+  __A_VARIABLE = 1;
   return __syscall (0, 0, 0, 0, SYS_argvlen);
 }
 
 int
 __argv (void)
 {
+  __A_VARIABLE = 1;
   return __syscall (0, 0, 0, 0, SYS_argv);
 }
 
 int
 chdir (char *dir)
 {
+  __A_VARIABLE = 1;
   return __syscall (dir, 0, 0, 0, SYS_chdir);
 }
 
 int
 stat (const char *__restrict filename, void *__restrict info)
 {
+  __A_VARIABLE = 1;
   return __syscall (filename, info, 0, 0, SYS_stat);
 }
 
 int
 chmod (const char *filename, int mode)
 {
+  __A_VARIABLE = 1;
   return __syscall (filename, mode, 0, 0, SYS_chmod);
 }
 
 int
 utime (const char *filename, void *packet)
 {
+  __A_VARIABLE = 1;
   return __syscall (filename, packet, 0, 0, SYS_utime);
 }
 
@@ -143,5 +161,6 @@ time (time_t *time_ptr)
   result = (time_t) __syscall (time_ptr, 0, 0, 0, SYS_time);
   if (time_ptr != NULL)
     *time_ptr = result;
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/libgloss/debug.c b/libgloss/debug.c
index 3b1c8ff..9de8f63 100644
--- a/libgloss/debug.c
+++ b/libgloss/debug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1995, 1996 Cygnus Support
  *
diff --git a/libgloss/epiphany/_exit.c b/libgloss/epiphany/_exit.c
index 7489f1a..d25eb38 100644
--- a/libgloss/epiphany/_exit.c
+++ b/libgloss/epiphany/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _exit ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/_isatty.c b/libgloss/epiphany/_isatty.c
index 9ec5060..fd81cf4 100644
--- a/libgloss/epiphany/_isatty.c
+++ b/libgloss/epiphany/_isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c
 
    Copyright (c) 1994-2009  Red Hat, Inc. All rights reserved.
@@ -26,10 +27,14 @@ _DEFUN(_isatty, (fd), int fd)
 
   if (_fstat (fd, &buf) < 0) {
     errno = EBADF;
+    __A_VARIABLE = 1;
     return 0;
   }
-  if (S_ISCHR (buf.st_mode))
+  if (S_ISCHR (buf.st_mode)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
   errno = ENOTTY;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/epiphany/access.c b/libgloss/epiphany/access.c
index 832eb76..1d7cc97 100644
--- a/libgloss/epiphany/access.c
+++ b/libgloss/epiphany/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,15 +19,23 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/epiphany/close.c b/libgloss/epiphany/close.c
index fe32223..b7063bd 100644
--- a/libgloss/epiphany/close.c
+++ b/libgloss/epiphany/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _close ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/environ.c b/libgloss/epiphany/environ.c
index fb3d9b6..3d23d93 100644
--- a/libgloss/epiphany/environ.c
+++ b/libgloss/epiphany/environ.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of the environ vector
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/epiphany-syscalls.c b/libgloss/epiphany/epiphany-syscalls.c
index e6ebcee..cbe6024 100644
--- a/libgloss/epiphany/epiphany-syscalls.c
+++ b/libgloss/epiphany/epiphany-syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Adapteva epiphany-core implementation of stdio support functions ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/execve.c b/libgloss/epiphany/execve.c
index 21e4897..a16e88f 100644
--- a/libgloss/epiphany/execve.c
+++ b/libgloss/epiphany/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _execve ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/fork.c b/libgloss/epiphany/fork.c
index a655484..fed66e1 100644
--- a/libgloss/epiphany/fork.c
+++ b/libgloss/epiphany/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _fork ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/fstat.c b/libgloss/epiphany/fstat.c
index 5a20b57..f6bf392 100644
--- a/libgloss/epiphany/fstat.c
+++ b/libgloss/epiphany/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _fstat ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/getpid.c b/libgloss/epiphany/getpid.c
index 221b653..da4fe10 100644
--- a/libgloss/epiphany/getpid.c
+++ b/libgloss/epiphany/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _getpid ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/gettimeofday.c b/libgloss/epiphany/gettimeofday.c
index e169385..c0cb983 100644
--- a/libgloss/epiphany/gettimeofday.c
+++ b/libgloss/epiphany/gettimeofday.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _stat ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
@@ -35,5 +36,6 @@
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return asm_syscall (tp, tzp, NULL, SYS_gettimeofday);
 }
diff --git a/libgloss/epiphany/kill.c b/libgloss/epiphany/kill.c
index 64c9151..b40b5fe 100644
--- a/libgloss/epiphany/kill.c
+++ b/libgloss/epiphany/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _kill ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/link.c b/libgloss/epiphany/link.c
index d87637e..912ab8d 100644
--- a/libgloss/epiphany/link.c
+++ b/libgloss/epiphany/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _link ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/lseek.c b/libgloss/epiphany/lseek.c
index 64ffcdd..a5885f0 100644
--- a/libgloss/epiphany/lseek.c
+++ b/libgloss/epiphany/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _lseek ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/open.c b/libgloss/epiphany/open.c
index 71e9d58..7063451 100644
--- a/libgloss/epiphany/open.c
+++ b/libgloss/epiphany/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _open ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/read.c b/libgloss/epiphany/read.c
index 6e33e05..9b17e66 100644
--- a/libgloss/epiphany/read.c
+++ b/libgloss/epiphany/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _read ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/sbrk.c b/libgloss/epiphany/sbrk.c
index 4880c0f..9c6a0d7 100644
--- a/libgloss/epiphany/sbrk.c
+++ b/libgloss/epiphany/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _sbrk ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/stat.c b/libgloss/epiphany/stat.c
index 988f28d..ab5696b 100644
--- a/libgloss/epiphany/stat.c
+++ b/libgloss/epiphany/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _stat ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/times.c b/libgloss/epiphany/times.c
index edcc8c6..664fea3 100644
--- a/libgloss/epiphany/times.c
+++ b/libgloss/epiphany/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _times ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/unlink.c b/libgloss/epiphany/unlink.c
index c78af28..746bbc5 100644
--- a/libgloss/epiphany/unlink.c
+++ b/libgloss/epiphany/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _unlink ()
 
    Copyright (c) 2011, Adapteva, Inc.
diff --git a/libgloss/epiphany/wait.c b/libgloss/epiphany/wait.c
index 246e3b8..b74976b 100644
--- a/libgloss/epiphany/wait.c
+++ b/libgloss/epiphany/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _wait ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/epiphany/write.c b/libgloss/epiphany/write.c
index 430c103..9396be1 100644
--- a/libgloss/epiphany/write.c
+++ b/libgloss/epiphany/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EPIPHANY implementation of _write ()
 
    Copyright (c) 2011, 2012 Adapteva, Inc.
diff --git a/libgloss/fr30/syscalls.c b/libgloss/fr30/syscalls.c
index 2558556..be6d473 100644
--- a/libgloss/fr30/syscalls.c
+++ b/libgloss/fr30/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* FR30 system call emulation code
    Copyright (C) 1998, 2010 Free Software Foundation, Inc.
    Contributed by Cygnus Solutions.  */
@@ -14,6 +15,7 @@ _read (file, ptr, len)
   asm ("ldi:8 %0, r0" :: "i" (SYS_read) : "r0");
   asm ("int   #10");
   
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -26,6 +28,7 @@ _lseek (file, ptr, dir)
   asm ("ldi:8 %0, r0" :: "i" (SYS_lseek) : "r0");
   asm ("int   #10");
   
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -38,6 +41,7 @@ _write (file, ptr, len)
   asm ("ldi:8 %0, r0" :: "i" (SYS_write) : "r0");
   asm ("int   #10");
   
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -49,6 +53,7 @@ _open (path, flags)
   asm ("ldi:8  %0, r0" :: "i" (SYS_open) : "r0");
   asm ("int    #10");
   
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -59,6 +64,7 @@ _close (file)
   asm ("ldi:8  %0, r0" :: "i" (SYS_close) : "r0");
   asm ("int    #10");
   
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -68,6 +74,7 @@ _exit (n)
 {
   asm ("ldi:8  %0, r0" :: "i" (SYS_exit) : "r0");
   asm ("int    #10");
+  __A_VARIABLE = 1;
 }
 
 
@@ -93,6 +100,7 @@ _sbrk (incr)
 #endif
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -102,12 +110,14 @@ _fstat (file, st)
      struct stat * st;
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -115,18 +125,21 @@ int
 _isatty (fd)
      int fd;
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _raise ()
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _times ()
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -135,11 +148,13 @@ _kill (pid, sig)
      int pid;
      int sig;
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _getpid (void)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/frv/fstat.c b/libgloss/frv/fstat.c
index 756f7b2..c6a8697 100644
--- a/libgloss/frv/fstat.c
+++ b/libgloss/frv/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/frv/getpid.c b/libgloss/frv/getpid.c
index e6d5682..37c5481 100644
--- a/libgloss/frv/getpid.c
+++ b/libgloss/frv/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -21,5 +22,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/frv/isatty.c b/libgloss/frv/isatty.c
index b021b4f..9fa46d7 100644
--- a/libgloss/frv/isatty.c
+++ b/libgloss/frv/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 2002 Red Hat, Inc
@@ -23,5 +24,6 @@ int
 _DEFUN (_isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/frv/kill.c b/libgloss/frv/kill.c
index 7c365fd..ffd98dd 100644
--- a/libgloss/frv/kill.c
+++ b/libgloss/frv/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -26,5 +27,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/frv/print.c b/libgloss/frv/print.c
index 8c8be84..508caea 100644
--- a/libgloss/frv/print.c
+++ b/libgloss/frv/print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* print.c -- print a string on the output device.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -24,4 +25,5 @@ char *ptr)
   while (*ptr) {
     outbyte (*ptr++);
   }
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/frv/putnum.c b/libgloss/frv/putnum.c
index c7fa121..36a1c8e 100644
--- a/libgloss/frv/putnum.c
+++ b/libgloss/frv/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 2002 Red Hat, Inc
@@ -38,4 +39,5 @@ _DEFUN (_putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/frv/sbrk.c b/libgloss/frv/sbrk.c
index 469257d..c204b4a 100644
--- a/libgloss/frv/sbrk.c
+++ b/libgloss/frv/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate memory dynamically.
  * 
  * Copyright (c) 2002 Red Hat, Inc
@@ -37,6 +38,7 @@ _sbrk (nbytes)
   base = __heap_ptr;
   __heap_ptr += nbytes;
 
+  __A_VARIABLE = 1;
   return base;
 /* FIXME: We really want to make sure we don't run out of RAM, but this
  *       isn't very portable.
diff --git a/libgloss/frv/sim-inbyte.c b/libgloss/frv/sim-inbyte.c
index 9d39751..c860401 100644
--- a/libgloss/frv/sim-inbyte.c
+++ b/libgloss/frv/sim-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-inbyte.c -- read a character from standard input.
  *
@@ -19,8 +20,11 @@ inbyte ()
 {
   char c;
 
-  if (read (0, &c, 1) <= 0)
+  if (read (0, &c, 1) <= 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return c;
 }
diff --git a/libgloss/frv/sim-time.c b/libgloss/frv/sim-time.c
index c4746b4..41aa8be 100644
--- a/libgloss/frv/sim-time.c
+++ b/libgloss/frv/sim-time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-time.c -- stubs so clock can be linked in.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -46,6 +47,7 @@ _DEFUN (time, time (t),
   if (t)
     *t = ret;
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -57,6 +59,7 @@ _DEFUN (_times, _times (buf),
 	struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -75,5 +78,6 @@ _DEFUN (_gettimeofday, _gettimeofday (tv, tz),
 
   tv->tv_usec = 0;
   tv->tv_sec = _sim_time ();
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/frv/stat.c b/libgloss/frv/stat.c
index 094ab48..de3ac20 100644
--- a/libgloss/frv/stat.c
+++ b/libgloss/frv/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 2002 Red Hat, Inc
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/fstat.c b/libgloss/fstat.c
index 8082d63..0287acc 100644
--- a/libgloss/fstat.c
+++ b/libgloss/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/ft32/fstat.c b/libgloss/ft32/fstat.c
index 77058b2..cf7ff1a 100644
--- a/libgloss/ft32/fstat.c
+++ b/libgloss/ft32/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;        /* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/ft32/getpid.c b/libgloss/ft32/getpid.c
index 75bba42..b01f896 100644
--- a/libgloss/ft32/getpid.c
+++ b/libgloss/ft32/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -21,5 +22,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/ft32/isatty.c b/libgloss/ft32/isatty.c
index 449410e..6995d17 100644
--- a/libgloss/ft32/isatty.c
+++ b/libgloss/ft32/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -23,5 +24,6 @@ int
 _DEFUN (_isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/ft32/kill.c b/libgloss/ft32/kill.c
index 765b03e..ac885e5 100644
--- a/libgloss/ft32/kill.c
+++ b/libgloss/ft32/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -26,5 +27,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/ft32/sbrk.c b/libgloss/ft32/sbrk.c
index 8e6743e..6059bf6 100644
--- a/libgloss/ft32/sbrk.c
+++ b/libgloss/ft32/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate memory dynamically.
  *
  *
diff --git a/libgloss/ft32/sim-inbyte.c b/libgloss/ft32/sim-inbyte.c
index 9df0e1f..2716206 100644
--- a/libgloss/ft32/sim-inbyte.c
+++ b/libgloss/ft32/sim-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-inbyte.c -- read a character from standard input.
  *
@@ -19,8 +20,11 @@ inbyte ()
 {
   char c;
 
-  if (read (0, &c, 1) <= 0)
+  if (read (0, &c, 1) <= 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return c;
 }
diff --git a/libgloss/ft32/sim-lseek.c b/libgloss/ft32/sim-lseek.c
index 297de2b..7c99a94 100644
--- a/libgloss/ft32/sim-lseek.c
+++ b/libgloss/ft32/sim-lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-lseek.S -- write interface for FT32 simulator
  *
@@ -28,5 +29,6 @@ _DEFUN (_lseek, (fd,  offset, whence),
        int whence)
 {
   /*   errno = ESPIPE; */
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
diff --git a/libgloss/ft32/sim-time.c b/libgloss/ft32/sim-time.c
index 25e72a1..d25826a 100644
--- a/libgloss/ft32/sim-time.c
+++ b/libgloss/ft32/sim-time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-time.c -- stubs so clock can be linked in.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -25,6 +26,7 @@ _DEFUN (_times, _times (buf),
         struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -43,5 +45,6 @@ _DEFUN (_gettimeofday, _gettimeofday (tv, tz),
 
   tv->tv_usec = 0;
   tv->tv_sec = 0;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/ft32/stat.c b/libgloss/ft32/stat.c
index 580e2ca..830c205 100644
--- a/libgloss/ft32/stat.c
+++ b/libgloss/ft32/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (C) 2015 FTDI (support@ftdichip.com)
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/getpid.c b/libgloss/getpid.c
index 07f7f92..67445cc 100644
--- a/libgloss/getpid.c
+++ b/libgloss/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/hp74x/checksum.c b/libgloss/hp74x/checksum.c
index 4a2b331..fade9ec 100644
--- a/libgloss/hp74x/checksum.c
+++ b/libgloss/hp74x/checksum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <fcntl.h>
 
diff --git a/libgloss/hp74x/io.c b/libgloss/hp74x/io.c
index 054d90c..ca02c72 100644
--- a/libgloss/hp74x/io.c
+++ b/libgloss/hp74x/io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io.c -- all the code to make GCC and the libraries run on
  *         a bare target board.
@@ -54,6 +55,7 @@ delay (x)
   int  y = 17;
   while (x-- !=0)
     y = y^2;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -65,6 +67,7 @@ zylons()
   while (1) {
     strobe();
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -92,6 +95,7 @@ strobe()
   }
   curled = 1;
   dir = 0;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -116,6 +120,7 @@ pdc_call(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11)
      int arg0, arg1, arg2, arg3,  arg4, arg5;
      int arg6, arg7, arg9, arg10, arg11;
 {
+   __A_VARIABLE = 1;
    return ( CALL_PDC(arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11));
 }
 
@@ -126,6 +131,7 @@ int
 led_putnum (byte)
      unsigned short byte;
 {
+  __A_VARIABLE = 1;
   return (pdc_call(OPT_PDC_CHASSIS,0,byte));
 }
 
@@ -146,8 +152,10 @@ outbyte(byte)
 
   switch(status)
     {
-    case 0:  return(1);
-    default: return (-1);
+    case 0:  __A_VARIABLE = 1;
+    	return(1);
+    default: __A_VARIABLE = 1;
+    	return (-1);
     }
 }
 
@@ -199,6 +207,7 @@ read(fd, buf, nbytes)
       break;
     }
   }
+  __A_VARIABLE = 1;
   return (i);
 }
 
@@ -221,6 +230,7 @@ write(fd, buf, nbytes)
     }
     outbyte (*(buf + i));
   }
+  __A_VARIABLE = 1;
   return (nbytes);
 }
 
@@ -235,6 +245,7 @@ open(buf, flags, mode)
      int mode;
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -246,6 +257,7 @@ int
 close(fd)
      int fd;
 {
+  __A_VARIABLE = 1;
   return (0);
 }
 
@@ -284,6 +296,7 @@ int
 isatty(fd)
      int fd;
 {
+  __A_VARIABLE = 1;
   return (1);
 }
 
@@ -298,6 +311,7 @@ lseek(fd,  offset, whence)
      int whence;
 {
   errno = ESPIPE;
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
 
@@ -311,6 +325,7 @@ fstat(fd, buf)
      struct stat *buf;
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -321,6 +336,7 @@ fstat(fd, buf)
 int
 getpid()
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
 
@@ -334,5 +350,6 @@ kill(pid, sig)
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/hp74x/pa_stub.c b/libgloss/hp74x/pa_stub.c
index 2964921..17726f3 100644
--- a/libgloss/hp74x/pa_stub.c
+++ b/libgloss/hp74x/pa_stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* -*-C-*-
 *******************************************************************************
 *
@@ -225,12 +226,19 @@ static int
 hex(ch)
      unsigned char ch;
 {
-  if (ch >= 'a' && ch <= 'f')
+  if (ch >= 'a' && ch <= 'f') {
+    __A_VARIABLE = 1;
     return ch-'a'+10;
-  if (ch >= '0' && ch <= '9')
+  }
+  if (ch >= '0' && ch <= '9') {
+    __A_VARIABLE = 1;
     return ch-'0';
-  if (ch >= 'A' && ch <= 'F')
+  }
+  if (ch >= 'A' && ch <= 'F') {
+    __A_VARIABLE = 1;
     return ch-'A'+10;
+  }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -324,8 +332,10 @@ putpacket(buffer)
 
       while (ch = buffer[count])
 	{
-	  if (! putDebugChar(ch))
+	  if (! putDebugChar(ch)) {
+	    __A_VARIABLE = 1;
 	    return;
+	  }
 	  checksum += ch;
 	  count += 1;
 	}
@@ -334,6 +344,7 @@ putpacket(buffer)
       putDebugChar(hexchars[checksum >> 4]);
       putDebugChar(hexchars[checksum & 0xf]);
       } while (getDebugChar() != '+');
+      __A_VARIABLE = 1;
 }
 
 /* Convert the memory pointed to by mem into hex, placing result in buf.
@@ -362,7 +373,10 @@ mem2hex(mem, buf, count, may_fault)
       { new_addr = ((int) (mem+3)) & 0xFFFFFFF8;
         if (new_addr != check_addr)
         { check_addr = new_addr;
-          if (pdc_call(OPT_PDC_ADD_VALID,0,check_addr)) return 0;
+          if (pdc_call(OPT_PDC_ADD_VALID,0,check_addr)) {
+            __A_VARIABLE = 1;
+            return 0;
+          }
         }
       }
       ch = *mem++;
@@ -372,6 +386,7 @@ mem2hex(mem, buf, count, may_fault)
 
   *buf = 0;
 
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -400,12 +415,16 @@ hex2mem(buf, mem, count, may_fault)
       { new_addr = ((int)(mem+3)) & 0xFFFFFFF8;
         if (new_addr != check_addr)
         { check_addr = new_addr;
-          if (pdc_call(OPT_PDC_ADD_VALID,0,check_addr)) return 0;
+          if (pdc_call(OPT_PDC_ADD_VALID,0,check_addr)) {
+            __A_VARIABLE = 1;
+            return 0;
+          }
         }
       }
       *mem++ = ch;
     }
 
+  __A_VARIABLE = 1;
   return mem;
 }
 
@@ -439,6 +458,7 @@ set_debug_traps()
   putDebugChar ('+');
 
   initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -451,9 +471,12 @@ computeSignal(tt)
   struct hard_trap_info *ht;
 
   for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
-    if (ht->tt == tt)
+    if (ht->tt == tt) {
+      __A_VARIABLE = 1;
       return ht->signo;
+    }
 
+  __A_VARIABLE = 1;
   return SIGHUP;		/* default for things we don't know about */
 }
 
@@ -484,6 +507,7 @@ hexToInt(ptr, intValue)
       (*ptr)++;
     }
 
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -493,13 +517,17 @@ flush_i_cache()
 {
   unsigned int addr,count,loop;
 
-  if (i_cache_params[0] <= 0) return;
+  if (i_cache_params[0] <= 0) {
+      __A_VARIABLE = 1;
+      return;
+  }
 
   addr = i_cache_params[2];
   for (count = 0; count < i_cache_params[4]; count++)
     { for ( loop = 0; loop < i_cache_params[5]; loop++) FICE(addr);
       addr = addr + i_cache_params[3];
     }
+    __A_VARIABLE = 1;
 }
 
 /*
diff --git a/libgloss/hp74x/test.c b/libgloss/hp74x/test.c
index 2fd84ac..b87999e 100644
--- a/libgloss/hp74x/test.c
+++ b/libgloss/hp74x/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int led_putnum();
 #define DELAY 900000
 extern char strobe(),putDebugChar(),print(),putnum(); 
@@ -34,6 +35,7 @@ main()
   foobar();
   /* whew, we made it */
   print ("\r\nDone...");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -44,4 +46,5 @@ puts(s)
      char *s;
 {
   s++;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/i386/cygmon-gmon.c b/libgloss/i386/cygmon-gmon.c
index 480b2ec..321f51f 100644
--- a/libgloss/i386/cygmon-gmon.c
+++ b/libgloss/i386/cygmon-gmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1991, 2000 The Regents of the University of California.
  * All rights reserved.
@@ -114,6 +115,7 @@ monstartup(lowpc, highpc)
   if (buffer == (char *) -1) 
     {
       write (2, MSG , sizeof(MSG));
+      __A_VARIABLE = 1;
       return;
     }
   bzero (buffer, monsize);
@@ -122,6 +124,7 @@ monstartup(lowpc, highpc)
     {
       write(2, MSG, sizeof(MSG));
       froms = 0;
+      __A_VARIABLE = 1;
       return;
     }
   bzero (froms, s_textsize / HASHFRACTION);
@@ -143,6 +146,7 @@ monstartup(lowpc, highpc)
       write (2, MSG, sizeof(MSG));
       froms = 0;
       tos = 0;
+      __A_VARIABLE = 1;
       return;
     }
   bzero (tos, tolimit * sizeof( struct tostruct ) );
@@ -153,8 +157,10 @@ monstartup(lowpc, highpc)
   ( (struct phdr *) buffer ) -> hpc = highpc;
   ( (struct phdr *) buffer ) -> ncnt = ssiz;
   monsize -= sizeof(struct phdr);
-  if ( monsize <= 0 )
+  if ( monsize <= 0 ) {
+    __A_VARIABLE = 1;
     return;
+  }
   o = highpc - lowpc;
   if (monsize < o)
     {
@@ -163,6 +169,7 @@ monstartup(lowpc, highpc)
   else
     s_scale = SCALE_1_TO_1;
   moncontrol (1);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -195,6 +202,7 @@ _mcleanup()
 	}
     }
   profil_write (3, 0, 0);
+  __A_VARIABLE = 1;
 }
 
 static char already_setup = 0;
@@ -327,6 +335,7 @@ done:
   profiling--;
   /* and fall through */
 out:
+  __A_VARIABLE = 1;
   return;		/* normal return restores saved registers */
 
 overflow:
diff --git a/libgloss/i386/cygmon-salib.c b/libgloss/i386/cygmon-salib.c
index b4a4d34..24d7b91 100644
--- a/libgloss/i386/cygmon-salib.c
+++ b/libgloss/i386/cygmon-salib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Standard x86 syscalls for user programs running under Cygmon
  *
@@ -28,6 +29,7 @@ _syscall3(int,read,int,i,char *,c,int,len);
 int
 read (int des, char *dest, int len)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 #endif
@@ -53,6 +55,7 @@ open (const char *filename, int mode, ...)
 #if 0
   return __open (filename, mode, 0644); 
 #else
+  __A_VARIABLE = 1;
   return -1;
 #endif
 }
@@ -61,11 +64,13 @@ open (const char *filename, int mode, ...)
 int
 isatty (int i)
 {
+  __A_VARIABLE = 1;
   return i<3;
 }
 
 int unlink (const char *p)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -78,13 +83,16 @@ sbrk (int amt)
   char *res;
   if (ptr == 0)
     ptr = &_end;
-  if (amt == 0)
+  if (amt == 0) {
+    __A_VARIABLE = 1;
     return (char *)ptr;
+  }
 
   if (((long)ptr) % 8)
     ptr = ptr + (8 - (((long)(ptr)) % 8));
   res = ptr;
   ptr += amt;
+  __A_VARIABLE = 1;
   return (char *)res;
 }
 
@@ -95,23 +103,27 @@ _exit(int i)
     __sys_exit (i);
     asm("	int $3");
   }
+  __A_VARIABLE = 1;
 }
 
 int
 fstat(int des, struct stat *buf)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 lseek(int des,unsigned long offset, int whence)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 getpid ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -122,6 +134,7 @@ clock ()
   struct timeval t;
 
   gettimeofday (&t, 0);
+  __A_VARIABLE = 1;
   return t.tv_sec * 1000 + (t.tv_usec / 1000);
 }
 
@@ -139,6 +152,7 @@ __do_global_ctors ()
       (d)();
       c++;
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -159,6 +173,7 @@ __do_global_dtors ()
       (*d)();
       c--;
     }
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -179,4 +194,5 @@ profil_write (int type, char *buffer, int len)
     {
       write (des, buffer, len);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/i960/crt0.c b/libgloss/i960/crt0.c
index 45d7891..1dc38f1 100644
--- a/libgloss/i960/crt0.c
+++ b/libgloss/i960/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int main(int argc, char **argv, char **envp);
 extern int brk (void *value);
 
@@ -16,6 +17,7 @@ enable_tracing (void)
     __asm__ volatile ("modpc %0,%0,%0"
 	              :
 	              : "d" (mask));
+    __A_VARIABLE = 1;
 }
 
 #define STACK_ALIGN 64
@@ -31,6 +33,7 @@ set_stack (void* ptr)
     __asm__ volatile ("mov %0,fp"
 	              :
 	              : "d" (ptr));
+    __A_VARIABLE = 1;
 }
 
 __inline static void 
@@ -46,6 +49,7 @@ init_Cregs (void)
                       :                      /* no output */
                       : "d" (mask0),
                         "d" (mask1));        /* fpu control kb */
+    __A_VARIABLE = 1;
 }
 
 void
@@ -63,4 +67,5 @@ _start(void)
   memset (&bss_start, 0, &end - &bss_start);
   main(0, 0, 0);
   exit(0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/i960/mon-read.c b/libgloss/i960/mon-read.c
index 92e15d2..8145d3a 100644
--- a/libgloss/i960/mon-read.c
+++ b/libgloss/i960/mon-read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <errno.h>
 
 read (fd, buf, sz)
diff --git a/libgloss/i960/mon-write.c b/libgloss/i960/mon-write.c
index 527037f..0980940 100644
--- a/libgloss/i960/mon-write.c
+++ b/libgloss/i960/mon-write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <errno.h>
 
 int
@@ -8,7 +9,9 @@ write (int fd, const char *buf, int sz)
   if (r != 0)
     {
       errno = r;
+      __A_VARIABLE = 1;
       return -1;
     }
+  __A_VARIABLE = 1;
   return nwritten;
 }
diff --git a/libgloss/i960/mon960.c b/libgloss/i960/mon960.c
index 7b1e07e..451e160 100644
--- a/libgloss/i960/mon960.c
+++ b/libgloss/i960/mon960.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 
@@ -7,6 +8,7 @@ int
 brk (void *ptr)
 {
   heap_end = ptr;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -20,12 +22,14 @@ sbrk (int amt)
     heap_end = &end;
   prev_heap_end = heap_end;
   heap_end += amt;
+  __A_VARIABLE = 1;
   return ((caddr_t) prev_heap_end);
 }
 
 int
 isatty (int file)
 {
+  __A_VARIABLE = 1;
   return file<3;
 }
 
@@ -33,6 +37,7 @@ int
 fstat (int file, struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -40,30 +45,35 @@ int
 stat (const char *__restrict filename, struct stat *__restrict st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 lseek (int fd, off_t offset, int type)
 {
+  __A_VARIABLE = 1;
   return _sys_lseek (fd, offset, type);
 }
 
 int
 open (char *file, int mode, int perms)
 {
+  __A_VARIABLE = 1;
   return _sys_open (file, mode, perms);
 }
 
 int
 close (int fd)
 {
+  __A_VARIABLE = 1;
   return _sys_close (fd);
 }
 
 int
 getpid ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -71,6 +81,7 @@ int
 kill (int pid, int signal)
 {
   exit (signal);
+  __A_VARIABLE = 1;
 }
 
 #if 0
diff --git a/libgloss/iq2000/_exit.c b/libgloss/iq2000/_exit.c
index 318984b..96591cc 100644
--- a/libgloss/iq2000/_exit.c
+++ b/libgloss/iq2000/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,6 +16,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -32,4 +34,5 @@ void _exit (n)
   __deregister_frame_info (__eh_frame_begin);
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/iq2000/access.c b/libgloss/iq2000/access.c
index 980682e..b71fa38 100644
--- a/libgloss/iq2000/access.c
+++ b/libgloss/iq2000/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/libgloss/iq2000/chmod.c b/libgloss/iq2000/chmod.c
index 8200506..d08fb19 100644
--- a/libgloss/iq2000/chmod.c
+++ b/libgloss/iq2000/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/iq2000/chown.c b/libgloss/iq2000/chown.c
index 6630d3b..a82a8eb 100644
--- a/libgloss/iq2000/chown.c
+++ b/libgloss/iq2000/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/libgloss/iq2000/close.c b/libgloss/iq2000/close.c
index 8474b38..47a154a 100644
--- a/libgloss/iq2000/close.c
+++ b/libgloss/iq2000/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/iq2000/creat.c b/libgloss/iq2000/creat.c
index 1003a2a..0b5dfa1 100644
--- a/libgloss/iq2000/creat.c
+++ b/libgloss/iq2000/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/libgloss/iq2000/crt1.c b/libgloss/iq2000/crt1.c
index fb333a8..a778534 100644
--- a/libgloss/iq2000/crt1.c
+++ b/libgloss/iq2000/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 /* This object reserves enough space for an EH frame initialization
@@ -28,4 +29,5 @@ void _main ()
 
       __register_frame_info (__eh_frame_begin, &object);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/iq2000/execv.c b/libgloss/iq2000/execv.c
index 16f3ca5..c785c45 100644
--- a/libgloss/iq2000/execv.c
+++ b/libgloss/iq2000/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/libgloss/iq2000/execve.c b/libgloss/iq2000/execve.c
index bd6c7a2..73418be 100644
--- a/libgloss/iq2000/execve.c
+++ b/libgloss/iq2000/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/libgloss/iq2000/fork.c b/libgloss/iq2000/fork.c
index 53df5a9..93245fa 100644
--- a/libgloss/iq2000/fork.c
+++ b/libgloss/iq2000/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/libgloss/iq2000/fstat.c b/libgloss/iq2000/fstat.c
index c3b2fa0..5a10d3c 100644
--- a/libgloss/iq2000/fstat.c
+++ b/libgloss/iq2000/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/iq2000/getpid.c b/libgloss/iq2000/getpid.c
index 20ab186..11e35c6 100644
--- a/libgloss/iq2000/getpid.c
+++ b/libgloss/iq2000/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -6,5 +7,6 @@
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/iq2000/gettime.c b/libgloss/iq2000/gettime.c
index 1a04267..9600e7a 100644
--- a/libgloss/iq2000/gettime.c
+++ b/libgloss/iq2000/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/libgloss/iq2000/isatty.c b/libgloss/iq2000/isatty.c
index 7e63a8c..a5a8fbd 100644
--- a/libgloss/iq2000/isatty.c
+++ b/libgloss/iq2000/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/iq2000/kill.c b/libgloss/iq2000/kill.c
index 40afa6a..922a4c5 100644
--- a/libgloss/iq2000/kill.c
+++ b/libgloss/iq2000/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/iq2000/lseek.c b/libgloss/iq2000/lseek.c
index 339baea..69f76f8 100644
--- a/libgloss/iq2000/lseek.c
+++ b/libgloss/iq2000/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _lseek (int file,
 	off_t ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/iq2000/open.c b/libgloss/iq2000/open.c
index 770defe..5d6c475 100644
--- a/libgloss/iq2000/open.c
+++ b/libgloss/iq2000/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/libgloss/iq2000/pipe.c b/libgloss/iq2000/pipe.c
index dfade5c..cefcfc9 100644
--- a/libgloss/iq2000/pipe.c
+++ b/libgloss/iq2000/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 pipe (int fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/libgloss/iq2000/read.c b/libgloss/iq2000/read.c
index 31d24cc..c3a5bca 100644
--- a/libgloss/iq2000/read.c
+++ b/libgloss/iq2000/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ _read (int file,
        char *ptr,
        size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/iq2000/sbrk.c b/libgloss/iq2000/sbrk.c
index 6dfd93b..f11c5fd 100644
--- a/libgloss/iq2000/sbrk.c
+++ b/libgloss/iq2000/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -24,7 +25,9 @@ _sbrk (size_t incr)
     {
       _write (1, "Heap and stack collision\n", 25);
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return (caddr_t)-1;
     }
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/iq2000/stat.c b/libgloss/iq2000/stat.c
index 4e1fddf..164976a 100644
--- a/libgloss/iq2000/stat.c
+++ b/libgloss/iq2000/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/iq2000/test.c b/libgloss/iq2000/test.c
index 9ea873a..3ab102c 100644
--- a/libgloss/iq2000/test.c
+++ b/libgloss/iq2000/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 static void
@@ -5,6 +6,7 @@ send_msg1 (void)
 {
   static char msg[] = "Hello World\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -12,6 +14,7 @@ send_msg2 (void)
 {
   static char msg[] = "Goodnight Irene\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -21,6 +24,7 @@ delay (void)
 
   for (i = 0; i < 1000000; i++)
     ;
+    __A_VARIABLE = 1;
 }
 
 int
@@ -33,6 +37,7 @@ main(int argc, char *argv[])
       delay ();
       send_msg2 ();
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/iq2000/time.c b/libgloss/iq2000/time.c
index 2df8d48..af74345 100644
--- a/libgloss/iq2000/time.c
+++ b/libgloss/iq2000/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/libgloss/iq2000/times.c b/libgloss/iq2000/times.c
index b804be4..240b40f 100644
--- a/libgloss/iq2000/times.c
+++ b/libgloss/iq2000/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 clock_t
 times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/libgloss/iq2000/trap.c b/libgloss/iq2000/trap.c
index 217cef2..eebc879 100644
--- a/libgloss/iq2000/trap.c
+++ b/libgloss/iq2000/trap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 // Perform a system call.
 // Unused parameters should be set to 0.
 int __trap0(unsigned long func, unsigned long p1, unsigned long p2, unsigned long p3)
@@ -9,5 +10,6 @@ int __trap0(unsigned long func, unsigned long p1, unsigned long p2, unsigned lon
   asm volatile ("nop\n\tor %%7,%%0,%0" : : "r"(p3));
   asm volatile ("nop\n\tor %%11,%%0,%0" : : "r"(func));
   asm volatile ("syscall\n\tnop\n\tor %0,%%0,%%2" : "=r"(ret));
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/libgloss/iq2000/unlink.c b/libgloss/iq2000/unlink.c
index 84fb711..78f961e 100644
--- a/libgloss/iq2000/unlink.c
+++ b/libgloss/iq2000/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/iq2000/utime.c b/libgloss/iq2000/utime.c
index 3fce7e3..16823d5 100644
--- a/libgloss/iq2000/utime.c
+++ b/libgloss/iq2000/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/iq2000/wait.c b/libgloss/iq2000/wait.c
index c8d8b4c..f134991 100644
--- a/libgloss/iq2000/wait.c
+++ b/libgloss/iq2000/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/libgloss/iq2000/write.c b/libgloss/iq2000/write.c
index 3ecf4a8..fa35bf2 100644
--- a/libgloss/iq2000/write.c
+++ b/libgloss/iq2000/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ _write ( int file,
 	 char *ptr,
 	 size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/isatty.c b/libgloss/isatty.c
index 2d66cd6..724aa5b 100644
--- a/libgloss/isatty.c
+++ b/libgloss/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -23,5 +24,6 @@ int
 _DEFUN (isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/kill.c b/libgloss/kill.c
index afc1257..e0c0495 100644
--- a/libgloss/kill.c
+++ b/libgloss/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/libnosys/_exit.c b/libgloss/libnosys/_exit.c
index 3fdf7f0..3e2b61c 100644
--- a/libgloss/libnosys/_exit.c
+++ b/libgloss/libnosys/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stub version of _exit.  */
 
 #include <limits.h>
@@ -16,4 +17,5 @@ _DEFUN (_exit, (rc),
   /* Convince GCC that this function never returns.  */
   for (;;)
     ;
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/libnosys/chown.c b/libgloss/libnosys/chown.c
index 67f98d5..e6c594d 100644
--- a/libgloss/libnosys/chown.c
+++ b/libgloss/libnosys/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of chown.
  */
@@ -18,6 +19,7 @@ _DEFUN (_chown, (path, owner, group),
         gid_t group)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/close.c b/libgloss/libnosys/close.c
index b759b86..3d6203d 100644
--- a/libgloss/libnosys/close.c
+++ b/libgloss/libnosys/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of close.
  */
@@ -15,6 +16,7 @@ _DEFUN (_close, (fildes),
         int fildes)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/environ.c b/libgloss/libnosys/environ.c
index b582506..acab30c 100644
--- a/libgloss/libnosys/environ.c
+++ b/libgloss/libnosys/environ.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Version of environ for no OS.
  */
diff --git a/libgloss/libnosys/errno.c b/libgloss/libnosys/errno.c
index 27d8e3a..9665bfb 100644
--- a/libgloss/libnosys/errno.c
+++ b/libgloss/libnosys/errno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Supply a definition of errno if one not already provided.  */
 
 int errno;
diff --git a/libgloss/libnosys/execve.c b/libgloss/libnosys/execve.c
index 01743ff..dd401ec 100644
--- a/libgloss/libnosys/execve.c
+++ b/libgloss/libnosys/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of execve.
  */
@@ -17,6 +18,7 @@ _DEFUN (_execve, (name, argv, env),
         char **env)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/fork.c b/libgloss/libnosys/fork.c
index f5795cb..bf187b0 100644
--- a/libgloss/libnosys/fork.c
+++ b/libgloss/libnosys/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of fork.
  */
@@ -15,6 +16,7 @@ _DEFUN (_fork, (),
         _NOARGS)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/fstat.c b/libgloss/libnosys/fstat.c
index 4e18d42..530d7f6 100644
--- a/libgloss/libnosys/fstat.c
+++ b/libgloss/libnosys/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of fstat.
  */
@@ -18,6 +19,7 @@ _DEFUN (_fstat, (fildes, st),
         struct stat *st)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/getpid.c b/libgloss/libnosys/getpid.c
index 0ea1923..a9117c2 100644
--- a/libgloss/libnosys/getpid.c
+++ b/libgloss/libnosys/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of getpid.
  */
@@ -15,6 +16,7 @@ _DEFUN (_getpid, (),
         _NOARGS)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/gettod.c b/libgloss/libnosys/gettod.c
index 4d42b4b..08f98ed 100644
--- a/libgloss/libnosys/gettod.c
+++ b/libgloss/libnosys/gettod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of gettimeofday.
  */
@@ -20,6 +21,7 @@ _DEFUN (_gettimeofday, (ptimeval, ptimezone),
         void *ptimezone)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/isatty.c b/libgloss/libnosys/isatty.c
index d93e177..02d2978 100644
--- a/libgloss/libnosys/isatty.c
+++ b/libgloss/libnosys/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of isatty.
  */
@@ -15,6 +16,7 @@ _DEFUN (_isatty, (file),
         int file)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/libnosys/kill.c b/libgloss/libnosys/kill.c
index f1d12c6..581888c 100644
--- a/libgloss/libnosys/kill.c
+++ b/libgloss/libnosys/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of kill.
  */
@@ -16,6 +17,7 @@ _DEFUN (_kill, (pid, sig),
         int sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/link.c b/libgloss/libnosys/link.c
index 35881cf..69caa6a 100644
--- a/libgloss/libnosys/link.c
+++ b/libgloss/libnosys/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of link.
  */
@@ -16,6 +17,7 @@ _DEFUN (_link, (existing, new),
         char *new)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/lseek.c b/libgloss/libnosys/lseek.c
index 0aa89e2..850cd69 100644
--- a/libgloss/libnosys/lseek.c
+++ b/libgloss/libnosys/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of lseek.
  */
@@ -17,6 +18,7 @@ _DEFUN (_lseek, (file, ptr, dir),
         int   dir)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/open.c b/libgloss/libnosys/open.c
index 2c8a6ce..65b0bf8 100644
--- a/libgloss/libnosys/open.c
+++ b/libgloss/libnosys/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of open.
  */
@@ -17,6 +18,7 @@ _DEFUN (_open, (file, flags, mode),
         int   mode)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/read.c b/libgloss/libnosys/read.c
index 1a2819c..16a6002 100644
--- a/libgloss/libnosys/read.c
+++ b/libgloss/libnosys/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of read.
  */
@@ -17,6 +18,7 @@ _DEFUN (_read, (file, ptr, len),
         int   len)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/readlink.c b/libgloss/libnosys/readlink.c
index 7df253c..06afed3 100644
--- a/libgloss/libnosys/readlink.c
+++ b/libgloss/libnosys/readlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of readlink.
  */
@@ -18,6 +19,7 @@ _DEFUN (_readlink, (path, buf, bufsize),
         size_t bufsize)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/sbrk.c b/libgloss/libnosys/sbrk.c
index 86c130a..c3d0d42 100644
--- a/libgloss/libnosys/sbrk.c
+++ b/libgloss/libnosys/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Version of sbrk for no operating system.  */
 
 #include "config.h"
@@ -17,5 +18,6 @@ _sbrk (incr)
    prev_heap_end = heap_end;
    heap_end += incr;
 
+   __A_VARIABLE = 1;
    return (void *) prev_heap_end;
 }
diff --git a/libgloss/libnosys/stat.c b/libgloss/libnosys/stat.c
index 7c34637..7f8def6 100644
--- a/libgloss/libnosys/stat.c
+++ b/libgloss/libnosys/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of stat.
  */
@@ -18,6 +19,7 @@ _DEFUN (_stat, (file, st),
         struct stat *st)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/symlink.c b/libgloss/libnosys/symlink.c
index d9e29f2..3ec900e 100644
--- a/libgloss/libnosys/symlink.c
+++ b/libgloss/libnosys/symlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of symlink.
  */
@@ -16,6 +17,7 @@ _DEFUN (_symlink, (path1, path2),
         const char *path2)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/times.c b/libgloss/libnosys/times.c
index f205e50..7d4d07a 100644
--- a/libgloss/libnosys/times.c
+++ b/libgloss/libnosys/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of times.
  */
@@ -16,6 +17,7 @@ _DEFUN (_times, (buf),
         struct tms *buf)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/unlink.c b/libgloss/libnosys/unlink.c
index c543709..c297cf6 100644
--- a/libgloss/libnosys/unlink.c
+++ b/libgloss/libnosys/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of unlink.
  */
@@ -15,6 +16,7 @@ _DEFUN (_unlink, (name),
         char *name)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/wait.c b/libgloss/libnosys/wait.c
index 2a785be..d808311 100644
--- a/libgloss/libnosys/wait.c
+++ b/libgloss/libnosys/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of wait.
  */
@@ -15,6 +16,7 @@ _DEFUN (_wait, (status),
         int  *status)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/libnosys/write.c b/libgloss/libnosys/write.c
index 0136d74..5e1aed0 100644
--- a/libgloss/libnosys/write.c
+++ b/libgloss/libnosys/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Stub version of write.
  */
@@ -17,6 +18,7 @@ _DEFUN (_write, (file, ptr, len),
         int   len)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/lm32/isatty.c b/libgloss/lm32/isatty.c
index 69833fa..99b8504 100644
--- a/libgloss/lm32/isatty.c
+++ b/libgloss/lm32/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 
  * Lattice Mico32 implementation of isatty system call.
  * Contributed by Jon Beniston <jon@beniston.com>
diff --git a/libgloss/lseek.c b/libgloss/lseek.c
index 1df36f5..952ff00 100644
--- a/libgloss/lseek.c
+++ b/libgloss/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek.c -- move read/write pointer.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,6 +27,7 @@ _DEFUN (lseek, (fd,  offset, whence),
        int whence)
 {
   errno = ESPIPE;
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
 
diff --git a/libgloss/m32c/sample.c b/libgloss/m32c/sample.c
index 0b7c665..8fbecee 100644
--- a/libgloss/m32c/sample.c
+++ b/libgloss/m32c/sample.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 
 Copyright (c) 2008 Red Hat Incorporated.
@@ -82,6 +83,7 @@ exit(int rv)
 {
   while (1)
     asm volatile ("");
+  __A_VARIABLE = 1;
 }
 
 #ifdef __r8c_cpu__
@@ -102,6 +104,7 @@ fast_clock(void)
   ocd = 0;
   prcr = 0;
   asm("fset I");
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -121,6 +124,7 @@ timer_ra_interrupt()
   p1 = tc;
   p0 = tc >> 8;
 #endif
+  __A_VARIABLE = 1;
 }
 
 main()
@@ -156,4 +160,5 @@ main()
   /* main() must never return.  */
   while (1)
     ;
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/m32c/sbrk.c b/libgloss/m32c/sbrk.c
index 8db42a9..878f314 100644
--- a/libgloss/m32c/sbrk.c
+++ b/libgloss/m32c/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 
 Copyright (c) 2005 Red Hat Incorporated.
@@ -49,5 +50,6 @@ sbrk(PTRDIFF_T adj)
 
   heap += adj;
   _set_heaptop(heap);
+  __A_VARIABLE = 1;
   return rv;
 }
diff --git a/libgloss/m32r/chmod.c b/libgloss/m32r/chmod.c
index 14990d9..fe1f9f6 100644
--- a/libgloss/m32r/chmod.c
+++ b/libgloss/m32r/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _chmod (const char *path, short mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/m32r/close.c b/libgloss/m32r/close.c
index 1e32da4..9a92faf 100644
--- a/libgloss/m32r/close.c
+++ b/libgloss/m32r/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/m32r/exit.c b/libgloss/m32r/exit.c
index 5251f0d..5676d19 100644
--- a/libgloss/m32r/exit.c
+++ b/libgloss/m32r/exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -7,4 +8,5 @@ void
 _exit (n)
 {
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m32r/fstat.c b/libgloss/m32r/fstat.c
index 1f91828..18216c1 100644
--- a/libgloss/m32r/fstat.c
+++ b/libgloss/m32r/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -7,5 +8,6 @@ int
 _fstat (int file, struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/m32r/getpid.c b/libgloss/m32r/getpid.c
index ff6e902..c199495 100644
--- a/libgloss/m32r/getpid.c
+++ b/libgloss/m32r/getpid.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 
 int
 _getpid (int n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/m32r/isatty.c b/libgloss/m32r/isatty.c
index cc9bfe1..163b494 100644
--- a/libgloss/m32r/isatty.c
+++ b/libgloss/m32r/isatty.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 
 /* FIXME: can we not nuke the 10,000 copies of this function
    and fudge things (which is all this function does) in _fstat?  */
 int
 _isatty (int fd)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/m32r/kill.c b/libgloss/m32r/kill.c
index d7aaee9..79cd0ff 100644
--- a/libgloss/m32r/kill.c
+++ b/libgloss/m32r/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
diff --git a/libgloss/m32r/lseek.c b/libgloss/m32r/lseek.c
index 1fbb5d0..7817478 100644
--- a/libgloss/m32r/lseek.c
+++ b/libgloss/m32r/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _lseek (int file, int ptr, int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/m32r/m32r-lib.c b/libgloss/m32r/m32r-lib.c
index 1d2d291..6172126 100644
--- a/libgloss/m32r/m32r-lib.c
+++ b/libgloss/m32r/m32r-lib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stand-alone library for M32R-EVA board.
  *
  * Copyright (c) 1996, 1998 Cygnus Support
@@ -53,12 +54,14 @@ rx_rdy()
 static int
 tx_rdy()
 {
+  __A_VARIABLE = 1;
   return (*tx_status & UART_OUTPUT_EMPTY);
 }
 
 static unsigned char
 rx_uchar()
 {
+  __A_VARIABLE = 1;
   return *rx_port;
 }
 
@@ -66,6 +69,7 @@ void
 tx_char(char c)
 {
   *tx_port = c;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -73,6 +77,7 @@ getDebugChar()
 {
   while (!rx_rdy())
     ;
+  __A_VARIABLE = 1;
   return rx_uchar();
 }
 
@@ -82,6 +87,7 @@ putDebugChar(int c)
   while (!tx_rdy())
     ;
   tx_char(c);
+  __A_VARIABLE = 1;
 }
 
 void mesg(char *p)
@@ -92,6 +98,7 @@ void mesg(char *p)
 	putDebugChar('\r');
       putDebugChar(*p++);
     }
+    __A_VARIABLE = 1;
 }
 
 void phex(long x)
@@ -107,6 +114,7 @@ void phex(long x)
       x >>= 4;
     }
   mesg(buf);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -130,6 +138,7 @@ exceptionHandler (int tt, unsigned long routine)
 
   tb[tt] = ((routine >> 2) | 0xff000000) - tt;
 #endif
+  __A_VARIABLE = 1;
 }
 
 /* Return the address of trap TT handler */
diff --git a/libgloss/m32r/m32r-stub.c b/libgloss/m32r/m32r-stub.c
index 4d54f72..362b000 100644
--- a/libgloss/m32r/m32r-stub.c
+++ b/libgloss/m32r/m32r-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************************
 
 		THIS SOFTWARE IS NOT COPYRIGHTED
@@ -567,18 +568,26 @@ crc32 (unsigned char *buf, int len, unsigned long crc)
       crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
       buf++;
     }
+  __A_VARIABLE = 1;
   return crc;
 }
 
 static int
 hex (unsigned char ch)
 {
-  if ((ch >= 'a') && (ch <= 'f'))
+  if ((ch >= 'a') && (ch <= 'f')) {
+    __A_VARIABLE = 1;
     return (ch - 'a' + 10);
-  if ((ch >= '0') && (ch <= '9'))
+  }
+  if ((ch >= '0') && (ch <= '9')) {
+    __A_VARIABLE = 1;
     return (ch - '0');
-  if ((ch >= 'A') && (ch <= 'F'))
+  }
+  if ((ch >= 'A') && (ch <= 'F')) {
+    __A_VARIABLE = 1;
     return (ch - 'A' + 10);
+  }
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -685,6 +694,7 @@ putpacket (unsigned char *buffer)
       putDebugChar (hexchars[checksum % 16]);
     }
   while (getDebugChar () != '+');
+  __A_VARIABLE = 1;
 }
 
 /* Address of a routine to RTE to if we get a memory fault.  */
@@ -695,6 +705,7 @@ static void
 set_mem_err (void)
 {
   mem_err = 1;
+  __A_VARIABLE = 1;
 }
 
 /* Check the address for safe access ranges.  As currently defined,
@@ -710,14 +721,23 @@ mem_safe (unsigned char *addr)
 #define BAD_RANGE_TWO_START	((unsigned char *) 0xff680000)
 #define BAD_RANGE_TWO_END	((unsigned char *) 0xff800000)
 
-  if (addr < BAD_RANGE_ONE_START)
-    return 1;			/* safe */
-  if (addr < BAD_RANGE_ONE_END)
-    return 0;			/* unsafe */
-  if (addr < BAD_RANGE_TWO_START)
-    return 1;			/* safe */
-  if (addr < BAD_RANGE_TWO_END)
-    return 0;			/* unsafe */
+  if (addr < BAD_RANGE_ONE_START) {
+    __A_VARIABLE = 1;
+    return 1;
+  }			/* safe */
+  if (addr < BAD_RANGE_ONE_END) {
+    __A_VARIABLE = 1;
+    return 0;
+  }			/* unsafe */
+  if (addr < BAD_RANGE_TWO_START) {
+    __A_VARIABLE = 1;
+    return 1;
+  }			/* safe */
+  if (addr < BAD_RANGE_TWO_END) {
+    __A_VARIABLE = 1;
+    return 0;
+  }			/* unsafe */
+  __A_VARIABLE = 1;
 }
 
 /* These are separate functions so that they are so short and sweet
@@ -731,9 +751,11 @@ get_char (unsigned char *addr)
   if (mem_fault_routine && !mem_safe (addr))
     {
       mem_fault_routine ();
+      __A_VARIABLE = 1;
       return 0;
     }
 #endif
+  __A_VARIABLE = 1;
   return *addr;
 }
 
@@ -744,10 +766,12 @@ set_char (unsigned char *addr, unsigned char val)
   if (mem_fault_routine && !mem_safe (addr))
     {
       mem_fault_routine ();
+      __A_VARIABLE = 1;
       return;
     }
 #endif
   *addr = val;
+  __A_VARIABLE = 1;
 }
 
 /* Convert the memory pointed to by mem into hex, placing result in buf.
@@ -766,14 +790,17 @@ mem2hex (unsigned char *mem, unsigned char *buf, int count, int may_fault)
   for (i = 0; i < count; i++)
     {
       ch = get_char (mem++);
-      if (may_fault && mem_err)
+      if (may_fault && mem_err) {
+	__A_VARIABLE = 1;
 	return (buf);
+      }
       *buf++ = hexchars[ch >> 4];
       *buf++ = hexchars[ch % 16];
     }
   *buf = 0;
   if (may_fault)
     mem_fault_routine = 0;
+  __A_VARIABLE = 1;
   return (buf);
 }
 
@@ -793,11 +820,14 @@ hex2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
       ch = hex (*buf++) << 4;
       ch = ch + hex (*buf++);
       set_char (mem++, ch);
-      if (may_fault && mem_err)
+      if (may_fault && mem_err) {
+	__A_VARIABLE = 1;
 	return (mem);
     }
+    }
   if (may_fault)
     mem_fault_routine = 0;
+  __A_VARIABLE = 1;
   return (mem);
 }
 
@@ -836,12 +866,15 @@ bin2mem (unsigned char *buf, unsigned char *mem, int count, int may_fault)
 
       set_char (mem++, *buf++);
 
-      if (may_fault && mem_err)
+      if (may_fault && mem_err) {
+	__A_VARIABLE = 1;
 	return mem;
     }
+    }
 
   if (may_fault)
     mem_fault_routine = 0;
+  __A_VARIABLE = 1;
   return mem;
 }
 
@@ -912,6 +945,7 @@ computeSignal (int exceptionVector)
       sigval = 7;
       break;			/* "software generated"        */
     }
+  __A_VARIABLE = 1;
   return (sigval);
 }
 
@@ -938,6 +972,7 @@ hexToInt (unsigned char **ptr, int *intValue)
 	break;
       (*ptr)++;
     }
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -970,17 +1005,24 @@ isShortBranch (unsigned char *instr)
 {
   unsigned char instr0 = instr[0] & 0x7F;	/* mask off high bit */
 
-  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */
-    return 1;			/* return from trap or exception */
+  if (instr0 == 0x10 && instr[1] == 0xB6)	/* RTE */ {
+    __A_VARIABLE = 1;
+    return 1;
+  }			/* return from trap or exception */
 
   if (instr0 == 0x1E || instr0 == 0x1F)	/* JL or JMP */
-    if ((instr[1] & 0xF0) == 0xC0)
-      return 2;			/* jump thru a register */
+    if ((instr[1] & 0xF0) == 0xC0) {
+      __A_VARIABLE = 1;
+      return 2;
+    }			/* jump thru a register */
 
   if (instr0 == 0x7C || instr0 == 0x7D ||	/* BC, BNC, BL, BRA */
-      instr0 == 0x7E || instr0 == 0x7F)
-    return 3;			/* eight bit PC offset */
+      instr0 == 0x7E || instr0 == 0x7F) {
+    __A_VARIABLE = 1;
+    return 3;
+  }			/* eight bit PC offset */
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -988,19 +1030,26 @@ static int
 isLongBranch (unsigned char *instr)
 {
   if (instr[0] == 0xFC || instr[0] == 0xFD ||	/* BRA, BNC, BL, BC */
-      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */
+      instr[0] == 0xFE || instr[0] == 0xFF)	/* 24 bit relative */ {
+    __A_VARIABLE = 1;
     return 4;
+  }
   if ((instr[0] & 0xF0) == 0xB0)	/* 16 bit relative */
     {
       if ((instr[1] & 0xF0) == 0x00 ||	/* BNE, BEQ */
-	  (instr[1] & 0xF0) == 0x10)
+	  (instr[1] & 0xF0) == 0x10) {
+	__A_VARIABLE = 1;
 	return 5;
+      }
       if (instr[0] == 0xB0)	/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ, BEQZ */
 	if ((instr[1] & 0xF0) == 0x80 || (instr[1] & 0xF0) == 0x90 ||
 	    (instr[1] & 0xF0) == 0xA0 || (instr[1] & 0xF0) == 0xB0 ||
-	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0)
+	    (instr[1] & 0xF0) == 0xC0 || (instr[1] & 0xF0) == 0xD0) {
+	  __A_VARIABLE = 1;
 	  return 6;
+	}
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1025,54 +1074,72 @@ willBranch (unsigned char *instr, int branchCode)
   switch (branchCode)
     {
     case 0:
+      __A_VARIABLE = 1;
       return 0;			/* not a branch */
     case 1:
+      __A_VARIABLE = 1;
       return 1;			/* RTE */
     case 2:
+      __A_VARIABLE = 1;
       return 1;			/* JL or JMP    */
     case 3:			/* BC, BNC, BL, BRA (short) */
     case 4:			/* BC, BNC, BL, BRA (long) */
       switch (instr[0] & 0x0F)
 	{
 	case 0xC:		/* Branch if Condition Register */
+	  __A_VARIABLE = 1;
 	  return (registers[CBR] != 0);
 	case 0xD:		/* Branch if NOT Condition Register */
+	  __A_VARIABLE = 1;
 	  return (registers[CBR] == 0);
 	case 0xE:		/* Branch and Link */
 	case 0xF:		/* Branch (unconditional) */
+	  __A_VARIABLE = 1;
 	  return 1;
 	default:		/* oops? */
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
     case 5:			/* BNE, BEQ */
       switch (instr[1] & 0xF0)
 	{
 	case 0x00:		/* Branch if r1 equal to r2 */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[0] & 0x0F] == registers[instr[1] & 0x0F]);
 	case 0x10:		/* Branch if r1 NOT equal to r2 */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[0] & 0x0F] != registers[instr[1] & 0x0F]);
 	default:		/* oops? */
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
     case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ */
       switch (instr[1] & 0xF0)
 	{
 	case 0x80:		/* Branch if reg equal to zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] == 0);
 	case 0x90:		/* Branch if reg NOT equal to zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] != 0);
 	case 0xA0:		/* Branch if reg less than zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] < 0);
 	case 0xB0:		/* Branch if reg greater or equal to zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] >= 0);
 	case 0xC0:		/* Branch if reg less than or equal to zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] <= 0);
 	case 0xD0:		/* Branch if reg greater than zero */
+	  __A_VARIABLE = 1;
 	  return (registers[instr[1] & 0x0F] > 0);
 	default:		/* oops? */
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
     default:			/* oops? */
+      __A_VARIABLE = 1;
       return 0;
     }
 }
@@ -1084,19 +1151,25 @@ branchDestination (unsigned char *instr, int branchCode)
     {
     default:
     case 0:			/* not a branch */
+      __A_VARIABLE = 1;
       return 0;
     case 1:			/* RTE */
+      __A_VARIABLE = 1;
       return registers[BPC] & ~3;	/* pop BPC into PC */
     case 2:			/* JL or JMP */
+      __A_VARIABLE = 1;
       return registers[instr[1] & 0x0F] & ~3;	/* jump thru a register */
     case 3:			/* BC, BNC, BL, BRA (short, 8-bit relative offset) */
+      __A_VARIABLE = 1;
       return (((int) instr) & ~3) + ((char) instr[1] << 2);
     case 4:			/* BC, BNC, BL, BRA (long, 24-bit relative offset) */
+      __A_VARIABLE = 1;
       return ((int) instr +
 	      ((((char) instr[1] << 16) | (instr[2] << 8) | (instr[3])) <<
 	       2));
     case 5:			/* BNE, BEQ (16-bit relative offset) */
     case 6:			/* BNEZ, BLTZ, BLEZ, BGTZ, BGEZ ,BEQZ (ditto) */
+      __A_VARIABLE = 1;
       return ((int) instr + ((((char) instr[2] << 8) | (instr[3])) << 2));
     }
 
@@ -1116,14 +1189,17 @@ branchSideEffects (unsigned char *instr, int branchCode)
   switch (branchCode)
     {
     case 1:			/* RTE */
+      __A_VARIABLE = 1;
       return;			/* I <THINK> this is already handled... */
     case 2:			/* JL (or JMP) */
     case 3:			/* BL (or BC, BNC, BRA) */
     case 4:
       if ((instr[0] & 0x0F) == 0x0E)	/* branch/jump and link */
 	registers[R14] = (registers[PC] & ~3) + 4;
+      __A_VARIABLE = 1;
       return;
     default:			/* any other branch has no side effects */
+      __A_VARIABLE = 1;
       return;
     }
 }
@@ -1335,6 +1411,7 @@ cleanup_stash (void)
     registers[SPU] = registers[R15];
   else
     registers[SPI] = registers[R15];
+  __A_VARIABLE = 1;
 }
 
 asm ("\n\
@@ -1390,6 +1467,7 @@ process_exception (int num)
 	mv r0, %0\n\
 	bl handle_exception\n\
 	bl restore_and_return"::"r" (num):"r0", "r1");
+  __A_VARIABLE = 1;
 }
 
 void _catchException0 ();
@@ -1617,6 +1695,7 @@ set_debug_traps (void)
   /*  exceptionHandler (17, _catchException17); */
 
   initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 /* This function will generate a breakpoint exception.  It is used at the
@@ -1631,6 +1710,7 @@ breakpoint (void)
 {
   if (initialized)
     BREAKPOINT ();
+  __A_VARIABLE = 1;
 }
 
 /* STDOUT section:
@@ -1655,6 +1735,7 @@ gdb_putchar (int ch)
   buf[2] = hexchars[ch & 0x0F];
   buf[3] = 0;
   putpacket (buf);
+  __A_VARIABLE = 1;
   return ch;
 }
 
@@ -1682,6 +1763,7 @@ gdb_write (char *data, int len)
       *cpy = 0;
       putpacket (buf);
     }
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -1692,6 +1774,7 @@ gdb_write (char *data, int len)
 static int
 gdb_puts (char *str)
 {
+  __A_VARIABLE = 1;
   return gdb_write (str, strlen (str));
 }
 
@@ -1743,6 +1826,7 @@ strcpy (unsigned char *dest, const unsigned char *src)
 	*dest++ = *src++;
       *dest = 0;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -1754,6 +1838,7 @@ strlen (const unsigned char *src)
   for (ret = 0; *src; src++)
     ret++;
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/libgloss/m32r/open.c b/libgloss/m32r/open.c
index 6671c29..be0a23c 100644
--- a/libgloss/m32r/open.c
+++ b/libgloss/m32r/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _open (const char *path, int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/libgloss/m32r/raise.c b/libgloss/m32r/raise.c
index b2dc2f6..2f29c7b 100644
--- a/libgloss/m32r/raise.c
+++ b/libgloss/m32r/raise.c
@@ -1,5 +1,7 @@
+static volatile int __A_VARIABLE;
 /* ??? Needed?  */
 
 _raise ()
 {
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/m32r/read.c b/libgloss/m32r/read.c
index 0e32b74..9bbc8ae 100644
--- a/libgloss/m32r/read.c
+++ b/libgloss/m32r/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _read (int file, char *ptr, int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/m32r/sbrk.c b/libgloss/m32r/sbrk.c
index bc82091..44cefef 100644
--- a/libgloss/m32r/sbrk.c
+++ b/libgloss/m32r/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
diff --git a/libgloss/m32r/stat.c b/libgloss/m32r/stat.c
index eb4c8e3..a4ec8c2 100644
--- a/libgloss/m32r/stat.c
+++ b/libgloss/m32r/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -7,5 +8,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/m32r/trapmon0.c b/libgloss/m32r/trapmon0.c
index 20a2fcb..af35237 100644
--- a/libgloss/m32r/trapmon0.c
+++ b/libgloss/m32r/trapmon0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Mon2000 Trap handler (syscall interface).
  *
@@ -47,6 +48,7 @@ int __trap0 (int function, int p1, int p2, int p3, struct _reent *r)
     break;
   }
 
+  __A_VARIABLE = 1;
   return rc;
 }
 
diff --git a/libgloss/m32r/unlink.c b/libgloss/m32r/unlink.c
index 14f741e..90adecc 100644
--- a/libgloss/m32r/unlink.c
+++ b/libgloss/m32r/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/m32r/utime.c b/libgloss/m32r/utime.c
index ea8da2f..6f24700 100644
--- a/libgloss/m32r/utime.c
+++ b/libgloss/m32r/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -8,5 +9,6 @@ _utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/m32r/write.c b/libgloss/m32r/write.c
index 55be40c..cb88ca3 100644
--- a/libgloss/m32r/write.c
+++ b/libgloss/m32r/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include "syscall.h"
@@ -6,5 +7,6 @@
 int
 _write (int file, char *ptr, int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/m68hc11/syscalls.c b/libgloss/m68hc11/syscalls.c
index 9620146..3e1fe95 100644
--- a/libgloss/m68hc11/syscalls.c
+++ b/libgloss/m68hc11/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* pseudo system calls for M68HC11 & M68HC12.
  * Copyright (C) 1999, 2000, 2001, 2002 Stephane Carrez (stcarrez@nerim.fr)	
  *
@@ -32,6 +33,7 @@ read(int file, void *p, size_t nbytes)
       break;
     }
   }
+  __A_VARIABLE = 1;
   return (i);
 }
 
@@ -45,6 +47,7 @@ write(int file, const void *p, size_t len)
     {
       outbyte (*ptr++);
     }
+  __A_VARIABLE = 1;
   return(len);
 }
 
@@ -68,6 +71,7 @@ sbrk(ptrdiff_t incr)
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return ((void*) prev_heap_end);
 }
 
diff --git a/libgloss/m68k/cf-crt1.c b/libgloss/m68k/cf-crt1.c
index 3f37ae9..e4325f8 100644
--- a/libgloss/m68k/cf-crt1.c
+++ b/libgloss/m68k/cf-crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Initialization code for coldfire boards.
  *
  * Copyright (c) 2006 CodeSourcery Inc
@@ -59,6 +60,7 @@ void __start1 (void *heap_limit)
   
   while (1)
     __reset ();
+  __A_VARIABLE = 1;
 }
 
 /* A default hardware init hook.  */
@@ -76,4 +78,5 @@ void __attribute__ ((weak)) hardware_init_hook (void)
 #endif
 
   /* Should we drop into user mode here? */
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/cf-exit.c b/libgloss/m68k/cf-exit.c
index 7d17a9b..8ac9df6 100644
--- a/libgloss/m68k/cf-exit.c
+++ b/libgloss/m68k/cf-exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cf-exit.c -- 
  *
@@ -27,4 +28,5 @@ void __attribute__ ((noreturn)) _exit (int code)
       __asm__ __volatile__ ("halt" ::: "memory");
       __reset ();
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/cf-isrs.c b/libgloss/m68k/cf-isrs.c
index 34dcf2c..9c06973 100644
--- a/libgloss/m68k/cf-isrs.c
+++ b/libgloss/m68k/cf-isrs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cf-isv.c -- 
  *
diff --git a/libgloss/m68k/cf-sbrk.c b/libgloss/m68k/cf-sbrk.c
index 1bcf3f0..5624120 100644
--- a/libgloss/m68k/cf-sbrk.c
+++ b/libgloss/m68k/cf-sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cf-sbrk.c -- 
  *
@@ -43,8 +44,10 @@ sbrk (int nbytes)
   if (nbytes < 0 || (long)(end - new_heap) < 0)
     {
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return (void *)-1;
     }
   heap = new_heap;
+  __A_VARIABLE = 1;
   return base;
 }
diff --git a/libgloss/m68k/fido-_exit.c b/libgloss/m68k/fido-_exit.c
index 08a1542..af38704 100644
--- a/libgloss/m68k/fido-_exit.c
+++ b/libgloss/m68k/fido-_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2006 CodeSourcery, Inc.
  *
@@ -20,4 +21,5 @@ _exit (int code)
 {
   while (1)
     asm volatile ("stop #0x700");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/fido-handler.c b/libgloss/m68k/fido-handler.c
index 838eafe..6123a79 100644
--- a/libgloss/m68k/fido-handler.c
+++ b/libgloss/m68k/fido-handler.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2006 CodeSourcery, Inc.
  *
@@ -21,4 +22,5 @@ HANDLER()
   asm("move.l %sp @(0),%d0\n\t"
       "move.l %sp @(-4),%d1\n\t"
       "sleep");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/fido-sbrk.c b/libgloss/m68k/fido-sbrk.c
index e46d35d..865b703 100644
--- a/libgloss/m68k/fido-sbrk.c
+++ b/libgloss/m68k/fido-sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stddef.h>
 
 extern char _end[];
@@ -8,8 +9,11 @@ void *
 sbrk (ptrdiff_t incr)
 {
   char *oldbrk = curbrk;
-  if (curbrk + incr > &_heapend)
+  if (curbrk + incr > &_heapend) {
+    __A_VARIABLE = 1;
     return (void *) -1;
+  }
   curbrk += incr;
+  __A_VARIABLE = 1;
   return oldbrk;
 }
diff --git a/libgloss/m68k/idp-inbyte.c b/libgloss/m68k/idp-inbyte.c
index 41db57f..ac8bd54 100644
--- a/libgloss/m68k/idp-inbyte.c
+++ b/libgloss/m68k/idp-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* idp-inbyte.c -- 
  * Copyright (c) 1995 Cygnus Support
  *
@@ -37,5 +38,6 @@ _DEFUN_VOID (inbyte)
   while ((READREG (DUART_SRA) & 0x01) == 0x00)
     ;
 
+  __A_VARIABLE = 1;
   return (READREG (DUART_RBA));		/* read the byte */
 }
diff --git a/libgloss/m68k/idp-outbyte.c b/libgloss/m68k/idp-outbyte.c
index a95dc0c..2089a69 100644
--- a/libgloss/m68k/idp-outbyte.c
+++ b/libgloss/m68k/idp-outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* idp-outbyte.c
  * Copyright (c) 1995 Cygnus Support
  *
@@ -45,6 +46,7 @@ _DEFUN (raw_outbyte, (byte),
     ;
 
   WRITEREG (DUART_TBA, byte);		/* write the byte */
+  __A_VARIABLE = 1;
 }
 
 
@@ -71,4 +73,5 @@ _DEFUN (outbyte, (byte),
   raw_outbyte (0x0f);
 #endif
   raw_outbyte (byte);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/io-close.c b/libgloss/m68k/io-close.c
index fb8cde3..51b199c 100644
--- a/libgloss/m68k/io-close.c
+++ b/libgloss/m68k/io-close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-close.c -- 
  *
diff --git a/libgloss/m68k/io-exit.c b/libgloss/m68k/io-exit.c
index 3eee09d..95ccf17 100644
--- a/libgloss/m68k/io-exit.c
+++ b/libgloss/m68k/io-exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-exit.c -- 
  *
@@ -25,5 +26,6 @@ void __attribute__ ((noreturn)) _exit (int code)
 {
   while (1)
     __hosted (HOSTED_EXIT, (void *)code);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/libgloss/m68k/io-fstat.c b/libgloss/m68k/io-fstat.c
index 83f1516..7163412 100644
--- a/libgloss/m68k/io-fstat.c
+++ b/libgloss/m68k/io-fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-fstat.c -- 
  *
diff --git a/libgloss/m68k/io-gdb.c b/libgloss/m68k/io-gdb.c
index 4f16b2f..c4a8750 100644
--- a/libgloss/m68k/io-gdb.c
+++ b/libgloss/m68k/io-gdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * hosted io support for GDB's remote fileio protocol
  *
@@ -45,6 +46,7 @@ __hosted_to_gdb_mode_t (mode_t m)
     result |= GDB_S_IWOTH;
   if (m & S_IXOTH)
     result |= GDB_S_IXOTH;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -66,6 +68,7 @@ __hosted_to_gdb_open_flags (int f)
     result |= GDB_O_TRUNC;
   if (f & O_EXCL)
     result |= GDB_O_EXCL;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -97,6 +100,7 @@ __hosted_from_gdb_stat (const struct gdb_stat *gs,
   s->st_atime = gs->st_atime;
   s->st_mtime = gs->st_mtime;
   s->st_ctime = gs->st_ctime;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -105,6 +109,7 @@ __hosted_from_gdb_timeval (const struct gdb_timeval *gt,
 {
   t->tv_sec = gt->tv_sec;
   t->tv_usec = gt->tv_usec;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -112,28 +117,49 @@ __hosted_from_gdb_errno (int32_t err)
 {
   switch (err)
     {
-    case 0: 		return 0;
-    case GDB_EPERM: 	return EPERM;
-    case GDB_ENOENT: 	return ENOENT;
-    case GDB_EINTR: 	return EINTR;
-    case GDB_EBADF: 	return EBADF;
-    case GDB_EACCES: 	return EACCES;
-    case GDB_EFAULT: 	return EFAULT;
-    case GDB_EBUSY: 	return EBUSY;
-    case GDB_EEXIST: 	return EEXIST;
-    case GDB_ENODEV: 	return ENODEV;
-    case GDB_ENOTDIR: 	return ENOTDIR;
-    case GDB_EISDIR: 	return EISDIR;
-    case GDB_EINVAL: 	return EINVAL;
-    case GDB_ENFILE: 	return ENFILE;
-    case GDB_EMFILE: 	return EMFILE;
-    case GDB_EFBIG: 	return EFBIG;
-    case GDB_ENOSPC: 	return ENOSPC;
-    case GDB_ESPIPE: 	return ESPIPE;
-    case GDB_EROFS: 	return EROFS;
-    case GDB_ENAMETOOLONG: 	return ENAMETOOLONG;
+    case 0: 		__A_VARIABLE = 1;
+      return 0;
+    case GDB_EPERM: 	__A_VARIABLE = 1;
+      return EPERM;
+    case GDB_ENOENT: 	__A_VARIABLE = 1;
+      return ENOENT;
+    case GDB_EINTR: 	__A_VARIABLE = 1;
+      return EINTR;
+    case GDB_EBADF: 	__A_VARIABLE = 1;
+      return EBADF;
+    case GDB_EACCES: 	__A_VARIABLE = 1;
+      return EACCES;
+    case GDB_EFAULT: 	__A_VARIABLE = 1;
+      return EFAULT;
+    case GDB_EBUSY: 	__A_VARIABLE = 1;
+      return EBUSY;
+    case GDB_EEXIST: 	__A_VARIABLE = 1;
+      return EEXIST;
+    case GDB_ENODEV: 	__A_VARIABLE = 1;
+      return ENODEV;
+    case GDB_ENOTDIR: 	__A_VARIABLE = 1;
+      return ENOTDIR;
+    case GDB_EISDIR: 	__A_VARIABLE = 1;
+      return EISDIR;
+    case GDB_EINVAL: 	__A_VARIABLE = 1;
+      return EINVAL;
+    case GDB_ENFILE: 	__A_VARIABLE = 1;
+      return ENFILE;
+    case GDB_EMFILE: 	__A_VARIABLE = 1;
+      return EMFILE;
+    case GDB_EFBIG: 	__A_VARIABLE = 1;
+      return EFBIG;
+    case GDB_ENOSPC: 	__A_VARIABLE = 1;
+      return ENOSPC;
+    case GDB_ESPIPE: 	__A_VARIABLE = 1;
+      return ESPIPE;
+    case GDB_EROFS: 	__A_VARIABLE = 1;
+      return EROFS;
+    case GDB_ENAMETOOLONG: 	__A_VARIABLE = 1;
+      return ENAMETOOLONG;
     case GDB_EUNKNOWN:
     default:
+      __A_VARIABLE = 1;
       return EIO;
     }
 }
diff --git a/libgloss/m68k/io-gettimeofday.c b/libgloss/m68k/io-gettimeofday.c
index ae4aaf6..0e780ae 100644
--- a/libgloss/m68k/io-gettimeofday.c
+++ b/libgloss/m68k/io-gettimeofday.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-gettimeofday.c -- 
  *
diff --git a/libgloss/m68k/io-isatty.c b/libgloss/m68k/io-isatty.c
index 4d9bb7d..1b319e6 100644
--- a/libgloss/m68k/io-isatty.c
+++ b/libgloss/m68k/io-isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-isatty.c -- 
  *
diff --git a/libgloss/m68k/io-lseek.c b/libgloss/m68k/io-lseek.c
index 63ec564..3a404ea 100644
--- a/libgloss/m68k/io-lseek.c
+++ b/libgloss/m68k/io-lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-lseek.c -- 
  *
diff --git a/libgloss/m68k/io-open.c b/libgloss/m68k/io-open.c
index ec45a53..db41467 100644
--- a/libgloss/m68k/io-open.c
+++ b/libgloss/m68k/io-open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-open.c -- 
  *
diff --git a/libgloss/m68k/io-read.c b/libgloss/m68k/io-read.c
index 2cf3555..0ee86c5 100644
--- a/libgloss/m68k/io-read.c
+++ b/libgloss/m68k/io-read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-read.c -- 
  *
diff --git a/libgloss/m68k/io-rename.c b/libgloss/m68k/io-rename.c
index 75e7c87..ece578f 100644
--- a/libgloss/m68k/io-rename.c
+++ b/libgloss/m68k/io-rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-rename.c -- 
  *
diff --git a/libgloss/m68k/io-stat.c b/libgloss/m68k/io-stat.c
index af36b3d..8f0bebb 100644
--- a/libgloss/m68k/io-stat.c
+++ b/libgloss/m68k/io-stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-stat.c -- 
  *
diff --git a/libgloss/m68k/io-system.c b/libgloss/m68k/io-system.c
index 7d35ed2..28576e9 100644
--- a/libgloss/m68k/io-system.c
+++ b/libgloss/m68k/io-system.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-system.c -- 
  *
diff --git a/libgloss/m68k/io-time.c b/libgloss/m68k/io-time.c
index 8c549ad..14951c4 100644
--- a/libgloss/m68k/io-time.c
+++ b/libgloss/m68k/io-time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-time.c -- 
  *
diff --git a/libgloss/m68k/io-unlink.c b/libgloss/m68k/io-unlink.c
index 0e623aa..f00f0da 100644
--- a/libgloss/m68k/io-unlink.c
+++ b/libgloss/m68k/io-unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-unlink.c -- 
  *
diff --git a/libgloss/m68k/io-write.c b/libgloss/m68k/io-write.c
index bf4b776..86a521b 100644
--- a/libgloss/m68k/io-write.c
+++ b/libgloss/m68k/io-write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * io-write.c -- 
  *
diff --git a/libgloss/m68k/leds.c b/libgloss/m68k/leds.c
index b911237..a0fcbea 100644
--- a/libgloss/m68k/leds.c
+++ b/libgloss/m68k/leds.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * leds.c -- control the led's on a Motorola mc68ec0x0 board.
  *
@@ -75,4 +76,5 @@ zylons()
       curled = (curled >> 1) | (curled << 7);
       delay ( 200 );
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/mc68ec.c b/libgloss/m68k/mc68ec.c
index d5ee9b5..504061b 100644
--- a/libgloss/m68k/mc68ec.c
+++ b/libgloss/m68k/mc68ec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* mc68ec.c -- Low level support for the Motorola mc68ec0x0 board.
  *             Written by rob@cygnus.com (Rob Savoye)
  *
@@ -31,6 +32,7 @@ _DEFUN (_exit, (status),
   /* Use `i' constraint to get proper immediate-operand syntax for
      target assembler configuration.  */
   asm ("trap %0" : : "i" (0));	/* seems to be a harmless vector number */
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -45,4 +47,5 @@ _DEFUN (delay, (num),
     {
       asm ("nop");
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/mvme-stub.c b/libgloss/m68k/mvme-stub.c
index fbc4c61..c796e7c 100644
--- a/libgloss/m68k/mvme-stub.c
+++ b/libgloss/m68k/mvme-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 unsigned long sp_ptr;
 unsigned long pc_ptr;
 int cnt;
@@ -241,14 +242,25 @@ void _returnFromException( Frame *frame )
     { /* return to user mode */
         return_to_user();
     }
+    __A_VARIABLE = 1;
 }
 
 int hex(ch)
 char ch;
 {
-  if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
-  if ((ch >= '0') && (ch <= '9')) return (ch-'0');
-  if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
+  if ((ch >= 'a') && (ch <= 'f')) {
+    __A_VARIABLE = 1;
+    return (ch-'a'+10);
+  }
+  if ((ch >= '0') && (ch <= '9')) {
+    __A_VARIABLE = 1;
+    return (ch-'0');
+  }
+  if ((ch >= 'A') && (ch <= 'F')) {
+    __A_VARIABLE = 1;
+    return (ch-'A'+10);
+  }
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -313,6 +325,7 @@ char * buffer;
     } 
   } while (checksum != xmitcsum);
   
+  __A_VARIABLE = 1;
 }
 
 /* send the packet in buffer.  The host get's one chance to read it.  
@@ -332,7 +345,10 @@ char * buffer;
   count    = 0;
   
   while (ch=buffer[count]) {
-    if (! putDebugChar(ch)) return;
+    if (! putDebugChar(ch)) {
+      __A_VARIABLE = 1;
+      return;
+    }
     checksum += ch;
     count += 1;
   }
@@ -353,6 +369,7 @@ char * buffer;
 /*** } while (getDebugChar() != '+'); ***/
 /** } while (1 == 0);  (getDebugChar() != '+'); **/
 
+  __A_VARIABLE = 1;
 }
 
 char  remcomInBuffer[BUFMAX];
@@ -365,6 +382,7 @@ char * format;
 char * parm;
 {
   if (remote_debug) fprintf(stderr,format,parm);
+  __A_VARIABLE = 1;
 }
 
 /* convert the memory pointed to by mem into hex, placing result in buf */
@@ -382,6 +400,7 @@ int   count;
           *buf++ = hexchars[ch % 16];
       }
       *buf = 0; 
+      __A_VARIABLE = 1;
       return(buf);
 }
 
@@ -399,6 +418,7 @@ int   count;
           ch = ch + hex(*buf++);
           *mem++ = ch;
       }
+      __A_VARIABLE = 1;
       return(mem);
 }
 
@@ -408,6 +428,7 @@ int   count;
 void handle_buserror()
 {
   longjmp(remcomEnv,1);
+  __A_VARIABLE = 1;
 }
 
 /* this function takes the 68000 exception number and attempts to 
@@ -441,6 +462,7 @@ int exceptionVector;
     default: 
       sigval = 7;         /* "software generated"*/
   }
+  __A_VARIABLE = 1;
   return (sigval);
 }
 
@@ -469,6 +491,7 @@ int hexToInt(char **ptr, int *intValue)
         (*ptr)++;
     }
 
+    __A_VARIABLE = 1;
     return (numChars);
 }
 
@@ -692,6 +715,7 @@ void handle_exception(int exceptionVector)
     /* reply to the request */
     putpacket(remcomOutBuffer); 
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -699,6 +723,7 @@ void initializeRemcomErrorFrame()
 {
     lastFrame = ((Frame *) &gdbFrameStack[FRAMESIZE-1]) - 1;
     lastFrame->previous = lastFrame;
+    __A_VARIABLE = 1;
 }
 
 /* this function is used to set up exception handlers for tracing and 
@@ -722,6 +747,7 @@ int exception;
   
   initialized = 1;
 
+  __A_VARIABLE = 1;
 }
 /* This function will generate a breakpoint exception.  It is used at the
    beginning of a program to sync up with a debugger and can be used
@@ -731,4 +757,5 @@ int exception;
 void breakpoint()
 {
   if (initialized) BREAKPOINT();
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/sim-abort.c b/libgloss/m68k/sim-abort.c
index 4960de8..4e2a0c6 100644
--- a/libgloss/m68k/sim-abort.c
+++ b/libgloss/m68k/sim-abort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-abort.c -- m68k abort support when running under the simulator.
  *
@@ -18,4 +19,5 @@ void abort(void)
 {
   write (2, "Abort called.\n", sizeof("Abort called.\n")-1);
   exit (1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/sim-errno.c b/libgloss/m68k/sim-errno.c
index de5f914..7eff784 100644
--- a/libgloss/m68k/sim-errno.c
+++ b/libgloss/m68k/sim-errno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-errno.c -- return address of errno for current thread.
  *
@@ -24,5 +25,6 @@ _cerror (e)
      int e;
 {
   *__errno() = e;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/m68k/sim-funcs.c b/libgloss/m68k/sim-funcs.c
index 712c566..71ef0d6 100644
--- a/libgloss/m68k/sim-funcs.c
+++ b/libgloss/m68k/sim-funcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-funcs.c - random needed simulator functions
  *
  * Copyright (c) 2001 Cygnus Support
@@ -20,11 +21,13 @@ int
 kill(int pid, int sig)
 {
   exit(0xdead);
+  __A_VARIABLE = 1;
 }
 
 pid_t
 getpid()
 {
+  __A_VARIABLE = 1;
   return 42;
 }
 
diff --git a/libgloss/m68k/sim-inbyte.c b/libgloss/m68k/sim-inbyte.c
index 3fa3f24..21b57a2 100644
--- a/libgloss/m68k/sim-inbyte.c
+++ b/libgloss/m68k/sim-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-inbyte.c -- read a character from standard input.
  *
@@ -19,8 +20,11 @@ inbyte ()
 {
   char c;
 
-  if (read (0, &c, 1) <= 0)
+  if (read (0, &c, 1) <= 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return c;
 }
diff --git a/libgloss/m68k/sim-print.c b/libgloss/m68k/sim-print.c
index 18ca022..8ba4476 100644
--- a/libgloss/m68k/sim-print.c
+++ b/libgloss/m68k/sim-print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-print.c -- print a string on the output device.
  *
  * Copyright (c) 1995, 2001 Cygnus Support
@@ -27,6 +28,7 @@ print (ptr)
     p++;
 
   write (1, ptr, p-ptr);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -40,4 +42,5 @@ outbyte (c_int)
   char c = c_int;
 
   write (1, &c, 1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/m68k/sim-sbrk.c b/libgloss/m68k/sim-sbrk.c
index 83e5287..5dfba6d 100644
--- a/libgloss/m68k/sim-sbrk.c
+++ b/libgloss/m68k/sim-sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-sbrk.c -- m68k sbrk support when running under the simulator.
  *
@@ -23,8 +24,11 @@ sbrk (incr)
 {
   char *oldbrk = curbrk;
   curbrk += incr;
-  if (brk (curbrk) == -1)
+  if (brk (curbrk) == -1) {
+    __A_VARIABLE = 1;
     return (char *) -1;
+  }
 
+  __A_VARIABLE = 1;
   return oldbrk;
 }
diff --git a/libgloss/m68k/test.c b/libgloss/m68k/test.c
index d84045d..737037f 100644
--- a/libgloss/m68k/test.c
+++ b/libgloss/m68k/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int led_putnum();
 extern char print(),putnum();
 
@@ -23,4 +24,5 @@ main()
   /* whew, we made it */
   print ("\r\nDone...\r\n");
   fflush(stdout);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mcore/close.c b/libgloss/mcore/close.c
index b94cb60..24e87aa 100644
--- a/libgloss/mcore/close.c
+++ b/libgloss/mcore/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close.c -- close a file descriptor.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (_close ,(fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/mcore/cmb-exit.c b/libgloss/mcore/cmb-exit.c
index 0e1de85..40eef74 100644
--- a/libgloss/mcore/cmb-exit.c
+++ b/libgloss/mcore/cmb-exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cmb-exit.c -- exit trap binding.
  *
  * Copyright (c) 1999 Cygnus Support
@@ -24,4 +25,5 @@ _DEFUN (_exit, (val),
     while (1) {
 	asm("bkpt");
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/mcore/cmb-inbyte.c b/libgloss/mcore/cmb-inbyte.c
index 0b0b8f5..54c70a6 100644
--- a/libgloss/mcore/cmb-inbyte.c
+++ b/libgloss/mcore/cmb-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cmb-inbyte.c -- inbyte function for CMB1200 eval board.
  *
  * Copyright (c) 1999 Cygnus Support
@@ -19,6 +20,7 @@ _DEFUN (inbyte, (),
 	_NOARGS)
 
 {
+    __A_VARIABLE = 1;
     return -1;
 }
 
diff --git a/libgloss/mcore/cmb-outbyte.c b/libgloss/mcore/cmb-outbyte.c
index ea2aaef..97f42ba 100644
--- a/libgloss/mcore/cmb-outbyte.c
+++ b/libgloss/mcore/cmb-outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cmb-outbyte.c -- outbyte function for CMB1200 eval board.
  *
  * Copyright (c) 1999 Cygnus Support
@@ -43,4 +44,5 @@ _DEFUN (outbyte, (ch),
     while (!(*SRREG & TRDY))
 	;
     *TXREG = (unsigned short)ch;
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/mcore/fstat.c b/libgloss/mcore/fstat.c
index 0205464..fbb0b28 100644
--- a/libgloss/mcore/fstat.c
+++ b/libgloss/mcore/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/mcore/getpid.c b/libgloss/mcore/getpid.c
index eee2ac0..f3cb176 100644
--- a/libgloss/mcore/getpid.c
+++ b/libgloss/mcore/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/mcore/kill.c b/libgloss/mcore/kill.c
index 43a3597..82baa0f 100644
--- a/libgloss/mcore/kill.c
+++ b/libgloss/mcore/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mcore/lseek.c b/libgloss/mcore/lseek.c
index 0f236fe..fae50cd 100644
--- a/libgloss/mcore/lseek.c
+++ b/libgloss/mcore/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek.c -- move read/write pointer.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -26,6 +27,7 @@ _DEFUN (_lseek, (fd,  offset, whence),
        int whence)
 {
   errno = ESPIPE;
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
 
diff --git a/libgloss/mcore/open.c b/libgloss/mcore/open.c
index a9e9959..7a22259 100644
--- a/libgloss/mcore/open.c
+++ b/libgloss/mcore/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open.c -- open a file.
  * 
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (_open, (buf, flags, mode),
        int mode)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
diff --git a/libgloss/mcore/print.c b/libgloss/mcore/print.c
index d0d2bce..91233c9 100644
--- a/libgloss/mcore/print.c
+++ b/libgloss/mcore/print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* print.c -- print a string on the output device.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -24,4 +25,5 @@ char *ptr)
   while (*ptr) {
     outbyte (*ptr++);
   }
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mcore/putnum.c b/libgloss/mcore/putnum.c
index 2e37c09..7663d3a 100644
--- a/libgloss/mcore/putnum.c
+++ b/libgloss/mcore/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -38,4 +39,5 @@ _DEFUN (_putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mcore/raise.c b/libgloss/mcore/raise.c
index 6657aa6..3b0905f 100644
--- a/libgloss/mcore/raise.c
+++ b/libgloss/mcore/raise.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* raise.c -- raise a signal for current process.
  *
  * Copyright (c) 1999 Cygnus Support
@@ -18,5 +19,6 @@ int
 _DEFUN (_raise, (sig),
 	int sig)
 {
+  __A_VARIABLE = 1;
   return _kill (_getpid (), sig);
 }
diff --git a/libgloss/mcore/read.c b/libgloss/mcore/read.c
index 499426d..1b3af08 100644
--- a/libgloss/mcore/read.c
+++ b/libgloss/mcore/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read.c -- read bytes from a input device.
  * 
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -35,5 +36,6 @@ _DEFUN (_read, (fd, buf, nbytes),
       break;
     }
   }
+  __A_VARIABLE = 1;
   return (i);
 }
diff --git a/libgloss/mcore/sbrk.c b/libgloss/mcore/sbrk.c
index 8449589..35b0281 100644
--- a/libgloss/mcore/sbrk.c
+++ b/libgloss/mcore/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate memory dynamically.
  * 
  * Copyright (c) 1995,1996,1999 Cygnus Support
@@ -38,5 +39,6 @@ _sbrk (size_t incr)
 #endif
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/mcore/stat.c b/libgloss/mcore/stat.c
index 401a6b5..f5e55e6 100644
--- a/libgloss/mcore/stat.c
+++ b/libgloss/mcore/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/mcore/unlink.c b/libgloss/mcore/unlink.c
index 16dda14..69f0f96 100644
--- a/libgloss/mcore/unlink.c
+++ b/libgloss/mcore/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink.c -- remove a file.
  * 
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (_unlink, (path),
         char * path)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
diff --git a/libgloss/mcore/write.c b/libgloss/mcore/write.c
index 7f39fd1..3e89200 100644
--- a/libgloss/mcore/write.c
+++ b/libgloss/mcore/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write.c -- write bytes to an output device.
  *
  * Copyright (c) 1995, 1999 Cygnus Support
@@ -35,5 +36,6 @@ _DEFUN (_write, (fd, buf, nbytes),
     }
     outbyte (*(buf + i));
   }
+  __A_VARIABLE = 1;
   return (nbytes);
 }
diff --git a/libgloss/mep/h_reset.c b/libgloss/mep/h_reset.c
index ced85b0..99f7a31 100644
--- a/libgloss/mep/h_reset.c
+++ b/libgloss/mep/h_reset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* h_reset.c -- Setup default reset handler.
  * 
  * Copyright (c) 2004  Red Hat, Inc. All rights reserved.
diff --git a/libgloss/mep/handlers.c b/libgloss/mep/handlers.c
index 292a428..4f21c77 100644
--- a/libgloss/mep/handlers.c
+++ b/libgloss/mep/handlers.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* handlers.c -- Setup default handlers.
  * 
  * Copyright (c) 2004  Red Hat, Inc. All rights reserved.
@@ -18,6 +19,7 @@
 void __interrupt
 _handler_NMI ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_RI
@@ -25,6 +27,7 @@ _handler_NMI ()
 void __interrupt
 _handler_RI ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_ZDIV
@@ -32,6 +35,7 @@ _handler_RI ()
 void __interrupt
 _handler_ZDIV ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_BRK
@@ -39,6 +43,7 @@ _handler_ZDIV ()
 void __interrupt
 _handler_BRK ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_SWI
@@ -46,6 +51,7 @@ _handler_BRK ()
 void __interrupt
 _handler_SWI ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_DEBUG
@@ -53,6 +59,7 @@ _handler_SWI ()
 void __interrupt
 _handler_DEBUG ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_DSP
@@ -60,6 +67,7 @@ _handler_DEBUG ()
 void __interrupt
 _handler_DSP ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_COP
@@ -67,6 +75,7 @@ _handler_DSP ()
 void __interrupt
 _handler_COP ()
 {
+	__A_VARIABLE = 1;
 }
 
 /* hardware interrupt */
@@ -77,6 +86,7 @@ _handler_COP ()
 void __interrupt
 _handler_INT0 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT1
@@ -84,6 +94,7 @@ _handler_INT0 ()
 void __interrupt
 _handler_INT1 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT2
@@ -91,6 +102,7 @@ _handler_INT1 ()
 void __interrupt
 _handler_INT2 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT3
@@ -98,6 +110,7 @@ _handler_INT2 ()
 void __interrupt
 _handler_INT3 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT4
@@ -105,6 +118,7 @@ _handler_INT3 ()
 void __interrupt
 _handler_INT4 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT5
@@ -112,6 +126,7 @@ _handler_INT4 ()
 void __interrupt
 _handler_INT5 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT6
@@ -119,6 +134,7 @@ _handler_INT5 ()
 void __interrupt
 _handler_INT6 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT7
@@ -126,6 +142,7 @@ _handler_INT6 ()
 void __interrupt
 _handler_INT7 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT8
@@ -133,6 +150,7 @@ _handler_INT7 ()
 void __interrupt
 _handler_INT8 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT9
@@ -140,6 +158,7 @@ _handler_INT8 ()
 void __interrupt
 _handler_INT9 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT10
@@ -147,6 +166,7 @@ _handler_INT9 ()
 void __interrupt
 _handler_INT10 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT11
@@ -154,6 +174,7 @@ _handler_INT10 ()
 void __interrupt
 _handler_INT11 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT12
@@ -161,6 +182,7 @@ _handler_INT11 ()
 void __interrupt
 _handler_INT12 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT13
@@ -168,6 +190,7 @@ _handler_INT12 ()
 void __interrupt
 _handler_INT13 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT14
@@ -175,6 +198,7 @@ _handler_INT13 ()
 void __interrupt
 _handler_INT14 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT15
@@ -182,6 +206,7 @@ _handler_INT14 ()
 void __interrupt
 _handler_INT15 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT16
@@ -189,6 +214,7 @@ _handler_INT15 ()
 void __interrupt
 _handler_INT16 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT17
@@ -196,6 +222,7 @@ _handler_INT16 ()
 void __interrupt
 _handler_INT17 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT18
@@ -203,6 +230,7 @@ _handler_INT17 ()
 void __interrupt
 _handler_INT18 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT19
@@ -210,6 +238,7 @@ _handler_INT18 ()
 void __interrupt
 _handler_INT19 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT20
@@ -217,6 +246,7 @@ _handler_INT19 ()
 void __interrupt
 _handler_INT20 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT21
@@ -224,6 +254,7 @@ _handler_INT20 ()
 void __interrupt
 _handler_INT21 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT22
@@ -231,6 +262,7 @@ _handler_INT21 ()
 void __interrupt
 _handler_INT22 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT23
@@ -238,6 +270,7 @@ _handler_INT22 ()
 void __interrupt
 _handler_INT23 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT24
@@ -245,6 +278,7 @@ _handler_INT23 ()
 void __interrupt
 _handler_INT24 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT25
@@ -252,6 +286,7 @@ _handler_INT24 ()
 void __interrupt
 _handler_INT25 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT26
@@ -259,6 +294,7 @@ _handler_INT25 ()
 void __interrupt
 _handler_INT26 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT27
@@ -266,6 +302,7 @@ _handler_INT26 ()
 void __interrupt
 _handler_INT27 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT28
@@ -273,6 +310,7 @@ _handler_INT27 ()
 void __interrupt
 _handler_INT28 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT29
@@ -280,6 +318,7 @@ _handler_INT28 ()
 void __interrupt
 _handler_INT29 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT30
@@ -287,6 +326,7 @@ _handler_INT29 ()
 void __interrupt
 _handler_INT30 ()
 {
+	__A_VARIABLE = 1;
 }
 
 #pragma weak _handler_INT31
@@ -294,4 +334,5 @@ _handler_INT30 ()
 void __interrupt
 _handler_INT31 ()
 {
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/mep/isatty.c b/libgloss/mep/isatty.c
index f01e3a2..b779586 100644
--- a/libgloss/mep/isatty.c
+++ b/libgloss/mep/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2004  Red Hat, Inc. All rights reserved.
  *
diff --git a/libgloss/mep/mep-bb.c b/libgloss/mep/mep-bb.c
index 191da16..754cbfc 100644
--- a/libgloss/mep/mep-bb.c
+++ b/libgloss/mep/mep-bb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2000-2001  Red Hat, Inc. All rights reserved.
  *
@@ -71,8 +72,10 @@ __bb_exit_func (void)
   long time_value;
   int i;
 
-  if (bb_head == 0)
+  if (bb_head == 0) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   i = strlen (bb_head->filename) - 3;
 
@@ -196,6 +199,7 @@ __bb_exit_func (void)
 		     ptr->filename);
 	}
 
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -314,6 +318,7 @@ __bb_exit_func (void)
       fprintf (file, "\n\n");
       fclose (file);
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -322,8 +327,10 @@ __bb_init_func (struct bb *blocks)
   /* User is supposed to check whether the first word is non-0,
      but just in case....  */
 
-  if (blocks->zero_word)
+  if (blocks->zero_word) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Initialize destructor.  */
   if (!bb_head)
@@ -333,6 +340,7 @@ __bb_init_func (struct bb *blocks)
   blocks->zero_word = 1;
   blocks->next = bb_head;
   bb_head = blocks;
+  __A_VARIABLE = 1;
 }
 
 /* Called before fork or exec - write out profile information gathered so
@@ -350,6 +358,7 @@ __bb_fork_func (void)
       for (i = ptr->ncounts - 1; i >= 0; i--)
 	ptr->counts[i] = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 #ifndef MACHINE_STATE_SAVE
@@ -493,11 +502,15 @@ gclose (FILE *f)
 
   if (f != 0)
     {
-      if (!fstat (fileno (f), &buf) && S_ISFIFO (buf.st_mode))
+      if (!fstat (fileno (f), &buf) && S_ISFIFO (buf.st_mode)) {
+        __A_VARIABLE = 1;
         return pclose (f);
+      }
 
+      __A_VARIABLE = 1;
       return fclose (f);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -713,8 +726,10 @@ __bb_init_prg (void)
   /* Initialize destructor.  */
   atexit (__bb_exit_func);
 
-  if (!(file = fopen ("bb.in", "r")))
+  if (!(file = fopen ("bb.in", "r"))) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   while(fgets (buf, BBINBUFSIZE, file) != 0)
     {
@@ -806,6 +821,7 @@ __bb_init_prg (void)
 
   /* Initialize destructor.  */
   atexit (__bb_exit_trace_func);
+  __A_VARIABLE = 1;
 }
 
 /* Called upon entering a basic block.  */
@@ -879,6 +895,7 @@ skip:
 
   MACHINE_STATE_RESTORE("1")
 
+        __A_VARIABLE = 1;
 }
 
 /* Called when returning from a function and `__bb_showret__' is set.  */
@@ -940,6 +957,7 @@ ret:
 skip:
   ;
 
+  __A_VARIABLE = 1;
 }
 
 /* Called upon entering the first function of a file.  */
@@ -959,8 +977,10 @@ __bb_init_file (struct bb *blocks)
 
   blocks->flags = 0;
   if (!bb_func_head
-      || !(blocks->flags = (char *) malloc (sizeof (char) * blocks->ncounts)))
+      || !(blocks->flags = (char *) malloc (sizeof (char) * blocks->ncounts))) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   for (blk = 0; blk < ncounts; blk++)
     blocks->flags[blk] = 0;
@@ -977,6 +997,7 @@ __bb_init_file (struct bb *blocks)
         }
     }
 
+    __A_VARIABLE = 1;
 }
 
 /* Called when exiting from a function.  */
@@ -1001,6 +1022,7 @@ __bb_trace_ret (void)
 
   MACHINE_STATE_RESTORE("2")
 
+    __A_VARIABLE = 1;
 }
 
 /* Called when entering a function.  */
@@ -1067,5 +1089,6 @@ stack_overflow:;
     }
 
   MACHINE_STATE_RESTORE("3")
+      __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/mep/mep-gmon.c b/libgloss/mep/mep-gmon.c
index 72d6369..066cfa0 100644
--- a/libgloss/mep/mep-gmon.c
+++ b/libgloss/mep/mep-gmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1991, 1998, 2001 The Regents of the University of California.
  * All rights reserved.
@@ -161,6 +162,7 @@ moncleanup ()
   if (fd < 0)
     {
       perror ("mcount: gmon.out");
+      __A_VARIABLE = 1;
       return;
     }
 #ifdef DEBUG
@@ -190,6 +192,7 @@ moncleanup ()
 	}
     }
   close (fd);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -219,6 +222,7 @@ monstartup (lowpc, highpc)
   if (buffer == (char *) -1)
     {
       write (2, MSG, sizeof (MSG));
+      __A_VARIABLE = 1;
       return;
     }
   froms = (unsigned short *) sbrk (s_textsize / HASHFRACTION);
@@ -226,6 +230,7 @@ monstartup (lowpc, highpc)
     {
       write (2, MSG, sizeof (MSG));
       froms = 0;
+      __A_VARIABLE = 1;
       return;
     }
   tolimit = s_textsize * ARCDENSITY / 100;
@@ -243,6 +248,7 @@ monstartup (lowpc, highpc)
       write (2, MSG, sizeof (MSG));
       froms = 0;
       tos = 0;
+      __A_VARIABLE = 1;
       return;
     }
   tos[0].link = 0;
@@ -252,8 +258,10 @@ monstartup (lowpc, highpc)
   ((struct phdr *) buffer)->hpc = highpc;
   ((struct phdr *) buffer)->ncnt = ssiz;
   monsize -= sizeof (struct phdr);
-  if (monsize <= 0)
+  if (monsize <= 0) {
+    __A_VARIABLE = 1;
     return;
+  }
   o = highpc - lowpc;
   if (monsize < o)
 #if 0
@@ -275,6 +283,7 @@ monstartup (lowpc, highpc)
   else
     s_scale = SCALE_1_TO_1;
   profiling = 0;
+  __A_VARIABLE = 1;
 }
 
 /* These happen to be in the right place because of how crt0 works */
@@ -398,6 +407,7 @@ done:
   profiling--;
   /* and fall through */
 out:
+  __A_VARIABLE = 1;
   return;			/* normal return restores saved registers */
 
 overflow:
diff --git a/libgloss/mep/read.c b/libgloss/mep/read.c
index 3cf5f7b..af4ab66 100644
--- a/libgloss/mep/read.c
+++ b/libgloss/mep/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read.c -- read characters from file, with hook.
  * 
  * Copyright (c) 2003  Red Hat, Inc. All rights reserved.
@@ -30,7 +31,9 @@ read(int fd, unsigned char *buf, int count)
 	    break;
 	  c ++;
 	}
+      __A_VARIABLE = 1;
       return c;
     }
+  __A_VARIABLE = 1;
   return __mep_read(fd, buf, count);
 }
diff --git a/libgloss/mep/sbrk.c b/libgloss/mep/sbrk.c
index 9ec8676..6742a5f 100644
--- a/libgloss/mep/sbrk.c
+++ b/libgloss/mep/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003  Red Hat, Inc. All rights reserved.
  *
@@ -22,6 +23,7 @@ static char *the_break = (char *)(& __heap);
 int
 is_addr_0 (int address)
 {
+  __A_VARIABLE = 1;
   return address ? 0 : 1;
 }
 
@@ -55,5 +57,6 @@ int
 brk (void *ptr)
 {
   the_break = ptr;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mep/write.c b/libgloss/mep/write.c
index cb06719..c5c73f4 100644
--- a/libgloss/mep/write.c
+++ b/libgloss/mep/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write.c -- write characters to file, with hook.
  * 
  * Copyright (c) 2003  Red Hat, Inc. All rights reserved.
@@ -27,7 +28,9 @@ write(int fd, unsigned char *buf, int count)
 	  c --;
 	  _ioOut(*buf++);
 	}
+      __A_VARIABLE = 1;
       return count;
     }
+  __A_VARIABLE = 1;
   return __mep_write(fd, buf, count);
 }
diff --git a/libgloss/microblaze/linux-inbyte.c b/libgloss/microblaze/linux-inbyte.c
index 58fdf19..e849629 100644
--- a/libgloss/microblaze/linux-inbyte.c
+++ b/libgloss/microblaze/linux-inbyte.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 int inbyte(void)
 {
 	char ch = 0;
 	read(0, &ch, 1);
+	__A_VARIABLE = 1;
 	return ch;
 }
diff --git a/libgloss/microblaze/linux-outbyte.c b/libgloss/microblaze/linux-outbyte.c
index 9d7bc48..17310b4 100644
--- a/libgloss/microblaze/linux-outbyte.c
+++ b/libgloss/microblaze/linux-outbyte.c
@@ -1,4 +1,6 @@
+static volatile int __A_VARIABLE;
 void outbyte (unsigned char c)
 {
 	_write(1, &c, 1);
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/microblaze/linux-syscalls-wrap.c b/libgloss/microblaze/linux-syscalls-wrap.c
index bccb016..e03141e 100644
--- a/libgloss/microblaze/linux-syscalls-wrap.c
+++ b/libgloss/microblaze/linux-syscalls-wrap.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
 int isatty (int fd) {
+	__A_VARIABLE = 1;
 	return 1;
 }
diff --git a/libgloss/microblaze/sbrk.c b/libgloss/microblaze/sbrk.c
index 1a506db..4ebdab1 100644
--- a/libgloss/microblaze/sbrk.c
+++ b/libgloss/microblaze/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2004, 2009 Xilinx, Inc.  All rights reserved. 
    
    Redistribution and use in source and binary forms, with or without
diff --git a/libgloss/microblaze/timer.c b/libgloss/microblaze/timer.c
index 5a204b1..e4bcf01 100644
--- a/libgloss/microblaze/timer.c
+++ b/libgloss/microblaze/timer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2001, 2009 Xilinx, Inc.  All rights reserved. 
    
    Redistribution and use in source and binary forms, with or without
@@ -36,5 +37,6 @@
 
 long	time(long *p)
 {
+       __A_VARIABLE = 1;
        return 0L;
 }
diff --git a/libgloss/microblaze/xil_malloc.c b/libgloss/microblaze/xil_malloc.c
index dac31ea..58d6b2a 100644
--- a/libgloss/microblaze/xil_malloc.c
+++ b/libgloss/microblaze/xil_malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995, 2002, 2009 Xilinx, Inc.  All rights reserved. 
    
    Redistribution and use in source and binary forms, with or without
@@ -86,32 +87,45 @@ typedef struct M_HEADER* M_HEADERP;
 
 BOOLEAN isalloced(M_HEADERP this)      
 { 
+  __A_VARIABLE = 1;
   return this->flag == M_ALLOCEDFLAG; 
 }
 BOOLEAN isfree(M_HEADERP this)         
 { 
+  __A_VARIABLE = 1;
   return this->flag == M_FREEFLAG; 
 }
 BOOLEAN iszero(M_HEADERP this)         
 { 
+  __A_VARIABLE = 1;
   return this->flag == M_ZEROFLAG; 
 }
 
-void           setalloced(M_HEADERP this)     { this->flag = M_ALLOCEDFLAG; }
-void           setfree(M_HEADERP this)        { this->flag = M_FREEFLAG; }
-void           setzero(M_HEADERP this)        { this->flag = M_ZEROFLAG; }
+void           setalloced(M_HEADERP this)     { this->flag = M_ALLOCEDFLAG; __A_VARIABLE = 1;
+}
+void           setfree(M_HEADERP this)        { this->flag = M_FREEFLAG; __A_VARIABLE = 1;
+}
+void           setzero(M_HEADERP this)        { this->flag = M_ZEROFLAG; __A_VARIABLE = 1;
+}
 
-int            getdbglev(M_HEADERP this)      { return this->dbglev; }
-void           setdbglev(M_HEADERP this, int d) { this->dbglev = d; }
+int            getdbglev(M_HEADERP this)      { __A_VARIABLE = 1;
+	return this->dbglev; }
+void           setdbglev(M_HEADERP this, int d) { this->dbglev = d; __A_VARIABLE = 1;
+}
 
-size_t         getsize(M_HEADERP this)        { return this->size << 3; }  /* Alignment is 8. */
-void           setsize(M_HEADERP this, size_t s){ this->size = s >> 3; }     
+size_t         getsize(M_HEADERP this)        { __A_VARIABLE = 1;
+	return this->size << 3; }  /* Alignment is 8. */
+void           setsize(M_HEADERP this, size_t s){ this->size = s >> 3; __A_VARIABLE = 1;
+}     
 
-DATA_T *       getend(M_HEADERP this)         { return (((DATA_T *)this)+getsize(this)); }
+DATA_T *       getend(M_HEADERP this)         { __A_VARIABLE = 1;
+	return (((DATA_T *)this)+getsize(this)); }
 
 /* Next pointer is after data in block. */
-M_HEADERP     getnext(M_HEADERP this)        { return *(((M_HEADERP*)getend(this)) - 1); }
-void           setnext(M_HEADERP this, M_HEADERP n) { *(((M_HEADERP*)getend(this)) - 1) = n; }
+M_HEADERP     getnext(M_HEADERP this)        { __A_VARIABLE = 1;
+	return *(((M_HEADERP*)getend(this)) - 1); }
+void           setnext(M_HEADERP this, M_HEADERP n) { *(((M_HEADERP*)getend(this)) - 1) = n; __A_VARIABLE = 1;
+}
 
 /* Routines used to set a flag at end of block if debuglevel != normal. */
 /* Sentinel is right BEFORE the next pointer. */
@@ -120,7 +134,8 @@ void           setsentinel(M_HEADERP this, unsigned long lflag);
 BOOLEAN        testsentinel(M_HEADERP this, unsigned long lflag);
 
 /* Routines to handle data.  Depend on debug level. */
-DATA_T *       getdata(M_HEADERP this)        { return (((DATA_T*)this)+sizeof(*this)); }
+DATA_T *       getdata(M_HEADERP this)        { __A_VARIABLE = 1;
+	return (((DATA_T*)this)+sizeof(*this)); }
 size_t         getdatasize(M_HEADERP this);
 
 /* Fill data with a pattern. */
@@ -153,6 +168,7 @@ getdatasize(M_HEADERP this)
       if (isfree(this))
         tmp_size -= sizeof(M_HEADERP);
     }
+  __A_VARIABLE = 1;
   return tmp_size;
 }
 
@@ -161,6 +177,7 @@ void
 setdata(M_HEADERP this, int f)
 { 
   memset(getdata(this), f, getdatasize(this));
+  __A_VARIABLE = 1;
 }
 
 /* At the end of the block, there may be a longword with
@@ -182,6 +199,7 @@ setsentinel(M_HEADERP this, unsigned long lflag)
   unsigned long* addr = getsentinel(this);
   if (addr)
     *addr = lflag;
+  __A_VARIABLE = 1;
 }
 
 BOOLEAN 
@@ -236,6 +254,7 @@ getmemblock(size_t n)
   if (block != NULL)
     totalallocated += n;
 
+  __A_VARIABLE = 1;
   return block;
 }
 
@@ -252,12 +271,14 @@ die (char* msg)
   for (;;)
     ;
 #endif
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
 int 
 getfreeindex(size_t size)
 {
+  __A_VARIABLE = 1;
   return MIN(size / M_BLOCKSIZE, M_FREESIZE - 1);
 }
 
@@ -301,19 +322,25 @@ void coalesce(M_HEADERP h)
           setsentinel(h, M_ALLOCED);
         }
     } /* forever */
+    __A_VARIABLE = 1;
 }
 
 BOOLEAN 
 checkalloc(M_HEADERP this)
 {
-  if (!isalloced(this))
+  if (!isalloced(this)) {
+    __A_VARIABLE = 1;
     return die ("checkalloc: pointer header clobbered.");
+  }
 
   if (getdbglev(this) > M_DBG_NORMAL) 
     {
-      if (!testsentinel(this, M_ALLOCED))
+      if (!testsentinel(this, M_ALLOCED)) {
+        __A_VARIABLE = 1;
         return die ("checkalloc: pointer length overrun.");
+      }
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -337,6 +364,7 @@ checkfree(M_HEADERP this)
           die("checkfree: freed data clobbered.");
       }
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -355,6 +383,7 @@ checkfreelist()
         h = getnext(h);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static void 
@@ -366,6 +395,7 @@ checkalloclist()
       checkalloc(a);
       a = getnext(a);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Free a block of memory.  This is done by adding to the free list. */
@@ -390,6 +420,7 @@ addtofreelist (M_HEADERP h)
       setdata(h, M_FREEFLAG);
       setsentinel(h, M_FREE);
     }
+    __A_VARIABLE = 1;
 }
 
 void 
@@ -403,12 +434,14 @@ xil_malloc_verify()
     }
   checkfreelist();
   checkalloclist();
+  __A_VARIABLE = 1;
 }
 
 void 
 xil_malloc_debug (int level)
 {
   mdebuglevel = MAX (M_DBG_NORMAL, MIN (M_DBG_FULL, level));
+  __A_VARIABLE = 1;
 }
 
 void* 
@@ -423,8 +456,10 @@ xil_malloc (size_t nbytes)
 
   nummallocs += 1;
 
-  if (nbytes == 0)
+  if (nbytes == 0) {
+    __A_VARIABLE = 1;
     return getdata(zeroblock);
+  }
 
   if (mdebuglevel == M_DBG_FULL)
     {
@@ -498,6 +533,7 @@ xil_malloc (size_t nbytes)
 #ifdef DEBUG
       printf ("xil_malloc: Out of dynamic memory.\n");
 #endif
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -553,6 +589,7 @@ xil_malloc (size_t nbytes)
   if (totalmalloc > highwater)
     highwater = totalmalloc;
 
+  __A_VARIABLE = 1;
   return getdata(h);
 }
 
@@ -648,6 +685,7 @@ unsigned
 xil_msize (void* ap)
 {
   M_HEADERP h = (M_HEADERP) (((DATA_T *)ap) - sizeof (struct M_HEADER));
+  __A_VARIABLE = 1;
   return getdatasize(h);
 }
 
@@ -746,6 +784,7 @@ xil_calloc (size_t number, size_t size)
           *longptr++ = 0 ;
         }
     }
+  __A_VARIABLE = 1;
   return blockptr ;
 }
 
@@ -795,10 +834,12 @@ xil_mstats(int verbosity)
 
   printf("\n");
   fflush(stdout);
+  __A_VARIABLE = 1;
 }
 #else
 void 
 xil_mstats(int verbosity)
 {
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/libgloss/microblaze/xil_printf.c b/libgloss/microblaze/xil_printf.c
index f18ee84..4b2b4f2 100644
--- a/libgloss/microblaze/xil_printf.c
+++ b/libgloss/microblaze/xil_printf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995-2013 Xilinx, Inc.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -70,6 +71,7 @@ static void padding( const int l_flag, params_t *par)
     if (par->do_padding && l_flag && (par->len < par->num1))
         for (i=par->len; i<par->num1; i++)
             outbyte( par->pad_character);
+    __A_VARIABLE = 1;
 }
 
 /*---------------------------------------------------*/
@@ -91,6 +93,7 @@ static void outs( charptr lp, params_t *par)
     /* CR 439175 - elided next stmt. Seemed bogus.   */
     /* par->len = strlen( lp);                       */
     padding( par->left_flag, par);
+    __A_VARIABLE = 1;
 }
 
 /*---------------------------------------------------*/
@@ -133,6 +136,7 @@ static void outnum( const long n, const long base, params_t *par)
     while (cp >= outbuf)
         outbyte( *cp--);
     padding( par->left_flag, par);
+    __A_VARIABLE = 1;
 }
 
 /*---------------------------------------------------*/
@@ -150,6 +154,7 @@ static int getnum( charptr* linep)
     while (isdigit(*cp))
         n = n*10 + ((*cp++) - '0');
     *linep = cp;
+    __A_VARIABLE = 1;
     return(n);
 }
 
@@ -279,6 +284,7 @@ void xil_printf( const charptr ctrl1, ...)
         goto try_next;
     }
     va_end( argp);
+    __A_VARIABLE = 1;
 }
 
 /*---------------------------------------------------*/
diff --git a/libgloss/microblaze/xil_sbrk.c b/libgloss/microblaze/xil_sbrk.c
index 582f585..c43f9fa 100644
--- a/libgloss/microblaze/xil_sbrk.c
+++ b/libgloss/microblaze/xil_sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995, 2002, 2009 Xilinx, Inc.  All rights reserved. 
    
    Redistribution and use in source and binary forms, with or without
@@ -40,7 +41,10 @@ sbrk(int size)
   int oldindex;
   oldindex = memindex;
   memindex += size;
-  if (memindex >= 65536)
+  if (memindex >= 65536) {
+    __A_VARIABLE = 1;
     return 0;
+  }
+  __A_VARIABLE = 1;
   return (void *)(&memblk[oldindex]);
 }
diff --git a/libgloss/mips/array-io.c b/libgloss/mips/array-io.c
index 5c1d96f..bb4f2a5 100644
--- a/libgloss/mips/array-io.c
+++ b/libgloss/mips/array-io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* array-io.c -- I/O code for the Array Tech RAID disk controller.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -21,6 +22,7 @@ int
 outbyte(byte)
      unsigned char byte;
 {
+  __A_VARIABLE = 1;
   return (PUTCHAR(byte));
 }
 
@@ -30,6 +32,7 @@ outbyte(byte)
 unsigned char
 inbyte()
 {
+  __A_VARIABLE = 1;
   return ((unsigned char)GETCHAR);
 }
 
@@ -53,6 +56,7 @@ void
 zylons()
 {
   print ("Sorry, unimplemented\r\n");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -65,4 +69,5 @@ delay (x)
   int  y = 17;
   while (x-- !=0)
     y = y^2;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mips/cfe.c b/libgloss/mips/cfe.c
index c1d8af5..1e719a2 100644
--- a/libgloss/mips/cfe.c
+++ b/libgloss/mips/cfe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cfe.c -- I/O code for the MIPS boards running CFE.  */
 
 /*
@@ -54,6 +55,7 @@ __libcfe_init (long handle, long a1, long entrypoint, long a3)
   cfe_conshandle = cfe_getstdhandle (CFE_STDHANDLE_CONSOLE);
 
   __libcfe_meminit ();
+  __A_VARIABLE = 1;
   return __libcfe_stack_top ();
 }
 
@@ -64,6 +66,7 @@ __libcfe_exit (long status)
   outbyte ('\r');
   outbyte ('\n');
   cfe_exit (CFE_FLG_WARMSTART, status);
+  __A_VARIABLE = 1;
 }
 
 char
@@ -78,6 +81,7 @@ inbyte (void)
     c = '\n';
   if (__libcfe_echo_input)
     outbyte (c);
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -93,6 +97,7 @@ outbyte (char c)
   while (res == 0);
   if (c == '\n')
     outbyte ('\r');
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -103,5 +108,6 @@ int
 _flush_cache (char *addr, int nbytes, int cache)
 {
   cfe_flushcache (0);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mips/cfe_api.c b/libgloss/mips/cfe_api.c
index ab5ac90..02bf2c7 100644
--- a/libgloss/mips/cfe_api.c
+++ b/libgloss/mips/cfe_api.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* From: CFE Id: cfe_api.c,v 1.16 2002/07/09 23:29:11 cgd Exp $ */
 
 /*
@@ -76,13 +77,18 @@ cfe_init(cfe_xuint_t handle, cfe_xuint_t ept)
 {
     cfe_dispfunc = NATIVE_FROM_XPTR(ept);
     cfe_handle = handle;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 int
 cfe_iocb_dispatch(cfe_xiocb_t *xiocb)
 {
-    if (!cfe_dispfunc) return -1;
+    if (!cfe_dispfunc) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return (*cfe_dispfunc)((intptr_t)cfe_handle, (intptr_t)xiocb);
 }
 #endif /* CFE_API_common || CFE_API_ALL */
@@ -101,6 +107,7 @@ cfe_close(int handle)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 
 }
@@ -126,6 +133,7 @@ cfe_cpu_start(int cpu, void (*fn)(void), long sp, long gp, long a1)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_cpu_start || CFE_API_ALL */
@@ -146,6 +154,7 @@ cfe_cpu_stop(int cpu)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_cpu_stop || CFE_API_ALL */
@@ -169,6 +178,7 @@ cfe_enumenv(int idx, char *name, int namelen, char *val, int vallen)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_enumenv || CFE_API_ALL */
@@ -189,13 +199,16 @@ cfe_enummem(int idx, int flags, cfe_xuint_t *start, cfe_xuint_t *length,
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
 
     *start = xiocb.plist.xiocb_meminfo.mi_addr;
     *length = xiocb.plist.xiocb_meminfo.mi_size;
     *type = xiocb.plist.xiocb_meminfo.mi_type;
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif /* CFE_API_enummem || CFE_API_ALL */
@@ -215,6 +228,7 @@ cfe_exit(int warm, int status)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_exit || CFE_API_ALL */
@@ -233,6 +247,7 @@ cfe_flushcache(int flg)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_flushcache || CFE_API_ALL */
@@ -254,8 +269,11 @@ cfe_getdevinfo(char *name)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.plist.xiocb_buffer.buf_devflags;
 }
 #endif /* CFE_API_getdevinfo || CFE_API_ALL */
@@ -281,6 +299,7 @@ cfe_getenv(char *name, char *dest, int destlen)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_getenv || CFE_API_ALL */
@@ -299,8 +318,10 @@ cfe_getfwinfo(cfe_fwinfo_t *info)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
 
     info->fwi_version = xiocb.plist.xiocb_fwinfo.fwi_version;
     info->fwi_totalmem = xiocb.plist.xiocb_fwinfo.fwi_totalmem;
@@ -315,6 +336,7 @@ cfe_getfwinfo(cfe_fwinfo_t *info)
     info->fwi_reserved3 = xiocb.plist.xiocb_fwinfo.fwi_reserved3;
 #endif
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif /* CFE_API_getfwinfo || CFE_API_ALL */
@@ -333,8 +355,11 @@ cfe_getstdhandle(int flg)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.xiocb_handle;
 
 }
@@ -359,6 +384,7 @@ cfe_getticks(void)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.plist.xiocb_time.ticks;
 
 }
@@ -379,8 +405,11 @@ cfe_inpstat(int handle)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.plist.xiocb_inpstat.inp_status;
 
 }
@@ -407,6 +436,7 @@ cfe_ioctl(int handle, unsigned int ioctlnum, unsigned char *buffer, int length,
 
     if (retlen)
 	*retlen = xiocb.plist.xiocb_buffer.buf_retlen;
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_ioctl || CFE_API_ALL */
@@ -428,8 +458,11 @@ cfe_open(char *name)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.xiocb_handle;
 }
 #endif /* CFE_API_open || CFE_API_ALL */
@@ -438,6 +471,7 @@ cfe_open(char *name)
 int
 cfe_read(int handle, unsigned char *buffer, int length)
 {
+    __A_VARIABLE = 1;
     return cfe_readblk(handle, 0, buffer, length);
 }
 #endif /* CFE_API_read || CFE_API_ALL */
@@ -459,8 +493,11 @@ cfe_readblk(int handle, cfe_xint_t offset, unsigned char *buffer, int length)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.plist.xiocb_buffer.buf_retlen;
 }
 #endif /* CFE_API_readblk || CFE_API_ALL */
@@ -484,6 +521,7 @@ cfe_setenv(char *name, char *val)
 
     cfe_iocb_dispatch(&xiocb);
 
+    __A_VARIABLE = 1;
     return xiocb.xiocb_status;
 }
 #endif /* CFE_API_setenv || CFE_API_ALL */
@@ -498,6 +536,7 @@ cfe_strlen(char *name)
     while (*name++)
 	count++;
 
+    __A_VARIABLE = 1;
     return count;
 }
 #endif /* CFE_API_strlen || CFE_API_ALL */
@@ -506,6 +545,7 @@ cfe_strlen(char *name)
 int
 cfe_write(int handle, unsigned char *buffer, int length)
 {
+    __A_VARIABLE = 1;
     return cfe_writeblk(handle, 0, buffer, length);
 }
 #endif /* CFE_API_write || CFE_API_ALL */
@@ -527,8 +567,11 @@ cfe_writeblk(int handle, cfe_xint_t offset, unsigned char *buffer, int length)
 
     cfe_iocb_dispatch(&xiocb);
 
-    if (xiocb.xiocb_status < 0)
+    if (xiocb.xiocb_status < 0) {
+	__A_VARIABLE = 1;
 	return xiocb.xiocb_status;
+    }
+    __A_VARIABLE = 1;
     return xiocb.plist.xiocb_buffer.buf_retlen;
 }
 #endif /* CFE_API_writeblk || CFE_API_ALL */
diff --git a/libgloss/mips/cfe_mem.c b/libgloss/mips/cfe_mem.c
index 87caabf..d7e4d31 100644
--- a/libgloss/mips/cfe_mem.c
+++ b/libgloss/mips/cfe_mem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cfe_mem.c -- Replaceable memory management hooks for MIPS boards
    running CFE.  */
 
@@ -109,6 +110,7 @@ __libcfe_meminit (void)
      round the stack size up to a 32-byte multiple.  */
   memtop = memtop & ~(unsigned long)31;
   stack_size = (stack_size + 31) & ~(unsigned long)31;
+  __A_VARIABLE = 1;
 }
 
 void *
@@ -116,6 +118,7 @@ __libcfe_stack_top (void)
 {
   /* Grow down from the top of available memory.  Obviously, if
      code writes above this limit, problems could result!  */
+  __A_VARIABLE = 1;
   return (void *) memtop;
 }
 
@@ -126,5 +129,6 @@ void *
 get_mem_info (struct s_mem *meminfo)
 {
   meminfo->size = (char *)(memtop - stack_size) - _end;
+  __A_VARIABLE = 1;
   return (void *) memtop;
 }
diff --git a/libgloss/mips/cma101.c b/libgloss/mips/cma101.c
index e8f3818..c650fbb 100644
--- a/libgloss/mips/cma101.c
+++ b/libgloss/mips/cma101.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cma101.c -- lo-level support for Cogent CMA101 development board.
  *
@@ -130,6 +131,7 @@ set_pclock (void)
      break;
   }
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -143,6 +145,7 @@ static int
 lcd_busy (void)
 {
   PCLOCK_WAIT(50); /* 50uS delay */
+  __A_VARIABLE = 1;
   return(*LCD_CMD & LCD_STAT_BUSY);
 }
 
@@ -155,20 +158,25 @@ lcd_display (int line, const char *msg)
 {
   int n;
 
-  if (lcd_busy ())
+  if (lcd_busy ()) {
+   __A_VARIABLE = 1;
    return;
+  }
 
   *LCD_CMD = (LCD_SET_DDADDR | (line == 1 ? 0x40 : 0x00));
 
   for (n = 0; n < 16; n++) {
-    if (lcd_busy ())
+    if (lcd_busy ()) {
+     __A_VARIABLE = 1;
      return;
+    }
     if (*msg)
      *LCD_DATA = *msg++;
     else
      *LCD_DATA = ' ';
   }
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -195,8 +203,10 @@ __sizemem ()
 
   /* If the linker script provided a value for the memory size (or the user
      overrode it in a debugger), use that.  */
-  if (__sizemem_default)
+  if (__sizemem_default) {
+    __A_VARIABLE = 1;
     return __sizemem_default;
+  }
 
   /* If we are running in kernel segment 0 (possibly cached), try sizing memory
      in kernel segment 1 (uncached) to avoid some problems with monitors.  */
@@ -255,6 +265,7 @@ __sizemem ()
 
   INTRESTORE(sr); /* restore interrupt mask to entry state */
 
+  __A_VARIABLE = 1;
   return((probe - base) * sizeof(unsigned int));
 }
 
@@ -264,6 +275,7 @@ static int
 convertbcd(byte)
      unsigned char byte;
 {
+  __A_VARIABLE = 1;
   return ((((byte >> 4) & 0xF) * 10) + (byte & 0xF));
 }
 
@@ -308,6 +320,7 @@ time (_timer)
   if (_timer != NULL)
     *_timer = result;
 
+  __A_VARIABLE = 1;
   return (result);
 }
 
diff --git a/libgloss/mips/cygmon.c b/libgloss/mips/cygmon.c
index 506e853..b11cd71 100644
--- a/libgloss/mips/cygmon.c
+++ b/libgloss/mips/cygmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cygmon.c -- Glue code for linking apps to run on top of Cygmon.
  *
  * Copyright (c) 1998, 1999, 2000 Red Hat, Inc.
@@ -20,6 +21,7 @@ write ( int file,
         char *buf,
         int nbytes)
 {
+  __A_VARIABLE = 1;
   return sysCall(SYS_write, file, (unsigned long)buf, nbytes);
 }
 
@@ -28,12 +30,14 @@ read (int file,
       char *buf,
       int nbytes)
 {
+  __A_VARIABLE = 1;
   return sysCall(SYS_read, file, (unsigned long)buf, nbytes);
 }
 
 int
 outbyte (unsigned char c)
 {
+  __A_VARIABLE = 1;
   return sysCall(SYS_write, 0, (unsigned long)&c, 1);
 }
 
@@ -42,6 +46,7 @@ inbyte (void)
 {
   char c;
   sysCall(SYS_read, 0, (unsigned long)&c, 1);
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -68,6 +73,7 @@ int sysCall(unsigned long func, unsigned long p1, unsigned long p2, unsigned lon
           syscall 		\n\
           nop			\n\
           move %0, $2" : "=r"(ret) : "r"(func), "r"(p1), "r"(p2), "r"(p3));
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -83,5 +89,6 @@ get_mem_info (mem)
 
   numbanks = sysCall(SYS_meminfo, (unsigned long)&totmem, (unsigned long)&topmem, 0);
   mem->size = totmem;
+  __A_VARIABLE = 1;
   return (void*)topmem;
 }
diff --git a/libgloss/mips/dvemon.c b/libgloss/mips/dvemon.c
index 16b49da..8801051 100644
--- a/libgloss/mips/dvemon.c
+++ b/libgloss/mips/dvemon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* dve.c -- I/O code for the Densan DVE-R3900 board.
  *
  * Copyright (c) 1998, 1999 Cygnus Support
@@ -52,6 +53,7 @@ outbyte(byte)
     co (0x0f);
 
   co (byte);
+  __A_VARIABLE = 1;
   return byte;
 }
 
@@ -60,6 +62,7 @@ outbyte(byte)
 unsigned char
 inbyte()
 {
+  __A_VARIABLE = 1;
   return (unsigned char) ci (WAIT);
 }
 
@@ -80,4 +83,5 @@ get_mem_info (mem)
      struct s_mem *mem;
 {
   mem->size = 0x1000000;	/* DVE-R3900 board has 16 MB of RAM */
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mips/jmr3904-io.c b/libgloss/mips/jmr3904-io.c
index 8d43007..4259466 100644
--- a/libgloss/mips/jmr3904-io.c
+++ b/libgloss/mips/jmr3904-io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 #define READ_UINT8( _register_, _value_ ) \
@@ -44,6 +45,7 @@ inbyte (void)
   disr = disr & ~0x0001;
   READ_UINT8 (DIAG_RFIFO, c);
   WRITE_UINT16 (DIAG_SLDISR, disr);
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -61,6 +63,7 @@ outbyte (unsigned char c)
   disr = disr & ~0x0002;
   WRITE_UINT8 (DIAG_TFIFO, c);
   WRITE_UINT16 (DIAG_SLDISR, disr);
+  __A_VARIABLE = 1;
 }
 
 /* Stuff required to setup IO on this board */
@@ -70,6 +73,7 @@ void board_serial_init (void)
   WRITE_UINT16 (DIAG_SLDICR, 0x0000);
   WRITE_UINT16 (DIAG_SFCR, 0x0000);
   WRITE_UINT16 (DIAG_SBRG, BRG_T2 | 5);
+  __A_VARIABLE = 1;
 }
 
 /* If you want this to be initialized as part of the stuff which gets called
@@ -80,6 +84,7 @@ void board_serial_init (void)
 void hardware_init_hook(void)
 {
   board_serial_init() ;
+  __A_VARIABLE = 1;
 }
      
 /* Structure filled in by get_mem_info.  Only the size field is
@@ -101,4 +106,5 @@ get_mem_info (mem)
      struct s_mem *mem;
 {
   mem->size = (unsigned int)_mem_size;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mips/nullmon.c b/libgloss/mips/nullmon.c
index 0b519bf..43affa1 100644
--- a/libgloss/mips/nullmon.c
+++ b/libgloss/mips/nullmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* nullmon.c - Stub or monitor services.
  *
  * Copyright (c) 1998 Cygnus Support
@@ -49,6 +50,7 @@ get_mem_info (mem)
      struct s_mem *mem;
 {
   mem->size = BOARD_MEM_SIZE - (_end - _ftext);
+  __A_VARIABLE = 1;
 }
 
 /*  SYSTEM INTERFACE
@@ -58,7 +60,10 @@ get_mem_info (mem)
   get pulled in by other libraries.
 */
  
-int read(int file, char * ptr , int len) {   return 0 ; }
-int close (int file) { return -1 ; }
-int write(int file , char * ptr, int len) { return 0 ; }
+int read(int file, char * ptr , int len) {   __A_VARIABLE = 1;
+	return 0 ; }
+int close (int file) { __A_VARIABLE = 1;
+	return -1 ; }
+int write(int file , char * ptr, int len) { __A_VARIABLE = 1;
+	return 0 ; }
 /*eof*/
diff --git a/libgloss/mips/syscalls.c b/libgloss/mips/syscalls.c
index 3ab5436..6fc53dc 100644
--- a/libgloss/mips/syscalls.c
+++ b/libgloss/mips/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -24,8 +25,10 @@ sbrk (nbytes)
 
   /* The sizeof (s_mem.size) must be 4 bytes.  The compiler should be
      able to eliminate this check */
-  if (sizeof (unsigned int) != 4)
+  if (sizeof (unsigned int) != 4) {
+    __A_VARIABLE = 1;
     return (char *)-1;
+  }
 
   get_mem_info(&mem);
   /* NOTE: The value returned from the get_mem_info call is the amount
@@ -41,5 +44,6 @@ sbrk (nbytes)
   else
    heap_ptr += nbytes;
 
+  __A_VARIABLE = 1;
   return base;
 }
diff --git a/libgloss/mips/test.c b/libgloss/mips/test.c
index a993479..2659aca 100644
--- a/libgloss/mips/test.c
+++ b/libgloss/mips/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 main()
 {
   outbyte ('&');
@@ -9,5 +10,6 @@ main()
   
   print ("\r\nDone...");
 
+  __A_VARIABLE = 1;
   return;
 }
diff --git a/libgloss/mn10200/_exit.c b/libgloss/mn10200/_exit.c
index ec51d40..f92390e 100644
--- a/libgloss/mn10200/_exit.c
+++ b/libgloss/mn10200/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,6 +16,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -26,4 +28,5 @@ void _exit (n)
   _do_dtors();
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mn10200/access.c b/libgloss/mn10200/access.c
index 980682e..b71fa38 100644
--- a/libgloss/mn10200/access.c
+++ b/libgloss/mn10200/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/libgloss/mn10200/chmod.c b/libgloss/mn10200/chmod.c
index 8200506..d08fb19 100644
--- a/libgloss/mn10200/chmod.c
+++ b/libgloss/mn10200/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/mn10200/chown.c b/libgloss/mn10200/chown.c
index 6630d3b..a82a8eb 100644
--- a/libgloss/mn10200/chown.c
+++ b/libgloss/mn10200/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/libgloss/mn10200/close.c b/libgloss/mn10200/close.c
index 8474b38..47a154a 100644
--- a/libgloss/mn10200/close.c
+++ b/libgloss/mn10200/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/mn10200/creat.c b/libgloss/mn10200/creat.c
index 1003a2a..0b5dfa1 100644
--- a/libgloss/mn10200/creat.c
+++ b/libgloss/mn10200/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/libgloss/mn10200/crt1.c b/libgloss/mn10200/crt1.c
index dd0be31..840f8d2 100644
--- a/libgloss/mn10200/crt1.c
+++ b/libgloss/mn10200/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
   static int initialized;
@@ -13,4 +14,5 @@ void __main ()
 	(*--p) ();
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/mn10200/execv.c b/libgloss/mn10200/execv.c
index 16f3ca5..c785c45 100644
--- a/libgloss/mn10200/execv.c
+++ b/libgloss/mn10200/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/libgloss/mn10200/execve.c b/libgloss/mn10200/execve.c
index bd6c7a2..73418be 100644
--- a/libgloss/mn10200/execve.c
+++ b/libgloss/mn10200/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/libgloss/mn10200/fork.c b/libgloss/mn10200/fork.c
index 53df5a9..93245fa 100644
--- a/libgloss/mn10200/fork.c
+++ b/libgloss/mn10200/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/libgloss/mn10200/fstat.c b/libgloss/mn10200/fstat.c
index c3b2fa0..5a10d3c 100644
--- a/libgloss/mn10200/fstat.c
+++ b/libgloss/mn10200/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mn10200/getpid.c b/libgloss/mn10200/getpid.c
index 20ab186..11e35c6 100644
--- a/libgloss/mn10200/getpid.c
+++ b/libgloss/mn10200/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -6,5 +7,6 @@
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/mn10200/gettime.c b/libgloss/mn10200/gettime.c
index 1a04267..9600e7a 100644
--- a/libgloss/mn10200/gettime.c
+++ b/libgloss/mn10200/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/libgloss/mn10200/isatty.c b/libgloss/mn10200/isatty.c
index 7e63a8c..a5a8fbd 100644
--- a/libgloss/mn10200/isatty.c
+++ b/libgloss/mn10200/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mn10200/kill.c b/libgloss/mn10200/kill.c
index 40afa6a..922a4c5 100644
--- a/libgloss/mn10200/kill.c
+++ b/libgloss/mn10200/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mn10200/lseek.c b/libgloss/mn10200/lseek.c
index 339baea..69f76f8 100644
--- a/libgloss/mn10200/lseek.c
+++ b/libgloss/mn10200/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _lseek (int file,
 	off_t ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/mn10200/open.c b/libgloss/mn10200/open.c
index 770defe..5d6c475 100644
--- a/libgloss/mn10200/open.c
+++ b/libgloss/mn10200/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/libgloss/mn10200/pipe.c b/libgloss/mn10200/pipe.c
index dfade5c..cefcfc9 100644
--- a/libgloss/mn10200/pipe.c
+++ b/libgloss/mn10200/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 pipe (int fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/libgloss/mn10200/read.c b/libgloss/mn10200/read.c
index 31d24cc..c3a5bca 100644
--- a/libgloss/mn10200/read.c
+++ b/libgloss/mn10200/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ _read (int file,
        char *ptr,
        size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/mn10200/sbrk.c b/libgloss/mn10200/sbrk.c
index 376fd32..cffb55c 100644
--- a/libgloss/mn10200/sbrk.c
+++ b/libgloss/mn10200/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -27,5 +28,6 @@ _sbrk (size_t incr)
       _write (1, "Heap and stack collision\n", 25);
       abort ();
     }
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/mn10200/stat.c b/libgloss/mn10200/stat.c
index 4e1fddf..164976a 100644
--- a/libgloss/mn10200/stat.c
+++ b/libgloss/mn10200/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/mn10200/test.c b/libgloss/mn10200/test.c
index 9928958..221a4ce 100644
--- a/libgloss/mn10200/test.c
+++ b/libgloss/mn10200/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <string.h>
 
@@ -6,6 +7,7 @@ send_msg1 (void)
 {
   static char msg[] = "Hello World\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -13,6 +15,7 @@ send_msg2 (void)
 {
   static char msg[] = "Goodnight Irene\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -22,6 +25,7 @@ delay (void)
 
   for (i = 0; i < 32000; i++)
     ;
+    __A_VARIABLE = 1;
 }
 
 int
@@ -34,6 +38,7 @@ main(int argc, char *argv[])
       delay ();
       send_msg2 ();
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/mn10200/time.c b/libgloss/mn10200/time.c
index 2df8d48..af74345 100644
--- a/libgloss/mn10200/time.c
+++ b/libgloss/mn10200/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/libgloss/mn10200/times.c b/libgloss/mn10200/times.c
index b804be4..240b40f 100644
--- a/libgloss/mn10200/times.c
+++ b/libgloss/mn10200/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 clock_t
 times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/libgloss/mn10200/unlink.c b/libgloss/mn10200/unlink.c
index 84fb711..78f961e 100644
--- a/libgloss/mn10200/unlink.c
+++ b/libgloss/mn10200/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/mn10200/utime.c b/libgloss/mn10200/utime.c
index 3fce7e3..16823d5 100644
--- a/libgloss/mn10200/utime.c
+++ b/libgloss/mn10200/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/mn10200/wait.c b/libgloss/mn10200/wait.c
index c8d8b4c..f134991 100644
--- a/libgloss/mn10200/wait.c
+++ b/libgloss/mn10200/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/libgloss/mn10200/write.c b/libgloss/mn10200/write.c
index 3ecf4a8..fa35bf2 100644
--- a/libgloss/mn10200/write.c
+++ b/libgloss/mn10200/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ _write ( int file,
 	 char *ptr,
 	 size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/mn10300/_exit.c b/libgloss/mn10300/_exit.c
index ec51d40..f92390e 100644
--- a/libgloss/mn10300/_exit.c
+++ b/libgloss/mn10300/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,6 +16,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -26,4 +28,5 @@ void _exit (n)
   _do_dtors();
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mn10300/access.c b/libgloss/mn10300/access.c
index 980682e..b71fa38 100644
--- a/libgloss/mn10300/access.c
+++ b/libgloss/mn10300/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/libgloss/mn10300/chmod.c b/libgloss/mn10300/chmod.c
index 8200506..d08fb19 100644
--- a/libgloss/mn10300/chmod.c
+++ b/libgloss/mn10300/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/mn10300/chown.c b/libgloss/mn10300/chown.c
index 6630d3b..a82a8eb 100644
--- a/libgloss/mn10300/chown.c
+++ b/libgloss/mn10300/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/libgloss/mn10300/close.c b/libgloss/mn10300/close.c
index 8474b38..47a154a 100644
--- a/libgloss/mn10300/close.c
+++ b/libgloss/mn10300/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/mn10300/creat.c b/libgloss/mn10300/creat.c
index 1003a2a..0b5dfa1 100644
--- a/libgloss/mn10300/creat.c
+++ b/libgloss/mn10300/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/libgloss/mn10300/crt1.c b/libgloss/mn10300/crt1.c
index dd0be31..840f8d2 100644
--- a/libgloss/mn10300/crt1.c
+++ b/libgloss/mn10300/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
   static int initialized;
@@ -13,4 +14,5 @@ void __main ()
 	(*--p) ();
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/mn10300/cygmon.c b/libgloss/mn10300/cygmon.c
index 513115c..c00fde9 100644
--- a/libgloss/mn10300/cygmon.c
+++ b/libgloss/mn10300/cygmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* cygmon.c -- Glue code for linking apps to run on top of Cygmon.
  *
  * Copyright (c) 1998, 1999, 2000, 2001 Red Hat, Inc.
@@ -57,6 +58,7 @@ int __trap0(unsigned long func, unsigned long p1, unsigned long p2, unsigned lon
   if (ret != 0)
       errno = ret;
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -69,5 +71,6 @@ get_mem_info (mem)
 
   numbanks = __trap0(SYS_meminfo, (unsigned long)&totmem, (unsigned long)&topmem, 0);
   mem->size = totmem;
+  __A_VARIABLE = 1;
   return (void*)topmem;
 }
diff --git a/libgloss/mn10300/execv.c b/libgloss/mn10300/execv.c
index 16f3ca5..c785c45 100644
--- a/libgloss/mn10300/execv.c
+++ b/libgloss/mn10300/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/libgloss/mn10300/execve.c b/libgloss/mn10300/execve.c
index bd6c7a2..73418be 100644
--- a/libgloss/mn10300/execve.c
+++ b/libgloss/mn10300/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/libgloss/mn10300/fork.c b/libgloss/mn10300/fork.c
index 53df5a9..93245fa 100644
--- a/libgloss/mn10300/fork.c
+++ b/libgloss/mn10300/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/libgloss/mn10300/fstat.c b/libgloss/mn10300/fstat.c
index c3b2fa0..5a10d3c 100644
--- a/libgloss/mn10300/fstat.c
+++ b/libgloss/mn10300/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mn10300/getpid.c b/libgloss/mn10300/getpid.c
index 20ab186..11e35c6 100644
--- a/libgloss/mn10300/getpid.c
+++ b/libgloss/mn10300/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -6,5 +7,6 @@
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/mn10300/gettime.c b/libgloss/mn10300/gettime.c
index 1a04267..9600e7a 100644
--- a/libgloss/mn10300/gettime.c
+++ b/libgloss/mn10300/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/libgloss/mn10300/isatty.c b/libgloss/mn10300/isatty.c
index 7e63a8c..a5a8fbd 100644
--- a/libgloss/mn10300/isatty.c
+++ b/libgloss/mn10300/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mn10300/kill.c b/libgloss/mn10300/kill.c
index 40afa6a..922a4c5 100644
--- a/libgloss/mn10300/kill.c
+++ b/libgloss/mn10300/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mn10300/lseek.c b/libgloss/mn10300/lseek.c
index 339baea..69f76f8 100644
--- a/libgloss/mn10300/lseek.c
+++ b/libgloss/mn10300/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ _lseek (int file,
 	off_t ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/mn10300/open.c b/libgloss/mn10300/open.c
index 770defe..5d6c475 100644
--- a/libgloss/mn10300/open.c
+++ b/libgloss/mn10300/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/libgloss/mn10300/pipe.c b/libgloss/mn10300/pipe.c
index dfade5c..cefcfc9 100644
--- a/libgloss/mn10300/pipe.c
+++ b/libgloss/mn10300/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 pipe (int fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/libgloss/mn10300/read.c b/libgloss/mn10300/read.c
index 31d24cc..c3a5bca 100644
--- a/libgloss/mn10300/read.c
+++ b/libgloss/mn10300/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ _read (int file,
        char *ptr,
        size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/mn10300/sbrk.c b/libgloss/mn10300/sbrk.c
index 376fd32..cffb55c 100644
--- a/libgloss/mn10300/sbrk.c
+++ b/libgloss/mn10300/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -27,5 +28,6 @@ _sbrk (size_t incr)
       _write (1, "Heap and stack collision\n", 25);
       abort ();
     }
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/mn10300/stat.c b/libgloss/mn10300/stat.c
index 4e1fddf..164976a 100644
--- a/libgloss/mn10300/stat.c
+++ b/libgloss/mn10300/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/mn10300/test.c b/libgloss/mn10300/test.c
index 9ea873a..3ab102c 100644
--- a/libgloss/mn10300/test.c
+++ b/libgloss/mn10300/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 static void
@@ -5,6 +6,7 @@ send_msg1 (void)
 {
   static char msg[] = "Hello World\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -12,6 +14,7 @@ send_msg2 (void)
 {
   static char msg[] = "Goodnight Irene\r\n";
   write(1, msg, strlen (msg));
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -21,6 +24,7 @@ delay (void)
 
   for (i = 0; i < 1000000; i++)
     ;
+    __A_VARIABLE = 1;
 }
 
 int
@@ -33,6 +37,7 @@ main(int argc, char *argv[])
       delay ();
       send_msg2 ();
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/mn10300/time.c b/libgloss/mn10300/time.c
index 4528631..01d9551 100644
--- a/libgloss/mn10300/time.c
+++ b/libgloss/mn10300/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -11,5 +12,6 @@ time (time_t *tloc)
   res = TRAP0 (SYS_time, 0, 0, 0);
   if (tloc)
     *tloc = res;
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/libgloss/mn10300/times.c b/libgloss/mn10300/times.c
index 8cdc55b..8ade763 100644
--- a/libgloss/mn10300/times.c
+++ b/libgloss/mn10300/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 clock_t
 _times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/libgloss/mn10300/unlink.c b/libgloss/mn10300/unlink.c
index 84fb711..78f961e 100644
--- a/libgloss/mn10300/unlink.c
+++ b/libgloss/mn10300/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/mn10300/utime.c b/libgloss/mn10300/utime.c
index 3fce7e3..16823d5 100644
--- a/libgloss/mn10300/utime.c
+++ b/libgloss/mn10300/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/mn10300/wait.c b/libgloss/mn10300/wait.c
index c8d8b4c..f134991 100644
--- a/libgloss/mn10300/wait.c
+++ b/libgloss/mn10300/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/libgloss/mn10300/write.c b/libgloss/mn10300/write.c
index 3ecf4a8..fa35bf2 100644
--- a/libgloss/mn10300/write.c
+++ b/libgloss/mn10300/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ _write ( int file,
 	 char *ptr,
 	 size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/moxie/fstat.c b/libgloss/moxie/fstat.c
index 6464a86..a491d45 100644
--- a/libgloss/moxie/fstat.c
+++ b/libgloss/moxie/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 2008 Anthony Green
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/moxie/getpid.c b/libgloss/moxie/getpid.c
index 957eee7..2d25fcf 100644
--- a/libgloss/moxie/getpid.c
+++ b/libgloss/moxie/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 2008 Anthony Green
@@ -21,5 +22,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/moxie/isatty.c b/libgloss/moxie/isatty.c
index 14cb9c4..dffacab 100644
--- a/libgloss/moxie/isatty.c
+++ b/libgloss/moxie/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 2008 Anthony Green
@@ -23,5 +24,6 @@ int
 _DEFUN (_isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/moxie/kill.c b/libgloss/moxie/kill.c
index 257c491..746db18 100644
--- a/libgloss/moxie/kill.c
+++ b/libgloss/moxie/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 2008 Anthony Green
@@ -26,5 +27,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/moxie/print.c b/libgloss/moxie/print.c
index a20743a..77e9ef1 100644
--- a/libgloss/moxie/print.c
+++ b/libgloss/moxie/print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* print.c -- print a string on the output device.
  *
  * Copyright (c) 2008 Anthony Green
@@ -24,4 +25,5 @@ char *ptr)
   while (*ptr) {
     outbyte (*ptr++);
   }
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/moxie/putnum.c b/libgloss/moxie/putnum.c
index f5bac1f..3812be0 100644
--- a/libgloss/moxie/putnum.c
+++ b/libgloss/moxie/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 2008 Anthony Green
@@ -38,4 +39,5 @@ _DEFUN (_putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/moxie/qemu-time.c b/libgloss/moxie/qemu-time.c
index 4b09209..b028f83 100644
--- a/libgloss/moxie/qemu-time.c
+++ b/libgloss/moxie/qemu-time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* qemu-time.c -- stubs so clock can be linked in.
  *
  * Copyright (c) 2008 Anthony Green
@@ -44,6 +45,7 @@ _DEFUN (_times, _times (buf),
 	struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -52,6 +54,7 @@ static unsigned char
 rtc_read (unsigned char reg)
 {
   *(volatile unsigned char *)(RTC_PORT) = reg;
+  __A_VARIABLE = 1;
   return *(volatile unsigned char *)(RTC_PORT + 1);
 }
 
@@ -61,6 +64,7 @@ rtc_write (unsigned char reg, unsigned char val)
 {
   *(volatile unsigned char *)(RTC_PORT) = reg;
   *(volatile unsigned char *)(RTC_PORT + 1) = val;
+  __A_VARIABLE = 1;
 }
 
 /* Convert BCD to Decimal.  */
@@ -92,6 +96,7 @@ _DEFUN (time, time (t),
   if (t)
     *t = ret;
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -112,5 +117,6 @@ _DEFUN (_gettimeofday, _gettimeofday (tv, tz),
   tv->tv_usec = 0;
   tv->tv_sec = time(0);
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/moxie/qemu-write.c b/libgloss/moxie/qemu-write.c
index 4abc6dd..7871614 100644
--- a/libgloss/moxie/qemu-write.c
+++ b/libgloss/moxie/qemu-write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * qemu-write.c -- write interface for default qemu simulator
  * 
@@ -19,5 +20,6 @@ int _write (int fd, char *buf, int len)
   int i = 0;
   while (i < len)
     *(char *)0x3f8 = buf[i++];
+  __A_VARIABLE = 1;
   return len;
 }
diff --git a/libgloss/moxie/sbrk.c b/libgloss/moxie/sbrk.c
index f3489c1..a50e386 100644
--- a/libgloss/moxie/sbrk.c
+++ b/libgloss/moxie/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate memory dynamically.
  * 
  * Copyright (c) 2008 Anthony Green
@@ -37,6 +38,7 @@ _sbrk (nbytes)
   base = __heap_ptr;
   __heap_ptr += nbytes;
 
+  __A_VARIABLE = 1;
   return base;
 /* FIXME: We really want to make sure we don't run out of RAM, but this
  *       isn't very portable.
diff --git a/libgloss/moxie/sim-inbyte.c b/libgloss/moxie/sim-inbyte.c
index 1e7466a..c2b704b 100644
--- a/libgloss/moxie/sim-inbyte.c
+++ b/libgloss/moxie/sim-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-inbyte.c -- read a character from standard input.
  *
@@ -19,8 +20,11 @@ inbyte ()
 {
   char c;
 
-  if (read (0, &c, 1) <= 0)
+  if (read (0, &c, 1) <= 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return c;
 }
diff --git a/libgloss/moxie/sim-lseek.c b/libgloss/moxie/sim-lseek.c
index 8e7ee50..b2676ab 100644
--- a/libgloss/moxie/sim-lseek.c
+++ b/libgloss/moxie/sim-lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-lseek.S -- write interface for moxie simulator
  * 
@@ -28,5 +29,6 @@ _DEFUN (_lseek, (fd,  offset, whence),
        int whence)
 {
   /*   errno = ESPIPE; */
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
diff --git a/libgloss/moxie/sim-time.c b/libgloss/moxie/sim-time.c
index 3e9fafb..688d5f5 100644
--- a/libgloss/moxie/sim-time.c
+++ b/libgloss/moxie/sim-time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-time.c -- stubs so clock can be linked in.
  *
  * Copyright (c) 2008 Anthony Green
@@ -45,6 +46,7 @@ _DEFUN (time, time (t),
   if (t)
     *t = ret;
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -56,6 +58,7 @@ _DEFUN (_times, _times (buf),
 	struct tms *buf)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -74,5 +77,6 @@ _DEFUN (_gettimeofday, _gettimeofday (tv, tz),
 
   tv->tv_usec = 0;
   tv->tv_sec = _sim_time ();
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/moxie/stat.c b/libgloss/moxie/stat.c
index 0d7511a..8b3422e 100644
--- a/libgloss/moxie/stat.c
+++ b/libgloss/moxie/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 2008 Anthony Green
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/msp430/sbrk.c b/libgloss/msp430/sbrk.c
index 0a88b94..07d0e47 100644
--- a/libgloss/msp430/sbrk.c
+++ b/libgloss/msp430/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 Red Hat, Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use, modify,
@@ -27,6 +28,7 @@ _sbrk (int adj)
     }
 
   heap += adj;
+  __A_VARIABLE = 1;
   return rv;
 }
 
diff --git a/libgloss/msp430/unlink.c b/libgloss/msp430/unlink.c
index 1c8c6f2..99a62a6 100644
--- a/libgloss/msp430/unlink.c
+++ b/libgloss/msp430/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <string.h>
 
 #include "cio.h"
@@ -7,8 +8,10 @@ unlink (const char * name)
 {
   unsigned len = strlen (name);
 
-  if (len >= CIO_BUF_SIZE)
+  if (len >= CIO_BUF_SIZE) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   __CIOBUF__.length[0] = len;
   __CIOBUF__.length[1] = len >> 8;
@@ -19,6 +22,7 @@ unlink (const char * name)
 
   _libgloss_cio_hook ();
 
+  __A_VARIABLE = 1;
   return __CIOBUF__.parms[0] + __CIOBUF__.parms[1] * 256;
 }
 
diff --git a/libgloss/msp430/write.c b/libgloss/msp430/write.c
index 3a5a9f8..8d55ac4 100644
--- a/libgloss/msp430/write.c
+++ b/libgloss/msp430/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013 Red Hat, Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use, modify,
@@ -29,6 +30,7 @@ write_chunk (int fd, char *buf, int len)
 
   _libgloss_cio_hook ();
 
+  __A_VARIABLE = 1;
   return __CIOBUF__.parms[0] + __CIOBUF__.parms[1] * 256;
 }
 
@@ -49,11 +51,14 @@ write (int fd, char *buf, int len)
     {
       int l = (len > CIO_BUF_SIZE) ? CIO_BUF_SIZE : len;
       c = write_chunk (fd, buf, l);
-      if (c < 0)
+      if (c < 0) {
+	__A_VARIABLE = 1;
 	return c;
+      }
       rv += l;
       len -= l;
       buf += l;
     }
+  __A_VARIABLE = 1;
   return rv;
 }
diff --git a/libgloss/mt/access.c b/libgloss/mt/access.c
index 980682e..b71fa38 100644
--- a/libgloss/mt/access.c
+++ b/libgloss/mt/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/libgloss/mt/chmod.c b/libgloss/mt/chmod.c
index 8200506..d08fb19 100644
--- a/libgloss/mt/chmod.c
+++ b/libgloss/mt/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/mt/close.c b/libgloss/mt/close.c
index 02ee072..330fb84 100644
--- a/libgloss/mt/close.c
+++ b/libgloss/mt/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/mt/exit-16-002.c b/libgloss/mt/exit-16-002.c
index ba048d9..d471d01 100644
--- a/libgloss/mt/exit-16-002.c
+++ b/libgloss/mt/exit-16-002.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,4 +10,5 @@ void _exit (n)
      the simulator. (The simulator will return a SIGQUIT signal.)  */
   asm("ori r1, r0, #$1\n");
   asm("stw r1, r0, #$fffff300\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mt/exit-16-003.c b/libgloss/mt/exit-16-003.c
index ba048d9..d471d01 100644
--- a/libgloss/mt/exit-16-003.c
+++ b/libgloss/mt/exit-16-003.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,4 +10,5 @@ void _exit (n)
      the simulator. (The simulator will return a SIGQUIT signal.)  */
   asm("ori r1, r0, #$1\n");
   asm("stw r1, r0, #$fffff300\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mt/exit-64-001.c b/libgloss/mt/exit-64-001.c
index 97c7b8c..4bf5cb0 100644
--- a/libgloss/mt/exit-64-001.c
+++ b/libgloss/mt/exit-64-001.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,4 +10,5 @@ void _exit (n)
      the simulator. (The simulator will return a SIGQUIT signal.)  */
   asm("ori r1, r0, #$1\n");
   asm("stw r1, r0, #$300\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mt/exit-ms2.c b/libgloss/mt/exit-ms2.c
index 93a3f85..60566b4 100644
--- a/libgloss/mt/exit-ms2.c
+++ b/libgloss/mt/exit-ms2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,4 +10,5 @@ void _exit (n)
   // the simulator. (The simulator will return a SIGQUIT signal.)
   asm("ori r1, r0, #$1\n");
   asm("stw r1, r0, #$fffff300\n");
+  __A_VARIABLE = 1;
 }  // exit
diff --git a/libgloss/mt/exit.c b/libgloss/mt/exit.c
index cc7983b..83d2392 100644
--- a/libgloss/mt/exit.c
+++ b/libgloss/mt/exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,4 +8,5 @@
 void _exit (n)
 {
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/mt/fstat.c b/libgloss/mt/fstat.c
index 1d7d2dc..f6cb53f 100644
--- a/libgloss/mt/fstat.c
+++ b/libgloss/mt/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/mt/getpid.c b/libgloss/mt/getpid.c
index 8d686b8..9b31b38 100644
--- a/libgloss/mt/getpid.c
+++ b/libgloss/mt/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -6,5 +7,6 @@
 
 getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/mt/gettime.c b/libgloss/mt/gettime.c
index 1a04267..9600e7a 100644
--- a/libgloss/mt/gettime.c
+++ b/libgloss/mt/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/libgloss/mt/isatty.c b/libgloss/mt/isatty.c
index 0930a53..2223286 100644
--- a/libgloss/mt/isatty.c
+++ b/libgloss/mt/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mt/kill.c b/libgloss/mt/kill.c
index e8ea437..4c28844 100644
--- a/libgloss/mt/kill.c
+++ b/libgloss/mt/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/mt/lseek.c b/libgloss/mt/lseek.c
index 7839091..4701e19 100644
--- a/libgloss/mt/lseek.c
+++ b/libgloss/mt/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -10,5 +11,6 @@ lseek (int file,
 	off_t ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/mt/open.c b/libgloss/mt/open.c
index d727bdd..8d73f88 100644
--- a/libgloss/mt/open.c
+++ b/libgloss/mt/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 open (const char *path, int flags, int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, mode);
 }
diff --git a/libgloss/mt/read.c b/libgloss/mt/read.c
index e7f37fa..727b717 100644
--- a/libgloss/mt/read.c
+++ b/libgloss/mt/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ read (int file,
        char *ptr,
        size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/mt/sbrk.c b/libgloss/mt/sbrk.c
index 1f959c0..814b94e 100644
--- a/libgloss/mt/sbrk.c
+++ b/libgloss/mt/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -20,5 +21,6 @@ sbrk (size_t incr)
   prev_heap_end = heap_end;
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/mt/stat.c b/libgloss/mt/stat.c
index 4f1da73..8e22fbd 100644
--- a/libgloss/mt/stat.c
+++ b/libgloss/mt/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@ int
 stat (const char *__restrict path, struct stat *__restrict st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/mt/time.c b/libgloss/mt/time.c
index 2df8d48..af74345 100644
--- a/libgloss/mt/time.c
+++ b/libgloss/mt/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/libgloss/mt/times.c b/libgloss/mt/times.c
index b804be4..240b40f 100644
--- a/libgloss/mt/times.c
+++ b/libgloss/mt/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -8,5 +9,6 @@
 clock_t
 times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/libgloss/mt/unlink.c b/libgloss/mt/unlink.c
index a620e89..27a2a67 100644
--- a/libgloss/mt/unlink.c
+++ b/libgloss/mt/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -7,5 +8,6 @@
 int
 unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/mt/utime.c b/libgloss/mt/utime.c
index 3fce7e3..16823d5 100644
--- a/libgloss/mt/utime.c
+++ b/libgloss/mt/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/mt/write.c b/libgloss/mt/write.c
index 88b5ff8..29188f8 100644
--- a/libgloss/mt/write.c
+++ b/libgloss/mt/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -9,5 +10,6 @@ write ( int file,
 	 char *ptr,
 	 size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/open.c b/libgloss/open.c
index 468b11c..5335fb1 100644
--- a/libgloss/open.c
+++ b/libgloss/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open.c -- open a file.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -26,6 +27,7 @@ _DEFUN (open, (buf, flags, mode),
        int mode)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/or1k/boards/tmpl.c b/libgloss/or1k/boards/tmpl.c
index ffc7258..2260510 100644
--- a/libgloss/or1k/boards/tmpl.c
+++ b/libgloss/or1k/boards/tmpl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* tmpl.c -- Template for new boards.
  *
  * Copyright (c) 2014 Authors
@@ -32,9 +33,11 @@ unsigned long __attribute__((weak)) _or1k_board_uart_IRQ = 0x0;
 // TODO: Board exit function, default: loop
 void __attribute__((weak)) _or1k_board_exit(void) {
 	while (1) {}
+	__A_VARIABLE = 1;
 }
 
 // TODO: Board initialization
 void __attribute__((weak)) _or1k_board_init(void) {
+	__A_VARIABLE = 1;
 	return;
 }
diff --git a/libgloss/or1k/exceptions.c b/libgloss/or1k/exceptions.c
index 8240d09..b26bdb4 100644
--- a/libgloss/or1k/exceptions.c
+++ b/libgloss/or1k/exceptions.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "include/or1k-support.h"
 
 #include "or1k-internals.h"
@@ -18,4 +19,5 @@ void or1k_exception_handler_add(int id, or1k_exception_handler_fptr handler)
 #else
 	_or1k_exception_handler_table[id] = handler;
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/or1k/impure.c b/libgloss/or1k/impure.c
index e94fd63..9225566 100644
--- a/libgloss/or1k/impure.c
+++ b/libgloss/or1k/impure.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* impure.c. Handling of re-entrancy data structure for OpenRISC 1000.
 
    Copyright (C) 2014, Authors
@@ -100,10 +101,12 @@ _or1k_libc_impure_init (void)
 	// Set current to standard impure pointer
 	_or1k_current_impure_ptr = _impure_ptr;
 #endif
+	__A_VARIABLE = 1;
 }
 
 struct _reent*
 _or1k_libc_getreent(void) {
+	__A_VARIABLE = 1;
 	return OR1K_LIBC_GETREENT;
 }
 
@@ -120,4 +123,5 @@ _or1k_reent_init(void)
 	size_t memsize = sizeof(struct _or1k_reent) * or1k_numcores();
 	_or1k_reent = (struct _or1k_reent*) _sbrk_r(0, memsize);
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/or1k/interrupts.c b/libgloss/or1k/interrupts.c
index 6badc49..7ffd513 100644
--- a/libgloss/or1k/interrupts.c
+++ b/libgloss/or1k/interrupts.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* interrupts.c -- interrupt handling for OpenRISC 1000.
  *
  * Copyright (c) 2014 Authors
@@ -40,6 +41,7 @@ void or1k_interrupt_handler_add(uint32_t id,
 	_or1k_interrupt_handler_table[id] = handler;
 	_or1k_interrupt_handler_data_ptr_table[id] = (uint32_t) data_ptr;
 #endif
+	__A_VARIABLE = 1;
 }
 
 void
@@ -48,6 +50,7 @@ or1k_interrupts_enable(void)
 	uint32_t sr = or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	sr = OR1K_SPR_SYS_SR_IEE_SET(sr, 1);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, sr);
+	__A_VARIABLE = 1;
 }
 
 uint32_t
@@ -57,6 +60,7 @@ or1k_interrupts_disable(void)
 	oldsr= or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	newsr = OR1K_SPR_SYS_SR_IEE_SET(oldsr, 0);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, newsr);
+	__A_VARIABLE = 1;
 	return OR1K_SPR_SYS_SR_IEE_GET(oldsr);
 }
 
@@ -66,4 +70,5 @@ or1k_interrupts_restore(uint32_t sr_iee)
 	uint32_t sr = or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	sr = OR1K_SPR_SYS_SR_IEE_SET(sr, sr_iee);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, sr);
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/or1k/or1k_uart.c b/libgloss/or1k/or1k_uart.c
index 0a991e6..3bc1b19 100644
--- a/libgloss/or1k/or1k_uart.c
+++ b/libgloss/or1k/or1k_uart.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* or1k_uart.c -- UART implementation for OpenRISC 1000.
  *
  *Copyright (c) 2014 Authors
@@ -99,11 +100,13 @@ void _or1k_uart_interrupt_handler(uint32_t data)
 	// or IIR_TO
 	if (!(iir & 0x1) || ((iir & 0xfe) != IIR_RDA) ||
 	    ((iir & 0xfe) != IIR_TO)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	// Read character and call callback function
 	_or1k_uart_read_cb(REG8(RB));
+	__A_VARIABLE = 1;
 }
 
 int _or1k_uart_init(void)
@@ -112,6 +115,7 @@ int _or1k_uart_init(void)
 
 	// Is uart present?
 	if (!_or1k_board_uart_base) {
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
@@ -138,6 +142,7 @@ int _or1k_uart_init(void)
 	// Disable all interrupts
 	REG8(IER) = 0;
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -148,6 +153,7 @@ void _or1k_uart_write(char c)
 
 	// Write character to device
 	REG8(THR) = c;
+	__A_VARIABLE = 1;
 }
 
 void or1k_uart_set_read_cb(void (*cb)(char c))
@@ -164,4 +170,5 @@ void or1k_uart_set_read_cb(void (*cb)(char c))
 
 	// Enable UART interrupt
 	or1k_interrupt_enable(_or1k_board_uart_IRQ);
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/or1k/sbrk.c b/libgloss/or1k/sbrk.c
index 0c3e66e..9212f62 100644
--- a/libgloss/or1k/sbrk.c
+++ b/libgloss/or1k/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate space on heap on OpenRISC 1000.
  *
  * Copyright (c) 2014 Authors
@@ -49,5 +50,6 @@ _sbrk_r (struct _reent * reent, ptrdiff_t incr)
 	or1k_timer_restore(sr_tee);
 	or1k_interrupts_restore(sr_iee);
 
+	__A_VARIABLE = 1;
 	return (void*) prev_heap_end;
 }
diff --git a/libgloss/or1k/syscalls.c b/libgloss/or1k/syscalls.c
index 92bff49..de39e08 100644
--- a/libgloss/or1k/syscalls.c
+++ b/libgloss/or1k/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* syscalls.c -- reentrant syscalls for OpenRISC 1000.
  *
  * Copyright (c) 2011, 2014 Authors
@@ -39,6 +40,7 @@ _write_r(struct _reent * reent, int fd, const void *buf, size_t nbytes)
 		}
 		_or1k_outbyte (*(b + i));
 	}
+	__A_VARIABLE = 1;
 	return (nbytes);
 }
 
@@ -47,12 +49,14 @@ _exit(int rc)
 {
 	_or1k_board_exit();
 	while (1) {}
+	__A_VARIABLE = 1;
 }
 
 int
 _close_r(struct _reent *reent, int fildes)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -61,6 +65,7 @@ _execve_r(struct _reent *reent, const char *name, char * const *argv,
 		char * const *env)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -68,6 +73,7 @@ int
 _fork_r(struct _reent *reent)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -75,6 +81,7 @@ int
 _fstat_r(struct _reent *reent, int fildes, struct stat *st)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -82,6 +89,7 @@ int
 _getpid_r(struct _reent *reent)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -89,6 +97,7 @@ int
 _gettimeofday(struct _reent *reent, struct timeval  *ptimeval, void *ptimezone)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -96,6 +105,7 @@ int
 _isatty_r(struct _reent *reent, int file)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -103,6 +113,7 @@ int
 _kill_r(struct _reent *reent, int pid, int sig)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -110,6 +121,7 @@ int
 _link_r(struct _reent *reent, const char *existing, const char *new)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -117,6 +129,7 @@ _off_t
 _lseek_r(struct _reent *reent, int file, _off_t ptr, int dir)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -124,6 +137,7 @@ int
 _open_r(struct _reent *reent, const char *file, int flags, int mode)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -131,6 +145,7 @@ _ssize_t
 _read_r(struct _reent *reent, int file, void *ptr, size_t len)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -138,6 +153,7 @@ int
 _readlink_r(struct _reent *reent, const char *path, char *buf, size_t bufsize)
 {
 	reent->_errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -145,6 +161,7 @@ int
 _stat_r(struct _reent *reent, const char *path, struct stat *buf)
 {
 	reent->_errno = EIO;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -152,6 +169,7 @@ int
 _unlink_r(struct _reent *reent, const char * path)
 {
 	reent->_errno = EIO;
+	__A_VARIABLE = 1;
 	return (-1);
 }
 
diff --git a/libgloss/or1k/timer.c b/libgloss/or1k/timer.c
index db45d3a..52fe03e 100644
--- a/libgloss/or1k/timer.c
+++ b/libgloss/or1k/timer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* timer.c -- tick timer functions for OpenRISC 1000.
  *
  * Copyright (c) 2011, 2014 Authors
@@ -37,6 +38,7 @@ _or1k_timer_interrupt_handler(void)
 	ttmr = OR1K_SPR_TICK_TTMR_MODE_SET(ttmr, OR1K_SPR_TICK_TTMR_MODE_RESTART);
 	ttmr = OR1K_SPR_TICK_TTMR_IP_SET(ttmr, 0);
 	or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
+	__A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------*/
@@ -51,6 +53,7 @@ or1k_timer_init(unsigned int hz)
 {
 	uint32_t upr = or1k_mfspr(OR1K_SPR_SYS_UPR_ADDR);
 	if (OR1K_SPR_SYS_UPR_TTP_GET(upr) == 0) {
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
@@ -69,6 +72,7 @@ or1k_timer_init(unsigned int hz)
 	/* Reset counter register */
 	or1k_mtspr(OR1K_SPR_TICK_TTCR_ADDR, 0);
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -80,12 +84,14 @@ or1k_timer_set_period(uint32_t hz)
 	ttmr = OR1K_SPR_TICK_TTMR_TP_SET(ttmr, period);
 	or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
 	OR1K_REENT.or1k_timer_period = period;
+	__A_VARIABLE = 1;
 }
 
 void
 or1k_timer_set_handler(void (*handler)(void))
 {
 	or1k_exception_handler_add(0x5, handler);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -100,6 +106,7 @@ or1k_timer_set_mode(uint32_t mode)
 		ttmr = OR1K_SPR_TICK_TTMR_MODE_SET(ttmr, mode);
 		or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
 	}
+	__A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------*/
@@ -119,6 +126,7 @@ or1k_timer_enable(void)
 	uint32_t sr = or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	sr = OR1K_SPR_SYS_SR_TEE_SET(sr, 1);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, sr);
+	__A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------*/
@@ -133,6 +141,7 @@ or1k_timer_disable(void)
 	uint32_t oldsr = or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	uint32_t sr = OR1K_SPR_SYS_SR_TEE_SET(oldsr, 0);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, sr);
+	__A_VARIABLE = 1;
 	return OR1K_SPR_SYS_SR_TEE_GET(oldsr);
 }
 
@@ -142,6 +151,7 @@ or1k_timer_restore(uint32_t sr_tee)
 	uint32_t sr = or1k_mfspr(OR1K_SPR_SYS_SR_ADDR);
 	sr = OR1K_SPR_SYS_SR_TEE_SET(sr, sr_tee);
 	or1k_mtspr(OR1K_SPR_SYS_SR_ADDR, sr);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -150,6 +160,7 @@ or1k_timer_pause(void)
 	uint32_t ttmr = or1k_mfspr(OR1K_SPR_TICK_TTMR_ADDR);
 	ttmr = OR1K_SPR_TICK_TTMR_MODE_SET(ttmr, OR1K_SPR_TICK_TTMR_MODE_DISABLE);
 	or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -159,6 +170,7 @@ or1k_timer_reset(void)
 	ttmr = OR1K_SPR_TICK_TTMR_IP_SET(ttmr, 0);
 	or1k_mtspr(OR1K_SPR_TICK_TTMR_ADDR, ttmr);
 	or1k_mtspr(OR1K_SPR_TICK_TTCR_ADDR, 0);
+	__A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------*/
@@ -170,6 +182,7 @@ or1k_timer_reset(void)
 unsigned long
 or1k_timer_get_ticks(void)
 {
+	__A_VARIABLE = 1;
 	return OR1K_REENT.or1k_timer_ticks;
 }
 
@@ -183,4 +196,5 @@ void
 or1k_timer_reset_ticks(void)
 {
 	OR1K_REENT.or1k_timer_ticks = 0;
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/or1k/util.c b/libgloss/or1k/util.c
index d2ee84d..79a719a 100644
--- a/libgloss/or1k/util.c
+++ b/libgloss/or1k/util.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* util.c -- Utility functions for OpenRISC 1000.
  *
  * Copyright (c) 2014 Authors
@@ -82,16 +83,19 @@ void _or1k_init() {
 #else
 	_or1k_exception_level = 0;
 #endif
+	__A_VARIABLE = 1;
 }
 
 uint32_t or1k_critical_begin() {
 	uint32_t iee = or1k_interrupts_disable();
 	uint32_t tee = or1k_timer_disable();
+	__A_VARIABLE = 1;
 	return (iee << 1) | tee;
 }
 
 void or1k_critical_end(uint32_t restore) {
 	or1k_timer_restore(restore & 0x1);
 	or1k_interrupts_restore((restore >> 1) & 0x1);
+	__A_VARIABLE = 1;
 }
 
diff --git a/libgloss/pa/op50nled.c b/libgloss/pa/op50nled.c
index b6b35be..af0d428 100644
--- a/libgloss/pa/op50nled.c
+++ b/libgloss/pa/op50nled.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* op50nled.c -- fucntions that manipulate the LEDs.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -42,6 +43,7 @@ zylons()
   while (1) {
     strobe();
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -69,6 +71,7 @@ strobe()
   }
   curled = 1;
   dir = 0;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -78,4 +81,5 @@ delay (x)
   int  y = 17;
   while (x-- !=0)
     y = y^2;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/pa/test.c b/libgloss/pa/test.c
index 4aefee6..9dcf72e 100644
--- a/libgloss/pa/test.c
+++ b/libgloss/pa/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995 Cygnus Support
  *
  * The authors hereby grant permission to use, copy, modify, distribute,
@@ -38,4 +39,5 @@ main()
   printf ("Print float, result with 'G' = %G\n", c1);
   fflush (stdout);
   print ("Done...\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/pa/w89k-io.c b/libgloss/pa/w89k-io.c
index 2d98a81..ecb5342 100644
--- a/libgloss/pa/w89k-io.c
+++ b/libgloss/pa/w89k-io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* w89k-io.c -- I/O code for the Winbond Cougar board.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -29,6 +30,7 @@ outbyte (byte)
 
   outp (COM1_DATA, byte);
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -40,6 +42,7 @@ inbyte ()
 {
   while ((inp(COM1_LSR) & RECEIVE) == 0x0) ;
 
+  __A_VARIABLE = 1;
   return (inp(COM1_DATA));
 }
 
@@ -62,6 +65,7 @@ void
 zylons()
 {
   print ("Sorry, no LED's on the WinBond W89k board\r\n");
+  __A_VARIABLE = 1;
 }
 
 void
@@ -71,4 +75,5 @@ delay (x)
   int  y = 17;
   while (x-- !=0)
     y = y^2;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/print.c b/libgloss/print.c
index 8f78ff2..85bc29e 100644
--- a/libgloss/print.c
+++ b/libgloss/print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* print.c -- print a string on the output device.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -24,4 +25,5 @@ char *ptr)
   while (*ptr) {
     outbyte (*ptr++);
   }
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/putnum.c b/libgloss/putnum.c
index 842e10f..64b65a2 100644
--- a/libgloss/putnum.c
+++ b/libgloss/putnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* putnum.c -- put a hex number on the output device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -38,4 +39,5 @@ _DEFUN (putnum, (num),
 
   *ptr = (char) 0;
   print (buf);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/read.c b/libgloss/read.c
index 419a8ed..f4a48d3 100644
--- a/libgloss/read.c
+++ b/libgloss/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read.c -- read bytes from a input device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -35,5 +36,6 @@ _DEFUN (read, (fd, buf, nbytes),
       break;
     }
   }
+  __A_VARIABLE = 1;
   return (i);
 }
diff --git a/libgloss/riscv/syscalls.c b/libgloss/riscv/syscalls.c
index f9ec25d..da6b96c 100644
--- a/libgloss/riscv/syscalls.c
+++ b/libgloss/riscv/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
@@ -76,6 +77,7 @@ long
 __syscall_error(long a0)
 {
   errno = -a0;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -83,6 +85,7 @@ __syscall_error(long a0)
 int
 _open(const char *name, int flags, int mode)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_open, name, flags, mode, 0);
 }
 
@@ -90,6 +93,7 @@ _open(const char *name, int flags, int mode)
 int
 _openat(int dirfd, const char *name, int flags, int mode)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_openat, dirfd, name, flags, mode);
 }
 
@@ -97,6 +101,7 @@ _openat(int dirfd, const char *name, int flags, int mode)
 off_t
 _lseek(int file, off_t ptr, int dir)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_lseek, file, ptr, dir, 0);
 }
 
@@ -104,6 +109,7 @@ _lseek(int file, off_t ptr, int dir)
 ssize_t
 _read(int file, void *ptr, size_t len)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_read, file, ptr, len, 0);
 }
 
@@ -111,6 +117,7 @@ _read(int file, void *ptr, size_t len)
 ssize_t
 _write(int file, const void *ptr, size_t len)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_write, file, ptr, len, 0);
 }
 
@@ -151,6 +158,7 @@ conv_stat (struct stat *st, struct kernel_stat *kst)
   st->st_atime = kst->st_atim.tv_sec;
   st->st_mtime = kst->st_mtim.tv_sec;
   st->st_ctime = kst->st_ctim.tv_sec;
+  __A_VARIABLE = 1;
 }
 
 /* Status of an open file. The sys/stat.h header file required is
@@ -161,6 +169,7 @@ _fstat(int file, struct stat *st)
   struct kernel_stat kst;
   int rv = syscall_errno (SYS_fstat, file, &kst, 0, 0);
   conv_stat (st, &kst);
+  __A_VARIABLE = 1;
   return rv;
 }
 
@@ -171,6 +180,7 @@ _stat(const char *file, struct stat *st)
   struct kernel_stat kst;
   int rv = syscall_errno (SYS_stat, file, &kst, 0, 0);
   conv_stat (st, &kst);
+  __A_VARIABLE = 1;
   return rv;
 }
 
@@ -181,6 +191,7 @@ _lstat(const char *file, struct stat *st)
   struct kernel_stat kst;
   int rv = syscall_errno (SYS_lstat, file, &kst, 0, 0);
   conv_stat (st, &kst);
+  __A_VARIABLE = 1;
   return rv;
 }
 
@@ -191,6 +202,7 @@ _fstatat(int dirfd, const char *file, struct stat *st, int flags)
   struct kernel_stat kst;
   int rv = syscall_errno (SYS_fstatat, dirfd, file, &kst, flags);
   conv_stat (st, &kst);
+  __A_VARIABLE = 1;
   return rv;
 }
 
@@ -198,6 +210,7 @@ _fstatat(int dirfd, const char *file, struct stat *st, int flags)
 int
 _access(const char *file, int mode)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_access, file, mode, 0, 0);
 }
 
@@ -205,6 +218,7 @@ _access(const char *file, int mode)
 int
 _faccessat(int dirfd, const char *file, int mode, int flags)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_faccessat, dirfd, file, mode, flags);
 }
 
@@ -212,6 +226,7 @@ _faccessat(int dirfd, const char *file, int mode, int flags)
 int
 _close(int file)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_close, file, 0, 0, 0);
 }
 
@@ -219,6 +234,7 @@ _close(int file)
 int
 _link(const char *old_name, const char *new_name)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_link, old_name, new_name, 0, 0);
 }
 
@@ -226,6 +242,7 @@ _link(const char *old_name, const char *new_name)
 int
 _unlink(const char *name)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_unlink, name, 0, 0, 0);
 }
 
@@ -235,6 +252,7 @@ int
 _execve(const char *name, char *const argv[], char *const env[])
 {
   errno = ENOMEM;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -245,6 +263,7 @@ int
 _fork()
 {
   errno = EAGAIN;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -255,6 +274,7 @@ _fork()
 int
 _getpid()
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -265,6 +285,7 @@ int
 _kill(int pid, int sig)
 {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -275,6 +296,7 @@ int
 _wait(int *status)
 {
   errno = ECHILD;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -287,6 +309,7 @@ _isatty(int file)
 {
   struct stat s;
   int ret = _fstat (file, &s);
+  __A_VARIABLE = 1;
   return ret == -1 ? -1 : !!(s.st_mode & S_IFCHR);
 }
 
@@ -295,6 +318,7 @@ _isatty(int file)
 int
 _gettimeofday(struct timeval *tp, void *tz)
 {
+  __A_VARIABLE = 1;
   return syscall_errno (SYS_gettimeofday, tp, 0, 0, 0);
 }
 
@@ -325,6 +349,7 @@ _times(struct tms *buf)
   buf->tms_utime = utime * CLOCKS_PER_SEC / 1000000;
   buf->tms_stime = buf->tms_cstime = buf->tms_cutime = 0;
 
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -333,6 +358,7 @@ int
 _ftime(struct timeb *tp)
 {
   tp->time = tp->millitm = 0;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -340,6 +366,7 @@ _ftime(struct timeb *tp)
 int
 _utime(const char *path, const struct utimbuf *times)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -347,6 +374,7 @@ _utime(const char *path, const struct utimbuf *times)
 int
 _chown(const char *path, uid_t owner, gid_t group)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -354,6 +382,7 @@ _chown(const char *path, uid_t owner, gid_t group)
 int
 _chmod(const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -361,6 +390,7 @@ _chmod(const char *path, mode_t mode)
 int
 _chdir(const char *path)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -368,6 +398,7 @@ _chdir(const char *path)
 char *
 _getcwd(char *buf, size_t size)
 {
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -379,9 +410,11 @@ _sysconf(int name)
   switch (name)
     {
     case _SC_CLK_TCK:
+      __A_VARIABLE = 1;
       return CLOCKS_PER_SEC;
     }
 
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -397,15 +430,20 @@ _sbrk(ptrdiff_t incr)
   if (heap_end == 0)
     {
       long brk = syscall_errno (SYS_brk, 0, 0, 0, 0);
-      if (brk == -1)
+      if (brk == -1) {
+	__A_VARIABLE = 1;
 	return (void *)-1;
+      }
       heap_end = brk;
     }
 
-  if (syscall_errno (SYS_brk, heap_end + incr, 0, 0, 0) != heap_end + incr)
+  if (syscall_errno (SYS_brk, heap_end + incr, 0, 0, 0) != heap_end + incr) {
+    __A_VARIABLE = 1;
     return (void *)-1;
+  }
 
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (void *)(heap_end - incr);
 }
 
@@ -416,4 +454,5 @@ _exit(int exit_status)
 {
   syscall_errno (SYS_exit, exit_status, 0, 0, 0);
   while (1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/rl78/mcount.c b/libgloss/rl78/mcount.c
index 567abd0..246bb55 100644
--- a/libgloss/rl78/mcount.c
+++ b/libgloss/rl78/mcount.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1983, 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -184,8 +185,10 @@ _mcount_internal (unsigned long frompc)
 
   /* Check that we are profiling and that we aren't recursively invoked.
      NB/ This version is not thread-safe.  */
-  if (p->state != GMON_PROF_ON)
+  if (p->state != GMON_PROF_ON) {
+    __A_VARIABLE = 1;
     return;
+  }
   p->state = GMON_PROF_BUSY;
 
   /* Check that frompcindex is a reasonable pc value.
@@ -268,10 +271,12 @@ _mcount_internal (unsigned long frompc)
 
  done:
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
   return;
 
  overflow:
   p->state = GMON_PROF_ERROR;
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -310,6 +315,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
       write (2, "monstartup: out of memory\n", 26);
       p->tos = NULL;
       p->state = GMON_PROF_ERROR;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -321,6 +327,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
 
   p->tos[0].link = 0;
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
 }
 
 
@@ -419,4 +426,5 @@ _mcleanup (void)
       free (_gmonparam.tos);
       _gmonparam.tos = NULL;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/rl78/sbrk.c b/libgloss/rl78/sbrk.c
index acff713..3206b27 100644
--- a/libgloss/rl78/sbrk.c
+++ b/libgloss/rl78/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 
 Copyright (c) 2005, 2009 Red Hat Incorporated.
@@ -48,9 +49,11 @@ _sbrk (int adj)
       || heap < rv)
     {
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return (char *) -1;
     }
 
+  __A_VARIABLE = 1;
   return rv;
 }
 
diff --git a/libgloss/rl78/write.c b/libgloss/rl78/write.c
index 849470c..c38b94e 100644
--- a/libgloss/rl78/write.c
+++ b/libgloss/rl78/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 
 Copyright (c) 2010 Red Hat Incorporated.
@@ -73,6 +74,7 @@ init_uart0 ()
   P(1)  |= 0b00000100;
   PM(1) &= 0b11111011;
   SS0 = 0x0001;
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -83,6 +85,7 @@ tputc (char c)
     asm("");
   /* Transmit that byte.  */
   SDR00 = c;
+  __A_VARIABLE = 1;
 }
 
 /* defaults to 0 unless open() is linked in */
@@ -93,8 +96,10 @@ _write(int fd, char *ptr, int len)
 {
   int rv = len;
 
-  if (_open_present && fd > 2)
+  if (_open_present && fd > 2) {
+    __A_VARIABLE = 1;
     return _SYS_write (fd, ptr, len);
+  }
 
   if (!initted)
     init_uart0 ();
@@ -105,6 +110,7 @@ _write(int fd, char *ptr, int len)
       ptr ++;
       len --;
     }
+  __A_VARIABLE = 1;
   return rv;
 }
 
diff --git a/libgloss/rs6000/ads-io.c b/libgloss/rs6000/ads-io.c
index d57b297..019c2ed 100644
--- a/libgloss/rs6000/ads-io.c
+++ b/libgloss/rs6000/ads-io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ads-io.c -- stub io functions for targets using the sds monitor
  *
@@ -16,12 +17,14 @@
 
 int inbyte(void)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 
 void outbyte(char c)
 {
+	__A_VARIABLE = 1;
 }
 
 
@@ -32,6 +35,7 @@ void outbyte(char c)
 int
 write (int fd, char *ptr, unsigned len)
 {
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -42,6 +46,7 @@ write (int fd, char *ptr, unsigned len)
 void
 print (char *ptr)
 {
+	__A_VARIABLE = 1;
 }
 
 
@@ -51,5 +56,6 @@ print (char *ptr)
  */
 int read (int fd, char *buf, int nbytes)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/rs6000/mbx-exit.c b/libgloss/rs6000/mbx-exit.c
index d295414..853638a 100644
--- a/libgloss/rs6000/mbx-exit.c
+++ b/libgloss/rs6000/mbx-exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * mbx-exit.c -- exit function for targets using the eppcbug monitor
  *
@@ -22,6 +23,7 @@ void _exit(int stat)
 
     while (1) ;
 
+    __A_VARIABLE = 1;
     return;
 }
 
diff --git a/libgloss/rs6000/mbx-inbyte.c b/libgloss/rs6000/mbx-inbyte.c
index bd06aa0..259bb93 100644
--- a/libgloss/rs6000/mbx-inbyte.c
+++ b/libgloss/rs6000/mbx-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * mbx-inbyte.c -- inbyte function for targets using the eppcbug monitor
  *
@@ -53,8 +54,11 @@ int inbyte(void)
 	);
     } while (outpb->status == 0 && outpb->cnt == 0);
 
-    if (outpb->status == 0)
+    if (outpb->status == 0) {
+	__A_VARIABLE = 1;
 	return ipb.buf[0] & 0xff;
+    }
 
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/libgloss/rs6000/mbx-outbyte.c b/libgloss/rs6000/mbx-outbyte.c
index 0ebf0c6..749841d 100644
--- a/libgloss/rs6000/mbx-outbyte.c
+++ b/libgloss/rs6000/mbx-outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * mbx-outbyte.c -- outbyte function for targets using the eppcbug monitor
  *
@@ -52,6 +53,7 @@ static int sendbyte(char c)
 	: "3", "4", "10"
     );
 
+    __A_VARIABLE = 1;
     return (outpb->status == 0 && outpb->cnt == 1);
 }
 
@@ -66,6 +68,7 @@ void outbyte(char c)
     while (!sendbyte('\017')) ;
 #endif
     while (!sendbyte(c)) ;
+    __A_VARIABLE = 1;
 }
 
 
diff --git a/libgloss/rs6000/mbx-print.c b/libgloss/rs6000/mbx-print.c
index 64472ee..15502ea 100644
--- a/libgloss/rs6000/mbx-print.c
+++ b/libgloss/rs6000/mbx-print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* mbx-print.c -- print a string on the output device.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -27,5 +28,6 @@ print (ptr)
     p++;
 
   write (1, ptr, p-ptr);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/rs6000/mvme-errno.c b/libgloss/rs6000/mvme-errno.c
index 17386d8..bc3043d 100644
--- a/libgloss/rs6000/mvme-errno.c
+++ b/libgloss/rs6000/mvme-errno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-errno.c -- return address of errno for current thread.
  *
@@ -19,5 +20,6 @@ int errno;
 int *
 __errno ()
 {
+  __A_VARIABLE = 1;
   return &errno;
 }
diff --git a/libgloss/rs6000/mvme-print.c b/libgloss/rs6000/mvme-print.c
index 8d19542..44c99d9 100644
--- a/libgloss/rs6000/mvme-print.c
+++ b/libgloss/rs6000/mvme-print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* mvme-print.c -- print a string on the output device.
  *
  * Copyright (c) 1996 Cygnus Support
@@ -55,6 +56,7 @@ write (fd, ptr, len)
 	    }
 	}
     }
+  __A_VARIABLE = 1;
   return len;
 }
 
@@ -73,4 +75,5 @@ print (ptr)
     p++;
 
   write (1, ptr, p-ptr);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/rs6000/mvme-read.c b/libgloss/rs6000/mvme-read.c
index 1c823b4..3851e21 100644
--- a/libgloss/rs6000/mvme-read.c
+++ b/libgloss/rs6000/mvme-read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* mvme-read.c -- read bytes from a input device.
  * 
  * Copyright (c) 1996 Cygnus Support
diff --git a/libgloss/rs6000/sim-abort.c b/libgloss/rs6000/sim-abort.c
index e1b59cf..e522221 100644
--- a/libgloss/rs6000/sim-abort.c
+++ b/libgloss/rs6000/sim-abort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-abort.c -- PowerPC abort support when running under the simulator.
  *
@@ -18,4 +19,5 @@ void abort(void)
 {
   write (2, "Abort called.\n", sizeof("Abort called.\n")-1);
   exit (1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/rs6000/sim-errno.c b/libgloss/rs6000/sim-errno.c
index 29cb4a2..3538dbf 100644
--- a/libgloss/rs6000/sim-errno.c
+++ b/libgloss/rs6000/sim-errno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-errno.c -- return address of errno for current thread.
  *
@@ -24,5 +25,6 @@ _cerror (e)
      int e;
 {
   _REENT->_errno = e;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/rs6000/sim-inbyte.c b/libgloss/rs6000/sim-inbyte.c
index 787b689..3a8e388 100644
--- a/libgloss/rs6000/sim-inbyte.c
+++ b/libgloss/rs6000/sim-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-inbyte.c -- read a character from standard input.
  *
@@ -19,8 +20,11 @@ inbyte ()
 {
   char c;
 
-  if (read (0, &c, 1) <= 0)
+  if (read (0, &c, 1) <= 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return c;
 }
diff --git a/libgloss/rs6000/sim-print.c b/libgloss/rs6000/sim-print.c
index c0b9adc..5861cb6 100644
--- a/libgloss/rs6000/sim-print.c
+++ b/libgloss/rs6000/sim-print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-print.c -- print a string on the output device.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -27,6 +28,7 @@ print (ptr)
     p++;
 
   write (1, ptr, p-ptr);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -40,4 +42,5 @@ outbyte (c_int)
   char c = c_int;
 
   write (1, &c, 1);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/rs6000/sim-sbrk.c b/libgloss/rs6000/sim-sbrk.c
index 5c8bd65..2b87adf 100644
--- a/libgloss/rs6000/sim-sbrk.c
+++ b/libgloss/rs6000/sim-sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * sim-sbrk.c -- PowerPC sbrk support when running under the simulator.
  *
@@ -23,8 +24,11 @@ sbrk (incr)
 {
   char *oldbrk = curbrk;
   curbrk += incr;
-  if (brk (curbrk) == -1)
+  if (brk (curbrk) == -1) {
+    __A_VARIABLE = 1;
     return (char *) -1;
+  }
 
+  __A_VARIABLE = 1;
   return oldbrk;
 }
diff --git a/libgloss/rs6000/sim-times.c b/libgloss/rs6000/sim-times.c
index 171ab15..4b2c55e 100644
--- a/libgloss/rs6000/sim-times.c
+++ b/libgloss/rs6000/sim-times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sim-times.c - times support routines for PowerPC.
  *
  * Written by Aldy Hernandez.
@@ -36,5 +37,6 @@ times (struct tms *tp)
       tp->tms_cstime = 0;	/* system time, children */
     }
 
+  __A_VARIABLE = 1;
   return tp->tms_utime;
 }
diff --git a/libgloss/rs6000/sol-cfuncs.c b/libgloss/rs6000/sol-cfuncs.c
index 9827167..a4b1237 100644
--- a/libgloss/rs6000/sol-cfuncs.c
+++ b/libgloss/rs6000/sol-cfuncs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * solaris-cfuncs.S -- C functions for Solaris.
  *
@@ -95,6 +96,7 @@ trace (msg)
     ;
 
   (void) write (2, msg, p-msg);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -113,6 +115,7 @@ trace1 (msg, num)
     num /= 10;
   } while (num != 0); 
   trace (p);  
+  __A_VARIABLE = 1;
 }
 
 #else
@@ -128,6 +131,7 @@ int errno;
 int *
 __errno ()
 {
+  __A_VARIABLE = 1;
   return &errno;
 }
 
@@ -140,6 +144,7 @@ _cerror (e)
 {
   TRACE1("got to _cerror ",e);
   errno = e;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -156,9 +161,12 @@ sbrk (incr)
   char *oldbrk = curbrk;
   TRACE("got to sbrk\n");
   curbrk += incr;
-  if (brk (curbrk) == -1)
+  if (brk (curbrk) == -1) {
+    __A_VARIABLE = 1;
     return (char *) -1;
+  }
 
+  __A_VARIABLE = 1;
   return (void *)oldbrk;
 }
 
@@ -175,6 +183,7 @@ isatty (fd)
   ret = (ioctl (fd, SOLARIS_TCGETS, &t) == 0);
 
   TRACE1("got to isatty, returned ", ret);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -203,6 +212,7 @@ solaris_to_newlib_stat (solaris, newlib)
   newlib->st_atime   = solaris->st_atim.tv_sec;
   newlib->st_mtime   = solaris->st_mtim.tv_sec;
   newlib->st_ctime   = solaris->st_ctim.tv_sec;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -218,6 +228,7 @@ stat (file, newlib_stat)
   if (ret >= 0)
     solaris_to_newlib_stat (&st, newlib_stat);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -234,6 +245,7 @@ lstat (file, newlib_stat)
   if (ret >= 0)
     solaris_to_newlib_stat (&st, newlib_stat);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -250,6 +262,7 @@ fstat (fd, newlib_stat)
   if (ret >= 0)
     solaris_to_newlib_stat (&st, newlib_stat);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -260,6 +273,7 @@ int
 getrusage ()
 {
   _cerror (EINVAL);
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -268,10 +282,13 @@ getcwd(buf, size)
      char *buf;
      size_t size;
 {
-  if (!buf || size < 2)
+  if (!buf || size < 2) {
+    __A_VARIABLE = 1;
     return ".";
+  }
 
   buf[0] = '.';
   buf[1] = '\0';
+  __A_VARIABLE = 1;
   return buf;
 }
diff --git a/libgloss/rs6000/test.c b/libgloss/rs6000/test.c
index f8f8ea1..b6ab93e 100644
--- a/libgloss/rs6000/test.c
+++ b/libgloss/rs6000/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int led_putnum();
 extern char putDebugChar(),print(),putnum(); 
 
@@ -20,4 +21,5 @@ main()
   
   /* whew, we made it */
   print ("\r\nDone...");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/rx/mcount.c b/libgloss/rx/mcount.c
index 4a72fe1..8982c1c 100644
--- a/libgloss/rx/mcount.c
+++ b/libgloss/rx/mcount.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1983, 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -184,8 +185,10 @@ _mcount_internal (unsigned long frompc)
 
   /* Check that we are profiling and that we aren't recursively invoked.
      NB/ This version is not thread-safe.  */
-  if (p->state != GMON_PROF_ON)
+  if (p->state != GMON_PROF_ON) {
+    __A_VARIABLE = 1;
     return;
+  }
   p->state = GMON_PROF_BUSY;
 
   /* Check that frompcindex is a reasonable pc value.
@@ -268,10 +271,12 @@ _mcount_internal (unsigned long frompc)
 
  done:
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
   return;
 
  overflow:
   p->state = GMON_PROF_ERROR;
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -310,6 +315,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
       write (2, "monstartup: out of memory\n", 26);
       p->tos = NULL;
       p->state = GMON_PROF_ERROR;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -321,6 +327,7 @@ _monstartup (unsigned long lowpc, unsigned long highpc)
 
   p->tos[0].link = 0;
   p->state = GMON_PROF_ON;
+  __A_VARIABLE = 1;
 }
 
 
@@ -419,4 +426,5 @@ _mcleanup (void)
       free (_gmonparam.tos);
       _gmonparam.tos = NULL;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/rx/sbrk.c b/libgloss/rx/sbrk.c
index 48d26bf..51d6643 100644
--- a/libgloss/rx/sbrk.c
+++ b/libgloss/rx/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 
 Copyright (c) 2005, 2009 Red Hat Incorporated.
@@ -41,6 +42,7 @@ _sbrk (int adj)
 
   heap += adj;
   __set_heaptop (heap);
+  __A_VARIABLE = 1;
   return rv;
 }
 
diff --git a/libgloss/sbrk.c b/libgloss/sbrk.c
index c222b4b..2b44499 100644
--- a/libgloss/sbrk.c
+++ b/libgloss/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- allocate memory dynamically.
  * 
  * Copyright (c) 1995,1996 Cygnus Support
@@ -38,6 +39,7 @@ sbrk (nbytes)
   base = heap_ptr;
   heap_ptr += nbytes;
 
+  __A_VARIABLE = 1;
   return base;
 /* FIXME: We really want to make sure we don't run out of RAM, but this
  *       isn't very portable.
diff --git a/libgloss/sparc/cache.c b/libgloss/sparc/cache.c
index 5b6e270..7b61d41 100644
--- a/libgloss/sparc/cache.c
+++ b/libgloss/sparc/cache.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Cache code for SPARClite
  *
  * Copyright (c) 1998 Cygnus Support
@@ -55,6 +56,7 @@ is_danlite ()
       danlite = (psr & 0xff000000) == 0x1e000000;
       checked = 1;
     }
+  __A_VARIABLE = 1;
   return danlite;
 }
 
@@ -76,6 +78,7 @@ cache_off ()
     {
       write_asi (1, 0, 0);
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -114,6 +117,7 @@ cache_on ()
       write_asi (1, 0, 0x35);	/* Write buf ena, prefetch buf ena, data
 				       & inst caches enab */
     }
+    __A_VARIABLE = 1;
 }
 
 /* Flush the instruction cache.  We need to do this for the debugger stub so
diff --git a/libgloss/sparc/cygmon-salib.c b/libgloss/sparc/cygmon-salib.c
index 7bffcff..7604633 100644
--- a/libgloss/sparc/cygmon-salib.c
+++ b/libgloss/sparc/cygmon-salib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef TARGET_CPU_SPARC64
 #include <sys/types.h>
 #endif
@@ -11,6 +12,7 @@ putTtyChar(int c)
 	or %g0,2,%g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -18,11 +20,13 @@ write(int fd,char *ptr,int amt)
 {
   if (fd < 0 || fd > 2)
     {
+      __A_VARIABLE = 1;
       return -1;
     }
   asm(" or %g0, 4, %g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
   return amt;
 }
 
@@ -31,11 +35,13 @@ read(int fd,char *ptr,int amt)
 {
   if (fd < 0 || fd > 2)
     {
+      __A_VARIABLE = 1;
       return -1;
     }
   asm(" or %g0, 3, %g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
   return amt;
 }
 
@@ -49,6 +55,7 @@ _exit(int code)
 	  ta 1			\n\
 	  nop");
   }
+  __A_VARIABLE = 1;
 }
 
 int
@@ -57,6 +64,7 @@ setitimer(int which, const struct itimerval *value, struct itimerval *ovalue)
   asm(" or %g0, 158, %g1	\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 
@@ -69,13 +77,16 @@ sbrk (unsigned long amt)
   char *res;
   if (ptr == 0)
     ptr = &_end;
-  if (amt == 0)
+  if (amt == 0) {
+    __A_VARIABLE = 1;
     return (long)ptr;
+  }
 
   if (((long)ptr) % 8)
     ptr = ptr + (8 - (((long)(ptr)) % 8));
   res = ptr;
   ptr += amt;
+  __A_VARIABLE = 1;
   return (long)res;
 }
 
@@ -83,30 +94,35 @@ sbrk (unsigned long amt)
 long
 _sbrk_r (void *foo, unsigned long amt)
 {
+  __A_VARIABLE = 1;
   return sbrk(amt);
 }
 
 long
 _fstat_r (void *foo, void *bar, void *baz)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 long
 _brk_r (void *foo)
 {
+  __A_VARIABLE = 1;
   return sbrk(0);
 }
 
 int
 _open_r (char *filename, int mode)
 {
+  __A_VARIABLE = 1;
   return open (filename, mode);
 }
 
 int
 _close_r (int fd)
 {
+  __A_VARIABLE = 1;
   return close(fd);
 }
 #endif
@@ -114,24 +130,28 @@ _close_r (int fd)
 int
 close (int fd)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 fstat(int des,void *buf)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 lseek(int des,unsigned long offset, int whence)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 isatty(int fd)
 {
+  __A_VARIABLE = 1;
   return (fd < 3);
 }
 
@@ -141,11 +161,13 @@ kill (int pid, int signal)
   asm ("or %g0, 37, %g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
 getpid ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -155,6 +177,7 @@ getitimer (int which, struct itimerval *value)
   asm ("or %g0, 157, %g1	\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 void
@@ -165,6 +188,7 @@ __install_signal_handler (void *func)
 	or %g0, 48, %g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -173,6 +197,7 @@ gettimeofday (struct timeval *tp, void *tzp)
   asm ("or %g0, 156, %g1	\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -181,6 +206,7 @@ stime (long *seconds)
   asm ("or %g0, 25, %g1		\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -189,6 +215,7 @@ add_mapping (long vma, long pma, long size)
   asm ("or %g0, 115, %g1	\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -197,11 +224,13 @@ remove_mapping (long vma, long vma_end)
   asm ("or %g0, 117, %g1	\n\
 	ta 8			\n\
 	nop");
+  __A_VARIABLE = 1;
 }
 
 int
 open (char *filename, int mode)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -216,5 +245,6 @@ __getProgramArgs (int *argv)
 	ta 8			\n\
 	nop			\n\
 	mov %%o0, %0" : "=r" (res) : "r" (argv): "g1");
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/libgloss/sparc/erc32-io.c b/libgloss/sparc/erc32-io.c
index 082d9f9..83311c7 100644
--- a/libgloss/sparc/erc32-io.c
+++ b/libgloss/sparc/erc32-io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define USE_PORT_A
 
 #define RXADATA (int *) 0x01F800E0
@@ -23,6 +24,7 @@ outbyte (int c)
   while ((*rxstat & rxmask) == 0);
 
   *rxadata = c;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -43,5 +45,6 @@ inbyte (void)
 
   while ((*rxstat & rxmask) == 0);
 
+  __A_VARIABLE = 1;
   return *rxadata;
 }
diff --git a/libgloss/sparc/erc32-stub.c b/libgloss/sparc/erc32-stub.c
index 98866e3..e04d14f 100644
--- a/libgloss/sparc/erc32-stub.c
+++ b/libgloss/sparc/erc32-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 Cygnus Support
  *
@@ -94,6 +95,7 @@ exception_handler (int tt, unsigned long routine)
   tb[tt].jmpl_simm13 = routine & 0x3ff;
 
   DEBUG (1, "Leaving exception_handler()");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -116,6 +118,7 @@ set_mem_fault_trap(enable)
     exception_handler(9, (unsigned long)trap_low);
 
   DEBUG (1, "Leaving set_mem_fault_trap()");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -164,6 +167,7 @@ handle_exception (registers)
 
   /* call the main command processing loop for gdb */
   gdb_event_loop (sigval, registers);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -177,14 +181,17 @@ breakpoint()
 {
   DEBUG (1, "Entering breakpoint()");
 
-  if (!initialized)
+  if (!initialized) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   asm("	.globl " STRINGSYM(breakinst) "		\n\
 	" STRINGSYM(breakinst) ": ta 128+1	\n\
 	nop					\n\
 	nop					\n\
       ");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -231,6 +238,7 @@ int tt;
 void
 flush_i_cache ()
 {
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -241,6 +249,7 @@ target_reset()
 {
   asm ("call 0		\n\
 	nop ");
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -264,6 +273,7 @@ target_read_registers(unsigned long *registers)
 	  ptr + 32 * 4 * 2,
 	  8 * 4,
 	  0);		/* Y, PSR, WIM, TBR, PC, NPC, FPSR, CPSR */
+  __A_VARIABLE = 1;
   return (ptr);
 }
 
diff --git a/libgloss/sparc/fixctors.c b/libgloss/sparc/fixctors.c
index 484023c..1ca504e 100644
--- a/libgloss/sparc/fixctors.c
+++ b/libgloss/sparc/fixctors.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Code to byte-swap static constructor/destructor tables on
    broken a.out little-endian targets. The startup code should call
    __fix_ctors just before calling main.  It is safe to use on non-broken
@@ -18,6 +19,7 @@ byte_swap (long *entry)
   tmp = p[1];
   p[1] = p[2];
   p[2] = tmp;
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -44,6 +46,7 @@ fix_table (long *table)
 	}
       while (*table);
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -51,4 +54,5 @@ __fix_ctors (void)
 {
   fix_table (__CTOR_LIST__);
   fix_table (__DTOR_LIST__);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc/libsys/isatty.c b/libgloss/sparc/libsys/isatty.c
index 3c64647..404bcab 100644
--- a/libgloss/sparc/libsys/isatty.c
+++ b/libgloss/sparc/libsys/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c */
 
 /* Dumb implementation so programs will at least run.  */
@@ -9,9 +10,14 @@ isatty (int fd)
 {
   struct stat buf;
 
-  if (fstat (fd, &buf) < 0)
+  if (fstat (fd, &buf) < 0) {
+    __A_VARIABLE = 1;
     return 0;
-  if (S_ISCHR (buf.st_mode))
+  }
+  if (S_ISCHR (buf.st_mode)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/sparc/salib-701.c b/libgloss/sparc/salib-701.c
index 404ad6c..10d85a7 100644
--- a/libgloss/sparc/salib-701.c
+++ b/libgloss/sparc/salib-701.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stand-alone library for Sparclet 701 board
  *
  * Copyright (c) 1996 Cygnus Support
@@ -79,12 +80,14 @@ static volatile unsigned int *tx_status = &UTSTR(STUB_PORT);
 static int
 rx_rdy()
 {
+  __A_VARIABLE = 1;
   return (*rx_status & URSTR_CHAR_NUM);
 }
 
 static unsigned char
 rx_char()
 {
+  __A_VARIABLE = 1;
   return *rx_fifo;
 }
 
@@ -92,11 +95,13 @@ void
 tx_char(char c)
 {
   *tx_fifo = c;
+  __A_VARIABLE = 1;
 }
 
 static int
 tx_rdy()
 {
+  __A_VARIABLE = 1;
   return (*tx_status & UTSTR_CHAR_FREE);
 }
 
@@ -105,6 +110,7 @@ getDebugChar()
 {
   while (!rx_rdy())
     ;
+  __A_VARIABLE = 1;
   return rx_char();
 }
 
@@ -114,6 +120,7 @@ putDebugChar(int c)
   while (!tx_rdy())
     ;
   tx_char(c);
+  __A_VARIABLE = 1;
 }
 
 #ifdef XDEBUG
@@ -127,6 +134,7 @@ void pmsg(char *p)
 	    putDebugChar('\r');
 	putDebugChar(*p++);
     }
+    __A_VARIABLE = 1;
 }
 
 /* print a hex number */
@@ -143,6 +151,7 @@ void phex(long x)
 	x >>= 4;
     }
     pmsg(buf);
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -213,6 +222,7 @@ struct trap_entry *copy_vectors()
     __trap_vectors[i] = old[i];
   wrtbr ((unsigned long)__trap_vectors);
   XDBG_MSG("Done\n");
+  __A_VARIABLE = 1;
   return __trap_vectors;
 }
 
@@ -233,6 +243,7 @@ disable_cache()
   CACHE_shadow_dccr = CACHE_shadow_dccr & ICCR_DISABLE;
   *ptr = CACHE_shadow_dccr;
   XDBG_MSG("Done\n");
+  __A_VARIABLE = 1;
 }
 
 /* Flush the instruction cache.  We need to do this for the debugger stub so
@@ -262,6 +273,7 @@ flush_i_cache ()
        addr <= CACHE_INST_TAG_ADDR + ALL_BANKS + ICACHE_LINES * ICACHE_LINE_SIZE;
        addr += ICACHE_LINE_SIZE)
     *(unsigned long *)addr = 0; /* Clr tag entry for all banks on this line */
+  __A_VARIABLE = 1;
 }
 
 /* Setup trap TT to go to ROUTINE. */
@@ -285,4 +297,5 @@ exceptionHandler (int tt, unsigned long routine)
   tb[tt].jmpl_simm13 = routine & 0x3ff;
 
   XDBG_MSG("Done\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc/salib.c b/libgloss/sparc/salib.c
index 8076a6b..056a0a0 100644
--- a/libgloss/sparc/salib.c
+++ b/libgloss/sparc/salib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stand-alone library for SPARClite
  *
  * Copyright (c) 1995 Cygnus Support
@@ -161,6 +162,7 @@ die(val)
   *leds = val;
 
   while (1) ;
+  __A_VARIABLE = 1;
 }
 
 /* Each entry in the trap vector occupies four words. */
@@ -213,6 +215,7 @@ exceptionHandler (tt, routine)
 
   tb[tt].sethi_imm22 = routine >> 10;
   tb[tt].jmpl_simm13 = routine & 0x3ff;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -271,6 +274,7 @@ update_leds()
     default:
       break;
     }
+    __A_VARIABLE = 1;
 }
 
  /* 1/5th of a second? */
@@ -282,6 +286,7 @@ unsigned long ledtime = LEDTIME;
 int
 inbyte()
 {
+	__A_VARIABLE = 1;
 	return (getDebugChar());
 }
 
@@ -303,6 +308,7 @@ getDebugChar()
 	}
     }
 
+  __A_VARIABLE = 1;
   return rcv_char(0);
 }
 
@@ -315,6 +321,7 @@ outbyte(c)
     __outbyte_hook (c);
   else
     putDebugChar(c);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -326,6 +333,7 @@ putDebugChar(c)
   while ((get_uart_status(0) & 1) == 0) ;
 
   xmt_char(0, c);
+  __A_VARIABLE = 1;
 }
 
 #if 0
diff --git a/libgloss/sparc/sparc-stub.c b/libgloss/sparc/sparc-stub.c
index fa21d72..3fed54e 100644
--- a/libgloss/sparc/sparc-stub.c
+++ b/libgloss/sparc/sparc-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "sparclite.h"
 /****************************************************************************
 
@@ -276,12 +277,19 @@ static int
 hex(ch)
      unsigned char ch;
 {
-  if (ch >= 'a' && ch <= 'f')
+  if (ch >= 'a' && ch <= 'f') {
+    __A_VARIABLE = 1;
     return ch-'a'+10;
-  if (ch >= '0' && ch <= '9')
+  }
+  if (ch >= '0' && ch <= '9') {
+    __A_VARIABLE = 1;
     return ch-'0';
-  if (ch >= 'A' && ch <= 'F')
+  }
+  if (ch >= 'A' && ch <= 'F') {
+    __A_VARIABLE = 1;
     return ch-'A'+10;
+  }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -351,6 +359,7 @@ getpacket(buffer)
 	}
     }
   while (checksum != xmitcsum);
+  __A_VARIABLE = 1;
 }
 
 /* send the packet in buffer.  */
@@ -372,8 +381,10 @@ putpacket(buffer)
 
       while (ch = buffer[count])
 	{
-	  if (! putDebugChar(ch))
+	  if (! putDebugChar(ch)) {
+	    __A_VARIABLE = 1;
 	    return;
+	  }
 	  checksum += ch;
 	  count += 1;
 	}
@@ -384,6 +395,7 @@ putpacket(buffer)
 
     }
   while ((getDebugChar() & 0x7f) != '+');
+  __A_VARIABLE = 1;
 }
 
 static char remcomInBuffer[BUFMAX];
@@ -414,8 +426,10 @@ mem2hex(mem, buf, count, may_fault)
   while (count-- > 0)
     {
       ch = *mem++;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       *buf++ = hexchars[ch >> 4];
       *buf++ = hexchars[ch & 0xf];
     }
@@ -424,6 +438,7 @@ mem2hex(mem, buf, count, may_fault)
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -447,12 +462,15 @@ hex2mem(buf, mem, count, may_fault)
       ch = hex(*buf++) << 4;
       ch |= hex(*buf++);
       *mem++ = ch;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
     }
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return mem;
 }
 
@@ -493,6 +511,7 @@ set_debug_traps()
   putDebugChar ('+');
 
   initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 asm ("
@@ -522,6 +541,7 @@ set_mem_fault_trap(enable)
     exceptionHandler(9, fltr_set_mem_err);
   else
     exceptionHandler(9, trap_low);
+  __A_VARIABLE = 1;
 }
 
 /* Convert the SPARC hardware trap type code to a unix signal number. */
@@ -533,9 +553,12 @@ computeSignal(tt)
   struct hard_trap_info *ht;
 
   for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
-    if (ht->tt == tt)
+    if (ht->tt == tt) {
+      __A_VARIABLE = 1;
       return ht->signo;
+    }
 
+  __A_VARIABLE = 1;
   return SIGHUP;		/* default for things we don't know about */
 }
 
@@ -564,6 +587,7 @@ hexToInt(char **ptr, int *intValue)
       (*ptr)++;
     }
 
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -771,6 +795,7 @@ handle_exception (registers)
  */
 
 	  flush_i_cache();
+	  __A_VARIABLE = 1;
 	  return;
 
 	  /* kill the program */
@@ -828,6 +853,7 @@ x1:	  break;
       /* reply to the request */
       putpacket(remcomOutBuffer);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function will generate a breakpoint exception.  It is used at the
@@ -838,11 +864,14 @@ x1:	  break;
 void
 breakpoint()
 {
-  if (!initialized)
+  if (!initialized) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   asm("	.globl _breakinst
 
 	_breakinst: ta 1
       ");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc/sparcl-stub.c b/libgloss/sparc/sparcl-stub.c
index 634878b..3893a37 100644
--- a/libgloss/sparc/sparcl-stub.c
+++ b/libgloss/sparc/sparcl-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************************
 
 		THIS SOFTWARE IS NOT COPYRIGHTED
@@ -355,12 +356,19 @@ static int
 hex(ch)
      unsigned char ch;
 {
-  if (ch >= 'a' && ch <= 'f')
+  if (ch >= 'a' && ch <= 'f') {
+    __A_VARIABLE = 1;
     return ch-'a'+10;
-  if (ch >= '0' && ch <= '9')
+  }
+  if (ch >= '0' && ch <= '9') {
+    __A_VARIABLE = 1;
     return ch-'0';
-  if (ch >= 'A' && ch <= 'F')
+  }
+  if (ch >= 'A' && ch <= 'F') {
+    __A_VARIABLE = 1;
     return ch-'A'+10;
+  }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -430,6 +438,7 @@ getpacket(buffer)
 	}
     }
   while (checksum != xmitcsum);
+  __A_VARIABLE = 1;
 }
 
 /* send the packet in buffer.  */
@@ -451,8 +460,10 @@ putpacket(buffer)
 
       while (ch = buffer[count])
 	{
-	  if (! putDebugChar(ch))
+	  if (! putDebugChar(ch)) {
+	    __A_VARIABLE = 1;
 	    return;
+	  }
 	  checksum += ch;
 	  count += 1;
 	}
@@ -463,6 +474,7 @@ putpacket(buffer)
 
     }
   while ((getDebugChar() & 0x7f) != '+');
+  __A_VARIABLE = 1;
 }
 
 static char remcomInBuffer[BUFMAX];
@@ -493,8 +505,10 @@ mem2hex(mem, buf, count, may_fault)
   while (count-- > 0)
     {
       ch = *mem++;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       *buf++ = hexchars[ch >> 4];
       *buf++ = hexchars[ch & 0xf];
     }
@@ -503,6 +517,7 @@ mem2hex(mem, buf, count, may_fault)
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -526,12 +541,15 @@ hex2mem(buf, mem, count, may_fault)
       ch = hex(*buf++) << 4;
       ch |= hex(*buf++);
       *mem++ = ch;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
     }
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return mem;
 }
 
@@ -573,6 +591,7 @@ set_debug_traps()
   putDebugChar ('+');
 
   initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 asm ("
@@ -602,6 +621,7 @@ set_mem_fault_trap(enable)
     exceptionHandler(9, fltr_set_mem_err);
   else
     exceptionHandler(9, trap_low);
+  __A_VARIABLE = 1;
 }
 
 asm ("
@@ -625,6 +645,7 @@ set_hw_breakpoint_trap(enable)
     exceptionHandler(255, dummy_hw_breakpoint);
   else
     exceptionHandler(255, trap_low);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -642,6 +663,7 @@ get_in_break_mode()
       ");
 
   set_hw_breakpoint_trap(0);
+  __A_VARIABLE = 1;
 }
 
 /* Convert the SPARC hardware trap type code to a unix signal number. */
@@ -653,9 +675,12 @@ computeSignal(tt)
   struct hard_trap_info *ht;
 
   for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
-    if (ht->tt == tt)
+    if (ht->tt == tt) {
+      __A_VARIABLE = 1;
       return ht->signo;
+    }
 
+  __A_VARIABLE = 1;
   return SIGHUP;		/* default for things we don't know about */
 }
 
@@ -684,6 +709,7 @@ hexToInt(char **ptr, int *intValue)
       (*ptr)++;
     }
 
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -700,6 +726,7 @@ outbyte_stub (int c)
   buf[2] = hexchars[c % 16];
   buf[3] = 0;
   putpacket (buf);
+  __A_VARIABLE = 1;
 }
 
 
@@ -920,6 +947,7 @@ handle_exception (registers)
  */
 
 	  flush_i_cache();
+	  __A_VARIABLE = 1;
 	  return;
 
 	  /* kill the program */
@@ -977,6 +1005,7 @@ x1:	  break;
       /* reply to the request */
       putpacket(remcomOutBuffer);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function will generate a breakpoint exception.  It is used at the
@@ -987,13 +1016,16 @@ x1:	  break;
 void
 breakpoint()
 {
-  if (!initialized)
+  if (!initialized) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   asm("	.globl " STRINGSYM(breakinst) "
 
 	" STRINGSYM(breakinst) ": ta 1
       ");
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -1002,4 +1034,5 @@ hw_breakpoint()
   asm("
       ta 127
       ");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc/sparclet-stub.c b/libgloss/sparc/sparclet-stub.c
index a462128..77cedf5 100644
--- a/libgloss/sparc/sparclet-stub.c
+++ b/libgloss/sparc/sparclet-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************************
 
 		THIS SOFTWARE IS NOT COPYRIGHTED
@@ -441,12 +442,19 @@ static int
 hex(ch)
      unsigned char ch;
 {
-  if (ch >= 'a' && ch <= 'f')
+  if (ch >= 'a' && ch <= 'f') {
+    __A_VARIABLE = 1;
     return ch-'a'+10;
-  if (ch >= '0' && ch <= '9')
+  }
+  if (ch >= '0' && ch <= '9') {
+    __A_VARIABLE = 1;
     return ch-'0';
-  if (ch >= 'A' && ch <= 'F')
+  }
+  if (ch >= 'A' && ch <= 'F') {
+    __A_VARIABLE = 1;
     return ch-'A'+10;
+  }
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -513,6 +521,7 @@ getpacket(buffer)
 	}
     }
   while (checksum != xmitcsum);
+  __A_VARIABLE = 1;
 }
 
 /* send the packet in buffer.  */
@@ -534,8 +543,10 @@ putpacket(buffer)
 
       while (ch = buffer[count])
 	{
-	  if (! putDebugChar(ch))
+	  if (! putDebugChar(ch)) {
+	    __A_VARIABLE = 1;
 	    return;
+	  }
 	  checksum += ch;
 	  count += 1;
 	}
@@ -546,6 +557,7 @@ putpacket(buffer)
 
     }
   while ((getDebugChar() & 0x7f) != '+');
+  __A_VARIABLE = 1;
 }
 
 static char remcomInBuffer[BUFMAX];
@@ -576,8 +588,10 @@ mem2hex(mem, buf, count, may_fault)
   while (count-- > 0)
     {
       ch = *mem++;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       *buf++ = hexchars[ch >> 4];
       *buf++ = hexchars[ch & 0xf];
     }
@@ -586,6 +600,7 @@ mem2hex(mem, buf, count, may_fault)
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -609,12 +624,15 @@ hex2mem(buf, mem, count, may_fault)
       ch = hex(*buf++) << 4;
       ch |= hex(*buf++);
       *mem++ = ch;
-      if (mem_err)
+      if (mem_err) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
     }
 
   set_mem_fault_trap(0);
 
+  __A_VARIABLE = 1;
   return mem;
 }
 
@@ -655,6 +673,7 @@ set_debug_traps()
   putDebugChar ('+');
 
   initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 asm ("
@@ -684,6 +703,7 @@ set_mem_fault_trap(enable)
     exceptionHandler(0x29, fltr_set_mem_err);
   else
     exceptionHandler(0x29, trap_low);
+  __A_VARIABLE = 1;
 }
 
 asm ("
@@ -707,6 +727,7 @@ set_hw_breakpoint_trap(enable)
     exceptionHandler(255, dummy_hw_breakpoint);
   else
     exceptionHandler(255, trap_low);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -729,6 +750,7 @@ get_in_break_mode()
       ");
 
   set_hw_breakpoint_trap(0);
+  __A_VARIABLE = 1;
 }
 
 /* Convert the SPARC hardware trap type code to a unix signal number. */
@@ -740,9 +762,12 @@ computeSignal(tt)
   struct hard_trap_info *ht;
 
   for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
-    if (ht->tt == tt)
+    if (ht->tt == tt) {
+      __A_VARIABLE = 1;
       return ht->signo;
+    }
 
+  __A_VARIABLE = 1;
   return SIGHUP;		/* default for things we don't know about */
 }
 
@@ -771,6 +796,7 @@ hexToInt(char **ptr, int *intValue)
       (*ptr)++;
     }
 
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -1036,6 +1062,7 @@ handle_exception (registers)
  */
 
 	  flush_i_cache();
+	  __A_VARIABLE = 1;
 	  return;
 
 	  /* kill the program */
@@ -1093,6 +1120,7 @@ x1:	  break;
       /* reply to the request */
       putpacket(remcomOutBuffer);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function will generate a breakpoint exception.  It is used at the
@@ -1103,13 +1131,16 @@ x1:	  break;
 void
 breakpoint()
 {
-  if (!initialized)
+  if (!initialized) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   asm("	.globl _breakinst
 
 	_breakinst: ta 1
       ");
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -1118,6 +1149,7 @@ hw_breakpoint()
   asm("
       ta 127
       ");
+  __A_VARIABLE = 1;
 }
 
 #if 0 /* experimental and never finished, left here for reference */
diff --git a/libgloss/sparc/sysc-701.c b/libgloss/sparc/sysc-701.c
index 191a08a..35d256f 100644
--- a/libgloss/sparc/sysc-701.c
+++ b/libgloss/sparc/sysc-701.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* more sparclet syscall support (the rest is in crt0-701.S).  */
 
 #include <sys/types.h>
@@ -8,6 +9,7 @@ int
 fstat(int _fd, struct stat* _sbuf)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -17,14 +19,17 @@ isatty(int fd)
   if (fd < 0)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
+  __A_VARIABLE = 1;
   return fd <= 2;
 }
 
 int 
 getpid()
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -32,6 +37,7 @@ int
 kill(int pid)
 {
   /* if we knew how to nuke the board, we would... */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -39,6 +45,7 @@ int
 lseek(int _fd, off_t offset, int whence)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -51,5 +58,6 @@ sbrk (int incr)
   if(!base) base = &end;
   b = base;
   base += incr;
+  __A_VARIABLE = 1;
   return b;
 }
diff --git a/libgloss/sparc/syscalls.c b/libgloss/sparc/syscalls.c
index 01ba501..2c4f979 100644
--- a/libgloss/sparc/syscalls.c
+++ b/libgloss/sparc/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995 Cygnus Support
  *
  * The authors hereby grant permission to use, copy, modify, distribute,
@@ -25,12 +26,14 @@ fstat(int _fd, struct stat* _sbuf)
 {
   /* this is used in a few places in stdio... */
   /* just error, so they assume a pipe */
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 isatty(int _fd)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -38,6 +41,7 @@ int
 close(int _fd)
 {
   /* return value usually ignored anyhow */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -45,23 +49,27 @@ int
 open(char *filename)
 {
   /* always fail */
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int 
 getpid() {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int 
 kill(int pid) {
   /* if we knew how to nuke the board, we would... */
+  __A_VARIABLE = 1;
   return 0;
 }
 
 void
 _exit(int status) {
   /* likewise... */
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -69,6 +77,7 @@ int
 lseek(int _fd, off_t offset, int whence)
 {
   /* nothing is ever seekable */
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -81,5 +90,6 @@ sbrk(int incr)
   if(!base) base = &end;
   b = base;
   base += incr;
+  __A_VARIABLE = 1;
   return b;
 }
diff --git a/libgloss/sparc/test.c b/libgloss/sparc/test.c
index fc443a8..90e4c35 100644
--- a/libgloss/sparc/test.c
+++ b/libgloss/sparc/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "debug.h"
 
 char hextab[] = "0123456789abcdef";
@@ -6,6 +7,7 @@ int
 foo(arg)
      int arg;
 {
+  __A_VARIABLE = 1;
   return arg+1;
 }
 
@@ -66,4 +68,5 @@ main()
   }
   
   print("I escaped!\r\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/_exit.c b/libgloss/sparc_leon/_exit.c
index fbe86cc..5263543 100644
--- a/libgloss/sparc_leon/_exit.c
+++ b/libgloss/sparc_leon/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -27,4 +28,5 @@ void
 _exit (int status)
 {
   asm ("mov 1, %g1; ta 0;\n");
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/amba.c b/libgloss/sparc_leon/amba.c
index 0df6759..7085fd6 100644
--- a/libgloss/sparc_leon/amba.c
+++ b/libgloss/sparc_leon/amba.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -53,9 +54,11 @@ amba_find_apbslv_addr (unsigned long vendor, unsigned long device,
 	      *irq = amba_irq (conf);
 	    }
 	  iobar = amba_apb_get_membar (amba_conf.apbslv, i);
+	  __A_VARIABLE = 1;
 	  return amba_iobar_start (amba_conf.apbslv.apbmst[i], iobar);
 	}
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -93,6 +96,7 @@ amba_init (void)
 
   if (amba_init_done)
     {
+      __A_VARIABLE = 1;
       return;
     }
   amba_init_done = 1;
@@ -149,4 +153,5 @@ amba_init (void)
     {
       LEON3_BYPASS_STORE_PA (&(LEON3_IrqCtrl_Regs->mask[0]), 0);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/amba_dbg.c b/libgloss/sparc_leon/amba_dbg.c
index 5f04450..b921cbe 100644
--- a/libgloss/sparc_leon/amba_dbg.c
+++ b/libgloss/sparc_leon/amba_dbg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -67,6 +68,7 @@ vendor_dev_string (unsigned long conf, char *vendorbuf, char *devbuf)
   vendorbuf[0] = 0;
   devbuf[0] = 0;
 #endif
+  __A_VARIABLE = 1;
 }
 
 void
@@ -144,4 +146,5 @@ amba_prinf_config (void)
 
     }
 
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/amba_driver.c b/libgloss/sparc_leon/amba_driver.c
index 0340e94..b124064 100644
--- a/libgloss/sparc_leon/amba_driver.c
+++ b/libgloss/sparc_leon/amba_driver.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -69,6 +70,7 @@ amba_get_free_apbslv_devices (int vendor, int device, amba_apb_device * dev,
 	    }
 	}
     }
+  __A_VARIABLE = 1;
   return j;
 }
 
@@ -115,5 +117,6 @@ amba_get_free_ahbslv_devices (int vendor, int device, amba_ahb_device * dev,
 	    }
 	}
     }
+  __A_VARIABLE = 1;
   return j;
 }
diff --git a/libgloss/sparc_leon/amba_scan.c b/libgloss/sparc_leon/amba_scan.c
index 6d12281..b8bf0bc 100644
--- a/libgloss/sparc_leon/amba_scan.c
+++ b/libgloss/sparc_leon/amba_scan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -41,9 +42,11 @@ leon3_ahbslv_scan (register unsigned int vendor, register unsigned int driver)
       conf = *confp;
       if ((amba_vendor (conf) == vendor) && (amba_device (conf) == driver))
 	{
+	  __A_VARIABLE = 1;
 	  return (unsigned int) confp;
 	}
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -52,6 +55,7 @@ leon3_getbase (register unsigned int *mbar, register unsigned int iobase,
 	       int *irq)
 {
   register unsigned int conf = mbar[1];
+  __A_VARIABLE = 1;
   return (unsigned int) (((iobase & 0xfff00000) |
 			  ((conf & 0xfff00000) >> 12)) & (((conf & 0x0000fff0)
 							   << 4) |
@@ -80,6 +84,7 @@ leon3_apbslv_scan (register unsigned int base,
 	    }
 	}
     }
+  __A_VARIABLE = 1;
   return j;
 }
 
@@ -92,5 +97,6 @@ leon3_getapbbase (register unsigned int vendor,
   unsigned int apb = leon3_ahbslv_scan (VENDOR_GAISLER, GAISLER_APBMST);
   apb = (*(unsigned int *) (apb + 16)) & LEON3_IO_AREA;
   apb |= LEON3_CONF_AREA;
+  __A_VARIABLE = 1;
   return leon3_apbslv_scan (apb, vendor, driver, apbdevs, c);
 }
diff --git a/libgloss/sparc_leon/catch_interrupt.c b/libgloss/sparc_leon/catch_interrupt.c
index f55defa..aab1092 100644
--- a/libgloss/sparc_leon/catch_interrupt.c
+++ b/libgloss/sparc_leon/catch_interrupt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -45,8 +46,10 @@ catch_interrupt (int func, int irq)
 {
   struct irqaction *a = _irqtbl[irq];
   struct irqaction *n = &_oirqtbl[irq];
-  if (irq >= 32)
+  if (irq >= 32) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   while (a)
     {
@@ -54,12 +57,14 @@ catch_interrupt (int func, int irq)
 	{
 	  int tmp = (int) a->handler;
 	  a->handler = (irqhandler) func;
+	  __A_VARIABLE = 1;
 	  return tmp;
 	}
       a = a->next;
     }
   n->handler = (irqhandler) func;
   chained_catch_interrupt (irq, n);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -68,6 +73,7 @@ chained_catch_interrupt (int irq, struct irqaction *a)
 {
   a->next = _irqtbl[irq];
   _irqtbl[irq] = a;
+  __A_VARIABLE = 1;
 }
 
 int no_inirq_check = 0;
@@ -112,6 +118,7 @@ handler_irq (int irq, struct leonbare_pt_regs *pt_regs)
 	}
       a = a->next;
     }
+    __A_VARIABLE = 1;
 }
 
 schedulehandler schedule_callback = 0;
diff --git a/libgloss/sparc_leon/catch_interrupt_mvt.c b/libgloss/sparc_leon/catch_interrupt_mvt.c
index da0332a..f73ab06 100644
--- a/libgloss/sparc_leon/catch_interrupt_mvt.c
+++ b/libgloss/sparc_leon/catch_interrupt_mvt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -38,6 +39,7 @@ mvtlolevelirqinstall (int irqnr, void (*handler) ())
 
   if (irqnr == 0 || irqnr >= 15)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -45,11 +47,13 @@ mvtlolevelirqinstall (int irqnr, void (*handler) ())
   addr[1] = ((h) & 0x3ff) | 0x81c52000;	/* 81c52000: jmpl    %l4 + %lo(handler), %g0 */
   addr[2] = 0x01000000;		/* 01000000: nop */
   addr[3] = 0x01000000;		/* 01000000: nop */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int
 lolevelirqinstall (int irqnr, void (*handler) ())
 {
+  __A_VARIABLE = 1;
   return mvtlolevelirqinstall (irqnr, handler);
 }
diff --git a/libgloss/sparc_leon/catch_interrupt_pending.c b/libgloss/sparc_leon/catch_interrupt_pending.c
index 1193cad..08aa3f0 100644
--- a/libgloss/sparc_leon/catch_interrupt_pending.c
+++ b/libgloss/sparc_leon/catch_interrupt_pending.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -47,6 +48,7 @@ get_pending ()
       TAILQ_REMOVE (&pending, a, next);
     }
   leonbare_enable_traps (old);
+  __A_VARIABLE = 1;
   return a;
 }
 
@@ -61,4 +63,5 @@ process_pending ()
 	  a->handler (a->arg);
 	}
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/catch_interrupt_svt.c b/libgloss/sparc_leon/catch_interrupt_svt.c
index 065b5f1..12e25b2 100644
--- a/libgloss/sparc_leon/catch_interrupt_svt.c
+++ b/libgloss/sparc_leon/catch_interrupt_svt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -48,6 +49,7 @@ gettrap_pos (int nr)
 	}
       p++;
     }
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -57,11 +59,13 @@ svtloleveltrapinstall (int trap, void (*handler) ())
   struct svt_trap_entry *p = gettrap_pos (trap);
   if (p >= &svt_trap_table_ext_end)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
   p->start = trap;
   p->end = trap;
   p->func = handler;
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -70,7 +74,9 @@ svtlolevelirqinstall (int irqnr, void (*handler) ())
 {
   if (irqnr == 0 || irqnr >= 15)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
+  __A_VARIABLE = 1;
   return svtloleveltrapinstall (irqnr + 0x10, handler);
 }
diff --git a/libgloss/sparc_leon/console.c b/libgloss/sparc_leon/console.c
index 849aad9..b02422c 100644
--- a/libgloss/sparc_leon/console.c
+++ b/libgloss/sparc_leon/console.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/console_dbg.c b/libgloss/sparc_leon/console_dbg.c
index 57c258f..49f003b 100644
--- a/libgloss/sparc_leon/console_dbg.c
+++ b/libgloss/sparc_leon/console_dbg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -40,6 +41,7 @@ lo_strnlen (const char *s, size_t count)
 
   for (sc = s; count-- && *sc != '\0'; ++sc)
     /* nothing */ ;
+  __A_VARIABLE = 1;
   return sc - s;
 }
 
@@ -265,6 +267,7 @@ lo_vsnprintf (char *buf, size_t size, const char *fmt, va_list args)
   /* the trailing null byte doesn't count towards the total
    * ++str;
    */
+  __A_VARIABLE = 1;
   return str - buf;
 }
 
@@ -280,6 +283,7 @@ lo_vsnprintf (char *buf, size_t size, const char *fmt, va_list args)
 static int
 lo_vsprintf (char *buf, const char *fmt, va_list args)
 {
+  __A_VARIABLE = 1;
   return lo_vsnprintf (buf, 0xFFFFFFFFUL, fmt, args);
 }
 
@@ -293,6 +297,7 @@ dbgleon_sprintf (char *buf, size_t size, const char *fmt, ...)
   va_start (args, fmt);
   printed_len = lo_vsnprintf (buf, size, fmt, args);
   va_end (args);
+  __A_VARIABLE = 1;
   return printed_len;
 }
 
@@ -351,4 +356,5 @@ dbgleon_printf (const char *fmt, ...)
       break;
     }
   //---------------------
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/console_init.c b/libgloss/sparc_leon/console_init.c
index 5a81698..8ea6e20 100644
--- a/libgloss/sparc_leon/console_init.c
+++ b/libgloss/sparc_leon/console_init.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -31,4 +32,5 @@ console_init (unsigned int *addr, int freq, int baud)
   addr[1] = 0;
   addr[2] = 3;
   addr[3] = (freq / baud + 8) / 16 - 1;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/contextswitch.c b/libgloss/sparc_leon/contextswitch.c
index 7aafec4..1ab86bd 100644
--- a/libgloss/sparc_leon/contextswitch.c
+++ b/libgloss/sparc_leon/contextswitch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -51,6 +52,7 @@ _do_thread_setjmp (threadctx_t env, unsigned int savesigs)
 #ifndef _SOFT_FLOAT
   env[THREAD_JB_FPUCTX] = fpustate_current;
 #endif
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -118,4 +120,5 @@ thread_longjmp (threadctx_t env, int val)
 /*     /\* %8 *\/ "r" (env) );                                                                       */
 
   /* never come here */
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/gettimeofday.c b/libgloss/sparc_leon/gettimeofday.c
index 088184c..2822e61 100644
--- a/libgloss/sparc_leon/gettimeofday.c
+++ b/libgloss/sparc_leon/gettimeofday.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -71,12 +72,14 @@ do_timer (struct leonbare_pt_regs *regs)
       while (ticks);
     }
   settimer ();
+  __A_VARIABLE = 1;
 }
 
 int
 leonbare_alarm (int irq, void *arg, struct leonbare_pt_regs *regs)
 {
   settimer ();
+  __A_VARIABLE = 1;
 }
 
 extern clock_t (*clock_custom) (void);
@@ -84,6 +87,7 @@ clock_t
 leonbare_clock_custom ()
 {
   int hz = leonbare_hz ? leonbare_hz : HZ;
+  __A_VARIABLE = 1;
   return (clock_t) ((jiffies * (CLOCK_TICK_RATE / hz)) + do_gettimeoffset ());
 }
 
@@ -108,6 +112,7 @@ leonbare_tick (int irq, void *arg, struct leonbare_pt_regs *regs)
       ctrl = LEON3_GpTimer_Regs->e[0].ctrl;
       if (!(ctrl & LEON3_GPTIMER_IP))
 	{
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
       LEON3_GpTimer_Regs->e[0].ctrl = ctrl & ~LEON3_GPTIMER_IP;
@@ -121,6 +126,7 @@ leonbare_tick (int irq, void *arg, struct leonbare_pt_regs *regs)
     {
       ticker_callback (regs);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -171,6 +177,7 @@ leonbare_init_ticks ()
       chained_catch_interrupt (irq2, &irqact2);
       leonbare_enable_irq (irq2);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -190,6 +197,7 @@ do_gettimeoffset ()
       break;
     }
   //---------------------
+  __A_VARIABLE = 1;
   return usec;
 }
 
@@ -229,12 +237,14 @@ do_gettimeofday (struct timeval *tv)
 
   tv->tv_sec = sec;
   tv->tv_usec = usec;
+  __A_VARIABLE = 1;
 }
 
 int
 gettimeofday (struct timeval *__p, void *__tz)
 {
   do_gettimeofday (__p);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -246,8 +256,10 @@ do_settimeofday (struct timespec *tv)
   time_t sec = tv->tv_sec;
   long nsec = tv->tv_nsec;
 
-  if ((unsigned long) nsec >= NSEC_PER_SEC)
+  if ((unsigned long) nsec >= NSEC_PER_SEC) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /*
    * This is revolting. We need to set "xtime" correctly. However, the
@@ -259,6 +271,7 @@ do_settimeofday (struct timespec *tv)
 		  (jiffies - wall_jiffies) * (USEC_PER_SEC / HZ));
 
   set_normalized_timespec (&xtime, sec, nsec);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -268,5 +281,6 @@ settimeofday (const struct timeval *tv, const struct timezone *tz)
   struct timespec ts;
   ts.tv_sec = tv->tv_sec;
   ts.tv_nsec = tv->tv_usec * NSEC_PER_USEC;
+  __A_VARIABLE = 1;
   return do_settimeofday (&ts);
 }
diff --git a/libgloss/sparc_leon/initcalls.c b/libgloss/sparc_leon/initcalls.c
index 773a345..8a56f9b 100644
--- a/libgloss/sparc_leon/initcalls.c
+++ b/libgloss/sparc_leon/initcalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -42,4 +43,5 @@ _call_initcalls ()
 	}
       p++;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/io.c b/libgloss/sparc_leon/io.c
index 282e513..b3b2d8c 100644
--- a/libgloss/sparc_leon/io.c
+++ b/libgloss/sparc_leon/io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -41,13 +42,17 @@ outbyte (int c)
       while ((console[1] & TREADY) == 0);
       console[0] = (int) '\r';
     }
+    __A_VARIABLE = 1;
 }
 
 int
 inbyte (void)
 {
-  if (!console)
+  if (!console) {
+    __A_VARIABLE = 1;
     return (0);
+  }
   while (!(console[1] & DREADY));
+  __A_VARIABLE = 1;
   return console[0];
 }
diff --git a/libgloss/sparc_leon/jiffies.c b/libgloss/sparc_leon/jiffies.c
index 61d320d..ec6bf24 100644
--- a/libgloss/sparc_leon/jiffies.c
+++ b/libgloss/sparc_leon/jiffies.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/kernel.c b/libgloss/sparc_leon/kernel.c
index ecdeb21..fa4b82c 100644
--- a/libgloss/sparc_leon/kernel.c
+++ b/libgloss/sparc_leon/kernel.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -105,6 +106,7 @@ leonbare_sched_update ()
       LEONBARE_PRINTQUEUES ();
     }
   LEONBARE_KR_NEXT = n;
+  __A_VARIABLE = 1;
   return (LEONBARE_KR_NEED_SCHEDULE);
 }
 
@@ -153,6 +155,7 @@ leonbare_thread_tick_callback ()
       LEONBARE_PROTECT_KERNEL_END ();
     }
   r = leonbare_sched_update ();
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -171,6 +174,7 @@ leonbare_thread_schedule_callback (struct leonbare_pt_regs *ptregs)
       //KERNEL_EXIT(LEONBARE_KR_NEED_SCHEDULE, retval);
     }
   LBDEBUG_FNEXIT;
+  __A_VARIABLE = 1;
 }
 
 
@@ -214,4 +218,5 @@ leonbare_thread_init ()
 
 
   LBDEBUG_FNEXIT;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/kernel_debug.c b/libgloss/sparc_leon/kernel_debug.c
index 0374de7..aa3117f 100644
--- a/libgloss/sparc_leon/kernel_debug.c
+++ b/libgloss/sparc_leon/kernel_debug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -132,6 +133,7 @@ leonbare_sched_verify ()
       }
   }
 #endif
+  __A_VARIABLE = 1;
 }
 
 int
@@ -141,6 +143,7 @@ leonbare_debug_printf (const char *fmt, ...)
   va_start (ap, fmt);
   vprintf (fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -159,4 +162,5 @@ leonbare_sched_printqueue ()
       }
       LBDEBUG (LBDEBUG_QUEUE_NR, "]\n", 0);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/kernel_debug_var.c b/libgloss/sparc_leon/kernel_debug_var.c
index 47b8e69..e452994 100644
--- a/libgloss/sparc_leon/kernel_debug_var.c
+++ b/libgloss/sparc_leon/kernel_debug_var.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/kernel_mm.c b/libgloss/sparc_leon/kernel_mm.c
index fd11bb0..1f2d859 100644
--- a/libgloss/sparc_leon/kernel_mm.c
+++ b/libgloss/sparc_leon/kernel_mm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/kernel_mutex.c b/libgloss/sparc_leon/kernel_mutex.c
index a813449..9f87456 100644
--- a/libgloss/sparc_leon/kernel_mutex.c
+++ b/libgloss/sparc_leon/kernel_mutex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -45,6 +46,7 @@ leonbare_mutex_init (leonbare_mutex_t m)
   }
   LEONBARE_PROTECT_KERNEL_END ();
 
+  __A_VARIABLE = 1;
 }
 
 int
@@ -74,6 +76,7 @@ _self__leonbare_mutex_lock (leonbare_mutex_t m, int wait)
       current_suspend ();
     }
   LEONBARE_PROTECT_MUTEXSTRUCT_END (m);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -103,5 +106,6 @@ leonbare_mutex_unlock (leonbare_mutex_t m)
       }
   }
   LEONBARE_PROTECT_MUTEXSTRUCT_END (m);
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/libgloss/sparc_leon/kernel_queue.c b/libgloss/sparc_leon/kernel_queue.c
index a6a20e1..f6036f9 100644
--- a/libgloss/sparc_leon/kernel_queue.c
+++ b/libgloss/sparc_leon/kernel_queue.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/kernel_sched.c b/libgloss/sparc_leon/kernel_sched.c
index 2b485c0..aadf982 100644
--- a/libgloss/sparc_leon/kernel_sched.c
+++ b/libgloss/sparc_leon/kernel_sched.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -34,6 +35,7 @@ unsigned int
 reschedule ()
 {
   leonbare_sched_update ();
+  __A_VARIABLE = 1;
   return leonbare_sched ();
 }
 
@@ -80,5 +82,6 @@ leonbare_sched ()
       LEONBARE_SMP_SPINLOCK_AQUIRE (LEONBARE_KR_LOCK);
     }
 
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/libgloss/sparc_leon/kernel_thread.c b/libgloss/sparc_leon/kernel_thread.c
index b51b6be..93c0fa0 100644
--- a/libgloss/sparc_leon/kernel_thread.c
+++ b/libgloss/sparc_leon/kernel_thread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -61,6 +62,7 @@ leonbare_thread_resume (leonbare_thread_t thread)
       LEONBARE_PROTECT_KERNEL_END ();
     }
 
+    __A_VARIABLE = 1;
 }
 
 int
@@ -98,6 +100,7 @@ leonbare_thread_terminate (leonbare_thread_t thread)
       LEONBARE_STOPALL;
     }
   LEONBARE_PROTECT_KERNEL_END ();
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -121,6 +124,7 @@ current_suspend ()
   }
   ret = reschedule ();
   LEONBARE_PROTECT_KERNEL_END ();
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -136,6 +140,7 @@ _leonbare_thread_body ()
   leonbare_thread_terminate (thread);
 
   LBDEBUG_FNEXIT;
+  __A_VARIABLE = 1;
 }
 
 #define LEONBARE_BODY_OFFSET 200
@@ -211,4 +216,5 @@ leonbare_thread_create (struct leonbare_thread *thread, char *stack,
   LEONBARE_PROTECT_KERNEL_END ();
 
   LBDEBUG_FNEXIT;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/locore_atexit.c b/libgloss/sparc_leon/locore_atexit.c
index b23054c..438d8b4 100644
--- a/libgloss/sparc_leon/locore_atexit.c
+++ b/libgloss/sparc_leon/locore_atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -42,9 +43,11 @@ atexit (void (*fn) (void))
     _GLOBAL_REENT->_atexit = p = &_GLOBAL_REENT->_atexit0;
   if (p->_ind >= _ATEXIT_SIZE)
     {
+      __A_VARIABLE = 1;
       return -1;
     }
 
   p->_fns[p->_ind++] = fn;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/sparc_leon/mutex.c b/libgloss/sparc_leon/mutex.c
index eb2c299..015995a 100644
--- a/libgloss/sparc_leon/mutex.c
+++ b/libgloss/sparc_leon/mutex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -87,8 +88,10 @@ ___st_pthread_mutex_destroy (mutex)
 {
   if (__lbst_pthread_mutex_destroy)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutex_destroy (mutex);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -98,8 +101,10 @@ ___st_pthread_mutex_lock (mutex)
 {
   if (__lbst_pthread_mutex_lock)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutex_lock (mutex);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -109,8 +114,10 @@ ___st_pthread_mutex_trylock (mutex)
 {
   if (__lbst_pthread_mutex_trylock)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutex_trylock (mutex);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -120,8 +127,10 @@ ___st_pthread_mutex_unlock (mutex)
 {
   if (__lbst_pthread_mutex_unlock)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutex_unlock (mutex);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -131,8 +140,10 @@ ___st_pthread_mutexattr_init (attr)
 {
   if (__lbst_pthread_mutexattr_init)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutexattr_init (attr);
     }
+  __A_VARIABLE = 1;
   return (0);
 }
 
@@ -142,8 +153,10 @@ ___st_pthread_mutexattr_destroy (attr)
 {
   if (__lbst_pthread_mutexattr_destroy)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutexattr_destroy (attr);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -154,8 +167,10 @@ ___st_pthread_mutexattr_settype (attr, kind)
 {
   if (__lbst_pthread_mutexattr_settype)
     {
+      __A_VARIABLE = 1;
       return __lbst_pthread_mutexattr_settype (attr, kind);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/libgloss/sparc_leon/pnpinit.c b/libgloss/sparc_leon/pnpinit.c
index 7b8522b..360b2c5 100644
--- a/libgloss/sparc_leon/pnpinit.c
+++ b/libgloss/sparc_leon/pnpinit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -42,18 +43,22 @@ unsigned int
 ambapp_addr_from (struct ambapp_mmap *mmaps, unsigned int address)
 {
   /* no translation? */
-  if (!mmaps)
+  if (!mmaps) {
+    __A_VARIABLE = 1;
     return address;
+  }
 
   while (mmaps->size)
     {
       if ((address >= mmaps->remote_adr)
 	  && (address <= (mmaps->remote_adr + (mmaps->size - 1))))
 	{
+	  __A_VARIABLE = 1;
 	  return (address - mmaps->remote_adr) + mmaps->local_adr;
 	}
       mmaps++;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -110,6 +115,7 @@ ambapp_ahb_dev_init (unsigned int ioarea,
       ahb_info->start[bar] = addr;
       ahb_info->mask[bar] = mask;
     }
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -131,6 +137,7 @@ ambapp_apb_dev_init (unsigned int base,
   DPRINTF (("+APB device %d:%d\n", dev->device, dev->vendor));
 
 
+  __A_VARIABLE = 1;
 }
 
 #define MAX_NUM_BUSES 16
@@ -143,9 +150,11 @@ ambapp_add_scanned_bus (unsigned int *ioareas, unsigned int ioarea)
       if (ioareas[i] == 0)
 	{
 	  ioareas[i] = ioarea;
+	  __A_VARIABLE = 1;
 	  return;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 static int
@@ -392,12 +401,14 @@ find_apbslvs_next (int vendor, int device, struct ambapp_apb_info *dev,
   ambapp_find (LEON3_IO_AREA, NULL, NULL, &busses,
 	       ambapp_dev_find_match, &arg, vendor, device);
 
+  __A_VARIABLE = 1;
   return maxno - arg.count;
 }
 
 int
 find_apbslv (int vendor, int device, struct ambapp_apb_info *dev)
 {
+  __A_VARIABLE = 1;
   return find_apbslvs_next (vendor, device, dev, 0, 1);
 }
 
@@ -427,4 +438,5 @@ pnpinit (void)
       irqmp = dev.start;
       DPRINTF (("Found irqmp at 0x%x\n", rtc));
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/pnpinit_malloc.c b/libgloss/sparc_leon/pnpinit_malloc.c
index ed76405..e27c8f7 100644
--- a/libgloss/sparc_leon/pnpinit_malloc.c
+++ b/libgloss/sparc_leon/pnpinit_malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -51,11 +52,14 @@ ambapp_alloc_dev_struct (int dev_type)
       size += sizeof (struct ambapp_ahb_info);
     }
   dev = malloc (size);
-  if (dev == NULL)
+  if (dev == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   memset (dev, 0, size);
   dev->devinfo = (void *) (dev + 1);
   dev->dev_type = dev_type;
+  __A_VARIABLE = 1;
   return dev;
 }
 
@@ -63,18 +67,22 @@ unsigned int
 ambapp_addr_from (struct ambapp_mmap *mmaps, unsigned int address)
 {
   /* no translation? */
-  if (!mmaps)
+  if (!mmaps) {
+    __A_VARIABLE = 1;
     return address;
+  }
 
   while (mmaps->size)
     {
       if ((address >= mmaps->remote_adr)
 	  && (address <= (mmaps->remote_adr + (mmaps->size - 1))))
 	{
+	  __A_VARIABLE = 1;
 	  return (address - mmaps->remote_adr) + mmaps->local_adr;
 	}
       mmaps++;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -130,6 +138,7 @@ ambapp_ahb_dev_init (unsigned int ioarea,
       ahb_info->start[bar] = addr;
       ahb_info->mask[bar] = mask;
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -151,6 +160,7 @@ ambapp_apb_dev_init (unsigned int base,
   DPRINTF (("+APB device %d:%d\n", dev->device, dev->vendor));
 
 
+  __A_VARIABLE = 1;
 }
 
 #define MAX_NUM_BUSES 16
@@ -163,9 +173,11 @@ ambapp_add_scanned_bus (unsigned int *ioareas, unsigned int ioarea)
       if (ioareas[i] == 0)
 	{
 	  ioareas[i] = ioarea;
+	  __A_VARIABLE = 1;
 	  return;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 int
@@ -362,8 +374,10 @@ ambapp_dev_match_options (struct ambapp_dev_hdr *dev, unsigned int options,
 						       DEV_IS_ALLOCATED
 						       (dev))))
     {
+      __A_VARIABLE = 1;
       return 1;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -377,8 +391,10 @@ ambapp_for_each_apb (struct ambapp_dev_hdr *dev,
   int index;
   struct ambapp_dev_hdr *apbslv;
 
-  if (maxdepth < 0)
+  if (maxdepth < 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   if (dev->children && (dev->children->dev_type == DEV_APB_SLV))
     {
@@ -389,13 +405,16 @@ ambapp_for_each_apb (struct ambapp_dev_hdr *dev,
 	{
 	  if (ambapp_dev_match_options (apbslv, options, vendor, device) == 1)
 	    {
-	      if (func (apbslv, index, maxdepth, arg) == 1)
-		return 1;	/* Signalled stopped */
+	      if (func (apbslv, index, maxdepth, arg) == 1) {
+		__A_VARIABLE = 1;
+		return 1;
+	      }	/* Signalled stopped */
 	    }
 	  index++;
 	  apbslv = apbslv->next;
 	}
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -410,8 +429,10 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
   int ahb_slave = 0;
   int index;
 
-  if (maxdepth < 0)
+  if (maxdepth < 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* Start at device 'root' and process downwards.
    *
@@ -440,8 +461,10 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
 	  if (ambapp_dev_match_options (dev, options, vendor, device) == 1)
 	    {
 	      /* Correct device and vendor ID */
-	      if (func (dev, index, maxdepth, arg) == 1)
-		return 1;	/* Signalled stopped */
+	      if (func (dev, index, maxdepth, arg) == 1) {
+		__A_VARIABLE = 1;
+		return 1;
+	      }	/* Signalled stopped */
 	    }
 
 	  if ((options & OPTIONS_DEPTH_FIRST) && (options & OPTIONS_APB_SLVS))
@@ -449,8 +472,10 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
 	      /* Check is APB bridge, and process all APB Slaves in that case */
 	      if (ambapp_for_each_apb
 		  (dev, options, vendor, device, (maxdepth - 1), func,
-		   arg) == 1)
-		return 1;	/* Signalled stopped */
+		   arg) == 1) {
+		__A_VARIABLE = 1;
+		return 1;
+	      }	/* Signalled stopped */
 	    }
 
 	  if (options & OPTIONS_DEPTH_FIRST)
@@ -460,8 +485,10 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
 		  /* Found AHB Bridge, recurse */
 		  if (ambapp_for_each
 		      (dev->children, options, vendor, device, (maxdepth - 1),
-		       func, arg) == 1)
+		       func, arg) == 1) {
+		    __A_VARIABLE = 1;
 		    return 1;
+		  }
 		}
 	    }
 
@@ -478,8 +505,10 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
 	{
 	  /* Check is APB bridge, and process all APB Slaves in that case */
 	  if (ambapp_for_each_apb
-	      (dev, options, vendor, device, (maxdepth - 1), func, arg) == 1)
-	    return 1;		/* Signalled stopped */
+	      (dev, options, vendor, device, (maxdepth - 1), func, arg) == 1) {
+	    __A_VARIABLE = 1;
+	    return 1;
+	  }		/* Signalled stopped */
 	  dev = dev->next;
 	}
     }
@@ -495,22 +524,28 @@ ambapp_for_each (struct ambapp_dev_hdr *root,
 	      /* Found AHB Bridge, recurse */
 	      if (ambapp_for_each
 		  (dev->children, options, vendor, device, (maxdepth - 1),
-		   func, arg) == 1)
+		   func, arg) == 1) {
+		__A_VARIABLE = 1;
 		return 1;
+	      }
 	    }
 	  dev = dev->next;
 	}
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 ambapp_alloc_dev (struct ambapp_dev_hdr *dev, void *owner)
 {
-  if (dev->owner)
+  if (dev->owner) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   dev->owner = owner;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -518,6 +553,7 @@ void
 ambapp_free_dev (struct ambapp_dev_hdr *dev)
 {
   dev->owner = NULL;
+  __A_VARIABLE = 1;
 }
 
 struct ambapp_dev_find_match_arg
@@ -575,6 +611,7 @@ ambapp_find_apbslvs_next (struct ambapp_dev_hdr *root, int vendor, int device,
   ambapp_for_each (root, (OPTIONS_ALL | OPTIONS_APB_SLVS), vendor, device, 10,
 		   ambapp_dev_find_match, &arg);
 
+  __A_VARIABLE = 1;
   return maxno - arg.count;
 }
 
@@ -582,6 +619,7 @@ int
 ambapp_find_apbslv (struct ambapp_dev_hdr *root, int vendor, int device,
 		    struct ambapp_apb_info *dev)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_apbslvs_next (root, vendor, device, dev, 0, 1);
 }
 
@@ -589,6 +627,7 @@ int
 ambapp_find_apbslv_next (struct ambapp_dev_hdr *root, int vendor, int device,
 			 struct ambapp_apb_info *dev, int index)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_apbslvs_next (root, vendor, device, dev, index, 1);
 }
 
@@ -596,6 +635,7 @@ int
 ambapp_find_apbslvs (struct ambapp_dev_hdr *root, int vendor, int device,
 		     struct ambapp_apb_info *dev, int maxno)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_apbslvs_next (root, vendor, device, dev, 0, maxno);
 }
 
@@ -613,6 +653,7 @@ ambapp_find_ahbslvs_next (struct ambapp_dev_hdr *root, int vendor, int device,
   ambapp_for_each (root, (OPTIONS_ALL | OPTIONS_AHB_SLVS), vendor, device, 10,
 		   ambapp_dev_find_match, &arg);
 
+  __A_VARIABLE = 1;
   return maxno - arg.count;
 }
 
@@ -620,6 +661,7 @@ int
 ambapp_find_ahbslv_next (struct ambapp_dev_hdr *root, int vendor, int device,
 			 struct ambapp_ahb_info *dev, int index)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_ahbslvs_next (root, vendor, device, dev, index, 1);
 }
 
@@ -627,6 +669,7 @@ int
 ambapp_find_ahbslv (struct ambapp_dev_hdr *root, int vendor, int device,
 		    struct ambapp_ahb_info *dev)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_ahbslvs_next (root, vendor, device, dev, 0, 1);
 }
 
@@ -634,6 +677,7 @@ int
 ambapp_find_ahbslvs (struct ambapp_dev_hdr *root, int vendor, int device,
 		     struct ambapp_ahb_info *dev, int maxno)
 {
+  __A_VARIABLE = 1;
   return ambapp_find_ahbslvs_next (root, vendor, device, dev, 0, maxno);
 }
 
@@ -644,10 +688,12 @@ ambapp_find_parent (struct ambapp_dev_hdr *dev)
     {
       if (dev == dev->prev->children)
 	{
+	  __A_VARIABLE = 1;
 	  return dev->prev;
 	}
       dev = dev->prev;
     }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -676,4 +722,5 @@ pnpinit (void)
       rtc = dev.start + 0x10;
       DPRINTF (("Found rtc at 0x%x\n", rtc));
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/pnpinit_simple.c b/libgloss/sparc_leon/pnpinit_simple.c
index 3fb9801..00b1049 100644
--- a/libgloss/sparc_leon/pnpinit_simple.c
+++ b/libgloss/sparc_leon/pnpinit_simple.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -31,4 +32,5 @@
 void
 pnpinit (void)
 {
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/regwin_patch.c b/libgloss/sparc_leon/regwin_patch.c
index 319403e..5372e58 100644
--- a/libgloss/sparc_leon/regwin_patch.c
+++ b/libgloss/sparc_leon/regwin_patch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -38,6 +39,7 @@ install_winoverflow_hook (void (*func) (void))
 {
   if (installed)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
   if (!installed)
@@ -64,6 +66,7 @@ install_winoverflow_hook (void (*func) (void))
       sparc_leon23_icache_flush ();
       installed = 1;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -79,4 +82,5 @@ uninstall_winoverflow_hook ()
       sparc_leon23_icache_flush ();
       installed = 0;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/sparc_leon/rtc.c b/libgloss/sparc_leon/rtc.c
index a67fb43..1b8e28c 100644
--- a/libgloss/sparc_leon/rtc.c
+++ b/libgloss/sparc_leon/rtc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
diff --git a/libgloss/sparc_leon/timer.c b/libgloss/sparc_leon/timer.c
index 0f4683e..5135ec3 100644
--- a/libgloss/sparc_leon/timer.c
+++ b/libgloss/sparc_leon/timer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -101,6 +102,7 @@ settimer ()
 	}
       e = n;
     }
+    __A_VARIABLE = 1;
 }
 
 int
@@ -119,6 +121,7 @@ Timer_getTimer1 (unsigned int **count, unsigned int **reload,
       break;
     }
   //---------------------
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -139,8 +142,10 @@ Timer_getTimer2 (unsigned int **count, unsigned int **reload,
 	  *ctrl = (unsigned int *) &(LEON3_GpTimer_Regs->e[1].ctrl);
 	  break;
 	}
+      __A_VARIABLE = 1;
       return 0;
     }
   //---------------------
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/sparc_leon/times.c b/libgloss/sparc_leon/times.c
index 817f40a..325656b 100644
--- a/libgloss/sparc_leon/times.c
+++ b/libgloss/sparc_leon/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 Aeroflex Gaisler
  *
@@ -47,12 +48,16 @@ times (struct tms *buffer)
   buffer->tms_stime = 0;
   buffer->tms_cutime = 0;
   buffer->tms_cstime = 0;
+  __A_VARIABLE = 1;
 }
 
 clock_t
 clock (void)
 {
-  if (clock_custom)
+  if (clock_custom) {
+    __A_VARIABLE = 1;
     return clock_custom ();
+  }
+  __A_VARIABLE = 1;
   return (-*rtc);
 }
diff --git a/libgloss/spu/access.c b/libgloss/spu/access.c
index 9c5cea4..b9e9b0a 100644
--- a/libgloss/spu/access.c
+++ b/libgloss/spu/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -46,5 +47,6 @@ access (const char *pathname, int mode)
 
         sys.pathname = (unsigned int) pathname;
         sys.mode = mode;
+        __A_VARIABLE = 1;
         return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_ACCESS, &sys);
 }
diff --git a/libgloss/spu/chdir.c b/libgloss/spu/chdir.c
index a62550e..c82392d 100644
--- a/libgloss/spu/chdir.c
+++ b/libgloss/spu/chdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 chdir (const char *path)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CHDIR, &path);
 }
diff --git a/libgloss/spu/chmod.c b/libgloss/spu/chmod.c
index 40c55bc..3479826 100644
--- a/libgloss/spu/chmod.c
+++ b/libgloss/spu/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ chmod (const char *path, mode_t mode)
 
   sys.path = (unsigned int) path;
   sys.mode = (unsigned int) mode;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CHMOD, &sys);
 }
diff --git a/libgloss/spu/chown.c b/libgloss/spu/chown.c
index c5eab58..ba159ef 100644
--- a/libgloss/spu/chown.c
+++ b/libgloss/spu/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ chown (const char *path, uid_t owner, gid_t group)
   sys.path = (unsigned int) path;
   sys.owner = (unsigned int) owner;
   sys.group = (unsigned int) group;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CHOWN, &sys);
 }
diff --git a/libgloss/spu/close.c b/libgloss/spu/close.c
index 57011f1..ab11f16 100644
--- a/libgloss/spu/close.c
+++ b/libgloss/spu/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -35,5 +36,6 @@ Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 int
 close (int file)
 {
+        __A_VARIABLE = 1;
         return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CLOSE, &file);
 }
diff --git a/libgloss/spu/conv_stat.c b/libgloss/spu/conv_stat.c
index 6b51058..9d13df8 100644
--- a/libgloss/spu/conv_stat.c
+++ b/libgloss/spu/conv_stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -54,4 +55,5 @@ __conv_stat (struct stat *stat, struct jsre_stat *jstat)
   stat->st_atime = jstat->atime;
   stat->st_mtime = jstat->mtime;
   stat->st_ctime = jstat->ctime;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/spu/dirfuncs.c b/libgloss/spu/dirfuncs.c
index adf1b0e..681350a 100644
--- a/libgloss/spu/dirfuncs.c
+++ b/libgloss/spu/dirfuncs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -83,11 +84,13 @@ opendir (const char *name)
       if (!dir->ppc_dir) {
         dir = NULL;
       }
+      __A_VARIABLE = 1;
       return dir;
     }
   }
 
   errno = EMFILE;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -120,6 +123,7 @@ closedir (DIR *dir)
     rc = -1;
     errno = EBADF;
   }
+  __A_VARIABLE = 1;
   return rc;
 }
 
@@ -137,6 +141,7 @@ readdir (DIR *dir)
 
   sys.ppc_dir = dir->ppc_dir;
   sys.dirent = (unsigned int) &dir->dirent;
+  __A_VARIABLE = 1;
   return (struct dirent *) __send_to_ppe (JSRE_POSIX1_SIGNALCODE,
                                          JSRE_READDIR, &sys);
 }
@@ -147,6 +152,7 @@ rewinddir (DIR *dir)
   uint64_t ppc_dir = dir->ppc_dir;
 
   __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_REWINDDIR, &ppc_dir);
+  __A_VARIABLE = 1;
 }
 
 typedef struct {
@@ -164,6 +170,7 @@ seekdir (DIR *dir, off_t offset)
   sys.ppc_dir = dir->ppc_dir;
   sys.offset = offset;
   __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SEEKDIR, &sys);
+  __A_VARIABLE = 1;
 }
 
 off_t
@@ -171,5 +178,6 @@ telldir (DIR *dir)
 {
   uint64_t ppc_dir = dir->ppc_dir;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_TELLDIR, &ppc_dir);
 }
diff --git a/libgloss/spu/dup.c b/libgloss/spu/dup.c
index 325db63..1543f7c 100644
--- a/libgloss/spu/dup.c
+++ b/libgloss/spu/dup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -34,5 +35,6 @@ POSSIBILITY OF SUCH DAMAGE.
 int
 dup (int oldfd)
 {
+        __A_VARIABLE = 1;
         return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_DUP, &oldfd);
 }
diff --git a/libgloss/spu/dup2.c b/libgloss/spu/dup2.c
index 3ae2855..6849eac 100644
--- a/libgloss/spu/dup2.c
+++ b/libgloss/spu/dup2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ dup2 (int oldfd, int newfd)
 
   sys.oldfd = (unsigned int) oldfd;
   sys.newfd = (unsigned int) newfd;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_DUP2, &sys);
 }
diff --git a/libgloss/spu/exit.c b/libgloss/spu/exit.c
index 899f324..01c5602 100644
--- a/libgloss/spu/exit.c
+++ b/libgloss/spu/exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -45,4 +46,5 @@ void _exit(int rc)
 
   for (;;)
     ;
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/spu/fchdir.c b/libgloss/spu/fchdir.c
index e12fbd0..24a4181 100644
--- a/libgloss/spu/fchdir.c
+++ b/libgloss/spu/fchdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 fchdir (int fd)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FCHDIR, &fd);
 }
diff --git a/libgloss/spu/fchmod.c b/libgloss/spu/fchmod.c
index c44d5fc..c3d616f 100644
--- a/libgloss/spu/fchmod.c
+++ b/libgloss/spu/fchmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ fchmod (int filedes, mode_t mode)
 
   sys.filedes = (unsigned int) filedes;
   sys.mode = (unsigned int) mode;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FCHMOD, &sys);
 }
diff --git a/libgloss/spu/fchown.c b/libgloss/spu/fchown.c
index 642c47e..d42d127 100644
--- a/libgloss/spu/fchown.c
+++ b/libgloss/spu/fchown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ fchown (int fd, uid_t owner, gid_t group)
   sys.fd = (unsigned int) fd;
   sys.owner = (unsigned int) owner;
   sys.group = (unsigned int) group;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FCHOWN, &sys);
 }
diff --git a/libgloss/spu/fdatasync.c b/libgloss/spu/fdatasync.c
index 6c06e3f..f52d28a 100644
--- a/libgloss/spu/fdatasync.c
+++ b/libgloss/spu/fdatasync.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 fdatasync (int fd)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FDATASYNC, &fd);
 }
diff --git a/libgloss/spu/fstat.c b/libgloss/spu/fstat.c
index cb983d9..7304664 100644
--- a/libgloss/spu/fstat.c
+++ b/libgloss/spu/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -52,5 +53,6 @@ fstat (int file, struct stat *pstat)
         sys.ptr = ( unsigned int )&pjstat;
         ret = __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FSTAT, &sys);
         __conv_stat (pstat, &pjstat);
+        __A_VARIABLE = 1;
         return ret;
 }
diff --git a/libgloss/spu/fsync.c b/libgloss/spu/fsync.c
index 7756659..43cd488 100644
--- a/libgloss/spu/fsync.c
+++ b/libgloss/spu/fsync.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 fsync (int fd)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FSYNC, &fd);
 }
diff --git a/libgloss/spu/ftruncate.c b/libgloss/spu/ftruncate.c
index 138f60e..21978f0 100644
--- a/libgloss/spu/ftruncate.c
+++ b/libgloss/spu/ftruncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -46,5 +47,6 @@ ftruncate (int file, off_t length)
 
 	sys.file = file;
 	sys.length = length;
+	__A_VARIABLE = 1;
 	return __send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_FTRUNCATE, &sys);
 }
diff --git a/libgloss/spu/getcwd.c b/libgloss/spu/getcwd.c
index 482af22..d7d3139 100644
--- a/libgloss/spu/getcwd.c
+++ b/libgloss/spu/getcwd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -74,6 +75,7 @@ getcwd (char *buf, size_t size)
       /*
        * Leave errno as set by malloc.
        */
+      __A_VARIABLE = 1;
       return NULL;
     }
   }
@@ -92,6 +94,7 @@ getcwd (char *buf, size_t size)
     newbuf = realloc (buf, size);
     if (!newbuf) {
       free (buf);
+      __A_VARIABLE = 1;
       return NULL;
     }
     buf = newbuf;
@@ -105,5 +108,6 @@ getcwd (char *buf, size_t size)
     free (buf);
   }
 
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/libgloss/spu/getitimer.c b/libgloss/spu/getitimer.c
index df28b0f..ba38b5a 100644
--- a/libgloss/spu/getitimer.c
+++ b/libgloss/spu/getitimer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -39,6 +40,7 @@ int
 getitimer (int which, struct itimerval *value)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/spu/getpagesize.c b/libgloss/spu/getpagesize.c
index 417426c..14f58e6 100644
--- a/libgloss/spu/getpagesize.c
+++ b/libgloss/spu/getpagesize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
diff --git a/libgloss/spu/getpid.c b/libgloss/spu/getpid.c
index ff2d820..01b2d72 100644
--- a/libgloss/spu/getpid.c
+++ b/libgloss/spu/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -33,6 +34,7 @@ Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 int
 getpid ()
 {
+	__A_VARIABLE = 1;
 	return (1);
 }
 
diff --git a/libgloss/spu/gettimeofday.c b/libgloss/spu/gettimeofday.c
index 9b32efb..81b4581 100644
--- a/libgloss/spu/gettimeofday.c
+++ b/libgloss/spu/gettimeofday.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007
 
@@ -49,5 +50,6 @@ gettimeofday (struct timeval *tv, void *tz)
 
 	sys.tv = (unsigned int)tv;
 	sys.tz = (unsigned int)tz;
+	__A_VARIABLE = 1;
 	return __send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_GETTIMEOFDAY, &sys);
 }
diff --git a/libgloss/spu/isatty.c b/libgloss/spu/isatty.c
index 7a20e15..b748654 100644
--- a/libgloss/spu/isatty.c
+++ b/libgloss/spu/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -33,6 +34,7 @@ Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 int
 isatty (int fd)
 {
+	__A_VARIABLE = 1;
 	return (0);
 }
 
diff --git a/libgloss/spu/kill.c b/libgloss/spu/kill.c
index 1aa2f5e..ce20bcf 100644
--- a/libgloss/spu/kill.c
+++ b/libgloss/spu/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -41,6 +42,7 @@ kill (int pid, int sig)
 		  _exit (sig);
 	  }
 	errno = ESRCH;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
diff --git a/libgloss/spu/lchown.c b/libgloss/spu/lchown.c
index 904232a..7696a57 100644
--- a/libgloss/spu/lchown.c
+++ b/libgloss/spu/lchown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ lchown (const char *path, uid_t owner, gid_t group)
   sys.path = (unsigned int) path;
   sys.owner = (unsigned int) owner;
   sys.group = (unsigned int) group;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LCHOWN, &sys);
 }
diff --git a/libgloss/spu/link.c b/libgloss/spu/link.c
index dde2a0d..cf91fe5 100644
--- a/libgloss/spu/link.c
+++ b/libgloss/spu/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ link (const char *oldpath, const char *newpath)
 
   sys.oldpath = (unsigned int) oldpath;
   sys.newpath = (unsigned int) newpath;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LINK, &sys);
 }
diff --git a/libgloss/spu/linux_getpid.c b/libgloss/spu/linux_getpid.c
index 9473ea5..441c7f7 100644
--- a/libgloss/spu/linux_getpid.c
+++ b/libgloss/spu/linux_getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -46,5 +47,6 @@ linux_getpid (void)
      0,
      0}
   };
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/libgloss/spu/linux_gettid.c b/libgloss/spu/linux_gettid.c
index 789c792..b2e29a2 100644
--- a/libgloss/spu/linux_gettid.c
+++ b/libgloss/spu/linux_gettid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -46,5 +47,6 @@ linux_gettid (void)
      0,
      0}
   };
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/libgloss/spu/linux_syscalls.c b/libgloss/spu/linux_syscalls.c
index 1ecc241..b249b97 100644
--- a/libgloss/spu/linux_syscalls.c
+++ b/libgloss/spu/linux_syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
diff --git a/libgloss/spu/lockf.c b/libgloss/spu/lockf.c
index 3d2d7dc..1cbd01e 100644
--- a/libgloss/spu/lockf.c
+++ b/libgloss/spu/lockf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ lockf (int fd, int cmd, off_t len)
   sys.fd = (unsigned int) fd;
   sys.cmd = (unsigned int) cmd;
   sys.len = (unsigned int) len;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LOCKF, &sys);
 }
diff --git a/libgloss/spu/lseek.c b/libgloss/spu/lseek.c
index e5b3b75..f8e1814 100644
--- a/libgloss/spu/lseek.c
+++ b/libgloss/spu/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -67,5 +68,6 @@ lseek (int file, off_t offset, int whence)
 			break;
 	}
 
+	__A_VARIABLE = 1;
 	return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LSEEK, &sys);
 }
diff --git a/libgloss/spu/lstat.c b/libgloss/spu/lstat.c
index f34e0a3..270d180 100644
--- a/libgloss/spu/lstat.c
+++ b/libgloss/spu/lstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -54,5 +55,6 @@ lstat (const char *__restrict pathname, struct stat *__restrict pstat)
   sys.ptr = ( unsigned int )&pjstat;
   ret = __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LSTAT, &sys);
   __conv_stat (pstat, &pjstat);
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/libgloss/spu/mkdir.c b/libgloss/spu/mkdir.c
index 9d0def7..aac57c9 100644
--- a/libgloss/spu/mkdir.c
+++ b/libgloss/spu/mkdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ mkdir (const char *path, mode_t mode)
 
   sys.path = (unsigned int) path;
   sys.mode = (unsigned int) mode;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_MKDIR, &sys);
 }
diff --git a/libgloss/spu/mknod.c b/libgloss/spu/mknod.c
index 42e3060..4e0d5d3 100644
--- a/libgloss/spu/mknod.c
+++ b/libgloss/spu/mknod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ mknod (const char *path, mode_t mode, dev_t dev)
   sys.path = (unsigned int) path;
   sys.mode = (unsigned int) mode;
   sys.dev = (unsigned int) dev;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_MKNOD, &sys);
 }
diff --git a/libgloss/spu/mkstemp.c b/libgloss/spu/mkstemp.c
index f94ef4d..626fae7 100644
--- a/libgloss/spu/mkstemp.c
+++ b/libgloss/spu/mkstemp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 mkstemp (char *template)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_MKSTEMP, &template);
 }
diff --git a/libgloss/spu/mktemp.c b/libgloss/spu/mktemp.c
index b13f19f..f0581f0 100644
--- a/libgloss/spu/mktemp.c
+++ b/libgloss/spu/mktemp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 char *
 mktemp (char *template)
 {
+  __A_VARIABLE = 1;
   return (char *) __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_MKTEMP, &template);
 }
diff --git a/libgloss/spu/mmap_eaddr.c b/libgloss/spu/mmap_eaddr.c
index 1ca0301..2ef3174 100644
--- a/libgloss/spu/mmap_eaddr.c
+++ b/libgloss/spu/mmap_eaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007
 
@@ -63,5 +64,6 @@ unsigned long long mmap_eaddr(unsigned long long start, size_t length, int
   /*
    * Extract 64 bit result from the result stored in sys.
    */
+  __A_VARIABLE = 1;
   return *(unsigned long long *) (&sys);
 }
diff --git a/libgloss/spu/mremap_eaddr.c b/libgloss/spu/mremap_eaddr.c
index df0ea2f..0f0289f 100644
--- a/libgloss/spu/mremap_eaddr.c
+++ b/libgloss/spu/mremap_eaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007
 
@@ -57,5 +58,6 @@ unsigned long long mremap_eaddr(unsigned long long old_addr, size_t old_size,
   /*
    * Extract 64 bit result from the result stored in sys.
    */
+  __A_VARIABLE = 1;
   return *(unsigned long long *) (&sys);
 }
diff --git a/libgloss/spu/msync_eaddr.c b/libgloss/spu/msync_eaddr.c
index ecfbbea..55bde60 100644
--- a/libgloss/spu/msync_eaddr.c
+++ b/libgloss/spu/msync_eaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007
 
@@ -54,5 +55,6 @@ unsigned long long msync_eaddr(unsigned long long start, size_t length,
   /*
    * Extract 64 bit result from the result stored in sys.
    */
+  __A_VARIABLE = 1;
   return *(unsigned long long *) (&sys);
 }
diff --git a/libgloss/spu/munmap_eaddr.c b/libgloss/spu/munmap_eaddr.c
index ac7a724..55dfb17 100644
--- a/libgloss/spu/munmap_eaddr.c
+++ b/libgloss/spu/munmap_eaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007
 
@@ -50,5 +51,6 @@ unsigned long long munmap_eaddr(unsigned long long start, size_t length)
   /*
    * Extract 64 bit result from the result stored in sys.
    */
+  __A_VARIABLE = 1;
   return *(unsigned long long *) (&sys);
 }
diff --git a/libgloss/spu/nanosleep.c b/libgloss/spu/nanosleep.c
index 937147c..97c9773 100644
--- a/libgloss/spu/nanosleep.c
+++ b/libgloss/spu/nanosleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -48,5 +49,6 @@ nanosleep(const struct timespec *req, struct timespec *rem)
 
   sys.req = (unsigned int) req;
   sys.rem = (unsigned int) rem;
+  __A_VARIABLE = 1;
   return __send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_NANOSLEEP, &sys);
 }
diff --git a/libgloss/spu/open.c b/libgloss/spu/open.c
index 0c1b253..d77a8da 100644
--- a/libgloss/spu/open.c
+++ b/libgloss/spu/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -92,5 +93,6 @@ open (const char *filename, int flags, ...)
         sys.mode = va_arg (ap, int);
         va_end (ap);
 
+        __A_VARIABLE = 1;
         return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_OPEN, &sys);
 }
diff --git a/libgloss/spu/pread.c b/libgloss/spu/pread.c
index a2f04b7..690f99f 100644
--- a/libgloss/spu/pread.c
+++ b/libgloss/spu/pread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -54,5 +55,6 @@ ssize_t pread(int fd, void *buf, size_t count, off_t offset)
   sys.buf = (unsigned int) buf;
   sys.count = (unsigned int) count;
   sys.offset = (unsigned int) offset;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_PREAD, &sys);
 }
diff --git a/libgloss/spu/pwrite.c b/libgloss/spu/pwrite.c
index af269ff..fe72ebb 100644
--- a/libgloss/spu/pwrite.c
+++ b/libgloss/spu/pwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -54,5 +55,6 @@ ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset)
   sys.buf = (unsigned int) buf;
   sys.count = (unsigned int) count;
   sys.offset = (unsigned int) offset;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_PWRITE, &sys);
 }
diff --git a/libgloss/spu/read.c b/libgloss/spu/read.c
index 4e7189c..1815f50 100644
--- a/libgloss/spu/read.c
+++ b/libgloss/spu/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -51,5 +52,6 @@ read (int file, void *ptr, size_t len)
 	sys.file = file;
 	sys.ptr = ( unsigned int )ptr;
 	sys.len = len;
+	__A_VARIABLE = 1;
 	return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_READ, &sys);
 }
diff --git a/libgloss/spu/readlink.c b/libgloss/spu/readlink.c
index 7a3dc95..e441ff3 100644
--- a/libgloss/spu/readlink.c
+++ b/libgloss/spu/readlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -52,5 +53,6 @@ readlink (const char *path, char *buf, size_t bufsiz)
   sys.path = (unsigned int) path;
   sys.buf = (unsigned int) buf;
   sys.bufsiz = (unsigned int) bufsiz;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_READLINK, &sys);
 }
diff --git a/libgloss/spu/readv.c b/libgloss/spu/readv.c
index 5dd00f8..bf76a93 100644
--- a/libgloss/spu/readv.c
+++ b/libgloss/spu/readv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -51,5 +52,6 @@ ssize_t readv(int fd, const struct iovec *vec, int count)
   sys.fd = (unsigned int) fd;
   sys.vec = (unsigned int) vec;
   sys.count = (unsigned int) count;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_READV, &sys);
 }
diff --git a/libgloss/spu/rmdir.c b/libgloss/spu/rmdir.c
index fcd8509..f516d68 100644
--- a/libgloss/spu/rmdir.c
+++ b/libgloss/spu/rmdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 rmdir (const char *path)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_RMDIR, &path);
 }
diff --git a/libgloss/spu/sbrk.c b/libgloss/spu/sbrk.c
index 00c8d97..2852da8 100644
--- a/libgloss/spu/sbrk.c
+++ b/libgloss/spu/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
diff --git a/libgloss/spu/sched_yield.c b/libgloss/spu/sched_yield.c
index 487e8e4..f2cb10d 100644
--- a/libgloss/spu/sched_yield.c
+++ b/libgloss/spu/sched_yield.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -45,5 +46,6 @@ sched_yield (void)
 {
   struct_sched_yield_t sys;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SCHED_YIELD, &sys);
 }
diff --git a/libgloss/spu/setitimer.c b/libgloss/spu/setitimer.c
index 9d9072d..1bf5555 100644
--- a/libgloss/spu/setitimer.c
+++ b/libgloss/spu/setitimer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -39,6 +40,7 @@ int
 setitimer (int which, const struct itimerval *value, struct itimerval *ovalue)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/spu/shm_open.c b/libgloss/spu/shm_open.c
index dbd0ee9..7c68b8f 100644
--- a/libgloss/spu/shm_open.c
+++ b/libgloss/spu/shm_open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ int shm_open (const char *name, int oflag, mode_t mode)
   sys.name = (char *) name;
   sys.oflag = oflag;
   sys.mode = mode;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SHM_OPEN, &sys);
 }
diff --git a/libgloss/spu/shm_unlink.c b/libgloss/spu/shm_unlink.c
index 93c31d3..a639cae 100644
--- a/libgloss/spu/shm_unlink.c
+++ b/libgloss/spu/shm_unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -34,5 +35,6 @@
 
 int shm_unlink (const char *name)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SHM_UNLINK, &name);
 }
diff --git a/libgloss/spu/stat.c b/libgloss/spu/stat.c
index 79be7dc..1af5092 100644
--- a/libgloss/spu/stat.c
+++ b/libgloss/spu/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -53,5 +54,6 @@ stat (const char *pathname, struct stat *pstat)
 	sys.ptr = ( unsigned int )&pjstat;
 	ret = __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_STAT, &sys);
 	__conv_stat (pstat, &pjstat);
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/libgloss/spu/symlink.c b/libgloss/spu/symlink.c
index f95825b..719734c 100644
--- a/libgloss/spu/symlink.c
+++ b/libgloss/spu/symlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ symlink (const char *oldpath, const char *newpath)
 
   sys.oldpath = (unsigned int) oldpath;
   sys.newpath = (unsigned int) newpath;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SYMLINK, &sys);
 }
diff --git a/libgloss/spu/sync.c b/libgloss/spu/sync.c
index 6b74f8e..0a282aa 100644
--- a/libgloss/spu/sync.c
+++ b/libgloss/spu/sync.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -40,4 +41,5 @@ sync (void)
   int sys;
 
   __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_SYNC, &sys);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/spu/syscalls.c b/libgloss/spu/syscalls.c
index 7e85fa5..849de35 100644
--- a/libgloss/spu/syscalls.c
+++ b/libgloss/spu/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
diff --git a/libgloss/spu/times.c b/libgloss/spu/times.c
index 40a4e8b..7c24b18 100644
--- a/libgloss/spu/times.c
+++ b/libgloss/spu/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -39,6 +40,7 @@ clock_t
 times (struct tms *buffer)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/libgloss/spu/truncate.c b/libgloss/spu/truncate.c
index 2f81baa..c71133f 100644
--- a/libgloss/spu/truncate.c
+++ b/libgloss/spu/truncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -49,5 +50,6 @@ truncate (const char *path, off_t length)
 
   sys.path = (unsigned int) path;
   sys.length = (unsigned int) length;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_TRUNCATE, &sys);
 }
diff --git a/libgloss/spu/umask.c b/libgloss/spu/umask.c
index 1202f8f..56b010d 100644
--- a/libgloss/spu/umask.c
+++ b/libgloss/spu/umask.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 mode_t
 umask (mode_t mask)
 {
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UMASK, &mask);
 }
diff --git a/libgloss/spu/unlink.c b/libgloss/spu/unlink.c
index 6c5dadd..49583a1 100644
--- a/libgloss/spu/unlink.c
+++ b/libgloss/spu/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -35,5 +36,6 @@ Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 int
 unlink (const char *pathname)
 {
+        __A_VARIABLE = 1;
         return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UNLINK, &pathname);
 }
diff --git a/libgloss/spu/utime.c b/libgloss/spu/utime.c
index 7f3897f..e31452b 100644
--- a/libgloss/spu/utime.c
+++ b/libgloss/spu/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -50,5 +51,6 @@ utime (const char *filename, const struct utimbuf *buf)
 
   sys.filename = (unsigned int) filename;
   sys.buf = (unsigned int) buf;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UTIME, &sys);
 }
diff --git a/libgloss/spu/utimes.c b/libgloss/spu/utimes.c
index 1bbadde..e3f5adc 100644
--- a/libgloss/spu/utimes.c
+++ b/libgloss/spu/utimes.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -51,5 +52,6 @@ utimes (const char *filename, const struct timeval times[2])
 
   sys.filename = (unsigned int) filename;
   sys.times = (unsigned int) times;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UTIMES, &sys);
 }
diff --git a/libgloss/spu/write.c b/libgloss/spu/write.c
index 7cd5e5a..0cbe8eb 100644
--- a/libgloss/spu/write.c
+++ b/libgloss/spu/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2005, 2006
 
@@ -51,5 +52,6 @@ write (int file, const void *ptr, size_t len)
 	sys.file = file;
 	sys.ptr = ( unsigned int )ptr;
 	sys.len = len;
+	__A_VARIABLE = 1;
 	return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_WRITE, &sys);
 }
diff --git a/libgloss/spu/writev.c b/libgloss/spu/writev.c
index a0373a6..ad0d553 100644
--- a/libgloss/spu/writev.c
+++ b/libgloss/spu/writev.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   Copyright 2007
   International Business Machines Corporation,
@@ -51,5 +52,6 @@ ssize_t writev(int fd, const struct iovec *vec, int count)
   sys.fd = (unsigned int) fd;
   sys.vec = (unsigned int) vec;
   sys.count = (unsigned int) count;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_WRITEV, &sys);
 }
diff --git a/libgloss/stat.c b/libgloss/stat.c
index ebb7de3..109bd0e 100644
--- a/libgloss/stat.c
+++ b/libgloss/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,6 +26,7 @@ _DEFUN (stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/testsuite/config/support.c b/libgloss/testsuite/config/support.c
index 2fc7bcc..229d3eb 100644
--- a/libgloss/testsuite/config/support.c
+++ b/libgloss/testsuite/config/support.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * support.c -- minimal support functions. This is to keep the exit code
  * 	generic enough that pattern matching from expect should be easier.
diff --git a/libgloss/testsuite/libgloss.all/array.c b/libgloss/testsuite/libgloss.all/array.c
index 14b6fdb..99e48a3 100644
--- a/libgloss/testsuite/libgloss.all/array.c
+++ b/libgloss/testsuite/libgloss.all/array.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* WinBond bug report
 
    this is a compile test. At one time static arrays over 500 elements
@@ -15,4 +16,5 @@ main()
   static int dd[500];
   pass ("large arrays");
   fflush(stdout);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/testsuite/libgloss.all/div.c b/libgloss/testsuite/libgloss.all/div.c
index 32eff9d..9f1385f 100644
--- a/libgloss/testsuite/libgloss.all/div.c
+++ b/libgloss/testsuite/libgloss.all/div.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* WinBond bug report
 
    Please don't use "gcc -O3 -S hello.c" command, because it
@@ -30,6 +31,7 @@ main ()
     }
     fflush (stdout);
   }
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/libgloss/testsuite/libgloss.all/double.c b/libgloss/testsuite/libgloss.all/double.c
index e648191..3c0fb25 100644
--- a/libgloss/testsuite/libgloss.all/double.c
+++ b/libgloss/testsuite/libgloss.all/double.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI001](gcc008_1)
 
         The following program is not executed.
@@ -20,6 +21,7 @@ main ()
 
   pass ("double [OKI001]");
   fflush(stdout);
+  __A_VARIABLE = 1;
 }
 
 double
@@ -27,6 +29,7 @@ dcall (d)
      double d;
 {
   int Zero = 0;
+  __A_VARIABLE = 1;
   return d + Zero;
 }
 
diff --git a/libgloss/testsuite/libgloss.all/float.c b/libgloss/testsuite/libgloss.all/float.c
index bbe41ca..085fd22 100644
--- a/libgloss/testsuite/libgloss.all/float.c
+++ b/libgloss/testsuite/libgloss.all/float.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 main()
@@ -16,5 +17,6 @@ main()
 
   pass ("float");
   fflush (stdout);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/testsuite/libgloss.all/func.c b/libgloss/testsuite/libgloss.all/func.c
index 50ca207..b1b3f96 100644
--- a/libgloss/testsuite/libgloss.all/func.c
+++ b/libgloss/testsuite/libgloss.all/func.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI002](gcc008_2)
 
         The following program is not executed.
@@ -18,9 +19,11 @@ void main ()
         func (2, 1., 2., 3.);
 	pass ("func [OKI002]");
 	fflush (stdout);
+	__A_VARIABLE = 1;
 }
 
 int func (int i, ...)
 {
+        __A_VARIABLE = 1;
         return (i);
 }
diff --git a/libgloss/testsuite/libgloss.all/io.c b/libgloss/testsuite/libgloss.all/io.c
index 5ad93ef..a21442a 100644
--- a/libgloss/testsuite/libgloss.all/io.c
+++ b/libgloss/testsuite/libgloss.all/io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  io.c -- Test the serial I/O.
  */
@@ -66,6 +67,7 @@ main()
 
   /* clear everything out */
   fflush (stdout);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/libgloss/testsuite/libgloss.all/math.c b/libgloss/testsuite/libgloss.all/math.c
index fe137da..1ce1b6f 100644
--- a/libgloss/testsuite/libgloss.all/math.c
+++ b/libgloss/testsuite/libgloss.all/math.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI004](gcc005)
 
           The following computation is no work.
@@ -40,6 +41,7 @@ main ()
 	fflush (stdout);
 
 	test_1();
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -84,5 +86,6 @@ test_1()
   j = -4;
   value = i / (j);
   printf ("%d / (%d) =  %d\n", i, j, value);
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/testsuite/libgloss.all/memory.c b/libgloss/testsuite/libgloss.all/memory.c
index 6e0422d..cddf395 100644
--- a/libgloss/testsuite/libgloss.all/memory.c
+++ b/libgloss/testsuite/libgloss.all/memory.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* WinBond bug report
 
    malloc() returns 0x0.
@@ -35,4 +36,5 @@ main()
   /* see if we can free it up. FIXME: how to test free ?*/
   free (buf);
   fflush (stdout);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/testsuite/libgloss.all/misc.c b/libgloss/testsuite/libgloss.all/misc.c
index 5d082bc..9d08342 100644
--- a/libgloss/testsuite/libgloss.all/misc.c
+++ b/libgloss/testsuite/libgloss.all/misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * this file contains misc bug reports from WinBond.
  */
@@ -72,6 +73,7 @@ main()
   test_4();
 
   fflush (stdout);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -98,6 +100,7 @@ test_1()
   } else {
     pass ("float multiple 2");
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -119,6 +122,7 @@ test_2()
   } else {
     pass ("float divide 1");
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -138,6 +142,7 @@ test_3()
   } else {
     pass ("float divide 1");
   }
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -159,6 +164,7 @@ test_4()
   printf ("1.0 = %E, 0.3010 = %E, -1.0 = %E\n", 1.0, 0.3010, -1.0);
   printf ("These test only pass if the outut matches:\nCorrect output is\nans = 1.000000E+00, ans1 = 3.010000E-01, ans2 = -1.000000E+00\n");
   printf ("ans = %E, ans1 = %E, ans2 = %E\n", ans, ans1, ans2);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/libgloss/testsuite/libgloss.all/printf.c b/libgloss/testsuite/libgloss.all/printf.c
index 4aff104..344d10e 100644
--- a/libgloss/testsuite/libgloss.all/printf.c
+++ b/libgloss/testsuite/libgloss.all/printf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI006]
 
         The following program is no work.
@@ -28,4 +29,5 @@ main ()
         iprintf ("Value = %d, %d\r\n", 2, 1);
 	pass ("iprintf [OKI007]");
 	fflush (stdout);
+	__A_VARIABLE = 1;
 }
diff --git a/libgloss/testsuite/libgloss.all/struct.c b/libgloss/testsuite/libgloss.all/struct.c
index 799f9a5..a68302e 100644
--- a/libgloss/testsuite/libgloss.all/struct.c
+++ b/libgloss/testsuite/libgloss.all/struct.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report, no number. Here's the output the error generates.
 
     gcc -c -g -ansi  oki008.c -o oki008.o -msoft-float
@@ -40,8 +41,10 @@ char *_malloc(size)
         pbuf += size;
         if (pbuf >= &buf[sizeof (buf)]) {
                 printf("_malloc error\n");
+                __A_VARIABLE = 1;
                 return (0);
         }
+        __A_VARIABLE = 1;
         return (p);
 }
 
@@ -50,6 +53,7 @@ main()
         Proc0();
 	pass ("struct");
 	fflush (stdout);
+        __A_VARIABLE = 1;
         return (0);
 }
 
@@ -62,4 +66,5 @@ Proc0()
         register unsigned int   i;
 
         PtrGlbNext = (RecordPtr) _malloc(sizeof(RecordType));
+        __A_VARIABLE = 1;
 }
diff --git a/libgloss/testsuite/libgloss.all/varargs.c b/libgloss/testsuite/libgloss.all/varargs.c
index c055574..1131681 100644
--- a/libgloss/testsuite/libgloss.all/varargs.c
+++ b/libgloss/testsuite/libgloss.all/varargs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI013]
  
    Variable argments test failed.
@@ -18,6 +19,7 @@ int     func(int, ...);
 main()
 {
         func(2, 1., 2., 3.);
+        __A_VARIABLE = 1;
 }
 
 func(int i, ...)
@@ -30,6 +32,7 @@ func(int i, ...)
                 dequals(__LINE__, (double)j, va_arg(p, double));
         }
         va_end(p);
+        __A_VARIABLE = 1;
         return (i);
 }
 
@@ -42,5 +45,6 @@ dequals(int line, double val1, double val2)
                 fail ("varargs [OKI013]");
 
         fflush (stdout);
+        __A_VARIABLE = 1;
         return;
 }
diff --git a/libgloss/testsuite/libgloss.all/varargs2.c b/libgloss/testsuite/libgloss.all/varargs2.c
index 9e590fc..a838d4f 100644
--- a/libgloss/testsuite/libgloss.all/varargs2.c
+++ b/libgloss/testsuite/libgloss.all/varargs2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Oki bug report [OKI013] 
 
    Variable argments test failed.
@@ -18,6 +19,7 @@ int     func();
 main()
 {
         func(1., 2., 3.);
+        __A_VARIABLE = 1;
 }
 
 func(va_alist)
@@ -44,5 +46,6 @@ dequals(double val1, double val2)
                 fail ("varargs2 [OKI013]");
 
         fflush (stdout);
+        __A_VARIABLE = 1;
         return;
 }
diff --git a/libgloss/tic6x/getpid.c b/libgloss/tic6x/getpid.c
index 3c1a7b8..cf584d4 100644
--- a/libgloss/tic6x/getpid.c
+++ b/libgloss/tic6x/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -22,5 +23,6 @@ int
 _DEFUN (getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/tic6x/kill.c b/libgloss/tic6x/kill.c
index 3ed228f..b47ecfd 100644
--- a/libgloss/tic6x/kill.c
+++ b/libgloss/tic6x/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,5 +26,6 @@ _DEFUN (kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/tic6x/sbrk.c b/libgloss/tic6x/sbrk.c
index 5bb645e..83026b0 100644
--- a/libgloss/tic6x/sbrk.c
+++ b/libgloss/tic6x/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c -- Implementation of the low-level sbrk() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -50,10 +51,12 @@ void * sbrk (ptrdiff_t size)
   { 
     /* top of heap is bigger than _HEAP_MAX */
     errno = ENOMEM;
+    __A_VARIABLE = 1;
     return (void *) -1;
   }
 
   /* success: update heap_ptr and return previous value */
   heap_ptr += size;
+  __A_VARIABLE = 1;
   return (void *)old_heap_ptr;
 }
diff --git a/libgloss/tic6x/syscalls.c b/libgloss/tic6x/syscalls.c
index 393fba6..ea3a933 100644
--- a/libgloss/tic6x/syscalls.c
+++ b/libgloss/tic6x/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2010 CodeSourcery, Inc.
    All rights reserved.
 
@@ -240,6 +241,7 @@ semi_call_wrapper (unsigned char command, const char *data,
   if (data != NULL)
     memcpy (_CIOBUF_.u.to_host.data, data, length);
   do_semi_call ();
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -254,6 +256,7 @@ semi_call_wrapper2 (unsigned char command, const char *data1,
   if (data2 != NULL)
     memcpy (_CIOBUF_.u.to_host.data + length1, data2, length2);
   do_semi_call ();
+  __A_VARIABLE = 1;
 }
 
 void
@@ -262,6 +265,7 @@ _exit (int status)
   /* The semihosting interface appears to provide no way to return an
      exit status.  */
   asm volatile (".globl C$$EXIT\nnop\nC$$EXIT:nop");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -275,8 +279,11 @@ open (const char *path, int flags, ...)
   _CIOBUF_.u.to_host.parms.open.flags = SWAPSHORT (flags);
   semi_call_wrapper (_DTOPEN, path, strlen (path) + 1);
   ret_fd = SWAPSHORT (_CIOBUF_.u.from_host.parms.open.fd);
-  if (ret_fd == -1)
+  if (ret_fd == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
+  __A_VARIABLE = 1;
   return suggest_fd;
 }
 
@@ -285,6 +292,7 @@ close (int fd)
 {
   _CIOBUF_.u.to_host.parms.close.fd = SWAPSHORT (fd);
   semi_call_wrapper (_DTCLOSE, NULL, 0);
+  __A_VARIABLE = 1;
   return SWAPSHORT (_CIOBUF_.u.from_host.parms.close.result);
 }
 
@@ -297,6 +305,7 @@ read (int fd, char *ptr, int len)
   _CIOBUF_.u.to_host.parms.read.length = SWAPSHORT (len);
   semi_call_wrapper (_DTREAD, NULL, 0);
   memcpy (ptr, _CIOBUF_.u.from_host.data, _CIOBUF_.u.from_host.length);
+  __A_VARIABLE = 1;
   return SWAPSHORT (_CIOBUF_.u.from_host.parms.read.result);
 }
 
@@ -308,6 +317,7 @@ write (int fd, char *ptr, int len)
   _CIOBUF_.u.to_host.parms.write.fd = SWAPSHORT (fd);
   _CIOBUF_.u.to_host.parms.write.length = SWAPSHORT (len);
   semi_call_wrapper (_DTWRITE, ptr, len);
+  __A_VARIABLE = 1;
   return SWAPSHORT (_CIOBUF_.u.from_host.parms.write.result);
 }
 
@@ -318,6 +328,7 @@ lseek (int fd, int offset, int whence)
   _CIOBUF_.u.to_host.parms.lseek.offset = SWAPINT (offset);
   _CIOBUF_.u.to_host.parms.lseek.whence = SWAPSHORT (whence);
   semi_call_wrapper (_DTLSEEK, NULL, 0);
+  __A_VARIABLE = 1;
   return SWAPINT (_CIOBUF_.u.from_host.parms.lseek.result);
 }
 
@@ -325,6 +336,7 @@ int
 unlink (const char *path)
 {
   semi_call_wrapper (_DTUNLINK, path, strlen (path) + 1);
+  __A_VARIABLE = 1;
   return SWAPSHORT (_CIOBUF_.u.from_host.parms.unlink.result);
 }
 
@@ -333,6 +345,7 @@ rename (const char *oldpath, const char *newpath)
 {
   semi_call_wrapper2 (_DTRENAME, oldpath, strlen (oldpath) + 1,
 		      newpath, strlen (newpath) + 1);
+  __A_VARIABLE = 1;
   return SWAPSHORT (_CIOBUF_.u.from_host.parms.rename.result);
 }
 
@@ -354,6 +367,7 @@ gettimeofday (struct timeval *tp, void *tzvp)
       tzp->tz_dsttime = 0;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -361,6 +375,7 @@ clock_t
 clock (void)
 {
   semi_call_wrapper (_DTGETCLK, NULL, 0);
+  __A_VARIABLE = 1;
   return SWAPINT (_CIOBUF_.u.from_host.parms.getclk.result);
 }
 
@@ -369,6 +384,7 @@ int
 isatty (int file __attribute__((unused)))
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -378,5 +394,6 @@ fstat (int fd, struct stat *buf)
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/unlink.c b/libgloss/unlink.c
index 15ea7e8..643763d 100644
--- a/libgloss/unlink.c
+++ b/libgloss/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink.c -- remove a file.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (unlink, (path),
         char * path)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
diff --git a/libgloss/v850/_exit.c b/libgloss/v850/_exit.c
index b45ae96..8ba26c0 100644
--- a/libgloss/v850/_exit.c
+++ b/libgloss/v850/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -20,6 +21,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -31,4 +33,5 @@ void _exit (n)
   _do_dtors();
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/v850/access.c b/libgloss/v850/access.c
index 980682e..b71fa38 100644
--- a/libgloss/v850/access.c
+++ b/libgloss/v850/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/libgloss/v850/chmod.c b/libgloss/v850/chmod.c
index c86e5c9..3e015de 100644
--- a/libgloss/v850/chmod.c
+++ b/libgloss/v850/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/libgloss/v850/chown.c b/libgloss/v850/chown.c
index 0344d77..a93b1a4 100644
--- a/libgloss/v850/chown.c
+++ b/libgloss/v850/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/libgloss/v850/close.c b/libgloss/v850/close.c
index 3c62f68..91a30ea 100644
--- a/libgloss/v850/close.c
+++ b/libgloss/v850/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/libgloss/v850/creat.c b/libgloss/v850/creat.c
index 8d468a6..b04c13d 100644
--- a/libgloss/v850/creat.c
+++ b/libgloss/v850/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/libgloss/v850/crt1.c b/libgloss/v850/crt1.c
index dd0be31..840f8d2 100644
--- a/libgloss/v850/crt1.c
+++ b/libgloss/v850/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
   static int initialized;
@@ -13,4 +14,5 @@ void __main ()
 	(*--p) ();
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/v850/execv.c b/libgloss/v850/execv.c
index 5286be6..8d9bdcf 100644
--- a/libgloss/v850/execv.c
+++ b/libgloss/v850/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/libgloss/v850/execve.c b/libgloss/v850/execve.c
index b8d97f9..08dd7b5 100644
--- a/libgloss/v850/execve.c
+++ b/libgloss/v850/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/libgloss/v850/fork.c b/libgloss/v850/fork.c
index 116116c..48adff1 100644
--- a/libgloss/v850/fork.c
+++ b/libgloss/v850/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/libgloss/v850/fstat.c b/libgloss/v850/fstat.c
index e8783b3..5972f8a 100644
--- a/libgloss/v850/fstat.c
+++ b/libgloss/v850/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _fstat (int file,
 	struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/v850/getpid.c b/libgloss/v850/getpid.c
index 18fd149..2d57b2d 100644
--- a/libgloss/v850/getpid.c
+++ b/libgloss/v850/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -11,5 +12,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/v850/gettime.c b/libgloss/v850/gettime.c
index fc47532..dd78c62 100644
--- a/libgloss/v850/gettime.c
+++ b/libgloss/v850/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/libgloss/v850/isatty.c b/libgloss/v850/isatty.c
index 95d2c0e..aa041c6 100644
--- a/libgloss/v850/isatty.c
+++ b/libgloss/v850/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/v850/kill.c b/libgloss/v850/kill.c
index b8e5395..ba33b46 100644
--- a/libgloss/v850/kill.c
+++ b/libgloss/v850/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/libgloss/v850/link.c b/libgloss/v850/link.c
index 9776d79..68f1b75 100644
--- a/libgloss/v850/link.c
+++ b/libgloss/v850/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _link ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/v850/lseek.c b/libgloss/v850/lseek.c
index b5d3ef0..820b45a 100644
--- a/libgloss/v850/lseek.c
+++ b/libgloss/v850/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _lseek (int file,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/libgloss/v850/open.c b/libgloss/v850/open.c
index 96616e5..b0ab850 100644
--- a/libgloss/v850/open.c
+++ b/libgloss/v850/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/libgloss/v850/pipe.c b/libgloss/v850/pipe.c
index 494a99e..737349f 100644
--- a/libgloss/v850/pipe.c
+++ b/libgloss/v850/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 pipe (int *fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/libgloss/v850/read.c b/libgloss/v850/read.c
index ec064cb..bc340ac 100644
--- a/libgloss/v850/read.c
+++ b/libgloss/v850/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ _read (int file,
        char *ptr,
        int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/libgloss/v850/sbrk.c b/libgloss/v850/sbrk.c
index 248a092..be62177 100644
--- a/libgloss/v850/sbrk.c
+++ b/libgloss/v850/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -25,5 +26,6 @@ _sbrk (int incr)
 
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/libgloss/v850/stat.c b/libgloss/v850/stat.c
index dc8351e..41513d4 100644
--- a/libgloss/v850/stat.c
+++ b/libgloss/v850/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/libgloss/v850/time.c b/libgloss/v850/time.c
index d0dc93f..06340f4 100644
--- a/libgloss/v850/time.c
+++ b/libgloss/v850/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/libgloss/v850/times.c b/libgloss/v850/times.c
index a558267..9962c3b 100644
--- a/libgloss/v850/times.c
+++ b/libgloss/v850/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 clock_t
 _times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/libgloss/v850/unlink.c b/libgloss/v850/unlink.c
index c6261d3..613417b 100644
--- a/libgloss/v850/unlink.c
+++ b/libgloss/v850/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/v850/utime.c b/libgloss/v850/utime.c
index ea1f789..df65333 100644
--- a/libgloss/v850/utime.c
+++ b/libgloss/v850/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/libgloss/v850/wait.c b/libgloss/v850/wait.c
index d8c96f0..9cdcdd1 100644
--- a/libgloss/v850/wait.c
+++ b/libgloss/v850/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/libgloss/v850/write.c b/libgloss/v850/write.c
index 136ac9e..ce9f2e9 100644
--- a/libgloss/v850/write.c
+++ b/libgloss/v850/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _write ( int file,
 	 char *ptr,
 	 int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/libgloss/visium/_exit.c b/libgloss/visium/_exit.c
index 307045d..f34c7ba 100644
--- a/libgloss/visium/_exit.c
+++ b/libgloss/visium/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _exit.c for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -38,4 +39,5 @@ _exit (int code)
      return, pretend to get stuck in a loop.  */
   while (1)
     ;
+    __A_VARIABLE = 1;
 }
diff --git a/libgloss/visium/gettod.c b/libgloss/visium/gettod.c
index 0ff7d1d..bff8276 100644
--- a/libgloss/visium/gettod.c
+++ b/libgloss/visium/gettod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stub functions for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -34,6 +35,7 @@
 int gettimeofday (struct timeval *__p, void *__tz)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -41,5 +43,6 @@ clock_t
 clock (void)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return (clock_t) -1;
 }
diff --git a/libgloss/visium/io-gdb.c b/libgloss/visium/io-gdb.c
index 4f16b2f..c4a8750 100644
--- a/libgloss/visium/io-gdb.c
+++ b/libgloss/visium/io-gdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * hosted io support for GDB's remote fileio protocol
  *
@@ -45,6 +46,7 @@ __hosted_to_gdb_mode_t (mode_t m)
     result |= GDB_S_IWOTH;
   if (m & S_IXOTH)
     result |= GDB_S_IXOTH;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -66,6 +68,7 @@ __hosted_to_gdb_open_flags (int f)
     result |= GDB_O_TRUNC;
   if (f & O_EXCL)
     result |= GDB_O_EXCL;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -97,6 +100,7 @@ __hosted_from_gdb_stat (const struct gdb_stat *gs,
   s->st_atime = gs->st_atime;
   s->st_mtime = gs->st_mtime;
   s->st_ctime = gs->st_ctime;
+  __A_VARIABLE = 1;
 }
 
 void
@@ -105,6 +109,7 @@ __hosted_from_gdb_timeval (const struct gdb_timeval *gt,
 {
   t->tv_sec = gt->tv_sec;
   t->tv_usec = gt->tv_usec;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -112,28 +117,49 @@ __hosted_from_gdb_errno (int32_t err)
 {
   switch (err)
     {
-    case 0: 		return 0;
-    case GDB_EPERM: 	return EPERM;
-    case GDB_ENOENT: 	return ENOENT;
-    case GDB_EINTR: 	return EINTR;
-    case GDB_EBADF: 	return EBADF;
-    case GDB_EACCES: 	return EACCES;
-    case GDB_EFAULT: 	return EFAULT;
-    case GDB_EBUSY: 	return EBUSY;
-    case GDB_EEXIST: 	return EEXIST;
-    case GDB_ENODEV: 	return ENODEV;
-    case GDB_ENOTDIR: 	return ENOTDIR;
-    case GDB_EISDIR: 	return EISDIR;
-    case GDB_EINVAL: 	return EINVAL;
-    case GDB_ENFILE: 	return ENFILE;
-    case GDB_EMFILE: 	return EMFILE;
-    case GDB_EFBIG: 	return EFBIG;
-    case GDB_ENOSPC: 	return ENOSPC;
-    case GDB_ESPIPE: 	return ESPIPE;
-    case GDB_EROFS: 	return EROFS;
-    case GDB_ENAMETOOLONG: 	return ENAMETOOLONG;
+    case 0: 		__A_VARIABLE = 1;
+      return 0;
+    case GDB_EPERM: 	__A_VARIABLE = 1;
+      return EPERM;
+    case GDB_ENOENT: 	__A_VARIABLE = 1;
+      return ENOENT;
+    case GDB_EINTR: 	__A_VARIABLE = 1;
+      return EINTR;
+    case GDB_EBADF: 	__A_VARIABLE = 1;
+      return EBADF;
+    case GDB_EACCES: 	__A_VARIABLE = 1;
+      return EACCES;
+    case GDB_EFAULT: 	__A_VARIABLE = 1;
+      return EFAULT;
+    case GDB_EBUSY: 	__A_VARIABLE = 1;
+      return EBUSY;
+    case GDB_EEXIST: 	__A_VARIABLE = 1;
+      return EEXIST;
+    case GDB_ENODEV: 	__A_VARIABLE = 1;
+      return ENODEV;
+    case GDB_ENOTDIR: 	__A_VARIABLE = 1;
+      return ENOTDIR;
+    case GDB_EISDIR: 	__A_VARIABLE = 1;
+      return EISDIR;
+    case GDB_EINVAL: 	__A_VARIABLE = 1;
+      return EINVAL;
+    case GDB_ENFILE: 	__A_VARIABLE = 1;
+      return ENFILE;
+    case GDB_EMFILE: 	__A_VARIABLE = 1;
+      return EMFILE;
+    case GDB_EFBIG: 	__A_VARIABLE = 1;
+      return EFBIG;
+    case GDB_ENOSPC: 	__A_VARIABLE = 1;
+      return ENOSPC;
+    case GDB_ESPIPE: 	__A_VARIABLE = 1;
+      return ESPIPE;
+    case GDB_EROFS: 	__A_VARIABLE = 1;
+      return EROFS;
+    case GDB_ENAMETOOLONG: 	__A_VARIABLE = 1;
+      return ENAMETOOLONG;
     case GDB_EUNKNOWN:
     default:
+      __A_VARIABLE = 1;
       return EIO;
     }
 }
diff --git a/libgloss/visium/io-stubs.c b/libgloss/visium/io-stubs.c
index 6baac09..4a561d2 100644
--- a/libgloss/visium/io-stubs.c
+++ b/libgloss/visium/io-stubs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* I/O stub functions for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -42,6 +43,7 @@ int
 chdir (const char *path)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -49,6 +51,7 @@ int
 chmod (const char *path, mode_t mode)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -56,6 +59,7 @@ int
 closedir (struct DIR *dirp)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -63,6 +67,7 @@ int
 execv (const char *path, char *const argv[])
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -70,6 +75,7 @@ int
 fcntl (int fd, int cmd, ...)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -77,6 +83,7 @@ int
 fork (void)
 {
   errno = EAGAIN;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -84,6 +91,7 @@ char *
 getcwd (char *buf, size_t size)
 {
   buf[0] = 0;
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -91,6 +99,7 @@ pid_t
 getppid (void)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -98,6 +107,7 @@ int
 link (const char *old, const char *new)
 {
   errno = EMLINK;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -107,6 +117,7 @@ nanosleep (const struct timespec *requested_time,
 {
   remaining->tv_sec = 0;
   remaining->tv_nsec = 0;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -114,6 +125,7 @@ struct DIR *
 opendir (const char *dirname)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -121,6 +133,7 @@ struct dirent *
 readdir (struct DIR *dirp)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -128,6 +141,7 @@ ssize_t
 readlink (const char *__path, char *__buf, size_t __buflen)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -135,6 +149,7 @@ int
 rmdir (const char *path)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -142,6 +157,7 @@ int
 symlink (const char *name1, const char *name2)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -149,12 +165,14 @@ clock_t
 times (struct tms *buf)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
 char *
 ttyname (int fildes)
 {
+  __A_VARIABLE = 1;
   return "";
 }
 
@@ -162,6 +180,7 @@ int
 utime (const char *path, const struct utimbuf *times)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -169,6 +188,7 @@ int
 wait (int *status)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -176,5 +196,6 @@ pid_t
 waitpid (pid_t pid, int *stat_loc, int options)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/visium/sbrk.c b/libgloss/visium/sbrk.c
index 61b1b8d..b71f568 100644
--- a/libgloss/visium/sbrk.c
+++ b/libgloss/visium/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk.c for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -48,9 +49,11 @@ sbrk (ptrdiff_t nbytes)
       heap_ptr += nbytes;
       memset (base, 0, nbytes);
 
+      __A_VARIABLE = 1;
       return base;
     }
 
   errno = ENOMEM;
+  __A_VARIABLE = 1;
   return (void *)-1;
 }
diff --git a/libgloss/visium/serial-inbyte.c b/libgloss/visium/serial-inbyte.c
index 579c969..69ad9b1 100644
--- a/libgloss/visium/serial-inbyte.c
+++ b/libgloss/visium/serial-inbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Serial Input for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -43,5 +44,6 @@ inbyte (void)
     bytes_in_fifo = *rxqs;
 
   /* Read one character.  */
+  __A_VARIABLE = 1;
   return (*rxdata) & 0xff;
 }
diff --git a/libgloss/visium/serial-outbyte.c b/libgloss/visium/serial-outbyte.c
index f1005f6..fccb889 100644
--- a/libgloss/visium/serial-outbyte.c
+++ b/libgloss/visium/serial-outbyte.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Serial Output for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -36,4 +37,5 @@ outbyte (char byte)
   volatile int *const txadata = (int *) 0x20001a1c;
 #endif
   *txadata = byte;
+  __A_VARIABLE = 1;
 }
diff --git a/libgloss/visium/syscalls.c b/libgloss/visium/syscalls.c
index de0ec16..3f5b0b1 100644
--- a/libgloss/visium/syscalls.c
+++ b/libgloss/visium/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* system calls for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -62,6 +63,7 @@ do_syscall (unsigned action, unsigned p1, unsigned p2,
   fileio->action = action;
 
   *error = (int) fileio->error;
+  __A_VARIABLE = 1;
   return (int) fileio->retval;
 }
 #else
@@ -92,6 +94,7 @@ do_syscall (unsigned action, unsigned p1, unsigned p2,
 	: "r1", "r2", "r3", "r4", "r5");
 
   *error = err;
+  __A_VARIABLE = 1;
   return ret;
 }
 #endif
@@ -107,6 +110,7 @@ close (int fildes)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -126,6 +130,7 @@ _exit (int code)
      return, pretend to get stuck in a loop. */
   while (1)
     ;
+    __A_VARIABLE = 1;
 }
 
 #ifdef TARGET_SIM
@@ -134,6 +139,7 @@ extern long long _sim_cmdline_header;
 long long
 _get_cmdline (void)
 {
+  __A_VARIABLE = 1;
   return _sim_cmdline_header;
 }
 #endif
@@ -152,6 +158,7 @@ fstat (int fildes, struct stat *st)
   else
     __hosted_from_gdb_stat (&gst, st);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -179,6 +186,7 @@ gettimeofday (struct timeval *__p, void *__tz)
   else
     __hosted_from_gdb_timeval (&gtv, tv);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -193,6 +201,7 @@ isatty (int fildes)
   if (status == 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -208,6 +217,7 @@ lseek (int fildes, off_t offset, int whence)
   if (ret == (off_t)-1)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -234,6 +244,7 @@ open (const char *path, int oflag, ...)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -248,6 +259,7 @@ read (int fildes, void *buf, size_t nbyte)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -265,6 +277,7 @@ rename (const char *old, const char *new)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -284,6 +297,7 @@ stat (const char *path, struct stat *st)
   else
     __hosted_from_gdb_stat (&gst, st);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -296,6 +310,7 @@ system (const char *string)
 
   status = do_syscall (SYS_system, (unsigned) string, len, 0, 0, &error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -311,6 +326,7 @@ unlink (const char *path)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -325,6 +341,7 @@ write (int fildes, const void *buf, size_t nbyte)
   if (status < 0)
     errno = __hosted_from_gdb_errno (error);
 
+  __A_VARIABLE = 1;
   return status;
 }
 
diff --git a/libgloss/write.c b/libgloss/write.c
index 292a68e..2e5db86 100644
--- a/libgloss/write.c
+++ b/libgloss/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write.c -- write bytes to an output device.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -35,5 +36,6 @@ _DEFUN (write, (fd, buf, nbytes),
     }
     outbyte (*(buf + i));
   }
+  __A_VARIABLE = 1;
   return (nbytes);
 }
diff --git a/libgloss/xc16x/create.c b/libgloss/xc16x/create.c
index 33f4e0b..a501bc5 100644
--- a/libgloss/xc16x/create.c
+++ b/libgloss/xc16x/create.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -35,5 +36,6 @@ volatile int _creat(char *name,int perms)
   temp=creatsys(name,perms);    
 // putchar((char)temp);
 //printf("%d\n",temp);					
+__A_VARIABLE = 1;
 return temp;  
 }
diff --git a/libgloss/xc16x/getchar1.c b/libgloss/xc16x/getchar1.c
index 4ba5959..cd39af1 100644
--- a/libgloss/xc16x/getchar1.c
+++ b/libgloss/xc16x/getchar1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -15,5 +16,6 @@ signed char getchar (void)
                                                                                
   asm(" trap #2");
                                                                                 
+  __A_VARIABLE = 1;
 }
 
diff --git a/libgloss/xc16x/isatty.c b/libgloss/xc16x/isatty.c
index 30e6a53..4fb19e3 100644
--- a/libgloss/xc16x/isatty.c
+++ b/libgloss/xc16x/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -22,5 +23,6 @@ isatty (int fd)
 
 
 
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/xc16x/lseek.c b/libgloss/xc16x/lseek.c
index ff3057d..e2df52a 100644
--- a/libgloss/xc16x/lseek.c
+++ b/libgloss/xc16x/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -17,5 +18,6 @@
 int
 _lseek (int file, int ptr, int dir)
 {
+  __A_VARIABLE = 1;
   return trap_lseek (file,(unsigned long)ptr, dir);
 }
diff --git a/libgloss/xc16x/mem-layout.c b/libgloss/xc16x/mem-layout.c
index 4619ed2..277755d 100644
--- a/libgloss/xc16x/mem-layout.c
+++ b/libgloss/xc16x/mem-layout.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
diff --git a/libgloss/xc16x/misc.c b/libgloss/xc16x/misc.c
index 786db36..36cc260 100644
--- a/libgloss/xc16x/misc.c
+++ b/libgloss/xc16x/misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -21,12 +22,14 @@ int _DEFUN(_raise,(sig),
 	   int sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int _DEFUN(_getpid,(),)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -35,5 +38,6 @@ int _DEFUN(_kill,(pid, sig),
 	   int sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/libgloss/xc16x/open.c b/libgloss/xc16x/open.c
index 4dd0d07..0adc4c9 100644
--- a/libgloss/xc16x/open.c
+++ b/libgloss/xc16x/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -34,5 +35,6 @@ int _open(char *name,int flags,int perms)
  int temp;
 
   temp=opensys(name,flags,perms);    
+__A_VARIABLE = 1;
 return temp;  
 }
diff --git a/libgloss/xc16x/read.c b/libgloss/xc16x/read.c
index b117af9..897861b 100644
--- a/libgloss/xc16x/read.c
+++ b/libgloss/xc16x/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -22,6 +23,7 @@
 int _read(int file, char *ptr,int len)
 {
  	
+ __A_VARIABLE = 1;
  return trap1(file,(unsigned long)ptr,1);
  
 }
diff --git a/libgloss/xc16x/sbrk.c b/libgloss/xc16x/sbrk.c
index deb2df2..270cbe9 100644
--- a/libgloss/xc16x/sbrk.c
+++ b/libgloss/xc16x/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -31,6 +32,7 @@ caddr_t
 
 
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t)prev_heap_end;
 }
 
diff --git a/libgloss/xc16x/syscalls.c b/libgloss/xc16x/syscalls.c
index 03b6368..5ec9ef0 100644
--- a/libgloss/xc16x/syscalls.c
+++ b/libgloss/xc16x/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -24,10 +25,12 @@
 void _exit(int n)
 {
 asm volatile("trap #0");
+__A_VARIABLE = 1;
 }
 
 int isatty(file)
      int file;
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/libgloss/xc16x/trap_handle.c b/libgloss/xc16x/trap_handle.c
index 899cdc2..aa2fb33 100644
--- a/libgloss/xc16x/trap_handle.c
+++ b/libgloss/xc16x/trap_handle.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -13,6 +14,7 @@
 int trap0(int file, unsigned long ptr,int len)
 {
 asm volatile("TRAP #3");
+__A_VARIABLE = 1;
 return len;
 }
 
@@ -21,12 +23,14 @@ int trap1(int file, unsigned long ptr,int len)
 {
  asm volatile("TRAP #4");
                                                                                 
+ __A_VARIABLE = 1;
 }
                                                                                 
 int trap_lseek(int file, unsigned long ptr,int len)
 {
  asm volatile("TRAP #8");
                                                                                 
+ __A_VARIABLE = 1;
 }
                                                                                 
 
@@ -46,6 +50,7 @@ asm volatile("trap #5");
 #ifndef __xc16xL__
 asm volatile("pop r11");
 #endif
+__A_VARIABLE = 1;
 }
                                                                                 
 volatile int creatsys(char *name,int perms)
@@ -62,6 +67,7 @@ asm volatile("trap #7");
 #ifndef __xc16xL__
 asm volatile("pop r10");
 #endif
+__A_VARIABLE = 1;
 }
                                                                                 
 
diff --git a/libgloss/xc16x/write.c b/libgloss/xc16x/write.c
index 10b1b55..ef6263f 100644
--- a/libgloss/xc16x/write.c
+++ b/libgloss/xc16x/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -21,5 +22,6 @@ return len;
 */
 int _write(int file, char *ptr,int len)
 {
+ __A_VARIABLE = 1;
  return trap0(file,(unsigned long)ptr,len);
 }
diff --git a/libgloss/xstormy16/close.c b/libgloss/xstormy16/close.c
index 5fcfbf5..580a5b7 100644
--- a/libgloss/xstormy16/close.c
+++ b/libgloss/xstormy16/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close.c -- close a file descriptor.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (_close ,(fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/xstormy16/eva_app.c b/libgloss/xstormy16/eva_app.c
index f6069fc..7516cdf 100644
--- a/libgloss/xstormy16/eva_app.c
+++ b/libgloss/xstormy16/eva_app.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* eva_app.c -- Glue code for linking apps to run under GDB debugger control.
  *
  * Copyright (c) 2001 Red Hat, Inc.
@@ -29,6 +30,7 @@ void
 print(char *ptr)
 {
   STUB_WRITE(ptr, strlen(ptr));
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -40,12 +42,14 @@ int
 _write (int fd, char *buf, int nbytes)
 {
   STUB_WRITE(buf, nbytes);
+  __A_VARIABLE = 1;
   return (nbytes);
 }
 
 int
 _read (int fd, char *buf, int nbytes)
 {
+  __A_VARIABLE = 1;
   return STUB_READ(buf, nbytes);
 }
 
@@ -58,12 +62,15 @@ _sbrk(int inc)
   static char *heap_ptr = _end;
   void *base;
 
-  if (inc > (HEAP_LIMIT - heap_ptr))
+  if (inc > (HEAP_LIMIT - heap_ptr)) {
+    __A_VARIABLE = 1;
     return (void *)-1;
+  }
 
   base = heap_ptr;
   heap_ptr += inc;
 
+  __A_VARIABLE = 1;
   return base;
 }
 
@@ -75,4 +82,5 @@ _exit(int n)
      asm volatile ("nop");
      asm volatile (".hword 0x0006");  /* breakpoint (special illegal insn) */
    }
+   __A_VARIABLE = 1;
 }
diff --git a/libgloss/xstormy16/fstat.c b/libgloss/xstormy16/fstat.c
index 982d578..583d5cd 100644
--- a/libgloss/xstormy16/fstat.c
+++ b/libgloss/xstormy16/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat.c -- get status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,5 +27,6 @@ _DEFUN (_fstat, (fd, buf),
   buf->st_mode = S_IFCHR;	/* Always pretend to be a tty */
   buf->st_blksize = 0;
 
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/libgloss/xstormy16/getpid.c b/libgloss/xstormy16/getpid.c
index 0f081a1..a4caddc 100644
--- a/libgloss/xstormy16/getpid.c
+++ b/libgloss/xstormy16/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid.c -- get the current process id.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -21,5 +22,6 @@ int
 _DEFUN (_getpid, (),
         )
 {
+  __A_VARIABLE = 1;
   return __MYPID;
 }
diff --git a/libgloss/xstormy16/isatty.c b/libgloss/xstormy16/isatty.c
index e3c3205..ae83f75 100644
--- a/libgloss/xstormy16/isatty.c
+++ b/libgloss/xstormy16/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c -- chek the terminal device.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -23,5 +24,6 @@ int
 _DEFUN (_isatty, (fd),
        int fd)
 {
+  __A_VARIABLE = 1;
   return (1);
 }
diff --git a/libgloss/xstormy16/kill.c b/libgloss/xstormy16/kill.c
index 0bbc014..ede91f3 100644
--- a/libgloss/xstormy16/kill.c
+++ b/libgloss/xstormy16/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill.c -- remove a process.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (_kill, (pid, sig),
 {
   if(pid == __MYPID)
     _exit(sig);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/libgloss/xstormy16/lseek.c b/libgloss/xstormy16/lseek.c
index 640a96e..6c7b1b4 100644
--- a/libgloss/xstormy16/lseek.c
+++ b/libgloss/xstormy16/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek.c -- move read/write pointer.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -26,6 +27,7 @@ _DEFUN (_lseek, (fd,  offset, whence),
        int whence)
 {
   errno = ESPIPE;
+  __A_VARIABLE = 1;
   return ((off_t)-1);
 }
 
diff --git a/libgloss/xstormy16/open.c b/libgloss/xstormy16/open.c
index a2c318e..7b4e12e 100644
--- a/libgloss/xstormy16/open.c
+++ b/libgloss/xstormy16/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open.c -- open a file.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -26,6 +27,7 @@ _DEFUN (_open, (buf, flags, mode),
        int mode)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/xstormy16/stat.c b/libgloss/xstormy16/stat.c
index c766a34..8069b5a 100644
--- a/libgloss/xstormy16/stat.c
+++ b/libgloss/xstormy16/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat.c -- Get the status of a file.
  *
  * Copyright (c) 1995 Cygnus Support
@@ -25,6 +26,7 @@ _DEFUN (_stat, (path, buf),
        struct stat *buf)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
 
diff --git a/libgloss/xstormy16/unlink.c b/libgloss/xstormy16/unlink.c
index 1c56663..da36bcc 100644
--- a/libgloss/xstormy16/unlink.c
+++ b/libgloss/xstormy16/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink.c -- remove a file.
  * 
  * Copyright (c) 1995 Cygnus Support
@@ -24,5 +25,6 @@ _DEFUN (_unlink, (path),
         char * path)
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return (-1);
 }
diff --git a/libgloss/xstormy16/xstormy16_stub.c b/libgloss/xstormy16/xstormy16_stub.c
index 7706031..732ac05 100644
--- a/libgloss/xstormy16/xstormy16_stub.c
+++ b/libgloss/xstormy16/xstormy16_stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************************
 
 		THIS SOFTWARE IS NOT COPYRIGHTED
@@ -158,6 +159,7 @@ get_char(unsigned long addr)
   asm("movf.b %0,(%2)\n" 
       : "=e"(ret) : "d"(msw), "r"(lsw) : "memory");
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -171,6 +173,7 @@ set_char(unsigned long addr, unsigned int val)
 
   asm("movf.b (%1),%2\n" 
       : /* none */ : "d"(msw), "r"(lsw), "e"(val) : "memory" );
+  __A_VARIABLE = 1;
 }
 
 static inline unsigned int
@@ -184,6 +187,7 @@ get_word(unsigned long addr)
   asm("movf.w %0,(%2)\n" 
       : "=e"(ret) : "d"(msw), "r"(lsw) : "memory" );
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -197,6 +201,7 @@ set_word(unsigned long addr, unsigned int val)
 
   asm("movf.w (%1),%2\n" 
       : /* none */ : "d"(msw), "r"(lsw), "e"(val) : "memory" );
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -206,6 +211,7 @@ assign_regs (struct regs *dest, const struct regs *src)
   char *d = (char *)dest, *s = (char *)src;
   for (i = 0; i < sizeof (struct regs); i++)
     *d++ = *s++;
+  __A_VARIABLE = 1;
 }
 
 /* Write out a register for a 'T' packet.  */
@@ -228,6 +234,7 @@ putreg (unsigned char *buf, int regnum, void *mem_p, int count)
       *buf++ = hexchars[ch % 16];
     }
   *buf++ = ';';
+  __A_VARIABLE = 1;
   return(buf);
 }
 
@@ -407,9 +414,19 @@ handle_exception(void)
 static int 
 hex (int ch)
 {
-  if ((ch >= '0') && (ch <= '9')) return (ch-'0');
-  if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
-  if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
+  if ((ch >= '0') && (ch <= '9')) {
+    __A_VARIABLE = 1;
+    return (ch-'0');
+  }
+  if ((ch >= 'a') && (ch <= 'f')) {
+    __A_VARIABLE = 1;
+    return (ch-'a'+10);
+  }
+  if ((ch >= 'A') && (ch <= 'F')) {
+    __A_VARIABLE = 1;
+    return (ch-'A'+10);
+  }
+  __A_VARIABLE = 1;
   return (-1);
 }
 
@@ -488,6 +505,7 @@ putPacket (unsigned char *buffer_p)
     putDebugChar(hexchars[(checksum >> 4) % 16]);
     putDebugChar(hexchars[checksum % 16]);
   } while (getDebugChar() != '+');
+  __A_VARIABLE = 1;
 }
 
 /* Convert the memory pointed to by mem into hex, and return it as a packet. */
@@ -524,6 +542,7 @@ putHex (char c, unsigned long mem_arg, int count)
     putDebugChar(hexchars[(checksum >> 4) % 16]);
     putDebugChar(hexchars[checksum % 16]);
   } while (getDebugChar() != '+');
+  __A_VARIABLE = 1;
 }
 
 /* Function: gdb_write(char *, int)
@@ -535,6 +554,7 @@ gdb_write (char *data, int len)
   ERR_DETECT_REG &= ~SER0_IRQ_ENA;
   putHex ('O', (unsigned long)(unsigned int)data, len);
   ERR_DETECT_REG |= SER0_IRQ_ENA;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -553,6 +573,7 @@ gdb_read (char *buf, int nbytes)
         }
     }
   ERR_DETECT_REG |= SER0_IRQ_ENA;
+  __A_VARIABLE = 1;
   return (i);
 }
 
@@ -561,15 +582,22 @@ valid_addr_range (unsigned long mem, int count)
 {
   unsigned long last = mem + count - 1;
 
-  if (last < 0x800L)
+  if (last < 0x800L) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
-  if (mem < 0x7f00L)
+  if (mem < 0x7f00L) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
-  if (last > 0x7ffffL)
+  if (last > 0x7ffffL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -588,6 +616,7 @@ hex2mem (unsigned char *buf, unsigned long mem, int count)
       ch = ch + hex(*buf++);
       set_char (mem++, ch);
     }
+    __A_VARIABLE = 1;
 }
 
 /**********************************************/
@@ -613,6 +642,7 @@ hexToInt (unsigned char **ptr, long *intValue)
 	break;
       (*ptr)++;
     }
+  __A_VARIABLE = 1;
   return (numChars);
 }
 
@@ -623,34 +653,53 @@ hexToInt (unsigned char **ptr, long *intValue)
 static int
 opcode_size(unsigned int opcode)
 {
-  if ((opcode & 0xff00) == 0)
+  if ((opcode & 0xff00) == 0) {
+    __A_VARIABLE = 1;
     return 2;
+  }
 
-  if ((opcode & 0xf800) == 0)
+  if ((opcode & 0xf800) == 0) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xf800) == 0x7800)
+  if ((opcode & 0xf800) == 0x7800) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xf000) == 0xc000)
+  if ((opcode & 0xf000) == 0xc000) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xf100) == 0x2000)
+  if ((opcode & 0xf100) == 0x2000) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xfff0) == 0x30e0)
+  if ((opcode & 0xfff0) == 0x30e0) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xf008) == 0x6008)
+  if ((opcode & 0xf008) == 0x6008) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if ((opcode & 0xf808) == 0x7008)
+  if ((opcode & 0xf808) == 0x7008) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
   opcode >>= 8;
-  if (opcode == 0x0c || opcode == 0x0d || opcode == 0x31)
+  if (opcode == 0x0c || opcode == 0x0d || opcode == 0x31) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
+  __A_VARIABLE = 1;
   return 2;
 }
 
@@ -769,6 +818,7 @@ prepare_to_step(void)
       stepinfo.opcode2 = get_word(next_pc2);
       set_word(next_pc2, BREAKPOINT_OPCODE);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Function: finish_from_step
@@ -789,6 +839,7 @@ finish_from_step (void)
           stepinfo.addr2 = 0;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -819,6 +870,7 @@ putDebugChar(unsigned ch)
   while ((UART_CR(DBG_UART) & UART_CR_TXEMPTY) == 0) ;
 
   UART_TXD(DBG_UART) = ch;
+  __A_VARIABLE = 1;
 }
 
 static unsigned char
@@ -826,6 +878,7 @@ getDebugChar(void)
 {
   while ((UART_CR(DBG_UART) & UART_CR_RXRDY) == 0) ;
 
+  __A_VARIABLE = 1;
   return UART_RXD(DBG_UART);
 }
 
@@ -833,5 +886,6 @@ void
 uart_init(void)
 {
   UART_CR(DBG_UART) |= (UART_CR_RUN | UART_CR_RXIEN);
+  __A_VARIABLE = 1;
 }
 
diff --git a/newlib/doc/makedoc.c b/newlib/doc/makedoc.c
index 96362f7..2c8abf7 100644
--- a/newlib/doc/makedoc.c
+++ b/newlib/doc/makedoc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* chew
    Copyright (C) 1990-1992 Free Software Foundation, Inc.
    Contributed by steve chamberlain @cygnus
@@ -74,6 +75,7 @@ static void DEFUN(init_string_with_size,(buffer, size),
   buffer->write_idx = 0;
   buffer->size = size;
   buffer->ptr = malloc(size);
+  __A_VARIABLE = 1;
 }
 
 static void DEFUN(init_string,(buffer),
@@ -81,6 +83,7 @@ static void DEFUN(init_string,(buffer),
 {
     init_string_with_size(buffer, DEF_SIZE);
 
+    __A_VARIABLE = 1;
 }
 
 static int DEFUN(find, (str, what),
@@ -97,6 +100,7 @@ static int DEFUN(find, (str, what),
 	else
 	 p = what;
     }
+    __A_VARIABLE = 1;
     return (*p == 0);
     
 }
@@ -105,6 +109,7 @@ static void DEFUN(write_buffer,(buffer),
 	   string_type *buffer)
 {
     fwrite(buffer->ptr, buffer->write_idx, 1, stdout);
+    __A_VARIABLE = 1;
 }
 
 
@@ -112,6 +117,7 @@ static void DEFUN(delete_string,(buffer),
 	   string_type *buffer)
 {
     free(buffer->ptr);
+    __A_VARIABLE = 1;
 }
 
 
@@ -119,6 +125,7 @@ static char *DEFUN(addr, (buffer, idx),
 	    string_type *buffer AND
 	    unsigned int idx)
 {
+    __A_VARIABLE = 1;
     return buffer->ptr + idx;
 }
 
@@ -128,8 +135,10 @@ static char DEFUN(at,(buffer, pos),
 {
     if ( pos >= buffer->write_idx) 
     {
+	__A_VARIABLE = 1;
 	return 0;
     }
+    __A_VARIABLE = 1;
     return buffer->ptr[pos];
 }
 
@@ -144,6 +153,7 @@ static void DEFUN(catchar,(buffer, ch),
   }
 
   buffer->ptr[buffer->write_idx ++ ] = ch;
+  __A_VARIABLE = 1;
 }
 
 
@@ -155,6 +165,7 @@ static void DEFUN(overwrite_string,(dst,   src),
     dst->size = src->size;
     dst->write_idx = src->write_idx;
     dst->ptr = src->ptr;
+    __A_VARIABLE = 1;
 }
 
 static void DEFUN(catstr,(dst, src),
@@ -166,6 +177,7 @@ static void DEFUN(catstr,(dst, src),
     {
 	catchar(dst, src->ptr[i]);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -179,6 +191,7 @@ static void DEFUN(cattext,(buffer, string),
 	catchar(buffer, *string);
 	string++;
     }
+    __A_VARIABLE = 1;
 }
 
 static void DEFUN(catbuf,(buffer, buf, len),
@@ -192,6 +205,7 @@ static void DEFUN(catbuf,(buffer, buf, len),
 	catchar(buffer, *buf);
 	buf++;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -204,6 +218,7 @@ DEFUN(skip_white_and_stars,(src, idx),
     while (isspace(at(src,idx)) 
 	   || (at(src,idx) == '*' && at(src,idx +1) !='/')) 
      idx++;
+    __A_VARIABLE = 1;
     return idx;
     
 
@@ -249,6 +264,7 @@ static void DEFUN(exec,(word),
 	(*pc)();
     }
     
+    __A_VARIABLE = 1;
 }
 WORD(call)
 {
@@ -258,6 +274,7 @@ stinst_type *oldpc = pc;
     exec(e);
     pc = oldpc + 2;
     
+    __A_VARIABLE = 1;
 }
 
 WORD(remchar)
@@ -265,6 +282,7 @@ WORD(remchar)
     tos->write_idx--;    
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 WORD(push_number)
@@ -274,6 +292,7 @@ WORD(push_number)
     *isp = (uintptr_t)(*pc);
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 
@@ -288,6 +307,7 @@ WORD(push_text)
     cattext(tos,*((char **)pc));
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 
@@ -348,6 +368,7 @@ DEFUN(remove_noncomments,(src,dst),
 	}
 	else idx++;
     }
+    __A_VARIABLE = 1;
 }
 /* turn foobar name(stuff); into foobar EXFUN(name,(stuff));
 
@@ -405,6 +426,7 @@ DEFUN_VOID(exfunstuff)
     overwrite_string(tos, &out);    
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 
@@ -442,6 +464,7 @@ WORD(translatecomments)
     
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 /* find something like
@@ -488,6 +511,7 @@ WORD(quickref)
   tos-=2;
   pc++;
   
+  __A_VARIABLE = 1;
 }
 
 #if 0
@@ -569,6 +593,7 @@ DEFUN_VOID(outputdots)
     overwrite_string(tos, &out);
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 /* Find lines starting with . and | and put example around them on tos
@@ -642,6 +667,7 @@ WORD(courierize)
     pc++;
 
     
+    __A_VARIABLE = 1;
 }
 
 /* 
@@ -713,6 +739,7 @@ WORD(bulletize)
   *tos = out;
   pc++;
     
+  __A_VARIABLE = 1;
 }
 
 /* Turn <<foo>> into @code{foo} in place at TOS 
@@ -769,6 +796,7 @@ WORD(do_fancy_stuff)
     *tos = out;
     pc++;
     
+    __A_VARIABLE = 1;
 }
 /* A command is all upper case,and alone on a line */
 static int 
@@ -793,10 +821,15 @@ DEFUN( iscommand,(ptr, idx),
 		/* The length check will never fail on a real command
 		 * because the commands are screened as the definitions file
 		 * is read.  */
-		if (len >= MIN_CMDLEN) return 1;
+		if (len >= MIN_CMDLEN) {
+			__A_VARIABLE = 1;
+			return 1;
+		}
+		__A_VARIABLE = 1;
 		return 0;
 	    }
 
+    __A_VARIABLE = 1;
     return 0;
 
 }
@@ -816,6 +849,7 @@ DEFUN(copy_past_newline,(ptr, idx, dst),
     }    
     catchar(dst, at(ptr, idx));
     idx++;
+    __A_VARIABLE = 1;
     return idx;
 
 }
@@ -826,6 +860,7 @@ WORD(icopy_past_newline)
     init_string(tos);
     idx = copy_past_newline(ptr, idx, tos);
     pc++;	
+    __A_VARIABLE = 1;
 }
 
 
@@ -910,6 +945,7 @@ WORD(kill_bogus_lines)
     *tos = out;
     
     
+    __A_VARIABLE = 1;
 }
 
 WORD(indent)
@@ -959,6 +995,7 @@ WORD(indent)
     delete_string(tos);
     *tos = out;
 
+    __A_VARIABLE = 1;
 }
 
 /* Change the TOS so that all that is left is the stuff inside the
@@ -990,6 +1027,7 @@ WORD(get_stuff_in_angle)
   
   overwrite_string(tos, &out);
   pc++;
+  __A_VARIABLE = 1;
 }
 
 
@@ -1003,6 +1041,7 @@ WORD(get_stuff_in_command)
     idx =   copy_past_newline(ptr, idx, tos);
   }
   pc++;    
+  __A_VARIABLE = 1;
 }
 
 WORD(swap)
@@ -1014,6 +1053,7 @@ WORD(swap)
     tos[-1] =t; 
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 WORD(dup_)
@@ -1023,6 +1063,7 @@ WORD(dup_)
     catstr(tos, tos-1);
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 
@@ -1034,6 +1075,7 @@ WORD(icatstr)
     tos--;
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 WORD(skip_past_newline)
@@ -1043,6 +1085,7 @@ WORD(skip_past_newline)
      idx++;
     idx++;
     pc++;
+    __A_VARIABLE = 1;
 }
 
 
@@ -1051,6 +1094,7 @@ WORD(internalmode)
     internal_mode = *(isp);
     isp--;
     pc++;
+    __A_VARIABLE = 1;
 }
 
 WORD(maybecatstr)
@@ -1063,6 +1107,7 @@ WORD(maybecatstr)
     tos--;
     pc++;
     
+    __A_VARIABLE = 1;
 }
 
 char *
@@ -1149,11 +1194,15 @@ DEFUN(lookup_word,(word),
 {
     dict_type *ptr = root;
     while (ptr) {
-	    if (strcmp(ptr->word, word) == 0) return ptr;
+	    if (strcmp(ptr->word, word) == 0) {
+	    	__A_VARIABLE = 1;
+	    	return ptr;
+	    }
 	    ptr = ptr->next;
 	    
 	 }
     fprintf(stderr,"Can't find %s\n",word);
+    __A_VARIABLE = 1;
     return 0;
     
     
@@ -1206,6 +1255,7 @@ DEFUN(newentry,(word),
     new->code = (stinst_type *)malloc(sizeof(stinst_type ));
     new->code_length = 1;
     new->code_end = 0;
+    __A_VARIABLE = 1;
     return new;
     
 }
@@ -1225,6 +1275,7 @@ DEFUN(add_to_definition,(entry, word),
     }
     entry->code[entry->code_end] = word;
     
+__A_VARIABLE = 1;
 return     entry->code_end++;  
 }
 
@@ -1242,6 +1293,7 @@ DEFUN(add_intrinsic,(name, func),
     dict_type *new = newentry(name);
     add_to_definition(new, func);
     add_to_definition(new, 0);
+    __A_VARIABLE = 1;
 }
 
 void
@@ -1253,6 +1305,7 @@ DEFUN(add_var,(name),
     add_to_definition(new, (stinst_type)(&(new->var)));
     add_to_definition(new,0);
     
+    __A_VARIABLE = 1;
 }
       
 
@@ -1336,6 +1389,7 @@ DEFUN(compile, (string),
 	}	    
     }
 
+__A_VARIABLE = 1;
 return(ret);
 }
 
@@ -1346,12 +1400,14 @@ static void DEFUN_VOID(bang)
 isp-=2;
 pc++;
 
+__A_VARIABLE = 1;
 }
 
 WORD(atsign)
 {
     isp[0] = *(uintptr_t *)(isp[0]);
     pc++;
+    __A_VARIABLE = 1;
 }
 
 WORD(hello)
@@ -1359,6 +1415,7 @@ WORD(hello)
     
     printf("hello\n");
     pc++;    
+    __A_VARIABLE = 1;
 }
 
 
@@ -1379,6 +1436,7 @@ static void DEFUN(read_in, (str, file),
     
     catbuf(str, buff,1);
     
+    __A_VARIABLE = 1;
 }
 
 
diff --git a/newlib/iconvdata/dummy.c b/newlib/iconvdata/dummy.c
index 9b13d4b..b496031 100644
--- a/newlib/iconvdata/dummy.c
+++ b/newlib/iconvdata/dummy.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* empty file to force proper Makefile creation */
diff --git a/newlib/iconvdata/euc-jp.c b/newlib/iconvdata/euc-jp.c
index 1a63899..ca9f703 100644
--- a/newlib/iconvdata/euc-jp.c
+++ b/newlib/iconvdata/euc-jp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Mapping tables for EUC-JP handling.
    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/iconvdata/jis0201.c b/newlib/iconvdata/jis0201.c
index a4a23cb..01c5b6b 100644
--- a/newlib/iconvdata/jis0201.c
+++ b/newlib/iconvdata/jis0201.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Mapping tables for JIS0201 handling.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/iconvdata/jis0208.c b/newlib/iconvdata/jis0208.c
index 1f16ad2..a5bc79e 100644
--- a/newlib/iconvdata/jis0208.c
+++ b/newlib/iconvdata/jis0208.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Mapping tables for JIS0208 handling.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/iconvdata/jis0212.c b/newlib/iconvdata/jis0212.c
index 8ad1c90..6307057 100644
--- a/newlib/iconvdata/jis0212.c
+++ b/newlib/iconvdata/jis0212.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Mapping tables for JIS0212 handling.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/iconvdata/sjis.c b/newlib/iconvdata/sjis.c
index 3a19642..dc13106 100644
--- a/newlib/iconvdata/sjis.c
+++ b/newlib/iconvdata/sjis.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Mapping tables for SJIS handling.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/argz/argz_add.c b/newlib/libc/argz/argz_add.c
index 1c3b170..dda0f26 100644
--- a/newlib/libc/argz/argz_add.c
+++ b/newlib/libc/argz/argz_add.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -19,15 +20,20 @@ _DEFUN (argz_add, (argz, argz_len, str),
   int len_to_add = 0;
   size_t last = *argz_len;
 
-  if (str == NULL)
+  if (str == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   len_to_add = strlen(str) + 1;
   *argz_len += len_to_add;
 
-  if(!(*argz = (char *)realloc(*argz, *argz_len)))
+  if(!(*argz = (char *)realloc(*argz, *argz_len))) {
+    __A_VARIABLE = 1;
     return ENOMEM;
+  }
 
   memcpy(*argz + last, str, len_to_add);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_add_sep.c b/newlib/libc/argz/argz_add_sep.c
index 7dfbb4d..bbfaf15 100644
--- a/newlib/libc/argz/argz_add_sep.c
+++ b/newlib/libc/argz/argz_add_sep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -27,10 +28,13 @@ _DEFUN (argz_add_sep, (argz, argz_len, str, sep),
     {
       *argz_len += str_argz_len;
 
-      if(!(*argz = (char *)realloc(*argz, *argz_len)))
+      if(!(*argz = (char *)realloc(*argz, *argz_len))) {
+	__A_VARIABLE = 1;
 	return ENOMEM;
+      }
 
       memcpy(*argz + last, str_argz, str_argz_len);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_append.c b/newlib/libc/argz/argz_append.c
index c6c3dbe..28a612c 100644
--- a/newlib/libc/argz/argz_append.c
+++ b/newlib/libc/argz/argz_append.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -23,10 +24,13 @@ _DEFUN (argz_append, (argz, argz_len, buf, buf_len),
 
       *argz_len += buf_len;
 
-      if(!(*argz = (char *)realloc(*argz, *argz_len)))
+      if(!(*argz = (char *)realloc(*argz, *argz_len))) {
+	__A_VARIABLE = 1;
 	return ENOMEM;
+      }
 
       memcpy(*argz + last, buf, buf_len);
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_count.c b/newlib/libc/argz/argz_count.c
index 4761275..b7d975e 100644
--- a/newlib/libc/argz/argz_count.c
+++ b/newlib/libc/argz/argz_count.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -22,5 +23,6 @@ _DEFUN (argz_count, (argz, argz_len),
       if (argz[i] == '\0')
         count++;
     }
+  __A_VARIABLE = 1;
   return count;
 }
diff --git a/newlib/libc/argz/argz_create.c b/newlib/libc/argz/argz_create.c
index 9d7b2f1..4744d20 100644
--- a/newlib/libc/argz/argz_create.c
+++ b/newlib/libc/argz/argz_create.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -26,6 +27,7 @@ _DEFUN (argz_create, (argv, argz, argz_len),
   if (*argv == NULL)
     {
       *argz = NULL;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -36,8 +38,10 @@ _DEFUN (argz_create, (argv, argz, argz_len),
     }
 
   /* There are argc strings to copy into argz. */
-  if(!(*argz = (char *)malloc(*argz_len)))
+  if(!(*argz = (char *)malloc(*argz_len))) {
+    __A_VARIABLE = 1;
     return ENOMEM;
+  }
 
   iter = *argz;
   for(i = 0; i < argc; i++)
@@ -46,5 +50,6 @@ _DEFUN (argz_create, (argv, argz, argz_len),
       memcpy(iter, argv[i], len);
       iter += len;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_create_sep.c b/newlib/libc/argz/argz_create_sep.c
index 38866e1..ae23494 100644
--- a/newlib/libc/argz/argz_create_sep.c
+++ b/newlib/libc/argz/argz_create_sep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -31,6 +32,7 @@ _DEFUN (argz_create_sep, (string, sep, argz, argz_len),
   if (!string || string[0] == '\0')
     {
       *argz= NULL;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -47,8 +49,10 @@ _DEFUN (argz_create_sep, (string, sep, argz, argz_len),
       num_strings++;
     }
 
-  if(!(*argz = (char *)malloc(*argz_len)))
+  if(!(*argz = (char *)malloc(*argz_len))) {
+    __A_VARIABLE = 1;
     return ENOMEM;
+  }
 
   free(old_running);
 
@@ -65,5 +69,6 @@ _DEFUN (argz_create_sep, (string, sep, argz, argz_len),
     }
 
   free(old_running);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_delete.c b/newlib/libc/argz/argz_delete.c
index aa94f6d..9433225 100644
--- a/newlib/libc/argz/argz_delete.c
+++ b/newlib/libc/argz/argz_delete.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -28,8 +29,10 @@ _DEFUN (argz_delete, (argz, argz_len, entry),
 
       *argz_len -= len;
 
-      if(!(*argz = (char *)realloc(*argz, *argz_len)))
+      if(!(*argz = (char *)realloc(*argz, *argz_len))) {
+        __A_VARIABLE = 1;
         return ENOMEM;
+      }
 
       if (*argz_len <= 0)
         {
@@ -37,5 +40,6 @@ _DEFUN (argz_delete, (argz, argz_len, entry),
           *argz = NULL;
         }
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_extract.c b/newlib/libc/argz/argz_extract.c
index a819f39..69364f4 100644
--- a/newlib/libc/argz/argz_extract.c
+++ b/newlib/libc/argz/argz_extract.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -29,4 +30,5 @@ _DEFUN (argz_extract, (argz, argz_len, argv),
       }
   argv[0] = &argz[0];
   argv[count] = NULL;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/argz/argz_insert.c b/newlib/libc/argz/argz_insert.c
index d0a32ec..8c3e8fd 100644
--- a/newlib/libc/argz/argz_insert.c
+++ b/newlib/libc/argz/argz_insert.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002, 2005 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -22,11 +23,15 @@ _DEFUN (argz_insert, (argz, argz_len, before, entry),
   int len = 0;
   ptrdiff_t delta;
 
-  if (before == NULL)
+  if (before == NULL) {
+    __A_VARIABLE = 1;
     return argz_add(argz, argz_len, entry);
+  }
 
-  if (before < *argz || before >= *argz + *argz_len)
+  if (before < *argz || before >= *argz + *argz_len) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   while (before != *argz && before[-1])
     before--;
@@ -36,13 +41,16 @@ _DEFUN (argz_insert, (argz, argz_len, before, entry),
 
   len = strlen(entry) + 1;
 
-  if(!(*argz = (char *)realloc(*argz, *argz_len + len)))
+  if(!(*argz = (char *)realloc(*argz, *argz_len + len))) {
+    __A_VARIABLE = 1;
     return ENOMEM;
+  }
   
   memmove(*argz + delta + len, *argz + delta,  *argz_len - delta);
   memcpy(*argz + delta, entry, len);
 
   *argz_len += len;
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_next.c b/newlib/libc/argz/argz_next.c
index 94852f5..2d63601 100644
--- a/newlib/libc/argz/argz_next.c
+++ b/newlib/libc/argz/argz_next.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libc/argz/argz_replace.c b/newlib/libc/argz/argz_replace.c
index b274f91..0bf3e17 100644
--- a/newlib/libc/argz/argz_replace.c
+++ b/newlib/libc/argz/argz_replace.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -46,8 +47,10 @@ _DEFUN (argz_replace, (argz, argz_len, str, with, replace_count),
 
   if (*replace_count)
     {
-      if (!(new_argz = (char *)malloc(new_argz_len)))
+      if (!(new_argz = (char *)malloc(new_argz_len))) {
+	__A_VARIABLE = 1;
 	return ENOMEM;
+      }
       
       buf_iter = *argz;
       buf_len = *argz_len;
@@ -75,6 +78,7 @@ _DEFUN (argz_replace, (argz, argz_len, str, with, replace_count),
       if(!(argz_realloc = (char *)realloc(*argz, new_argz_len)))
         {
           free(new_argz);
+          __A_VARIABLE = 1;
           return ENOMEM;
         }
       *argz = argz_realloc;
@@ -90,5 +94,6 @@ _DEFUN (argz_replace, (argz, argz_len, str, with, replace_count),
       free(new_argz);
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/argz_stringify.c b/newlib/libc/argz/argz_stringify.c
index be5f2cf..0e35ebe 100644
--- a/newlib/libc/argz/argz_stringify.c
+++ b/newlib/libc/argz/argz_stringify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -24,4 +25,5 @@ _DEFUN (argz_stringify, (argz, argz_len, sep),
 	if (argz[i] == '\0')
 	  argz[i] = sep;
       }
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/argz/buf_findstr.c b/newlib/libc/argz/buf_findstr.c
index aeb32a9..9b5ed1e 100644
--- a/newlib/libc/argz/buf_findstr.c
+++ b/newlib/libc/argz/buf_findstr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -29,6 +30,7 @@ _buf_findstr(const char *str, char **buf, size_t *buf_len)
             {
               *buf += j;
               *buf_len -= j;
+              __A_VARIABLE = 1;
               return 1;
             }
         }
@@ -40,5 +42,6 @@ _buf_findstr(const char *str, char **buf, size_t *buf_len)
       *buf_len = 0;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/dummy.c b/newlib/libc/argz/dummy.c
index 895395e..8ebc983 100644
--- a/newlib/libc/argz/dummy.c
+++ b/newlib/libc/argz/dummy.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* empty stub to allow objectlist.awk.in to be created */
diff --git a/newlib/libc/argz/envz_add.c b/newlib/libc/argz/envz_add.c
index 3e91a58..0f6de9a 100644
--- a/newlib/libc/argz/envz_add.c
+++ b/newlib/libc/argz/envz_add.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libc/argz/envz_entry.c b/newlib/libc/argz/envz_entry.c
index 3d1986b..ec12e22 100644
--- a/newlib/libc/argz/envz_entry.c
+++ b/newlib/libc/argz/envz_entry.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -37,10 +38,12 @@ _DEFUN (envz_entry, (envz, envz_len, name),
                   if(*buf_ptr == '\0')
                     buf_ptr++;
 
+                  __A_VARIABLE = 1;
                   return (char *)buf_ptr;
                 }
             }
         }
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/argz/envz_get.c b/newlib/libc/argz/envz_get.c
index b4f7c28..47cf79f 100644
--- a/newlib/libc/argz/envz_get.c
+++ b/newlib/libc/argz/envz_get.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libc/argz/envz_merge.c b/newlib/libc/argz/envz_merge.c
index 8a26bc3..8767927 100644
--- a/newlib/libc/argz/envz_merge.c
+++ b/newlib/libc/argz/envz_merge.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -58,5 +59,6 @@ _DEFUN (envz_merge, (envz, envz_len, envz2, envz2_len, override),
           free(name_str);
         }
     }
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/argz/envz_remove.c b/newlib/libc/argz/envz_remove.c
index 1882297..cfc5e2e 100644
--- a/newlib/libc/argz/envz_remove.c
+++ b/newlib/libc/argz/envz_remove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -34,4 +35,5 @@ _DEFUN (envz_remove, (envz, envz_len, name),
       *envz = (char *)realloc(*envz, *envz_len - len);
       *envz_len -= len;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/argz/envz_strip.c b/newlib/libc/argz/envz_strip.c
index e1c4610..857d6d0 100644
--- a/newlib/libc/argz/envz_strip.c
+++ b/newlib/libc/argz/envz_strip.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -39,4 +40,5 @@ _DEFUN (envz_strip, (envz, envz_len),
     {
       *envz = (char *)realloc(*envz, *envz_len);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/ctype/ctype_.c b/newlib/libc/ctype/ctype_.c
index 9e3cdcf..2ecf936 100644
--- a/newlib/libc/ctype/ctype_.c
+++ b/newlib/libc/ctype/ctype_.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
@@ -184,6 +185,7 @@ __set_ctype (struct __locale_t *loc, const char *charset)
 #  else
   loc->ctype_ptr = ctype_ptr;
 #  endif
+  __A_VARIABLE = 1;
 }
 #endif /* !__CYGWIN__ */
 #endif /* _MB_CAPABLE */
diff --git a/newlib/libc/ctype/isalnum.c b/newlib/libc/ctype/isalnum.c
index 113ef02..4c17b4f 100644
--- a/newlib/libc/ctype/isalnum.c
+++ b/newlib/libc/ctype/isalnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION 
 	<<isalnum>>, <<isalnum_l>>---alphanumeric character predicate
@@ -50,5 +51,6 @@ No OS subroutines are required.
 int
 _DEFUN(isalnum,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & (_U|_L|_N));
 }
diff --git a/newlib/libc/ctype/isalnum_l.c b/newlib/libc/ctype/isalnum_l.c
index dcb7e36..6eeaf71 100644
--- a/newlib/libc/ctype/isalnum_l.c
+++ b/newlib/libc/ctype/isalnum_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 isalnum_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & (_U|_L|_N);
 }
diff --git a/newlib/libc/ctype/isalpha.c b/newlib/libc/ctype/isalpha.c
index 59511e1..1d8f25e 100644
--- a/newlib/libc/ctype/isalpha.c
+++ b/newlib/libc/ctype/isalpha.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isalpha>>, <<isalpha_l>>---alphabetic character predicate
@@ -49,5 +50,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isalpha,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & (_U|_L));
 }
diff --git a/newlib/libc/ctype/isalpha_l.c b/newlib/libc/ctype/isalpha_l.c
index dcae3cc..7b97c9b 100644
--- a/newlib/libc/ctype/isalpha_l.c
+++ b/newlib/libc/ctype/isalpha_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 isalpha_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & (_U|_L);
 }
diff --git a/newlib/libc/ctype/isascii.c b/newlib/libc/ctype/isascii.c
index 45e19ef..96d41f7 100644
--- a/newlib/libc/ctype/isascii.c
+++ b/newlib/libc/ctype/isascii.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isascii>>, <<isascii_l>>---ASCII character predicate
@@ -50,5 +51,6 @@ No supporting OS subroutines are required.
 int 
 _DEFUN(isascii,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return c >= 0 && c< 128;
 }
diff --git a/newlib/libc/ctype/isascii_l.c b/newlib/libc/ctype/isascii_l.c
index 59b5f95..ee0bcca 100644
--- a/newlib/libc/ctype/isascii_l.c
+++ b/newlib/libc/ctype/isascii_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 isascii_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return c >= 0 && c < 128;
 }
diff --git a/newlib/libc/ctype/isblank.c b/newlib/libc/ctype/isblank.c
index db62a26..6237c4c 100644
--- a/newlib/libc/ctype/isblank.c
+++ b/newlib/libc/ctype/isblank.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isblank>>, <<isblank_l>>---blank character predicate
@@ -48,5 +49,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isblank,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return ((__CTYPE_PTR[c+1] & _B) || (c == '\t'));
 }
diff --git a/newlib/libc/ctype/isblank_l.c b/newlib/libc/ctype/isblank_l.c
index 8bbb84e..7007548 100644
--- a/newlib/libc/ctype/isblank_l.c
+++ b/newlib/libc/ctype/isblank_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 isblank_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return (__locale_ctype_ptr_l (locale)[c+1] & _B) || (c == '\t');
 }
diff --git a/newlib/libc/ctype/iscntrl.c b/newlib/libc/ctype/iscntrl.c
index d78c957..1a44bce 100644
--- a/newlib/libc/ctype/iscntrl.c
+++ b/newlib/libc/ctype/iscntrl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iscntrl>>, <<iscntrl_l>>---control character predicate
@@ -52,5 +53,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iscntrl,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & _C);
 }
diff --git a/newlib/libc/ctype/iscntrl_l.c b/newlib/libc/ctype/iscntrl_l.c
index 0ae17c7..8faddde 100644
--- a/newlib/libc/ctype/iscntrl_l.c
+++ b/newlib/libc/ctype/iscntrl_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 iscntrl_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & _C;
 }
diff --git a/newlib/libc/ctype/isdigit.c b/newlib/libc/ctype/isdigit.c
index 06f1422..d510dd7 100644
--- a/newlib/libc/ctype/isdigit.c
+++ b/newlib/libc/ctype/isdigit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isdigit>>, <<isdigit_l>>---decimal digit predicate
@@ -51,5 +52,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isdigit,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & _N);
 }
diff --git a/newlib/libc/ctype/isdigit_l.c b/newlib/libc/ctype/isdigit_l.c
index 1fb79e0..5cfe84d 100644
--- a/newlib/libc/ctype/isdigit_l.c
+++ b/newlib/libc/ctype/isdigit_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 isdigit_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & _N;
 }
diff --git a/newlib/libc/ctype/islower.c b/newlib/libc/ctype/islower.c
index 466252a..bb3c02c 100644
--- a/newlib/libc/ctype/islower.c
+++ b/newlib/libc/ctype/islower.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<islower>>, <<islower_l>>---lowercase character predicate
@@ -49,5 +50,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(islower,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return ((__CTYPE_PTR[c+1] & (_U|_L)) == _L);
 }
diff --git a/newlib/libc/ctype/islower_l.c b/newlib/libc/ctype/islower_l.c
index d1f3a82..fc014d8 100644
--- a/newlib/libc/ctype/islower_l.c
+++ b/newlib/libc/ctype/islower_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 islower_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return (__locale_ctype_ptr_l (locale)[c+1] & (_U|_L)) == _L;
 }
diff --git a/newlib/libc/ctype/isprint.c b/newlib/libc/ctype/isprint.c
index 21fdf5b..285fd55 100644
--- a/newlib/libc/ctype/isprint.c
+++ b/newlib/libc/ctype/isprint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isprint>>, <<isgraph>>, <<isprint_l>>, <<isgraph_l>>---printable character predicates
@@ -64,6 +65,7 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isgraph,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & (_P|_U|_L|_N));
 }
 
@@ -72,5 +74,6 @@ _DEFUN(isgraph,(c),int c)
 int
 _DEFUN(isprint,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & (_P|_U|_L|_N|_B));
 }
diff --git a/newlib/libc/ctype/isprint_l.c b/newlib/libc/ctype/isprint_l.c
index 535504f..739d3c1 100644
--- a/newlib/libc/ctype/isprint_l.c
+++ b/newlib/libc/ctype/isprint_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,6 +7,7 @@
 int
 isgraph_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & (_P|_U|_L|_N);
 }
 
@@ -14,5 +16,6 @@ isgraph_l (int c, struct __locale_t *locale)
 int
 isprint_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & (_P|_U|_L|_N|_B);
 }
diff --git a/newlib/libc/ctype/ispunct.c b/newlib/libc/ctype/ispunct.c
index 4fb6219..d14b38d 100644
--- a/newlib/libc/ctype/ispunct.c
+++ b/newlib/libc/ctype/ispunct.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<ispunct>>, <<ispunct_l>>---punctuation character predicate
@@ -51,5 +52,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(ispunct,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & _P);
 }
diff --git a/newlib/libc/ctype/ispunct_l.c b/newlib/libc/ctype/ispunct_l.c
index eeba1f5..908a074 100644
--- a/newlib/libc/ctype/ispunct_l.c
+++ b/newlib/libc/ctype/ispunct_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,6 +7,7 @@
 int
 ispunct_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & _P;
 }
 
diff --git a/newlib/libc/ctype/isspace.c b/newlib/libc/ctype/isspace.c
index 2a19518..daf55d5 100644
--- a/newlib/libc/ctype/isspace.c
+++ b/newlib/libc/ctype/isspace.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isspace>>, <<isspace_l>>---whitespace character predicate
@@ -50,5 +51,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isspace,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & _S);
 }
diff --git a/newlib/libc/ctype/isspace_l.c b/newlib/libc/ctype/isspace_l.c
index bf4a36c..baa09c1 100644
--- a/newlib/libc/ctype/isspace_l.c
+++ b/newlib/libc/ctype/isspace_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,6 +7,7 @@
 int
 isspace_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & _S;
 }
 
diff --git a/newlib/libc/ctype/isupper.c b/newlib/libc/ctype/isupper.c
index e36b3a3..273a57b 100644
--- a/newlib/libc/ctype/isupper.c
+++ b/newlib/libc/ctype/isupper.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isupper>>, <<isupper_l>>---uppercase character predicate
@@ -47,5 +48,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isupper,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return ((__CTYPE_PTR[c+1] & (_U|_L)) == _U);
 }
diff --git a/newlib/libc/ctype/isupper_l.c b/newlib/libc/ctype/isupper_l.c
index eb473a7..53e1faa 100644
--- a/newlib/libc/ctype/isupper_l.c
+++ b/newlib/libc/ctype/isupper_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,6 +7,7 @@
 int
 isupper_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return (__locale_ctype_ptr_l (locale)[c+1] & (_U|_L)) == _U;
 }
 
diff --git a/newlib/libc/ctype/iswalnum.c b/newlib/libc/ctype/iswalnum.c
index 76fa504..bad21a2 100644
--- a/newlib/libc/ctype/iswalnum.c
+++ b/newlib/libc/ctype/iswalnum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswalnum>>, <<iswalnum_l>>---alphanumeric wide character test
@@ -44,5 +45,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswalnum,(c),wint_t c)
 {
+  __A_VARIABLE = 1;
   return (iswalpha (c) || iswdigit (c));
 }
diff --git a/newlib/libc/ctype/iswalnum_l.c b/newlib/libc/ctype/iswalnum_l.c
index e4ab3dd..15d3882 100644
--- a/newlib/libc/ctype/iswalnum_l.c
+++ b/newlib/libc/ctype/iswalnum_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswalnum_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswalpha (c) || iswdigit (c);
 }
diff --git a/newlib/libc/ctype/iswalpha.c b/newlib/libc/ctype/iswalpha.c
index 92fad8e..25e8d92 100644
--- a/newlib/libc/ctype/iswalpha.c
+++ b/newlib/libc/ctype/iswalpha.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -100,8 +101,10 @@ _DEFUN(iswalpha,(c), wint_t c)
       (x >= 0x120 && x <= 0x122) ||
       (x >= 0x130 && x <= 0x133) ||
       (x >= 0x200 && x <= 0x2a5) ||
-      (x >= 0x2a7 && x <= 0x2b6))
+      (x >= 0x2a7 && x <= 0x2b6)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
   
   switch (x)
     {
@@ -122,6 +125,7 @@ _DEFUN(iswalpha,(c), wint_t c)
     case 0xfc:
     case 0x2f8:
     case 0x2f9:
+      __A_VARIABLE = 1;
       return 1;
     case 0x02:
       table = u2;
@@ -412,6 +416,7 @@ _DEFUN(iswalpha,(c), wint_t c)
       size = sizeof(u2fa);
       break;
     default:
+      __A_VARIABLE = 1;
       return 0;
     }
   /* we have narrowed down to a section of 256 characters to check */
@@ -420,10 +425,14 @@ _DEFUN(iswalpha,(c), wint_t c)
   ctmp = (unsigned char)c;
   while (ptr < table + size)
     {
-      if (ctmp == *ptr)
+      if (ctmp == *ptr) {
+	__A_VARIABLE = 1;
 	return 1;
-      if (ctmp < *ptr)
+      }
+      if (ctmp < *ptr) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       /* otherwise c > *ptr */
       /* look for 0x0 as next element which indicates a range */
       ++ptr;
@@ -431,12 +440,15 @@ _DEFUN(iswalpha,(c), wint_t c)
 	{
 	  /* we have a range..see if c falls within range */
 	  ++ptr;
-	  if (ctmp <= *ptr)
+	  if (ctmp <= *ptr) {
+	    __A_VARIABLE = 1;
 	    return 1;
+	  }
 	  ++ptr;
 	}
     }
   /* not in table */
+  __A_VARIABLE = 1;
   return 0;
 #else
   return (c < (wint_t)0x100 ? isalpha (c) : 0);
diff --git a/newlib/libc/ctype/iswalpha_l.c b/newlib/libc/ctype/iswalpha_l.c
index efcb95a..32e3a4b 100644
--- a/newlib/libc/ctype/iswalpha_l.c
+++ b/newlib/libc/ctype/iswalpha_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswalpha_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswalpha (c);
 }
diff --git a/newlib/libc/ctype/iswblank.c b/newlib/libc/ctype/iswblank.c
index ca448a9..49ae3ae 100644
--- a/newlib/libc/ctype/iswblank.c
+++ b/newlib/libc/ctype/iswblank.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -81,6 +82,7 @@ _DEFUN(iswblank,(c), wint_t c)
   /* Based on Unicode 5.2.  Control char 09, plus all characters
      from general category "Zs", which are not marked as decomposition
      type "noBreak". */
+  __A_VARIABLE = 1;
   return (c == 0x0009 || c == 0x0020 ||
 	  c == 0x1680 || c == 0x180e ||
 	  (c >= 0x2000 && c <= 0x2006) ||
diff --git a/newlib/libc/ctype/iswblank_l.c b/newlib/libc/ctype/iswblank_l.c
index 6960693..3737285 100644
--- a/newlib/libc/ctype/iswblank_l.c
+++ b/newlib/libc/ctype/iswblank_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswblank_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswblank (c);
 }
diff --git a/newlib/libc/ctype/iswcntrl.c b/newlib/libc/ctype/iswcntrl.c
index d094d19..78f6fbd 100644
--- a/newlib/libc/ctype/iswcntrl.c
+++ b/newlib/libc/ctype/iswcntrl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -81,6 +82,7 @@ _DEFUN(iswcntrl,(c), wint_t c)
 
   /* Based on Unicode 5.2.  All characters from general category "Cc", "Zl",
      and "Zp".  */
+  __A_VARIABLE = 1;
   return ((c >= 0x0000 && c <= 0x001f) || 
 	  (c >= 0x007f && c <= 0x009f) ||
 	  c == 0x2028 || c == 0x2029);
diff --git a/newlib/libc/ctype/iswcntrl_l.c b/newlib/libc/ctype/iswcntrl_l.c
index 37caba8..459ae08 100644
--- a/newlib/libc/ctype/iswcntrl_l.c
+++ b/newlib/libc/ctype/iswcntrl_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswcntrl_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswcntrl (c);
 }
diff --git a/newlib/libc/ctype/iswctype.c b/newlib/libc/ctype/iswctype.c
index ff8e324..98eb540 100644
--- a/newlib/libc/ctype/iswctype.c
+++ b/newlib/libc/ctype/iswctype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswctype>>, <<iswctype_l>>---extensible wide-character test
@@ -49,30 +50,43 @@ _DEFUN(iswctype,(c, desc), wint_t c _AND wctype_t desc)
   switch (desc)
     {
     case WC_ALNUM:
+      __A_VARIABLE = 1;
       return iswalnum (c);
     case WC_ALPHA:
+      __A_VARIABLE = 1;
       return iswalpha (c);
     case WC_BLANK:
+      __A_VARIABLE = 1;
       return iswblank (c);
     case WC_CNTRL:
+      __A_VARIABLE = 1;
       return iswcntrl (c);
     case WC_DIGIT:
+      __A_VARIABLE = 1;
       return iswdigit (c);
     case WC_GRAPH:
+      __A_VARIABLE = 1;
       return iswgraph (c);
     case WC_LOWER:
+      __A_VARIABLE = 1;
       return iswlower (c);
     case WC_PRINT:
+      __A_VARIABLE = 1;
       return iswprint (c);
     case WC_PUNCT:
+      __A_VARIABLE = 1;
       return iswpunct (c);
     case WC_SPACE:
+      __A_VARIABLE = 1;
       return iswspace (c);
     case WC_UPPER:
+      __A_VARIABLE = 1;
       return iswupper (c);
     case WC_XDIGIT:
+      __A_VARIABLE = 1;
       return iswxdigit (c);
     default:
+      __A_VARIABLE = 1;
       return 0; /* eliminate warning */
     }
 
diff --git a/newlib/libc/ctype/iswctype_l.c b/newlib/libc/ctype/iswctype_l.c
index d9e7b2e..ed0236f 100644
--- a/newlib/libc/ctype/iswctype_l.c
+++ b/newlib/libc/ctype/iswctype_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswctype_l (wint_t c, wctype_t desc, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswctype (c, desc);
 }
diff --git a/newlib/libc/ctype/iswdigit.c b/newlib/libc/ctype/iswdigit.c
index 7c3ad4b..c7fa8cb 100644
--- a/newlib/libc/ctype/iswdigit.c
+++ b/newlib/libc/ctype/iswdigit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswdigit>>, <<iswdigit_l>>---decimal digit wide character test
@@ -43,5 +44,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswdigit,(c), wint_t c)
 {
+  __A_VARIABLE = 1;
   return (c >= (wint_t)'0' && c <= (wint_t)'9');
 }
diff --git a/newlib/libc/ctype/iswdigit_l.c b/newlib/libc/ctype/iswdigit_l.c
index 98dd94e..d92aa34 100644
--- a/newlib/libc/ctype/iswdigit_l.c
+++ b/newlib/libc/ctype/iswdigit_l.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
 int
 iswdigit_l (wint_t c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return (c >= (wint_t)'0' && c <= (wint_t)'9');
 }
diff --git a/newlib/libc/ctype/iswgraph.c b/newlib/libc/ctype/iswgraph.c
index 17e3060..13205c6 100644
--- a/newlib/libc/ctype/iswgraph.c
+++ b/newlib/libc/ctype/iswgraph.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -72,5 +73,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswgraph,(c),wint_t c)
 {
+  __A_VARIABLE = 1;
   return (iswprint (c) && !iswspace (c));
 }
diff --git a/newlib/libc/ctype/iswgraph_l.c b/newlib/libc/ctype/iswgraph_l.c
index 9803c18..eb1058e 100644
--- a/newlib/libc/ctype/iswgraph_l.c
+++ b/newlib/libc/ctype/iswgraph_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswgraph_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswprint (c) && !iswspace (c);
 }
diff --git a/newlib/libc/ctype/iswlower.c b/newlib/libc/ctype/iswlower.c
index 9d3b844..17fb5e5 100644
--- a/newlib/libc/ctype/iswlower.c
+++ b/newlib/libc/ctype/iswlower.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswlower>>, <<iswlower_l>>---lowercase wide character test
@@ -43,5 +44,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswlower,(c),wint_t c)
 {
+	__A_VARIABLE = 1;
 	return (towupper (c) != c);
 }
diff --git a/newlib/libc/ctype/iswlower_l.c b/newlib/libc/ctype/iswlower_l.c
index d69615b..cacfaad 100644
--- a/newlib/libc/ctype/iswlower_l.c
+++ b/newlib/libc/ctype/iswlower_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswlower_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return (towupper (c) != c);
 }
diff --git a/newlib/libc/ctype/iswprint.c b/newlib/libc/ctype/iswprint.c
index aad34ac..fc0b3f1 100644
--- a/newlib/libc/ctype/iswprint.c
+++ b/newlib/libc/ctype/iswprint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -103,8 +104,10 @@ _DEFUN(iswprint,(c), wint_t c)
       (x >= 0x200 && x <= 0x2a5) ||
       (x >= 0x2a7 && x <= 0x2b6) ||
       (x >= 0xf00 && x <= 0xffe) ||
-      (x >= 0x1000 && x <= 0x10fe))
+      (x >= 0x1000 && x <= 0x10fe)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
   
   switch (x)
     {
@@ -124,6 +127,7 @@ _DEFUN(iswprint,(c), wint_t c)
     case 0xfc:
     case 0x2f8:
     case 0x2f9:
+      __A_VARIABLE = 1;
       return 1;
     case 0x00:
       table = u0;
@@ -474,6 +478,7 @@ _DEFUN(iswprint,(c), wint_t c)
       size = sizeof(u10ff);
       break;
     default:
+      __A_VARIABLE = 1;
       return 0;
     }
   /* we have narrowed down to a section of 256 characters to check */
@@ -482,10 +487,14 @@ _DEFUN(iswprint,(c), wint_t c)
   ctmp = (unsigned char)c;
   while (ptr < table + size)
     {
-      if (ctmp == *ptr)
+      if (ctmp == *ptr) {
+	__A_VARIABLE = 1;
 	return 1;
-      if (ctmp < *ptr)
+      }
+      if (ctmp < *ptr) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       /* otherwise c > *ptr */
       /* look for 0x0 as next element which indicates a range */
       ++ptr;
@@ -493,12 +502,15 @@ _DEFUN(iswprint,(c), wint_t c)
 	{
 	  /* we have a range..see if c falls within range */
 	  ++ptr;
-	  if (ctmp <= *ptr)
+	  if (ctmp <= *ptr) {
+	    __A_VARIABLE = 1;
 	    return 1;
+	  }
 	  ++ptr;
 	}
     }
   /* not in table */
+  __A_VARIABLE = 1;
   return 0;
 #else
   return (c < (wint_t)0x100 ? isprint (c) : 0);
diff --git a/newlib/libc/ctype/iswprint_l.c b/newlib/libc/ctype/iswprint_l.c
index a8d8686..7023f10 100644
--- a/newlib/libc/ctype/iswprint_l.c
+++ b/newlib/libc/ctype/iswprint_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswprint_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswprint (c);
 }
diff --git a/newlib/libc/ctype/iswpunct.c b/newlib/libc/ctype/iswpunct.c
index 8b1791b..21ab320 100644
--- a/newlib/libc/ctype/iswpunct.c
+++ b/newlib/libc/ctype/iswpunct.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -76,5 +77,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswpunct,(c), wint_t c)
 {
+  __A_VARIABLE = 1;
   return (!iswalnum (c) && iswgraph (c));
 }
diff --git a/newlib/libc/ctype/iswpunct_l.c b/newlib/libc/ctype/iswpunct_l.c
index c7acc4e..2f820ed 100644
--- a/newlib/libc/ctype/iswpunct_l.c
+++ b/newlib/libc/ctype/iswpunct_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswpunct_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return !iswalnum (c) && iswgraph (c);
 }
diff --git a/newlib/libc/ctype/iswspace.c b/newlib/libc/ctype/iswspace.c
index 40a667c..24e61b7 100644
--- a/newlib/libc/ctype/iswspace.c
+++ b/newlib/libc/ctype/iswspace.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -81,6 +82,7 @@ _DEFUN(iswspace,(c), wint_t c)
   /* Based on Unicode 5.2.  Control chars 09-0D, plus all characters
      from general category "Zs", which are not marked as decomposition
      type "noBreak". */
+  __A_VARIABLE = 1;
   return ((c >= 0x0009 && c <= 0x000d) || c == 0x0020 ||
 	  c == 0x1680 || c == 0x180e ||
 	  (c >= 0x2000 && c <= 0x2006) ||
diff --git a/newlib/libc/ctype/iswspace_l.c b/newlib/libc/ctype/iswspace_l.c
index 0c30242..f21c420 100644
--- a/newlib/libc/ctype/iswspace_l.c
+++ b/newlib/libc/ctype/iswspace_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswspace_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return iswspace (c);
 }
diff --git a/newlib/libc/ctype/iswupper.c b/newlib/libc/ctype/iswupper.c
index 588e7f1..1480658 100644
--- a/newlib/libc/ctype/iswupper.c
+++ b/newlib/libc/ctype/iswupper.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswupper>>, <<iswupper_l>>---uppercase wide character test
@@ -43,5 +44,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswupper,(c),wint_t c)
 {
+  __A_VARIABLE = 1;
   return (towlower (c) != c);
 }
diff --git a/newlib/libc/ctype/iswupper_l.c b/newlib/libc/ctype/iswupper_l.c
index 2555cd0..7fde08d 100644
--- a/newlib/libc/ctype/iswupper_l.c
+++ b/newlib/libc/ctype/iswupper_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ iswupper_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return towlower (c) != c;
 }
diff --git a/newlib/libc/ctype/iswxdigit.c b/newlib/libc/ctype/iswxdigit.c
index 7cd3abb..6b74d91 100644
--- a/newlib/libc/ctype/iswxdigit.c
+++ b/newlib/libc/ctype/iswxdigit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<iswxdigit>>, <<iswxdigit_l>>---hexadecimal digit wide character test
@@ -43,6 +44,7 @@ No supporting OS subroutines are required.
 int
 _DEFUN(iswxdigit,(c), wint_t c)
 {
+  __A_VARIABLE = 1;
   return ((c >= (wint_t)'0' && c <= (wint_t)'9') ||
 	  (c >= (wint_t)'a' && c <= (wint_t)'f') ||
 	  (c >= (wint_t)'A' && c <= (wint_t)'F'));
diff --git a/newlib/libc/ctype/iswxdigit_l.c b/newlib/libc/ctype/iswxdigit_l.c
index 5a4c339..c60abc5 100644
--- a/newlib/libc/ctype/iswxdigit_l.c
+++ b/newlib/libc/ctype/iswxdigit_l.c
@@ -1,9 +1,11 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
 int
 iswxdigit_l (wint_t c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return ((c >= (wint_t)'0' && c <= (wint_t)'9') ||
 	  (c >= (wint_t)'a' && c <= (wint_t)'f') ||
 	  (c >= (wint_t)'A' && c <= (wint_t)'F'));
diff --git a/newlib/libc/ctype/isxdigit.c b/newlib/libc/ctype/isxdigit.c
index b55ba9c..6869db3 100644
--- a/newlib/libc/ctype/isxdigit.c
+++ b/newlib/libc/ctype/isxdigit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<isxdigit>>, <<isxdigit_l>>---hexadecimal digit predicate
@@ -50,5 +51,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN(isxdigit,(c),int c)
 {
+	__A_VARIABLE = 1;
 	return(__CTYPE_PTR[c+1] & ((_X)|(_N)));
 }
diff --git a/newlib/libc/ctype/isxdigit_l.c b/newlib/libc/ctype/isxdigit_l.c
index 726db31..b366184 100644
--- a/newlib/libc/ctype/isxdigit_l.c
+++ b/newlib/libc/ctype/isxdigit_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,6 +7,7 @@
 int
 isxdigit_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return __locale_ctype_ptr_l (locale)[c+1] & ((_X)|(_N));
 }
 
diff --git a/newlib/libc/ctype/jp2uc.c b/newlib/libc/ctype/jp2uc.c
index f5bd7db..8249627 100644
--- a/newlib/libc/ctype/jp2uc.c
+++ b/newlib/libc/ctype/jp2uc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Routine to translate from Japanese characters to Unicode */
 
 /* Copyright (c) 2002 Red Hat Incorporated.
@@ -160,6 +161,7 @@ _DEFUN (_jp2uc, (c), wint_t c)
     c = __jp2uc (c, JP_SJIS);
   else if (!strcmp (__current_locale_charset (), "EUCJP"))
     c = __jp2uc (c, JP_EUCJP);
+  __A_VARIABLE = 1;
   return c;
 }
 
diff --git a/newlib/libc/ctype/toascii.c b/newlib/libc/ctype/toascii.c
index 945e918..627ba54 100644
--- a/newlib/libc/ctype/toascii.c
+++ b/newlib/libc/ctype/toascii.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<toascii>>, <<toascii_l>>---force integers to ASCII range
@@ -48,6 +49,7 @@ No supporting OS subroutines are required.
 int
 _DEFUN(toascii,(c),int c)
 {
+  __A_VARIABLE = 1;
   return (c)&0177;
 }
 
diff --git a/newlib/libc/ctype/toascii_l.c b/newlib/libc/ctype/toascii_l.c
index 8781261..88afce3 100644
--- a/newlib/libc/ctype/toascii_l.c
+++ b/newlib/libc/ctype/toascii_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 
@@ -6,5 +7,6 @@
 int
 toascii_l (int c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return c & 0177;
 }
diff --git a/newlib/libc/ctype/tolower.c b/newlib/libc/ctype/tolower.c
index d1850ed..c4cd369 100644
--- a/newlib/libc/ctype/tolower.c
+++ b/newlib/libc/ctype/tolower.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<tolower>>, <<tolower_l>>---translate characters to lowercase
diff --git a/newlib/libc/ctype/tolower_l.c b/newlib/libc/ctype/tolower_l.c
index 3b196c8..948f445 100644
--- a/newlib/libc/ctype/tolower_l.c
+++ b/newlib/libc/ctype/tolower_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 #if defined (_MB_EXTENDED_CHARSETS_ISO) || defined (_MB_EXTENDED_CHARSETS_WINDOWS)
diff --git a/newlib/libc/ctype/toupper.c b/newlib/libc/ctype/toupper.c
index dc800e4..b570c36 100644
--- a/newlib/libc/ctype/toupper.c
+++ b/newlib/libc/ctype/toupper.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<toupper>>, <<toupper_l>>---translate characters to uppercase
diff --git a/newlib/libc/ctype/toupper_l.c b/newlib/libc/ctype/toupper_l.c
index b126c1e..cbf4a70 100644
--- a/newlib/libc/ctype/toupper_l.c
+++ b/newlib/libc/ctype/toupper_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <ctype.h>
 #if defined (_MB_EXTENDED_CHARSETS_ISO) \
diff --git a/newlib/libc/ctype/towctrans.c b/newlib/libc/ctype/towctrans.c
index a9eaf49..bde00a4 100644
--- a/newlib/libc/ctype/towctrans.c
+++ b/newlib/libc/ctype/towctrans.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -104,6 +105,7 @@ _DEFUN (towctrans, (c, w),
 	wint_t c _AND
         wctrans_t w)
 {
+  __A_VARIABLE = 1;
   return _towctrans_r (_REENT, c, w);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/ctype/towctrans_l.c b/newlib/libc/ctype/towctrans_l.c
index d7369e1..f03911e 100644
--- a/newlib/libc/ctype/towctrans_l.c
+++ b/newlib/libc/ctype/towctrans_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ towctrans_l (wint_t c, wctrans_t w, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return towctrans (c, w);
 }
diff --git a/newlib/libc/ctype/towlower.c b/newlib/libc/ctype/towlower.c
index b69c8ff..630e987 100644
--- a/newlib/libc/ctype/towlower.c
+++ b/newlib/libc/ctype/towlower.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
diff --git a/newlib/libc/ctype/towlower_l.c b/newlib/libc/ctype/towlower_l.c
index 2e89ec9..f385d12 100644
--- a/newlib/libc/ctype/towlower_l.c
+++ b/newlib/libc/ctype/towlower_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <newlib.h>
 #include <wctype.h>
@@ -8,5 +9,6 @@ towlower_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return towlower (c);
 }
diff --git a/newlib/libc/ctype/towupper.c b/newlib/libc/ctype/towupper.c
index 1e4d0f5..0ae48e6 100644
--- a/newlib/libc/ctype/towupper.c
+++ b/newlib/libc/ctype/towupper.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
diff --git a/newlib/libc/ctype/towupper_l.c b/newlib/libc/ctype/towupper_l.c
index 5a8384c..f53e506 100644
--- a/newlib/libc/ctype/towupper_l.c
+++ b/newlib/libc/ctype/towupper_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ towupper_l (wint_t c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return towupper (c);
 }
diff --git a/newlib/libc/ctype/wctrans.c b/newlib/libc/ctype/wctrans.c
index b3ad0bb..1f7ee9f 100644
--- a/newlib/libc/ctype/wctrans.c
+++ b/newlib/libc/ctype/wctrans.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -100,6 +101,7 @@ wctrans_t
 _DEFUN (wctrans, (c),
 	const char *c)
 {
+  __A_VARIABLE = 1;
   return _wctrans_r (_REENT, c);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/ctype/wctrans_l.c b/newlib/libc/ctype/wctrans_l.c
index 30e61a4..2e2505e 100644
--- a/newlib/libc/ctype/wctrans_l.c
+++ b/newlib/libc/ctype/wctrans_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
@@ -6,5 +7,6 @@ wctrans_l (const char *c, struct __locale_t *locale)
 {
   /* We're using a locale-independent representation of upper/lower case
      based on Unicode data.  Thus, the locale doesn't matter. */
+  __A_VARIABLE = 1;
   return wctrans (c);
 }
diff --git a/newlib/libc/ctype/wctype.c b/newlib/libc/ctype/wctype.c
index f32c421..d0a508b 100644
--- a/newlib/libc/ctype/wctype.c
+++ b/newlib/libc/ctype/wctype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2002 Red Hat Incorporated.
    All rights reserved.
 
@@ -143,6 +144,7 @@ wctype_t
 _DEFUN (wctype, (c),
 	const char *c)
 {
+  __A_VARIABLE = 1;
   return _wctype_r (_REENT, c);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/ctype/wctype_l.c b/newlib/libc/ctype/wctype_l.c
index c2793dd..4de7e20 100644
--- a/newlib/libc/ctype/wctype_l.c
+++ b/newlib/libc/ctype/wctype_l.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <wctype.h>
 
 wctype_t
 wctype_l (const char *c, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return wctype (c);
 }
diff --git a/newlib/libc/errno/errno.c b/newlib/libc/errno/errno.c
index fd1743d..53c11c6 100644
--- a/newlib/libc/errno/errno.c
+++ b/newlib/libc/errno/errno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The errno variable is stored in the reentrancy structure.  This
    function returns its address for use by the macro errno defined in
    errno.h.  */
@@ -10,6 +11,7 @@
 int *
 __errno ()
 {
+  __A_VARIABLE = 1;
   return &_REENT->_errno;
 }
 
diff --git a/newlib/libc/iconv/ccs/big5.c b/newlib/libc/iconv/ccs/big5.c
index 45ea59b..2b4a6ed 100644
--- a/newlib/libc/iconv/ccs/big5.c
+++ b/newlib/libc/iconv/ccs/big5.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for big5 encoding.
diff --git a/newlib/libc/iconv/ccs/ccsbi.c b/newlib/libc/iconv/ccs/ccsbi.c
index d79a2ce..51bb6ae 100644
--- a/newlib/libc/iconv/ccs/ccsbi.c
+++ b/newlib/libc/iconv/ccs/ccsbi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was automatically generated mkdeps.pl script. Don't edit.
  */
diff --git a/newlib/libc/iconv/ccs/cns11643_plane1.c b/newlib/libc/iconv/ccs/cns11643_plane1.c
index 37e31a9..5c2a955 100644
--- a/newlib/libc/iconv/ccs/cns11643_plane1.c
+++ b/newlib/libc/iconv/ccs/cns11643_plane1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cns11643_plane1 encoding.
diff --git a/newlib/libc/iconv/ccs/cns11643_plane14.c b/newlib/libc/iconv/ccs/cns11643_plane14.c
index 18230d5..5af3182 100644
--- a/newlib/libc/iconv/ccs/cns11643_plane14.c
+++ b/newlib/libc/iconv/ccs/cns11643_plane14.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cns11643_plane14 encoding.
diff --git a/newlib/libc/iconv/ccs/cns11643_plane2.c b/newlib/libc/iconv/ccs/cns11643_plane2.c
index c591ce3..e8f64bd 100644
--- a/newlib/libc/iconv/ccs/cns11643_plane2.c
+++ b/newlib/libc/iconv/ccs/cns11643_plane2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cns11643_plane2 encoding.
diff --git a/newlib/libc/iconv/ccs/cp775.c b/newlib/libc/iconv/ccs/cp775.c
index c35a87c..f7eced9 100644
--- a/newlib/libc/iconv/ccs/cp775.c
+++ b/newlib/libc/iconv/ccs/cp775.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cp775 encoding.
diff --git a/newlib/libc/iconv/ccs/cp850.c b/newlib/libc/iconv/ccs/cp850.c
index 305ae85..2d42b94 100644
--- a/newlib/libc/iconv/ccs/cp850.c
+++ b/newlib/libc/iconv/ccs/cp850.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cp850 encoding.
diff --git a/newlib/libc/iconv/ccs/cp852.c b/newlib/libc/iconv/ccs/cp852.c
index 73a1e0f..f8d84b8 100644
--- a/newlib/libc/iconv/ccs/cp852.c
+++ b/newlib/libc/iconv/ccs/cp852.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cp852 encoding.
diff --git a/newlib/libc/iconv/ccs/cp855.c b/newlib/libc/iconv/ccs/cp855.c
index 2add727..06dd666 100644
--- a/newlib/libc/iconv/ccs/cp855.c
+++ b/newlib/libc/iconv/ccs/cp855.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cp855 encoding.
diff --git a/newlib/libc/iconv/ccs/cp866.c b/newlib/libc/iconv/ccs/cp866.c
index 678ea42..9ccc190 100644
--- a/newlib/libc/iconv/ccs/cp866.c
+++ b/newlib/libc/iconv/ccs/cp866.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for cp866 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_1.c b/newlib/libc/iconv/ccs/iso_8859_1.c
index a239477..1112678 100644
--- a/newlib/libc/iconv/ccs/iso_8859_1.c
+++ b/newlib/libc/iconv/ccs/iso_8859_1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_1 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_10.c b/newlib/libc/iconv/ccs/iso_8859_10.c
index 1848afd..5fdcd8b 100644
--- a/newlib/libc/iconv/ccs/iso_8859_10.c
+++ b/newlib/libc/iconv/ccs/iso_8859_10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_10 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_11.c b/newlib/libc/iconv/ccs/iso_8859_11.c
index 97cc075..8ecb1a5 100644
--- a/newlib/libc/iconv/ccs/iso_8859_11.c
+++ b/newlib/libc/iconv/ccs/iso_8859_11.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_11 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_13.c b/newlib/libc/iconv/ccs/iso_8859_13.c
index 88a2a6f..f15ac8b 100644
--- a/newlib/libc/iconv/ccs/iso_8859_13.c
+++ b/newlib/libc/iconv/ccs/iso_8859_13.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_13 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_14.c b/newlib/libc/iconv/ccs/iso_8859_14.c
index 28052a7..ce4c8b1 100644
--- a/newlib/libc/iconv/ccs/iso_8859_14.c
+++ b/newlib/libc/iconv/ccs/iso_8859_14.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_14 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_15.c b/newlib/libc/iconv/ccs/iso_8859_15.c
index da3cfc3..a439887 100644
--- a/newlib/libc/iconv/ccs/iso_8859_15.c
+++ b/newlib/libc/iconv/ccs/iso_8859_15.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_15 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_2.c b/newlib/libc/iconv/ccs/iso_8859_2.c
index 5a19666..410f841 100644
--- a/newlib/libc/iconv/ccs/iso_8859_2.c
+++ b/newlib/libc/iconv/ccs/iso_8859_2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_2 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_3.c b/newlib/libc/iconv/ccs/iso_8859_3.c
index a69fcb3..1f4f4b7 100644
--- a/newlib/libc/iconv/ccs/iso_8859_3.c
+++ b/newlib/libc/iconv/ccs/iso_8859_3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_3 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_4.c b/newlib/libc/iconv/ccs/iso_8859_4.c
index 0cec458..c083d25 100644
--- a/newlib/libc/iconv/ccs/iso_8859_4.c
+++ b/newlib/libc/iconv/ccs/iso_8859_4.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_4 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_5.c b/newlib/libc/iconv/ccs/iso_8859_5.c
index e4765ff..8d946d8 100644
--- a/newlib/libc/iconv/ccs/iso_8859_5.c
+++ b/newlib/libc/iconv/ccs/iso_8859_5.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_5 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_6.c b/newlib/libc/iconv/ccs/iso_8859_6.c
index 783cf1f..689a257 100644
--- a/newlib/libc/iconv/ccs/iso_8859_6.c
+++ b/newlib/libc/iconv/ccs/iso_8859_6.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_6 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_7.c b/newlib/libc/iconv/ccs/iso_8859_7.c
index e964a02..8390ba9 100644
--- a/newlib/libc/iconv/ccs/iso_8859_7.c
+++ b/newlib/libc/iconv/ccs/iso_8859_7.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_7 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_8.c b/newlib/libc/iconv/ccs/iso_8859_8.c
index bf49604..1eb9fac 100644
--- a/newlib/libc/iconv/ccs/iso_8859_8.c
+++ b/newlib/libc/iconv/ccs/iso_8859_8.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_8 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_8859_9.c b/newlib/libc/iconv/ccs/iso_8859_9.c
index 20fbb84..65da5d6 100644
--- a/newlib/libc/iconv/ccs/iso_8859_9.c
+++ b/newlib/libc/iconv/ccs/iso_8859_9.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_8859_9 encoding.
diff --git a/newlib/libc/iconv/ccs/iso_ir_111.c b/newlib/libc/iconv/ccs/iso_ir_111.c
index 0e9bcc4..1c502e8 100644
--- a/newlib/libc/iconv/ccs/iso_ir_111.c
+++ b/newlib/libc/iconv/ccs/iso_ir_111.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for iso_ir_111 encoding.
diff --git a/newlib/libc/iconv/ccs/jis_x0201_1976.c b/newlib/libc/iconv/ccs/jis_x0201_1976.c
index e5cdb5f..2bd1deb 100644
--- a/newlib/libc/iconv/ccs/jis_x0201_1976.c
+++ b/newlib/libc/iconv/ccs/jis_x0201_1976.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for jis_x0201_1976 encoding.
diff --git a/newlib/libc/iconv/ccs/jis_x0208_1990.c b/newlib/libc/iconv/ccs/jis_x0208_1990.c
index c12d134..e4e0def 100644
--- a/newlib/libc/iconv/ccs/jis_x0208_1990.c
+++ b/newlib/libc/iconv/ccs/jis_x0208_1990.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for jis_x0208_1990 encoding.
diff --git a/newlib/libc/iconv/ccs/jis_x0212_1990.c b/newlib/libc/iconv/ccs/jis_x0212_1990.c
index eb8882f..8b0b1b2 100644
--- a/newlib/libc/iconv/ccs/jis_x0212_1990.c
+++ b/newlib/libc/iconv/ccs/jis_x0212_1990.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for jis_x0212_1990 encoding.
diff --git a/newlib/libc/iconv/ccs/koi8_r.c b/newlib/libc/iconv/ccs/koi8_r.c
index cccb7c1..1bb7573 100644
--- a/newlib/libc/iconv/ccs/koi8_r.c
+++ b/newlib/libc/iconv/ccs/koi8_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for koi8_r encoding.
diff --git a/newlib/libc/iconv/ccs/koi8_ru.c b/newlib/libc/iconv/ccs/koi8_ru.c
index 704ce95..e71a183 100644
--- a/newlib/libc/iconv/ccs/koi8_ru.c
+++ b/newlib/libc/iconv/ccs/koi8_ru.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for koi8_ru encoding.
diff --git a/newlib/libc/iconv/ccs/koi8_u.c b/newlib/libc/iconv/ccs/koi8_u.c
index ebe0c91..9715352 100644
--- a/newlib/libc/iconv/ccs/koi8_u.c
+++ b/newlib/libc/iconv/ccs/koi8_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for koi8_u encoding.
diff --git a/newlib/libc/iconv/ccs/koi8_uni.c b/newlib/libc/iconv/ccs/koi8_uni.c
index 5596c2d..d93e0fc 100644
--- a/newlib/libc/iconv/ccs/koi8_uni.c
+++ b/newlib/libc/iconv/ccs/koi8_uni.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for koi8_uni encoding.
diff --git a/newlib/libc/iconv/ccs/ksx1001.c b/newlib/libc/iconv/ccs/ksx1001.c
index ad2c30d..1227c5b 100644
--- a/newlib/libc/iconv/ccs/ksx1001.c
+++ b/newlib/libc/iconv/ccs/ksx1001.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for ksx1001 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1250.c b/newlib/libc/iconv/ccs/win_1250.c
index e43eb8d..0c4ed10 100644
--- a/newlib/libc/iconv/ccs/win_1250.c
+++ b/newlib/libc/iconv/ccs/win_1250.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1250 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1251.c b/newlib/libc/iconv/ccs/win_1251.c
index 7e9b4c3..a6799c1 100644
--- a/newlib/libc/iconv/ccs/win_1251.c
+++ b/newlib/libc/iconv/ccs/win_1251.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1251 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1252.c b/newlib/libc/iconv/ccs/win_1252.c
index 659054f..5194009 100644
--- a/newlib/libc/iconv/ccs/win_1252.c
+++ b/newlib/libc/iconv/ccs/win_1252.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1252 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1253.c b/newlib/libc/iconv/ccs/win_1253.c
index 4508133..ae58435 100644
--- a/newlib/libc/iconv/ccs/win_1253.c
+++ b/newlib/libc/iconv/ccs/win_1253.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1253 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1254.c b/newlib/libc/iconv/ccs/win_1254.c
index 3c1599a..5f985e4 100644
--- a/newlib/libc/iconv/ccs/win_1254.c
+++ b/newlib/libc/iconv/ccs/win_1254.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1254 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1255.c b/newlib/libc/iconv/ccs/win_1255.c
index 937afca..40fbe2d 100644
--- a/newlib/libc/iconv/ccs/win_1255.c
+++ b/newlib/libc/iconv/ccs/win_1255.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1255 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1256.c b/newlib/libc/iconv/ccs/win_1256.c
index 44d4519..7513017 100644
--- a/newlib/libc/iconv/ccs/win_1256.c
+++ b/newlib/libc/iconv/ccs/win_1256.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1256 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1257.c b/newlib/libc/iconv/ccs/win_1257.c
index ad497cb..d2d4648 100644
--- a/newlib/libc/iconv/ccs/win_1257.c
+++ b/newlib/libc/iconv/ccs/win_1257.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1257 encoding.
diff --git a/newlib/libc/iconv/ccs/win_1258.c b/newlib/libc/iconv/ccs/win_1258.c
index 7331d78..b2e2670 100644
--- a/newlib/libc/iconv/ccs/win_1258.c
+++ b/newlib/libc/iconv/ccs/win_1258.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was generated automatically - don't edit it.
  * File contains iconv CCS tables for win_1258 encoding.
diff --git a/newlib/libc/iconv/ces/cesbi.c b/newlib/libc/iconv/ces/cesbi.c
index c2e6520..83d49f3 100644
--- a/newlib/libc/iconv/ces/cesbi.c
+++ b/newlib/libc/iconv/ces/cesbi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was automatically generated mkdeps.pl script. Don't edit.
  */
diff --git a/newlib/libc/iconv/ces/euc.c b/newlib/libc/iconv/ces/euc.c
index 7492697..0ed5c5a 100644
--- a/newlib/libc/iconv/ces/euc.c
+++ b/newlib/libc/iconv/ces/euc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -108,8 +109,10 @@ _DEFUN(euc_from_ucs_init, (rptr, encoding),
   int i;
   euc_data_t *data;
 
-  if ((data = (euc_data_t *)_calloc_r (rptr, 1, sizeof (euc_data_t))) == NULL)
+  if ((data = (euc_data_t *)_calloc_r (rptr, 1, sizeof (euc_data_t))) == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   
 #if defined (_ICONV_TO_ENCODING_EUC_JP) \
  || defined (_ICONV_ENABLE_EXTERNAL_CCS)
@@ -154,13 +157,16 @@ ok:
         goto error;
     } 
 
+  __A_VARIABLE = 1;
   return data;
     
 error:
   _iconv_from_ucs_ces_handlers_table.close (rptr, data);
+  __A_VARIABLE = 1;
   return NULL;
 error1:
   _free_r (rptr, (_VOID_PTR)data);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -181,6 +187,7 @@ _DEFUN(euc_from_ucs_close, (rptr, data),
     }
   _free_r(rptr, data);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -198,12 +205,14 @@ _DEFUN(euc_convert_from_ucs, (data, in, outbuf, outbytesleft),
   size_t outbytesleft1;
   euc_data_t *d = (euc_data_t *)data;
 
-  if (in < 0x80) /* CS0 ASCII */
+  if (in < 0x80) /* CS0 ASCII */ {
+    __A_VARIABLE = 1;
     return _iconv_from_ucs_ces_handlers_us_ascii.convert_from_ucs (
                                                  NULL,
                                                  in,
                                                  outbuf,
                                                  outbytesleft);
+  }
       
   /* Try other CS */
   for (i = 0; d->desc[i].csname != NULL; i++) 
@@ -221,8 +230,10 @@ _DEFUN(euc_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                                          in,
                                                          &outbuf1,
                                                          &outbytesleft1);
-          if (res > 0)
+          if (res > 0) {
+            __A_VARIABLE = 1;
             return (size_t)ICONV_CES_NOSPACE;
+          }
 
           continue;
         }
@@ -243,18 +254,22 @@ _DEFUN(euc_convert_from_ucs, (data, in, outbuf, outbytesleft),
           if (d->desc[i].touchmsb)
             for (j = 0; j < d->desc[i].bytes; j++)
               {
-                if ((*outbuf)[j + d->desc[i].prefixbytes] & 0x80)
+                if ((*outbuf)[j + d->desc[i].prefixbytes] & 0x80) {
+                  __A_VARIABLE = 1;
                   return (size_t)ICONV_CES_INVALID_CHARACTER;
+                }
                 (*outbuf)[j + d->desc[i].prefixbytes] |= 0x80;
               }
 
           *outbuf = outbuf1;
           *outbytesleft = outbytesleft1;
           
+          __A_VARIABLE = 1;
           return (size_t)(res + d->desc[i].bytes);
         }
     }
 
+  __A_VARIABLE = 1;
   return (size_t)ICONV_CES_INVALID_CHARACTER;
 }
 #endif /* ICONV_FROM_UCS_CES_EUC */
@@ -268,8 +283,10 @@ _DEFUN(euc_to_ucs_init, (rptr, encoding),
   int i;
   euc_data_t *data;
 
-  if ((data = (euc_data_t *)_calloc_r (rptr, 1, sizeof (euc_data_t))) == NULL)
+  if ((data = (euc_data_t *)_calloc_r (rptr, 1, sizeof (euc_data_t))) == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   
 #if defined (_ICONV_TO_ENCODING_EUC_JP) \
  || defined (_ICONV_ENABLE_EXTERNAL_CCS)
@@ -314,13 +331,16 @@ ok:
         goto error;
     } 
 
+  __A_VARIABLE = 1;
   return data;
     
 error:
   _iconv_to_ucs_ces_handlers_table.close (rptr, data);
+  __A_VARIABLE = 1;
   return NULL;
 error1:
   _free_r (rptr, (_VOID_PTR)data);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -341,6 +361,7 @@ _DEFUN(euc_to_ucs_close, (rptr, data),
     }
   _free_r(rptr, data);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -435,6 +456,7 @@ static int
 _DEFUN(euc_get_mb_cur_max, (data),
                            _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return ((euc_data_t *)data)->mb_cur_max;
 }
 
diff --git a/newlib/libc/iconv/ces/table-pcs.c b/newlib/libc/iconv/ces/table-pcs.c
index fc46e27..0197ebf 100644
--- a/newlib/libc/iconv/ces/table-pcs.c
+++ b/newlib/libc/iconv/ces/table-pcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * modification, are permitted provided that the following conditions
@@ -46,17 +47,21 @@ _DEFUN(table_pcs_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                unsigned char **outbuf _AND
                                size_t *outbytesleft)
 {
-  if (*outbytesleft < 1)
+  if (*outbytesleft < 1) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
     
   if (in  < 0x80)
     {
       **outbuf = (unsigned char)in;
       *outbuf += 1;
       *outbytesleft -= 1;
+      __A_VARIABLE = 1;
       return 1;
     }
 
+  __A_VARIABLE = 1;
   return _iconv_from_ucs_ces_handlers_table.convert_from_ucs (
                                                     data,
                                                     in,
@@ -69,6 +74,7 @@ _DEFUN(table_pcs_from_ucs_init, (rptr, encoding),
                                 struct _reent *rptr _AND
                                 _CONST char *encoding)
 {
+  __A_VARIABLE = 1;
   return _iconv_from_ucs_ces_handlers_table.init (rptr, encoding);
 }
 
@@ -77,6 +83,7 @@ _DEFUN(table_pcs_from_ucs_close, (rptr, data),
                                  struct _reent *rptr _AND
                                  _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return _iconv_from_ucs_ces_handlers_table.close (rptr, data);
 }
 
@@ -84,6 +91,7 @@ static int
 _DEFUN(table_pcs_from_ucs_get_mb_cur_max, (data),
                                            _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return _iconv_from_ucs_ces_handlers_table.get_mb_cur_max (data);
 }
 
@@ -96,16 +104,20 @@ _DEFUN(table_pcs_convert_to_ucs, (data, inbuf, inbytesleft),
                              _CONST unsigned char **inbuf _AND
                              size_t *inbytesleft)
 {
-  if (*inbytesleft < 1)
+  if (*inbytesleft < 1) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   if (**inbuf < 0x80)
     {
       *inbytesleft -= 1;
       *inbuf += 1;
+      __A_VARIABLE = 1;
       return (ucs4_t)(*(*inbuf - 1));
     }
     
+  __A_VARIABLE = 1;
   return _iconv_to_ucs_ces_handlers_table.convert_to_ucs (
                                                              data,
                                                              inbuf,
@@ -117,6 +129,7 @@ _DEFUN(table_pcs_to_ucs_init, (rptr, encoding),
                               struct _reent *rptr _AND
                               _CONST char *encoding)
 {
+  __A_VARIABLE = 1;
   return _iconv_to_ucs_ces_handlers_table.init (rptr, encoding);
 }
 
@@ -125,6 +138,7 @@ _DEFUN(table_pcs_to_ucs_close, (rptr, data),
                                struct _reent *rptr _AND
                                _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return _iconv_to_ucs_ces_handlers_table.close (rptr, data);
 }
 
@@ -132,6 +146,7 @@ static int
 _DEFUN(table_pcs_to_ucs_get_mb_cur_max, (data),
                                          _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return _iconv_to_ucs_ces_handlers_table.get_mb_cur_max (data);
 }
 
diff --git a/newlib/libc/iconv/ces/table.c b/newlib/libc/iconv/ces/table.c
index e43e23f..f4ffad7 100644
--- a/newlib/libc/iconv/ces/table.c
+++ b/newlib/libc/iconv/ces/table.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -84,6 +85,7 @@ _DEFUN(table_close, (rptr, data),
     _free_r (rptr, (_VOID_PTR)ccsp->tbl);
 
   _free_r( rptr, (_VOID_PTR)ccsp);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -220,21 +222,28 @@ _DEFUN(table_convert_to_ucs, (data, inbuf, inbytesleft),
   
   if (ccsp->bits == TABLE_8BIT)
     {
-      if (*inbytesleft < 1)
+      if (*inbytesleft < 1) {
+        __A_VARIABLE = 1;
         return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+      }
   
       ucs = (ucs2_t)ccsp->tbl[**inbuf];
       
-      if (ucs == INVALC)
+      if (ucs == INVALC) {
+        __A_VARIABLE = 1;
         return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+      }
          
       *inbytesleft -= 1;
       *inbuf += 1;
+      __A_VARIABLE = 1;
       return (ucs4_t)ucs; 
     }
 
-  if (*inbytesleft < 2)
+  if (*inbytesleft < 2) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   if (ccsp->optimization == TABLE_SIZE_OPTIMIZED)
     ucs = find_code_size((ucs2_t)**inbuf << 8 | (ucs2_t)*(*inbuf + 1),
@@ -243,11 +252,14 @@ _DEFUN(table_convert_to_ucs, (data, inbuf, inbytesleft),
     ucs = find_code_speed((ucs2_t)**inbuf << 8 | (ucs2_t)*(*inbuf + 1),
                           ccsp->tbl);
 
-  if (ucs == INVALC)
+  if (ucs == INVALC) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
 
   *inbuf += 2;
   *inbytesleft -= 2;
+  __A_VARIABLE = 1;
   return (ucs4_t)ucs; 
 }
 #endif /* ICONV_TO_UCS_CES_TABLE */
@@ -256,6 +268,7 @@ static int
 _DEFUN(table_get_mb_cur_max, (data),
                              _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return ((iconv_ccs_desc_t *)data)->bits/8;
 }
 
@@ -309,9 +322,12 @@ _DEFUN(find_code_speed, (code, tblp),
 {
   int idx = tblp[code >> 8];
 
-  if (idx == INVBLK)
+  if (idx == INVBLK) {
+    __A_VARIABLE = 1;
     return (ucs2_t)INVALC;
+  }
 
+  __A_VARIABLE = 1;
   return (ucs2_t)tblp[(code & 0x00FF) + idx];
 }
 
@@ -333,16 +349,21 @@ _DEFUN(find_code_speed_8bit, (code, tblp),
   int idx;
   unsigned char ccs;
 
-  if (code == ((ucs2_t *)tblp)[0])
+  if (code == ((ucs2_t *)tblp)[0]) {
+    __A_VARIABLE = 1;
     return (ucs2_t)0xFF;
+  }
  
   idx = ((ucs2_t *)tblp)[1 + (code >> 8)];
   
-  if (idx == INVBLK)
+  if (idx == INVBLK) {
+    __A_VARIABLE = 1;
     return (ucs2_t)INVALC;
+  }
 
   ccs = tblp[(code & 0x00FF) + idx];
 
+  __A_VARIABLE = 1;
   return ccs == 0xFF ? (ucs2_t)INVALC : (ucs2_t)ccs;
 }
 
diff --git a/newlib/libc/iconv/ces/ucs-2-internal.c b/newlib/libc/iconv/ces/ucs-2-internal.c
index 893bdd4..b27047b 100644
--- a/newlib/libc/iconv/ces/ucs-2-internal.c
+++ b/newlib/libc/iconv/ces/ucs-2-internal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -50,16 +51,21 @@ _DEFUN(ucs_2_internal_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                         unsigned char **outbuf _AND
                                         size_t *outbytesleft)
 {
-  if (in > 0x0000FFFF)
+  if (in > 0x0000FFFF) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_INVALID_CHARACTER;
+  }
   
-  if (*outbytesleft < sizeof (ucs2_t))
+  if (*outbytesleft < sizeof (ucs2_t)) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   *((ucs2_t *)(*outbuf)) = (ucs2_t)in;
   *outbuf += sizeof (ucs2_t);
   *outbytesleft -= sizeof (ucs2_t);
 
+  __A_VARIABLE = 1;
   return sizeof (ucs2_t);
 }
 #endif /* ICONV_FROM_UCS_CES_UCS_2_INTERNAL */
@@ -73,17 +79,22 @@ _DEFUN(ucs_2_internal_convert_to_ucs, (data, inbuf, inbytesleft),
 {
   register ucs4_t res;
   
-  if (*inbytesleft < sizeof (ucs2_t))
+  if (*inbytesleft < sizeof (ucs2_t)) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   res = (ucs4_t)*((ucs2_t *)(*inbuf));
   
-  if (res > 0x0000FFFF)
+  if (res > 0x0000FFFF) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
     
   *inbuf += sizeof (ucs2_t);
   *inbytesleft -= sizeof (ucs2_t);
 
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* ICONV_TO_UCS_CES_UCS_2_INTERNAL */
@@ -92,6 +103,7 @@ static int
 _DEFUN(ucs_2_internal_get_mb_cur_max, (data),
                                       _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/newlib/libc/iconv/ces/ucs-2.c b/newlib/libc/iconv/ces/ucs-2.c
index 6f796ca..1b5ded9 100644
--- a/newlib/libc/iconv/ces/ucs-2.c
+++ b/newlib/libc/iconv/ces/ucs-2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -56,14 +57,17 @@ _DEFUN(ucs_2_init, (rptr, encoding),
 {
   int *data;
   
-  if ((data = (int *) _malloc_r(rptr, sizeof (int))) == NULL)
+  if ((data = (int *) _malloc_r(rptr, sizeof (int))) == NULL) {
+    __A_VARIABLE = 1;
     return (_VOID_PTR)NULL;
+  }
   
   if (strcmp (encoding, UCS_2LE) == 0)
     *data = UCS_2_LITTLE_ENDIAN;
   else
     *data = UCS_2_BIG_ENDIAN;
      
+  __A_VARIABLE = 1;
   return (_VOID_PTR)data;
 }
 
@@ -73,6 +77,7 @@ _DEFUN(ucs_2_close, (rptr, data),
                     _VOID_PTR data)
 {
   _free_r (rptr, data);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -85,11 +90,15 @@ _DEFUN(ucs_2_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                size_t *outbytesleft)
 {
   if ((in  >= 0x0000D800 && in <= 0x0000DFFF) /* Surrogate character */
-      || in >= 0x0000FFFE)
+      || in >= 0x0000FFFE) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_INVALID_CHARACTER;
+  }
 
-  if (*outbytesleft < sizeof (ucs2_t))
+  if (*outbytesleft < sizeof (ucs2_t)) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   if (*((int *)data) == UCS_2_BIG_ENDIAN)
     *((ucs2_t *)(*outbuf)) = ICONV_HTOBES ((ucs2_t)in);
@@ -99,6 +108,7 @@ _DEFUN(ucs_2_convert_from_ucs, (data, in, outbuf, outbytesleft),
   *outbuf += sizeof (ucs2_t);
   *outbytesleft -= sizeof (ucs2_t);
 
+  __A_VARIABLE = 1;
   return sizeof (ucs2_t);
 }
 #endif /* ICONV_FROM_UCS_CES_UCS_2 */
@@ -112,8 +122,10 @@ _DEFUN(ucs_2_convert_to_ucs, (data, inbuf, inbytesleft),
 {
   ucs4_t res;
   
-  if (*inbytesleft < sizeof (ucs2_t))
+  if (*inbytesleft < sizeof (ucs2_t)) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   if (*((int *)data) == UCS_2_BIG_ENDIAN)
     res = (ucs4_t)ICONV_BETOHS (*((ucs2_t *)(*inbuf)));
@@ -121,12 +133,15 @@ _DEFUN(ucs_2_convert_to_ucs, (data, inbuf, inbytesleft),
     res = (ucs4_t)ICONV_LETOHS (*((ucs2_t *)(*inbuf)));
 
   if ((res  >= 0x0000D800 && res <= 0x0000DFFF) /* Surrogate character */
-      || res >= 0x0000FFFE)
+      || res >= 0x0000FFFE) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
     
   *inbytesleft -= sizeof (ucs2_t);
   *inbuf += sizeof (ucs2_t);
 
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* ICONV_TO_UCS_CES_UCS_2 */
@@ -135,6 +150,7 @@ static int
 _DEFUN(ucs_2_get_mb_cur_max, (data),
                              _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/newlib/libc/iconv/ces/ucs-4-internal.c b/newlib/libc/iconv/ces/ucs-4-internal.c
index d8df9b1..69c9a72 100644
--- a/newlib/libc/iconv/ces/ucs-4-internal.c
+++ b/newlib/libc/iconv/ces/ucs-4-internal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -50,16 +51,21 @@ _DEFUN(ucs_4_internal_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                         unsigned char **outbuf _AND
                                         size_t *outbytesleft)
 {
-  if (in > 0x7FFFFFFF)
+  if (in > 0x7FFFFFFF) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_INVALID_CHARACTER;
+  }
     
-  if (*outbytesleft < sizeof (ucs4_t))
+  if (*outbytesleft < sizeof (ucs4_t)) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   *((ucs4_t *)(*outbuf)) = in;
   *outbytesleft -= sizeof (ucs4_t);
   *outbuf += sizeof (ucs4_t);
 
+  __A_VARIABLE = 1;
   return sizeof (ucs4_t);
 }
 #endif /* ICONV_FROM_UCS_CES_UCS_4_INTERNAL */
@@ -73,17 +79,22 @@ _DEFUN(ucs_4_internal_convert_to_ucs, (data, inbuf, inbytesleft),
 {
   register ucs4_t res;
 
-  if (*inbytesleft < sizeof (ucs4_t))
+  if (*inbytesleft < sizeof (ucs4_t)) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   res = *((ucs4_t *)(*inbuf));
 
-  if (res > 0x7FFFFFFF)
+  if (res > 0x7FFFFFFF) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
     
   *inbytesleft -= sizeof (ucs4_t);
   *inbuf += sizeof (ucs4_t);
   
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* ICONV_TO_UCS_CES_UCS_4_INTERNAL */
@@ -92,6 +103,7 @@ static int
 _DEFUN(ucs_4_internal_get_mb_cur_max, (data),
                                       _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/newlib/libc/iconv/ces/ucs-4.c b/newlib/libc/iconv/ces/ucs-4.c
index cfa7b36..4b1c258 100644
--- a/newlib/libc/iconv/ces/ucs-4.c
+++ b/newlib/libc/iconv/ces/ucs-4.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -57,14 +58,17 @@ _DEFUN(ucs_4_init, (rptr, encoding),
 {
   int *data;
   
-  if ((data = (int *)_malloc_r (rptr, sizeof(int))) == NULL)
+  if ((data = (int *)_malloc_r (rptr, sizeof(int))) == NULL) {
+    __A_VARIABLE = 1;
     return (_VOID_PTR)NULL;
+  }
   
   if (strcmp (encoding, UCS_4LE) == 0)
     *data = UCS_4_LITTLE_ENDIAN;
   else
     *data = UCS_4_BIG_ENDIAN;
      
+  __A_VARIABLE = 1;
   return (_VOID_PTR)data;
 }
 
@@ -74,6 +78,7 @@ _DEFUN(ucs_4_close, (rptr, data),
                     _VOID_PTR data)
 {
   _free_r(rptr, data);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -87,11 +92,15 @@ _DEFUN(ucs_4_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                size_t *outbytesleft)
 {
   if ((in  >= 0x0000D800 && in <= 0x0000DFFF) /* Surrogate character */
-      || in > 0x7FFFFFFF || in == 0x0000FFFF || in == 0x0000FFFE)
-    return (size_t)ICONV_CES_INVALID_CHARACTER; 
+      || in > 0x7FFFFFFF || in == 0x0000FFFF || in == 0x0000FFFE) {
+    __A_VARIABLE = 1;
+    return (size_t)ICONV_CES_INVALID_CHARACTER;
+  } 
 
-  if (*outbytesleft < sizeof (ucs4_t))
+  if (*outbytesleft < sizeof (ucs4_t)) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   if (*((int *)data) == UCS_4_BIG_ENDIAN)
     *((ucs4_t *)(*outbuf)) = ICONV_HTOBEL (in);
@@ -101,6 +110,7 @@ _DEFUN(ucs_4_convert_from_ucs, (data, in, outbuf, outbytesleft),
   *outbuf += sizeof (ucs4_t);
   *outbytesleft -= sizeof (ucs4_t);
 
+  __A_VARIABLE = 1;
   return sizeof (ucs4_t);
 }
 #endif /* ICONV_FROM_UCS_CES_UCS_4 */
@@ -114,8 +124,10 @@ _DEFUN(ucs_4_convert_to_ucs, (data, inbuf, inbytesleft),
 {
   ucs4_t res;
   
-  if (*inbytesleft < sizeof (ucs4_t))
+  if (*inbytesleft < sizeof (ucs4_t)) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   if (*((int *)data) == UCS_4_BIG_ENDIAN)
     res = ICONV_BETOHL (*((ucs4_t *)(*inbuf)));
@@ -123,12 +135,15 @@ _DEFUN(ucs_4_convert_to_ucs, (data, inbuf, inbytesleft),
     res = ICONV_LETOHL (*((ucs4_t *)(*inbuf)));
 
   if ((res  >= 0x0000D800 && res <= 0x0000DFFF) /* Surrogate character */
-      || res > 0x7FFFFFFF || res == 0x0000FFFF || res == 0x0000FFFE)
+      || res > 0x7FFFFFFF || res == 0x0000FFFF || res == 0x0000FFFE) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
 
   *inbytesleft -= sizeof (ucs4_t);
   *inbuf += sizeof(ucs4_t);
   
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* ICONV_TO_UCS_CES_UCS_4 */
@@ -137,6 +152,7 @@ static int
 _DEFUN(ucs_4_get_mb_cur_max, (data),
                              _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 4;
 }
 
diff --git a/newlib/libc/iconv/ces/us-ascii.c b/newlib/libc/iconv/ces/us-ascii.c
index 2f213a7..1fe61e8 100644
--- a/newlib/libc/iconv/ces/us-ascii.c
+++ b/newlib/libc/iconv/ces/us-ascii.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  *
@@ -46,14 +47,17 @@ _DEFUN(us_ascii_convert_from_ucs, (data, in, outbuf, outbytesleft),
                                   unsigned char **outbuf _AND
                                   size_t *outbytesleft)
 {
-  if (in  > 0x7F)
+  if (in  > 0x7F) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_INVALID_CHARACTER;
+  }
 
   *((char *)(*outbuf)) = (char)in;
     
   *outbuf += 1;
   *outbytesleft -= 1;
 
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* ICONV_FROM_UCS_CES_US_ASCII */
@@ -67,17 +71,22 @@ _DEFUN(us_ascii_convert_to_ucs, (data, inbuf, inbytesleft),
 {
   ucs4_t res;
 
-  if (*inbytesleft < 1)
+  if (*inbytesleft < 1) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_BAD_SEQUENCE;
+  }
 
   res = (ucs4_t)**inbuf;
 
-  if (res  > 0x7F)
+  if (res  > 0x7F) {
+    __A_VARIABLE = 1;
     return (ucs4_t)ICONV_CES_INVALID_CHARACTER;
+  }
     
   *inbytesleft -= 1;
   *inbuf += 1;
 
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* ICONV_TO_UCS_CES_US_ASCII */
@@ -86,6 +95,7 @@ static int
 _DEFUN(us_ascii_get_mb_cur_max, (data),
                                 _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/newlib/libc/iconv/ces/utf-16.c b/newlib/libc/iconv/ces/utf-16.c
index 4b2ff77..e3cfd73 100644
--- a/newlib/libc/iconv/ces/utf-16.c
+++ b/newlib/libc/iconv/ces/utf-16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -63,6 +64,7 @@ _DEFUN(utf_16_close, (rptr, data),
                      _VOID_PTR data)
 {
   _free_r(rptr, data);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -74,8 +76,10 @@ _DEFUN(utf_16_init_from_ucs, (rptr, encoding),
 {
   int *data;
   
-  if ((data = (int *)_malloc_r (rptr, sizeof (int))) == NULL)
+  if ((data = (int *)_malloc_r (rptr, sizeof (int))) == NULL) {
+    __A_VARIABLE = 1;
     return (_VOID_PTR)NULL;
+  }
   
   if (strcmp (encoding, UTF_16LE) == 0)
     *data = UTF16_LITTLE_ENDIAN;
@@ -84,6 +88,7 @@ _DEFUN(utf_16_init_from_ucs, (rptr, encoding),
   else
     *data = UTF16_SYSTEM_ENDIAN;
      
+  __A_VARIABLE = 1;
   return (_VOID_PTR)data;
 }
 
@@ -99,8 +104,10 @@ _DEFUN(utf_16_convert_from_ucs, (data, in, outbuf, outbytesleft),
   register int *state;
   
   if (in > 0x0010FFFF || (in >= 0x0000D800 && in <= 0x0000DFFF)
-      || in == 0x0000FFFF || in == 0x0000FFFE)
-    return (size_t)ICONV_CES_INVALID_CHARACTER; 
+      || in == 0x0000FFFF || in == 0x0000FFFE) {
+    __A_VARIABLE = 1;
+    return (size_t)ICONV_CES_INVALID_CHARACTER;
+  } 
 
   state = (int *)data;
   bytes = (*state == UTF16_SYSTEM_ENDIAN) ? sizeof (ucs2_t) * 2 
@@ -109,8 +116,10 @@ _DEFUN(utf_16_convert_from_ucs, (data, in, outbuf, outbytesleft),
   if (in > 0x0000FFFF)
     bytes += sizeof (ucs2_t);
 
-  if (*outbytesleft < bytes)
+  if (*outbytesleft < bytes) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   cp = (ucs2_t *)*outbuf;
 
@@ -164,6 +173,7 @@ _DEFUN(utf_16_convert_from_ucs, (data, in, outbuf, outbytesleft),
   *outbuf += bytes;
   *outbytesleft -= bytes;
 
+  __A_VARIABLE = 1;
   return bytes;
 }
 #endif /* ICONV_FROM_UCS_CES_UTF_16 */
@@ -176,8 +186,10 @@ _DEFUN(utf_16_init_to_ucs, (rptr, encoding),
 {
   int *data;
   
-  if ((data = (int *)_malloc_r (rptr, sizeof (int))) == NULL)
+  if ((data = (int *)_malloc_r (rptr, sizeof (int))) == NULL) {
+    __A_VARIABLE = 1;
     return (_VOID_PTR)NULL;
+  }
   
   if (strcmp (encoding, UTF_16BE) == 0)
     *data = UTF16_BIG_ENDIAN;
@@ -186,6 +198,7 @@ _DEFUN(utf_16_init_to_ucs, (rptr, encoding),
   else
     *data = UTF16_UNDEFINED;
      
+  __A_VARIABLE = 1;
   return (_VOID_PTR)data;
 }
 
@@ -271,6 +284,7 @@ static int
 _DEFUN(utf_16_get_mb_cur_max, (data),
                               _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 6;
 }
 
diff --git a/newlib/libc/iconv/ces/utf-8.c b/newlib/libc/iconv/ces/utf-8.c
index fda1e6e..c6c8305 100644
--- a/newlib/libc/iconv/ces/utf-8.c
+++ b/newlib/libc/iconv/ces/utf-8.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -53,8 +54,10 @@ _DEFUN(convert_from_ucs, (data, in, outbuf, outbytesleft),
   register size_t bytes;
 
   if ((in  >= 0x0000D800 && in <= 0x0000DFFF)
-      || in > 0x7FFFFFFF || in == 0x0000FFFF || in == 0x0000FFFE)
+      || in > 0x7FFFFFFF || in == 0x0000FFFF || in == 0x0000FFFE) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_INVALID_CHARACTER;
+  }
 
   if (in < 0x80)
     bytes = 1;
@@ -69,8 +72,10 @@ _DEFUN(convert_from_ucs, (data, in, outbuf, outbytesleft),
   else
     bytes = 6;
 
-  if (*outbytesleft < bytes)
+  if (*outbytesleft < bytes) {
+    __A_VARIABLE = 1;
     return (size_t)ICONV_CES_NOSPACE;
+  }
 
   cp = *outbuf;
   
@@ -119,6 +124,7 @@ _DEFUN(convert_from_ucs, (data, in, outbuf, outbytesleft),
   *outbytesleft -= bytes;
   *outbuf += bytes;
   
+  __A_VARIABLE = 1;
   return bytes;
 }
 #endif /* ICONV_FROM_UCS_CES_UTF_8 */
@@ -262,6 +268,7 @@ static int
 _DEFUN(get_mb_cur_max, (data),
                        _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return UTF8_MB_CUR_MAX;
 }
 
diff --git a/newlib/libc/iconv/lib/aliasesbi.c b/newlib/libc/iconv/lib/aliasesbi.c
index 36c434e..7e1fd2f 100644
--- a/newlib/libc/iconv/lib/aliasesbi.c
+++ b/newlib/libc/iconv/lib/aliasesbi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file was automatically generated mkdeps.pl script. Don't edit.
  */
diff --git a/newlib/libc/iconv/lib/aliasesi.c b/newlib/libc/iconv/lib/aliasesi.c
index 41497c6..4e477b7 100644
--- a/newlib/libc/iconv/lib/aliasesi.c
+++ b/newlib/libc/iconv/lib/aliasesi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  *
@@ -54,8 +55,10 @@ _DEFUN(canonical_form, (rptr, str),
 {
   char *p, *p1;
 
-  if (str == NULL || (p = p1 = _strdup_r (rptr, str)) == NULL)
+  if (str == NULL || (p = p1 = _strdup_r (rptr, str)) == NULL) {
+    __A_VARIABLE = 1;
     return (_CONST char *)NULL;
+  }
 
   for (; *str; str++, p++)
     {
@@ -65,6 +68,7 @@ _DEFUN(canonical_form, (rptr, str),
         *p = tolower (*str);
     }
 
+  __A_VARIABLE = 1;
   return (_CONST char *)p1;
 }
 
@@ -105,12 +109,16 @@ _DEFUN(find_alias, (rptr, alias, table, len),
   _CONST char *ptable = table;
   _CONST char *table_end = table + len;
 
-  if (table == NULL || alias == NULL || *table == '\0' || *alias == '\0')
+  if (table == NULL || alias == NULL || *table == '\0' || *alias == '\0') {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
 search_again:
-  if (len < l || (p = strnstr (ptable, alias, len)) == NULL)
+  if (len < l || (p = strnstr (ptable, alias, len)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   
   /* Check that substring is segregated by '\n', '\t' or ' ' */
   if (!((p == table || isspace (*(p-1)) || *(p-1) == '\n')
@@ -123,11 +131,14 @@ search_again:
 
   while(--p > table && *p != '\n');
 
-  if (*(++p) == '#')
+  if (*(++p) == '#') {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   for (end = p + 1; !isspace (*end) && *end != '\n' && *end != '\0'; end++);
 
+  __A_VARIABLE = 1;
   return _strndup_r (rptr, p, (size_t)(end - p));
 }
 
@@ -155,15 +166,20 @@ _DEFUN(_iconv_resolve_encoding_name, (rptr, cname, path),
 
   /* Alias shouldn't contain white spaces, '\n' and '\r' symbols */ 
   while (*p)
-    if (*p == ' ' || *p == '\r' || *p++ == '\n')
+    if (*p == ' ' || *p == '\r' || *p++ == '\n') {
+      __A_VARIABLE = 1;
       return NULL;
+    }
     
-  if ((ca = canonical_form (rptr, ca)) == NULL)
+  if ((ca = canonical_form (rptr, ca)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   p = find_alias (rptr, ca, _iconv_aliases, strlen (_iconv_aliases));
   
   _free_r (rptr, (_VOID_PTR)ca);
+  __A_VARIABLE = 1;
   return p;
 }
 
diff --git a/newlib/libc/iconv/lib/iconv.c b/newlib/libc/iconv/lib/iconv.c
index 8214a78..ac99e0b 100644
--- a/newlib/libc/iconv/lib/iconv.c
+++ b/newlib/libc/iconv/lib/iconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -162,6 +163,7 @@ _DEFUN(iconv_open, (to, from),
                    _CONST char *to _AND
                    _CONST char *from)
 {
+  __A_VARIABLE = 1;
   return _iconv_open_r (_REENT, to, from);
 }
 
@@ -174,6 +176,7 @@ _DEFUN(iconv, (cd, inbuf, inbytesleft, outbuf, outbytesleft),
               char **__restrict outbuf       _AND
               size_t *__restrict outbytesleft)
 {
+    __A_VARIABLE = 1;
     return _iconv_r (_REENT, cd, (_CONST char **) inbuf, inbytesleft,
 		     outbuf, outbytesleft);
 }
@@ -182,6 +185,7 @@ _DEFUN(iconv, (cd, inbuf, inbytesleft, outbuf, outbytesleft),
 int
 _DEFUN(iconv_close, (cd), iconv_t cd)
 {
+    __A_VARIABLE = 1;
     return _iconv_close_r (_REENT, cd);
 }
 
@@ -195,21 +199,28 @@ _DEFUN(_iconv_open_r, (rptr, to, from),
 {
   iconv_conversion_t *ic;
     
-  if (to == NULL || from == NULL || *to == '\0' || *from == '\0')
+  if (to == NULL || from == NULL || *to == '\0' || *from == '\0') {
+    __A_VARIABLE = 1;
     return (iconv_t)-1;
+  }
 
-  if ((to = (_CONST char *)_iconv_resolve_encoding_name (rptr, to)) == NULL)
+  if ((to = (_CONST char *)_iconv_resolve_encoding_name (rptr, to)) == NULL) {
+    __A_VARIABLE = 1;
     return (iconv_t)-1;
+  }
 
   if ((from = (_CONST char *)_iconv_resolve_encoding_name (rptr, from)) == NULL)
     {
       _free_r (rptr, (_VOID_PTR)to);
+      __A_VARIABLE = 1;
       return (iconv_t)-1;
     }
 
   ic = (iconv_conversion_t *)_malloc_r (rptr, sizeof (iconv_conversion_t));
-  if (ic == NULL)
+  if (ic == NULL) {
+    __A_VARIABLE = 1;
     return (iconv_t)-1;
+  }
 
   /* Select which conversion type to use */
   if (strcmp (from, to) == 0)
@@ -231,9 +242,11 @@ _DEFUN(_iconv_open_r, (rptr, to, from),
   if (ic->data == NULL)
     {
       _free_r (rptr, (_VOID_PTR)ic);
+      __A_VARIABLE = 1;
       return (iconv_t)-1;
     }
 
+  __A_VARIABLE = 1;
   return (_VOID_PTR)ic;
 }
 
@@ -254,6 +267,7 @@ _DEFUN(_iconv_r, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
            && ic->handlers != &_iconv_ucs_conversion_handlers))
     {
       __errno_r (rptr) = EBADF;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
 
@@ -261,14 +275,17 @@ _DEFUN(_iconv_r, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
     {
       mbstate_t state_null = ICONV_ZERO_MB_STATE_T;
       
-      if (!ic->handlers->is_stateful(ic->data, 1))
+      if (!ic->handlers->is_stateful(ic->data, 1)) {
+        __A_VARIABLE = 1;
         return (size_t)0;
+      }
       
       if (outbuf == NULL || *outbuf == NULL)
         {
           /* Reset shift state */
           ic->handlers->set_state (ic->data, &state_null, 1);
           
+          __A_VARIABLE = 1;
           return (size_t)0;
         }
        
@@ -292,6 +309,7 @@ _DEFUN(_iconv_r, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
               *outbuf += state_null.__count;
               *outbytesleft -= state_null.__count;
 
+              __A_VARIABLE = 1;
               return (size_t)0;
             }
 
@@ -300,21 +318,25 @@ _DEFUN(_iconv_r, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
         }
        
       __errno_r (rptr) = E2BIG;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
   
   if (*inbytesleft == 0)
     {
       __errno_r (rptr) = EINVAL;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
    
   if (*outbytesleft == 0 || *outbuf == NULL)
     {
       __errno_r (rptr) = E2BIG;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
 
+  __A_VARIABLE = 1;
   return ic->handlers->convert (rptr,
                                 ic->data,
                                 (_CONST unsigned char**)inbuf,
@@ -338,6 +360,7 @@ _DEFUN(_iconv_close_r, (rptr, cd),
            && ic->handlers != &_iconv_ucs_conversion_handlers))
     {
       __errno_r (rptr) = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -345,6 +368,7 @@ _DEFUN(_iconv_close_r, (rptr, cd),
   
   _free_r (rptr, (_VOID_PTR)cd);
 
+  __A_VARIABLE = 1;
   return res;
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/iconv/lib/iconvnls.c b/newlib/libc/iconv/lib/iconvnls.c
index 1b42f2c..fa86a19 100644
--- a/newlib/libc/iconv/lib/iconvnls.c
+++ b/newlib/libc/iconv/lib/iconvnls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  *
@@ -77,8 +78,10 @@ _DEFUN(_iconv_nls_construct_filename, (rptr, file, ext),
   len2 = strlen (file);
   len3 = strlen (ext);
 
-  if ((p = _malloc_r (rptr, len1 + dirlen + len2 + len3 + 3)) == NULL)
+  if ((p = _malloc_r (rptr, len1 + dirlen + len2 + len3 + 3)) == NULL) {
+    __A_VARIABLE = 1;
     return (_CONST char *)NULL;
+  }
 
   memcpy (p, path, len1);
   if (p[len1 - 1] != '/')
@@ -95,6 +98,7 @@ _DEFUN(_iconv_nls_construct_filename, (rptr, file, ext),
   }
   p[len1] = '\0';
  
+  __A_VARIABLE = 1;
   return (_CONST char *)p;
 }
 
@@ -120,6 +124,7 @@ _DEFUN(_iconv_nls_get_mb_cur_max, (cd, direction),
 {
   iconv_conversion_t *ic = (iconv_conversion_t *)cd;
   
+  __A_VARIABLE = 1;
   return ic->handlers->get_mb_cur_max (ic->data, direction);
 }
 
@@ -143,6 +148,7 @@ _DEFUN(_iconv_nls_is_stateful, (cd, direction),
 {
   iconv_conversion_t *ic = (iconv_conversion_t *)cd;
   
+  __A_VARIABLE = 1;
   return ic->handlers->is_stateful (ic->data, direction);
 }
 
@@ -182,11 +188,14 @@ _DEFUN(_iconv_nls_conv, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
            && ic->handlers != &_iconv_ucs_conversion_handlers))
     {
       __errno_r (rptr) = EBADF;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
   
-  if (inbytesleft == NULL || *inbytesleft == 0)
+  if (inbytesleft == NULL || *inbytesleft == 0) {
+    __A_VARIABLE = 1;
     return (size_t)0;
+  }
   
   if (outbuf == NULL || *outbuf == NULL)
     flags |= ICONV_DONT_SAVE_BIT;
@@ -194,9 +203,11 @@ _DEFUN(_iconv_nls_conv, (rptr, cd, inbuf, inbytesleft, outbuf, outbytesleft),
   if (outbytesleft == NULL || *outbytesleft == 0)
     {
       __errno_r (rptr) = E2BIG;
+      __A_VARIABLE = 1;
       return (size_t)-1;
     }
 
+  __A_VARIABLE = 1;
   return ic->handlers->convert (rptr,
                                 ic->data,
                                 (_CONST unsigned char**)inbuf,
@@ -229,6 +240,7 @@ _DEFUN(_iconv_nls_get_state, (cd, ps, direction),
   
   ic->handlers->get_state (ic->data, ps, direction);
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -254,6 +266,7 @@ _DEFUN(_iconv_nls_set_state, (cd, ps, direction),
 {
   iconv_conversion_t *ic = (iconv_conversion_t *)cd;
   
+  __A_VARIABLE = 1;
   return ic->handlers->set_state (ic->data, ps, direction);
 }
 
@@ -266,12 +279,16 @@ _DEFUN(iconv_open1, (rptr, to, from),
 {
   iconv_conversion_t *ic;
     
-  if (to == NULL || from == NULL || *to == '\0' || *from == '\0')
+  if (to == NULL || from == NULL || *to == '\0' || *from == '\0') {
+    __A_VARIABLE = 1;
     return (iconv_t)-1;
+  }
 
   ic = (iconv_conversion_t *)_malloc_r (rptr, sizeof (iconv_conversion_t));
-  if (ic == NULL)
+  if (ic == NULL) {
+    __A_VARIABLE = 1;
     return (iconv_t)-1;
+  }
 
   /* Select which conversion type to use */
   if (strcmp (from, to) == 0)
@@ -290,9 +307,11 @@ _DEFUN(iconv_open1, (rptr, to, from),
   if (ic->data == NULL)
     {
       _free_r (rptr, (_VOID_PTR)ic);
+      __A_VARIABLE = 1;
       return (iconv_t)-1;
     }
 
+  __A_VARIABLE = 1;
   return (_VOID_PTR)ic;
 }
 
diff --git a/newlib/libc/iconv/lib/nullconv.c b/newlib/libc/iconv/lib/nullconv.c
index d35027f..620d223 100644
--- a/newlib/libc/iconv/lib/nullconv.c
+++ b/newlib/libc/iconv/lib/nullconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -41,6 +42,7 @@ _DEFUN(null_conversion_open, (rptr, to, from),
                              _CONST char *to     _AND
                              _CONST char *from)
 {
+  __A_VARIABLE = 1;
   return (_VOID_PTR)&null_conversion_dummy_data;
 }
 
@@ -50,6 +52,7 @@ _DEFUN(null_conversion_close, (rptr, data),
                               struct _reent *rptr _AND
                               _VOID_PTR data)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -88,6 +91,7 @@ _DEFUN(null_conversion_convert,
   *inbytesleft  -= len;
   *outbytesleft -= len;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -97,6 +101,7 @@ _DEFUN(null_conversion_get_mb_cur_max, (data, direction),
                                        _VOID_PTR data     _AND
                                        int direction)
 {
+  __A_VARIABLE = 1;
   return ICONV_MB_LEN_MAX;
 }
 
@@ -107,6 +112,7 @@ _DEFUN(null_conversion_get_state, (data, state, size),
                                   mbstate_t *state _AND
                                   int direction)
 {
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -117,6 +123,7 @@ _DEFUN(null_conversion_set_state, (data, state, direction),
                                   mbstate_t *state _AND
                                   int direction)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -125,6 +132,7 @@ _DEFUN(null_conversion_is_stateful, (data, direction),
                                     _VOID_PTR data _AND
                                     int direction)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/iconv/lib/ucsconv.c b/newlib/libc/iconv/lib/ucsconv.c
index cc5ceb9..f97e635 100644
--- a/newlib/libc/iconv/lib/ucsconv.c
+++ b/newlib/libc/iconv/lib/ucsconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003-2004, Artem B. Bityuckiy
  * Copyright (c) 1999,2000, Konstantin Chuguev. All rights reserved.
@@ -56,8 +57,10 @@ _DEFUN(ucs_based_conversion_open, (rptr, to, from),
   
   uc = (iconv_ucs_conversion_t *)
              _calloc_r (rptr, 1, sizeof (iconv_ucs_conversion_t));
-  if (uc == NULL)
+  if (uc == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* 
    * Find CES converter for "from" encoding ("from" source encoding corresponds
@@ -110,6 +113,7 @@ _DEFUN(ucs_based_conversion_open, (rptr, to, from),
   else
     uc->from_ucs.data = (_VOID_PTR)&fake_data;
 
+  __A_VARIABLE = 1;
   return uc;
 
 error:
@@ -118,6 +122,7 @@ error:
 
   _free_r (rptr, (_VOID_PTR)uc);
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -139,6 +144,7 @@ _DEFUN(ucs_based_conversion_close, (rptr, data),
 
   _free_r (rptr, (_VOID_PTR)data);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -275,6 +281,7 @@ _DEFUN(ucs_based_conversion_get_state, (data, state, direction),
         *state = nullstate; /* internal copy */
     }
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -349,9 +356,12 @@ _DEFUN(find_encoding_name, (searchee, names),
   _CONST char *p;
 
   for (p = *names; p != NULL; p = *(names++))
-    if (strcmp (p, searchee) == 0)
+    if (strcmp (p, searchee) == 0) {
+      __A_VARIABLE = 1;
       return 0;
+    }
 
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/newlib/libc/locale/duplocale.c b/newlib/libc/locale/duplocale.c
index 9f6156c..2b83d9f 100644
--- a/newlib/libc/locale/duplocale.c
+++ b/newlib/libc/locale/duplocale.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<duplocale>>---duplicate a locale object
@@ -46,6 +47,7 @@ _duplocale_r (struct _reent *p, struct __locale_t *locobj)
   int i;
 
 #ifndef _MB_CAPABLE
+  __A_VARIABLE = 1;
   return __get_C_locale ();
 #else /* _MB_CAPABLE */
   /* LC_GLOBAL_LOCALE denotes the global locale. */
@@ -97,6 +99,7 @@ error:
 struct __locale_t *
 duplocale (struct __locale_t *locobj)
 {
+  __A_VARIABLE = 1;
   return _duplocale_r (_REENT, locobj);
 }
 #endif
diff --git a/newlib/libc/locale/freelocale.c b/newlib/libc/locale/freelocale.c
index dd3c0f9..23671a8 100644
--- a/newlib/libc/locale/freelocale.c
+++ b/newlib/libc/locale/freelocale.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<freelocale>>---free resources allocated for a locale object
@@ -61,4 +62,5 @@ void
 freelocale (struct __locale_t *locobj)
 {
   _freelocale_r (_REENT, locobj);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/locale/lctype.c b/newlib/libc/locale/lctype.c
index 6446697..2b8a193 100644
--- a/newlib/libc/locale/lctype.c
+++ b/newlib/libc/locale/lctype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/newlib/libc/locale/lmessages.c b/newlib/libc/locale/lmessages.c
index 7a5bb56..a922c6e 100644
--- a/newlib/libc/locale/lmessages.c
+++ b/newlib/libc/locale/lmessages.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>
  * All rights reserved.
diff --git a/newlib/libc/locale/lmonetary.c b/newlib/libc/locale/lmonetary.c
index 995263b..12dec92 100644
--- a/newlib/libc/locale/lmonetary.c
+++ b/newlib/libc/locale/lmonetary.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
  * All rights reserved.
@@ -81,6 +82,7 @@ cnv(const char *str) {
 	int i = strtol(str, NULL, 10);
 	if (i == -1)
 		i = CHAR_MAX;
+	__A_VARIABLE = 1;
 	return (char)i;
 }
 #endif
diff --git a/newlib/libc/locale/lnumeric.c b/newlib/libc/locale/lnumeric.c
index b4ddbda..bb6a692 100644
--- a/newlib/libc/locale/lnumeric.c
+++ b/newlib/libc/locale/lnumeric.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2000, 2001 Alexey Zelkin <phantom@FreeBSD.org>
  * All rights reserved.
diff --git a/newlib/libc/locale/locale.c b/newlib/libc/locale/locale.c
index b540237..27aa569 100644
--- a/newlib/libc/locale/locale.c
+++ b/newlib/libc/locale/locale.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<setlocale>>, <<localeconv>>---select or query locale
@@ -314,9 +315,12 @@ _DEFUN(_setlocale_r, (p, category, locale),
   if (locale)
     { 
       if (strcmp (locale, "POSIX") && strcmp (locale, "C")
-	  && strcmp (locale, ""))
+	  && strcmp (locale, "")) {
+        __A_VARIABLE = 1;
         return NULL;
+      }
     }
+  __A_VARIABLE = 1;
   return "C";
 #else /* _MB_CAPABLE */
   static char new_categories[_LC_LAST][ENCODING_LEN + 1];
@@ -473,6 +477,7 @@ currentlocale ()
 	  }
 	break;
       }
+  __A_VARIABLE = 1;
   return global_locale_string;
 }
 
@@ -977,6 +982,7 @@ __get_locale_env (struct _reent *p, int category)
   if (env == NULL || !*env)
     env = __default_locale;
 
+  __A_VARIABLE = 1;
   return env;
 }
 #endif /* _MB_CAPABLE */
@@ -994,12 +1000,14 @@ _DEFUN_VOID (__locale_mb_cur_max)
 const char *
 __locale_ctype_ptr_l (struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return locale->ctype_ptr;
 }
 
 const char *
 __locale_ctype_ptr (void)
 {
+  __A_VARIABLE = 1;
   return __get_current_locale ()->ctype_ptr;
 }
 
@@ -1010,6 +1018,7 @@ _DEFUN (setlocale, (category, locale),
 	int category _AND
 	_CONST char *locale)
 {
+  __A_VARIABLE = 1;
   return _setlocale_r (_REENT, category, locale);
 }
 
diff --git a/newlib/libc/locale/localeconv.c b/newlib/libc/locale/localeconv.c
index 165f6f7..0a81acc 100644
--- a/newlib/libc/locale/localeconv.c
+++ b/newlib/libc/locale/localeconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "newlib.h"
 #include <reent.h>
 #include "setlocale.h"
@@ -6,8 +7,10 @@ struct lconv *
 __localeconv_l (struct __locale_t *locale)
 {
   struct lconv *lconv = &locale->lconv;
-  if (locale == __get_C_locale ())
+  if (locale == __get_C_locale ()) {
+    __A_VARIABLE = 1;
     return lconv;
+  }
 
 #ifdef __HAVE_LOCALE_INFO__
   const struct lc_numeric_T *n = __get_numeric_locale (locale);
@@ -47,6 +50,7 @@ __localeconv_l (struct __locale_t *locale)
   lconv->int_p_sign_posn = m->p_sign_posn[0];
 #endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
 #endif /* __HAVE_LOCALE_INFO__ */
+  __A_VARIABLE = 1;
   return lconv;
 }
 
@@ -57,6 +61,7 @@ _DEFUN (_localeconv_r, (data),
   /* Note that we always fall back to the global locale, even in case
      of specifying a reent.  Otherwise a call to _localeconv_r would just
      crash if the reent locale pointer is NULL. */
+  __A_VARIABLE = 1;
   return __localeconv_l (__get_current_locale ());
 }
 
@@ -64,6 +69,7 @@ _DEFUN (_localeconv_r, (data),
 struct lconv *
 _DEFUN_VOID (localeconv)
 {
+  __A_VARIABLE = 1;
   return __localeconv_l (__get_current_locale ());
 }
 #endif
diff --git a/newlib/libc/locale/newlocale.c b/newlib/libc/locale/newlocale.c
index c817625..7efb27d 100644
--- a/newlib/libc/locale/newlocale.c
+++ b/newlib/libc/locale/newlocale.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<newlocale>>---create or modify a locale object
@@ -87,6 +88,7 @@ _newlocale_r (struct _reent *p, int category_mask, const char *locale,
 	      struct __locale_t *base)
 {
 #ifndef _MB_CAPABLE
+  __A_VARIABLE = 1;
   return __get_C_locale ();
 #else /* _MB_CAPABLE */
   char new_categories[_LC_LAST][ENCODING_LEN + 1];
@@ -218,5 +220,6 @@ error:
 struct __locale_t *
 newlocale (int category_mask, const char *locale, struct __locale_t *base)
 {
+  __A_VARIABLE = 1;
   return _newlocale_r (_REENT, category_mask, locale, base);
 }
diff --git a/newlib/libc/locale/nl_langinfo.c b/newlib/libc/locale/nl_langinfo.c
index eb98491..27d60cb 100644
--- a/newlib/libc/locale/nl_langinfo.c
+++ b/newlib/libc/locale/nl_langinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>
  * All rights reserved.
@@ -374,6 +375,7 @@ do_codeset:
 		   LC_ constants are in ascending order. */
 		if (item > NL_LOCALE_NAME(LC_ALL)
 		    && item < NL_LOCALE_NAME(_LC_LAST)) {
+			__A_VARIABLE = 1;
 			return locale->categories[item
 						  - NL_LOCALE_NAME(LC_ALL)];
 		}
@@ -381,16 +383,19 @@ do_codeset:
 		if (item > _NL_LOCALE_EXTENDED_FIRST_ENTRY
 		    && item < _NL_LOCALE_EXTENDED_LAST_ENTRY) {
 			int idx = item - _NL_LOCALE_EXTENDED_FIRST_ENTRY - 1;
+			__A_VARIABLE = 1;
 			return *(char **) ((char *) (*nl_ext[idx].base)(locale)
 					   + nl_ext[idx].offset);
 		}
 #endif
 		ret = "";
    }
+   __A_VARIABLE = 1;
    return (ret);
 }
 
 char *nl_langinfo (nl_item item)
 {
+  __A_VARIABLE = 1;
   return nl_langinfo_l (item, __get_current_locale ());
 }
diff --git a/newlib/libc/locale/timelocal.c b/newlib/libc/locale/timelocal.c
index 4b36154..99c299f 100644
--- a/newlib/libc/locale/timelocal.c
+++ b/newlib/libc/locale/timelocal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>
  * Copyright (c) 1997 FreeBSD Inc.
diff --git a/newlib/libc/locale/uselocale.c b/newlib/libc/locale/uselocale.c
index 810590f..1496dfa 100644
--- a/newlib/libc/locale/uselocale.c
+++ b/newlib/libc/locale/uselocale.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<uselocale>>---free resources allocated for a locale object
@@ -67,6 +68,7 @@ _uselocale_r (struct _reent *p, struct __locale_t *newloc)
     p->_locale = NULL;
   else if (newloc)
     p->_locale = newloc;
+  __A_VARIABLE = 1;
   return current_locale;
 }
 
@@ -74,6 +76,7 @@ _uselocale_r (struct _reent *p, struct __locale_t *newloc)
 struct __locale_t *
 uselocale (struct __locale_t *newloc)
 {
+  __A_VARIABLE = 1;
   return _uselocale_r (_REENT, newloc);
 }
 #endif
diff --git a/newlib/libc/machine/aarch64/memchr-stub.c b/newlib/libc/machine/aarch64/memchr-stub.c
index dc550aa..e8d43ec 100644
--- a/newlib/libc/machine/aarch64/memchr-stub.c
+++ b/newlib/libc/machine/aarch64/memchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/memcmp-stub.c b/newlib/libc/machine/aarch64/memcmp-stub.c
index a4e4876..9bb07bc 100644
--- a/newlib/libc/machine/aarch64/memcmp-stub.c
+++ b/newlib/libc/machine/aarch64/memcmp-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/memcpy-stub.c b/newlib/libc/machine/aarch64/memcpy-stub.c
index cd6d72a..88e1e7e 100644
--- a/newlib/libc/machine/aarch64/memcpy-stub.c
+++ b/newlib/libc/machine/aarch64/memcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2012-2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/memmove-stub.c b/newlib/libc/machine/aarch64/memmove-stub.c
index 8fa4ab9..3dca594 100644
--- a/newlib/libc/machine/aarch64/memmove-stub.c
+++ b/newlib/libc/machine/aarch64/memmove-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/memset-stub.c b/newlib/libc/machine/aarch64/memset-stub.c
index 7defee8..a422bfc 100644
--- a/newlib/libc/machine/aarch64/memset-stub.c
+++ b/newlib/libc/machine/aarch64/memset-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2012-2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/rawmemchr-stub.c b/newlib/libc/machine/aarch64/rawmemchr-stub.c
index 4449412..14889aa 100644
--- a/newlib/libc/machine/aarch64/rawmemchr-stub.c
+++ b/newlib/libc/machine/aarch64/rawmemchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2015-2016, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/stpcpy-stub.c b/newlib/libc/machine/aarch64/stpcpy-stub.c
index bfaba5c..ef1d332 100644
--- a/newlib/libc/machine/aarch64/stpcpy-stub.c
+++ b/newlib/libc/machine/aarch64/stpcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2015, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strchr-stub.c b/newlib/libc/machine/aarch64/strchr-stub.c
index 3f9ec2d..686d4de 100644
--- a/newlib/libc/machine/aarch64/strchr-stub.c
+++ b/newlib/libc/machine/aarch64/strchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2014, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strchrnul-stub.c b/newlib/libc/machine/aarch64/strchrnul-stub.c
index b47e92d..e146281 100644
--- a/newlib/libc/machine/aarch64/strchrnul-stub.c
+++ b/newlib/libc/machine/aarch64/strchrnul-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2014, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strcmp-stub.c b/newlib/libc/machine/aarch64/strcmp-stub.c
index 871a241..7f8060e 100644
--- a/newlib/libc/machine/aarch64/strcmp-stub.c
+++ b/newlib/libc/machine/aarch64/strcmp-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2012-2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strcpy-stub.c b/newlib/libc/machine/aarch64/strcpy-stub.c
index 966277c..5f7f7c0 100644
--- a/newlib/libc/machine/aarch64/strcpy-stub.c
+++ b/newlib/libc/machine/aarch64/strcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2014, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strlen-stub.c b/newlib/libc/machine/aarch64/strlen-stub.c
index 717e209..13cb97a 100644
--- a/newlib/libc/machine/aarch64/strlen-stub.c
+++ b/newlib/libc/machine/aarch64/strlen-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strncmp-stub.c b/newlib/libc/machine/aarch64/strncmp-stub.c
index 1eb988f..9a421df 100644
--- a/newlib/libc/machine/aarch64/strncmp-stub.c
+++ b/newlib/libc/machine/aarch64/strncmp-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strnlen-stub.c b/newlib/libc/machine/aarch64/strnlen-stub.c
index 8e1903c..ddf8e8f 100644
--- a/newlib/libc/machine/aarch64/strnlen-stub.c
+++ b/newlib/libc/machine/aarch64/strnlen-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2013, Linaro Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/aarch64/strrchr-stub.c b/newlib/libc/machine/aarch64/strrchr-stub.c
index 5923a44..02b6c42 100644
--- a/newlib/libc/machine/aarch64/strrchr-stub.c
+++ b/newlib/libc/machine/aarch64/strrchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2014, ARM Limited
    All rights reserved.
 
diff --git a/newlib/libc/machine/arc/memcmp-stub.c b/newlib/libc/machine/arc/memcmp-stub.c
index 30c7884..da36fc1 100644
--- a/newlib/libc/machine/arc/memcmp-stub.c
+++ b/newlib/libc/machine/arc/memcmp-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/memcpy-stub.c b/newlib/libc/machine/arc/memcpy-stub.c
index cc46c2d..f762899 100644
--- a/newlib/libc/machine/arc/memcpy-stub.c
+++ b/newlib/libc/machine/arc/memcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/memset-stub.c b/newlib/libc/machine/arc/memset-stub.c
index 981ca1f..628feb9 100644
--- a/newlib/libc/machine/arc/memset-stub.c
+++ b/newlib/libc/machine/arc/memset-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/strchr-stub.c b/newlib/libc/machine/arc/strchr-stub.c
index 8d84a82..72927cc 100644
--- a/newlib/libc/machine/arc/strchr-stub.c
+++ b/newlib/libc/machine/arc/strchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/strcmp-stub.c b/newlib/libc/machine/arc/strcmp-stub.c
index 19528e3..83508ea 100644
--- a/newlib/libc/machine/arc/strcmp-stub.c
+++ b/newlib/libc/machine/arc/strcmp-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/strcpy-stub.c b/newlib/libc/machine/arc/strcpy-stub.c
index 80ea0e8..2b91ac4 100644
--- a/newlib/libc/machine/arc/strcpy-stub.c
+++ b/newlib/libc/machine/arc/strcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/strlen-stub.c b/newlib/libc/machine/arc/strlen-stub.c
index 942e9be..12461d9 100644
--- a/newlib/libc/machine/arc/strlen-stub.c
+++ b/newlib/libc/machine/arc/strlen-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arc/strncpy-stub.c b/newlib/libc/machine/arc/strncpy-stub.c
index 3f8f9db..e77efd1 100644
--- a/newlib/libc/machine/arc/strncpy-stub.c
+++ b/newlib/libc/machine/arc/strncpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    Copyright (c) 2015, Synopsys, Inc. All rights reserved.
 
diff --git a/newlib/libc/machine/arm/aeabi_memclr.c b/newlib/libc/machine/arm/aeabi_memclr.c
index 6da9135..c343dd7 100644
--- a/newlib/libc/machine/arm/aeabi_memclr.c
+++ b/newlib/libc/machine/arm/aeabi_memclr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2015 ARM Ltd
  * All rights reserved.
@@ -42,4 +43,5 @@ void __aeabi_memclr (void *dest, size_t n)
 {
   extern void __aeabi_memset (void *dest, size_t n, int c);
   __aeabi_memset (dest, n, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/arm/aeabi_memcpy.c b/newlib/libc/machine/arm/aeabi_memcpy.c
index 9837c35..c31fe69 100644
--- a/newlib/libc/machine/arm/aeabi_memcpy.c
+++ b/newlib/libc/machine/arm/aeabi_memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 ARM Ltd
  * All rights reserved.
@@ -60,5 +61,6 @@ void __aeabi_memcpy (void *dest, const void *source, size_t n)
 {
   extern void memcpy (void *dest, const void *source, size_t n);
   memcpy (dest, source, n);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/machine/arm/aeabi_memmove.c b/newlib/libc/machine/arm/aeabi_memmove.c
index 1e2bbaf..27c3fec 100644
--- a/newlib/libc/machine/arm/aeabi_memmove.c
+++ b/newlib/libc/machine/arm/aeabi_memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2015 ARM Ltd
  * All rights reserved.
@@ -59,5 +60,6 @@ void __aeabi_memmove (void *dest, const void *source, size_t n)
 {
   extern void memmove (void *dest, const void *source, size_t n);
   memmove (dest, source, n);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/machine/arm/aeabi_memset.c b/newlib/libc/machine/arm/aeabi_memset.c
index 8a97320..8d94566 100644
--- a/newlib/libc/machine/arm/aeabi_memset.c
+++ b/newlib/libc/machine/arm/aeabi_memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2015 ARM Ltd
  * All rights reserved.
@@ -61,5 +62,6 @@ void __aeabi_memset (void *dest, size_t n, int c)
     of its second and third arguments reversed.  */
   extern void memset (void *dest, int c, size_t n);
   memset (dest, c, n);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/machine/arm/memchr-stub.c b/newlib/libc/machine/arm/memchr-stub.c
index 5c7881b..487a49c 100644
--- a/newlib/libc/machine/arm/memchr-stub.c
+++ b/newlib/libc/machine/arm/memchr-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2015 ARM Ltd.
    All rights reserved.
 
diff --git a/newlib/libc/machine/arm/memcpy-stub.c b/newlib/libc/machine/arm/memcpy-stub.c
index 6cd0e3b..301dd6d 100644
--- a/newlib/libc/machine/arm/memcpy-stub.c
+++ b/newlib/libc/machine/arm/memcpy-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2015 ARM Ltd.
    All rights reserved.
 
diff --git a/newlib/libc/machine/arm/strcpy.c b/newlib/libc/machine/arm/strcpy.c
index 111528e..cbfc5fa 100644
--- a/newlib/libc/machine/arm/strcpy.c
+++ b/newlib/libc/machine/arm/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2008 ARM Ltd
  * All rights reserved.
@@ -171,4 +172,5 @@ strcpy (char* dst, const char* src)
        "bx	lr\n\t"
 #endif
        );
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/arm/strlen-stub.c b/newlib/libc/machine/arm/strlen-stub.c
index fc2daf1..58bab27 100644
--- a/newlib/libc/machine/arm/strlen-stub.c
+++ b/newlib/libc/machine/arm/strlen-stub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2008-2015 ARM Ltd
  * All rights reserved.
@@ -169,6 +170,7 @@ strlen (const char* str)
 # endif
 #endif
        "bx	lr\n\t");
+  __A_VARIABLE = 1;
 }
 #endif
 #endif
diff --git a/newlib/libc/machine/cr16/getenv.c b/newlib/libc/machine/cr16/getenv.c
index 75ef1cc..f9a1bf6 100644
--- a/newlib/libc/machine/cr16/getenv.c
+++ b/newlib/libc/machine/cr16/getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getenv.c -- Implementation of the getenv() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -19,6 +20,7 @@ char * getenv (const char *name)
 {
   char *_getenv(const char *);
 
+  __A_VARIABLE = 1;
   return (_getenv (name));
 }
 
diff --git a/newlib/libc/machine/cris/libcdtor.c b/newlib/libc/machine/cris/libcdtor.c
index 3273477..8a12602 100644
--- a/newlib/libc/machine/cris/libcdtor.c
+++ b/newlib/libc/machine/cris/libcdtor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Call ctors and dtors from elinux a.out shared libraries.
    Copyright (C) 1999, 2000, 2003, 2004, 2005 Axis Communications.
    All rights reserved.
@@ -76,6 +77,7 @@ _Libctors (void)
 
       (**ctors)();
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -88,4 +90,5 @@ _Libdtors(void)
       {
 	(**dtors++) ();
       }
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/cris/memcpy.c b/newlib/libc/machine/cris/memcpy.c
index c7a1af9..dbdae19 100644
--- a/newlib/libc/machine/cris/memcpy.c
+++ b/newlib/libc/machine/cris/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A memcpy for CRIS.
    Copyright (C) 1994-2005 Axis Communications.
    All rights reserved.
@@ -232,5 +233,6 @@ memcpy(void *__restrict pdst, const void *__restrict psrc, size_t pn)
       break;
     }
 
+  __A_VARIABLE = 1;
   return return_dst;
 }
diff --git a/newlib/libc/machine/cris/memmove.c b/newlib/libc/machine/cris/memmove.c
index b022eaa..bb74324 100644
--- a/newlib/libc/machine/cris/memmove.c
+++ b/newlib/libc/machine/cris/memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A memmove for CRIS.
    Copyright (C) 2000-2005 Axis Communications.
    All rights reserved.
@@ -69,6 +70,7 @@ memmove(void *pdst, const void *psrc, size_t pn)
 	  *--dst = *--src;
 	}
 
+      __A_VARIABLE = 1;
       return return_dst;
     }
   /* Whew, no overlap.  Proceed as with memcpy.  We could call it instead
@@ -253,5 +255,6 @@ memmove(void *pdst, const void *psrc, size_t pn)
       break;
     }
 
+  __A_VARIABLE = 1;
   return return_dst;
 }
diff --git a/newlib/libc/machine/cris/memset.c b/newlib/libc/machine/cris/memset.c
index c94ea9b..807f5fb 100644
--- a/newlib/libc/machine/cris/memset.c
+++ b/newlib/libc/machine/cris/memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A memset for CRIS.
    Copyright (C) 1999-2005 Axis Communications.
    All rights reserved.
@@ -255,5 +256,6 @@ void *memset(void *pdst, int c, unsigned int plen)
       }
   }
 
+  __A_VARIABLE = 1;
   return return_dst;
 }
diff --git a/newlib/libc/machine/cris/setjmp.c b/newlib/libc/machine/cris/setjmp.c
index ca54494..cd05701 100644
--- a/newlib/libc/machine/cris/setjmp.c
+++ b/newlib/libc/machine/cris/setjmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A setjmp.c for CRIS
    Copyright (C) 1993-2005 Axis Communications.
    All rights reserved.
@@ -143,6 +144,7 @@ setjmp (jmp_buf buf)
      : "r9");
 #endif /* not PIC */
 #endif /* not __arch_common_v10_v32 or __arch_v32 */
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -209,4 +211,5 @@ longjmp(jmp_buf buf, int val)
      : "r" (buf), "r" (val)
      : "memory");
 #endif /* not __arch_common_v10_v32 or __arch_v32 */
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/crx/getenv.c b/newlib/libc/machine/crx/getenv.c
index 75ef1cc..f9a1bf6 100644
--- a/newlib/libc/machine/crx/getenv.c
+++ b/newlib/libc/machine/crx/getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getenv.c -- Implementation of the getenv() routine
  *
  * Copyright (c) 2004 National Semiconductor Corporation
@@ -19,6 +20,7 @@ char * getenv (const char *name)
 {
   char *_getenv(const char *);
 
+  __A_VARIABLE = 1;
   return (_getenv (name));
 }
 
diff --git a/newlib/libc/machine/h8500/cmpsi.c b/newlib/libc/machine/h8500/cmpsi.c
index 3357343..d3a443c 100644
--- a/newlib/libc/machine/h8500/cmpsi.c
+++ b/newlib/libc/machine/h8500/cmpsi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 union u 
 {
@@ -28,14 +29,23 @@ __cmpsi2(long arga,
 
   if (u.w.msw != msw_b)
     {
-      if (u.w.msw < msw_b) return 0;
+      if (u.w.msw < msw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
   if (u.w.lsw != lsw_b) 
     {
-      if (u.w.lsw < lsw_b) return 0;
+      if (u.w.lsw < lsw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -49,14 +59,23 @@ __ucmpsi2(unsigned long arga,
 
   if (u.w.msw != msw_b)
     {
-      if (u.w.msw < msw_b) return 0;
+      if (u.w.msw < msw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
   if (u.w.lsw != lsw_b) 
     {
-      if (u.w.lsw < lsw_b) return 0;
+      if (u.w.lsw < lsw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -92,14 +111,23 @@ __cmppsi2(long arga, long argb)
 
   if (a.w.msb != b.w.msb)
     {
-      if (a.w.msb < b.w.msb) return 0;
+      if (a.w.msb < b.w.msb) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
   if (a.w.lsw != b.w.lsw)
     {
-      if (a.w.lsw < b.w.lsw) return 0;
+      if (a.w.lsw < b.w.lsw) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -114,13 +142,22 @@ __ucmppsi2(long arga, long argb)
 
   if (a.w.msb != b.w.msb)
     {
-      if (a.w.msb < b.w.msb) return 0;
+      if (a.w.msb < b.w.msb) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
   if (a.w.lsw != b.w.lsw)
     {
-      if (a.w.lsw < b.w.lsw) return 0;
+      if (a.w.lsw < b.w.lsw) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/machine/h8500/divsi3.c b/newlib/libc/machine/h8500/divsi3.c
index e19855d..b67d1c7 100644
--- a/newlib/libc/machine/h8500/divsi3.c
+++ b/newlib/libc/machine/h8500/divsi3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #define divnorm(num, den, sign) 		\
 {						\
@@ -43,7 +44,11 @@ divmodsi4(int modwanted, unsigned long num, unsigned long den)
       bit >>=1;					
       den >>=1;					
     }						
-  if (modwanted) return num;
+  if (modwanted) {
+      __A_VARIABLE = 1;
+      return num;
+  }
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -69,8 +74,11 @@ __modsi3 (long numerator, long denominator)
     }  
   
   modul =  divmodsi4 (1, numerator, denominator);
-  if (sign)
+  if (sign) {
+    __A_VARIABLE = 1;
     return - modul;
+  }
+  __A_VARIABLE = 1;
   return modul;
 }
 
@@ -85,6 +93,7 @@ __divsi3 (long numerator, long denominator)
 
   dividend = divmodsi4 (0,  numerator, denominator);
   exitdiv (sign, dividend);
+  __A_VARIABLE = 1;
 }
 
 long 
@@ -94,6 +103,7 @@ __umodsi3 (unsigned long numerator, unsigned long denominator)
   long modul;
 
 modul= divmodsi4 (1,  numerator, denominator);
+  __A_VARIABLE = 1;
   return modul;
 }
 
@@ -104,6 +114,7 @@ __udivsi3 (unsigned long numerator, unsigned long denominator)
   long dividend;
   long modul;
   dividend =   divmodsi4 (0, numerator, denominator);
+  __A_VARIABLE = 1;
   return dividend;
 }
 
@@ -129,6 +140,7 @@ main ()
 	    printf ("fail %d %d %d %d\n", i, j, k, m);
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/machine/h8500/mulhi3.c b/newlib/libc/machine/h8500/mulhi3.c
index 869e131..6c443e3 100644
--- a/newlib/libc/machine/h8500/mulhi3.c
+++ b/newlib/libc/machine/h8500/mulhi3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 short 
@@ -15,6 +16,7 @@ __mulhi3(short a, short b)
 	  b<<=1;
 	}
     }
+  __A_VARIABLE = 1;
   return r;
 }
 
diff --git a/newlib/libc/machine/h8500/mulsi3.c b/newlib/libc/machine/h8500/mulsi3.c
index a923e8d..98c9655 100644
--- a/newlib/libc/machine/h8500/mulsi3.c
+++ b/newlib/libc/machine/h8500/mulsi3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 typedef union {
   struct {
@@ -17,6 +18,7 @@ long __mulsi3(u a, u b)
   if (a.s.msw == 0 &&
       b.s.msw == 0)
     {
+      __A_VARIABLE = 1;
       return (long)a.s.lsw * b.s.lsw;
     }
 
@@ -41,10 +43,12 @@ long __mulsi3(u a, u b)
     {
       pp1 = -pp1;
     }
+  __A_VARIABLE = 1;
   return pp1;
 }
 long __mulpsi3(long a, long b)
 {
+ __A_VARIABLE = 1;
  return a*b;
 }
 
@@ -66,6 +70,7 @@ __mulhi3(short a, short b)
       a>>=1;
 
     }
+  __A_VARIABLE = 1;
   return r;
 }
 
diff --git a/newlib/libc/machine/h8500/negsi2.c b/newlib/libc/machine/h8500/negsi2.c
index c5b31b1..ae87525 100644
--- a/newlib/libc/machine/h8500/negsi2.c
+++ b/newlib/libc/machine/h8500/negsi2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 
 
 long
 __negsi2(long x)
 {
+  __A_VARIABLE = 1;
   return ~x+1;
 }
diff --git a/newlib/libc/machine/h8500/shifts.c b/newlib/libc/machine/h8500/shifts.c
index 5b81069..851a069 100644
--- a/newlib/libc/machine/h8500/shifts.c
+++ b/newlib/libc/machine/h8500/shifts.c
@@ -1,22 +1,27 @@
+static volatile int __A_VARIABLE;
 
 
 int __ashrhi3(int a,int b)
 {
+  __A_VARIABLE = 1;
   return a>>b;
 }
 
 int __ashlhi3(int a,int b)
 {
+  __A_VARIABLE = 1;
   return a<<b;
 }
 
 unsigned __lshlhi3(unsigned int a,int b)
 {
+  __A_VARIABLE = 1;
   return a<<b;
 }
 
 unsigned __lshrhi3(unsigned int a,int b)
 {
+  __A_VARIABLE = 1;
   return a>>b;
 }
 
@@ -25,21 +30,25 @@ unsigned __lshrhi3(unsigned int a,int b)
 
 long __ashrsi3(long a, int b)
 {
+  __A_VARIABLE = 1;
   return a>>b;
 }
 
 long __ashlsi3(long a,int b)
 {
+  __A_VARIABLE = 1;
   return a<<b;
 }
 
 unsigned __lshlsi3(unsigned long a,int b)
 {
+  __A_VARIABLE = 1;
   return a<<b;
 }
 
 unsigned __lshrsi3(unsigned long a,int b)
 {
+  __A_VARIABLE = 1;
   return a>>b;
 }
 
diff --git a/newlib/libc/machine/m68k/strcpy.c b/newlib/libc/machine/m68k/strcpy.c
index ccc9141..793bdf3 100644
--- a/newlib/libc/machine/m68k/strcpy.c
+++ b/newlib/libc/machine/m68k/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *  C library strcpy routine
  *
@@ -32,5 +33,6 @@ strcpy (char *to, const char *from)
 		"=a" (from), "=a" (pto), "=d" (n) :
 		 "0" (from),  "1" (pto), "2" (n) :
 		 "cc", "memory");
+	__A_VARIABLE = 1;
 	return to;
 }
diff --git a/newlib/libc/machine/m68k/strlen.c b/newlib/libc/machine/m68k/strlen.c
index 589a697..3872703 100644
--- a/newlib/libc/machine/m68k/strlen.c
+++ b/newlib/libc/machine/m68k/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *  C library strlen routine
  *
@@ -31,5 +32,6 @@ strlen (const char *str)
 		"=a" (cp), "=d" (n) :
 		 "0" (cp),  "1" (n) :
 		 "cc");
+	__A_VARIABLE = 1;
 	return (cp - str) - 1;
 }
diff --git a/newlib/libc/machine/microblaze/abort.c b/newlib/libc/machine/microblaze/abort.c
index b2c5a00..74f65a9 100644
--- a/newlib/libc/machine/microblaze/abort.c
+++ b/newlib/libc/machine/microblaze/abort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NetWare can not use this implementation of abort.  It provides its
    own version of abort in clib.nlm.  If we can not use clib.nlm, then
    we must write abort in sys/netware.  */
@@ -61,4 +62,5 @@ _DEFUN_VOID (abort)
     {
       exit(1);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/microblaze/strcmp.c b/newlib/libc/machine/microblaze/strcmp.c
index 2f03374..00bbb27 100644
--- a/newlib/libc/machine/microblaze/strcmp.c
+++ b/newlib/libc/machine/microblaze/strcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009 Xilinx, Inc.  All rights reserved. 
 
    Redistribution and use in source and binary forms, with or without
@@ -101,6 +102,7 @@ _DEFUN (strcmp, (s1, s2),
       s2++;
     }
 
+  __A_VARIABLE = 1;
   return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 #else
   unsigned long *a1;
diff --git a/newlib/libc/machine/microblaze/strcpy.c b/newlib/libc/machine/microblaze/strcpy.c
index 0819ee5..c98e5e0 100644
--- a/newlib/libc/machine/microblaze/strcpy.c
+++ b/newlib/libc/machine/microblaze/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009 Xilinx, Inc.  All rights reserved. 
 
    Redistribution and use in source and binary forms, with or without
@@ -100,6 +101,7 @@ _DEFUN (strcpy, (dst0, src0),
   while (*dst0++ = *src0++)
     ;
 
+  __A_VARIABLE = 1;
   return s;
 #else
   char *dst = dst0;
diff --git a/newlib/libc/machine/microblaze/strlen.c b/newlib/libc/machine/microblaze/strlen.c
index 51387cd..7c216a1 100644
--- a/newlib/libc/machine/microblaze/strlen.c
+++ b/newlib/libc/machine/microblaze/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2009 Xilinx, Inc.  All rights reserved. 
 
    Redistribution and use in source and binary forms, with or without
@@ -95,6 +96,7 @@ _DEFUN (strlen, (str),
   while (*str)
     str++;
 
+  __A_VARIABLE = 1;
   return str - start;
 #else
   _CONST char *start = str;
diff --git a/newlib/libc/machine/mips/strlen.c b/newlib/libc/machine/mips/strlen.c
index a87bddd..e23001a 100644
--- a/newlib/libc/machine/mips/strlen.c
+++ b/newlib/libc/machine/mips/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * strlen.c -- strlen function.  On at least some MIPS chips, a simple
  * strlen is faster than the 'optimized' C version.
@@ -29,6 +30,7 @@ strlen (const char *str)
   while (*str++ != '\0')
     ;
 
+  __A_VARIABLE = 1;
   return str - start - 1;
 }
 #elif defined(__mips64)
diff --git a/newlib/libc/machine/mips/strncpy.c b/newlib/libc/machine/mips/strncpy.c
index 47413cb..498cb0a 100644
--- a/newlib/libc/machine/mips/strncpy.c
+++ b/newlib/libc/machine/mips/strncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * strncpy.S -- strncmp function.  On at least some MIPS chips, you get better
  * code by hand unrolling the loops, and by using store words to zero the
@@ -66,6 +67,7 @@ strncpy (char *dst0, const char *src0, size_t count)
 	}
     }
 
+  __A_VARIABLE = 1;
   return dst0;
 
 #else
diff --git a/newlib/libc/machine/nds32/abort.c b/newlib/libc/machine/nds32/abort.c
index 724562a..c38a29a 100644
--- a/newlib/libc/machine/nds32/abort.c
+++ b/newlib/libc/machine/nds32/abort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<abort>>---abnormal termination of a program
@@ -39,4 +40,5 @@ _DEFUN_VOID (abort)
     {
       _exit (1);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/powerpc/atosfix16.c b/newlib/libc/machine/powerpc/atosfix16.c
index 501c0f1..c1d6c44 100644
--- a/newlib/libc/machine/powerpc/atosfix16.c
+++ b/newlib/libc/machine/powerpc/atosfix16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<atosfix16>>, <<atosfix32>>, <<atosfix64>>---string to signed fixed-point
@@ -89,6 +90,7 @@ _DEFUN (_atosfix16_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtosfix16_r (reent, s, NULL);
 }
 
@@ -97,6 +99,7 @@ __int16_t
 _DEFUN (atosfix16, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtosfix16 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/atosfix32.c b/newlib/libc/machine/powerpc/atosfix32.c
index dbcac7e..13bf69d 100644
--- a/newlib/libc/machine/powerpc/atosfix32.c
+++ b/newlib/libc/machine/powerpc/atosfix32.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Jeff Johnston - 02/13/2002
  */
@@ -12,6 +13,7 @@ _DEFUN (_atosfix32_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtosfix32_r (reent, s, NULL);
 }
 
@@ -20,6 +22,7 @@ __int32_t
 _DEFUN (atosfix32, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtosfix32 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/atosfix64.c b/newlib/libc/machine/powerpc/atosfix64.c
index 109baf7..ea913e1 100644
--- a/newlib/libc/machine/powerpc/atosfix64.c
+++ b/newlib/libc/machine/powerpc/atosfix64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Jeff Johnston - 02/13/2002
  */
@@ -12,6 +13,7 @@ _DEFUN (_atosfix64_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtosfix64_r (reent, s, NULL);
 }
 
@@ -20,6 +22,7 @@ __int64_t
 _DEFUN (atosfix64, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtosfix64 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/atoufix16.c b/newlib/libc/machine/powerpc/atoufix16.c
index 53db137..a41a57c 100644
--- a/newlib/libc/machine/powerpc/atoufix16.c
+++ b/newlib/libc/machine/powerpc/atoufix16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<atoufix16>>, <<atoufix32>>, <<atoufix64>>---string to unsigned fixed-point
@@ -89,6 +90,7 @@ _DEFUN (_atoufix16_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtoufix16_r (reent, s, NULL);
 }
 
@@ -97,6 +99,7 @@ __uint16_t
 _DEFUN (atoufix16, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtoufix16 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/atoufix32.c b/newlib/libc/machine/powerpc/atoufix32.c
index ee29ac5..7634910 100644
--- a/newlib/libc/machine/powerpc/atoufix32.c
+++ b/newlib/libc/machine/powerpc/atoufix32.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Jeff Johnston - 02/13/2002
  */
@@ -12,6 +13,7 @@ _DEFUN (_atoufix32_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtoufix32_r (reent, s, NULL);
 }
 
@@ -20,6 +22,7 @@ __uint32_t
 _DEFUN (atoufix32, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtoufix32 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/atoufix64.c b/newlib/libc/machine/powerpc/atoufix64.c
index e5eefc4..b576f98 100644
--- a/newlib/libc/machine/powerpc/atoufix64.c
+++ b/newlib/libc/machine/powerpc/atoufix64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Jeff Johnston - 02/13/2002
  */
@@ -12,6 +13,7 @@ _DEFUN (_atoufix64_r, (reent, s),
 	struct _reent *reent _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtoufix64_r (reent, s, NULL);
 }
 
@@ -20,6 +22,7 @@ __uint64_t
 _DEFUN (atoufix64, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtoufix64 (s, NULL);
 }
 
diff --git a/newlib/libc/machine/powerpc/simdldtoa.c b/newlib/libc/machine/powerpc/simdldtoa.c
index 9a90e64..a41f3d4 100644
--- a/newlib/libc/machine/powerpc/simdldtoa.c
+++ b/newlib/libc/machine/powerpc/simdldtoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
  /* Extended precision arithmetic functions for long double I/O.
   * This program has been placed in the public domain.
@@ -432,6 +433,7 @@ register int i;
 
 for( i=0; i<NE; i++ )
 	*x++ = 0;
+__A_VARIABLE = 1;
 }
 
 
@@ -447,6 +449,7 @@ register int i;
 
 for( i=0; i<NE; i++ )
 	*b++ = *a++;
+__A_VARIABLE = 1;
 }
 
 
@@ -569,6 +572,7 @@ if( ldp->rndprc < NBITS )
 		}
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 /* Move in external format number,
@@ -663,6 +667,7 @@ register int i;
 
 for( i=0; i<NI; i++ )
 	*xi++ = 0;
+__A_VARIABLE = 1;
 }
 
 /* same, but don't touch the sign. */
@@ -674,6 +679,7 @@ register int i;
 ++xi;
 for(i=0; i<NI-1; i++)
 	*xi++ = 0;
+__A_VARIABLE = 1;
 }
 
 
@@ -689,6 +695,7 @@ for( i=0; i<NI-1; i++ )
 	*b++ = *a++;
 /* clear low guard word */
 *b = 0;
+__A_VARIABLE = 1;
 }
 
 /* Return nonzero if internal format number is a NaN.
@@ -702,10 +709,13 @@ if( (x[E] & 0x7fff) == 0x7fff )
 	{
 	for( i=M+1; i<NI; i++ )
 		{
-		if( x[i] != 0 )
+		if( x[i] != 0 ) {
+			__A_VARIABLE = 1;
 			return(1);
 		}
+		}
 	}
+__A_VARIABLE = 1;
 return(0);
 }
 
@@ -987,6 +997,7 @@ for( i=M+1; i<NI; i++ )
 	}
 for( i=M; i<NI; i++ )
 	c[i] = p[i];
+__A_VARIABLE = 1;
 }
 
 
@@ -1078,6 +1089,7 @@ if( j )
 for( i=0; i<NI; i++ )
 	num[i] = equot[i];
 
+__A_VARIABLE = 1;
 return( (int )j );
 }
 
@@ -1119,6 +1131,7 @@ for( i=0; i<NI; i++ )
 	b[i] = equot[i];
 
 /* return flag for lost nonzero bits */
+__A_VARIABLE = 1;
 return( (int)j );
 }
 
@@ -2076,12 +2089,14 @@ static void etoe53( x, e )
 unsigned short *x, *e;
 {
 etodec( x, e ); /* see etodec.c */
+__A_VARIABLE = 1;
 }
 
 static void toe53( x, y )
 unsigned short *x, *y;
 {
 todec( x, y );
+__A_VARIABLE = 1;
 }
 
 #else
@@ -2833,6 +2848,7 @@ if( mode == 3 && ((ndigits + ldp->outexpon) < 0))
 
 if( rve )
         *rve = s;
+__A_VARIABLE = 1;
 return outstr;
 }
 
@@ -3181,6 +3197,7 @@ else
 bxit:
 ldp->rndprc = rndsav;
 ldp->outexpon =  expon;
+__A_VARIABLE = 1;
 }
 
 
@@ -3217,6 +3234,7 @@ void _simdstrtold (char *s, char **se, LONG_DOUBLE_UNION *x)
   lenldstr = asctoeg( s, (unsigned short *)x, SIMD_LDBL_MANT_DIG, ldp );
   if (se)
     *se = s + lenldstr;
+  __A_VARIABLE = 1;
 }
 
 #define REASONABLE_LEN 200
@@ -3542,6 +3560,7 @@ switch( oprec )
 lenldstr += s - lstr;
 if (mflag)
   free (lstr);
+__A_VARIABLE = 1;
 return lenldstr;
 }
 
@@ -3649,6 +3668,7 @@ while( ln >= ld )
 	ln -= 1;
 	}
 emdnorm( num, 0, 0, ln, 0, ldp );
+__A_VARIABLE = 1;
 }
 
 /* NaN bit patterns
diff --git a/newlib/libc/machine/powerpc/strtosfix16.c b/newlib/libc/machine/powerpc/strtosfix16.c
index d3cfe07..f7eb6f4 100644
--- a/newlib/libc/machine/powerpc/strtosfix16.c
+++ b/newlib/libc/machine/powerpc/strtosfix16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<strtosfix16>>, <<strtosfix32>>, <<strtosfix64>>---string to signed fixed point
@@ -202,6 +203,7 @@ _DEFUN (strtosfix16, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtosfix16_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/strtosfix32.c b/newlib/libc/machine/powerpc/strtosfix32.c
index 2e22c14..42388f6 100644
--- a/newlib/libc/machine/powerpc/strtosfix32.c
+++ b/newlib/libc/machine/powerpc/strtosfix32.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef __SPE__
 
 #include <_ansi.h>
@@ -96,6 +97,7 @@ _DEFUN (strtosfix32, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtosfix32_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/strtosfix64.c b/newlib/libc/machine/powerpc/strtosfix64.c
index 3006632..bfc8856 100644
--- a/newlib/libc/machine/powerpc/strtosfix64.c
+++ b/newlib/libc/machine/powerpc/strtosfix64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef __SPE__
 
 #include <_ansi.h>
@@ -109,6 +110,7 @@ _DEFUN (strtosfix64, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtosfix64_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/strtoufix16.c b/newlib/libc/machine/powerpc/strtoufix16.c
index d90255c..debfffd 100644
--- a/newlib/libc/machine/powerpc/strtoufix16.c
+++ b/newlib/libc/machine/powerpc/strtoufix16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<strtoufix16>>, <<strtoufix32>>, <<strtoufix64>>---string to signed fixed point
@@ -193,6 +194,7 @@ _DEFUN (strtoufix16, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtoufix16_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/strtoufix32.c b/newlib/libc/machine/powerpc/strtoufix32.c
index 6a8e081..31bd869 100644
--- a/newlib/libc/machine/powerpc/strtoufix32.c
+++ b/newlib/libc/machine/powerpc/strtoufix32.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef __SPE__ 
 
 #include <_ansi.h>
@@ -93,6 +94,7 @@ _DEFUN (strtoufix32, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtoufix32_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/strtoufix64.c b/newlib/libc/machine/powerpc/strtoufix64.c
index 539f953..80ec0e6 100644
--- a/newlib/libc/machine/powerpc/strtoufix64.c
+++ b/newlib/libc/machine/powerpc/strtoufix64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef __SPE__
 
 #include <_ansi.h>
@@ -108,6 +109,7 @@ _DEFUN (strtoufix64, (s, ptr, base),
 	_CONST char *s _AND
 	char **ptr)
 {
+  __A_VARIABLE = 1;
   return _strtoufix64_r (_REENT, s, ptr);
 }
 
diff --git a/newlib/libc/machine/powerpc/ufix64toa.c b/newlib/libc/machine/powerpc/ufix64toa.c
index 450e0a3..3b83a11 100644
--- a/newlib/libc/machine/powerpc/ufix64toa.c
+++ b/newlib/libc/machine/powerpc/ufix64toa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _ufix64toa_r: convert unsigned 64-bit fixed point to ASCII string.
  *
  * This routine converts an unsigned fixed-point number to long double format and
@@ -85,6 +86,7 @@ _DEFUN (_ufix64toa_r, (rptr, value, mode, ndigits, decpt, sign, rve),
     }
 
   /* convert long double to character */
+  __A_VARIABLE = 1;
   return _simdldtoa_r (rptr, &ldbl, mode, ndigits, decpt, sign, rve);
 }
 
diff --git a/newlib/libc/machine/powerpc/vec_calloc.c b/newlib/libc/machine/powerpc/vec_calloc.c
index 5efe910..6cf0fb8 100644
--- a/newlib/libc/machine/powerpc/vec_calloc.c
+++ b/newlib/libc/machine/powerpc/vec_calloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<vec_calloc>>---allocate space for arrays
@@ -60,6 +61,7 @@ _DEFUN (vec_calloc, (n, size),
 	size_t n _AND
 	size_t size)
 {
+  __A_VARIABLE = 1;
   return _vec_calloc_r (_REENT, n, size);
 }
 
diff --git a/newlib/libc/machine/powerpc/vec_free.c b/newlib/libc/machine/powerpc/vec_free.c
index b55c52d..912e2c1 100644
--- a/newlib/libc/machine/powerpc/vec_free.c
+++ b/newlib/libc/machine/powerpc/vec_free.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* vec_free.c - a wrapper for _free_r */
 #include <_ansi.h>
 #include <reent.h>
@@ -10,6 +11,7 @@ _DEFUN (vec_free, (aptr),
         _PTR aptr)
 {
   _free_r (_REENT, aptr);
+  __A_VARIABLE = 1;
 }
 
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/machine/powerpc/vec_malloc.c b/newlib/libc/machine/powerpc/vec_malloc.c
index 6bcad59..42c550d 100644
--- a/newlib/libc/machine/powerpc/vec_malloc.c
+++ b/newlib/libc/machine/powerpc/vec_malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<vec_malloc>>, <<vec_realloc>>, <<vec_free>>---manage vector memory
@@ -125,6 +126,7 @@ _PTR
 _DEFUN (vec_malloc, (nbytes),
 	size_t nbytes)		/* get a block */
 {
+  __A_VARIABLE = 1;
   return _memalign_r (_REENT, 16, nbytes);
 }
 
diff --git a/newlib/libc/machine/powerpc/vec_mallocr.c b/newlib/libc/machine/powerpc/vec_mallocr.c
index c375c8b..b2652fb 100644
--- a/newlib/libc/machine/powerpc/vec_mallocr.c
+++ b/newlib/libc/machine/powerpc/vec_mallocr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This code is based on mallocr.c written by Doug Lea which is released
    to the public domain.  Any changes to libc/stdlib/mallocr.c
    should be reflected here as well.    */
@@ -335,12 +336,16 @@ Void_t* vECREALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
   INTERNAL_SIZE_T  remainder_size;   /* its size */
 
 #ifdef REALLOC_ZERO_BYTES_FREES
-  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
+  if (bytes == 0) { fREe(RCALL oldmem); __A_VARIABLE = 1;
+    return 0; }
 #endif
 
 
   /* realloc of null is supposed to be same as malloc */
-  if (oldmem == 0) return mEMALIGn(RCALL 16, bytes);
+  if (oldmem == 0) {
+    __A_VARIABLE = 1;
+    return mEMALIGn(RCALL 16, bytes);
+  }
 
   MALLOC_LOCK;
 
@@ -358,6 +363,7 @@ Void_t* vECREALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
     if (newmem == 0)  /* propagate failure */
     {
       MALLOC_UNLOCK;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -365,6 +371,7 @@ Void_t* vECREALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
     MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
     fREe(RCALL oldmem);
     MALLOC_UNLOCK;
+    __A_VARIABLE = 1;
     return newmem;
   }
 
@@ -385,6 +392,7 @@ Void_t* vECREALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
   }
 
   MALLOC_UNLOCK;
+  __A_VARIABLE = 1;
   return chunk2mem(newp);
 }
 
@@ -413,10 +421,12 @@ Void_t* vECCALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
 
   if (mem == 0) 
   {
+    __A_VARIABLE = 1;
     return 0;
   }
 
   MALLOC_ZERO(mem, sz);
+  __A_VARIABLE = 1;
   return mem;
 }
 
diff --git a/newlib/libc/machine/powerpc/vec_realloc.c b/newlib/libc/machine/powerpc/vec_realloc.c
index e192e39..63e54f1 100644
--- a/newlib/libc/machine/powerpc/vec_realloc.c
+++ b/newlib/libc/machine/powerpc/vec_realloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* vec_realloc.c -- a wrapper for _vec_realloc_r.  */
 
 #include <_ansi.h>
@@ -11,6 +12,7 @@ _DEFUN (vec_realloc, (ap, nbytes),
 	_PTR ap _AND
 	size_t nbytes)
 {
+  __A_VARIABLE = 1;
   return _vec_realloc_r (_REENT, ap, nbytes);
 }
 
diff --git a/newlib/libc/machine/powerpc/vfprintf.c b/newlib/libc/machine/powerpc/vfprintf.c
index d264e26..e291550 100644
--- a/newlib/libc/machine/powerpc/vfprintf.c
+++ b/newlib/libc/machine/powerpc/vfprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<vprintf>>, <<vfprintf>>, <<vsprintf>>---format argument list
@@ -216,11 +217,13 @@ __sprint_r(rptr, fp, uio)
 
 	if (uio->uio_resid == 0) {
 		uio->uio_iovcnt = 0;
+		__A_VARIABLE = 1;
 		return (0);
 	}
 	err = __sfvwrite_r(rptr, fp, uio);
 	uio->uio_resid = 0;
 	uio->uio_iovcnt = 0;
+	__A_VARIABLE = 1;
 	return (err);
 }
 
@@ -257,6 +260,7 @@ __sbprintf_r(rptr, fp, fmt, ap)
 		ret = EOF;
 	if (fake._flags & __SERR)
 		fp->_flags |= __SERR;
+	__A_VARIABLE = 1;
 	return (ret);
 }
 
@@ -324,6 +328,7 @@ _DEFUN (VFPRINTF, (fp, fmt0, ap),
 	va_list ap)
 {
   CHECK_INIT (_REENT, fp);
+  __A_VARIABLE = 1;
   return _VFPRINTF_R (_REENT, fp, fmt0, ap);
 }
 
@@ -1369,6 +1374,7 @@ cvt(data, value, ndigits, flags, sign, decpt, ch, length)
 			*rve++ = '0';
 	}
 	*length = rve - digits;
+	__A_VARIABLE = 1;
 	return (digits);
 }
 
@@ -1400,6 +1406,7 @@ exponent(p0, exp, fmtch)
 		*p++ = '0';
 		*p++ = to_char(exp);
 	}
+	__A_VARIABLE = 1;
 	return (p - p0);
 }
 #endif /* FLOATING_POINT */
@@ -1429,6 +1436,7 @@ cvt_ufix64 (data, value, ndigits, decpt, length)
 	while (rve < bp)
 	  *rve++ = '0';
 	*length = rve - digits;
+	__A_VARIABLE = 1;
 	return (digits);
 }
 #endif /* __SPE__ */
diff --git a/newlib/libc/machine/powerpc/vfscanf.c b/newlib/libc/machine/powerpc/vfscanf.c
index 1520cea..c019338 100644
--- a/newlib/libc/machine/powerpc/vfscanf.c
+++ b/newlib/libc/machine/powerpc/vfscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<vscanf>>, <<vfscanf>>, <<vsscanf>>---format argument list
@@ -222,6 +223,7 @@ _DEFUN (vfscanf, (fp, fmt, ap),
     va_list ap)
 {
   CHECK_INIT(_REENT, fp);
+  __A_VARIABLE = 1;
   return __svfscanf_r (_REENT, fp, fmt, ap);
 }
 
@@ -231,6 +233,7 @@ __svfscanf (fp, fmt0, ap)
      char _CONST *fmt0;
      va_list ap;
 {
+  __A_VARIABLE = 1;
   return __svfscanf_r (_REENT, fp, fmt0, ap);
 }
 
@@ -243,6 +246,7 @@ _DEFUN (_vfscanf_r, (data, fp, fmt, ap),
     _CONST char *__restrict fmt _AND 
     va_list ap)
 {
+  __A_VARIABLE = 1;
   return __svfscanf_r (data, fp, fmt, ap);
 }
 
diff --git a/newlib/libc/machine/riscv/ffs.c b/newlib/libc/machine/riscv/ffs.c
index 2f2176e..fa7be27 100644
--- a/newlib/libc/machine/riscv/ffs.c
+++ b/newlib/libc/machine/riscv/ffs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
diff --git a/newlib/libc/machine/riscv/ieeefp.c b/newlib/libc/machine/riscv/ieeefp.c
index 9094cc6..8d32e36 100644
--- a/newlib/libc/machine/riscv/ieeefp.c
+++ b/newlib/libc/machine/riscv/ieeefp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
@@ -16,6 +17,7 @@ static void
 fssr(unsigned value)
 {
   asm volatile ("fssr %0" :: "r"(value));
+  __A_VARIABLE = 1;
 }
 
 static unsigned
@@ -23,6 +25,7 @@ frsr()
 {
   unsigned value;
   asm volatile ("frsr %0" : "=r" (value));
+  __A_VARIABLE = 1;
   return value;
 }
 
@@ -31,12 +34,17 @@ frm_fp_rnd (unsigned frm)
 {
   switch (frm)
     {
-    case 0: return FP_RN;
-    case 1: return FP_RZ;
-    case 2: return FP_RM;
-    case 3: return FP_RP;
+    case 0: __A_VARIABLE = 1;
+      return FP_RN;
+    case 1: __A_VARIABLE = 1;
+      return FP_RZ;
+    case 2: __A_VARIABLE = 1;
+      return FP_RM;
+    case 3: __A_VARIABLE = 1;
+      return FP_RP;
     /* 4 ~ 7 is invalid value, so just retun FP_RP.  */
-    default:return FP_RP;
+    default:__A_VARIABLE = 1;
+      return FP_RP;
     }
 }
 
@@ -45,6 +53,7 @@ frm_fp_rnd (unsigned frm)
 fp_except
 fpgetmask(void)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -72,6 +81,7 @@ fpgetsticky(void)
 fp_except
 fpsetmask(fp_except mask)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/newlib/libc/machine/riscv/memcpy.c b/newlib/libc/machine/riscv/memcpy.c
index c717f9f..83da52a 100644
--- a/newlib/libc/machine/riscv/memcpy.c
+++ b/newlib/libc/machine/riscv/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
@@ -34,6 +35,7 @@ small:
       if (__builtin_expect (a < end, 1))
 	while (a < end)
 	  BODY (a, b, char);
+      __A_VARIABLE = 1;
       return aa;
     }
 
@@ -77,5 +79,6 @@ small:
   b = (const char *)lb;
   if (unlikely (a < end))
     goto small;
+  __A_VARIABLE = 1;
   return aa;
 }
diff --git a/newlib/libc/machine/riscv/strcpy.c b/newlib/libc/machine/riscv/strcpy.c
index 6d802fa..2464e09 100644
--- a/newlib/libc/machine/riscv/strcpy.c
+++ b/newlib/libc/machine/riscv/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
diff --git a/newlib/libc/machine/riscv/strlen.c b/newlib/libc/machine/riscv/strlen.c
index 3b04066..58bb094 100644
--- a/newlib/libc/machine/riscv/strlen.c
+++ b/newlib/libc/machine/riscv/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2017  SiFive Inc. All rights reserved.
 
    This copyrighted material is made available to anyone wishing to use,
diff --git a/newlib/libc/machine/sparc/scan.c b/newlib/libc/machine/sparc/scan.c
index d76c0b9..aa0c209 100644
--- a/newlib/libc/machine/sparc/scan.c
+++ b/newlib/libc/machine/sparc/scan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Cover function to sparclet `scan' instruction.
 
    This file is in the public domain.  */
@@ -9,6 +10,7 @@ scan (int a, int b)
 {
   int res;
   __asm__ ("scan %1,%2,%0" : "=r" (res) : "r" (a), "r" (b));
+  __A_VARIABLE = 1;
   return res;
 }
 
diff --git a/newlib/libc/machine/sparc/shuffle.c b/newlib/libc/machine/sparc/shuffle.c
index 2c2ec1c..552ff35 100644
--- a/newlib/libc/machine/sparc/shuffle.c
+++ b/newlib/libc/machine/sparc/shuffle.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Cover function to sparclet `shuffle' instruction.
 
    This file is in the public domain.  */
@@ -9,6 +10,7 @@ shuffle (int a, int b)
 {
   int res;
   __asm__ ("shuffle %1,%2,%0" : "=r" (res) : "r" (a), "r" (b));
+  __A_VARIABLE = 1;
   return res;
 }
 
diff --git a/newlib/libc/machine/spu/assert.c b/newlib/libc/machine/spu/assert.c
index f1dd330..64a831b 100644
--- a/newlib/libc/machine/spu/assert.c
+++ b/newlib/libc/machine/spu/assert.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -28,6 +29,7 @@ _DEFUN (__assert_func, (file, line, func, failedexpr),
    */
   exit(6);
   /* NOTREACHED */
+  __A_VARIABLE = 1;
 }
 
 void
@@ -38,4 +40,5 @@ _DEFUN (__assert, (file, line, failedexpr),
 {
    __assert_func (file, line, NULL, failedexpr);
   /* NOTREACHED */
+   __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/calloc_ea.c b/newlib/libc/machine/spu/calloc_ea.c
index 019bf4b..193cdc6 100644
--- a/newlib/libc/machine/spu/calloc_ea.c
+++ b/newlib/libc/machine/spu/calloc_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -52,5 +53,6 @@ calloc_ea (size_ea_t nmemb, size_ea_t length)
   args.nmemb = (unsigned long long) nmemb;
   args.length = (unsigned long long) length;
   __send_to_ppe (JSRE_LIBEA_SIGNALCODE, SPE_LIBEA_CALLOC, &args);
+  __A_VARIABLE = 1;
   return ull_to_eavoid (args.nmemb);
 }
diff --git a/newlib/libc/machine/spu/clearerr.c b/newlib/libc/machine/spu/clearerr.c
index b4034f8..2fa29f4 100644
--- a/newlib/libc/machine/spu/clearerr.c
+++ b/newlib/libc/machine/spu/clearerr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -49,6 +50,7 @@ _DEFUN (clearerr, (fp),
 
   __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_CLEARERR, &ret);
 
+  __A_VARIABLE = 1;
   return;
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/creat.c b/newlib/libc/machine/spu/creat.c
index 3cd7143..e244442 100644
--- a/newlib/libc/machine/spu/creat.c
+++ b/newlib/libc/machine/spu/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* creat() "system call" */
 
 /* copied from libc/posix/creat.c */
@@ -11,5 +12,6 @@ _DEFUN(creat, (path, mode),
        const char *path _AND
        mode_t mode)
 {
+  __A_VARIABLE = 1;
   return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
 }
diff --git a/newlib/libc/machine/spu/fclose.c b/newlib/libc/machine/spu/fclose.c
index 4e1b825..cea4b35 100644
--- a/newlib/libc/machine/spu/fclose.c
+++ b/newlib/libc/machine/spu/fclose.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -50,6 +51,7 @@ _DEFUN (fclose, (fp),
 
   __sfp_free(fp);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fdopen.c b/newlib/libc/machine/spu/fdopen.c
index a795db8..37843b6 100644
--- a/newlib/libc/machine/spu/fdopen.c
+++ b/newlib/libc/machine/spu/fdopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -39,6 +40,7 @@ _DEFUN (fdopen, (fd, mode),
         _CONST char *mode)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/feof.c b/newlib/libc/machine/spu/feof.c
index 25e3a8f..fe9442f 100644
--- a/newlib/libc/machine/spu/feof.c
+++ b/newlib/libc/machine/spu/feof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -46,6 +47,7 @@ _DEFUN (feof, (fp),
 
   result = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FEOF, &result);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/ferror.c b/newlib/libc/machine/spu/ferror.c
index ac747ef..d85b3fc 100644
--- a/newlib/libc/machine/spu/ferror.c
+++ b/newlib/libc/machine/spu/ferror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -46,6 +47,7 @@ _DEFUN (ferror, (fp),
 
   result = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FERROR, &result);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fflush.c b/newlib/libc/machine/spu/fflush.c
index 7037f49..f8e0ccf 100644
--- a/newlib/libc/machine/spu/fflush.c
+++ b/newlib/libc/machine/spu/fflush.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -45,6 +46,7 @@ _DEFUN (fflush, (fp),
 
   result = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FFLUSH, &result);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fgetc.c b/newlib/libc/machine/spu/fgetc.c
index 8152032..27d7880 100644
--- a/newlib/libc/machine/spu/fgetc.c
+++ b/newlib/libc/machine/spu/fgetc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -46,6 +47,7 @@ _DEFUN (fgetc, (fp),
 
   result = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETC, &result);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fgetpos.c b/newlib/libc/machine/spu/fgetpos.c
index 694400e..b44e36a 100644
--- a/newlib/libc/machine/spu/fgetpos.c
+++ b/newlib/libc/machine/spu/fgetpos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -55,6 +56,7 @@ _DEFUN (fgetpos, (fp, pos),
   arg.fp = fp->_fp;
   arg.pos = pos;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETPOS, &arg);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fgets.c b/newlib/libc/machine/spu/fgets.c
index 2b0ca41..9d3a5e3 100644
--- a/newlib/libc/machine/spu/fgets.c
+++ b/newlib/libc/machine/spu/fgets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -59,6 +60,7 @@ _DEFUN (fgets, (buf, n, fp),
   args.n = n;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return (char*) __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETS, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fileno.c b/newlib/libc/machine/spu/fileno.c
index 867a6b8..bc74c2f 100644
--- a/newlib/libc/machine/spu/fileno.c
+++ b/newlib/libc/machine/spu/fileno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -47,6 +48,7 @@ _DEFUN (fileno, (fp),
 
   ret = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FILENO, &ret);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fopen.c b/newlib/libc/machine/spu/fopen.c
index 821d7c2..35e743f 100644
--- a/newlib/libc/machine/spu/fopen.c
+++ b/newlib/libc/machine/spu/fopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
diff --git a/newlib/libc/machine/spu/fputc.c b/newlib/libc/machine/spu/fputc.c
index bf25526..fe61c53 100644
--- a/newlib/libc/machine/spu/fputc.c
+++ b/newlib/libc/machine/spu/fputc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -57,6 +58,7 @@ fputc (c, fp)
   args.ch = c;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FPUTC, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fputs.c b/newlib/libc/machine/spu/fputs.c
index 9ed7968..218cc40 100644
--- a/newlib/libc/machine/spu/fputs.c
+++ b/newlib/libc/machine/spu/fputs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -57,6 +58,7 @@ _DEFUN (fputs, (s, fp),
   args.s = s;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FPUTS, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fread.c b/newlib/libc/machine/spu/fread.c
index eb3966c..9a34ef3 100644
--- a/newlib/libc/machine/spu/fread.c
+++ b/newlib/libc/machine/spu/fread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -64,6 +65,7 @@ _DEFUN (fread, (buf, size, count, fp),
   args.count = count;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FREAD, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/free_ea.c b/newlib/libc/machine/spu/free_ea.c
index ac206a1..4d2ad9e 100644
--- a/newlib/libc/machine/spu/free_ea.c
+++ b/newlib/libc/machine/spu/free_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -47,5 +48,6 @@ void free_ea(__ea void *ptr)
   if (__cache_flush)
     __cache_flush ();
   __send_to_ppe(JSRE_LIBEA_SIGNALCODE, SPE_LIBEA_FREE , &ptr_arg);
+  __A_VARIABLE = 1;
   return;
 }
diff --git a/newlib/libc/machine/spu/freopen.c b/newlib/libc/machine/spu/freopen.c
index 53dd2bc..cba8b9b 100644
--- a/newlib/libc/machine/spu/freopen.c
+++ b/newlib/libc/machine/spu/freopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
diff --git a/newlib/libc/machine/spu/fseek.c b/newlib/libc/machine/spu/fseek.c
index dc74533..f61cdce 100644
--- a/newlib/libc/machine/spu/fseek.c
+++ b/newlib/libc/machine/spu/fseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -60,6 +61,7 @@ _DEFUN (fseek, (fp, offset, whence),
   args.offset = offset;
   args.whence = whence;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FSEEK, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fsetpos.c b/newlib/libc/machine/spu/fsetpos.c
index 3bd0dde..56a1d37 100644
--- a/newlib/libc/machine/spu/fsetpos.c
+++ b/newlib/libc/machine/spu/fsetpos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -56,6 +57,7 @@ _DEFUN (fsetpos, (iop, pos),
   args.fp = iop->_fp;
   args.pos = pos;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FSETPOS, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/ftell.c b/newlib/libc/machine/spu/ftell.c
index 4782e5e..0c9d2f8 100644
--- a/newlib/libc/machine/spu/ftell.c
+++ b/newlib/libc/machine/spu/ftell.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -47,6 +48,7 @@ _DEFUN (ftell, (fp),
 
   ret = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FTELL, &ret);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/fwrite.c b/newlib/libc/machine/spu/fwrite.c
index 58aab9f..062e668 100644
--- a/newlib/libc/machine/spu/fwrite.c
+++ b/newlib/libc/machine/spu/fwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -64,6 +65,7 @@ _DEFUN (fwrite, (buf, size, count, fp),
   args.count = count;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FWRITE, &args);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/getc.c b/newlib/libc/machine/spu/getc.c
index 213bada..8b422f6 100644
--- a/newlib/libc/machine/spu/getc.c
+++ b/newlib/libc/machine/spu/getc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -49,6 +50,7 @@ getc (fp)
 
   ret = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETC, &ret);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/getchar.c b/newlib/libc/machine/spu/getchar.c
index 68247ef..7365b5e 100644
--- a/newlib/libc/machine/spu/getchar.c
+++ b/newlib/libc/machine/spu/getchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -45,6 +46,7 @@ getchar ()
 
   CHECK_STD_INIT(_REENT);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETCHAR, &ret);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/gets.c b/newlib/libc/machine/spu/gets.c
index 2ac05db..45f06d2 100644
--- a/newlib/libc/machine/spu/gets.c
+++ b/newlib/libc/machine/spu/gets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -44,6 +45,7 @@ gets (buf)
 
   /* The return value gets written over buf
    */
+  __A_VARIABLE = 1;
   return (char*) __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETS, &buf);
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/impure.c b/newlib/libc/machine/spu/impure.c
index 5fbe0e5..b4a1750 100644
--- a/newlib/libc/machine/spu/impure.c
+++ b/newlib/libc/machine/spu/impure.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 
 /* Note that there is a copy of this in sys/reent.h.  */
diff --git a/newlib/libc/machine/spu/malloc_ea.c b/newlib/libc/machine/spu/malloc_ea.c
index e5f9e2f..9ff8169 100644
--- a/newlib/libc/machine/spu/malloc_ea.c
+++ b/newlib/libc/machine/spu/malloc_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -43,5 +44,6 @@ malloc_ea (size_ea_t size)
 
   sz = (unsigned long long) size;
   __send_to_ppe (JSRE_LIBEA_SIGNALCODE, SPE_LIBEA_MALLOC, &sz);
+  __A_VARIABLE = 1;
   return ull_to_eavoid (sz);
 }
diff --git a/newlib/libc/machine/spu/memchr_ea.c b/newlib/libc/machine/spu/memchr_ea.c
index 10d0d59..864cb4d 100644
--- a/newlib/libc/machine/spu/memchr_ea.c
+++ b/newlib/libc/machine/spu/memchr_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -60,6 +61,7 @@ memchr_ea (__ea const void *s, int c, size_ea_t n)
 	{
 	  ret = (size_ea_t) curr_s +
 	    ((size_ea_t) (int) where - (size_ea_t) (int) local_s);
+	  __A_VARIABLE = 1;
 	  return (__ea void *) ret;
 	}
 
@@ -69,5 +71,6 @@ memchr_ea (__ea const void *s, int c, size_ea_t n)
     }
 
   /* if we got here n was initially 0 */
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/machine/spu/memcmp.c b/newlib/libc/machine/spu/memcmp.c
index a0f5449..561f1b1 100644
--- a/newlib/libc/machine/spu/memcmp.c
+++ b/newlib/libc/machine/spu/memcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2008
   International Business Machines Corporation
@@ -39,5 +40,6 @@
 int memcmp(const void *s1, const void *s2, size_t n)
 {
   vec_uint4 end_v;
+  __A_VARIABLE = 1;
   return _strncmp_internal (s1, s2, n, &end_v, 0 /* no zero check */);
 }
diff --git a/newlib/libc/machine/spu/memcmp_ea.c b/newlib/libc/machine/spu/memcmp_ea.c
index 4088bcc..b6b3232 100644
--- a/newlib/libc/machine/spu/memcmp_ea.c
+++ b/newlib/libc/machine/spu/memcmp_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -64,8 +65,10 @@ memcmp_ea (__ea void *s1, __ea const void *s2, size_ea_t n)
       local_n = three_way_min (s2_n, s1_n, n);
 
       ret = memcmp (l_s1, l_s2, local_n);
-      if (ret)
+      if (ret) {
+	__A_VARIABLE = 1;
 	return ret;
+      }
 
       /* update values to take into account what we copied */
       curr_s2 += local_n;
@@ -74,5 +77,6 @@ memcmp_ea (__ea void *s1, __ea const void *s2, size_ea_t n)
 
     }
 
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/machine/spu/memcpy.c b/newlib/libc/machine/spu/memcpy.c
index dbbce8c..b425602 100644
--- a/newlib/libc/machine/spu/memcpy.c
+++ b/newlib/libc/machine/spu/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -111,5 +112,6 @@ void * memcpy(void * __restrict__ dest, const void * __restrict__ src, size_t n)
   mask = spu_and((vec_uchar16)spu_cmpgt(spu_splats((unsigned int)n), 16), mask2);
   *vDst = spu_sel(*vDst, spu_shuffle(sdata2, *vSrc, shuffle), mask);
 
+  __A_VARIABLE = 1;
   return (dest);
 }
diff --git a/newlib/libc/machine/spu/memcpy_ea.c b/newlib/libc/machine/spu/memcpy_ea.c
index 6dfea7a..525f93e 100644
--- a/newlib/libc/machine/spu/memcpy_ea.c
+++ b/newlib/libc/machine/spu/memcpy_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -72,5 +73,6 @@ memcpy_ea (__ea void *dest, __ea const void *src, size_ea_t n)
       n -= local_n;
     }
 
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/memmove.c b/newlib/libc/machine/spu/memmove.c
index f2fe4f9..e8fbd96 100644
--- a/newlib/libc/machine/spu/memmove.c
+++ b/newlib/libc/machine/spu/memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -211,6 +212,7 @@ void * memmove(void * __restrict__ dest, const void * __restrict__ src, size_t n
     mask = spu_and((vec_uchar16)spu_cmpgt(spu_splats((int)n), 0), mask1);
     *vDst = spu_sel(*vDst, spu_shuffle(*vSrc, sdata1, shuffle), mask);
   }
+  __A_VARIABLE = 1;
   return (dest);
 }
 
diff --git a/newlib/libc/machine/spu/memmove_ea.c b/newlib/libc/machine/spu/memmove_ea.c
index 356ab56..95d0ef7 100644
--- a/newlib/libc/machine/spu/memmove_ea.c
+++ b/newlib/libc/machine/spu/memmove_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -73,5 +74,6 @@ memmove_ea (__ea void *dest, __ea const void *src, size_ea_t n)
       n -= local_n;
     }
 
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/memset.c b/newlib/libc/machine/spu/memset.c
index 0b1958d..898d2ab 100644
--- a/newlib/libc/machine/spu/memset.c
+++ b/newlib/libc/machine/spu/memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -86,5 +87,6 @@ void * memset(void *s, int c, size_t n)
     *vs = spu_sel(*vs, vc, mask);
   }
 
+  __A_VARIABLE = 1;
   return (s);
 }
diff --git a/newlib/libc/machine/spu/memset_ea.c b/newlib/libc/machine/spu/memset_ea.c
index a18baf2..2dea475 100644
--- a/newlib/libc/machine/spu/memset_ea.c
+++ b/newlib/libc/machine/spu/memset_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -60,5 +61,6 @@ memset_ea (__ea void *dest, int c, size_ea_t n)
       n -= local_n;
     }
 
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/mmap_ea.c b/newlib/libc/machine/spu/mmap_ea.c
index 0b4a5d8..d7fe7dd 100644
--- a/newlib/libc/machine/spu/mmap_ea.c
+++ b/newlib/libc/machine/spu/mmap_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
diff --git a/newlib/libc/machine/spu/mremap_ea.c b/newlib/libc/machine/spu/mremap_ea.c
index dfd778e..c4b2ee5 100644
--- a/newlib/libc/machine/spu/mremap_ea.c
+++ b/newlib/libc/machine/spu/mremap_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
diff --git a/newlib/libc/machine/spu/msync_ea.c b/newlib/libc/machine/spu/msync_ea.c
index cfb9597..3cbff4b 100644
--- a/newlib/libc/machine/spu/msync_ea.c
+++ b/newlib/libc/machine/spu/msync_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -39,6 +40,7 @@ COMPAT_EA_ALIAS (msync_ea);
 int
 msync_ea (__ea void *start, size_ea_t length, int flags)
 {
+  __A_VARIABLE = 1;
   return msync_eaddr ((unsigned long long) (size_ea_t) start, length,
 		      flags);
 }
diff --git a/newlib/libc/machine/spu/munmap_ea.c b/newlib/libc/machine/spu/munmap_ea.c
index 7b4f624..64d9125 100644
--- a/newlib/libc/machine/spu/munmap_ea.c
+++ b/newlib/libc/machine/spu/munmap_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -39,5 +40,6 @@ COMPAT_EA_ALIAS (munmap_ea);
 int
 munmap_ea (__ea void *start, size_ea_t length)
 {
+  __A_VARIABLE = 1;
   return munmap_eaddr ((unsigned long long) (size_ea_t) start, length);
 }
diff --git a/newlib/libc/machine/spu/perror.c b/newlib/libc/machine/spu/perror.c
index 028f44a..8e887ea 100644
--- a/newlib/libc/machine/spu/perror.c
+++ b/newlib/libc/machine/spu/perror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <errno.h>
 
@@ -26,6 +27,7 @@ _DEFUN (perror, (s),
   arg.arg_errno = errno;
   __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PERROR, &arg);
 
+  __A_VARIABLE = 1;
   return;
 }
 #endif /* ! _REENT_ONLY */
diff --git a/newlib/libc/machine/spu/posix_memalign_ea.c b/newlib/libc/machine/spu/posix_memalign_ea.c
index a1a7361..60cd802 100644
--- a/newlib/libc/machine/spu/posix_memalign_ea.c
+++ b/newlib/libc/machine/spu/posix_memalign_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -61,6 +62,7 @@ posix_memalign_ea (__ea void **memptr, size_ea_t align, size_ea_t size)
   arg.memptr = (unsigned int) memptr;
   arg.align = (unsigned long long) align;
   arg.size = (unsigned long long) size;
+  __A_VARIABLE = 1;
   return __send_to_ppe (JSRE_LIBEA_SIGNALCODE, SPE_LIBEA_POSIX_MEMALIGN,
 			&arg);
 }
diff --git a/newlib/libc/machine/spu/pread_ea.c b/newlib/libc/machine/spu/pread_ea.c
index 124afcd..4125e7c 100644
--- a/newlib/libc/machine/spu/pread_ea.c
+++ b/newlib/libc/machine/spu/pread_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -55,5 +56,6 @@ pread_ea (int fd, __ea void *buf, size_ea_t count, off_t offset)
   /* Flush cache only if the application really uses the software cache.  */
   if (__cache_flush)
     __cache_flush ();
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/newlib/libc/machine/spu/putc.c b/newlib/libc/machine/spu/putc.c
index dc478d3..03ed555 100644
--- a/newlib/libc/machine/spu/putc.c
+++ b/newlib/libc/machine/spu/putc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -57,6 +58,7 @@ putc (c, fp)
   args.ch = c;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTC, &args);
 }
 
diff --git a/newlib/libc/machine/spu/putchar.c b/newlib/libc/machine/spu/putchar.c
index 67eb599..b211fa6 100644
--- a/newlib/libc/machine/spu/putchar.c
+++ b/newlib/libc/machine/spu/putchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 #include "c99ppe.h"
@@ -14,6 +15,7 @@ putchar (c)
 
   /* c gets overwritten before return */
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTCHAR, &c);
 }
 
diff --git a/newlib/libc/machine/spu/puts.c b/newlib/libc/machine/spu/puts.c
index 06f4b87..270b508 100644
--- a/newlib/libc/machine/spu/puts.c
+++ b/newlib/libc/machine/spu/puts.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 #include "c99ppe.h"
@@ -12,6 +13,7 @@ _DEFUN (puts, (s),
 
   /* The return value gets written over s
    */
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTS, &s);
 }
 
diff --git a/newlib/libc/machine/spu/pwrite_ea.c b/newlib/libc/machine/spu/pwrite_ea.c
index e08012c..bf2b7cb 100644
--- a/newlib/libc/machine/spu/pwrite_ea.c
+++ b/newlib/libc/machine/spu/pwrite_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -55,5 +56,6 @@ pwrite_ea (int fd, __ea const void *buf, size_ea_t count, off_t offset)
   /* Flush cache only if the application really uses the software cache.  */
   if (__cache_flush)
     __cache_flush ();
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/newlib/libc/machine/spu/read_ea.c b/newlib/libc/machine/spu/read_ea.c
index adc72d2..303900e 100644
--- a/newlib/libc/machine/spu/read_ea.c
+++ b/newlib/libc/machine/spu/read_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -55,5 +56,6 @@ read_ea (int fd, __ea void *buf, size_ea_t count)
   /* Flush cache only if the application really uses the software cache.  */
   if (__cache_flush)
     __cache_flush ();
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/newlib/libc/machine/spu/readv_ea.c b/newlib/libc/machine/spu/readv_ea.c
index f8875d9..22c4a6d 100644
--- a/newlib/libc/machine/spu/readv_ea.c
+++ b/newlib/libc/machine/spu/readv_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
diff --git a/newlib/libc/machine/spu/realloc_ea.c b/newlib/libc/machine/spu/realloc_ea.c
index 4b7dc87..94e70f1 100644
--- a/newlib/libc/machine/spu/realloc_ea.c
+++ b/newlib/libc/machine/spu/realloc_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -51,5 +52,6 @@ realloc_ea (__ea void *ptr, size_ea_t size)
   args.ptr = (unsigned long long) (size_ea_t) ptr;
   args.size = (unsigned long long) size;
   __send_to_ppe (JSRE_LIBEA_SIGNALCODE, SPE_LIBEA_REALLOC, &args);
+  __A_VARIABLE = 1;
   return ull_to_eavoid (args.ptr);
 }
diff --git a/newlib/libc/machine/spu/remove.c b/newlib/libc/machine/spu/remove.c
index 930a980..516ea36 100644
--- a/newlib/libc/machine/spu/remove.c
+++ b/newlib/libc/machine/spu/remove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -41,6 +42,7 @@ remove (filename)
 
   /* The return value gets written over buf
    */
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_REMOVE, &filename);
 }
 
diff --git a/newlib/libc/machine/spu/rename.c b/newlib/libc/machine/spu/rename.c
index bf58fbd..da5dbf3 100644
--- a/newlib/libc/machine/spu/rename.c
+++ b/newlib/libc/machine/spu/rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -52,5 +53,6 @@ rename (old, new)
   args.old = old;
   args.new = new;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_RENAME, &args);
 }
diff --git a/newlib/libc/machine/spu/rewind.c b/newlib/libc/machine/spu/rewind.c
index 8d1a0a9..6cab2e6 100644
--- a/newlib/libc/machine/spu/rewind.c
+++ b/newlib/libc/machine/spu/rewind.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -48,6 +49,7 @@ _DEFUN (rewind, (fp),
 
   __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_REWIND, &ret);
 
+  __A_VARIABLE = 1;
   return;
 }
 
diff --git a/newlib/libc/machine/spu/setbuf.c b/newlib/libc/machine/spu/setbuf.c
index 84430fc..01af616 100644
--- a/newlib/libc/machine/spu/setbuf.c
+++ b/newlib/libc/machine/spu/setbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -59,6 +60,7 @@ _DEFUN (setbuf, (fp, buf),
 
   __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_SETBUF, &args);
 
+  __A_VARIABLE = 1;
   return;
 }
 
diff --git a/newlib/libc/machine/spu/setvbuf.c b/newlib/libc/machine/spu/setvbuf.c
index 32da292..3473499 100644
--- a/newlib/libc/machine/spu/setvbuf.c
+++ b/newlib/libc/machine/spu/setvbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -65,6 +66,7 @@ _DEFUN (setvbuf, (fp, buf, mode, size),
   args.mode = mode;
   args.size = size;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_SETVBUF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/sleep.c b/newlib/libc/machine/spu/sleep.c
index f3aa979..cf3fec8 100644
--- a/newlib/libc/machine/spu/sleep.c
+++ b/newlib/libc/machine/spu/sleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copied from libc/posix/sleep.c, removed the check for HAVE_NANOSLEEP */
 
 /* Written 2000 by Werner Almesberger */
@@ -12,7 +13,14 @@ unsigned sleep(unsigned seconds)
 
     ts.tv_sec = seconds;
     ts.tv_nsec = 0;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/newlib/libc/machine/spu/spu-gmon.c b/newlib/libc/machine/spu/spu-gmon.c
index 5709bf6..1f4b33c 100644
--- a/newlib/libc/machine/spu/spu-gmon.c
+++ b/newlib/libc/machine/spu/spu-gmon.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -141,14 +142,18 @@ __sample (int id)
   off_t offset;
   unsigned short val;
 
-  if (id != timer_id)
+  if (id != timer_id) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Fetch program counter.  */
   pc = spu_read_srr0 () & ~3;
   pc_backup = pc;
-  if (pc < s_lowpc || pc > s_highpc)
+  if (pc < s_lowpc || pc > s_highpc) {
+    __A_VARIABLE = 1;
     return;
+  }
   pc -= (uintptr_t) & _start;
   offset = pc / HISTFRACTION * sizeof (HISTCOUNTER) + sizeof (struct gmon_hdr)
              + 1 + sizeof (struct gmon_hist_hdr);
@@ -157,6 +162,7 @@ __sample (int id)
   if (pread (fd, &val, 2, offset) != 2)
     {
       perror ("can't read the histogram");
+      __A_VARIABLE = 1;
       return;
     }
   if (val < USHRT_MAX)
@@ -165,6 +171,7 @@ __sample (int id)
     {
       perror ("can't write the histogram");
     }
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -187,6 +194,7 @@ write_histogram (int fd)
 
   /* Skip the already written histogram data.  */
   lseek (fd, hist_size, SEEK_CUR);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -218,6 +226,7 @@ write_callgraph (int fd)
 	    }
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -235,6 +244,7 @@ __mcleanup (void)
     {
       perror ("Cannot seek to the beginning of the gmon.out file.");
       close (fd);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -246,6 +256,7 @@ __mcleanup (void)
     {
       perror ("Cannot write the gmon header to the gmon.out file.");
       close (fd);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -256,6 +267,7 @@ __mcleanup (void)
   write_callgraph (fd);
 
   close (fd);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -275,6 +287,7 @@ __monstartup (unsigned long long spu_id)
   if (froms == NULL)
     {
       fprintf (stderr, "Cannot allocate ea memory for the froms array.\n");
+      __A_VARIABLE = 1;
       return;
     }
   memset_ea (froms, 0, s_textsize / HASHFRACTION);
@@ -289,6 +302,7 @@ __monstartup (unsigned long long spu_id)
   if (tos == NULL)
     {
       fprintf (stderr, "Cannot allocate ea memory for the tos array.\n");
+      __A_VARIABLE = 1;
       return;
     }
   memset_ea (tos, 0, tolimit * sizeof (struct tostruct));
@@ -306,6 +320,7 @@ __monstartup (unsigned long long spu_id)
       char errstr[128];
       snprintf (errstr, sizeof (errstr), "Cannot open file: %s", filename);
       perror (errstr);
+      __A_VARIABLE = 1;
       return;
     }
   /* Truncate the file up to the size where the histogram fits in.  */
@@ -316,6 +331,7 @@ __monstartup (unsigned long long spu_id)
       char errstr[128];
       snprintf (errstr, sizeof (errstr), "Cannot truncate file: %s", filename);
       perror (errstr);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -326,6 +342,7 @@ __monstartup (unsigned long long spu_id)
   spu_timer_start (timer_id);
 
   atexit (__mcleanup);
+  __A_VARIABLE = 1;
 }
 
 void
diff --git a/newlib/libc/machine/spu/spu_clock_stop.c b/newlib/libc/machine/spu/spu_clock_stop.c
index da31b42..9f2f544 100644
--- a/newlib/libc/machine/spu/spu_clock_stop.c
+++ b/newlib/libc/machine/spu/spu_clock_stop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -44,15 +45,21 @@ POSSIBILITY OF SUCH DAMAGE.
 int
 spu_clock_stop (void)
 {
-  if (__spu_clock_startcnt == 0)
+  if (__spu_clock_startcnt == 0) {
+    __A_VARIABLE = 1;
     return SPU_CLOCK_ERR_NOT_RUNNING;
+  }
 
-  if (__spu_clock_startcnt == 1 && (__spu_timers_active || __spu_timers_handled))
+  if (__spu_clock_startcnt == 1 && (__spu_timers_active || __spu_timers_handled)) {
+    __A_VARIABLE = 1;
     return SPU_CLOCK_ERR_TIMERS_ACTIVE;
+  }
 
   /* Don't stop clock if the clock is still in use.  */
-  if (--__spu_clock_startcnt != 0)
+  if (--__spu_clock_startcnt != 0) {
+    __A_VARIABLE = 1;
     return SPU_CLOCK_ERR_STILL_RUNNING;
+  }
 
   /* Clock stopped, stop decrementer.  */
   __disable_spu_decr ();
@@ -63,5 +70,6 @@ spu_clock_stop (void)
       spu_idisable ();
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/machine/spu/spu_clock_svcs.c b/newlib/libc/machine/spu/spu_clock_svcs.c
index 6cc2af4..bc0819f 100644
--- a/newlib/libc/machine/spu/spu_clock_svcs.c
+++ b/newlib/libc/machine/spu/spu_clock_svcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -53,8 +54,10 @@ void
 spu_clock_start (void)
 {
   /* Increment clock start and return if it was already running.  */
-  if (++__spu_clock_startcnt > 1)
+  if (++__spu_clock_startcnt > 1) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   __spu_clock_state_was_enabled = spu_readch (SPU_RdMachStat) & 0x1;
 
@@ -67,6 +70,7 @@ spu_clock_start (void)
 
   spu_ienable ();
 
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -79,8 +83,10 @@ spu_clock_read (void)
   unsigned was_enabled;
 
   /* Return 0 if clock is off.  */
-  if (__spu_clock_startcnt == 0)
+  if (__spu_clock_startcnt == 0) {
+    __A_VARIABLE = 1;
     return 0LL;
+  }
 
   was_enabled = spu_readch (SPU_RdMachStat) & 0x1;
   spu_idisable ();
@@ -89,5 +95,6 @@ spu_clock_read (void)
 
   if (__likely (was_enabled))
     spu_ienable ();
+  __A_VARIABLE = 1;
   return time;
 }
diff --git a/newlib/libc/machine/spu/spu_timebase.c b/newlib/libc/machine/spu/spu_timebase.c
index cb8f34d..db9f032 100644
--- a/newlib/libc/machine/spu/spu_timebase.c
+++ b/newlib/libc/machine/spu/spu_timebase.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -46,6 +47,7 @@ spu_timebase (void)
           break;
       fclose (f);
     }
+  __A_VARIABLE = 1;
   return (tb);
 }
 
diff --git a/newlib/libc/machine/spu/spu_timer_free.c b/newlib/libc/machine/spu/spu_timer_free.c
index 9fb3e0c..f41b1f5 100644
--- a/newlib/libc/machine/spu/spu_timer_free.c
+++ b/newlib/libc/machine/spu/spu_timer_free.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -47,8 +48,10 @@ spu_timer_free (int id)
   spu_timer_t *t, **pn;
   unsigned was_enabled;
 
-  if (id < 0 || id >= SPU_TIMER_NTIMERS)
+  if (id < 0 || id >= SPU_TIMER_NTIMERS) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_INVALID_ID;
+  }
 
   if (__spu_timers[id].state == SPU_TIMER_STOPPED)
     {
@@ -77,10 +80,12 @@ spu_timer_free (int id)
       if (__likely (was_enabled))
 	spu_ienable ();
 
+      __A_VARIABLE = 1;
       return 0;
     }
 
   /* Handle invalid states.  */
+  __A_VARIABLE = 1;
   return (__spu_timers[id].state == SPU_TIMER_FREE) ?
 	  SPU_TIMER_ERR_FREE : SPU_TIMER_ERR_ACTIVE;
 }
diff --git a/newlib/libc/machine/spu/spu_timer_slih.c b/newlib/libc/machine/spu/spu_timer_slih.c
index 8b54b13..60338ed 100644
--- a/newlib/libc/machine/spu/spu_timer_slih.c
+++ b/newlib/libc/machine/spu/spu_timer_slih.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -63,6 +64,7 @@ __reset_spu_decr (int val)
   /* Update the timebase values before enabling for interrupts.  */
   __spu_tb_val += __spu_tb_timeout - decval;
   __spu_tb_timeout = enable_val;
+  __A_VARIABLE = 1;
 }
 
 /* Update software timebase and timeout value for the 'next to expire' timer.
@@ -88,6 +90,7 @@ __update_spu_tb_val (void)
       if (__spu_timers_active->tmout < 0)
 	__spu_timers_active->tmout = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add an allocated timer to the active list. The active list is sorted by
@@ -154,6 +157,7 @@ __spu_timer_start (int id, int reset)
 
   if (__unlikely (was_enabled))
     spu_ienable ();
+  __A_VARIABLE = 1;
 }
 
 /* SLIH for decrementer.  Manages software timebase and timers.
@@ -217,5 +221,6 @@ spu_clock_slih (unsigned status)
   if (__likely (was_enabled))
     spu_ienable ();
 
+  __A_VARIABLE = 1;
   return status;
 }
diff --git a/newlib/libc/machine/spu/spu_timer_slih_reg.c b/newlib/libc/machine/spu/spu_timer_slih_reg.c
index cd1e86f..93ab01a 100644
--- a/newlib/libc/machine/spu/spu_timer_slih_reg.c
+++ b/newlib/libc/machine/spu/spu_timer_slih_reg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -51,6 +52,7 @@ __spu_default_slih (unsigned events)
   mse = 0x80000000 >> SPU_EVENT_ID (events);
   events &= ~mse;
 
+  __A_VARIABLE = 1;
   return (events);
 }
 
@@ -69,4 +71,5 @@ spu_slih_register (unsigned mask, spu_slih_t func)
       __spu_slih_handlers[id] = (func) ? func : __spu_default_slih;
       mask &= ~(0x80000000 >> id);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/spu_timer_stop.c b/newlib/libc/machine/spu/spu_timer_stop.c
index 94286c9..63b82e6 100644
--- a/newlib/libc/machine/spu/spu_timer_stop.c
+++ b/newlib/libc/machine/spu/spu_timer_stop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -44,11 +45,15 @@ spu_timer_stop (int id)
   spu_timer_t *t, **pn;
   unsigned was_enabled;
 
-  if (id < 0 || id >= SPU_TIMER_NTIMERS)
+  if (id < 0 || id >= SPU_TIMER_NTIMERS) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_INVALID_ID;
+  }
 
-  if (__spu_clock_startcnt == 0)
+  if (__spu_clock_startcnt == 0) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_NOCLOCK;
+  }
 
 
   /* Free or stopped states.  */
@@ -94,8 +99,10 @@ spu_timer_stop (int id)
       if (__likely (was_enabled))
 	spu_ienable ();
 
+      __A_VARIABLE = 1;
       return 0;
     }
 
+  __A_VARIABLE = 1;
   return SPU_TIMER_ERR_NOT_ACTIVE;
 }
diff --git a/newlib/libc/machine/spu/spu_timer_svcs.c b/newlib/libc/machine/spu/spu_timer_svcs.c
index 8e7013c..7439021 100644
--- a/newlib/libc/machine/spu/spu_timer_svcs.c
+++ b/newlib/libc/machine/spu/spu_timer_svcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -59,8 +60,10 @@ spu_timer_alloc (int interval, void (*func) (int))
 {
   unsigned was_enabled;
   int id;
-  if (interval < MIN_INTVL || interval > MAX_INTVL || func == NULL)
+  if (interval < MIN_INTVL || interval > MAX_INTVL || func == NULL) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_INVALID_PARM;
+  }
 
   was_enabled = spu_readch (SPU_RdMachStat) & 0x1;
 
@@ -70,8 +73,10 @@ spu_timer_alloc (int interval, void (*func) (int))
 					     (__spu_timers_avail, 0)))), 0);
 
   /* No timers avail.  */
-  if (id == -1)
+  if (id == -1) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_NONE_FREE;
+  }
 
   /* Higher order bits represent lower timer ids.  */
   __spu_timers_avail &= ~(1 << (id));
@@ -89,6 +94,7 @@ spu_timer_alloc (int interval, void (*func) (int))
 
   if (__likely (was_enabled))
     spu_ienable ();
+  __A_VARIABLE = 1;
   return id;
 }
 
@@ -100,16 +106,23 @@ spu_timer_alloc (int interval, void (*func) (int))
 int
 spu_timer_start (int id)
 {
-  if (id < 0 || id >= SPU_TIMER_NTIMERS)
+  if (id < 0 || id >= SPU_TIMER_NTIMERS) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_INVALID_ID;
+  }
 
-  if (__spu_clock_startcnt == 0)
+  if (__spu_clock_startcnt == 0) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_NOCLOCK;
+  }
 
-  if (__spu_timers[id].state != SPU_TIMER_STOPPED)
+  if (__spu_timers[id].state != SPU_TIMER_STOPPED) {
+    __A_VARIABLE = 1;
     return SPU_TIMER_ERR_NOT_STOPPED;
+  }
 
   __spu_timer_start (id, 1);
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/machine/spu/stdio.c b/newlib/libc/machine/spu/stdio.c
index 997ccb7..3e9488e 100644
--- a/newlib/libc/machine/spu/stdio.c
+++ b/newlib/libc/machine/spu/stdio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 Copyright (C) 2007 Sony Computer Entertainment Inc.
 Copyright 2007 Sony Corp.
@@ -45,10 +46,12 @@ _DEFUN (__sfp, (d),
   int i;
   for (i = 0; i < SPE_FOPEN_MAX; i++) {
     if (!__fp[i]._fp) {
+      __A_VARIABLE = 1;
       return &__fp[i];
     }
   }
   d->_errno = EMFILE;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -62,6 +65,7 @@ _DEFUN (__cleanup, (s),
       fclose(&__fp[i]);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 _VOID
@@ -79,10 +83,12 @@ _DEFUN (__sinit, (s),
 
   s->_stderr = &s->__sf[2];
   s->_stderr->_fp = SPE_STDERR;
+  __A_VARIABLE = 1;
 }
 
 _VOID
 _DEFUN_VOID (__check_init)
 {
     CHECK_INIT(_REENT);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/strcat.c b/newlib/libc/machine/spu/strcat.c
index 9a5185c..418e305 100644
--- a/newlib/libc/machine/spu/strcat.c
+++ b/newlib/libc/machine/spu/strcat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2008
   International Business Machines Corporation,
@@ -42,5 +43,6 @@
 char *strcat(char * __restrict__ dest, const char * __restrict__ src)
 {
   _strncpy(_straddr(dest), src, 0, 0, 0);
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strcat_ea.c b/newlib/libc/machine/spu/strcat_ea.c
index f6178e4..01a34c8 100644
--- a/newlib/libc/machine/spu/strcat_ea.c
+++ b/newlib/libc/machine/spu/strcat_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -51,5 +52,6 @@ strcat_ea (__ea char *dest, __ea const char *src)
   length_dest = strlen_ea (dest);
   new_dest = dest + length_dest;
   memcpy_ea ((__ea void *) new_dest, (__ea void *) src, length_src + 1);
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strchr.c b/newlib/libc/machine/spu/strchr.c
index dc93d60..dc29564 100644
--- a/newlib/libc/machine/spu/strchr.c
+++ b/newlib/libc/machine/spu/strchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -78,5 +79,6 @@ char *strchr(const char *s, int c)
 
   result = spu_andc(result, spu_cmpgt(cmp_0, cmp_c));
 
+  __A_VARIABLE = 1;
   return ((char *)spu_extract(result, 0));
 }
diff --git a/newlib/libc/machine/spu/strchr_ea.c b/newlib/libc/machine/spu/strchr_ea.c
index 6c751c8..d77cd4d 100644
--- a/newlib/libc/machine/spu/strchr_ea.c
+++ b/newlib/libc/machine/spu/strchr_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -43,5 +44,6 @@ strchr_ea (__ea const char *s, int c)
   size_ea_t size;
 
   size = strlen_ea (s);
+  __A_VARIABLE = 1;
   return (char *) memchr_ea (s, c, size);
 }
diff --git a/newlib/libc/machine/spu/strcmp.c b/newlib/libc/machine/spu/strcmp.c
index 2db1a13..86a45bf 100644
--- a/newlib/libc/machine/spu/strcmp.c
+++ b/newlib/libc/machine/spu/strcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -90,5 +91,6 @@ int strcmp(const char *s1, const char *s2)
 
   gt_v = spu_sub(-1, spu_sl(spu_cmpgt(gt_v, lt_v), 1));
 
+  __A_VARIABLE = 1;
   return (spu_extract(spu_andc(gt_v, mask_v), 0));
 }
diff --git a/newlib/libc/machine/spu/strcmp_ea.c b/newlib/libc/machine/spu/strcmp_ea.c
index 2c9c5eb..9f0c1f3 100644
--- a/newlib/libc/machine/spu/strcmp_ea.c
+++ b/newlib/libc/machine/spu/strcmp_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -73,14 +74,17 @@ strcmp_ea (__ea char *s1, __ea const char *s2)
       /*
        * Only the first slot of end_v is set.
        */
-      if (ret || spu_extract (end_v, 0))
+      if (ret || spu_extract (end_v, 0)) {
 	/*
 	 * If any NUL values were seen (end_v values of zero) we still have
 	 * to return ret, as it might not be zero.
 	 */
+	__A_VARIABLE = 1;
 	return ret;
+      }
 
       curr_s1 += min;
       curr_s2 += min;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/strcpy.c b/newlib/libc/machine/spu/strcpy.c
index 69045ba..370c27b 100644
--- a/newlib/libc/machine/spu/strcpy.c
+++ b/newlib/libc/machine/spu/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2008
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
  */
 char * strcpy(char * __restrict__ dest, const char * __restrict__ src)
 {
+  __A_VARIABLE = 1;
   return _strncpy(dest, src, 0, 0, 0);
 }
diff --git a/newlib/libc/machine/spu/strcpy_ea.c b/newlib/libc/machine/spu/strcpy_ea.c
index 7d39058..f27d0c8 100644
--- a/newlib/libc/machine/spu/strcpy_ea.c
+++ b/newlib/libc/machine/spu/strcpy_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -47,5 +48,6 @@ strcpy_ea (__ea char *dest, __ea const char *src)
 
   length = strlen_ea (src);
   memcpy_ea ((__ea void *) dest, (__ea void *) src, length + 1);
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strcspn.c b/newlib/libc/machine/spu/strcspn.c
index 5f75a29..f9c9a8b 100644
--- a/newlib/libc/machine/spu/strcspn.c
+++ b/newlib/libc/machine/spu/strcspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -92,5 +93,6 @@ size_t strcspn(const char *s1, const char *s2)
     dataB = *ptr1++;
   } while (cnt == 32);
 
+  __A_VARIABLE = 1;
   return (len);
 }
diff --git a/newlib/libc/machine/spu/strcspn_ea.c b/newlib/libc/machine/spu/strcspn_ea.c
index 2cc0f08..24c0664 100644
--- a/newlib/libc/machine/spu/strcspn_ea.c
+++ b/newlib/libc/machine/spu/strcspn_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -59,5 +60,6 @@ strcspn_ea (__ea const char *s, const char *reject)
 	ret = found_length;
     }
 
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/machine/spu/strlen.c b/newlib/libc/machine/spu/strlen.c
index a8403e0..3c865fe 100644
--- a/newlib/libc/machine/spu/strlen.c
+++ b/newlib/libc/machine/spu/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -64,5 +65,6 @@ size_t strlen(const char *s)
    * The length is ptr aligned down to a 16 byte boundary, plus the offset
    * to the zero byte, minus the starting address s.
    */
+  __A_VARIABLE = 1;
   return ((((int) ptr & ~0xf) + (cnt - 16)) - (int) s);
 }
diff --git a/newlib/libc/machine/spu/strlen_ea.c b/newlib/libc/machine/spu/strlen_ea.c
index f00cec2..1c860e8 100644
--- a/newlib/libc/machine/spu/strlen_ea.c
+++ b/newlib/libc/machine/spu/strlen_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -57,6 +58,7 @@ strlen_ea (__ea const char *s)
 	{
 	  length_of_string += ((size_ea_t) (int) where_null - (size_ea_t)
 			       (int) local_s);
+	  __A_VARIABLE = 1;
 	  return length_of_string;
 	}
 
@@ -64,4 +66,5 @@ strlen_ea (__ea const char *s)
       curr_s += left_in_cacheline;
       length_of_string += left_in_cacheline;
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/strncat.c b/newlib/libc/machine/spu/strncat.c
index 3eeea7a..12fe304 100644
--- a/newlib/libc/machine/spu/strncat.c
+++ b/newlib/libc/machine/spu/strncat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2008
   International Business Machines Corporation,
@@ -42,5 +43,6 @@ char * strncat(char * __restrict__ dest, const char * __restrict__ src,
                size_t n)
 {
   _strncpy(_straddr(dest), src, n, 1, 1);
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strncat_ea.c b/newlib/libc/machine/spu/strncat_ea.c
index b6c7389..e10d3dd 100644
--- a/newlib/libc/machine/spu/strncat_ea.c
+++ b/newlib/libc/machine/spu/strncat_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -56,5 +57,6 @@ strncat_ea (__ea char *dest, __ea const char *src, size_ea_t n)
   /* null out last character */
   memset_ea ((__ea void *) (new_dest + smaller_length), 0, 1);
 
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strncmp.c b/newlib/libc/machine/spu/strncmp.c
index d96504c..e73f305 100644
--- a/newlib/libc/machine/spu/strncmp.c
+++ b/newlib/libc/machine/spu/strncmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -42,5 +43,6 @@
 int strncmp(const char *s1, const char *s2, size_t n)
 {
   vec_uint4 end_v;
+  __A_VARIABLE = 1;
   return _strncmp_internal (s1, s2, n, &end_v, 1);
 }
diff --git a/newlib/libc/machine/spu/strncmp_ea.c b/newlib/libc/machine/spu/strncmp_ea.c
index 1a4f366..5061b0a 100644
--- a/newlib/libc/machine/spu/strncmp_ea.c
+++ b/newlib/libc/machine/spu/strncmp_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -72,16 +73,19 @@ strncmp_ea (__ea void *s1, __ea const void *s2, size_ea_t n3)
        */
       /* if (ret || spu_extract(spu_cmpeq(end_v, 0), 0)) { */
       /* if (ret || spu_extract(spu_gather(spu_cmpeq(end_v, 0)), 0)) { */
-      if (ret || spu_extract (end_v, 0))
+      if (ret || spu_extract (end_v, 0)) {
 	/*
 	 * If any NUL values were seen (end_v values of zero) we still have
 	 * to return ret, as it might not be zero.
 	 */
+	__A_VARIABLE = 1;
 	return ret;
+      }
 
       curr_s2 += min;
       curr_s1 += min;
       n3 -= min;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/machine/spu/strncpy.c b/newlib/libc/machine/spu/strncpy.c
index 9c70b04..02c80c6 100644
--- a/newlib/libc/machine/spu/strncpy.c
+++ b/newlib/libc/machine/spu/strncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2008
   International Business Machines Corporation,
@@ -38,5 +39,6 @@
  */
 char * strncpy(char * __restrict__ dest, const char * __restrict__ src, size_t n)
 {
+  __A_VARIABLE = 1;
   return _strncpy(dest, src, n, 1, 0);
 }
diff --git a/newlib/libc/machine/spu/strncpy_ea.c b/newlib/libc/machine/spu/strncpy_ea.c
index c29ba91..5a59527 100644
--- a/newlib/libc/machine/spu/strncpy_ea.c
+++ b/newlib/libc/machine/spu/strncpy_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -53,5 +54,6 @@ strncpy_ea (__ea char *dest, __ea const char *src, size_ea_t n)
     {
       memcpy_ea ((__ea void *) dest, (__ea void *) src, n);
     }
+  __A_VARIABLE = 1;
   return dest;
 }
diff --git a/newlib/libc/machine/spu/strpbrk.c b/newlib/libc/machine/spu/strpbrk.c
index 461a586..690001d 100644
--- a/newlib/libc/machine/spu/strpbrk.c
+++ b/newlib/libc/machine/spu/strpbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -91,6 +92,7 @@ char * strpbrk(const char *s1, const char *s2)
   /* Compute the first match pointer, zeroing it (NIL) if it is the end of
    * string.
    */
+  __A_VARIABLE = 1;
   return ((char *)spu_extract(spu_andc(spu_add(spu_add(spu_promote((unsigned int)(ptr1), 0), -64), cnt),
 				       spu_cmpeq(cnt, spu_cntlz(spu_gather(eos)))), 0));
 }
diff --git a/newlib/libc/machine/spu/strpbrk_ea.c b/newlib/libc/machine/spu/strpbrk_ea.c
index a8b69f5..77dd729 100644
--- a/newlib/libc/machine/spu/strpbrk_ea.c
+++ b/newlib/libc/machine/spu/strpbrk_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -43,5 +44,6 @@ strpbrk_ea (__ea const char *s, const char *accept)
   size_ea_t where;
 
   where = strcspn_ea (s, accept);
+  __A_VARIABLE = 1;
   return (__ea char *) ((size_ea_t) s + where);
 }
diff --git a/newlib/libc/machine/spu/strrchr.c b/newlib/libc/machine/spu/strrchr.c
index d311710..626fba6 100644
--- a/newlib/libc/machine/spu/strrchr.c
+++ b/newlib/libc/machine/spu/strrchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -111,5 +112,6 @@ char * strrchr(const char *s, int c)
   result = spu_sub(spu_add(res_ptr, 15), spu_cntlz(res_cmp));
   result = spu_andc(result, mask);
 
+  __A_VARIABLE = 1;
   return ((char *)spu_extract(result, 0));
 }
diff --git a/newlib/libc/machine/spu/strrchr_ea.c b/newlib/libc/machine/spu/strrchr_ea.c
index 76ebb31..ed8d9a3 100644
--- a/newlib/libc/machine/spu/strrchr_ea.c
+++ b/newlib/libc/machine/spu/strrchr_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
@@ -38,6 +39,7 @@ POSSIBILITY OF SUCH DAMAGE.
 static __ea char *
 similie_ls_to_ea (char *l1, __ea char *ea1, char *l2)
 {
+  __A_VARIABLE = 1;
   return (__ea char *) ((size_ea_t) ea1 +
 			((size_ea_t) (int) l2 - (size_ea_t) (int) l1));
 }
@@ -68,12 +70,16 @@ strrchr_ea (__ea const char *s, int c)
       /*search backwards through this cachline */
       while (curr_ptr >= start_of_cachline_local)
 	{
-	  if (*curr_ptr == (char) c)
+	  if (*curr_ptr == (char) c) {
+	    __A_VARIABLE = 1;
 	    return similie_ls_to_ea (start_of_cachline_local,
 				     start_of_cacheline_ea, curr_ptr);
+	  }
 	  curr_ptr--;
-	  if (curr_ptr < string_start_local)
+	  if (curr_ptr < string_start_local) {
+	    __A_VARIABLE = 1;
 	    return NULL;
+	  }
 	}
 
       /* iterate cacheline backwards */
@@ -81,4 +87,5 @@ strrchr_ea (__ea const char *s, int c)
       start_of_cachline_local = __cache_fetch (start_of_cacheline_ea);
       curr_ptr = __cache_fetch (start_of_cacheline_ea + 128);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/machine/spu/strspn.c b/newlib/libc/machine/spu/strspn.c
index 511e631..6cd41aa 100644
--- a/newlib/libc/machine/spu/strspn.c
+++ b/newlib/libc/machine/spu/strspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -91,5 +92,6 @@ size_t strspn(const char *s1, const char *s2)
     dataB = *ptr1++;
   } while (cnt == 32);
 
+  __A_VARIABLE = 1;
   return (len);
 }
diff --git a/newlib/libc/machine/spu/strspn_ea.c b/newlib/libc/machine/spu/strspn_ea.c
index d1e2947..f1f3d8b 100644
--- a/newlib/libc/machine/spu/strspn_ea.c
+++ b/newlib/libc/machine/spu/strspn_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
diff --git a/newlib/libc/machine/spu/strstr_ea.c b/newlib/libc/machine/spu/strstr_ea.c
index 9200cbf..6730e6b 100644
--- a/newlib/libc/machine/spu/strstr_ea.c
+++ b/newlib/libc/machine/spu/strstr_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2007, 2008
 
diff --git a/newlib/libc/machine/spu/strxfrm.c b/newlib/libc/machine/spu/strxfrm.c
index 02bb9a8..5303139 100644
--- a/newlib/libc/machine/spu/strxfrm.c
+++ b/newlib/libc/machine/spu/strxfrm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2001,2006,
   International Business Machines Corporation,
@@ -57,5 +58,6 @@ size_t strxfrm(char * __restrict__ dest, const char * __restrict__ src, size_t n
   len = strlen(src);
   (void)memcpy((void *)dest, (void *)src, min(n,len + 1));
 
+  __A_VARIABLE = 1;
   return len;
 }
diff --git a/newlib/libc/machine/spu/tmpfile.c b/newlib/libc/machine/spu/tmpfile.c
index c66f783..b13f4a3 100644
--- a/newlib/libc/machine/spu/tmpfile.c
+++ b/newlib/libc/machine/spu/tmpfile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
diff --git a/newlib/libc/machine/spu/tmpnam.c b/newlib/libc/machine/spu/tmpnam.c
index 5cbf279..0d6d62e 100644
--- a/newlib/libc/machine/spu/tmpnam.c
+++ b/newlib/libc/machine/spu/tmpnam.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -40,5 +41,6 @@ _DEFUN (tmpnam, (s),
 {
   /* The return value gets written over buf
    */
+  __A_VARIABLE = 1;
   return (char*) __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_TMPNAM, &s);
 }
diff --git a/newlib/libc/machine/spu/ungetc.c b/newlib/libc/machine/spu/ungetc.c
index 631e71d..cbc7b3d 100644
--- a/newlib/libc/machine/spu/ungetc.c
+++ b/newlib/libc/machine/spu/ungetc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -57,6 +58,7 @@ ungetc (c, fp)
   args.c = c;
   args.fp = fp->_fp;
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_UNGETC, &args);
 }
 
diff --git a/newlib/libc/machine/spu/usleep.c b/newlib/libc/machine/spu/usleep.c
index c587f31..e3a6b4d 100644
--- a/newlib/libc/machine/spu/usleep.c
+++ b/newlib/libc/machine/spu/usleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copied from libc/posix/usleep.c, removed the check for HAVE_NANOSLEEP */
 
 /* Written 2002 by Jeff Johnston */
@@ -12,7 +13,14 @@ int usleep(useconds_t useconds)
 
     ts.tv_sec = (long int)useconds / 1000000;
     ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/newlib/libc/machine/spu/vfiprintf.c b/newlib/libc/machine/spu/vfiprintf.c
index 83394a6..047316f 100644
--- a/newlib/libc/machine/spu/vfiprintf.c
+++ b/newlib/libc/machine/spu/vfiprintf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vfprintf.c"
diff --git a/newlib/libc/machine/spu/vfiscanf.c b/newlib/libc/machine/spu/vfiscanf.c
index 261122e..8afa9ca 100644
--- a/newlib/libc/machine/spu/vfiscanf.c
+++ b/newlib/libc/machine/spu/vfiscanf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vfscanf.c"
diff --git a/newlib/libc/machine/spu/vfprintf.c b/newlib/libc/machine/spu/vfprintf.c
index 128d0b3..8c63e03 100644
--- a/newlib/libc/machine/spu/vfprintf.c
+++ b/newlib/libc/machine/spu/vfprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -70,6 +71,7 @@ _DEFUN (vfprintf, (fp, fmt0, ap),
   args.fmt = (char*) fmt0;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFPRINTF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/vfscanf.c b/newlib/libc/machine/spu/vfscanf.c
index 0f72896..c8acd55 100644
--- a/newlib/libc/machine/spu/vfscanf.c
+++ b/newlib/libc/machine/spu/vfscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -70,6 +71,7 @@ _DEFUN (vfscanf, (fp, fmt, ap),
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFSCANF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/viprintf.c b/newlib/libc/machine/spu/viprintf.c
index f0753ff..e4dde8c 100644
--- a/newlib/libc/machine/spu/viprintf.c
+++ b/newlib/libc/machine/spu/viprintf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vprintf.c"
diff --git a/newlib/libc/machine/spu/viscanf.c b/newlib/libc/machine/spu/viscanf.c
index 4e239e3..f6fc3ec 100644
--- a/newlib/libc/machine/spu/viscanf.c
+++ b/newlib/libc/machine/spu/viscanf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vscanf.c"
diff --git a/newlib/libc/machine/spu/vprintf.c b/newlib/libc/machine/spu/vprintf.c
index 32b86d8..f34f6ec 100644
--- a/newlib/libc/machine/spu/vprintf.c
+++ b/newlib/libc/machine/spu/vprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <stdio.h>
 
@@ -34,6 +35,7 @@ _DEFUN (vprintf, (fmt, ap),
   args.fmt = fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VPRINTF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/vscanf.c b/newlib/libc/machine/spu/vscanf.c
index 4f68bfe..2a68b50 100644
--- a/newlib/libc/machine/spu/vscanf.c
+++ b/newlib/libc/machine/spu/vscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -66,6 +67,7 @@ _DEFUN (vscanf, (fmt, ap),
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSCANF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/vsiprintf.c b/newlib/libc/machine/spu/vsiprintf.c
index fbd64e4..3d04aaf 100644
--- a/newlib/libc/machine/spu/vsiprintf.c
+++ b/newlib/libc/machine/spu/vsiprintf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vsprintf.c"
diff --git a/newlib/libc/machine/spu/vsiscanf.c b/newlib/libc/machine/spu/vsiscanf.c
index 73a44cd..fb4d617 100644
--- a/newlib/libc/machine/spu/vsiscanf.c
+++ b/newlib/libc/machine/spu/vsiscanf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vsscanf.c"
diff --git a/newlib/libc/machine/spu/vsniprintf.c b/newlib/libc/machine/spu/vsniprintf.c
index fb6f641..5793e7f 100644
--- a/newlib/libc/machine/spu/vsniprintf.c
+++ b/newlib/libc/machine/spu/vsniprintf.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define INTEGER_ONLY
 #include "vsnprintf.c"
diff --git a/newlib/libc/machine/spu/vsnprintf.c b/newlib/libc/machine/spu/vsnprintf.c
index cf4f5e7..70c26ba 100644
--- a/newlib/libc/machine/spu/vsnprintf.c
+++ b/newlib/libc/machine/spu/vsnprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <stdio.h>
 
@@ -42,6 +43,7 @@ _DEFUN (vsnprintf, (str, size, fmt, ap),
   args.fmt = fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSNPRINTF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/vsprintf.c b/newlib/libc/machine/spu/vsprintf.c
index 0719d38..1344462 100644
--- a/newlib/libc/machine/spu/vsprintf.c
+++ b/newlib/libc/machine/spu/vsprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include <_ansi.h>
 #include <stdio.h>
@@ -39,6 +40,7 @@ _DEFUN (vsprintf, (str, fmt, ap),
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSPRINTF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/vsscanf.c b/newlib/libc/machine/spu/vsscanf.c
index 2f7380f..224e8f2 100644
--- a/newlib/libc/machine/spu/vsscanf.c
+++ b/newlib/libc/machine/spu/vsscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2006
 
@@ -70,6 +71,7 @@ _DEFUN (vsscanf, (str, fmt, ap),
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
+  __A_VARIABLE = 1;
   return __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSSCANF, &args);
 }
 
diff --git a/newlib/libc/machine/spu/write_ea.c b/newlib/libc/machine/spu/write_ea.c
index 05d6bdf..a85fa7a 100644
--- a/newlib/libc/machine/spu/write_ea.c
+++ b/newlib/libc/machine/spu/write_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
@@ -56,5 +57,6 @@ write_ea (int fd, __ea const void *buf, size_ea_t count)
   /* Flush cache only if the application really uses the software cache.  */
   if (__cache_flush)
     __cache_flush ();
+  __A_VARIABLE = 1;
   return __linux_syscall (&s);
 }
diff --git a/newlib/libc/machine/spu/writev_ea.c b/newlib/libc/machine/spu/writev_ea.c
index efda38b..884ed01 100644
--- a/newlib/libc/machine/spu/writev_ea.c
+++ b/newlib/libc/machine/spu/writev_ea.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2008
 
diff --git a/newlib/libc/machine/visium/memcpy.c b/newlib/libc/machine/visium/memcpy.c
index c511006..9e95153 100644
--- a/newlib/libc/machine/visium/memcpy.c
+++ b/newlib/libc/machine/visium/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* memcpy for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -559,6 +560,7 @@ __int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     MOVE_32_OBJECTS (in, out);
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -699,6 +701,7 @@ __shrt_int_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     MOVE_32_OBJECTS (in, out);
+  __A_VARIABLE = 1;
 }
 
 
@@ -840,6 +843,7 @@ __byte_memcpy (void *__restrict s1, const void *__restrict s2, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     MOVE_32_OBJECTS (in, out);
+  __A_VARIABLE = 1;
 }
 
 
@@ -870,5 +874,6 @@ memcpy (void *__restrict s1, const void *__restrict s2, size_t n)
 #endif /* __VISIUM_ARCH_BMI__ */
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/machine/visium/memmove.c b/newlib/libc/machine/visium/memmove.c
index d594213..4cb783c 100644
--- a/newlib/libc/machine/visium/memmove.c
+++ b/newlib/libc/machine/visium/memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* memmove for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -45,8 +46,10 @@ memmove (void *dst, const void *src, size_t len)
       while (len--)
         *--d = *--s;
 
+      __A_VARIABLE = 1;
       return dst;
     }
 
+  __A_VARIABLE = 1;
   return memcpy (dst, src, len);
 }
diff --git a/newlib/libc/machine/visium/memset.c b/newlib/libc/machine/visium/memset.c
index bad64a9..3e6e1e8 100644
--- a/newlib/libc/machine/visium/memset.c
+++ b/newlib/libc/machine/visium/memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* memset for the Visium processor.
 
    Copyright (c) 2015 Rolls-Royce Controls and Data Services Limited.
@@ -366,6 +367,7 @@ __int_memset (void *__restrict s1, int val, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     SET_32_OBJECTS (out);
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -505,6 +507,7 @@ __short_int_memset (void *__restrict s1, int val, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     SET_32_OBJECTS (out);
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -644,6 +647,7 @@ __byte_memset (void *__restrict s1, int val, size_t n)
   count = value >> 5;
   for (loop_var = 0; loop_var < count; loop_var++)
     SET_32_OBJECTS (out);
+  __A_VARIABLE = 1;
 }
 
 
@@ -673,5 +677,6 @@ memset (void *s, int c, size_t n)
 	}
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/machine/w65/cmpsi.c b/newlib/libc/machine/w65/cmpsi.c
index 3773c9d..69d2173 100644
--- a/newlib/libc/machine/w65/cmpsi.c
+++ b/newlib/libc/machine/w65/cmpsi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 union u {
   struct {
@@ -16,13 +17,22 @@ __cmpsi2(long arga,
 
   if (u.w.msw != msw_b)
     {
-      if (u.w.msw < msw_b) return 0;
+      if (u.w.msw < msw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
   if (u.w.lsw != lsw_b) 
     {
-      if (u.w.lsw < lsw_b) return 0;
+      if (u.w.lsw < lsw_b) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
+      __A_VARIABLE = 1;
       return 2;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/machine/w65/divsi3.c b/newlib/libc/machine/w65/divsi3.c
index bf74992..d2aef15 100644
--- a/newlib/libc/machine/w65/divsi3.c
+++ b/newlib/libc/machine/w65/divsi3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #define divnorm(num, den, sign) 		\
 {						\
@@ -43,7 +44,11 @@ divmodsi4(int modwanted, unsigned long num, unsigned long den)
       bit >>=1;					
       den >>=1;					
     }						
-  if (modwanted) return num;
+  if (modwanted) {
+      __A_VARIABLE = 1;
+      return num;
+  }
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -69,8 +74,11 @@ __modsi3 (long numerator, long denominator)
     }  
   
   modul =  divmodsi4 (1, numerator, denominator);
-  if (sign)
+  if (sign) {
+    __A_VARIABLE = 1;
     return - modul;
+  }
+  __A_VARIABLE = 1;
   return modul;
 }
 
@@ -85,6 +93,7 @@ __divsi3 (long numerator, long denominator)
 
   dividend = divmodsi4 (0,  numerator, denominator);
   exitdiv (sign, dividend);
+  __A_VARIABLE = 1;
 }
 
 long 
@@ -94,6 +103,7 @@ __umodsi3 (unsigned long numerator, unsigned long denominator)
   long modul;
 
 modul= divmodsi4 (1,  numerator, denominator);
+  __A_VARIABLE = 1;
   return modul;
 }
 
@@ -104,6 +114,7 @@ __udivsi3 (unsigned long numerator, unsigned long denominator)
   long dividend;
   long modul;
   dividend =   divmodsi4 (0, numerator, denominator);
+  __A_VARIABLE = 1;
   return dividend;
 }
 
@@ -129,6 +140,7 @@ main ()
 	    printf ("fail %d %d %d %d\n", i, j, k, m);
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/machine/w65/mulsi3.c b/newlib/libc/machine/w65/mulsi3.c
index b48fe97..88a1689 100644
--- a/newlib/libc/machine/w65/mulsi3.c
+++ b/newlib/libc/machine/w65/mulsi3.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 long
@@ -13,5 +14,6 @@ __mulsi3(unsigned long a, unsigned long b)
       b <<= 1;
       a >>=1;
     }
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/newlib/libc/machine/xc16x/putchar.c b/newlib/libc/machine/xc16x/putchar.c
index 13a6aa3..c1083c9 100644
--- a/newlib/libc/machine/xc16x/putchar.c
+++ b/newlib/libc/machine/xc16x/putchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -13,5 +14,6 @@
 void putchar (int c)
 {
   asm("trap #1");
+  __A_VARIABLE = 1;
 }
 
diff --git a/newlib/libc/machine/xc16x/puts.c b/newlib/libc/machine/xc16x/puts.c
index c833a8f..3274dfd 100644
--- a/newlib/libc/machine/xc16x/puts.c
+++ b/newlib/libc/machine/xc16x/puts.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2006 KPIT Cummins
  * Copyright (C) 2009 Conny Marco Menebrcker
@@ -16,6 +17,7 @@ int puts(const char *s)
     int a;
     while ((a = *s++))
         putchar(a);
+    __A_VARIABLE = 1;
     return putchar('\n');
 }
 
diff --git a/newlib/libc/machine/xscale/memchr.c b/newlib/libc/machine/xscale/memchr.c
index 9bf1826..81c9763 100644
--- a/newlib/libc/machine/xscale/memchr.c
+++ b/newlib/libc/machine/xscale/memchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/memchr.c"
diff --git a/newlib/libc/machine/xscale/memcmp.c b/newlib/libc/machine/xscale/memcmp.c
index 1eba4b8..4c500a2 100644
--- a/newlib/libc/machine/xscale/memcmp.c
+++ b/newlib/libc/machine/xscale/memcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/memcmp.c"
@@ -107,6 +108,7 @@ memcmp (const void * s1, const void * s2, size_t len)
        : "=r" (result), "=&r" (s2), "=&r" (len)
        : "0" (s1), "1" (s2), "2" (len)
        : "r2", "r3", "r4", "r5", "r6", "cc", "lr");
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
diff --git a/newlib/libc/machine/xscale/memcpy.c b/newlib/libc/machine/xscale/memcpy.c
index 7de967f..1c7290d 100644
--- a/newlib/libc/machine/xscale/memcpy.c
+++ b/newlib/libc/machine/xscale/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/memcpy.c"
@@ -96,6 +97,7 @@ memcpy (void *__restrict dst0, const void *__restrict src0, size_t len)
        : "=&r" (dummy), "=&r" (src0), "=&r" (len)
        : "0" (dst0), "1" (src0), "2" (len)
        : "memory", "lr", "r3", "r4", "r5", "cc");
+  __A_VARIABLE = 1;
   return dst0;
 }
 #endif
diff --git a/newlib/libc/machine/xscale/memmove.c b/newlib/libc/machine/xscale/memmove.c
index 04d1a14..8b8055e 100644
--- a/newlib/libc/machine/xscale/memmove.c
+++ b/newlib/libc/machine/xscale/memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/memmove.c"
@@ -96,6 +97,7 @@ do_memcpy (void *dst0, const void *src0, size_t len)
        : "=&r" (dummy), "=&r" (src0), "=&r" (len)
        : "0" (dst0), "1" (src0), "2" (len)
        : "memory", "lr", "r3", "r4", "r5", "cc");
+  __A_VARIABLE = 1;
   return dst0;
 }
 
diff --git a/newlib/libc/machine/xscale/memset.c b/newlib/libc/machine/xscale/memset.c
index 4ff8d01..c0630de 100644
--- a/newlib/libc/machine/xscale/memset.c
+++ b/newlib/libc/machine/xscale/memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/memset.c"
@@ -83,6 +84,7 @@ memset (void *dst, int c, size_t len)
        : "0" (dst), "1" (c), "2" (len)
        : "memory", "r3", "r4", "r5", "lr");
 
+  __A_VARIABLE = 1;
   return dst;
 }
  
diff --git a/newlib/libc/machine/xscale/strchr.c b/newlib/libc/machine/xscale/strchr.c
index 3b736c5..efd251f 100644
--- a/newlib/libc/machine/xscale/strchr.c
+++ b/newlib/libc/machine/xscale/strchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/strchr.c"
diff --git a/newlib/libc/machine/xscale/strcmp.c b/newlib/libc/machine/xscale/strcmp.c
index 6c94d12..1c4a111 100644
--- a/newlib/libc/machine/xscale/strcmp.c
+++ b/newlib/libc/machine/xscale/strcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/strcmp.c"
diff --git a/newlib/libc/machine/xscale/strcpy.c b/newlib/libc/machine/xscale/strcpy.c
index 46db2ba..5f9b352 100644
--- a/newlib/libc/machine/xscale/strcpy.c
+++ b/newlib/libc/machine/xscale/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__
 
 #include "../../string/strcpy.c"
diff --git a/newlib/libc/machine/xscale/strlen.c b/newlib/libc/machine/xscale/strlen.c
index a8bc085..eb61a31 100644
--- a/newlib/libc/machine/xscale/strlen.c
+++ b/newlib/libc/machine/xscale/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #if defined __thumb__ || defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
 
 #include "../../string/strlen.c"
@@ -94,6 +95,7 @@ strlen (const char *str)
        : "=r" (str) : "0" (str) : "r2", "r3", "r4", "r5", "r6", "r7");
 
   out:
+  __A_VARIABLE = 1;
   return str - start;
 }
 
diff --git a/newlib/libc/machine/xstormy16/mallocr.c b/newlib/libc/machine/xstormy16/mallocr.c
index 23e02f7..b23462d 100644
--- a/newlib/libc/machine/xstormy16/mallocr.c
+++ b/newlib/libc/machine/xstormy16/mallocr.c
@@ -1,9 +1,11 @@
+static volatile int __A_VARIABLE;
 #include <malloc.h>
 
 #ifdef DEFINE_MALLOC
 _PTR 
 _malloc_r (struct _reent *r, size_t sz)
 {
+  __A_VARIABLE = 1;
   return malloc (sz);
 }
 #endif
@@ -12,6 +14,7 @@ _malloc_r (struct _reent *r, size_t sz)
 _PTR 
 _calloc_r (struct _reent *r, size_t a, size_t b)
 {
+  __A_VARIABLE = 1;
   return calloc (a, b);
 }
 #endif
@@ -21,6 +24,7 @@ void
 _free_r (struct _reent *r, _PTR x)
 {
   free (x);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -28,6 +32,7 @@ _free_r (struct _reent *r, _PTR x)
 _PTR 
 _realloc_r (struct _reent *r, _PTR x, size_t sz)
 {
+  __A_VARIABLE = 1;
   return realloc (x, sz);
 }
 #endif
diff --git a/newlib/libc/machine/xstormy16/tiny-malloc.c b/newlib/libc/machine/xstormy16/tiny-malloc.c
index 597e389..2aca676 100644
--- a/newlib/libc/machine/xstormy16/tiny-malloc.c
+++ b/newlib/libc/machine/xstormy16/tiny-malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A replacement malloc with:
    - Much reduced code size;
    - Smaller RAM footprint;
@@ -278,8 +279,10 @@ realloc (void *block_p, size_t sz)
   size_t real_size = REAL_SIZE (sz);
   size_t old_real_size;
 
-  if (block_p == NULL)
+  if (block_p == NULL) {
+    __A_VARIABLE = 1;
     return malloc (sz);
+  }
 
   old_real_size = block->size;
 
@@ -291,10 +294,13 @@ realloc (void *block_p, size_t sz)
       
       /* Need to allocate, copy, and free.  */
       result = malloc (sz);
-      if (result == NULL)
+      if (result == NULL) {
+	__A_VARIABLE = 1;
 	return NULL;
+      }
       memcpy (result, block_p, old_size < sz ? old_size : sz);
       free (block_p);
+      __A_VARIABLE = 1;
       return result;
     }
   /* Perhaps we can free some space.  */
@@ -305,6 +311,7 @@ realloc (void *block_p, size_t sz)
       newblock->size = old_real_size - real_size;
       free (&newblock->next);
     }
+  __A_VARIABLE = 1;
   return block_p;
 }
 #endif
@@ -318,6 +325,7 @@ calloc (size_t n, size_t elem_size)
   result = malloc (sz);
   if (result != NULL)
     memset (result, 0, sz);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -327,6 +335,7 @@ void
 cfree (void *p)
 {
   free (p);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -496,6 +505,7 @@ memalign (size_t align, size_t sz)
 void *
 valloc (size_t sz)
 {
+  __A_VARIABLE = 1;
   return memalign (128, sz);
 }
 #endif
@@ -503,6 +513,7 @@ valloc (size_t sz)
 void *
 pvalloc (size_t sz)
 {
+  __A_VARIABLE = 1;
   return memalign (128, sz + M_ALIGN (sz, 128));
 }
 #endif
@@ -553,6 +564,7 @@ mallinfo (void)
   r.fordblks = free_size;
   r.uordblks = total_size - free_size;
   r.ordblks = free_blocks;
+  __A_VARIABLE = 1;
   return r;
 }
 #endif
@@ -576,6 +588,7 @@ malloc_stats(void)
   fprintf (fp, "of which %u bytes are at the end of the reserved space\n",
 	   i.keepcost);
   fprintf (fp, "and %u bytes are in use.\n", i.uordblks);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -584,6 +597,7 @@ size_t
 malloc_usable_size (void *block_p)
 {
   fle block = (fle)((size_t) block_p - offsetof (struct freelist_entry, next));
+  __A_VARIABLE = 1;
   return block->size - sizeof (size_t);
 }
 #endif
@@ -593,6 +607,7 @@ int
 mallopt (int n, int v)
 {
   (void)n; (void)v;
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif
diff --git a/newlib/libc/misc/__dprintf.c b/newlib/libc/misc/__dprintf.c
index eba45ea..0ac1da8 100644
--- a/newlib/libc/misc/__dprintf.c
+++ b/newlib/libc/misc/__dprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Debugging printf, for debugging the library itself.
 
    We don't assume stdio is working.
@@ -149,6 +150,7 @@ __dprintf (fmt, va_alist)
     }
 
   va_end (args);
+  __A_VARIABLE = 1;
 }
 
 #if 0
@@ -191,6 +193,7 @@ _DEFUN(get_number, (s, size, unsigned_p),
       x = *p;
       if (!unsigned_p)
 	x = (x ^ 0x80) - 0x80;
+      __A_VARIABLE = 1;
       return x;
     case 2 :
       if (big_endian_p)
@@ -199,6 +202,7 @@ _DEFUN(get_number, (s, size, unsigned_p),
 	x = (p[1] << 8) | p[0];
       if (!unsigned_p)
 	x = (x ^ 0x8000) - 0x8000;
+      __A_VARIABLE = 1;
       return x;
     case 4 :
       if (big_endian_p)
@@ -207,12 +211,14 @@ _DEFUN(get_number, (s, size, unsigned_p),
 	x = ((long)p[3] << 24) | ((long)p[2] << 16) | (p[1] << 8) | p[0];
       if (!unsigned_p)
 	x = (x ^ 0x80000000L) - 0x80000000L;
+      __A_VARIABLE = 1;
       return x;
 #if 0 /* FIXME: Is there a standard mechanism for knowing if
 	 long longs exist?  */
     case 8 :
 #endif
     default :
+      __A_VARIABLE = 1;
       return 0;
   }
 }
@@ -247,6 +253,7 @@ _DEFUN(print_number, (base, unsigned_p, n),
   while (x != 0);
 
   write_string (p);
+  __A_VARIABLE = 1;
 }
 
 /* Write C to the console.
@@ -258,6 +265,7 @@ _DEFUN(write_char, (c),
      char c)
 {
   _write_r (_REENT, CONSOLE_FD, &c, 1);
+  __A_VARIABLE = 1;
 }
 
 /* Write S to the console.
@@ -269,4 +277,5 @@ _DEFUN(write_string, (s),
      _CONST char *s)
 {
   _write_r (_REENT, CONSOLE_FD, s, strlen (s));
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/misc/ffs.c b/newlib/libc/misc/ffs.c
index ba57009..3ee7518 100644
--- a/newlib/libc/misc/ffs.c
+++ b/newlib/libc/misc/ffs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<ffs>>---find first bit set in a word
@@ -32,5 +33,6 @@ int
 ffs(int i)
 {
 
+	__A_VARIABLE = 1;
 	return (__builtin_ffs(i));
 }
diff --git a/newlib/libc/misc/fini.c b/newlib/libc/misc/fini.c
index ab4203b..abc288d 100644
--- a/newlib/libc/misc/fini.c
+++ b/newlib/libc/misc/fini.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2010 CodeSourcery, Inc.
  *
@@ -31,5 +32,6 @@ __libc_fini_array (void)
     __fini_array_start[i-1] ();
 
   _fini ();
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/misc/init.c b/newlib/libc/misc/init.c
index c85d602..f95e240 100644
--- a/newlib/libc/misc/init.c
+++ b/newlib/libc/misc/init.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2004 CodeSourcery, LLC
  *
@@ -39,5 +40,6 @@ __libc_init_array (void)
   count = __init_array_end - __init_array_start;
   for (i = 0; i < count; i++)
     __init_array_start[i] ();
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/misc/lock.c b/newlib/libc/misc/lock.c
index a763176..f570024 100644
--- a/newlib/libc/misc/lock.c
+++ b/newlib/libc/misc/lock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<__retarget_lock_init>>, <<__retarget_lock_init_recursive>>, <<__retarget_lock_close>>, <<__retarget_lock_close_recursive>>, <<__retarget_lock_acquire>>, <<__retarget_lock_acquire_recursive>>, <<__retarget_lock_try_acquire>>, <<__retarget_lock_try_acquire_recursive>>, <<__retarget_lock_release>>, <<__retarget_lock_release_recursive>>---locking routines
@@ -105,53 +106,63 @@ struct __lock __lock___arc4random_mutex;
 void
 __retarget_lock_init (_LOCK_T *lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_init_recursive(_LOCK_T *lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_close(_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_close_recursive(_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_acquire (_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_acquire_recursive (_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 int
 __retarget_lock_try_acquire(_LOCK_T lock)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int
 __retarget_lock_try_acquire_recursive(_LOCK_T lock)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 void
 __retarget_lock_release (_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __retarget_lock_release_recursive (_LOCK_T lock)
 {
+	__A_VARIABLE = 1;
 }
 
 #endif /* !defined(__SINGLE_THREAD__) */
diff --git a/newlib/libc/misc/unctrl.c b/newlib/libc/misc/unctrl.c
index fa0b90f..cd6dd5d 100644
--- a/newlib/libc/misc/unctrl.c
+++ b/newlib/libc/misc/unctrl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<unctrl>>---get printable representation of a character
diff --git a/newlib/libc/posix/_isatty.c b/newlib/libc/posix/_isatty.c
index 7d6ccae..7fcdd38 100644
--- a/newlib/libc/posix/_isatty.c
+++ b/newlib/libc/posix/_isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c */
 
 /* Dumb implementation so programs will at least run.  */
@@ -12,10 +13,14 @@ _DEFUN(_isatty, (fd), int fd)
 
   if (fstat (fd, &buf) < 0) {
     errno = EBADF;
+    __A_VARIABLE = 1;
     return 0;
   }
-  if (S_ISCHR (buf.st_mode))
+  if (S_ISCHR (buf.st_mode)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
   errno = ENOTTY;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/posix/closedir.c b/newlib/libc/posix/closedir.c
index 7801da0..33bd1a5 100644
--- a/newlib/libc/posix/closedir.c
+++ b/newlib/libc/posix/closedir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -65,6 +66,7 @@ _DEFUN(closedir, (dirp),
 	__lock_close_recursive(dirp->dd_lock);
 #endif
 	free((void *)dirp);
+	__A_VARIABLE = 1;
 	return rc;
 }
 
diff --git a/newlib/libc/posix/collate.c b/newlib/libc/posix/collate.c
index 8bb04ef..1b8c472 100644
--- a/newlib/libc/posix/collate.c
+++ b/newlib/libc/posix/collate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1995 Alex Tatmanjants <alex@elvisti.kiev.ua>
  *		at Electronni Visti IA, Kiev, Ukraine.
@@ -69,12 +70,16 @@ __collate_load_tables(encoding)
 	__collate_load_error = 1;
 	if (!encoding) {
 		__collate_load_error = save_load_error;
+		__A_VARIABLE = 1;
 		return -1;
 	}
-	if (!strcmp(encoding, "C") || !strcmp(encoding, "POSIX"))
+	if (!strcmp(encoding, "C") || !strcmp(encoding, "POSIX")) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 	if (!_PathLocale) {
 		__collate_load_error = save_load_error;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 	/* Range checking not needed, encoding has fixed size */
@@ -84,11 +89,13 @@ __collate_load_tables(encoding)
 	(void) strcat(buf, "/LC_COLLATE");
 	if ((fp = fopen(buf, "r")) == NULL) {
 		__collate_load_error = save_load_error;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 	FREAD(__collate_version, sizeof(__collate_version), 1, fp);
 	if (strcmp(__collate_version, COLLATE_VERSION) != 0) {
 		fclose(fp);
+		__A_VARIABLE = 1;
 		return -1;
 	}
 	FREAD(__collate_substitute_table, sizeof(__collate_substitute_table),
@@ -109,6 +116,7 @@ __collate_load_tables(encoding)
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -120,8 +128,10 @@ __collate_substitute(s)
 	int delta = strlen((const char *) s);
 	u_char *dest_str = NULL;
 
-	if(s == NULL || *s == '\0')
+	if(s == NULL || *s == '\0') {
+		__A_VARIABLE = 1;
 		return __collate_strdup((u_char *) "");
+	}
 	delta += delta / 8;
 	dest_str = (u_char *) malloc(dest_len = delta);
 	if(dest_str == NULL)
@@ -139,6 +149,7 @@ __collate_substitute(s)
 		       (const char *) __collate_substitute_table[*s++]);
 		len = nlen;
 	}
+	__A_VARIABLE = 1;
 	return dest_str;
 }
 
@@ -157,11 +168,13 @@ __collate_lookup(t, len, prim, sec)
 			*len = strlen((const char *) p2->str);
 			*prim = p2->prim;
 			*sec = p2->sec;
+			__A_VARIABLE = 1;
 			return;
 		}
 	}
 	*prim = __collate_char_pri_table[*t].prim;
 	*sec = __collate_char_pri_table[*t].sec;
+	__A_VARIABLE = 1;
 }
 
 u_char *
@@ -172,6 +185,7 @@ __collate_strdup(s)
 
 	if (t == NULL)
 		__collate_err(EX_OSERR, __FUNCTION__);
+	__A_VARIABLE = 1;
 	return t;
 }
 
@@ -190,6 +204,7 @@ __collate_err(int ex, const char *f)
 	write(STDERR_FILENO, s, strlen(s));
 	write(STDERR_FILENO, "\n", 1);
 	exit(ex);
+	__A_VARIABLE = 1;
 }
 
 #ifdef COLLATE_DEBUG
@@ -211,5 +226,6 @@ __collate_print_tables()
 	for (i = 0; i < UCHAR_MAX + 1; i++)
 		printf("\t'%c' : %d %d\n", i, __collate_char_pri_table[i].prim,
 		       __collate_char_pri_table[i].sec);
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/posix/collcmp.c b/newlib/libc/posix/collcmp.c
index 7770897..df41b2a 100644
--- a/newlib/libc/posix/collcmp.c
+++ b/newlib/libc/posix/collcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 1996 by Andrey A. Chernov, Moscow, Russia.
  * All rights reserved.
diff --git a/newlib/libc/posix/creat.c b/newlib/libc/posix/creat.c
index b8a4f9a..ab6d12a 100644
--- a/newlib/libc/posix/creat.c
+++ b/newlib/libc/posix/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* creat() "system call" */
 
 /* This is needed by f2c and therefore the SPEC benchmarks.  */
@@ -9,5 +10,6 @@ _DEFUN(creat, (path, mode),
        const char *path _AND 
        mode_t mode)
 {
+  __A_VARIABLE = 1;
   return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
 }
diff --git a/newlib/libc/posix/engine.c b/newlib/libc/posix/engine.c
index c80834a..140e1d1 100644
--- a/newlib/libc/posix/engine.c
+++ b/newlib/libc/posix/engine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993, 1994 Henry Spencer.
  * Copyright (c) 1992, 1993, 1994
diff --git a/newlib/libc/posix/execl.c b/newlib/libc/posix/execl.c
index ebb97fb..5e3359d 100644
--- a/newlib/libc/posix/execl.c
+++ b/newlib/libc/posix/execl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execl.c */
@@ -47,6 +48,7 @@ _DEFUN(execl, (path, arg0, va_alist),
   while (argv[i++] != NULL);
   va_end (args);
 
+  __A_VARIABLE = 1;
   return _execve (path, (char * _CONST  *) argv, *p_environ);
 }
 #endif /* !_NO_EXECVE  */
diff --git a/newlib/libc/posix/execle.c b/newlib/libc/posix/execle.c
index 2b22036..cb0cb89 100644
--- a/newlib/libc/posix/execle.c
+++ b/newlib/libc/posix/execle.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execle.c */
diff --git a/newlib/libc/posix/execlp.c b/newlib/libc/posix/execlp.c
index 6212da6..4afbcff 100644
--- a/newlib/libc/posix/execlp.c
+++ b/newlib/libc/posix/execlp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execlp.c */
@@ -42,6 +43,7 @@ _DEFUN(execlp, (path, arg0, va_alist),
   while (argv[i++] != NULL);
   va_end (args);
 
+  __A_VARIABLE = 1;
   return execvp (path, (char * _CONST *) argv);
 }
 
diff --git a/newlib/libc/posix/execv.c b/newlib/libc/posix/execv.c
index 8793e2e..44c3a90 100644
--- a/newlib/libc/posix/execv.c
+++ b/newlib/libc/posix/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execv.c */
@@ -18,6 +19,7 @@ _DEFUN (execv, (path, argv),
 	const char *path _AND
 	char * const argv[])
 {
+  __A_VARIABLE = 1;
   return _execve (path, (char * _CONST *) argv, *p_environ);
 }
 
diff --git a/newlib/libc/posix/execve.c b/newlib/libc/posix/execve.c
index d135513..60f1cf7 100644
--- a/newlib/libc/posix/execve.c
+++ b/newlib/libc/posix/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execve.c */
@@ -15,6 +16,7 @@ _DEFUN(execve, (path, argv, envp),
       char * const argv[] _AND
       char * const envp[])
 {
+  __A_VARIABLE = 1;
   return _execve (path, argv, envp);
 }
 
diff --git a/newlib/libc/posix/execvp.c b/newlib/libc/posix/execvp.c
index 64310f6..e491982 100644
--- a/newlib/libc/posix/execvp.c
+++ b/newlib/libc/posix/execvp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_EXECVE
 
 /* execvp.c */
@@ -32,6 +33,7 @@ _DEFUN (strccpy, (s1, s2, c),
     *s1++ = *s2++;
   *s1 = 0;
 
+  __A_VARIABLE = 1;
   return dest;
 }
 
@@ -44,13 +46,17 @@ _DEFUN (execvp, (file, argv),
   char buf[MAXNAMLEN];
 
   /* If $PATH doesn't exist, just pass FILE on unchanged.  */
-  if (!path)
+  if (!path) {
+    __A_VARIABLE = 1;
     return execv (file, argv);
+  }
 
   /* If FILE contains a directory, don't search $PATH.  */
   if (strchr (file, '/')
-      )
+      ) {
+    __A_VARIABLE = 1;
     return execv (file, argv);
+  }
 
   while (*path)
     {
@@ -59,14 +65,17 @@ _DEFUN (execvp, (file, argv),
       if (*buf != 0 && buf[strlen(buf) - 1] != '/')
 	strcat (buf, "/");
       strcat (buf, file);
-      if (execv (buf, argv) == -1 && errno != ENOENT)
+      if (execv (buf, argv) == -1 && errno != ENOENT) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       while (*path && *path != PATH_DELIM)
 	path++;
       if (*path == PATH_DELIM)
 	path++;			/* skip over delim */
     }
 
+  __A_VARIABLE = 1;
   return -1;
 }
 
diff --git a/newlib/libc/posix/fnmatch.c b/newlib/libc/posix/fnmatch.c
index 1a679ab..34ccc35 100644
--- a/newlib/libc/posix/fnmatch.c
+++ b/newlib/libc/posix/fnmatch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1989, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
diff --git a/newlib/libc/posix/glob.c b/newlib/libc/posix/glob.c
index 5e6c2fc..0d8f4cc 100644
--- a/newlib/libc/posix/glob.c
+++ b/newlib/libc/posix/glob.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -224,13 +225,18 @@ globexp1(pattern, pglob, limit)
 	int rv;
 
 	/* Protect a single {}, for find(1), like csh */
-	if (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)
+	if (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS) {
+		__A_VARIABLE = 1;
 		return glob0(pattern, pglob, limit);
+	}
 
 	while ((ptr = (const Char *) g_strchr((Char *) ptr, LBRACE)) != NULL)
-		if (!globexp2(ptr, pattern, pglob, &rv, limit))
+		if (!globexp2(ptr, pattern, pglob, &rv, limit)) {
+			__A_VARIABLE = 1;
 			return rv;
+		}
 
+	__A_VARIABLE = 1;
 	return glob0(pattern, pglob, limit);
 }
 
@@ -282,6 +288,7 @@ globexp2(ptr, pattern, pglob, rv, limit)
 	/* Non matching braces; just glob the pattern */
 	if (i != 0 || *pe == EOS) {
 		*rv = glob0(patbuf, pglob, limit);
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -339,6 +346,7 @@ globexp2(ptr, pattern, pglob, rv, limit)
 			break;
 		}
 	*rv = 0;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -517,6 +525,7 @@ static int
 compare(p, q)
 	const void *p, *q;
 {
+	__A_VARIABLE = 1;
 	return(strcmp(*(char **)p, *(char **)q));
 }
 
@@ -529,8 +538,11 @@ glob1(pattern, pglob, limit)
 	Char pathbuf[MAXPATHLEN];
 
 	/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */
-	if (*pattern == EOS)
+	if (*pattern == EOS) {
+		__A_VARIABLE = 1;
 		return(0);
+	}
+	__A_VARIABLE = 1;
 	return(glob2(pathbuf, pathbuf, pathbuf + MAXPATHLEN - 1,
 	    pattern, pglob, limit));
 }
@@ -619,20 +631,27 @@ glob3(pathbuf, pathend, pathend_last, pattern, restpattern, pglob, limit)
 	 */
 	struct dirent *(*readdirfunc)();
 
-	if (pathend > pathend_last)
+	if (pathend > pathend_last) {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 	*pathend = EOS;
 	errno = 0;
 
 	if ((dirp = g_opendir(pathbuf, pglob)) == NULL) {
 		/* TODO: don't call for ENOENT or ENOTDIR? */
 		if (pglob->gl_errfunc) {
-			if (g_Ctoc(pathbuf, buf, sizeof(buf)))
+			if (g_Ctoc(pathbuf, buf, sizeof(buf))) {
+				__A_VARIABLE = 1;
 				return (GLOB_ABEND);
+			}
 			if (pglob->gl_errfunc(buf, errno) ||
-			    pglob->gl_flags & GLOB_ERR)
+			    pglob->gl_flags & GLOB_ERR) {
+				__A_VARIABLE = 1;
 				return (GLOB_ABEND);
+			}
 		}
+		__A_VARIABLE = 1;
 		return(0);
 	}
 
@@ -668,6 +687,7 @@ glob3(pathbuf, pathend, pathend_last, pattern, restpattern, pglob, limit)
 		(*pglob->gl_closedir)(dirp);
 	else
 		closedir(dirp);
+	__A_VARIABLE = 1;
 	return(err);
 }
 
@@ -700,6 +720,7 @@ globextend(path, pglob, limit)
 
 	if (*limit && pglob->gl_pathc > *limit) {
 		errno = 0;
+		__A_VARIABLE = 1;
 		return (GLOB_NOSPACE);
 	}
 
@@ -712,6 +733,7 @@ globextend(path, pglob, limit)
 			free(pglob->gl_pathv);
 			pglob->gl_pathv = NULL;
 		}
+		__A_VARIABLE = 1;
 		return(GLOB_NOSPACE);
 	}
 
@@ -729,11 +751,13 @@ globextend(path, pglob, limit)
 	if ((copy = malloc(len)) != NULL) {
 		if (g_Ctoc(path, copy, len)) {
 			free(copy);
+			__A_VARIABLE = 1;
 			return (GLOB_NOSPACE);
 		}
 		pathv[pglob->gl_offs + pglob->gl_pathc++] = copy;
 	}
 	pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
+	__A_VARIABLE = 1;
 	return(copy == NULL ? GLOB_NOSPACE : 0);
 }
 
@@ -752,21 +776,30 @@ match(name, pat, patend)
 		c = *pat++;
 		switch (c & M_MASK) {
 		case M_ALL:
-			if (pat == patend)
+			if (pat == patend) {
+				__A_VARIABLE = 1;
 				return(1);
+			}
 			do
-			    if (match(name, pat, patend))
+			    if (match(name, pat, patend)) {
+				    __A_VARIABLE = 1;
 				    return(1);
+			}
 			while (*name++ != EOS);
+			__A_VARIABLE = 1;
 			return(0);
 		case M_ONE:
-			if (*name++ == EOS)
+			if (*name++ == EOS) {
+				__A_VARIABLE = 1;
 				return(0);
+			}
 			break;
 		case M_SET:
 			ok = 0;
-			if ((k = *name++) == EOS)
+			if ((k = *name++) == EOS) {
+				__A_VARIABLE = 1;
 				return(0);
+			}
 			if ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)
 				++pat;
 			while (((c = *pat++) & M_MASK) != M_END)
@@ -780,15 +813,20 @@ match(name, pat, patend)
 					pat += 2;
 				} else if (c == k)
 					ok = 1;
-			if (ok == negate_range)
+			if (ok == negate_range) {
+				__A_VARIABLE = 1;
 				return(0);
+			}
 			break;
 		default:
-			if (*name++ != c)
+			if (*name++ != c) {
+				__A_VARIABLE = 1;
 				return(0);
+			}
 			break;
 		}
 	}
+	__A_VARIABLE = 1;
 	return(*name == EOS);
 }
 
@@ -808,6 +846,7 @@ globfree(pglob)
 		free(pglob->gl_pathv);
 		pglob->gl_pathv = NULL;
 	}
+	__A_VARIABLE = 1;
 }
 
 static DIR *
@@ -840,10 +879,14 @@ g_lstat(fn, sb, pglob)
 
 	if (g_Ctoc(fn, buf, sizeof(buf))) {
 		errno = ENAMETOOLONG;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
-	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
+	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
+		__A_VARIABLE = 1;
 		return((*pglob->gl_lstat)(buf, sb));
+	}
+	__A_VARIABLE = 1;
 	return(lstat(buf, sb));
 }
 
@@ -857,10 +900,14 @@ g_stat(fn, sb, pglob)
 
 	if (g_Ctoc(fn, buf, sizeof(buf))) {
 		errno = ENAMETOOLONG;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
-	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
+	if (pglob->gl_flags & GLOB_ALTDIRFUNC) {
+		__A_VARIABLE = 1;
 		return((*pglob->gl_stat)(buf, sb));
+	}
+	__A_VARIABLE = 1;
 	return(stat(buf, sb));
 }
 
@@ -870,9 +917,12 @@ g_strchr(str, ch)
 	int ch;
 {
 	do {
-		if (*str == ch)
+		if (*str == ch) {
+			__A_VARIABLE = 1;
 			return (str);
+		}
 	} while (*str++);
+	__A_VARIABLE = 1;
 	return (NULL);
 }
 
@@ -884,9 +934,12 @@ g_Ctoc(str, buf, len)
 {
 
 	while (len--) {
-		if ((*buf++ = *str++) == '\0')
+		if ((*buf++ = *str++) == '\0') {
+			__A_VARIABLE = 1;
 			return (0);
+		}
 	}
+	__A_VARIABLE = 1;
 	return (1);
 }
 
@@ -908,6 +961,7 @@ qprintf(str, s)
 	for (p = s; *p; p++)
 		(void)printf("%c", ismeta(*p) ? '_' : ' ');
 	(void)printf("\n");
+	__A_VARIABLE = 1;
 }
 #endif
 #endif /*  !_NO_GLOB */
diff --git a/newlib/libc/posix/isatty.c b/newlib/libc/posix/isatty.c
index afd5ec8..f2bbcd8 100644
--- a/newlib/libc/posix/isatty.c
+++ b/newlib/libc/posix/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c */
 
 #include <unistd.h>
@@ -6,5 +7,6 @@
 int
 _DEFUN(isatty, (fd), int fd)
 {
+  __A_VARIABLE = 1;
   return _isatty (fd);
 }
diff --git a/newlib/libc/posix/opendir.c b/newlib/libc/posix/opendir.c
index ca764e1..70fc08a 100644
--- a/newlib/libc/posix/opendir.c
+++ b/newlib/libc/posix/opendir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -54,14 +55,17 @@ _DEFUN(opendir, (name),
 	register int fd;
 	int rc = 0;
 
-	if ((fd = open(name, 0)) == -1)
+	if ((fd = open(name, 0)) == -1) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 #ifdef HAVE_FCNTL
 	rc = fcntl(fd, F_SETFD, 1);
 #endif
 	if (rc == -1 ||
 	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	/*
@@ -76,6 +80,7 @@ _DEFUN(opendir, (name),
 	if (dirp->dd_buf == NULL) {
 		free (dirp);
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	dirp->dd_fd = fd;
@@ -90,6 +95,7 @@ _DEFUN(opendir, (name),
 	__lock_init_recursive(dirp->dd_lock);
 #endif
 
+	__A_VARIABLE = 1;
 	return dirp;
 }
 
diff --git a/newlib/libc/posix/popen.c b/newlib/libc/posix/popen.c
index faf72b6..d6123df 100644
--- a/newlib/libc/posix/popen.c
+++ b/newlib/libc/posix/popen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: popen.c,v 1.11 1995/06/16 07:05:33 jtc Exp $	*/
 
 /*
@@ -124,14 +125,18 @@ _DEFUN(popen, (program, type),
 #endif
 			       )) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 
-	if ((cur = malloc(sizeof(struct pid))) == NULL)
+	if ((cur = malloc(sizeof(struct pid))) == NULL) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 
 	if (pipe(pdes) < 0) {
 		free(cur);
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 
@@ -140,6 +145,7 @@ _DEFUN(popen, (program, type),
 		(void)close(pdes[0]);
 		(void)close(pdes[1]);
 		free(cur);
+		__A_VARIABLE = 1;
 		return (NULL);
 		/* NOTREACHED */
 	case 0:				/* Child. */
@@ -188,6 +194,7 @@ _DEFUN(popen, (program, type),
 	cur->next = pidlist;
 	pidlist = cur;
 
+	__A_VARIABLE = 1;
 	return (iop);
 }
 
@@ -210,8 +217,10 @@ _DEFUN(pclose, (iop),
 	for (last = NULL, cur = pidlist; cur; last = cur, cur = cur->next)
 		if (cur->fp == iop)
 			break;
-	if (cur == NULL)
+	if (cur == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 	do {
 		pid = waitpid(cur->pid, &pstat, 0);
@@ -224,6 +233,7 @@ _DEFUN(pclose, (iop),
 		last->next = cur->next;
 	free(cur);
 
+	__A_VARIABLE = 1;
 	return (pid == -1 ? -1 : pstat);
 }
 
diff --git a/newlib/libc/posix/posix_spawn.c b/newlib/libc/posix/posix_spawn.c
index e5655e2..75fc304 100644
--- a/newlib/libc/posix/posix_spawn.c
+++ b/newlib/libc/posix/posix_spawn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2008 Ed Schouten <ed@FreeBSD.org>
  * All rights reserved.
@@ -248,9 +249,12 @@ process_file_actions(_CONST posix_spawn_file_actions_t fa)
 	/* Replay all file descriptor modifications */
 	STAILQ_FOREACH(fae, &fa->fa_list, fae_list) {
 		error = process_file_actions_entry(fae);
-		if (error)
+		if (error) {
+			__A_VARIABLE = 1;
 			return (error);
+		}
 	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -266,6 +270,7 @@ do_posix_spawn(pid_t *pid, _CONST char *path,
 	p = vfork();
 	switch (p) {
 	case -1:
+		__A_VARIABLE = 1;
 		return (errno);
 	case 0:
 		if (sa != NULL) {
@@ -289,6 +294,7 @@ do_posix_spawn(pid_t *pid, _CONST char *path,
 			waitpid(p, NULL, WNOHANG);
 		else if (pid != NULL)
 			*pid = p;
+		__A_VARIABLE = 1;
 		return (error);
 	}
 }
@@ -302,6 +308,7 @@ _DEFUN(posix_spawn, (pid, path, fa, sa, argv, envp),
 	char * _CONST argv[] _AND
 	char * _CONST envp[])
 {
+	__A_VARIABLE = 1;
 	return do_posix_spawn(pid, path, fa, sa, argv, envp, 0);
 }
 
@@ -314,6 +321,7 @@ _DEFUN(posix_spawnp, (pid, path, fa, sa, argv, envp),
 	char * _CONST argv[] _AND
 	char * _CONST envp[])
 {
+	__A_VARIABLE = 1;
 	return do_posix_spawn(pid, path, fa, sa, argv, envp, 1);
 }
 
@@ -328,11 +336,14 @@ _DEFUN(posix_spawn_file_actions_init, (ret),
 	posix_spawn_file_actions_t fa;
 
 	fa = malloc(sizeof(struct __posix_spawn_file_actions));
-	if (fa == NULL)
+	if (fa == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 	STAILQ_INIT(&fa->fa_list);
 	*ret = fa;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -353,6 +364,7 @@ _DEFUN(posix_spawn_file_actions_destroy, (fa),
 	}
 
 	free(*fa);
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -367,13 +379,17 @@ _DEFUN(posix_spawn_file_actions_addopen, (fa, fildes, path, oflag, mode),
 	posix_spawn_file_actions_entry_t *fae;
 	int error;
 
-	if (fildes < 0)
+	if (fildes < 0) {
+		__A_VARIABLE = 1;
 		return (EBADF);
+	}
 
 	/* Allocate object */
 	fae = malloc(sizeof(posix_spawn_file_actions_entry_t));
-	if (fae == NULL)
+	if (fae == NULL) {
+		__A_VARIABLE = 1;
 		return (errno);
+	}
 
 	/* Set values and store in queue */
 	fae->fae_action = FAE_OPEN;
@@ -381,6 +397,7 @@ _DEFUN(posix_spawn_file_actions_addopen, (fa, fildes, path, oflag, mode),
 	if (fae->fae_path == NULL) {
 		error = errno;
 		free(fae);
+		__A_VARIABLE = 1;
 		return (error);
 	}
 	fae->fae_fildes = fildes;
@@ -388,6 +405,7 @@ _DEFUN(posix_spawn_file_actions_addopen, (fa, fildes, path, oflag, mode),
 	fae->fae_mode = mode;
 
 	STAILQ_INSERT_TAIL(&(*fa)->fa_list, fae, fae_list);
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -399,13 +417,17 @@ _DEFUN(posix_spawn_file_actions_adddup2, (fa, fildes, newfildes),
 {
 	posix_spawn_file_actions_entry_t *fae;
 
-	if (fildes < 0 || newfildes < 0)
+	if (fildes < 0 || newfildes < 0) {
+		__A_VARIABLE = 1;
 		return (EBADF);
+	}
 
 	/* Allocate object */
 	fae = malloc(sizeof(posix_spawn_file_actions_entry_t));
-	if (fae == NULL)
+	if (fae == NULL) {
+		__A_VARIABLE = 1;
 		return (errno);
+	}
 
 	/* Set values and store in queue */
 	fae->fae_action = FAE_DUP2;
@@ -413,6 +435,7 @@ _DEFUN(posix_spawn_file_actions_adddup2, (fa, fildes, newfildes),
 	fae->fae_newfildes = newfildes;
 
 	STAILQ_INSERT_TAIL(&(*fa)->fa_list, fae, fae_list);
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -423,19 +446,24 @@ _DEFUN(posix_spawn_file_actions_addclose, (fa, fildes),
 {
 	posix_spawn_file_actions_entry_t *fae;
 
-	if (fildes < 0)
+	if (fildes < 0) {
+		__A_VARIABLE = 1;
 		return (EBADF);
+	}
 
 	/* Allocate object */
 	fae = malloc(sizeof(posix_spawn_file_actions_entry_t));
-	if (fae == NULL)
+	if (fae == NULL) {
+		__A_VARIABLE = 1;
 		return (errno);
+	}
 
 	/* Set values and store in queue */
 	fae->fae_action = FAE_CLOSE;
 	fae->fae_fildes = fildes;
 
 	STAILQ_INSERT_TAIL(&(*fa)->fa_list, fae, fae_list);
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -450,11 +478,14 @@ _DEFUN(posix_spawnattr_init, (ret),
 	posix_spawnattr_t sa;
 
 	sa = calloc(1, sizeof(struct __posix_spawnattr));
-	if (sa == NULL)
+	if (sa == NULL) {
+		__A_VARIABLE = 1;
 		return (errno);
+	}
 
 	/* Set defaults as specified by POSIX, cleared above */
 	*ret = sa;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -463,6 +494,7 @@ _DEFUN(posix_spawnattr_destroy, (sa),
 	posix_spawnattr_t *sa)
 {
 	free(*sa);
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -472,6 +504,7 @@ _DEFUN(posix_spawnattr_getflags, (sa, flags),
 	short * __restrict flags)
 {
 	*flags = (*sa)->sa_flags;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -481,6 +514,7 @@ _DEFUN(posix_spawnattr_getpgroup, (sa, pgroup),
 	pid_t * __restrict pgroup)
 {
 	*pgroup = (*sa)->sa_pgroup;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -490,6 +524,7 @@ _DEFUN(posix_spawnattr_getschedparam, (sa, schedparam),
 	struct sched_param * __restrict schedparam)
 {
 	*schedparam = (*sa)->sa_schedparam;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -499,6 +534,7 @@ _DEFUN(posix_spawnattr_getschedpolicy, (sa, schedpolicy),
 	int * __restrict schedpolicy)
 {
 	*schedpolicy = (*sa)->sa_schedpolicy;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -508,6 +544,7 @@ _DEFUN(posix_spawnattr_getsigdefault, (sa, sigdefault),
 	sigset_t * __restrict sigdefault)
 {
 	*sigdefault = (*sa)->sa_sigdefault;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -517,6 +554,7 @@ _DEFUN(posix_spawnattr_getsigmask, (sa, sigmask),
 	sigset_t * __restrict sigmask)
 {
 	*sigmask = (*sa)->sa_sigmask;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -526,6 +564,7 @@ _DEFUN(posix_spawnattr_setflags, (sa, flags),
 	short flags)
 {
 	(*sa)->sa_flags = flags;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -535,6 +574,7 @@ _DEFUN(posix_spawnattr_setpgroup, (sa, pgroup),
 	pid_t pgroup)
 {
 	(*sa)->sa_pgroup = pgroup;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -544,6 +584,7 @@ _DEFUN(posix_spawnattr_setschedparam, (sa, schedparam),
 	_CONST struct sched_param * __restrict schedparam)
 {
 	(*sa)->sa_schedparam = *schedparam;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -553,6 +594,7 @@ _DEFUN(posix_spawnattr_setschedpolicy, (sa, schedpolicy),
 	int schedpolicy)
 {
 	(*sa)->sa_schedpolicy = schedpolicy;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -562,6 +604,7 @@ _DEFUN(posix_spawnattr_setsigdefault, (sa, sigdefault),
 	_CONST sigset_t * __restrict sigdefault)
 {
 	(*sa)->sa_sigdefault = *sigdefault;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -571,6 +614,7 @@ _DEFUN(posix_spawnattr_setsigmask, (sa, sigmask),
 	_CONST sigset_t * __restrict sigmask)
 {
 	(*sa)->sa_sigmask = *sigmask;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
diff --git a/newlib/libc/posix/readdir.c b/newlib/libc/posix/readdir.c
index 3e620e3..d01f23e 100644
--- a/newlib/libc/posix/readdir.c
+++ b/newlib/libc/posix/readdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -64,6 +65,7 @@ _DEFUN(readdir, (dirp),
 #ifdef HAVE_DD_LOCK
         __lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 	return NULL;
       }
     }
@@ -77,6 +79,7 @@ _DEFUN(readdir, (dirp),
 #ifdef HAVE_DD_LOCK
       __lock_release_recursive(dirp->dd_lock);
 #endif
+      __A_VARIABLE = 1;
       return NULL;
     }
     dirp->dd_loc += dp->d_reclen;
@@ -85,8 +88,10 @@ _DEFUN(readdir, (dirp),
 #ifdef HAVE_DD_LOCK
     __lock_release_recursive(dirp->dd_lock);
 #endif
+    __A_VARIABLE = 1;
     return (dp);
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* ! HAVE_OPENDIR */
diff --git a/newlib/libc/posix/readdir_r.c b/newlib/libc/posix/readdir_r.c
index d13775b..7cfd7c7 100644
--- a/newlib/libc/posix/readdir_r.c
+++ b/newlib/libc/posix/readdir_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -72,6 +73,7 @@ struct dirent *tmpdp;
         __lock_release_recursive(dirp->dd_lock);
 #endif
         *dpp = NULL;
+        __A_VARIABLE = 1;
         return dirp->dd_size == 0 ? 0 : errno;
       }
     }
@@ -87,6 +89,7 @@ struct dirent *tmpdp;
       __lock_release_recursive(dirp->dd_lock);
 #endif
       *dpp = NULL;
+      __A_VARIABLE = 1;
       return -1;
     }
     memcpy (dp, tmpdp, MIN (tmpdp->d_reclen, sizeof (struct dirent)));
@@ -98,8 +101,10 @@ struct dirent *tmpdp;
     __lock_release_recursive(dirp->dd_lock);
 #endif
     *dpp = dp;
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
 }
 
 #endif /* ! HAVE_OPENDIR */
diff --git a/newlib/libc/posix/regcomp.c b/newlib/libc/posix/regcomp.c
index 002f978..07b76bd 100644
--- a/newlib/libc/posix/regcomp.c
+++ b/newlib/libc/posix/regcomp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993, 1994 Henry Spencer.
  * Copyright (c) 1992, 1993, 1994
diff --git a/newlib/libc/posix/regerror.c b/newlib/libc/posix/regerror.c
index a48d37c..66cad4d 100644
--- a/newlib/libc/posix/regerror.c
+++ b/newlib/libc/posix/regerror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993, 1994 Henry Spencer.
  * Copyright (c) 1992, 1993, 1994
diff --git a/newlib/libc/posix/regexec.c b/newlib/libc/posix/regexec.c
index 6e39e9e..051f7c3 100644
--- a/newlib/libc/posix/regexec.c
+++ b/newlib/libc/posix/regexec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993, 1994 Henry Spencer.
  * Copyright (c) 1992, 1993, 1994
diff --git a/newlib/libc/posix/regfree.c b/newlib/libc/posix/regfree.c
index bed8f91..6507507 100644
--- a/newlib/libc/posix/regfree.c
+++ b/newlib/libc/posix/regfree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993, 1994 Henry Spencer.
  * Copyright (c) 1992, 1993, 1994
diff --git a/newlib/libc/posix/rewinddir.c b/newlib/libc/posix/rewinddir.c
index f9ca9f7..f80911e 100644
--- a/newlib/libc/posix/rewinddir.c
+++ b/newlib/libc/posix/rewinddir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -52,6 +53,7 @@ _DEFUN(rewinddir, (dirp),
 #ifdef HAVE_DD_LOCK
 	__lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 #endif /* ! HAVE_OPENDIR */
diff --git a/newlib/libc/posix/scandir.c b/newlib/libc/posix/scandir.c
index 8cb8ff8..01cf8f8 100644
--- a/newlib/libc/posix/scandir.c
+++ b/newlib/libc/posix/scandir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -85,8 +86,10 @@ _DEFUN(scandir, (dirname, namelist, select, dcomp),
 	dirp = NULL;
 	names = NULL;
 
-	if ((dirp = opendir(dirname)) == NULL)
+	if ((dirp = opendir(dirname)) == NULL) {
+		__A_VARIABLE = 1;
 		return(-1);
+	}
 #ifdef HAVE_DD_LOCK
 	__lock_acquire_recursive(dirp->dd_lock);
 #endif
@@ -162,6 +165,7 @@ cleanup:
 #ifdef HAVE_DD_LOCK
 	__lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 	return(rc);
 }
 
@@ -173,6 +177,7 @@ _DEFUN(alphasort, (d1, d2),
        const struct dirent **d1 _AND
        const struct dirent **d2)
 {
+       __A_VARIABLE = 1;
        return(strcmp((*d1)->d_name, (*d2)->d_name));
 }
 
diff --git a/newlib/libc/posix/seekdir.c b/newlib/libc/posix/seekdir.c
index 3965eda..c316071 100644
--- a/newlib/libc/posix/seekdir.c
+++ b/newlib/libc/posix/seekdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -57,6 +58,7 @@ _DEFUN(seekdir, (dirp, loc),
 #ifdef HAVE_DD_LOCK
 	__lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 #endif /* ! HAVE_OPENDIR */
diff --git a/newlib/libc/posix/sleep.c b/newlib/libc/posix/sleep.c
index f7c780e..bf157f0 100644
--- a/newlib/libc/posix/sleep.c
+++ b/newlib/libc/posix/sleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/posix/sleep.c - sleep function */
 
 /* Written 2000 by Werner Almesberger */
@@ -14,8 +15,15 @@ unsigned sleep(unsigned seconds)
 
     ts.tv_sec = seconds;
     ts.tv_nsec = 0;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
 
diff --git a/newlib/libc/posix/telldir.c b/newlib/libc/posix/telldir.c
index 959e3b7..09dbf99 100644
--- a/newlib/libc/posix/telldir.c
+++ b/newlib/libc/posix/telldir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef HAVE_OPENDIR
 
 /*
@@ -87,8 +88,10 @@ _DEFUN(telldir, (dirp),
 	register int index;
 	register struct ddloc *lp;
 
-	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL)
+	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 #ifdef HAVE_DD_LOCK
 	__lock_acquire_recursive(dirp->dd_lock);
@@ -109,6 +112,7 @@ _DEFUN(telldir, (dirp),
 #endif
 	__lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 	return (index);
 }
 
@@ -207,5 +211,6 @@ _DEFUN(_cleanupdir, (dirp),
 	__lock_release(__dd_hash_mutex);
 #endif
 
+	__A_VARIABLE = 1;
 }
 #endif /* ! HAVE_OPENDIR */
diff --git a/newlib/libc/posix/usleep.c b/newlib/libc/posix/usleep.c
index 9322b65..0045068 100644
--- a/newlib/libc/posix/usleep.c
+++ b/newlib/libc/posix/usleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/posix/usleep.c - usleep function */
 
 /* Written 2002 by Jeff Johnston */
@@ -14,8 +15,15 @@ int usleep(useconds_t useconds)
 
     ts.tv_sec = (long int)useconds / 1000000;
     ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
 
diff --git a/newlib/libc/posix/wordexp.c b/newlib/libc/posix/wordexp.c
index 3e90c3a..0ab0969 100644
--- a/newlib/libc/posix/wordexp.c
+++ b/newlib/libc/posix/wordexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libc/posix/wordfree.c b/newlib/libc/posix/wordfree.c
index 024a619..a9bd11c 100644
--- a/newlib/libc/posix/wordfree.c
+++ b/newlib/libc/posix/wordfree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -28,11 +29,15 @@ wordfree(wordexp_t *pwordexp)
 {
   ext_wordv_t *wordv;
 
-  if (pwordexp == NULL)
+  if (pwordexp == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
 
-  if (pwordexp->we_wordv == NULL)
+  if (pwordexp->we_wordv == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   wordv = WE_WORDV_TO_EXT_WORDV(pwordexp->we_wordv);
   while (!SLIST_EMPTY(&wordv->list)) {
@@ -43,6 +48,7 @@ wordfree(wordexp_t *pwordexp)
 
   free(wordv);
   pwordexp->we_wordv = NULL;
+  __A_VARIABLE = 1;
 }
 
 #endif /* !_NO_WORDEXP  */
diff --git a/newlib/libc/reent/closer.c b/newlib/libc/reent/closer.c
index aeacebd..2c55b99 100644
--- a/newlib/libc/reent/closer.c
+++ b/newlib/libc/reent/closer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant version of close system call.  */
 
 #include <reent.h>
@@ -52,6 +53,7 @@ _close_r (ptr, fd)
   errno = 0;
   if ((ret = _close (fd)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/execr.c b/newlib/libc/reent/execr.c
index d802670..a175e70 100644
--- a/newlib/libc/reent/execr.c
+++ b/newlib/libc/reent/execr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of execution system calls.  These
    implementations just call the usual system calls.  */
 
@@ -64,6 +65,7 @@ _DEFUN (_execve_r, (ptr, name, argv, env),
   errno = 0;
   if ((ret = _execve (name, argv, env)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -102,6 +104,7 @@ _DEFUN (_fork_r, (ptr),
   errno = 0;
   if ((ret = _fork ()) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -141,6 +144,7 @@ _DEFUN (_wait_r, (ptr, status),
   errno = 0;
   if ((ret = _wait (status)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/fcntlr.c b/newlib/libc/reent/fcntlr.c
index d632d18..a9ed1e8 100644
--- a/newlib/libc/reent/fcntlr.c
+++ b/newlib/libc/reent/fcntlr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of fcntl system call.  This implementation just
    calls the fcntl system call.  */
 
@@ -59,6 +60,7 @@ _DEFUN (_fcntl_r, (ptr, fd, cmd, arg),
   errno = 0;
   if ((ret = _fcntl (fd, cmd, arg)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/fstat64r.c b/newlib/libc/reent/fstat64r.c
index 1c45897..d7efcce 100644
--- a/newlib/libc/reent/fstat64r.c
+++ b/newlib/libc/reent/fstat64r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of fstat system call.  This implementation just
    calls the fstat system call.  */
 
@@ -64,6 +65,7 @@ _DEFUN (_fstat64_r, (ptr, fd, pstat),
   errno = 0;
   if ((ret = _fstat64 (fd, pstat)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/fstatr.c b/newlib/libc/reent/fstatr.c
index 29e21cf..8652063 100644
--- a/newlib/libc/reent/fstatr.c
+++ b/newlib/libc/reent/fstatr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of fstat system call.  This implementation just
    calls the fstat system call.  */
 
@@ -65,6 +66,7 @@ _fstat_r (ptr, fd, pstat)
   memcpy(pstat, &_pstat, sizeof(*pstat));
   if (ret == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/getreent.c b/newlib/libc/reent/getreent.c
index 60ae6fb..7835165 100644
--- a/newlib/libc/reent/getreent.c
+++ b/newlib/libc/reent/getreent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* default reentrant pointer when multithread enabled */
 
 #include <_ansi.h>
@@ -10,5 +11,6 @@
 struct _reent *
 _DEFUN_VOID(__getreent)
 {
+  __A_VARIABLE = 1;
   return _impure_ptr;
 }
diff --git a/newlib/libc/reent/gettimeofdayr.c b/newlib/libc/reent/gettimeofdayr.c
index 1e49006..e548468 100644
--- a/newlib/libc/reent/gettimeofdayr.c
+++ b/newlib/libc/reent/gettimeofdayr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant version of gettimeofday system call
    This implementation just calls the times/gettimeofday system calls.
    Gettimeofday may not be available on all targets.  It's presence
@@ -77,6 +78,7 @@ _DEFUN (_gettimeofday_r, (ptr, ptimeval, ptimezone),
   ptimeval->tv_usec = _ptimeval.tv_usec;
   if (ret == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/impure.c b/newlib/libc/reent/impure.c
index f5918c8..aef448f 100644
--- a/newlib/libc/reent/impure.c
+++ b/newlib/libc/reent/impure.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 
 /* Note that there is a copy of this in sys/reent.h.  */
diff --git a/newlib/libc/reent/isattyr.c b/newlib/libc/reent/isattyr.c
index 05d47d3..a844844 100644
--- a/newlib/libc/reent/isattyr.c
+++ b/newlib/libc/reent/isattyr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of isatty system call.  */
 
 #include <reent.h>
@@ -57,6 +58,7 @@ _isatty_r (ptr, fd)
   errno = 0;
   if ((ret = _isatty (fd)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/linkr.c b/newlib/libc/reent/linkr.c
index ded636a..867dbb0 100644
--- a/newlib/libc/reent/linkr.c
+++ b/newlib/libc/reent/linkr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of file system calls.  These implementations
    just call the usual system calls.  */
 
@@ -60,6 +61,7 @@ _DEFUN (_link_r, (ptr, old, new),
   errno = 0;
   if ((ret = _link (old, new)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/lseek64r.c b/newlib/libc/reent/lseek64r.c
index 0207a12..ccc2ebe 100644
--- a/newlib/libc/reent/lseek64r.c
+++ b/newlib/libc/reent/lseek64r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of lseek system call. */
 
 #include <reent.h>
@@ -60,6 +61,7 @@ _DEFUN (_lseek64_r, (ptr, fd, pos, whence),
   errno = 0;
   if ((ret = _lseek64 (fd, pos, whence)) == (_off64_t) -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/lseekr.c b/newlib/libc/reent/lseekr.c
index fa00695..d297c11 100644
--- a/newlib/libc/reent/lseekr.c
+++ b/newlib/libc/reent/lseekr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of lseek system call. */
 
 #include <reent.h>
@@ -57,6 +58,7 @@ _DEFUN (_lseek_r, (ptr, fd, pos, whence),
   errno = 0;
   if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/mkdirr.c b/newlib/libc/reent/mkdirr.c
index fe36de1..7e4e4d1 100644
--- a/newlib/libc/reent/mkdirr.c
+++ b/newlib/libc/reent/mkdirr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of mkdir system call. */
 
 #include <reent.h>
@@ -57,6 +58,7 @@ _DEFUN (_mkdir_r, (ptr, path, mode),
   errno = 0;
   if ((ret = _mkdir (path, mode)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/open64r.c b/newlib/libc/reent/open64r.c
index 30310d3..fffb47e 100644
--- a/newlib/libc/reent/open64r.c
+++ b/newlib/libc/reent/open64r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of open system call. */
 
 #include <reent.h>
@@ -61,6 +62,7 @@ _open64_r (ptr, file, flags, mode)
   errno = 0;
   if ((ret = _open64 (file, flags, mode)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/openr.c b/newlib/libc/reent/openr.c
index 35138c6..8ee762d 100644
--- a/newlib/libc/reent/openr.c
+++ b/newlib/libc/reent/openr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of open system call. */
 
 #include <reent.h>
@@ -58,6 +59,7 @@ _DEFUN (_open_r, (ptr, file, flags, mode),
   errno = 0;
   if ((ret = _open (file, flags, mode)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/readr.c b/newlib/libc/reent/readr.c
index 38c1d9e..df01ddb 100644
--- a/newlib/libc/reent/readr.c
+++ b/newlib/libc/reent/readr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of read system call. */
 
 #include <reent.h>
@@ -57,6 +58,7 @@ _DEFUN (_read_r, (ptr, fd, buf, cnt),
   errno = 0;
   if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/reent.c b/newlib/libc/reent/reent.c
index b6c2abf..433efc5 100644
--- a/newlib/libc/reent/reent.c
+++ b/newlib/libc/reent/reent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<reent>>---definition of impure data.
@@ -39,6 +40,7 @@ _DEFUN (cleanup_glue, (ptr, glue),
     cleanup_glue (ptr, glue->_next);
 
   _free_r (ptr, glue);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -133,4 +135,5 @@ _DEFUN (_reclaim_reent, (ptr),
       /* Malloc memory not reclaimed; no good way to return memory anyway. */
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/reent/renamer.c b/newlib/libc/reent/renamer.c
index d3951a2..7b2519d 100644
--- a/newlib/libc/reent/renamer.c
+++ b/newlib/libc/reent/renamer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant version of rename system call.  */
 
 #include <reent.h>
@@ -59,15 +60,19 @@ _DEFUN (_rename_r, (ptr, old, new),
   if ((ret = _rename (old, new)) == -1 && errno != 0)
     ptr->_errno = errno;
 #else
-  if (_link_r (ptr, old, new) == -1)
+  if (_link_r (ptr, old, new) == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   if (_unlink_r (ptr, old) == -1)
     {
       /* ??? Should we unlink new? (rhetorical question) */
+      __A_VARIABLE = 1;
       return -1;
     }
 #endif
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/sbrkr.c b/newlib/libc/reent/sbrkr.c
index 44e42b5..9f659b1 100644
--- a/newlib/libc/reent/sbrkr.c
+++ b/newlib/libc/reent/sbrkr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant version of sbrk system call. */
 
 #include <reent.h>
@@ -57,6 +58,7 @@ _DEFUN (_sbrk_r, (ptr, incr),
   errno = 0;
   if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/signalr.c b/newlib/libc/reent/signalr.c
index 161d530..6024866 100644
--- a/newlib/libc/reent/signalr.c
+++ b/newlib/libc/reent/signalr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of syscalls need to support signal/raise.
    These implementations just call the usual system calls.  */
 
@@ -60,6 +61,7 @@ _DEFUN (_kill_r, (ptr, pid, sig),
   errno = 0;
   if ((ret = _kill (pid, sig)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -95,6 +97,7 @@ _DEFUN (_getpid_r, (ptr),
 {
   int ret;
   ret = _getpid ();
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/signgam.c b/newlib/libc/reent/signgam.c
index bfb2dea..2e8abf2 100644
--- a/newlib/libc/reent/signgam.c
+++ b/newlib/libc/reent/signgam.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The signgam variable is stored in the reentrancy structure.  This
    function returns its address for use by the macro signgam defined in
    math.h.  */
@@ -10,6 +11,7 @@
 int *
 _DEFUN_VOID (__signgam)
 {
+  __A_VARIABLE = 1;
   return &_REENT_SIGNGAM(_REENT);
 }
 
diff --git a/newlib/libc/reent/stat64r.c b/newlib/libc/reent/stat64r.c
index 695b7f8..2ad8be3 100644
--- a/newlib/libc/reent/stat64r.c
+++ b/newlib/libc/reent/stat64r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of stat64 system call.  This implementation just
    calls the stat64 system call.  */
 
@@ -62,6 +63,7 @@ _DEFUN (_stat64_r, (ptr, file, pstat),
   errno = 0;
   if ((ret = _stat64 (file, pstat)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/statr.c b/newlib/libc/reent/statr.c
index 9ad2bb2..ac751a2 100644
--- a/newlib/libc/reent/statr.c
+++ b/newlib/libc/reent/statr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of stat system call.  This implementation just
    calls the stat system call.  */
 
@@ -62,6 +63,7 @@ _DEFUN (_stat_r, (ptr, file, pstat),
   errno = 0;
   if ((ret = _stat (file, pstat)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/timesr.c b/newlib/libc/reent/timesr.c
index 1881724..79586dd 100644
--- a/newlib/libc/reent/timesr.c
+++ b/newlib/libc/reent/timesr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of times system calls */
 
 #include <reent.h>
@@ -58,6 +59,7 @@ _DEFUN (_times_r, (ptr, ptms),
   clock_t ret;
 
   ret = _times (ptms);
+  __A_VARIABLE = 1;
   return ret;
 }
 #endif /* ! defined (REENTRANT_SYSCALLS_PROVIDED) */
diff --git a/newlib/libc/reent/unlinkr.c b/newlib/libc/reent/unlinkr.c
index 95b815f..36d54b1 100644
--- a/newlib/libc/reent/unlinkr.c
+++ b/newlib/libc/reent/unlinkr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of file system calls.  These implementations
    just call the usual system calls.  */
 
@@ -53,6 +54,7 @@ _DEFUN (_unlink_r, (ptr, file),
   errno = 0;
   if ((ret = _unlink (file)) == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/reent/writer.c b/newlib/libc/reent/writer.c
index fa2ab8e..01487c7 100644
--- a/newlib/libc/reent/writer.c
+++ b/newlib/libc/reent/writer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reentrant versions of write system call. */
 
 #include <reent.h>
@@ -61,6 +62,7 @@ _DEFUN (_write_r, (ptr, fd, buf, cnt),
   ret = (_ssize_t) rret;
   if (ret == -1 && errno != 0)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/search/bsd_qsort_r.c b/newlib/libc/search/bsd_qsort_r.c
index f4a3757..9c96678 100644
--- a/newlib/libc/search/bsd_qsort_r.c
+++ b/newlib/libc/search/bsd_qsort_r.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define I_AM_QSORT_R
 #include "qsort.c"
diff --git a/newlib/libc/search/bsearch.c b/newlib/libc/search/bsearch.c
index d874e79..04e7264 100644
--- a/newlib/libc/search/bsearch.c
+++ b/newlib/libc/search/bsearch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * bsearch.c
  * Original Author:	G. Haley
diff --git a/newlib/libc/search/hash.c b/newlib/libc/search/hash.c
index 5fea88a..9a98972 100644
--- a/newlib/libc/search/hash.c
+++ b/newlib/libc/search/hash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -283,12 +284,15 @@ hash_close(dbp)
 	HTAB *hashp;
 	int retval;
 
-	if (!dbp)
+	if (!dbp) {
+		__A_VARIABLE = 1;
 		return (ERROR);
+	}
 
 	hashp = (HTAB *)dbp->internal;
 	retval = hdestroy(hashp);
 	free(dbp);
+	__A_VARIABLE = 1;
 	return (retval);
 }
 
@@ -298,14 +302,18 @@ hash_fd(dbp)
 {
 	HTAB *hashp;
 
-	if (!dbp)
+	if (!dbp) {
+		__A_VARIABLE = 1;
 		return (ERROR);
+	}
 
 	hashp = (HTAB *)dbp->internal;
 	if (hashp->fp == -1) {
 		errno = ENOENT;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (hashp->fp);
 }
 
@@ -409,8 +417,10 @@ init_htab(hashp, nelem)
 	hashp->LAST_FREED = 2;
 
 	/* First bitmap page is at: splitpoint l2 page offset 1 */
-	if (__ibitmap(hashp, OADDR_OF(l2, 1), l2 + 1, 0))
+	if (__ibitmap(hashp, OADDR_OF(l2, 1), l2 + 1, 0)) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 	hashp->MAX_BUCKET = hashp->LOW_MASK = nbuckets - 1;
 	hashp->HIGH_MASK = (nbuckets << 1) - 1;
@@ -422,6 +432,7 @@ init_htab(hashp, nelem)
 
 	if (nsegs > hashp->DSIZE)
 		hashp->DSIZE = nsegs;
+	__A_VARIABLE = 1;
 	return (alloc_segs(hashp, nsegs));
 }
 
@@ -480,8 +491,10 @@ hdestroy(hashp)
 
 	if (save_errno) {
 		errno = save_errno;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
+	__A_VARIABLE = 1;
 	return (SUCCESS);
 }
 /*
@@ -500,18 +513,26 @@ hash_sync(dbp, flags)
 
 	if (flags != 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
 
-	if (!dbp)
+	if (!dbp) {
+		__A_VARIABLE = 1;
 		return (ERROR);
+	}
 
 	hashp = (HTAB *)dbp->internal;
-	if (!hashp->save_file)
+	if (!hashp->save_file) {
+		__A_VARIABLE = 1;
 		return (0);
-	if (__buf_free(hashp, 0, 1) || flush_meta(hashp))
+	}
+	if (__buf_free(hashp, 0, 1) || flush_meta(hashp)) {
+		__A_VARIABLE = 1;
 		return (ERROR);
+	}
 	hashp->new_file = 0;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -580,8 +601,10 @@ hash_get(dbp, key, data, flag)
 	hashp = (HTAB *)dbp->internal;
 	if (flag) {
 		hashp->error = errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
+	__A_VARIABLE = 1;
 	return (hash_access(hashp, HASH_GET, (DBT *)key, data));
 }
 
@@ -598,12 +621,15 @@ hash_put(dbp, key, data, flag)
 	if (flag && flag != R_NOOVERWRITE) {
 		hashp->error = EINVAL;
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
 	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
 		hashp->error = errno = EPERM;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
+	__A_VARIABLE = 1;
 	return (hash_access(hashp, flag == R_NOOVERWRITE ?
 	    HASH_PUTNEW : HASH_PUT, (DBT *)key, (DBT *)data));
 }
@@ -619,12 +645,15 @@ hash_delete(dbp, key, flag)
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_CURSOR) {
 		hashp->error = errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
 	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
 		hashp->error = errno = EPERM;
+		__A_VARIABLE = 1;
 		return (ERROR);
 	}
+	__A_VARIABLE = 1;
 	return (hash_access(hashp, HASH_DELETE, (DBT *)key, NULL));
 }
 
@@ -871,13 +900,17 @@ __expand_table(hashp)
 		if (new_segnum >= hashp->DSIZE) {
 			/* Reallocate directory */
 			dirsize = hashp->DSIZE * sizeof(SEGMENT *);
-			if (!hash_realloc(&hashp->dir, dirsize, dirsize << 1))
+			if (!hash_realloc(&hashp->dir, dirsize, dirsize << 1)) {
+				__A_VARIABLE = 1;
 				return (-1);
+			}
 			hashp->DSIZE = dirsize << 1;
 		}
 		if ((hashp->dir[new_segnum] =
-		    (SEGMENT)calloc(hashp->SGSIZE, sizeof(SEGMENT))) == NULL)
+		    (SEGMENT)calloc(hashp->SGSIZE, sizeof(SEGMENT))) == NULL) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		hashp->exsegs++;
 		hashp->nsegs++;
 	}
@@ -898,6 +931,7 @@ __expand_table(hashp)
 		hashp->HIGH_MASK = new_bucket | hashp->LOW_MASK;
 	}
 	/* Relocate records to the new bucket */
+	__A_VARIABLE = 1;
 	return (__split_page(hashp, old_bucket, new_bucket));
 }
 
@@ -918,6 +952,7 @@ hash_realloc(p_ptr, oldsize, newsize)
 		free(*p_ptr);
 		*p_ptr = p;
 	}
+	__A_VARIABLE = 1;
 	return (p);
 }
 
@@ -933,6 +968,7 @@ __call_hash(hashp, k, len)
 	bucket = n & hashp->HIGH_MASK;
 	if (bucket > hashp->MAX_BUCKET)
 		bucket = bucket & hashp->LOW_MASK;
+	__A_VARIABLE = 1;
 	return (bucket);
 }
 
@@ -956,6 +992,7 @@ alloc_segs(hashp, nsegs)
 		save_errno = errno;
 		(void)hdestroy(hashp);
 		errno = save_errno;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	/* Allocate segments */
@@ -964,10 +1001,12 @@ alloc_segs(hashp, nsegs)
 		save_errno = errno;
 		(void)hdestroy(hashp);
 		errno = save_errno;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	for (i = 0; i < nsegs; i++, hashp->nsegs++)
 		hashp->dir[i] = &store[i << hashp->SSHIFT];
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -1002,6 +1041,7 @@ swap_header_copy(srcp, destp)
 		P_32_COPY(srcp->spares[i], destp->spares[i]);
 		P_16_COPY(srcp->bitmaps[i], destp->bitmaps[i]);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1034,5 +1074,6 @@ swap_header(hashp)
 		M_32_SWAP(hdrp->spares[i]);
 		M_16_SWAP(hdrp->bitmaps[i]);
 	}
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/search/hash_bigkey.c b/newlib/libc/search/hash_bigkey.c
index 8ff52b3..bf0a574 100644
--- a/newlib/libc/search/hash_bigkey.c
+++ b/newlib/libc/search/hash_bigkey.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -218,8 +219,10 @@ __big_delete(hashp, bufp)
 		if (last_bfp)
 			__free_ovflpage(hashp, last_bfp);
 		last_bfp = rbufp;
-		if (!rbufp)
-			return (-1);		/* Error. */
+		if (!rbufp) {
+			__A_VARIABLE = 1;
+			return (-1);
+		}		/* Error. */
 		bp = (__uint16_t *)rbufp->page;
 	}
 
@@ -256,6 +259,7 @@ __big_delete(hashp, bufp)
 		__free_ovflpage(hashp, last_bfp);
 
 	hashp->NKEYS--;
+	__A_VARIABLE = 1;
 	return (0);
 }
 /*
@@ -513,9 +517,12 @@ __big_keydata(hashp, bufp, key, val, set)
 	int set;
 {
 	key->size = collect_key(hashp, bufp, 0, val, set);
-	if (key->size == -1)
+	if (key->size == -1) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	key->data = (u_char *)hashp->tmp_key;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
diff --git a/newlib/libc/search/hash_buf.c b/newlib/libc/search/hash_buf.c
index d50fc57..d4b2246 100644
--- a/newlib/libc/search/hash_buf.c
+++ b/newlib/libc/search/hash_buf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -318,6 +319,7 @@ __buf_init(hashp, nbytes)
 	 * bfp->page = NULL;
 	 * bfp->addr = 0;
 	 */
+	__A_VARIABLE = 1;
 }
 
 extern int
@@ -328,15 +330,19 @@ __buf_free(hashp, do_free, to_disk)
 	BUFHEAD *bp;
 
 	/* Need to make sure that buffer manager has been initialized */
-	if (!LRU)
+	if (!LRU) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	for (bp = LRU; bp != &hashp->bufhead;) {
 		/* Check that the buffer is valid */
 		if (bp->addr || IS_BUCKET(bp->flags)) {
 			if (to_disk && (bp->flags & BUF_MOD) &&
 			    __put_page(hashp, bp->page,
-			    bp->addr, IS_BUCKET(bp->flags), 0))
+			    bp->addr, IS_BUCKET(bp->flags), 0)) {
+				__A_VARIABLE = 1;
 				return (-1);
+			}
 		}
 		/* Check if we are freeing stuff */
 		if (do_free) {
@@ -348,6 +354,7 @@ __buf_free(hashp, do_free, to_disk)
 		} else
 			bp = bp->prev;
 	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -361,4 +368,5 @@ __reclaim_buf(hashp, bp)
 	bp->flags = 0;
 	BUF_REMOVE(bp);
 	LRU_INSERT(bp);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/search/hash_func.c b/newlib/libc/search/hash_func.c
index 355f0b5..fbdb759 100644
--- a/newlib/libc/search/hash_func.c
+++ b/newlib/libc/search/hash_func.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -216,5 +217,6 @@ hash4(keyarg, len)
 			} while (--loop);
 		}
 	}
+	__A_VARIABLE = 1;
 	return (h);
 }
diff --git a/newlib/libc/search/hash_log2.c b/newlib/libc/search/hash_log2.c
index 9414f26..892c1d6 100644
--- a/newlib/libc/search/hash_log2.c
+++ b/newlib/libc/search/hash_log2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -51,5 +52,6 @@ __log2(num)
 
 	limit = 1;
 	for (i = 0; limit < num; limit = limit << 1, i++);
+	__A_VARIABLE = 1;
 	return (i);
 }
diff --git a/newlib/libc/search/hash_page.c b/newlib/libc/search/hash_page.c
index 7ca304d..aa72ca6 100644
--- a/newlib/libc/search/hash_page.c
+++ b/newlib/libc/search/hash_page.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -119,6 +120,7 @@ putpair(p, key, val)
 	bp[0] = n;
 	bp[n + 1] = off - ((n + 3) * sizeof(__uint16_t));
 	bp[n + 2] = off;
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -139,8 +141,10 @@ __delpair(hashp, bufp, ndx)
 	bp = (__uint16_t *)bufp->page;
 	n = bp[0];
 
-	if (bp[ndx + 1] < REAL_KEY)
+	if (bp[ndx + 1] < REAL_KEY) {
+		__A_VARIABLE = 1;
 		return (__big_delete(hashp, bufp));
+	}
 	if (ndx != 1)
 		newoff = bp[ndx - 1];
 	else
@@ -172,6 +176,7 @@ __delpair(hashp, bufp, ndx)
 	hashp->NKEYS--;
 
 	bufp->flags |= BUF_MOD;
+	__A_VARIABLE = 1;
 	return (0);
 }
 /*
@@ -195,11 +200,15 @@ __split_page(hashp, obucket, nbucket)
 	copyto = (__uint16_t)hashp->BSIZE;
 	off = (__uint16_t)hashp->BSIZE;
 	old_bufp = __get_buf(hashp, obucket, NULL, 0);
-	if (old_bufp == NULL)
+	if (old_bufp == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	new_bufp = __get_buf(hashp, nbucket, NULL, 0);
-	if (new_bufp == NULL)
+	if (new_bufp == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 	old_bufp->flags |= (BUF_MOD | BUF_PIN);
 	new_bufp->flags |= (BUF_MOD | BUF_PIN);
@@ -215,6 +224,7 @@ __split_page(hashp, obucket, nbucket)
 			    (int)copyto, (int)moved);
 			old_bufp->flags &= ~BUF_PIN;
 			new_bufp->flags &= ~BUF_PIN;
+			__A_VARIABLE = 1;
 			return (retval);
 
 		}
@@ -257,6 +267,7 @@ __split_page(hashp, obucket, nbucket)
 	/* unpin both pages */
 	old_bufp->flags &= ~BUF_PIN;
 	new_bufp->flags &= ~BUF_PIN;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -487,8 +498,10 @@ __add_ovflpage(hashp, bufp)
 	tmp1 = bufp->addr;
 	tmp2 = bufp->ovfl ? bufp->ovfl->addr : 0;
 #endif
-	if (!ovfl_num || !(bufp->ovfl = __get_buf(hashp, ovfl_num, bufp, 1)))
+	if (!ovfl_num || !(bufp->ovfl = __get_buf(hashp, ovfl_num, bufp, 1))) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	bufp->ovfl->flags |= BUF_MOD;
 #ifdef DEBUG1
 	(void)fprintf(stderr, "ADDOVFLPAGE: %d->ovfl was %d is now %d\n",
@@ -508,6 +521,7 @@ __add_ovflpage(hashp, bufp)
 #ifdef HASH_STATISTICS
 	hash_overflows++;
 #endif
+	__A_VARIABLE = 1;
 	return (bufp->ovfl);
 }
 
@@ -587,8 +601,10 @@ __put_page(hashp, p, bucket, is_bucket, is_bitmap)
 	int wsize;
 
 	size = hashp->BSIZE;
-	if ((hashp->fp == -1) && open_temp(hashp))
+	if ((hashp->fp == -1) && open_temp(hashp)) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	fd = hashp->fp;
 
        if (hashp->LORDER != DB_BYTE_ORDER) {
@@ -610,13 +626,17 @@ __put_page(hashp, p, bucket, is_bucket, is_bitmap)
 	else
 		page = OADDR_TO_PAGE(bucket);
 	if ((lseek(fd, (off_t)page << hashp->BSHIFT, SEEK_SET) == -1) ||
-	    ((wsize = write(fd, p, size)) == -1))
+	    ((wsize = write(fd, p, size)) == -1)) {
 		/* Errno is set */
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	if (wsize != size) {
 		errno = EFTYPE;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -633,8 +653,10 @@ __ibitmap(hashp, pnum, nbits, ndx)
 	__uint32_t *ip;
 	int clearbytes, clearints;
 
-	if ((ip = (__uint32_t *)malloc(hashp->BSIZE)) == NULL)
+	if ((ip = (__uint32_t *)malloc(hashp->BSIZE)) == NULL) {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 	hashp->nmaps++;
 	clearints = ((nbits - 1) >> INT_BYTE_SHIFT) + 1;
 	clearbytes = clearints << INT_TO_BYTE;
@@ -645,6 +667,7 @@ __ibitmap(hashp, pnum, nbits, ndx)
 	SETBIT(ip, 0);
 	hashp->BITMAPS[ndx] = (__uint16_t)pnum;
 	hashp->mapp[ndx] = ip;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -656,10 +679,13 @@ first_free(map)
 
 	mask = 0x1;
 	for (i = 0; i < BITS_PER_MAP; i++) {
-		if (!(mask & map))
+		if (!(mask & map)) {
+			__A_VARIABLE = 1;
 			return (i);
+		}
 		mask = mask << 1;
 	}
+	__A_VARIABLE = 1;
 	return (i);
 }
 
@@ -850,6 +876,7 @@ __free_ovflpage(hashp, obufp)
 	    obufp->addr, free_bit, free_page);
 #endif
 	__reclaim_buf(hashp, obufp);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -874,6 +901,7 @@ open_temp(hashp)
 #endif
 	}
 	(void)sigprocmask(SIG_SETMASK, &oset, (sigset_t *)NULL);
+	__A_VARIABLE = 1;
 	return (hashp->fp != -1 ? 0 : -1);
 }
 
@@ -906,6 +934,7 @@ squeeze_key(sp, key, val)
 	sp[n + 2] = OVFLPAGE;
 	FREESPACE(sp) = free_space - PAIRSIZE(key, val);
 	OFFSET(sp) = off;
+	__A_VARIABLE = 1;
 }
 
 static __uint32_t *
@@ -913,15 +942,21 @@ fetch_bitmap(hashp, ndx)
 	HTAB *hashp;
 	int ndx;
 {
-	if (ndx >= hashp->nmaps)
+	if (ndx >= hashp->nmaps) {
+		__A_VARIABLE = 1;
 		return (NULL);
-	if ((hashp->mapp[ndx] = (__uint32_t *)malloc(hashp->BSIZE)) == NULL)
+	}
+	if ((hashp->mapp[ndx] = (__uint32_t *)malloc(hashp->BSIZE)) == NULL) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	if (__get_page(hashp,
 	    (char *)hashp->mapp[ndx], hashp->BITMAPS[ndx], 0, 1, 1)) {
 		free(hashp->mapp[ndx]);
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
+	__A_VARIABLE = 1;
 	return (hashp->mapp[ndx]);
 }
 
@@ -944,5 +979,6 @@ print_chain(addr)
 		bp = (short *)bufp->page;
 	}
 	(void)fprintf(stderr, "\n");
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/search/hcreate.c b/newlib/libc/search/hcreate.c
index b7be1cd..898d572 100644
--- a/newlib/libc/search/hcreate.c
+++ b/newlib/libc/search/hcreate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: hcreate.c,v 1.2 2001/02/19 21:26:04 ross Exp $ */
 
 /*
@@ -59,6 +60,7 @@ static struct hsearch_data htab;
 int
 _DEFUN(hcreate, (nel), size_t nel)
 {
+  __A_VARIABLE = 1;
   return hcreate_r (nel, &htab);
 }
 
@@ -66,6 +68,7 @@ void
 _DEFUN_VOID (hdestroy)
 {
   hdestroy_r (&htab);
+  __A_VARIABLE = 1;
 }
 
 ENTRY *
@@ -77,5 +80,6 @@ _DEFUN(hsearch, (item, action),
 
   hsearch_r (item, action, &retval, &htab);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/search/hcreate_r.c b/newlib/libc/search/hcreate_r.c
index 8aba524..f8f012b 100644
--- a/newlib/libc/search/hcreate_r.c
+++ b/newlib/libc/search/hcreate_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: hcreate.c,v 1.2 2001/02/19 21:26:04 ross Exp $ */
 
 /*
@@ -87,6 +88,7 @@ hcreate_r(size_t nel, struct hsearch_data *htab)
 	/* Make sure this this isn't called when a table already exists. */
 	if (htab->htable != NULL) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -110,6 +112,7 @@ hcreate_r(size_t nel, struct hsearch_data *htab)
 	htab->htable = malloc(htab->htablesize * sizeof htab->htable[0]);
 	if (htab->htable == NULL) {
 		errno = ENOMEM;
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -117,6 +120,7 @@ hcreate_r(size_t nel, struct hsearch_data *htab)
 	for (idx = 0; idx < htab->htablesize; idx++)
 		SLIST_INIT(&(htab->htable[idx]));
 
+	__A_VARIABLE = 1;
 	return 1;
 }
 
@@ -127,8 +131,10 @@ hdestroy_r(struct hsearch_data *htab)
 	struct internal_entry *ie;
 	size_t idx;
 #endif
-	if (htab->htable == NULL)
+	if (htab->htable == NULL) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 #if 0
 	for (idx = 0; idx < htab->htablesize; idx++) {
@@ -142,6 +148,7 @@ hdestroy_r(struct hsearch_data *htab)
 #endif
 	free(htab->htable);
 	htab->htable = NULL;
+	__A_VARIABLE = 1;
 }
 
 int
diff --git a/newlib/libc/search/qsort.c b/newlib/libc/search/qsort.c
index bf6285f..82a2153 100644
--- a/newlib/libc/search/qsort.c
+++ b/newlib/libc/search/qsort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<qsort>>---sort an array
@@ -118,6 +119,7 @@ _DEFUN(swapfunc, (a, b, n, swaptype),
 		swapcode(long, a, b, n)
 	else
 		swapcode(char, a, b, n)
+	__A_VARIABLE = 1;
 }
 
 #define swap(a, b)					\
@@ -150,6 +152,7 @@ __unused
 #endif
 )
 {
+	__A_VARIABLE = 1;
 	return CMP(thunk, a, b) < 0 ?
 	       (CMP(thunk, b, c) < 0 ? b : (CMP(thunk, a, c) < 0 ? c : a ))
               :(CMP(thunk, b, c) > 0 ? b : (CMP(thunk, a, c) < 0 ? a : c ));
@@ -193,6 +196,7 @@ loop:	SWAPINIT(a, es);
 			for (pl = pm; pl > (char *) a && CMP(thunk, pl - es, pl) > 0;
 			     pl -= es)
 				swap(pl, pl - es);
+		__A_VARIABLE = 1;
 		return;
 	}
 	pm = (char *) a + (n / 2) * es;
@@ -240,6 +244,7 @@ loop:	SWAPINIT(a, es);
 			for (pl = pm; pl > (char *) a && CMP(thunk, pl - es, pl) > 0;
 			     pl -= es)
 				swap(pl, pl - es);
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -263,4 +268,5 @@ loop:	SWAPINIT(a, es);
 		goto loop;
 	}
 /*		qsort(pn - r, r / es, es, cmp);*/
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/search/qsort_r.c b/newlib/libc/search/qsort_r.c
index 9073061..a360588 100644
--- a/newlib/libc/search/qsort_r.c
+++ b/newlib/libc/search/qsort_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<qsort_r>>---sort an array
diff --git a/newlib/libc/search/tdelete.c b/newlib/libc/search/tdelete.c
index b607b54..1b857ac 100644
--- a/newlib/libc/search/tdelete.c
+++ b/newlib/libc/search/tdelete.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: tdelete.c,v 1.2 1999/09/16 11:45:37 lukem Exp $	*/
 
 /*
@@ -35,16 +36,20 @@ _DEFUN(tdelete, (vkey, vrootp, compar),
 	node_t *p, *q, *r;
 	int  cmp;
 
-	if (rootp == NULL || (p = *rootp) == NULL)
+	if (rootp == NULL || (p = *rootp) == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
 	while ((cmp = (*compar)(vkey, (*rootp)->key)) != 0) {
 		p = *rootp;
 		rootp = (cmp < 0) ?
 		    &(*rootp)->llink :		/* follow llink branch */
 		    &(*rootp)->rlink;		/* follow rlink branch */
-		if (*rootp == NULL)
-			return NULL;		/* key not found */
+		if (*rootp == NULL) {
+			__A_VARIABLE = 1;
+			return NULL;
+		}		/* key not found */
 	}
 	r = (*rootp)->rlink;			/* D1: */
 	if ((q = (*rootp)->llink) == NULL)	/* Left NULL? */
@@ -63,5 +68,6 @@ _DEFUN(tdelete, (vkey, vrootp, compar),
 	}
 	free(*rootp);				/* D4: Free node */
 	*rootp = q;				/* link parent to new node */
+	__A_VARIABLE = 1;
 	return p;
 }
diff --git a/newlib/libc/search/tdestroy.c b/newlib/libc/search/tdestroy.c
index 3e7327c..5149cea 100644
--- a/newlib/libc/search/tdestroy.c
+++ b/newlib/libc/search/tdestroy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: tdelete.c,v 1.2 1999/09/16 11:45:37 lukem Exp $	*/
 
 /*
@@ -37,6 +38,7 @@ trecurse(root, free_action)
 
   (*free_action) ((void *) root->key);
   free(root);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -48,4 +50,5 @@ _DEFUN(tdestroy, (vrootp, freefct),
 
   if (root != NULL)
     trecurse(root, freefct);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/search/tfind.c b/newlib/libc/search/tfind.c
index 5d7c40c..b248647 100644
--- a/newlib/libc/search/tfind.c
+++ b/newlib/libc/search/tfind.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: tfind.c,v 1.2 1999/09/16 11:45:37 lukem Exp $	*/
 
 /*
@@ -32,17 +33,22 @@ _DEFUN(tfind, (vkey, vrootp, compar),
 {
 	node_t **rootp = (node_t **)vrootp;
 
-	if (rootp == NULL)
+	if (rootp == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
 	while (*rootp != NULL) {		/* T1: */
 		int r;
 
-		if ((r = (*compar)(vkey, (*rootp)->key)) == 0)	/* T2: */
-			return *rootp;		/* key found */
+		if ((r = (*compar)(vkey, (*rootp)->key)) == 0)	/* T2: */ {
+			__A_VARIABLE = 1;
+			return *rootp;
+		}		/* key found */
 		rootp = (r < 0) ?
 		    &(*rootp)->llink :		/* T3: follow left branch */
 		    &(*rootp)->rlink;		/* T4: follow right branch */
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
diff --git a/newlib/libc/search/tsearch.c b/newlib/libc/search/tsearch.c
index 5f41b40..9d4575a 100644
--- a/newlib/libc/search/tsearch.c
+++ b/newlib/libc/search/tsearch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: tsearch.c,v 1.3 1999/09/16 11:45:37 lukem Exp $	*/
 
 /*
@@ -33,14 +34,18 @@ _DEFUN(tsearch, (vkey, vrootp, compar),
 	node_t *q;
 	node_t **rootp = (node_t **)vrootp;
 
-	if (rootp == NULL)
+	if (rootp == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
 	while (*rootp != NULL) {	/* Knuth's T1: */
 		int r;
 
-		if ((r = (*compar)(vkey, (*rootp)->key)) == 0)	/* T2: */
-			return *rootp;		/* we found it! */
+		if ((r = (*compar)(vkey, (*rootp)->key)) == 0)	/* T2: */ {
+			__A_VARIABLE = 1;
+			return *rootp;
+		}		/* we found it! */
 
 		rootp = (r < 0) ?
 		    &(*rootp)->llink :		/* T3: follow left branch */
@@ -54,5 +59,6 @@ _DEFUN(tsearch, (vkey, vrootp, compar),
 		q->key = (void *)vkey;		/* initialize new node */
 		q->llink = q->rlink = NULL;
 	}
+	__A_VARIABLE = 1;
 	return q;
 }
diff --git a/newlib/libc/search/twalk.c b/newlib/libc/search/twalk.c
index 74ad5a6..01c3fc3 100644
--- a/newlib/libc/search/twalk.c
+++ b/newlib/libc/search/twalk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: twalk.c,v 1.1 1999/02/22 10:33:16 christos Exp $	*/
 
 /*
@@ -45,6 +46,7 @@ trecurse(root, action, level)
 			trecurse(root->rlink, action, level + 1);
 		(*action)(root, endorder, level);
 	}
+	__A_VARIABLE = 1;
 }
 
 /* Walk the nodes of a tree */
@@ -55,4 +57,5 @@ _DEFUN(twalk, (vroot, action),
 {
 	if (vroot != NULL && action != NULL)
 		trecurse(vroot, action, 0);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/signal/psignal.c b/newlib/libc/signal/psignal.c
index 4638518..b5086f0 100644
--- a/newlib/libc/signal/psignal.c
+++ b/newlib/libc/signal/psignal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, 2011 Red Hat Inc. */
 /*
 FUNCTION
@@ -48,4 +49,5 @@ _DEFUN(psignal, (sig, s),
     fprintf (stderr, "%s: %s\n", s, strsignal (sig));
   else
     fprintf (stderr, "%s\n", strsignal (sig));
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/signal/raise.c b/newlib/libc/signal/raise.c
index bc47864..f823233 100644
--- a/newlib/libc/signal/raise.c
+++ b/newlib/libc/signal/raise.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Embedded systems may want the simulated signals if no other form exists,
    but UNIX versions will want to use the host facilities.
    Define SIMULATED_SIGNALS when you want to use the simulated versions.
@@ -64,6 +65,7 @@ int
 _DEFUN (raise, (sig),
 	int sig)
 {
+  __A_VARIABLE = 1;
   return _raise_r (_REENT, sig);
 }
 
@@ -74,6 +76,7 @@ _DEFUN (_raise_r, (reent, sig),
 	struct _reent *reent _AND
 	int sig)
 {
+  __A_VARIABLE = 1;
   return _kill_r (reent, _getpid_r (reent), sig);
 }
 
diff --git a/newlib/libc/signal/signal.c b/newlib/libc/signal/signal.c
index 1830047..7d03238 100644
--- a/newlib/libc/signal/signal.c
+++ b/newlib/libc/signal/signal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<signal>>---specify handler subroutine for a signal
@@ -108,13 +109,16 @@ _DEFUN (_init_signal_r, (ptr),
   if (ptr->_sig_func == NULL)
     {
       ptr->_sig_func = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
-      if (ptr->_sig_func == NULL)
+      if (ptr->_sig_func == NULL) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
 
       for (i = 0; i < NSIG; i++)
 	ptr->_sig_func[i] = SIG_DFL;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -129,15 +133,19 @@ _DEFUN (_signal_r, (ptr, sig, func),
   if (sig < 0 || sig >= NSIG)
     {
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return SIG_ERR;
     }
 
-  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
+  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0) {
+    __A_VARIABLE = 1;
     return SIG_ERR;
+  }
   
   old_func = ptr->_sig_func[sig];
   ptr->_sig_func[sig] = func;
 
+  __A_VARIABLE = 1;
   return old_func;
 }
 
@@ -212,6 +220,7 @@ int
 _DEFUN (raise, (sig),
      int sig)
 {
+  __A_VARIABLE = 1;
   return _raise_r (_REENT, sig);
 }
 
@@ -220,18 +229,21 @@ _DEFUN (signal, (sig, func),
 	int sig _AND
 	_sig_func_ptr func)
 {
+  __A_VARIABLE = 1;
   return _signal_r (_REENT, sig, func);
 }
 
 int 
 _DEFUN_VOID (_init_signal)
 {
+  __A_VARIABLE = 1;
   return _init_signal_r (_REENT);
 }
 
 int
 _DEFUN (__sigtramp, (sig), int sig)
 {
+  __A_VARIABLE = 1;
   return __sigtramp_r (_REENT, sig);
 }
 
diff --git a/newlib/libc/stdio/asiprintf.c b/newlib/libc/stdio/asiprintf.c
index 0c363d5..01db168 100644
--- a/newlib/libc/stdio/asiprintf.c
+++ b/newlib/libc/stdio/asiprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -47,6 +48,7 @@ _DEFUN(_asiprintf_r, (ptr, strp, fmt),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -74,6 +76,7 @@ _DEFUN(asiprintf, (strp, fmt),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/asniprintf.c b/newlib/libc/stdio/asniprintf.c
index 16ccfde..a61ada1 100644
--- a/newlib/libc/stdio/asniprintf.c
+++ b/newlib/libc/stdio/asniprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007, 2008 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -44,6 +45,7 @@ _DEFUN(_asniprintf_r, (ptr, buf, lenp, fmt),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
@@ -51,10 +53,13 @@ _DEFUN(_asniprintf_r, (ptr, buf, lenp, fmt),
   va_start (ap, fmt);
   ret = _svfiprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
@@ -91,6 +96,7 @@ _DEFUN(asniprintf, (buf, lenp, fmt),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
@@ -98,10 +104,13 @@ _DEFUN(asniprintf, (buf, lenp, fmt),
   va_start (ap, fmt);
   ret = _svfiprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
diff --git a/newlib/libc/stdio/asnprintf.c b/newlib/libc/stdio/asnprintf.c
index 2e8d8aa..ea524ca 100644
--- a/newlib/libc/stdio/asnprintf.c
+++ b/newlib/libc/stdio/asnprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007, 2008 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -44,6 +45,7 @@ _DEFUN(_asnprintf_r, (ptr, buf, lenp, fmt),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
@@ -51,10 +53,13 @@ _DEFUN(_asnprintf_r, (ptr, buf, lenp, fmt),
   va_start (ap, fmt);
   ret = _svfprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
@@ -97,6 +102,7 @@ _DEFUN(asnprintf, (buf, lenp, fmt),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
@@ -104,10 +110,13 @@ _DEFUN(asnprintf, (buf, lenp, fmt),
   va_start (ap, fmt);
   ret = _svfprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
diff --git a/newlib/libc/stdio/asprintf.c b/newlib/libc/stdio/asprintf.c
index bf214f9..65a4610 100644
--- a/newlib/libc/stdio/asprintf.c
+++ b/newlib/libc/stdio/asprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -47,6 +48,7 @@ _DEFUN(_asprintf_r, (ptr, strp, fmt),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -80,6 +82,7 @@ _DEFUN(asprintf, (strp, fmt),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/clearerr.c b/newlib/libc/stdio/clearerr.c
index 9bf0837..af2dbb1 100644
--- a/newlib/libc/stdio/clearerr.c
+++ b/newlib/libc/stdio/clearerr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -89,4 +90,5 @@ _DEFUN(clearerr, (fp),
   _newlib_flockfile_start (fp);
   __sclearerr (fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdio/clearerr_u.c b/newlib/libc/stdio/clearerr_u.c
index 00c5e8e..4f7eb88 100644
--- a/newlib/libc/stdio/clearerr_u.c
+++ b/newlib/libc/stdio/clearerr_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -38,4 +39,5 @@ _DEFUN(clearerr_unlocked, (fp),
 {
   CHECK_INIT(_REENT, fp);
   __sclearerr (fp);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdio/diprintf.c b/newlib/libc/stdio/diprintf.c
index e0a5595..81e6aef 100644
--- a/newlib/libc/stdio/diprintf.c
+++ b/newlib/libc/stdio/diprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2005, 2007 Shaun Jackman
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -60,6 +61,7 @@ _DEFUN(_diprintf_r, (ptr, fd, format),
   va_start (ap, format);
   n = _vdiprintf_r (ptr, fd, format, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -76,6 +78,7 @@ _DEFUN(diprintf, (fd, format),
   va_start (ap, format);
   n = _vdiprintf_r (_REENT, fd, format, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return n;
 }
 
diff --git a/newlib/libc/stdio/dprintf.c b/newlib/libc/stdio/dprintf.c
index 2925ceb..93cce3b 100644
--- a/newlib/libc/stdio/dprintf.c
+++ b/newlib/libc/stdio/dprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2005, 2007 Shaun Jackman
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -64,6 +65,7 @@ _DEFUN(_dprintf_r, (ptr, fd, format),
 	va_start (ap, format);
 	n = _vdprintf_r (ptr, fd, format, ap);
 	va_end (ap);
+	__A_VARIABLE = 1;
 	return n;
 }
 
@@ -88,6 +90,7 @@ _DEFUN(dprintf, (fd, format),
   va_start (ap, format);
   n = _vdprintf_r (ptr, fd, format, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return n;
 }
 
diff --git a/newlib/libc/stdio/fclose.c b/newlib/libc/stdio/fclose.c
index 0ce1123..7300dc9 100644
--- a/newlib/libc/stdio/fclose.c
+++ b/newlib/libc/stdio/fclose.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -71,8 +72,10 @@ _DEFUN(_fclose_r, (rptr, fp),
 {
   int r;
 
-  if (fp == NULL)
-    return (0);			/* on NULL */
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
+    return (0);
+  }			/* on NULL */
 
   CHECK_INIT (rptr, fp);
 
@@ -92,6 +95,7 @@ _DEFUN(_fclose_r, (rptr, fp),
 #ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
       pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
+      __A_VARIABLE = 1;
       return (0);
     }
 #ifdef _STDIO_BSD_SEMANTICS
@@ -124,6 +128,7 @@ _DEFUN(_fclose_r, (rptr, fp),
   pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
 
+  __A_VARIABLE = 1;
   return (r);
 }
 
@@ -133,6 +138,7 @@ int
 _DEFUN(fclose, (fp),
        register FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _fclose_r(_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio/fcloseall.c b/newlib/libc/stdio/fcloseall.c
index 090f3f2..683c60d 100644
--- a/newlib/libc/stdio/fcloseall.c
+++ b/newlib/libc/stdio/fcloseall.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -67,6 +68,7 @@ int
 _DEFUN(_fcloseall_r, (ptr),
        struct _reent *ptr)
 {
+  __A_VARIABLE = 1;
   return _fwalk_reent (ptr, _fclose_r);
 }
 
@@ -75,6 +77,7 @@ _DEFUN(_fcloseall_r, (ptr),
 int
 _DEFUN_VOID(fcloseall)
 {
+  __A_VARIABLE = 1;
   return _fcloseall_r (_GLOBAL_REENT);
 }
 
diff --git a/newlib/libc/stdio/fdopen.c b/newlib/libc/stdio/fdopen.c
index 77f599b..3cd02a9 100644
--- a/newlib/libc/stdio/fdopen.c
+++ b/newlib/libc/stdio/fdopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -75,23 +76,30 @@ _DEFUN(_fdopen_r, (ptr, fd, mode),
   int fdflags, fdmode;
 #endif
 
-  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
+  if ((flags = __sflags (ptr, mode, &oflags)) == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* make sure the mode the user wants is a subset of the actual mode */
 #ifdef HAVE_FCNTL
-  if ((fdflags = _fcntl_r (ptr, fd, F_GETFL, 0)) < 0)
+  if ((fdflags = _fcntl_r (ptr, fd, F_GETFL, 0)) < 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   fdmode = fdflags & O_ACCMODE;
   if (fdmode != O_RDWR && (fdmode != (oflags & O_ACCMODE)))
     {
       ptr->_errno = EBADF;
+      __A_VARIABLE = 1;
       return 0;
     }
 #endif
 
-  if ((fp = __sfp (ptr)) == 0)
+  if ((fp = __sfp (ptr)) == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   _newlib_flockfile_start (fp);
 
@@ -128,6 +136,7 @@ _DEFUN(_fdopen_r, (ptr, fd, mode),
 #endif
 
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -138,6 +147,7 @@ _DEFUN(fdopen, (fd, mode),
        int fd _AND
        _CONST char *mode)
 {
+  __A_VARIABLE = 1;
   return _fdopen_r (_REENT, fd, mode);
 }
 
diff --git a/newlib/libc/stdio/feof.c b/newlib/libc/stdio/feof.c
index 7aadd82..80791f3 100644
--- a/newlib/libc/stdio/feof.c
+++ b/newlib/libc/stdio/feof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -83,5 +84,6 @@ _DEFUN(feof, (fp),
   _newlib_flockfile_start (fp);
   result = __sfeof (fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdio/feof_u.c b/newlib/libc/stdio/feof_u.c
index 48fc4af..ca587bf 100644
--- a/newlib/libc/stdio/feof_u.c
+++ b/newlib/libc/stdio/feof_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -36,5 +37,6 @@ _DEFUN(feof_unlocked, (fp),
        FILE * fp)
 {
   CHECK_INIT(_REENT, fp);
+  __A_VARIABLE = 1;
   return __sfeof (fp);
 }
diff --git a/newlib/libc/stdio/ferror.c b/newlib/libc/stdio/ferror.c
index f93063d..c6318fb 100644
--- a/newlib/libc/stdio/ferror.c
+++ b/newlib/libc/stdio/ferror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -92,5 +93,6 @@ _DEFUN(ferror, (fp),
   _newlib_flockfile_start (fp);
   result = __sferror (fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdio/ferror_u.c b/newlib/libc/stdio/ferror_u.c
index 9b9edba..b6fbcd4 100644
--- a/newlib/libc/stdio/ferror_u.c
+++ b/newlib/libc/stdio/ferror_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -37,5 +38,6 @@ _DEFUN(ferror_unlocked, (fp),
        FILE * fp)
 {
   CHECK_INIT(_REENT, fp);
+  __A_VARIABLE = 1;
   return __sferror (fp);
 }
diff --git a/newlib/libc/stdio/fflush.c b/newlib/libc/stdio/fflush.c
index a4e639e..d748135 100644
--- a/newlib/libc/stdio/fflush.c
+++ b/newlib/libc/stdio/fflush.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -243,6 +244,7 @@ _DEFUN(__sflushw_r, (ptr, fp),
        struct _reent *ptr _AND
        register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & __SWR) ?  __sflush_r (ptr, fp) : 0;
 }
 #endif
@@ -289,9 +291,12 @@ int
 _DEFUN(fflush, (fp),
        register FILE * fp)
 {
-  if (fp == NULL)
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
     return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
+  }
 
+  __A_VARIABLE = 1;
   return _fflush_r (_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio/fflush_u.c b/newlib/libc/stdio/fflush_u.c
index adcc460..4610fc4 100644
--- a/newlib/libc/stdio/fflush_u.c
+++ b/newlib/libc/stdio/fflush_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fgetc.c b/newlib/libc/stdio/fgetc.c
index 34447a2..64839a1 100644
--- a/newlib/libc/stdio/fgetc.c
+++ b/newlib/libc/stdio/fgetc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -115,6 +116,7 @@ _DEFUN(_fgetc_r, (ptr, fp),
   _newlib_flockfile_start (fp);
   result = __sgetc_r (ptr, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdio/fgetc_u.c b/newlib/libc/stdio/fgetc_u.c
index 5bbd5a5..d4268e7 100644
--- a/newlib/libc/stdio/fgetc_u.c
+++ b/newlib/libc/stdio/fgetc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -34,6 +35,7 @@ _DEFUN(_fgetc_unlocked_r, (ptr, fp),
        FILE * fp)
 {
   CHECK_INIT(ptr, fp);
+  __A_VARIABLE = 1;
   return __sgetc_r (ptr, fp);
 }
 
diff --git a/newlib/libc/stdio/fgetpos.c b/newlib/libc/stdio/fgetpos.c
index 20dd108..6d0026a 100644
--- a/newlib/libc/stdio/fgetpos.c
+++ b/newlib/libc/stdio/fgetpos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -85,8 +86,10 @@ _DEFUN(_fgetpos_r, (ptr, fp, pos),
 
   if (*pos != -1)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -97,6 +100,7 @@ _DEFUN(fgetpos, (fp, pos),
        FILE *__restrict fp _AND
        _fpos_t *__restrict pos)
 {
+  __A_VARIABLE = 1;
   return _fgetpos_r (_REENT, fp, pos);
 }
 
diff --git a/newlib/libc/stdio/fgets.c b/newlib/libc/stdio/fgets.c
index f7c8a03..1a8df01 100644
--- a/newlib/libc/stdio/fgets.c
+++ b/newlib/libc/stdio/fgets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -132,8 +133,10 @@ _DEFUN(_fgets_r, (ptr, buf, n, fp),
   char *s;
   unsigned char *p, *t;
 
-  if (n < 2)			/* sanity check */
+  if (n < 2)			/* sanity check */ {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   s = buf;
 
@@ -154,10 +157,12 @@ _DEFUN(_fgets_r, (ptr, buf, n, fp),
       if (c == EOF && s == buf)
         {
           _newlib_flockfile_exit (fp);
+          __A_VARIABLE = 1;
           return NULL;
         }
       *s = 0;
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return buf;
     }
 #endif
@@ -176,6 +181,7 @@ _DEFUN(_fgets_r, (ptr, buf, n, fp),
 	      if (s == buf)
                 {
                   _newlib_flockfile_exit (fp);
+                  __A_VARIABLE = 1;
                   return 0;
                 }
 	      break;
@@ -201,6 +207,7 @@ _DEFUN(_fgets_r, (ptr, buf, n, fp),
 	  _CAST_VOID memcpy ((_PTR) s, (_PTR) p, len);
 	  s[len] = 0;
           _newlib_flockfile_exit (fp);
+	  __A_VARIABLE = 1;
 	  return (buf);
 	}
       fp->_r -= len;
@@ -211,6 +218,7 @@ _DEFUN(_fgets_r, (ptr, buf, n, fp),
   while ((n -= len) != 0);
   *s = 0;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -222,6 +230,7 @@ _DEFUN(fgets, (buf, n, fp),
        int n     _AND
        FILE *__restrict fp)
 {
+  __A_VARIABLE = 1;
   return _fgets_r (_REENT, buf, n, fp);
 }
 
diff --git a/newlib/libc/stdio/fgets_u.c b/newlib/libc/stdio/fgets_u.c
index b36748d..d7406fc 100644
--- a/newlib/libc/stdio/fgets_u.c
+++ b/newlib/libc/stdio/fgets_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fgetwc.c b/newlib/libc/stdio/fgetwc.c
index d6de4b6..b920a49 100644
--- a/newlib/libc/stdio/fgetwc.c
+++ b/newlib/libc/stdio/fgetwc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002-2004 Tim J. Robbins.
  * All rights reserved.
@@ -229,6 +230,7 @@ _DEFUN(_fgetwc_r, (ptr, fp),
   ORIENT(fp, 1);
   r = __fgetwc (ptr, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -239,5 +241,6 @@ _DEFUN(fgetwc, (fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return _fgetwc_r (reent, fp);
 }
diff --git a/newlib/libc/stdio/fgetwc_u.c b/newlib/libc/stdio/fgetwc_u.c
index 4ccd576..e0c97d1 100644
--- a/newlib/libc/stdio/fgetwc_u.c
+++ b/newlib/libc/stdio/fgetwc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -35,6 +36,7 @@ _DEFUN(_fgetwc_unlocked_r, (ptr, fp),
 	register FILE *fp)
 {
   ORIENT(fp, 1);
+  __A_VARIABLE = 1;
   return __fgetwc (ptr, fp);
 }
 
@@ -45,5 +47,6 @@ _DEFUN(fgetwc_unlocked, (fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return _fgetwc_unlocked_r (reent, fp);
 }
diff --git a/newlib/libc/stdio/fgetws.c b/newlib/libc/stdio/fgetws.c
index ae1f48e..bc854c9 100644
--- a/newlib/libc/stdio/fgetws.c
+++ b/newlib/libc/stdio/fgetws.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002-2004 Tim J. Robbins.
  * All rights reserved.
@@ -192,10 +193,12 @@ _DEFUN(_fgetws_r, (ptr, ws, n, fp),
     goto error;
   *wsp++ = L'\0';
   _newlib_flockfile_exit (fp);
+  __A_VARIABLE = 1;
   return ws;
 
 error:
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -208,5 +211,6 @@ _DEFUN(fgetws, (ws, n, fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT (reent, fp);
+  __A_VARIABLE = 1;
   return _fgetws_r (reent, ws, n, fp);
 }
diff --git a/newlib/libc/stdio/fgetws_u.c b/newlib/libc/stdio/fgetws_u.c
index ae4d7d9..ed6a6d5 100644
--- a/newlib/libc/stdio/fgetws_u.c
+++ b/newlib/libc/stdio/fgetws_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fileno.c b/newlib/libc/stdio/fileno.c
index 7b50582..db13a45 100644
--- a/newlib/libc/stdio/fileno.c
+++ b/newlib/libc/stdio/fileno.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -87,5 +88,6 @@ _DEFUN(fileno, (f),
       _REENT->_errno = EBADF;
     }
   _newlib_flockfile_end (f);
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdio/fileno_u.c b/newlib/libc/stdio/fileno_u.c
index 468d112..b71ec46 100644
--- a/newlib/libc/stdio/fileno_u.c
+++ b/newlib/libc/stdio/fileno_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -42,5 +43,6 @@ _DEFUN(fileno_unlocked, (f),
       result = -1;
       _REENT->_errno = EBADF;
     }
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdio/findfp.c b/newlib/libc/stdio/findfp.c
index 737bde1..4b090d3 100644
--- a/newlib/libc/stdio/findfp.c
+++ b/newlib/libc/stdio/findfp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -86,12 +87,14 @@ _DEFUN(std, (ptr, flags, file),
   if (__stextmode (ptr->_file))
     ptr->_flags |= __SCLE;
 #endif
+  __A_VARIABLE = 1;
 }
 
 static inline void
 stdin_init(FILE *ptr)
 {
   std (ptr,  __SRD, 0);
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -108,6 +111,7 @@ stdout_init(FILE *ptr)
 #else
   std (ptr, __SWR | __SLBF, 1);
 #endif
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -116,6 +120,7 @@ stderr_init(FILE *ptr)
   /* POSIX requires stderr to be opened for reading and writing, even
      when the underlying fd 2 is write-only.  */
   std (ptr, __SRW | __SNBF, 2);
+  __A_VARIABLE = 1;
 }
 
 struct glue_with_file {
@@ -132,12 +137,15 @@ _DEFUN(__sfmoreglue, (d, n),
 
   g = (struct glue_with_file *)
     _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
-  if (g == NULL)
+  if (g == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   g->glue._next = NULL;
   g->glue._niobs = n;
   g->glue._iobs = &g->file;
   memset (&g->file, 0, n * sizeof (FILE));
+  __A_VARIABLE = 1;
   return &g->glue;
 }
 
@@ -168,6 +176,7 @@ _DEFUN(__sfp, (d),
     }
   _newlib_sfp_lock_exit ();
   d->_errno = ENOMEM;
+  __A_VARIABLE = 1;
   return NULL;
 
 found:
@@ -192,6 +201,7 @@ found:
   fp->_lb._base = NULL;		/* no line buffer */
   fp->_lb._size = 0;
 
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -231,6 +241,7 @@ _DEFUN(_cleanup_r, (ptr),
     (*cleanup_func) (ptr, ptr->_stderr);
 #endif
   _CAST_VOID _fwalk_reent (ptr, cleanup_func);
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -238,6 +249,7 @@ _VOID
 _DEFUN_VOID(_cleanup)
 {
   _cleanup_r (_GLOBAL_REENT);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -254,6 +266,7 @@ _DEFUN(__sinit, (s),
   if (s->__sdidinit)
     {
       __sinit_lock_release ();
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -296,6 +309,7 @@ _DEFUN(__sinit, (s),
   s->__sdidinit = 1;
 
   __sinit_lock_release ();
+  __A_VARIABLE = 1;
 }
 
 #ifndef __SINGLE_THREAD__
@@ -307,24 +321,28 @@ _VOID
 _DEFUN_VOID(__sfp_lock_acquire)
 {
   __lock_acquire_recursive (__sfp_recursive_mutex);
+  __A_VARIABLE = 1;
 }
 
 _VOID
 _DEFUN_VOID(__sfp_lock_release)
 {
   __lock_release_recursive (__sfp_recursive_mutex);
+  __A_VARIABLE = 1;
 }
 
 _VOID
 _DEFUN_VOID(__sinit_lock_acquire)
 {
   __lock_acquire_recursive (__sinit_recursive_mutex);
+  __A_VARIABLE = 1;
 }
 
 _VOID
 _DEFUN_VOID(__sinit_lock_release)
 {
   __lock_release_recursive (__sinit_recursive_mutex);
+  __A_VARIABLE = 1;
 }
 
 /* Walkable file locking routine.  */
diff --git a/newlib/libc/stdio/fiprintf.c b/newlib/libc/stdio/fiprintf.c
index 7d417f8..57e1a9a 100644
--- a/newlib/libc/stdio/fiprintf.c
+++ b/newlib/libc/stdio/fiprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -33,6 +34,7 @@ _DEFUN(_fiprintf_r, (ptr, fp, fmt),
   va_start (ap, fmt);
   ret = _vfiprintf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -49,6 +51,7 @@ _DEFUN(fiprintf, (fp, fmt),
   va_start (ap, fmt);
   ret = _vfiprintf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/fiscanf.c b/newlib/libc/stdio/fiscanf.c
index 53fee84..e0302d6 100644
--- a/newlib/libc/stdio/fiscanf.c
+++ b/newlib/libc/stdio/fiscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -47,6 +48,7 @@ fiscanf(FILE *fp, fmt, va_alist)
 #endif
   ret = __svfiscanf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -73,6 +75,7 @@ _fiscanf_r(ptr, FILE *fp, fmt, va_alist)
 #endif
   ret = __svfiscanf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/flags.c b/newlib/libc/stdio/flags.c
index 518cc33..f47b7cc 100644
--- a/newlib/libc/stdio/flags.c
+++ b/newlib/libc/stdio/flags.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 Regents of the University of California.
  * All rights reserved.
@@ -58,6 +59,7 @@ _DEFUN(__sflags, (ptr, mode, optr),
       break;
     default:			/* illegal mode */
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return (0);
     }
   while (*++mode)
@@ -95,5 +97,6 @@ _DEFUN(__sflags, (ptr, mode, optr),
     m |= O_TEXT;
 #endif
   *optr = m | o;
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/fmemopen.c b/newlib/libc/stdio/fmemopen.c
index 17a3c9b..ac2dcf6 100644
--- a/newlib/libc/stdio/fmemopen.c
+++ b/newlib/libc/stdio/fmemopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -91,12 +92,15 @@ _DEFUN(fmemreader, (ptr, cookie, buf, n),
 {
   fmemcookie *c = (fmemcookie *) cookie;
   /* Can't read beyond current size, but EOF condition is not an error.  */
-  if (c->pos > c->eof)
+  if (c->pos > c->eof) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (n >= c->eof - c->pos)
     n = c->eof - c->pos;
   memcpy (buf, c->buf + c->pos, n);
   c->pos += n;
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -207,6 +211,7 @@ _DEFUN(fmemseeker, (ptr, cookie, pos, whence),
 	  c->buf[c->pos] = '\0';
 	}
     }
+  __A_VARIABLE = 1;
   return (_fpos_t) offset;
 }
 
@@ -250,6 +255,7 @@ _DEFUN(fmemseeker64, (ptr, cookie, pos, whence),
 	  c->buf[c->pos] = '\0';
 	}
     }
+  __A_VARIABLE = 1;
   return (_fpos64_t) offset;
 }
 #endif /* __LARGE64_FILES */
@@ -262,6 +268,7 @@ _DEFUN(fmemcloser, (ptr, cookie),
 {
   fmemcookie *c = (fmemcookie *) cookie;
   _free_r (ptr, c->storage);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -279,15 +286,20 @@ _DEFUN(_fmemopen_r, (ptr, buf, size, mode),
   int flags;
   int dummy;
 
-  if ((flags = __sflags (ptr, mode, &dummy)) == 0)
+  if ((flags = __sflags (ptr, mode, &dummy)) == 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if (!size || !(buf || flags & __SRW))
     {
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return NULL;
     }
-  if ((fp = __sfp (ptr)) == NULL)
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if ((c = (fmemcookie *) _malloc_r (ptr, sizeof *c + (buf ? 0 : size)))
       == NULL)
     {
@@ -297,6 +309,7 @@ _DEFUN(_fmemopen_r, (ptr, buf, size, mode),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end ();
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -356,6 +369,7 @@ _DEFUN(_fmemopen_r, (ptr, buf, size, mode),
 #endif
   fp->_close = fmemcloser;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -366,6 +380,7 @@ _DEFUN(fmemopen, (buf, size, mode),
        size_t size _AND
        const char *__restrict mode)
 {
+  __A_VARIABLE = 1;
   return _fmemopen_r (_REENT, buf, size, mode);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/fopen.c b/newlib/libc/stdio/fopen.c
index 6d07561..0ffbe13 100644
--- a/newlib/libc/stdio/fopen.c
+++ b/newlib/libc/stdio/fopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -133,10 +134,14 @@ _DEFUN(_fopen_r, (ptr, file, mode),
   register int f;
   int flags, oflags;
 
-  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
+  if ((flags = __sflags (ptr, mode, &oflags)) == 0) {
+    __A_VARIABLE = 1;
     return NULL;
-  if ((fp = __sfp (ptr)) == NULL)
+  }
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   if ((f = _open_r (ptr, file, oflags, 0666)) < 0)
     {
@@ -146,6 +151,7 @@ _DEFUN(_fopen_r, (ptr, file, mode),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end (); 
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -168,6 +174,7 @@ _DEFUN(_fopen_r, (ptr, file, mode),
 #endif
 
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -178,6 +185,7 @@ _DEFUN(fopen, (file, mode),
        _CONST char *file _AND
        _CONST char *mode)
 {
+  __A_VARIABLE = 1;
   return _fopen_r (_REENT, file, mode);
 }
 
diff --git a/newlib/libc/stdio/fopencookie.c b/newlib/libc/stdio/fopencookie.c
index 3697b48..2f12bb7 100644
--- a/newlib/libc/stdio/fopencookie.c
+++ b/newlib/libc/stdio/fopencookie.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -109,6 +110,7 @@ _DEFUN(fcreader, (ptr, cookie, buf, n),
   errno = 0;
   if ((result = c->readfn (c->cookie, buf, n)) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -132,6 +134,7 @@ _DEFUN(fcwriter, (ptr, cookie, buf, n),
   errno = 0;
   if ((result = c->writefn (c->cookie, buf, n)) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -159,6 +162,7 @@ _DEFUN(fcseeker, (ptr, cookie, pos, whence),
       offset = -1;
     }
 #endif /* __LARGE64_FILES */
+  __A_VARIABLE = 1;
   return (_fpos_t) offset;
 }
 
@@ -175,6 +179,7 @@ _DEFUN(fcseeker64, (ptr, cookie, pos, whence),
   errno = 0;
   if (c->seekfn (c->cookie, &offset, whence) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return (_fpos64_t) offset;
 }
 #endif /* __LARGE64_FILES */
@@ -193,6 +198,7 @@ _DEFUN(fccloser, (ptr, cookie),
 	ptr->_errno = errno;
     }
   _free_r (ptr, c);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -208,16 +214,21 @@ _DEFUN(_fopencookie_r, (ptr, cookie, mode, functions),
   int flags;
   int dummy;
 
-  if ((flags = __sflags (ptr, mode, &dummy)) == 0)
+  if ((flags = __sflags (ptr, mode, &dummy)) == 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if (((flags & (__SRD | __SRW)) && !functions.read)
       || ((flags & (__SWR | __SRW)) && !functions.write))
     {
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return NULL;
     }
-  if ((fp = __sfp (ptr)) == NULL)
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if ((c = (fccookie *) _malloc_r (ptr, sizeof *c)) == NULL)
     {
       _newlib_sfp_lock_start ();
@@ -226,6 +237,7 @@ _DEFUN(_fopencookie_r, (ptr, cookie, mode, functions),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end ();
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -248,6 +260,7 @@ _DEFUN(_fopencookie_r, (ptr, cookie, mode, functions),
   c->closefn = functions.close;
   fp->_close = fccloser;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -258,6 +271,7 @@ _DEFUN(fopencookie, (cookie, mode, functions),
        const char *mode _AND
        cookie_io_functions_t functions)
 {
+  __A_VARIABLE = 1;
   return _fopencookie_r (_REENT, cookie, mode, functions);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/fprintf.c b/newlib/libc/stdio/fprintf.c
index fe92a5b..61ed5f1 100644
--- a/newlib/libc/stdio/fprintf.c
+++ b/newlib/libc/stdio/fprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -33,6 +34,7 @@ _DEFUN(_fprintf_r, (ptr, fp, fmt),
   va_start (ap, fmt);
   ret = _vfprintf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -55,6 +57,7 @@ _DEFUN(fprintf, (fp, fmt),
   va_start (ap, fmt);
   ret = _vfprintf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/fpurge.c b/newlib/libc/stdio/fpurge.c
index dc052e8..e74a3f0 100644
--- a/newlib/libc/stdio/fpurge.c
+++ b/newlib/libc/stdio/fpurge.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2009 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -75,6 +76,7 @@ _DEFUN(_fpurge_r, (ptr, fp),
     {
       ptr->_errno = EBADF;
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return EOF;
     }
   fp->_p = fp->_bf._base;
@@ -87,6 +89,7 @@ _DEFUN(_fpurge_r, (ptr, fp),
   else
     fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -96,6 +99,7 @@ int
 _DEFUN(fpurge, (fp),
        register FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _fpurge_r (_REENT, fp);
 }
 
@@ -106,6 +110,7 @@ _DEFUN(__fpurge, (fp),
        register FILE * fp)
 {
   _fpurge_r (_REENT, fp);
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdio/fputc.c b/newlib/libc/stdio/fputc.c
index 0aad0a9..4ff8edd 100644
--- a/newlib/libc/stdio/fputc.c
+++ b/newlib/libc/stdio/fputc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -121,6 +122,7 @@ _DEFUN(_fputc_r, (ptr, ch, file),
    _newlib_flockfile_start (file);
   result = _putc_r (ptr, ch, file);
   _newlib_flockfile_end (file);
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdio/fputc_u.c b/newlib/libc/stdio/fputc_u.c
index ac64b0b..bfa6345 100644
--- a/newlib/libc/stdio/fputc_u.c
+++ b/newlib/libc/stdio/fputc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -35,6 +36,7 @@ _DEFUN(_fputc_unlocked_r, (ptr, ch, file),
        FILE * file)
 {
   CHECK_INIT(ptr, file);
+  __A_VARIABLE = 1;
   return _putc_unlocked_r (ptr, ch, file);
 }
 
diff --git a/newlib/libc/stdio/fputs.c b/newlib/libc/stdio/fputs.c
index 75f65d9..e1eee4c 100644
--- a/newlib/libc/stdio/fputs.c
+++ b/newlib/libc/stdio/fputs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -131,6 +132,7 @@ _DEFUN(_fputs_r, (ptr, s, fp),
   ORIENT (fp, -1);
   result = __sfvwrite_r (ptr, fp, &uio);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 #else
   _CONST char *p = s;
@@ -163,6 +165,7 @@ _DEFUN(fputs, (s, fp),
        char _CONST *__restrict s _AND
        FILE *__restrict fp)
 {
+  __A_VARIABLE = 1;
   return _fputs_r (_REENT, s, fp);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/fputs_u.c b/newlib/libc/stdio/fputs_u.c
index 3b03cec..c9cc862 100644
--- a/newlib/libc/stdio/fputs_u.c
+++ b/newlib/libc/stdio/fputs_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fputwc.c b/newlib/libc/stdio/fputwc.c
index 9c2ef6c..3abb8cc 100644
--- a/newlib/libc/stdio/fputwc.c
+++ b/newlib/libc/stdio/fputwc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002-2004 Tim J. Robbins.
  * All rights reserved.
@@ -229,6 +230,7 @@ _DEFUN(_fputwc_r, (ptr, wc, fp),
   ORIENT(fp, 1);
   r = __fputwc(ptr, wc, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -240,5 +242,6 @@ _DEFUN(fputwc, (wc, fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return _fputwc_r (reent, wc, fp);
 }
diff --git a/newlib/libc/stdio/fputwc_u.c b/newlib/libc/stdio/fputwc_u.c
index 43be648..320b492 100644
--- a/newlib/libc/stdio/fputwc_u.c
+++ b/newlib/libc/stdio/fputwc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(_fputwc_unlocked_r, (ptr, wc, fp),
 	FILE *fp)
 {
   ORIENT(fp, 1);
+  __A_VARIABLE = 1;
   return __fputwc(ptr, wc, fp);
 }
 
@@ -47,5 +49,6 @@ _DEFUN(fputwc_unlocked, (wc, fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return _fputwc_unlocked_r (reent, wc, fp);
 }
diff --git a/newlib/libc/stdio/fputws.c b/newlib/libc/stdio/fputws.c
index bb2fa6d..a9ac6f4 100644
--- a/newlib/libc/stdio/fputws.c
+++ b/newlib/libc/stdio/fputws.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002-2004 Tim J. Robbins.
  * All rights reserved.
@@ -189,5 +190,6 @@ _DEFUN(fputws, (ws, fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT (reent, fp);
+  __A_VARIABLE = 1;
   return _fputws_r (reent, ws, fp);
 }
diff --git a/newlib/libc/stdio/fputws_u.c b/newlib/libc/stdio/fputws_u.c
index 0583e79..7f0dd62 100644
--- a/newlib/libc/stdio/fputws_u.c
+++ b/newlib/libc/stdio/fputws_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fread.c b/newlib/libc/stdio/fread.c
index c683947..9aaa810 100644
--- a/newlib/libc/stdio/fread.c
+++ b/newlib/libc/stdio/fread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -135,8 +136,10 @@ _DEFUN(crlf_r, (ptr, fp, buf, count, eof),
   int r;
   char *s, *d, *e;
 
-  if (count == 0)
+  if (count == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   e = buf + count;
   for (s=d=buf; s<e-1; s++)
@@ -162,11 +165,14 @@ _DEFUN(crlf_r, (ptr, fp, buf, count, eof),
   while (d < e)
     {
       r = _getc_r (ptr, fp);
-      if (r == EOF)
+      if (r == EOF) {
+        __A_VARIABLE = 1;
         return count - (e-d);
+      }
       *d++ = r;
     }
 
+  __A_VARIABLE = 1;
   return count;
   
 }
@@ -298,6 +304,7 @@ _DEFUN(fread, (buf, size, count, fp),
        size_t count _AND
        FILE *__restrict fp)
 {
+   __A_VARIABLE = 1;
    return _fread_r (_REENT, buf, size, count, fp);
 }
 #endif
diff --git a/newlib/libc/stdio/fread_u.c b/newlib/libc/stdio/fread_u.c
index 48239a9..28fa3a8 100644
--- a/newlib/libc/stdio/fread_u.c
+++ b/newlib/libc/stdio/fread_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/freopen.c b/newlib/libc/stdio/freopen.c
index fb1f6c4..89715cb 100644
--- a/newlib/libc/stdio/freopen.c
+++ b/newlib/libc/stdio/freopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -118,6 +119,7 @@ _DEFUN(_freopen_r, (ptr, file, mode, fp),
       pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
       _fclose_r (ptr, fp);
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -229,6 +231,7 @@ _DEFUN(_freopen_r, (ptr, file, mode, fp),
 #ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
       pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -250,6 +253,7 @@ _DEFUN(_freopen_r, (ptr, file, mode, fp),
 #ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
   pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -261,6 +265,7 @@ _DEFUN(freopen, (file, mode, fp),
        _CONST char *__restrict mode _AND
        register FILE *__restrict fp)
 {
+  __A_VARIABLE = 1;
   return _freopen_r (_REENT, file, mode, fp);
 }
 
diff --git a/newlib/libc/stdio/fscanf.c b/newlib/libc/stdio/fscanf.c
index 87b51dd..ce9a69d 100644
--- a/newlib/libc/stdio/fscanf.c
+++ b/newlib/libc/stdio/fscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -47,6 +48,7 @@ fscanf(FILE *fp, fmt, va_alist)
 #endif
   ret = _vfscanf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -79,6 +81,7 @@ _fscanf_r(ptr, FILE *fp, fmt, va_alist)
 #endif
   ret = _vfscanf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/fseek.c b/newlib/libc/stdio/fseek.c
index b8fc36a..6ad4985 100644
--- a/newlib/libc/stdio/fseek.c
+++ b/newlib/libc/stdio/fseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -111,6 +112,7 @@ _DEFUN(_fseek_r, (ptr, fp, offset, whence),
        long offset        _AND
        int whence)
 {
+  __A_VARIABLE = 1;
   return _fseeko_r (ptr, fp, offset, whence);
 }
 
@@ -122,6 +124,7 @@ _DEFUN(fseek, (fp, offset, whence),
        long offset       _AND
        int whence)
 {
+  __A_VARIABLE = 1;
   return _fseek_r (_REENT, fp, offset, whence);
 }
 
diff --git a/newlib/libc/stdio/fseeko.c b/newlib/libc/stdio/fseeko.c
index 2c9419d..1282bd8 100644
--- a/newlib/libc/stdio/fseeko.c
+++ b/newlib/libc/stdio/fseeko.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -388,6 +389,7 @@ _DEFUN(fseeko, (fp, offset, whence),
        _off_t offset     _AND
        int whence)
 {
+  __A_VARIABLE = 1;
   return _fseeko_r (_REENT, fp, offset, whence);
 }
 
diff --git a/newlib/libc/stdio/fsetlocking.c b/newlib/libc/stdio/fsetlocking.c
index 3c489f5..1e7285d 100644
--- a/newlib/libc/stdio/fsetlocking.c
+++ b/newlib/libc/stdio/fsetlocking.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -84,6 +85,7 @@ _DEFUN(__fsetlocking, (fp, type),
     default:
       break;
     }
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdio/fsetpos.c b/newlib/libc/stdio/fsetpos.c
index d159629..8186ed7 100644
--- a/newlib/libc/stdio/fsetpos.c
+++ b/newlib/libc/stdio/fsetpos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -77,8 +78,11 @@ _DEFUN(_fsetpos_r, (ptr, iop, pos),
 {
   int x = _fseek_r (ptr, iop, *pos, SEEK_SET);
 
-  if (x != 0)
+  if (x != 0) {
+    __A_VARIABLE = 1;
     return 1;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -89,6 +93,7 @@ _DEFUN(fsetpos, (iop, pos),
        FILE * iop _AND
        _CONST _fpos_t * pos)
 {
+  __A_VARIABLE = 1;
   return _fsetpos_r (_REENT, iop, pos);
 }
 
diff --git a/newlib/libc/stdio/ftell.c b/newlib/libc/stdio/ftell.c
index 5af0709..af330a9 100644
--- a/newlib/libc/stdio/ftell.c
+++ b/newlib/libc/stdio/ftell.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -111,6 +112,7 @@ _DEFUN(_ftell_r, (ptr, fp),
       pos = -1;
       ptr->_errno = EOVERFLOW;
     }
+  __A_VARIABLE = 1;
   return (long)pos;
 }
 
@@ -120,6 +122,7 @@ long
 _DEFUN(ftell, (fp),
        register FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _ftell_r (_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio/ftello.c b/newlib/libc/stdio/ftello.c
index 3a1885e..bc597d0 100644
--- a/newlib/libc/stdio/ftello.c
+++ b/newlib/libc/stdio/ftello.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -166,6 +167,7 @@ _off_t
 _DEFUN(ftello, (fp),
        register FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _ftello_r (_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio/funopen.c b/newlib/libc/stdio/funopen.c
index e71d231..b3e8891 100644
--- a/newlib/libc/stdio/funopen.c
+++ b/newlib/libc/stdio/funopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -115,6 +116,7 @@ _DEFUN(funreader, (ptr, cookie, buf, n),
   errno = 0;
   if ((result = c->readfn (c->cookie, buf, n)) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -130,6 +132,7 @@ _DEFUN(funwriter, (ptr, cookie, buf, n),
   errno = 0;
   if ((result = c->writefn (c->cookie, buf, n)) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -157,6 +160,7 @@ _DEFUN(funseeker, (ptr, cookie, off, whence),
       result = -1;
     }
 #endif /* __LARGE64_FILES */
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -173,6 +177,7 @@ _DEFUN(funseeker64, (ptr, cookie, off, whence),
   errno = 0;
   if ((result = c->seekfn (c->cookie, off, whence)) < 0 && errno)
     ptr->_errno = errno;
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* __LARGE64_FILES */
@@ -191,6 +196,7 @@ _DEFUN(funcloser, (ptr, cookie),
 	ptr->_errno = errno;
     }
   _free_r (ptr, c);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -209,10 +215,13 @@ _DEFUN(_funopen_r, (ptr, cookie, readfn, writefn, seekfn, closefn),
   if (!readfn && !writefn)
     {
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return NULL;
     }
-  if ((fp = __sfp (ptr)) == NULL)
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if ((c = (funcookie *) _malloc_r (ptr, sizeof *c)) == NULL)
     {
       _newlib_sfp_lock_start ();
@@ -221,6 +230,7 @@ _DEFUN(_funopen_r, (ptr, cookie, readfn, writefn, seekfn, closefn),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end ();
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -262,6 +272,7 @@ _DEFUN(_funopen_r, (ptr, cookie, readfn, writefn, seekfn, closefn),
   c->closefn = closefn;
   fp->_close = funcloser;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -274,6 +285,7 @@ _DEFUN(funopen, (cookie, readfn, writefn, seekfn, closefn),
        funseek seekfn _AND
        funclose closefn)
 {
+  __A_VARIABLE = 1;
   return _funopen_r (_REENT, cookie, readfn, writefn, seekfn, closefn);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/fvwrite.c b/newlib/libc/stdio/fvwrite.c
index 4556660..1185602 100644
--- a/newlib/libc/stdio/fvwrite.c
+++ b/newlib/libc/stdio/fvwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fwalk.c b/newlib/libc/stdio/fwalk.c
index cceaa96..fdf1c09 100644
--- a/newlib/libc/stdio/fwalk.c
+++ b/newlib/libc/stdio/fwalk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -49,6 +50,7 @@ _DEFUN(_fwalk, (ptr, function),
       if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 	ret |= (*function) (fp);
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -76,5 +78,6 @@ _DEFUN(_fwalk_reent, (ptr, reent_function),
       if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 	ret |= (*reent_function) (ptr, fp);
 
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/fwide.c b/newlib/libc/stdio/fwide.c
index b2aaf8a..d62f002 100644
--- a/newlib/libc/stdio/fwide.c
+++ b/newlib/libc/stdio/fwide.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<fwide>>---set and determine the orientation of a FILE stream
@@ -77,6 +78,7 @@ _DEFUN(_fwide_r, (ptr, fp, mode),
   else
     ret = (fp->_flags2 & __SWID) ? 1 : -1;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -85,5 +87,6 @@ _DEFUN(fwide, (fp, mode),
 	FILE *fp _AND
 	int mode)
 {
+  __A_VARIABLE = 1;
   return _fwide_r (_REENT, fp, mode);
 }
diff --git a/newlib/libc/stdio/fwprintf.c b/newlib/libc/stdio/fwprintf.c
index 4b05824..97f171c 100644
--- a/newlib/libc/stdio/fwprintf.c
+++ b/newlib/libc/stdio/fwprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -34,6 +35,7 @@ _DEFUN(_fwprintf_r, (ptr, fp, fmt),
   va_start (ap, fmt);
   ret = _vfwprintf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -50,6 +52,7 @@ _DEFUN(fwprintf, (fp, fmt),
   va_start (ap, fmt);
   ret = _vfwprintf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/fwrite.c b/newlib/libc/stdio/fwrite.c
index d910247..9bf53da 100644
--- a/newlib/libc/stdio/fwrite.c
+++ b/newlib/libc/stdio/fwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -170,9 +171,11 @@ _DEFUN(_fwrite_r, (ptr, buf, size, count, fp),
   if (__sfvwrite_r (ptr, fp, &uio) == 0)
     {
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return count;
     }
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return (n - uio.uio_resid) / size;
 #else
   size_t i = 0;
@@ -211,6 +214,7 @@ _DEFUN(fwrite, (buf, size, count, fp),
        size_t count    _AND
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _fwrite_r (_REENT, buf, size, count, fp);
 }
 #endif
diff --git a/newlib/libc/stdio/fwrite_u.c b/newlib/libc/stdio/fwrite_u.c
index 80154a0..6ed0607 100644
--- a/newlib/libc/stdio/fwrite_u.c
+++ b/newlib/libc/stdio/fwrite_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
diff --git a/newlib/libc/stdio/fwscanf.c b/newlib/libc/stdio/fwscanf.c
index 8572f41..2aec675 100644
--- a/newlib/libc/stdio/fwscanf.c
+++ b/newlib/libc/stdio/fwscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -34,6 +35,7 @@ fwscanf (FILE *__restrict fp, _CONST wchar_t *__restrict fmt, ...)
   va_start (ap, fmt);
   ret = _vfwscanf_r (_REENT, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -48,6 +50,7 @@ _fwscanf_r (struct _reent *ptr, FILE *fp, _CONST wchar_t *fmt, ...)
   va_start (ap, fmt);
   ret = _vfwscanf_r (ptr, fp, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/getc.c b/newlib/libc/stdio/getc.c
index 7951cdc..2df626c 100644
--- a/newlib/libc/stdio/getc.c
+++ b/newlib/libc/stdio/getc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -95,6 +96,7 @@ _DEFUN(_getc_r, (ptr, fp),
   _newlib_flockfile_start (fp);
   result = __sgetc_r (ptr, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -111,6 +113,7 @@ _DEFUN(getc, (fp),
   _newlib_flockfile_start (fp);
   result = __sgetc_r (reent, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdio/getc_u.c b/newlib/libc/stdio/getc_u.c
index 6b71ce5..f82356d 100644
--- a/newlib/libc/stdio/getc_u.c
+++ b/newlib/libc/stdio/getc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -75,6 +76,7 @@ _DEFUN(_getc_unlocked_r, (ptr, fp),
 {
   /* CHECK_INIT is called (eventually) by __srefill_r.  */
 
+  __A_VARIABLE = 1;
   return __sgetc_r (ptr, fp);
 }
 
@@ -84,6 +86,7 @@ int
 _DEFUN(getc_unlocked, (fp),
        register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return __sgetc_r (_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio/getchar.c b/newlib/libc/stdio/getchar.c
index 7f3ceac..7237573 100644
--- a/newlib/libc/stdio/getchar.c
+++ b/newlib/libc/stdio/getchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -83,6 +84,7 @@ _DEFUN(_getchar_r, (reent),
        struct _reent *reent)
 {
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _getc_r (reent, _stdin_r (reent));
 }
 
@@ -95,6 +97,7 @@ _DEFUN_VOID(getchar)
 
   /* CHECK_INIT is called (eventually) by __srefill_r.  */
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _getc_r (reent, _stdin_r (reent));
 }
 
diff --git a/newlib/libc/stdio/getchar_u.c b/newlib/libc/stdio/getchar_u.c
index 516b4db..c2c858a 100644
--- a/newlib/libc/stdio/getchar_u.c
+++ b/newlib/libc/stdio/getchar_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -73,6 +74,7 @@ int
 _DEFUN(_getchar_unlocked_r, (ptr),
        struct _reent *ptr)
 {
+  __A_VARIABLE = 1;
   return _getc_unlocked_r (ptr, _stdin_r (ptr));
 }
 
@@ -83,6 +85,7 @@ _DEFUN_VOID(getchar_unlocked)
 {
   /* CHECK_INIT is called (eventually) by __srefill_r.  */
 
+  __A_VARIABLE = 1;
   return _getc_unlocked_r (_REENT, _stdin_r (_REENT));
 }
 
diff --git a/newlib/libc/stdio/getdelim.c b/newlib/libc/stdio/getdelim.c
index 63a579a..1e7b3ec 100644
--- a/newlib/libc/stdio/getdelim.c
+++ b/newlib/libc/stdio/getdelim.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. - all rights reserved */
 /*
 FUNCTION
@@ -64,6 +65,7 @@ _DEFUN(__getdelim, (bufptr, n, delim, fp),
   if (fp == NULL || bufptr == NULL || n == NULL)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -73,6 +75,7 @@ _DEFUN(__getdelim, (bufptr, n, delim, fp),
       buf = (char *)realloc (*bufptr, DEFAULT_LINE_SIZE);
       if (buf == NULL)
         {
+	  __A_VARIABLE = 1;
 	  return -1;
         }
       *bufptr = buf;
@@ -132,11 +135,14 @@ _DEFUN(__getdelim, (bufptr, n, delim, fp),
   _newlib_flockfile_end (fp);
 
   /* if no input data, return failure */
-  if (ptr == buf)
+  if (ptr == buf) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* otherwise, nul-terminate and return number of bytes read */
   *ptr = '\0';
+  __A_VARIABLE = 1;
   return (ssize_t)(ptr - buf);
 }
 
diff --git a/newlib/libc/stdio/getline.c b/newlib/libc/stdio/getline.c
index c758ae9..e11d489 100644
--- a/newlib/libc/stdio/getline.c
+++ b/newlib/libc/stdio/getline.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. - all rights reserved */
 /*
 FUNCTION
@@ -49,6 +50,7 @@ _DEFUN(__getline, (lptr, n, fp),
        size_t *n   _AND
        FILE *fp)
 {
+  __A_VARIABLE = 1;
   return __getdelim (lptr, n, '\n', fp);
 }
 
diff --git a/newlib/libc/stdio/gets.c b/newlib/libc/stdio/gets.c
index 6c21f3e..5cb0783 100644
--- a/newlib/libc/stdio/gets.c
+++ b/newlib/libc/stdio/gets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -107,6 +108,7 @@ char *
 _DEFUN(gets, (buf),
        char *buf)
 {
+  __A_VARIABLE = 1;
   return _gets_r (_REENT, buf);
 }
 
diff --git a/newlib/libc/stdio/getw.c b/newlib/libc/stdio/getw.c
index 210c593..af22ee1 100644
--- a/newlib/libc/stdio/getw.c
+++ b/newlib/libc/stdio/getw.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -63,7 +64,10 @@ _DEFUN(getw, (fp),
        register FILE *fp)
 {
   int result;
-  if (fread ((char*)&result, sizeof (result), 1, fp) != 1)
+  if (fread ((char*)&result, sizeof (result), 1, fp) != 1) {
+    __A_VARIABLE = 1;
     return EOF;
+  }
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdio/getwc.c b/newlib/libc/stdio/getwc.c
index 6d88fa8..1fffaca 100644
--- a/newlib/libc/stdio/getwc.c
+++ b/newlib/libc/stdio/getwc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002 Tim J. Robbins.
  * All rights reserved.
@@ -37,6 +38,7 @@ _DEFUN(_getwc_r, (ptr, fp),
 	struct _reent *ptr _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _fgetwc_r (ptr, fp);
 }
 
@@ -48,5 +50,6 @@ wint_t
 _DEFUN(getwc, (fp),
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return fgetwc(fp);
 }
diff --git a/newlib/libc/stdio/getwc_u.c b/newlib/libc/stdio/getwc_u.c
index 613b69e..215dd83 100644
--- a/newlib/libc/stdio/getwc_u.c
+++ b/newlib/libc/stdio/getwc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -38,6 +39,7 @@ _DEFUN(_getwc_unlocked_r, (ptr, fp),
 	struct _reent *ptr _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _fgetwc_unlocked_r (ptr, fp);
 }
 
@@ -49,5 +51,6 @@ wint_t
 _DEFUN(getwc_unlocked, (fp),
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return fgetwc_unlocked(fp);
 }
diff --git a/newlib/libc/stdio/getwchar.c b/newlib/libc/stdio/getwchar.c
index 7ab230a..200da54 100644
--- a/newlib/libc/stdio/getwchar.c
+++ b/newlib/libc/stdio/getwchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002 Tim J. Robbins.
  * All rights reserved.
@@ -112,6 +113,7 @@ wint_t
 _DEFUN (_getwchar_r, (ptr),
 	struct _reent *ptr)
 {
+  __A_VARIABLE = 1;
   return _fgetwc_r (ptr, stdin);
 }
 
@@ -122,5 +124,6 @@ wint_t
 _DEFUN_VOID (getwchar)
 {
   _REENT_SMALL_CHECK_INIT (_REENT);
+  __A_VARIABLE = 1;
   return fgetwc (stdin);
 }
diff --git a/newlib/libc/stdio/getwchar_u.c b/newlib/libc/stdio/getwchar_u.c
index f5c50cc..6474b1b 100644
--- a/newlib/libc/stdio/getwchar_u.c
+++ b/newlib/libc/stdio/getwchar_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -37,6 +38,7 @@ wint_t
 _DEFUN (_getwchar_unlocked_r, (ptr),
 	struct _reent *ptr)
 {
+  __A_VARIABLE = 1;
   return _fgetwc_unlocked_r (ptr, stdin);
 }
 
@@ -47,5 +49,6 @@ wint_t
 _DEFUN_VOID (getwchar_unlocked)
 {
   _REENT_SMALL_CHECK_INIT (_REENT);
+  __A_VARIABLE = 1;
   return fgetwc_unlocked (stdin);
 }
diff --git a/newlib/libc/stdio/iprintf.c b/newlib/libc/stdio/iprintf.c
index c55f7ce..f81545e 100644
--- a/newlib/libc/stdio/iprintf.c
+++ b/newlib/libc/stdio/iprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(iprintf, (fmt),
   va_start (ap, fmt);
   ret = _vfiprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -53,5 +55,6 @@ _DEFUN(_iprintf_r, (ptr, fmt),
   va_start (ap, fmt);
   ret = _vfiprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/iscanf.c b/newlib/libc/stdio/iscanf.c
index f35acd2..63ab70c 100644
--- a/newlib/libc/stdio/iscanf.c
+++ b/newlib/libc/stdio/iscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -47,6 +48,7 @@ iscanf(fmt, va_alist)
 #endif
   ret = __svfiscanf_r (_REENT, _stdin_r (_REENT), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -73,6 +75,7 @@ _iscanf_r(ptr, fmt, va_alist)
 #endif
   ret = __svfiscanf_r (ptr, _stdin_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/makebuf.c b/newlib/libc/stdio/makebuf.c
index ab20a08..3f897a6 100644
--- a/newlib/libc/stdio/makebuf.c
+++ b/newlib/libc/stdio/makebuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -48,6 +49,7 @@ _DEFUN(__smakebuf_r, (ptr, fp),
     {
       fp->_bf._base = fp->_p = fp->_nbuf;
       fp->_bf._size = 1;
+      __A_VARIABLE = 1;
       return;
     }
   flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
@@ -70,6 +72,7 @@ _DEFUN(__smakebuf_r, (ptr, fp),
 	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
       fp->_flags |= flags;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
diff --git a/newlib/libc/stdio/mktemp.c b/newlib/libc/stdio/mktemp.c
index ecbc7af..c9de16b 100644
--- a/newlib/libc/stdio/mktemp.c
+++ b/newlib/libc/stdio/mktemp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1987 Regents of the University of California.
  * All rights reserved.
@@ -269,6 +270,7 @@ _DEFUN(_mkstemp_r, (ptr, path),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, &fd, 0, 0, O_BINARY) ? fd : -1);
 }
 
@@ -278,6 +280,7 @@ _DEFUN(_mkdtemp_r, (ptr, path),
        struct _reent *ptr _AND
        char *path)
 {
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, (int *) NULL, 1, 0, 0) ? path : NULL);
 }
 
@@ -289,6 +292,7 @@ _DEFUN(_mkstemps_r, (ptr, path, len),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, &fd, 0, len, O_BINARY) ? fd : -1);
 }
 
@@ -300,6 +304,7 @@ _DEFUN(_mkostemp_r, (ptr, path, flags),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, &fd, 0, 0, flags & ~O_ACCMODE) ? fd : -1);
 }
 
@@ -312,6 +317,7 @@ _DEFUN(_mkostemps_r, (ptr, path, len, flags),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, &fd, 0, len, flags & ~O_ACCMODE) ? fd : -1);
 }
 #endif /* _ELIX_LEVEL */
@@ -321,6 +327,7 @@ _DEFUN(_mktemp_r, (ptr, path),
        struct _reent *ptr _AND
        char *path)
 {
+  __A_VARIABLE = 1;
   return (_gettemp (ptr, path, (int *) NULL, 0, 0, 0) ? path : (char *) NULL);
 }
 
@@ -332,6 +339,7 @@ _DEFUN(mkstemp, (path),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, &fd, 0, 0, O_BINARY) ? fd : -1);
 }
 
@@ -340,6 +348,7 @@ char *
 _DEFUN(mkdtemp, (path),
        char *path)
 {
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, (int *) NULL, 1, 0, 0) ? path : NULL);
 }
 
@@ -350,6 +359,7 @@ _DEFUN(mkstemps, (path, len),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, &fd, 0, len, O_BINARY) ? fd : -1);
 }
 
@@ -360,6 +370,7 @@ _DEFUN(mkostemp, (path, flags),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, &fd, 0, 0, flags & ~O_ACCMODE) ? fd : -1);
 }
 
@@ -371,6 +382,7 @@ _DEFUN(mkostemps, (path, len, flags),
 {
   int fd;
 
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, &fd, 0, len, flags & ~O_ACCMODE) ? fd : -1);
 }
 # endif /* _ELIX_LEVEL */
@@ -379,6 +391,7 @@ char *
 _DEFUN(mktemp, (path),
        char *path)
 {
+  __A_VARIABLE = 1;
   return (_gettemp (_REENT, path, (int *) NULL, 0, 0, 0) ? path : (char *) NULL);
 }
 
diff --git a/newlib/libc/stdio/nano-vfprintf.c b/newlib/libc/stdio/nano-vfprintf.c
index f106a41..4b46aea 100644
--- a/newlib/libc/stdio/nano-vfprintf.c
+++ b/newlib/libc/stdio/nano-vfprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -232,10 +233,12 @@ _DEFUN(__ssputs_r, (ptr, fp, buf, len),
   (void)memmove ((_PTR) fp->_p, (_PTR) buf, (size_t) (w));
   fp->_w -= w;
   fp->_p += w;
+  __A_VARIABLE = 1;
   return 0;
 
 err:
   fp->_flags |= __SERR;
+  __A_VARIABLE = 1;
   return EOF;
 }
 /* __ssprint_r is the original implementation of __SPRINT.  In nano
@@ -259,6 +262,7 @@ _DEFUN(__ssprint_r, (ptr, fp, uio),
   if (uio->uio_resid == 0)
     {
       uio->uio_iovcnt = 0;
+      __A_VARIABLE = 1;
       return (0);
     }
 
@@ -333,12 +337,14 @@ _DEFUN(__ssprint_r, (ptr, fp, uio),
 
   uio->uio_resid = 0;
   uio->uio_iovcnt = 0;
+  __A_VARIABLE = 1;
   return 0;
 
 err:
   fp->_flags |= __SERR;
   uio->uio_resid = 0;
   uio->uio_iovcnt = 0;
+  __A_VARIABLE = 1;
   return EOF;
 }
 #else
@@ -357,6 +363,7 @@ _DEFUN(__sprint_r, (ptr, fp, uio),
   if (uio->uio_resid == 0)
     {
       uio->uio_iovcnt = 0;
+      __A_VARIABLE = 1;
       return 0;
     }
 #ifdef _WIDE_ORIENT
@@ -388,6 +395,7 @@ _DEFUN(__sprint_r, (ptr, fp, uio),
 out:
   uio->uio_resid = 0;
   uio->uio_iovcnt = 0;
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -449,6 +457,7 @@ _DEFUN(VFPRINTF, (fp, fmt0, ap),
 {
   int result;
   result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -497,6 +506,7 @@ _DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
   if (cantwrite (data, fp))
     {
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return (EOF);
     }
 
@@ -508,6 +518,7 @@ _DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       if (!fp->_p)
 	{
 	  data->_errno = ENOMEM;
+	  __A_VARIABLE = 1;
 	  return EOF;
 	}
       fp->_bf._size = 64;
@@ -651,6 +662,7 @@ error:
 #ifndef STRING_ONLY
   _newlib_flockfile_end (fp);
 #endif
+  __A_VARIABLE = 1;
   return (__sferror (fp) ? EOF : prt_data.ret);
 }
 
diff --git a/newlib/libc/stdio/nano-vfprintf_float.c b/newlib/libc/stdio/nano-vfprintf_float.c
index aca24ae..17d244d 100644
--- a/newlib/libc/stdio/nano-vfprintf_float.c
+++ b/newlib/libc/stdio/nano-vfprintf_float.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -117,6 +118,7 @@ __cvt (struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
 	*rve++ = '0';
     }
   *length = rve - digits;
+  __A_VARIABLE = 1;
   return (digits);
 }
 
@@ -156,6 +158,7 @@ __exponent (char *p0, int exp, int fmtch)
 	*p++ = '0';
       *p++ = to_char (exp);
     }
+  __A_VARIABLE = 1;
   return (p - p0);
 }
 
@@ -354,8 +357,10 @@ print_float:
   if (pdata->flags & LADJUST)
     PAD (pdata->width - realsz, pdata->blank);
 
+  __A_VARIABLE = 1;
   return (pdata->width > realsz ? pdata->width : realsz);
 error:
+  __A_VARIABLE = 1;
   return -1;
 
 #undef _fpvalue
diff --git a/newlib/libc/stdio/nano-vfprintf_i.c b/newlib/libc/stdio/nano-vfprintf_i.c
index 46945b3..efd8db6 100644
--- a/newlib/libc/stdio/nano-vfprintf_i.c
+++ b/newlib/libc/stdio/nano-vfprintf_i.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2012-2014 ARM Ltd
  * All rights reserved.
@@ -100,6 +101,7 @@ _printf_common (struct _reent *data,
     n += pdata->dprec - pdata->size;
 
   PAD (n, pdata->zero);
+  __A_VARIABLE = 1;
   return 0;
 error:
   return -1;
@@ -243,8 +245,10 @@ non_number_nosign:
     if (pdata->flags & LADJUST)
       PAD (pdata->width - realsz, pdata->blank);
 
+    __A_VARIABLE = 1;
     return (pdata->width > realsz ? pdata->width : realsz);
 error:
+    __A_VARIABLE = 1;
     return -1;
 }
 
diff --git a/newlib/libc/stdio/nano-vfscanf.c b/newlib/libc/stdio/nano-vfscanf.c
index 5ba00f7..49e30a6 100644
--- a/newlib/libc/stdio/nano-vfscanf.c
+++ b/newlib/libc/stdio/nano-vfscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -175,6 +176,7 @@ _DEFUN(VFSCANF, (fp, fmt, ap),
        va_list ap)
 {
   CHECK_INIT(_REENT, fp);
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (_REENT, fp, fmt, ap);
 }
 
@@ -188,6 +190,7 @@ _DEFUN(__SVFSCANF, (fp, fmt0, ap),
        char _CONST *fmt0 _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (_REENT, fp, fmt0, ap);
 }
 
@@ -201,6 +204,7 @@ _DEFUN(_VFSCANF_R, (data, fp, fmt, ap),
        va_list ap)
 {
   CHECK_INIT(data, fp);
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (data, fp, fmt, ap);
 }
 
@@ -219,8 +223,10 @@ _DEFUN(_sungetc_r, (data, fp, ch),
 	int c               _AND
 	register FILE *fp)
 {
-  if (c == EOF)
+  if (c == EOF) {
+    __A_VARIABLE = 1;
     return (EOF);
+  }
 
   /* After ungetc, we won't be at eof anymore.  */
   fp->_flags &= ~__SEOF;
@@ -231,11 +237,14 @@ _DEFUN(_sungetc_r, (data, fp, ch),
 
   if (HASUB (fp))
     {
-      if (fp->_r >= fp->_ub._size && __submore (data, fp))
+      if (fp->_r >= fp->_ub._size && __submore (data, fp)) {
+        __A_VARIABLE = 1;
         return EOF;
+      }
 
       *--fp->_p = c;
       fp->_r++;
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -246,6 +255,7 @@ _DEFUN(_sungetc_r, (data, fp, ch),
     {
       fp->_p--;
       fp->_r++;
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -258,6 +268,7 @@ _DEFUN(_sungetc_r, (data, fp, ch),
   fp->_ubuf[sizeof (fp->_ubuf) - 1] = c;
   fp->_p = &fp->_ubuf[sizeof (fp->_ubuf) - 1];
   fp->_r = 1;
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -275,6 +286,7 @@ _DEFUN(__ssrefill_r, (ptr, fp),
       if ((fp->_r = fp->_ur) != 0)
         {
           fp->_p = fp->_up;
+	  __A_VARIABLE = 1;
 	  return 0;
         }
     }
@@ -283,6 +295,7 @@ _DEFUN(__ssrefill_r, (ptr, fp),
   fp->_p = fp->_bf._base;
   fp->_r = 0;
   fp->_flags |= __SEOF;
+  __A_VARIABLE = 1;
   return EOF;
 }
 
@@ -421,6 +434,7 @@ _DEFUN(__SVFSCANF_R, (rptr, fp, fmt0, ap),
 	/* Disgusting backwards compatibility hacks.	XXX.  */
 	case '\0':		/* compat.  */
 	  _newlib_flockfile_exit (fp);
+	  __A_VARIABLE = 1;
 	  return EOF;
 
 #ifdef FLOATING_POINT
@@ -477,12 +491,14 @@ input_failure:
      invalid format string), return EOF if no matches yet, else number
      of matches made prior to failure.  */
   _newlib_flockfile_exit (fp);
+  __A_VARIABLE = 1;
   return scan_data.nassigned && !(fp->_flags & __SERR) ? scan_data.nassigned
 						       : EOF;
 match_failure:
 all_done:
   /* Return number of matches, which can be 0 on match failure.  */
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return scan_data.nassigned;
 }
 
diff --git a/newlib/libc/stdio/nano-vfscanf_float.c b/newlib/libc/stdio/nano-vfscanf_float.c
index a81fe7f..7465457 100644
--- a/newlib/libc/stdio/nano-vfscanf_float.c
+++ b/newlib/libc/stdio/nano-vfscanf_float.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/stdio/nano-vfscanf_i.c b/newlib/libc/stdio/nano-vfscanf_i.c
index aba74b0..2cd667c 100644
--- a/newlib/libc/stdio/nano-vfscanf_i.c
+++ b/newlib/libc/stdio/nano-vfscanf_i.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2012-2014 ARM Ltd
  * All rights reserved.
@@ -78,8 +79,10 @@ _scanf_chars (struct _reent *rptr,
   /* For CT_CHAR, it is impossible to have input_failure(n == 0) here.
      For CT_CCL, it is impossible to have input_failure here.
      For CT_STRING, it is possible to have empty string.  */
-  if (n == 0 && pdata->code == CT_CCL)
+  if (n == 0 && pdata->code == CT_CCL) {
+    __A_VARIABLE = 1;
     return MATCH_FAILURE;
+  }
 
   if ((pdata->flags & SUPPRESS) == 0)
     {
@@ -88,6 +91,7 @@ _scanf_chars (struct _reent *rptr,
 	*p = 0;
     }
   pdata->nread += n;
+  __A_VARIABLE = 1;
   return 0;
 }
 int
diff --git a/newlib/libc/stdio/open_memstream.c b/newlib/libc/stdio/open_memstream.c
index 5de9947..2b4b570 100644
--- a/newlib/libc/stdio/open_memstream.c
+++ b/newlib/libc/stdio/open_memstream.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -107,6 +108,7 @@ _DEFUN(memwriter, (ptr, cookie, buf, n),
   if (sizeof (OFF_T) == sizeof (size_t) && (ssize_t) (c->pos + n) < 0)
     {
       ptr->_errno = EFBIG;
+      __A_VARIABLE = 1;
       return EOF;
     }
   /* Grow the buffer, if necessary.  Choose a geometric growth factor
@@ -120,8 +122,10 @@ _DEFUN(memwriter, (ptr, cookie, buf, n),
       if (newsize < c->pos + n + 1)
 	newsize = c->pos + n + 1;
       cbuf = _realloc_r (ptr, cbuf, newsize);
-      if (! cbuf)
-	return EOF; /* errno already set to ENOMEM */
+      if (! cbuf) {
+	__A_VARIABLE = 1;
+	return EOF;
+      } /* errno already set to ENOMEM */
       *c->pbuf = cbuf;
       c->max = newsize;
     }
@@ -141,6 +145,7 @@ _DEFUN(memwriter, (ptr, cookie, buf, n),
     c->saved.c = cbuf[c->pos];
   cbuf[c->pos] = '\0';
   *c->psize = (c->wide > 0) ? c->pos / sizeof (wchar_t) : c->pos;
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -208,6 +213,7 @@ _DEFUN(memseeker, (ptr, cookie, pos, whence),
       else
 	*c->psize = c->eof;
     }
+  __A_VARIABLE = 1;
   return (_fpos_t) offset;
 }
 
@@ -269,6 +275,7 @@ _DEFUN(memseeker64, (ptr, cookie, pos, whence),
       else
 	*c->psize = c->eof;
     }
+  __A_VARIABLE = 1;
   return (_fpos64_t) offset;
 }
 #endif /* __LARGE64_FILES */
@@ -289,6 +296,7 @@ _DEFUN(memcloser, (ptr, cookie),
   if (buf)
     *c->pbuf = buf;
   _free_r (ptr, c->storage);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -307,10 +315,13 @@ _DEFUN(internal_open_memstream_r, (ptr, buf, size, wide),
   if (!buf || !size)
     {
       ptr->_errno = EINVAL;
+      __A_VARIABLE = 1;
       return NULL;
     }
-  if ((fp = __sfp (ptr)) == NULL)
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   if ((c = (memstream *) _malloc_r (ptr, sizeof *c)) == NULL)
     {
       _newlib_sfp_lock_start ();
@@ -319,6 +330,7 @@ _DEFUN(internal_open_memstream_r, (ptr, buf, size, wide),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end ();
+      __A_VARIABLE = 1;
       return NULL;
     }
   /* Use *size as a hint for initial sizing, but bound the initial
@@ -345,6 +357,7 @@ _DEFUN(internal_open_memstream_r, (ptr, buf, size, wide),
 #endif
       _newlib_sfp_lock_end ();
       _free_r (ptr, c);
+      __A_VARIABLE = 1;
       return NULL;
     }
   if (wide == 1)
@@ -374,6 +387,7 @@ _DEFUN(internal_open_memstream_r, (ptr, buf, size, wide),
   fp->_close = memcloser;
   ORIENT (fp, wide);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -383,6 +397,7 @@ _DEFUN(_open_memstream_r, (ptr, buf, size),
        char **buf _AND
        size_t *size)
 {
+  __A_VARIABLE = 1;
   return internal_open_memstream_r (ptr, buf, size, -1);
 }
 
@@ -392,6 +407,7 @@ _DEFUN(_open_wmemstream_r, (ptr, buf, size),
        wchar_t **buf _AND
        size_t *size)
 {
+  __A_VARIABLE = 1;
   return internal_open_memstream_r (ptr, (char **)buf, size, 1);
 }
 
@@ -401,6 +417,7 @@ _DEFUN(open_memstream, (buf, size),
        char **buf _AND
        size_t *size)
 {
+  __A_VARIABLE = 1;
   return _open_memstream_r (_REENT, buf, size);
 }
 
@@ -409,6 +426,7 @@ _DEFUN(open_wmemstream, (buf, size),
        wchar_t **buf _AND
        size_t *size)
 {
+  __A_VARIABLE = 1;
   return _open_wmemstream_r (_REENT, buf, size);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/perror.c b/newlib/libc/stdio/perror.c
index 14b4d21..ff6f441 100644
--- a/newlib/libc/stdio/perror.c
+++ b/newlib/libc/stdio/perror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -86,6 +87,7 @@ _DEFUN(_perror_r, (ptr, s),
     fputs (error, _stderr_r (ptr));
 
   fputc ('\n', _stderr_r (ptr));
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -95,6 +97,7 @@ _DEFUN(perror, (s),
        _CONST char *s)
 {
   _perror_r (_REENT, s);
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdio/printf.c b/newlib/libc/stdio/printf.c
index d5dedf9..13e07b8 100644
--- a/newlib/libc/stdio/printf.c
+++ b/newlib/libc/stdio/printf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -34,6 +35,7 @@ _DEFUN(_printf_r, (ptr, fmt),
   va_start (ap, fmt);
   ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -57,6 +59,7 @@ _DEFUN(printf, (fmt),
   va_start (ap, fmt);
   ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/putc.c b/newlib/libc/stdio/putc.c
index 2b1fd1b..bf6292e 100644
--- a/newlib/libc/stdio/putc.c
+++ b/newlib/libc/stdio/putc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -100,6 +101,7 @@ _DEFUN(_putc_r, (ptr, c, fp),
   _newlib_flockfile_start (fp);
   result = __sputc_r (ptr, c, fp);
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdio/putc_u.c b/newlib/libc/stdio/putc_u.c
index f710aaf..6d15adf 100644
--- a/newlib/libc/stdio/putc_u.c
+++ b/newlib/libc/stdio/putc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -77,6 +78,7 @@ _DEFUN(_putc_unlocked_r, (ptr, c, fp),
 {
   /* CHECK_INIT is (eventually) called by __swbuf.  */
 
+  __A_VARIABLE = 1;
   return __sputc_r (ptr, c, fp);
 }
 
@@ -88,6 +90,7 @@ _DEFUN(putc_unlocked, (c, fp),
 {
   /* CHECK_INIT is (eventually) called by __swbuf.  */
 
+  __A_VARIABLE = 1;
   return __sputc_r (_REENT, c, fp);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/putchar.c b/newlib/libc/stdio/putchar.c
index bb27dc4..373ec2b 100644
--- a/newlib/libc/stdio/putchar.c
+++ b/newlib/libc/stdio/putchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -81,6 +82,7 @@ _DEFUN(_putchar_r, (ptr, c),
        int c)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return _putc_r (ptr, c, _stdout_r (ptr));
 }
 
@@ -93,6 +95,7 @@ _DEFUN(putchar, (c),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _putc_r (reent, c, _stdout_r (reent));
 }
 
diff --git a/newlib/libc/stdio/putchar_u.c b/newlib/libc/stdio/putchar_u.c
index a866c77..5fb40c0 100644
--- a/newlib/libc/stdio/putchar_u.c
+++ b/newlib/libc/stdio/putchar_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -65,6 +66,7 @@ _DEFUN(_putchar_unlocked_r, (ptr, c),
        struct _reent *ptr _AND
        int c)
 {
+  __A_VARIABLE = 1;
   return putc_unlocked (c, _stdout_r (ptr));
 }
 
@@ -76,6 +78,7 @@ _DEFUN(putchar_unlocked, (c),
 {
   /* CHECK_INIT is (eventually) called by __swbuf.  */
 
+  __A_VARIABLE = 1;
   return _putchar_unlocked_r (_REENT, c);
 }
 
diff --git a/newlib/libc/stdio/puts.c b/newlib/libc/stdio/puts.c
index 7467371..78ccf81 100644
--- a/newlib/libc/stdio/puts.c
+++ b/newlib/libc/stdio/puts.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -100,6 +101,7 @@ _DEFUN(_puts_r, (ptr, s),
   ORIENT (fp, -1);
   result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return result;
 #else
   int result = EOF;
@@ -137,6 +139,7 @@ int
 _DEFUN(puts, (s),
        char _CONST * s)
 {
+  __A_VARIABLE = 1;
   return _puts_r (_REENT, s);
 }
 
diff --git a/newlib/libc/stdio/putw.c b/newlib/libc/stdio/putw.c
index 682015c..4cfb887 100644
--- a/newlib/libc/stdio/putw.c
+++ b/newlib/libc/stdio/putw.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -59,7 +60,10 @@ _DEFUN(putw, (w, fp),
        int w _AND
        register FILE *fp)
 {
-  if (fwrite ((_CONST char*)&w, sizeof (w), 1, fp) != 1)
+  if (fwrite ((_CONST char*)&w, sizeof (w), 1, fp) != 1) {
+    __A_VARIABLE = 1;
     return EOF;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/stdio/putwc.c b/newlib/libc/stdio/putwc.c
index 9a84f35..c54341c 100644
--- a/newlib/libc/stdio/putwc.c
+++ b/newlib/libc/stdio/putwc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002 Tim J. Robbins.
  * All rights reserved.
@@ -38,6 +39,7 @@ _DEFUN(_putwc_r, (ptr, wc, fp),
 	wchar_t wc _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _fputwc_r (ptr, wc, fp);
 }
 /*
@@ -49,5 +51,6 @@ _DEFUN(putwc, (wc, fp),
 	wchar_t wc _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return fputwc (wc, fp);
 }
diff --git a/newlib/libc/stdio/putwc_u.c b/newlib/libc/stdio/putwc_u.c
index bb71acc..6578acf 100644
--- a/newlib/libc/stdio/putwc_u.c
+++ b/newlib/libc/stdio/putwc_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -39,6 +40,7 @@ _DEFUN(_putwc_unlocked_r, (ptr, wc, fp),
 	wchar_t wc _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _fputwc_unlocked_r (ptr, wc, fp);
 }
 /*
@@ -50,5 +52,6 @@ _DEFUN(putwc_unlocked, (wc, fp),
 	wchar_t wc _AND
 	FILE *fp)
 {
+  __A_VARIABLE = 1;
   return fputwc_unlocked (wc, fp);
 }
diff --git a/newlib/libc/stdio/putwchar.c b/newlib/libc/stdio/putwchar.c
index cdd2542..7d82d6a 100644
--- a/newlib/libc/stdio/putwchar.c
+++ b/newlib/libc/stdio/putwchar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002 Tim J. Robbins.
  * All rights reserved.
@@ -110,6 +111,7 @@ _DEFUN(_putwchar_r, (ptr, wc),
 	struct _reent *ptr _AND
 	wchar_t wc)
 {
+  __A_VARIABLE = 1;
   return _fputwc_r (ptr, wc, stdout);
 }
 
@@ -121,5 +123,6 @@ _DEFUN(putwchar, (wc),
 	wchar_t wc)
 {
   _REENT_SMALL_CHECK_INIT (_REENT);
+  __A_VARIABLE = 1;
   return fputwc (wc, stdout);
 }
diff --git a/newlib/libc/stdio/putwchar_u.c b/newlib/libc/stdio/putwchar_u.c
index 3235472..5f94322 100644
--- a/newlib/libc/stdio/putwchar_u.c
+++ b/newlib/libc/stdio/putwchar_u.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014 Red Hat, Inc.
  * All rights reserved.
@@ -38,6 +39,7 @@ _DEFUN(_putwchar_unlocked_r, (ptr, wc),
 	struct _reent *ptr _AND
 	wchar_t wc)
 {
+  __A_VARIABLE = 1;
   return _fputwc_unlocked_r (ptr, wc, stdout);
 }
 
@@ -49,5 +51,6 @@ _DEFUN(putwchar_unlocked, (wc),
 	wchar_t wc)
 {
   _REENT_SMALL_CHECK_INIT (_REENT);
+  __A_VARIABLE = 1;
   return fputwc_unlocked (wc, stdout);
 }
diff --git a/newlib/libc/stdio/refill.c b/newlib/libc/stdio/refill.c
index 9d853f9..7c3294c 100644
--- a/newlib/libc/stdio/refill.c
+++ b/newlib/libc/stdio/refill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -26,8 +27,11 @@ static int
 _DEFUN(lflush, (fp),
        FILE *fp)
 {
-  if ((fp->_flags & (__SLBF | __SWR)) == (__SLBF | __SWR))
+  if ((fp->_flags & (__SLBF | __SWR)) == (__SLBF | __SWR)) {
+    __A_VARIABLE = 1;
     return fflush (fp);
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/stdio/remove.c b/newlib/libc/stdio/remove.c
index 5a3e16b..5fe5ece 100644
--- a/newlib/libc/stdio/remove.c
+++ b/newlib/libc/stdio/remove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -72,9 +73,12 @@ _DEFUN(_remove_r, (ptr, filename),
        struct _reent *ptr _AND
        _CONST char *filename)
 {
-  if (_unlink_r (ptr, filename) == -1)
+  if (_unlink_r (ptr, filename) == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -84,6 +88,7 @@ int
 _DEFUN(remove, (filename),
        _CONST char *filename)
 {
+  __A_VARIABLE = 1;
   return _remove_r (_REENT, filename);
 }
 
diff --git a/newlib/libc/stdio/rename.c b/newlib/libc/stdio/rename.c
index 6eb1f7d..a1648db 100644
--- a/newlib/libc/stdio/rename.c
+++ b/newlib/libc/stdio/rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -64,6 +65,7 @@ _DEFUN(rename, (old, new),
        _CONST char *old _AND
        _CONST char *new)
 {
+  __A_VARIABLE = 1;
   return _rename_r (_REENT, old, new);
 }
 
diff --git a/newlib/libc/stdio/rewind.c b/newlib/libc/stdio/rewind.c
index fb03e5b..30ddbee 100644
--- a/newlib/libc/stdio/rewind.c
+++ b/newlib/libc/stdio/rewind.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -67,6 +68,7 @@ _DEFUN(_rewind_r, (ptr, fp),
 {
   _CAST_VOID _fseek_r (ptr, fp, 0L, SEEK_SET);
   clearerr (fp);
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -76,6 +78,7 @@ _DEFUN(rewind, (fp),
        register FILE * fp)
 {
   _rewind_r (_REENT, fp);
+  __A_VARIABLE = 1;
 }
 
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/rget.c b/newlib/libc/stdio/rget.c
index 9474bd9..aa8d071 100644
--- a/newlib/libc/stdio/rget.c
+++ b/newlib/libc/stdio/rget.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -43,8 +44,10 @@ _DEFUN(__srget_r, (ptr, fp),
   if (__srefill_r (ptr, fp) == 0)
     {
       fp->_r--;
+      __A_VARIABLE = 1;
       return *fp->_p++;
     }
+  __A_VARIABLE = 1;
   return EOF;
 }
 
@@ -55,5 +58,6 @@ int
 _DEFUN(__srget, (fp),
        register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return __srget_r (_REENT, fp);
 }
diff --git a/newlib/libc/stdio/scanf.c b/newlib/libc/stdio/scanf.c
index 23e97b8..0cddd93 100644
--- a/newlib/libc/stdio/scanf.c
+++ b/newlib/libc/stdio/scanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -48,6 +49,7 @@ scanf(fmt, va_alist)
 #endif
   ret = _vfscanf_r (reent, _stdin_r (reent), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -80,6 +82,7 @@ _scanf_r(ptr, fmt, va_alist)
 #endif
   ret = _vfscanf_r (ptr, _stdin_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/sccl.c b/newlib/libc/stdio/sccl.c
index b018011..5200f77 100644
--- a/newlib/libc/stdio/sccl.c
+++ b/newlib/libc/stdio/sccl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/stdio/setbuf.c b/newlib/libc/stdio/setbuf.c
index cffb6fb..0e7b608 100644
--- a/newlib/libc/stdio/setbuf.c
+++ b/newlib/libc/stdio/setbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -76,4 +77,5 @@ _DEFUN(setbuf, (fp, buf),
        char *__restrict buf)
 {
   _CAST_VOID setvbuf (fp, buf, buf ? _IOFBF : _IONBF, BUFSIZ);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdio/setbuffer.c b/newlib/libc/stdio/setbuffer.c
index e881874..fa1feb0 100644
--- a/newlib/libc/stdio/setbuffer.c
+++ b/newlib/libc/stdio/setbuffer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -78,4 +79,5 @@ _DEFUN(setbuffer, (fp, buf, size),
        int size)
 {
   _CAST_VOID setvbuf (fp, buf, buf ? _IOFBF : _IONBF, (size_t) size);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdio/setlinebuf.c b/newlib/libc/stdio/setlinebuf.c
index 0df6a57..2c5c61b 100644
--- a/newlib/libc/stdio/setlinebuf.c
+++ b/newlib/libc/stdio/setlinebuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -64,5 +65,6 @@ int
 _DEFUN(setlinebuf, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (setvbuf (fp, (char *) NULL, _IOLBF, (size_t) 0));
 }
diff --git a/newlib/libc/stdio/setvbuf.c b/newlib/libc/stdio/setvbuf.c
index a8e46a5..4a2ff8b 100644
--- a/newlib/libc/stdio/setvbuf.c
+++ b/newlib/libc/stdio/setvbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -115,8 +116,10 @@ _DEFUN(setvbuf, (fp, buf, mode, size),
    * when setting _IONBF.
    */
   if (mode != _IONBF)
-    if ((mode != _IOFBF && mode != _IOLBF) || (int)(_POINTER_INT) size < 0)
+    if ((mode != _IOFBF && mode != _IOLBF) || (int)(_POINTER_INT) size < 0) {
+      __A_VARIABLE = 1;
       return (EOF);
+    }
 
 
   /*
@@ -174,6 +177,7 @@ nbf:
           fp->_bf._base = fp->_p = fp->_nbuf;
           fp->_bf._size = 1;
           _newlib_flockfile_exit (fp);
+          __A_VARIABLE = 1;
           return (ret);
         }
       fp->_flags |= __SMBF;
@@ -227,5 +231,6 @@ nbf:
     }
 
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/stdio/siprintf.c b/newlib/libc/stdio/siprintf.c
index f0a8098..cf98dc2 100644
--- a/newlib/libc/stdio/siprintf.c
+++ b/newlib/libc/stdio/siprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -132,6 +133,7 @@ _siprintf_r(ptr, str, fmt, va_alist)
   ret = _svfiprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
   *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -165,6 +167,7 @@ siprintf(str, fmt, va_alist)
   ret = _svfiprintf_r (_REENT, &f, fmt, ap);
   va_end (ap);
   *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/siscanf.c b/newlib/libc/stdio/siscanf.c
index a6a8126..0a78fc7 100644
--- a/newlib/libc/stdio/siscanf.c
+++ b/newlib/libc/stdio/siscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -146,6 +147,7 @@ siscanf(str, fmt, va_alist)
 #endif
   ret = __ssvfiscanf_r (_REENT, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -184,5 +186,6 @@ _siscanf_r(ptr, str, fmt, va_alist)
 #endif
   ret = __ssvfiscanf_r (ptr, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/sniprintf.c b/newlib/libc/stdio/sniprintf.c
index 98a2c25..59a339d 100644
--- a/newlib/libc/stdio/sniprintf.c
+++ b/newlib/libc/stdio/sniprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -53,6 +54,7 @@ _sniprintf_r (ptr, str, size, fmt, va_alist)
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -70,6 +72,7 @@ _sniprintf_r (ptr, str, size, fmt, va_alist)
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -97,6 +100,7 @@ sniprintf (str, size, fmt, va_alist)
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -114,6 +118,7 @@ sniprintf (str, size, fmt, va_alist)
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/snprintf.c b/newlib/libc/stdio/snprintf.c
index d2408b2..3f6270f 100644
--- a/newlib/libc/stdio/snprintf.c
+++ b/newlib/libc/stdio/snprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -52,6 +53,7 @@ _snprintf_r(ptr, str, size, fmt, va_alist)
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -69,6 +71,7 @@ _snprintf_r(ptr, str, size, fmt, va_alist)
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -102,6 +105,7 @@ snprintf(str, size, fmt, va_alist)
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -119,6 +123,7 @@ snprintf(str, size, fmt, va_alist)
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/sprintf.c b/newlib/libc/stdio/sprintf.c
index d74c6f8..4bd8834 100644
--- a/newlib/libc/stdio/sprintf.c
+++ b/newlib/libc/stdio/sprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -608,6 +609,7 @@ _sprintf_r(ptr, str, fmt, va_alist)
   ret = _svfprintf_r (ptr, &f, fmt, ap);
   va_end (ap);
   *f._p = '\0';	/* terminate the string */
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -647,6 +649,7 @@ sprintf(str, fmt, va_alist)
   ret = _svfprintf_r (_REENT, &f, fmt, ap);
   va_end (ap);
   *f._p = '\0';	/* terminate the string */
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/sscanf.c b/newlib/libc/stdio/sscanf.c
index 7961294..de5cadf 100644
--- a/newlib/libc/stdio/sscanf.c
+++ b/newlib/libc/stdio/sscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -485,6 +486,7 @@ sscanf(str, fmt, va_alist)
 #endif
   ret = __ssvfscanf_r (_REENT, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -529,6 +531,7 @@ _sscanf_r(ptr, str, fmt, va_alist)
 #endif
   ret = __ssvfscanf_r (ptr, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/stdio.c b/newlib/libc/stdio/stdio.c
index a6e28f5..54fc78d 100644
--- a/newlib/libc/stdio/stdio.c
+++ b/newlib/libc/stdio/stdio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -58,6 +59,7 @@ _DEFUN(__sread, (ptr, cookie, buf, n),
     fp->_offset += ret;
   else
     fp->_flags &= ~__SOFF;	/* paranoia */
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -69,6 +71,7 @@ _DEFUN(__seofread, (ptr, cookie, buf, len),
        char *buf   _AND
        _READ_WRITE_BUFSIZE_TYPE len)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -101,6 +104,7 @@ _DEFUN(__swrite, (ptr, cookie, buf, n),
     setmode (fp->_file, oldmode);
 #endif
 
+  __A_VARIABLE = 1;
   return w;
 }
 
@@ -122,6 +126,7 @@ _DEFUN(__sseek, (ptr, cookie, offset, whence),
       fp->_flags |= __SOFF;
       fp->_offset = ret;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -132,6 +137,7 @@ _DEFUN(__sclose, (ptr, cookie),
 {
   FILE *fp = (FILE *) cookie;
 
+  __A_VARIABLE = 1;
   return _close_r (ptr, fp->_file);
 }
 
diff --git a/newlib/libc/stdio/stdio_ext.c b/newlib/libc/stdio/stdio_ext.c
index 588209d..59476c8 100644
--- a/newlib/libc/stdio/stdio_ext.c
+++ b/newlib/libc/stdio/stdio_ext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<stdio_ext>>,<<__fbufsize>>,<<__fpending>>,<<__flbf>>,<<__freadable>>,<<__fwritable>>,<<__freading>>,<<__fwriting>>---access internals of FILE structure
@@ -65,6 +66,7 @@ size_t
 _DEFUN(__fbufsize, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (size_t) fp->_bf._size;
 }
 
@@ -72,6 +74,7 @@ size_t
 _DEFUN(__fpending, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return fp->_p - fp->_bf._base;
 }
 
@@ -79,6 +82,7 @@ int
 _DEFUN(__flbf, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & __SLBF) != 0;
 }
 
@@ -86,6 +90,7 @@ int
 _DEFUN(__freadable, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & (__SRD | __SRW)) != 0;
 }
 
@@ -93,6 +98,7 @@ int
 _DEFUN(__fwritable, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & (__SWR | __SRW)) != 0;
 }
 
@@ -100,6 +106,7 @@ int
 _DEFUN(__freading, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & __SRD) != 0;
 }
 
@@ -107,6 +114,7 @@ int
 _DEFUN(__fwriting, (fp),
        FILE * fp)
 {
+  __A_VARIABLE = 1;
   return (fp->_flags & __SWR) != 0;
 }
 
diff --git a/newlib/libc/stdio/swprintf.c b/newlib/libc/stdio/swprintf.c
index 2233b3b..f3cde7c 100644
--- a/newlib/libc/stdio/swprintf.c
+++ b/newlib/libc/stdio/swprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -566,6 +567,7 @@ _DEFUN(_swprintf_r, (ptr, str, size, fmt),
   if (size > INT_MAX / sizeof (wchar_t))
     {
       ptr->_errno = EOVERFLOW;	/* POSIX extension */
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -588,6 +590,7 @@ _DEFUN(_swprintf_r, (ptr, str, size, fmt),
     ptr->_errno = EOVERFLOW;	/* POSIX extension */
     ret = -1;
   }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
@@ -607,6 +610,7 @@ _DEFUN(swprintf, (str, size, fmt),
   if (size > INT_MAX / sizeof (wchar_t))
     {
       ptr->_errno = EOVERFLOW;	/* POSIX extension */
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -629,6 +633,7 @@ _DEFUN(swprintf, (str, size, fmt),
     ptr->_errno = EOVERFLOW;	/* POSIX extension */
     ret = -1;
   }
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/swscanf.c b/newlib/libc/stdio/swscanf.c
index 6a469ac..473c2c2 100644
--- a/newlib/libc/stdio/swscanf.c
+++ b/newlib/libc/stdio/swscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -461,6 +462,7 @@ swscanf (_CONST wchar_t *__restrict str, _CONST wchar_t *__restrict fmt, ...)
   va_start (ap, fmt);
   ret = __ssvfwscanf_r (_REENT, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -483,5 +485,6 @@ _swscanf_r (struct _reent *ptr, _CONST wchar_t *str, _CONST wchar_t *fmt, ...)
   va_start (ap, fmt);
   ret = __ssvfwscanf_r (ptr, &f, fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/tmpfile.c b/newlib/libc/stdio/tmpfile.c
index eca4ec7..a899874 100644
--- a/newlib/libc/stdio/tmpfile.c
+++ b/newlib/libc/stdio/tmpfile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<tmpfile>>---create a temporary file
@@ -68,20 +69,25 @@ _DEFUN(_tmpfile_r, (ptr),
 
   do
     {
-      if ((f = _tmpnam_r (ptr, buf)) == NULL)
+      if ((f = _tmpnam_r (ptr, buf)) == NULL) {
+	__A_VARIABLE = 1;
 	return NULL;
+      }
       fd = _open_r (ptr, f, O_RDWR | O_CREAT | O_EXCL | O_BINARY,
 		    S_IRUSR | S_IWUSR);
     }
   while (fd < 0 && ptr->_errno == EEXIST);
-  if (fd < 0)
+  if (fd < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   fp = _fdopen_r (ptr, fd, "wb+");
   e = ptr->_errno;
   if (!fp)
     _close_r (ptr, fd);
   _CAST_VOID _remove_r (ptr, f);
   ptr->_errno = e;
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -90,6 +96,7 @@ _DEFUN(_tmpfile_r, (ptr),
 FILE *
 _DEFUN_VOID(tmpfile)
 {
+  __A_VARIABLE = 1;
   return _tmpfile_r (_REENT);
 }
 
diff --git a/newlib/libc/stdio/tmpnam.c b/newlib/libc/stdio/tmpnam.c
index ee722e6..eed705c 100644
--- a/newlib/libc/stdio/tmpnam.c
+++ b/newlib/libc/stdio/tmpnam.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * tmpname.c
  * Original Author:	G. Haley
@@ -126,12 +127,14 @@ _DEFUN(worker, (ptr, result, part1, part2, part3, part4),
 	  if (ptr->_errno == ENOSYS)
 	    {
 	      result[0] = '\0';
+	      __A_VARIABLE = 1;
 	      return 0;
 	    }
 	  break;
 	}
       _close_r (ptr, t);
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -158,9 +161,11 @@ _DEFUN(_tmpnam_r, (p, s),
   if (worker (p, result, P_tmpdir, "t", pid, &p->_inc))
     {
       p->_inc++;
+      __A_VARIABLE = 1;
       return result;
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -183,9 +188,12 @@ _DEFUN(_tempnam_r, (p, dir, pfx),
   if (filename)
     {
       if (! worker (p, filename, dir, prefix,
-		    _getpid_r (p) ^ (int) (_POINTER_INT) p, &p->_inc))
+		    _getpid_r (p) ^ (int) (_POINTER_INT) p, &p->_inc)) {
+	__A_VARIABLE = 1;
 	return NULL;
+      }
     }
+  __A_VARIABLE = 1;
   return filename;
 }
 
@@ -196,6 +204,7 @@ _DEFUN(tempnam, (dir, pfx),
        _CONST char *dir _AND
        _CONST char *pfx)
 {
+  __A_VARIABLE = 1;
   return _tempnam_r (_REENT, dir, pfx);
 }
 
@@ -203,6 +212,7 @@ char *
 _DEFUN(tmpnam, (s),
        char *s)
 {
+  __A_VARIABLE = 1;
   return _tmpnam_r (_REENT, s);
 }
 
diff --git a/newlib/libc/stdio/ungetc.c b/newlib/libc/stdio/ungetc.c
index e385ce8..18e830b 100644
--- a/newlib/libc/stdio/ungetc.c
+++ b/newlib/libc/stdio/ungetc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -89,24 +90,30 @@ _DEFUN(__submore, (rptr, fp),
       /*
        * Get a new buffer (rather than expanding the old one).
        */
-      if ((p = (unsigned char *) _malloc_r (rptr, (size_t) BUFSIZ)) == NULL)
+      if ((p = (unsigned char *) _malloc_r (rptr, (size_t) BUFSIZ)) == NULL) {
+	__A_VARIABLE = 1;
 	return EOF;
+      }
       fp->_ub._base = p;
       fp->_ub._size = BUFSIZ;
       p += BUFSIZ - sizeof (fp->_ubuf);
       for (i = sizeof (fp->_ubuf); --i >= 0;)
 	p[i] = fp->_ubuf[i];
       fp->_p = p;
+      __A_VARIABLE = 1;
       return 0;
     }
   i = fp->_ub._size;
   p = (unsigned char *) _realloc_r (rptr, (_PTR) (fp->_ub._base), i << 1);
-  if (p == NULL)
+  if (p == NULL) {
+    __A_VARIABLE = 1;
     return EOF;
+  }
   _CAST_VOID memcpy ((_PTR) (p + i), (_PTR) p, (size_t) i);
   fp->_p = p + i;
   fp->_ub._base = p;
   fp->_ub._size = i << 1;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -116,8 +123,10 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
        int c               _AND
        register FILE *fp)
 {
-  if (c == EOF)
+  if (c == EOF) {
+    __A_VARIABLE = 1;
     return (EOF);
+  }
 
   /* Ensure stdio has been initialized.
      ??? Might be able to remove this as some other stdio routine should
@@ -141,6 +150,7 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
       if ((fp->_flags & __SRW) == 0)
         {
           _newlib_flockfile_exit (fp);
+          __A_VARIABLE = 1;
           return EOF;
         }
       if (fp->_flags & __SWR)
@@ -148,6 +158,7 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
 	  if (_fflush_r (rptr, fp))
             {
               _newlib_flockfile_exit (fp);
+              __A_VARIABLE = 1;
               return EOF;
             }
 	  fp->_flags &= ~__SWR;
@@ -168,11 +179,13 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
       if (fp->_r >= fp->_ub._size && __submore (rptr, fp))
         {
           _newlib_flockfile_exit (fp);
+          __A_VARIABLE = 1;
           return EOF;
         }
       *--fp->_p = c;
       fp->_r++;
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -187,6 +200,7 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
       fp->_p--;
       fp->_r++;
       _newlib_flockfile_exit (fp);
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -203,6 +217,7 @@ _DEFUN(_ungetc_r, (rptr, c, fp),
   fp->_p = &fp->_ubuf[sizeof (fp->_ubuf) - 1];
   fp->_r = 1;
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -212,6 +227,7 @@ _DEFUN(ungetc, (c, fp),
        int c               _AND
        register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _ungetc_r (_REENT, c, fp);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdio/ungetwc.c b/newlib/libc/stdio/ungetwc.c
index a69449e..c0ddbb4 100644
--- a/newlib/libc/stdio/ungetwc.c
+++ b/newlib/libc/stdio/ungetwc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2002-2004 Tim J. Robbins.
  * All rights reserved.
@@ -99,6 +100,7 @@ _DEFUN(_ungetwc_r, (ptr, wc, fp),
 	  break;
 	}
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return wc;
 }
 
@@ -113,5 +115,6 @@ _DEFUN(ungetwc, (wint_t wc, FILE *fp),
   struct _reent *reent = _REENT;
 
   CHECK_INIT (reent, fp);
+  __A_VARIABLE = 1;
   return _ungetwc_r (reent, wc, fp);
 }
diff --git a/newlib/libc/stdio/vasiprintf.c b/newlib/libc/stdio/vasiprintf.c
index f96de0d..87608d9 100644
--- a/newlib/libc/stdio/vasiprintf.c
+++ b/newlib/libc/stdio/vasiprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(vasiprintf, (strp, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vasiprintf_r (_REENT, strp, fmt, ap);
 }
 
@@ -61,5 +63,6 @@ _DEFUN(_vasiprintf_r, (ptr, strp, fmt, ap),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/vasniprintf.c b/newlib/libc/stdio/vasniprintf.c
index 56db45e..e027b3b 100644
--- a/newlib/libc/stdio/vasniprintf.c
+++ b/newlib/libc/stdio/vasniprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007, 2008 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -44,15 +45,19 @@ _DEFUN(_vasniprintf_r, (ptr, buf, lenp, fmt, ap),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
   f._file = -1;  /* No file. */
   ret = _svfiprintf_r (ptr, &f, fmt, ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
@@ -65,6 +70,7 @@ _DEFUN(vasniprintf, (buf, lenp, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vasniprintf_r (_REENT, buf, lenp, fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vasnprintf.c b/newlib/libc/stdio/vasnprintf.c
index 4cb43ce..f905636 100644
--- a/newlib/libc/stdio/vasnprintf.c
+++ b/newlib/libc/stdio/vasnprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2007 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -44,15 +45,19 @@ _DEFUN(_vasnprintf_r, (ptr, buf, lenp, fmt, ap),
   if (len > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return NULL;
     }
   f._bf._size = f._w = len;
   f._file = -1;  /* No file. */
   ret = _svfprintf_r (ptr, &f, fmt, ap);
-  if (ret < 0)
+  if (ret < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *lenp = ret;
   *f._p = '\0';
+  __A_VARIABLE = 1;
   return (char *) f._bf._base;
 }
 
@@ -72,6 +77,7 @@ _DEFUN(vasnprintf, (buf, lenp, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vasnprintf_r (_REENT, buf, lenp, fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vasprintf.c b/newlib/libc/stdio/vasprintf.c
index 5ba817d..fc4fb59 100644
--- a/newlib/libc/stdio/vasprintf.c
+++ b/newlib/libc/stdio/vasprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(vasprintf, (strp, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vasprintf_r (_REENT, strp, fmt, ap);
 }
 
@@ -67,6 +69,7 @@ _DEFUN(_vasprintf_r, (ptr, strp, fmt, ap),
       *f._p = 0;
       *strp = (char *) f._bf._base;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/vdiprintf.c b/newlib/libc/stdio/vdiprintf.c
index 51bdb00..31ff05a 100644
--- a/newlib/libc/stdio/vdiprintf.c
+++ b/newlib/libc/stdio/vdiprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2005, 2007 Shaun Jackman
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -25,11 +26,14 @@ _DEFUN(_vdiprintf_r, (ptr, fd, format, ap),
 
   _REENT_SMALL_CHECK_INIT (ptr);
   p = _vasniprintf_r (ptr, buf, &n, format, ap);
-  if (!p)
+  if (!p) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   n = _write_r (ptr, fd, p, n);
   if (p != buf)
     _free_r (ptr, p);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -41,6 +45,7 @@ _DEFUN(vdiprintf, (fd, format, ap),
        const char *format _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vdiprintf_r (_REENT, fd, format, ap);
 }
 
diff --git a/newlib/libc/stdio/vdprintf.c b/newlib/libc/stdio/vdprintf.c
index c295a39..e2c7503 100644
--- a/newlib/libc/stdio/vdprintf.c
+++ b/newlib/libc/stdio/vdprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2005, 2007 Shaun Jackman
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
@@ -25,11 +26,14 @@ _DEFUN(_vdprintf_r, (ptr, fd, format, ap),
 
   _REENT_SMALL_CHECK_INIT (ptr);
   p = _vasnprintf_r (ptr, buf, &n, format, ap);
-  if (!p)
+  if (!p) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   n = _write_r (ptr, fd, p, n);
   if (p != buf)
     _free_r (ptr, p);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -47,6 +51,7 @@ _DEFUN(vdprintf, (fd, format, ap),
        const char *__restrict format _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vdprintf_r (_REENT, fd, format, ap);
 }
 
diff --git a/newlib/libc/stdio/vfprintf.c b/newlib/libc/stdio/vfprintf.c
index 3585423..ebdb19e 100644
--- a/newlib/libc/stdio/vfprintf.c
+++ b/newlib/libc/stdio/vfprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -258,10 +259,12 @@ _DEFUN(__ssputs_r, (ptr, fp, buf, len),
 	fp->_w -= w;
 	fp->_p += w;
 
+	__A_VARIABLE = 1;
 	return 0;
 
 err:
 	fp->_flags |= __SERR;
+	__A_VARIABLE = 1;
 	return EOF;
 }
 #endif
@@ -282,6 +285,7 @@ _DEFUN(__ssprint_r, (ptr, fp, uio),
 
 	if (uio->uio_resid == 0) {
 		uio->uio_iovcnt = 0;
+		__A_VARIABLE = 1;
 		return (0);
 	}
 
@@ -349,12 +353,14 @@ _DEFUN(__ssprint_r, (ptr, fp, uio),
 
 	uio->uio_resid = 0;
 	uio->uio_iovcnt = 0;
+	__A_VARIABLE = 1;
 	return 0;
 
 err:
   fp->_flags |= __SERR;
   uio->uio_resid = 0;
   uio->uio_iovcnt = 0;
+  __A_VARIABLE = 1;
   return EOF;
 }
 #else /* !INTEGER_ONLY */
@@ -412,6 +418,7 @@ _DEFUN(__sprint_r, (ptr, fp, uio),
 
 	if (uio->uio_resid == 0) {
 		uio->uio_iovcnt = 0;
+		__A_VARIABLE = 1;
 		return (0);
 	}
 #ifdef _WIDE_ORIENT
@@ -438,6 +445,7 @@ _DEFUN(__sprint_r, (ptr, fp, uio),
 out:
 	uio->uio_resid = 0;
 	uio->uio_iovcnt = 0;
+	__A_VARIABLE = 1;
 	return (err);
 }
 #else /* !INTEGER_ONLY */
@@ -491,6 +499,7 @@ _DEFUN(__sbprintf, (rptr, fp, fmt, ap),
 #ifndef __SINGLE_THREAD__
 	__lock_close_recursive (fake._lock);
 #endif
+	__A_VARIABLE = 1;
 	return (ret);
 }
 #endif /* _UNBUF_STREAM_OPT */
@@ -655,6 +664,7 @@ _DEFUN(VFPRINTF, (fp, fmt0, ap),
 {
   int result;
   result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* STRING_ONLY */
@@ -864,6 +874,7 @@ _DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
 	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
 	if (cantwrite (data, fp)) {
 		_newlib_flockfile_exit (fp);
+		__A_VARIABLE = 1;
 		return (EOF);
 	}
 
@@ -872,6 +883,7 @@ _DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
 	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 	    fp->_file >= 0) {
 		_newlib_flockfile_exit (fp);
+		__A_VARIABLE = 1;
 		return (__sbprintf (data, fp, fmt0, ap));
 	}
 #endif
@@ -883,6 +895,7 @@ _DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
 		if (!fp->_p)
 		{
 			data->_errno = ENOMEM;
+			__A_VARIABLE = 1;
 			return EOF;
 		}
 		fp->_bf._size = 64;
@@ -1792,6 +1805,7 @@ error:
 #ifndef STRING_ONLY
 	_newlib_flockfile_end (fp);
 #endif
+	__A_VARIABLE = 1;
 	return (__sferror (fp) ? EOF : ret);
 	/* NOTREACHED */
 }
@@ -1931,6 +1945,7 @@ exponent(char *p0, int exp, int fmtch)
 			*p++ = '0';
 		*p++ = to_char (exp);
 	}
+	__A_VARIABLE = 1;
 	return (p - p0);
 }
 #endif /* FLOATING_POINT */
@@ -2353,6 +2368,7 @@ _DEFUN(get_arg, (data, n, fmt, ap, numargs_p, args, arg_type, last_fmt),
      string we processed here because the caller will continue processing where we started */
   *numargs_p = numargs;
   *last_fmt = fmt;
+  __A_VARIABLE = 1;
   return &args[n];
 }
 #endif /* !_NO_POS_ARGS */
diff --git a/newlib/libc/stdio/vfscanf.c b/newlib/libc/stdio/vfscanf.c
index 544d8db..d115774 100644
--- a/newlib/libc/stdio/vfscanf.c
+++ b/newlib/libc/stdio/vfscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -265,6 +266,7 @@ _DEFUN(VFSCANF, (fp, fmt, ap),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (reent, fp, fmt, ap);
 }
 
@@ -274,6 +276,7 @@ _DEFUN(__SVFSCANF, (fp, fmt0, ap),
        char _CONST *fmt0 _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (_REENT, fp, fmt0, ap);
 }
 
@@ -287,6 +290,7 @@ _DEFUN(_VFSCANF_R, (data, fp, fmt, ap),
        va_list ap)
 {
   CHECK_INIT(data, fp);
+  __A_VARIABLE = 1;
   return __SVFSCANF_R (data, fp, fmt, ap);
 }
 #endif /* !STRING_ONLY */
@@ -301,8 +305,10 @@ _DEFUN(_sungetc_r, (data, fp, ch),
 	int c               _AND
 	register FILE *fp)
 {
-  if (c == EOF)
+  if (c == EOF) {
+    __A_VARIABLE = 1;
     return (EOF);
+  }
 
   /* After ungetc, we won't be at eof anymore */
   fp->_flags &= ~__SEOF;
@@ -317,10 +323,12 @@ _DEFUN(_sungetc_r, (data, fp, ch),
     {
       if (fp->_r >= fp->_ub._size && __submore (data, fp))
         {
+          __A_VARIABLE = 1;
           return EOF;
         }
       *--fp->_p = c;
       fp->_r++;
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -334,6 +342,7 @@ _DEFUN(_sungetc_r, (data, fp, ch),
     {
       fp->_p--;
       fp->_r++;
+      __A_VARIABLE = 1;
       return c;
     }
 
@@ -349,6 +358,7 @@ _DEFUN(_sungetc_r, (data, fp, ch),
   fp->_ubuf[sizeof (fp->_ubuf) - 1] = c;
   fp->_p = &fp->_ubuf[sizeof (fp->_ubuf) - 1];
   fp->_r = 1;
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -368,6 +378,7 @@ _DEFUN(__ssrefill_r, (ptr, fp),
       if ((fp->_r = fp->_ur) != 0)
         {
           fp->_p = fp->_up;
+	  __A_VARIABLE = 1;
 	  return 0;
         }
     }
@@ -376,6 +387,7 @@ _DEFUN(__ssrefill_r, (ptr, fp),
   fp->_p = fp->_bf._base;
   fp->_r = 0;
   fp->_flags |= __SEOF;
+  __A_VARIABLE = 1;
   return EOF;
 }
 
@@ -392,8 +404,10 @@ _DEFUN(_sfread_r, (ptr, buf, size, count, fp),
   register int r;
   size_t total;
 
-  if ((resid = count * size) == 0)
+  if ((resid = count * size) == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   total = resid;
   p = buf;
@@ -408,12 +422,14 @@ _DEFUN(_sfread_r, (ptr, buf, size, count, fp),
       if (__ssrefill_r (ptr, fp))
         {
           /* no more input: return partial result */
+          __A_VARIABLE = 1;
           return (total - resid) / size;
         }
     }
   _CAST_VOID memcpy ((_PTR) p, (_PTR) fp->_p, resid);
   fp->_r -= resid;
   fp->_p += resid;
+  __A_VARIABLE = 1;
   return count;
 }
 #else /* !STRING_ONLY || !INTEGER_ONLY */
@@ -1655,6 +1671,7 @@ get_arg (int n, va_list *ap, int *numargs_p, void **args)
   while (n >= numargs)
     args[numargs++] = va_arg (*ap, void *);
   *numargs_p = numargs;
+  __A_VARIABLE = 1;
   return args[n];
 }
 #endif /* !_NO_POS_ARGS */
diff --git a/newlib/libc/stdio/vfwprintf.c b/newlib/libc/stdio/vfwprintf.c
index 4786ed6..1547b0b 100644
--- a/newlib/libc/stdio/vfwprintf.c
+++ b/newlib/libc/stdio/vfwprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -209,6 +210,7 @@ _DEFUN(__sbwprintf, (rptr, fp, fmt, ap),
 #ifndef __SINGLE_THREAD__
 	__lock_close_recursive (fake._lock);
 #endif
+	__A_VARIABLE = 1;
 	return (ret);
 }
 #endif /* _UNBUF_STREAM_OPT */
@@ -373,6 +375,7 @@ _DEFUN(VFWPRINTF, (fp, fmt0, ap),
 {
   int result;
   result = _VFWPRINTF_R (_REENT, fp, fmt0, ap);
+  __A_VARIABLE = 1;
   return result;
 }
 #endif /* STRING_ONLY */
@@ -599,6 +602,7 @@ _DEFUN(_VFWPRINTF_R, (data, fp, fmt0, ap),
 	/* sorry, fwprintf(read_only_file, "") returns EOF, not 0 */
 	if (cantwrite (data, fp)) {
 		_newlib_flockfile_exit (fp);
+		__A_VARIABLE = 1;
 		return (EOF);
 	}
 
@@ -607,6 +611,7 @@ _DEFUN(_VFWPRINTF_R, (data, fp, fmt0, ap),
 	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 	    fp->_file >= 0) {
 		_newlib_flockfile_exit (fp);
+		__A_VARIABLE = 1;
 		return (__sbwprintf (data, fp, fmt0, ap));
 	}
 #endif
@@ -618,6 +623,7 @@ _DEFUN(_VFWPRINTF_R, (data, fp, fmt0, ap),
 		if (!fp->_p)
 		{
 			data->_errno = ENOMEM;
+			__A_VARIABLE = 1;
 			return EOF;
 		}
 		fp->_bf._size = 64;
@@ -1536,6 +1542,7 @@ error:
 #ifndef STRING_ONLY
 	_newlib_flockfile_end (fp);
 #endif
+	__A_VARIABLE = 1;
 	return (__sferror (fp) ? EOF : ret);
 	/* NOTREACHED */
 }
@@ -1694,6 +1701,7 @@ wexponent(wchar_t *p0, int exp, int fmtch)
 			*p++ = L'0';
 		*p++ = to_char (exp);
 	}
+	__A_VARIABLE = 1;
 	return (p - p0);
 }
 #endif /* FLOATING_POINT */
@@ -2018,6 +2026,7 @@ _DEFUN(get_arg, (data, n, fmt, ap, numargs_p, args, arg_type, last_fmt),
      string we processed here because the caller will continue processing where we started */
   *numargs_p = numargs;
   *last_fmt = fmt;
+  __A_VARIABLE = 1;
   return &args[n];
 }
 #endif /* !_NO_POS_ARGS */
diff --git a/newlib/libc/stdio/vfwscanf.c b/newlib/libc/stdio/vfwscanf.c
index 5b35601..b47d842 100644
--- a/newlib/libc/stdio/vfwscanf.c
+++ b/newlib/libc/stdio/vfwscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -267,6 +268,7 @@ _DEFUN(VFWSCANF, (fp, fmt, ap),
   struct _reent *reent = _REENT;
 
   CHECK_INIT(reent, fp);
+  __A_VARIABLE = 1;
   return __SVFWSCANF_R (reent, fp, fmt, ap);
 }
 
@@ -276,6 +278,7 @@ _DEFUN(__SVFWSCANF, (fp, fmt0, ap),
        wchar_t _CONST *fmt0 _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return __SVFWSCANF_R (_REENT, fp, fmt0, ap);
 }
 
@@ -289,6 +292,7 @@ _DEFUN(_VFWSCANF_R, (data, fp, fmt, ap),
        va_list ap)
 {
   CHECK_INIT(data, fp);
+  __A_VARIABLE = 1;
   return __SVFWSCANF_R (data, fp, fmt, ap);
 }
 #endif /* !STRING_ONLY */
@@ -303,8 +307,10 @@ _DEFUN(_sungetwc_r, (data, fp, ch),
 	wint_t wc           _AND
 	register FILE *fp)
 {
-  if (wc == WEOF)
+  if (wc == WEOF) {
+    __A_VARIABLE = 1;
     return (WEOF);
+  }
 
   /* After ungetc, we won't be at eof anymore */
   fp->_flags &= ~__SEOF;
@@ -318,11 +324,13 @@ _DEFUN(_sungetwc_r, (data, fp, ch),
     {
       if (fp->_r >= fp->_ub._size && __submore (data, fp))
         {
+          __A_VARIABLE = 1;
           return EOF;
         }
       fp->_p -= sizeof (wchar_t);
       *fp->_p = (wchar_t) wc;
       fp->_r += sizeof (wchar_t);
+      __A_VARIABLE = 1;
       return wc;
     }
 
@@ -337,6 +345,7 @@ _DEFUN(_sungetwc_r, (data, fp, ch),
     {
       fp->_p -= sizeof (wchar_t);
       fp->_r += sizeof (wchar_t);
+      __A_VARIABLE = 1;
       return wc;
     }
 
@@ -352,6 +361,7 @@ _DEFUN(_sungetwc_r, (data, fp, ch),
   fp->_p = &fp->_ubuf[sizeof (fp->_ubuf) - sizeof (wchar_t)];
   *(wchar_t *) fp->_p = wc;
   fp->_r = 2;
+  __A_VARIABLE = 1;
   return wc;
 }
 
@@ -364,11 +374,14 @@ _DEFUN(_sfgetwc_r, (ptr, fp),
 {
   wchar_t wc;
 
-  if (fp->_r <= 0 && __ssrefill_r (ptr, fp))
+  if (fp->_r <= 0 && __ssrefill_r (ptr, fp)) {
+    __A_VARIABLE = 1;
     return (WEOF);
+  }
   wc = *(wchar_t *) fp->_p;
   fp->_p += sizeof (wchar_t);
   fp->_r -= sizeof (wchar_t);
+  __A_VARIABLE = 1;
   return (wc);
 }
 #endif /* STRING_ONLY */
@@ -1496,6 +1509,7 @@ get_arg (int n, va_list *ap, int *numargs_p, void **args)
   while (n >= numargs)
     args[numargs++] = va_arg (*ap, void *);
   *numargs_p = numargs;
+  __A_VARIABLE = 1;
   return args[n];
 }
 #endif /* !_NO_POS_ARGS */
diff --git a/newlib/libc/stdio/viprintf.c b/newlib/libc/stdio/viprintf.c
index fec92fa..b7b904b 100644
--- a/newlib/libc/stdio/viprintf.c
+++ b/newlib/libc/stdio/viprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -112,6 +113,7 @@ _DEFUN(viprintf, (fmt, ap),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _vfiprintf_r (reent, _stdout_r (reent), fmt, ap);
 }
 
@@ -124,5 +126,6 @@ _DEFUN(_viprintf_r, (ptr, fmt, ap),
        va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return _vfiprintf_r (ptr, _stdout_r (ptr), fmt, ap);
 }
diff --git a/newlib/libc/stdio/viscanf.c b/newlib/libc/stdio/viscanf.c
index 9a7d0c5..e2506c5 100644
--- a/newlib/libc/stdio/viscanf.c
+++ b/newlib/libc/stdio/viscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Code created by modifying iscanf.c which has following copyright.
  *
@@ -130,6 +131,7 @@ _DEFUN(viscanf, (fmt, ap),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return __svfiscanf_r (reent, _stdin_r (reent), fmt, ap);
 }
 
@@ -142,6 +144,7 @@ _DEFUN(_viscanf_r, (ptr, fmt, ap),
        va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return __svfiscanf_r (ptr, _stdin_r (ptr), fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vprintf.c b/newlib/libc/stdio/vprintf.c
index 00b8023..00236aa 100644
--- a/newlib/libc/stdio/vprintf.c
+++ b/newlib/libc/stdio/vprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(vprintf, (fmt, ap),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _vfprintf_r (reent, _stdout_r (reent), fmt, ap);
 }
 
@@ -53,6 +55,7 @@ _DEFUN(_vprintf_r, (ptr, fmt, ap),
        va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vscanf.c b/newlib/libc/stdio/vscanf.c
index 4371e23..d8d7682 100644
--- a/newlib/libc/stdio/vscanf.c
+++ b/newlib/libc/stdio/vscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Code created by modifying scanf.c which has following copyright.
  *
@@ -37,6 +38,7 @@ _DEFUN(vscanf, (fmt, ap),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return __svfscanf_r (reent, _stdin_r (reent), fmt, ap);
 }
 
@@ -54,6 +56,7 @@ _DEFUN(_vscanf_r, (ptr, fmt, ap),
        va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return __svfscanf_r (ptr, _stdin_r (ptr), fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vsiprintf.c b/newlib/libc/stdio/vsiprintf.c
index 150b4e7..9505730 100644
--- a/newlib/libc/stdio/vsiprintf.c
+++ b/newlib/libc/stdio/vsiprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(vsiprintf, (str, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsiprintf_r (_REENT, str, fmt, ap);
 }
 
@@ -57,5 +59,6 @@ _DEFUN(_vsiprintf_r, (ptr, str, fmt, ap),
   f._file = -1;  /* No file. */
   ret = _svfiprintf_r (ptr, &f, fmt, ap);
   *f._p = 0;
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/vsiscanf.c b/newlib/libc/stdio/vsiscanf.c
index 0129599..bbcfff4 100644
--- a/newlib/libc/stdio/vsiscanf.c
+++ b/newlib/libc/stdio/vsiscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Code created by modifying iscanf.c which has following copyright.
  *
@@ -40,6 +41,7 @@ _DEFUN(vsiscanf, (str, fmt, ap),
        _CONST char *fmt _AND 
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsiscanf_r (_REENT, str, fmt, ap);
 }
 
@@ -61,5 +63,6 @@ _DEFUN(_vsiscanf_r, (ptr, str, fmt, ap),
   f._ub._base = NULL;
   f._lb._base = NULL;
   f._file = -1;  /* No file. */
+  __A_VARIABLE = 1;
   return __ssvfiscanf_r (ptr, &f, fmt, ap);
 }
diff --git a/newlib/libc/stdio/vsniprintf.c b/newlib/libc/stdio/vsniprintf.c
index c4305c1..1fe2d57 100644
--- a/newlib/libc/stdio/vsniprintf.c
+++ b/newlib/libc/stdio/vsniprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990, 2007 The Regents of the University of California.
  * All rights reserved.
@@ -38,6 +39,7 @@ _DEFUN(vsniprintf, (str, size, fmt, ap),
        const char *fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsniprintf_r (_REENT, str, size, fmt, ap);
 }
 
@@ -57,6 +59,7 @@ _DEFUN(_vsniprintf_r, (ptr, str, size, fmt, ap),
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -68,5 +71,6 @@ _DEFUN(_vsniprintf_r, (ptr, str, size, fmt, ap),
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return ret;
 }
diff --git a/newlib/libc/stdio/vsnprintf.c b/newlib/libc/stdio/vsnprintf.c
index e08f267..e468700 100644
--- a/newlib/libc/stdio/vsnprintf.c
+++ b/newlib/libc/stdio/vsnprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -38,6 +39,7 @@ _DEFUN(vsnprintf, (str, size, fmt, ap),
        const char *__restrict fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsnprintf_r (_REENT, str, size, fmt, ap);
 }
 
@@ -63,6 +65,7 @@ _DEFUN(_vsnprintf_r, (ptr, str, size, fmt, ap),
   if (size > INT_MAX)
     {
       ptr->_errno = EOVERFLOW;
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -74,6 +77,7 @@ _DEFUN(_vsnprintf_r, (ptr, str, size, fmt, ap),
     ptr->_errno = EOVERFLOW;
   if (size > 0)
     *f._p = 0;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/vsprintf.c b/newlib/libc/stdio/vsprintf.c
index 742cde0..4cd0838 100644
--- a/newlib/libc/stdio/vsprintf.c
+++ b/newlib/libc/stdio/vsprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ _DEFUN(vsprintf, (str, fmt, ap),
        const char *__restrict fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsprintf_r (_REENT, str, fmt, ap);
 }
 
@@ -63,6 +65,7 @@ _DEFUN(_vsprintf_r, (ptr, str, fmt, ap),
   f._file = -1;  /* No file. */
   ret = _svfprintf_r (ptr, &f, fmt, ap);
   *f._p = 0;
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/vsscanf.c b/newlib/libc/stdio/vsscanf.c
index 1660fa1..844e114 100644
--- a/newlib/libc/stdio/vsscanf.c
+++ b/newlib/libc/stdio/vsscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Code created by modifying scanf.c which has following copyright.
  *
@@ -40,6 +41,7 @@ _DEFUN(vsscanf, (str, fmt, ap),
        _CONST char *__restrict fmt _AND 
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vsscanf_r (_REENT, str, fmt, ap);
 }
 
@@ -67,6 +69,7 @@ _DEFUN(_vsscanf_r, (ptr, str, fmt, ap),
   f._ub._base = NULL;
   f._lb._base = NULL;
   f._file = -1;  /* No file. */
+  __A_VARIABLE = 1;
   return __ssvfscanf_r (ptr, &f, fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vswprintf.c b/newlib/libc/stdio/vswprintf.c
index ac321b6..1b7d173 100644
--- a/newlib/libc/stdio/vswprintf.c
+++ b/newlib/libc/stdio/vswprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -44,6 +45,7 @@ _DEFUN(_vswprintf_r, (ptr, str, size, fmt, ap),
   if (size > INT_MAX / sizeof (wchar_t))
     {
       ptr->_errno = EOVERFLOW;	/* POSIX extension */
+      __A_VARIABLE = 1;
       return EOF;
     }
   f._flags = __SWR | __SSTR;
@@ -64,6 +66,7 @@ _DEFUN(_vswprintf_r, (ptr, str, size, fmt, ap),
     ptr->_errno = EOVERFLOW;	/* POSIX extension */
     ret = -1;
   }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -76,6 +79,7 @@ _DEFUN(vswprintf, (str, size, fmt, ap),
        const wchar_t *__restrict fmt _AND
        va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vswprintf_r (_REENT, str, size, fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/vswscanf.c b/newlib/libc/stdio/vswscanf.c
index 0d090f0..101d82b 100644
--- a/newlib/libc/stdio/vswscanf.c
+++ b/newlib/libc/stdio/vswscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Code created by modifying scanf.c which has following copyright.
  *
@@ -40,6 +41,7 @@ int
 vswscanf (_CONST wchar_t *__restrict str, _CONST wchar_t * __restrict fmt,
   va_list ap)
 {
+  __A_VARIABLE = 1;
   return _vswscanf_r (_REENT, str, fmt, ap);
 }
 
@@ -58,5 +60,6 @@ _vswscanf_r (struct _reent *ptr, _CONST wchar_t *str, _CONST wchar_t *fmt,
   f._ub._base = NULL;
   f._lb._base = NULL;
   f._file = -1;  /* No file. */
+  __A_VARIABLE = 1;
   return __ssvfwscanf_r (ptr, &f, fmt, ap);
 }
diff --git a/newlib/libc/stdio/vwprintf.c b/newlib/libc/stdio/vwprintf.c
index 51d1df3..42a6e56 100644
--- a/newlib/libc/stdio/vwprintf.c
+++ b/newlib/libc/stdio/vwprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -33,6 +34,7 @@ _DEFUN(vwprintf, (fmt, ap),
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return _vfwprintf_r (reent, _stdout_r (reent), fmt, ap);
 }
 
@@ -45,5 +47,6 @@ _DEFUN(_vwprintf_r, (ptr, fmt, ap),
        va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return _vfwprintf_r (ptr, _stdout_r (ptr), fmt, ap);
 }
diff --git a/newlib/libc/stdio/vwscanf.c b/newlib/libc/stdio/vwscanf.c
index e40bded..4e761c9 100644
--- a/newlib/libc/stdio/vwscanf.c
+++ b/newlib/libc/stdio/vwscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Code created by modifying scanf.c which has following copyright.
  *
@@ -37,6 +38,7 @@ vwscanf (_CONST wchar_t *__restrict fmt, va_list ap)
   struct _reent *reent = _REENT;
 
   _REENT_SMALL_CHECK_INIT (reent);
+  __A_VARIABLE = 1;
   return __svfwscanf_r (reent, _stdin_r (reent), fmt, ap);
 }
 
@@ -46,6 +48,7 @@ int
 _vwscanf_r (struct _reent *ptr, _CONST wchar_t *fmt, va_list ap)
 {
   _REENT_SMALL_CHECK_INIT (ptr);
+  __A_VARIABLE = 1;
   return __svfwscanf_r (ptr, _stdin_r (ptr), fmt, ap);
 }
 
diff --git a/newlib/libc/stdio/wbuf.c b/newlib/libc/stdio/wbuf.c
index f9197ea..1715ca0 100644
--- a/newlib/libc/stdio/wbuf.c
+++ b/newlib/libc/stdio/wbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -53,8 +54,10 @@ _DEFUN(__swbuf_r, (ptr, c, fp),
    */
 
   fp->_w = fp->_lbfsize;
-  if (cantwrite (ptr, fp))
+  if (cantwrite (ptr, fp)) {
+    __A_VARIABLE = 1;
     return EOF;
+  }
   c = (unsigned char) c;
 
   ORIENT (fp, -1);
@@ -72,15 +75,20 @@ _DEFUN(__swbuf_r, (ptr, c, fp),
   n = fp->_p - fp->_bf._base;
   if (n >= fp->_bf._size)
     {
-      if (_fflush_r (ptr, fp))
+      if (_fflush_r (ptr, fp)) {
+	__A_VARIABLE = 1;
 	return EOF;
+      }
       n = 0;
     }
   fp->_w--;
   *fp->_p++ = c;
   if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
-    if (_fflush_r (ptr, fp))
+    if (_fflush_r (ptr, fp)) {
+      __A_VARIABLE = 1;
       return EOF;
+    }
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -92,5 +100,6 @@ _DEFUN(__swbuf, (c, fp),
        register int c _AND
        register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return __swbuf_r (_REENT, c, fp);
 }
diff --git a/newlib/libc/stdio/wprintf.c b/newlib/libc/stdio/wprintf.c
index e05ba10..cf62dee 100644
--- a/newlib/libc/stdio/wprintf.c
+++ b/newlib/libc/stdio/wprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -35,6 +36,7 @@ _DEFUN(_wprintf_r, (ptr, fmt),
   va_start (ap, fmt);
   ret = _vfwprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -52,6 +54,7 @@ _DEFUN(wprintf, (fmt),
   va_start (ap, fmt);
   ret = _vfwprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/stdio/wscanf.c b/newlib/libc/stdio/wscanf.c
index f953d9f..3052cf3 100644
--- a/newlib/libc/stdio/wscanf.c
+++ b/newlib/libc/stdio/wscanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -36,6 +37,7 @@ wscanf(_CONST wchar_t *__restrict fmt, ...)
   va_start (ap, fmt);
   ret = _vfwscanf_r (reent, _stdin_r (reent), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -51,6 +53,7 @@ _wscanf_r(struct _reent *ptr, _CONST wchar_t *fmt, ...)
   va_start (ap, fmt);
   ret = _vfwscanf_r (ptr, _stdin_r (ptr), fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
   return (ret);
 }
 
diff --git a/newlib/libc/stdio/wsetup.c b/newlib/libc/stdio/wsetup.c
index 08ae70f..ecf6da7 100644
--- a/newlib/libc/stdio/wsetup.c
+++ b/newlib/libc/stdio/wsetup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* No user fns here. Pesch 15apr92. */
 
 /*
@@ -48,6 +49,7 @@ _DEFUN(__swsetup_r, (ptr, fp),
         {
 	  ptr->_errno = EBADF;
 	  fp->_flags |= __SERR;
+	  __A_VARIABLE = 1;
 	  return EOF;
         }
       if (fp->_flags & __SRD)
@@ -88,7 +90,9 @@ _DEFUN(__swsetup_r, (ptr, fp),
     {
       /* __smakebuf_r set errno, but not flag */
       fp->_flags |= __SERR;
+      __A_VARIABLE = 1;
       return EOF;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/stdio64/dummy.c b/newlib/libc/stdio64/dummy.c
index 90d0120..9f6eeb3 100644
--- a/newlib/libc/stdio64/dummy.c
+++ b/newlib/libc/stdio64/dummy.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* empty stub so there's at least one file to put in objectlist.awk.in */
diff --git a/newlib/libc/stdio64/fdopen64.c b/newlib/libc/stdio64/fdopen64.c
index f386583..871fc2b 100644
--- a/newlib/libc/stdio64/fdopen64.c
+++ b/newlib/libc/stdio64/fdopen64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<fdopen64>>---turn open large file into a stream
@@ -46,23 +47,30 @@ _DEFUN (_fdopen64_r, (ptr, fd, mode),
   int fdflags, fdmode;
 #endif
 
-  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
+  if ((flags = __sflags (ptr, mode, &oflags)) == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* make sure the mode the user wants is a subset of the actual mode */
 #ifdef HAVE_FCNTL
-  if ((fdflags = _fcntl_r (ptr, fd, F_GETFL, 0)) < 0)
+  if ((fdflags = _fcntl_r (ptr, fd, F_GETFL, 0)) < 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   fdmode = fdflags & O_ACCMODE;
   if (fdmode != O_RDWR && (fdmode != (oflags & O_ACCMODE)))
     {
       ptr->_errno = EBADF;
+      __A_VARIABLE = 1;
       return 0;
     }
 #endif
 
-  if ((fp = __sfp (ptr)) == 0)
+  if ((fp = __sfp (ptr)) == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   _newlib_flockfile_start(fp);
 
@@ -102,6 +110,7 @@ _DEFUN (_fdopen64_r, (ptr, fd, mode),
   fp->_flags |= __SL64;
 
   _newlib_flockfile_end(fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -112,6 +121,7 @@ _DEFUN (fdopen64, (fd, mode),
 	int fd _AND
 	_CONST char *mode)
 {
+  __A_VARIABLE = 1;
   return _fdopen64_r (_REENT, fd, mode);
 }
 
diff --git a/newlib/libc/stdio64/fgetpos64.c b/newlib/libc/stdio64/fgetpos64.c
index 36f7ec9..278b29c 100644
--- a/newlib/libc/stdio64/fgetpos64.c
+++ b/newlib/libc/stdio64/fgetpos64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<fgetpos64>>---record position in a large stream or file
@@ -64,8 +65,10 @@ _DEFUN (_fgetpos64_r, (ptr, fp, pos),
 
   if (*pos != -1)
     {
+      __A_VARIABLE = 1;
       return 0;
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -76,6 +79,7 @@ _DEFUN (fgetpos64, (fp, pos),
 	FILE * fp _AND
 	_fpos64_t * pos)
 {
+  __A_VARIABLE = 1;
   return _fgetpos64_r (_REENT, fp, pos);
 }
 
diff --git a/newlib/libc/stdio64/fopen64.c b/newlib/libc/stdio64/fopen64.c
index 84f7b6e..151d906 100644
--- a/newlib/libc/stdio64/fopen64.c
+++ b/newlib/libc/stdio64/fopen64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -84,10 +85,14 @@ _DEFUN (_fopen64_r, (ptr, file, mode),
   register int f;
   int flags, oflags;
 
-  if ((flags = __sflags (ptr, mode, &oflags)) == 0)
+  if ((flags = __sflags (ptr, mode, &oflags)) == 0) {
+    __A_VARIABLE = 1;
     return NULL;
-  if ((fp = __sfp (ptr)) == NULL)
+  }
+  if ((fp = __sfp (ptr)) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   if ((f = _open64_r (ptr, file, oflags, 0666)) < 0)
     {
@@ -97,6 +102,7 @@ _DEFUN (_fopen64_r, (ptr, file, mode),
       __lock_close_recursive (fp->_lock);
 #endif
       _newlib_sfp_lock_end ();
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -122,6 +128,7 @@ _DEFUN (_fopen64_r, (ptr, file, mode),
   fp->_flags |= __SL64;
 
   _newlib_flockfile_end (fp);
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -132,6 +139,7 @@ _DEFUN (fopen64, (file, mode),
 	_CONST char *file _AND
 	_CONST char *mode)
 {
+  __A_VARIABLE = 1;
   return _fopen64_r (_REENT, file, mode);
 }
 
diff --git a/newlib/libc/stdio64/freopen64.c b/newlib/libc/stdio64/freopen64.c
index f7df354..ce63367 100644
--- a/newlib/libc/stdio64/freopen64.c
+++ b/newlib/libc/stdio64/freopen64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -119,6 +120,7 @@ _DEFUN (_freopen64_r, (ptr, file, mode, fp),
       pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
       _fclose_r (ptr, fp);
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -230,6 +232,7 @@ _DEFUN (_freopen64_r, (ptr, file, mode, fp),
 #if !defined (__SINGLE_THREAD__) && defined (_POSIX_THREADS)
       pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -254,6 +257,7 @@ _DEFUN (_freopen64_r, (ptr, file, mode, fp),
 #if !defined (__SINGLE_THREAD__) && defined (_POSIX_THREADS)
   pthread_setcancelstate (__oldcancel, &__oldcancel);
 #endif
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -265,6 +269,7 @@ _DEFUN (freopen64, (file, mode, fp),
 	_CONST char *mode _AND
 	register FILE *fp)
 {
+  __A_VARIABLE = 1;
   return _freopen64_r (_REENT, file, mode, fp);
 }
 
diff --git a/newlib/libc/stdio64/fseeko64.c b/newlib/libc/stdio64/fseeko64.c
index 34eee67..48bc8bf 100644
--- a/newlib/libc/stdio64/fseeko64.c
+++ b/newlib/libc/stdio64/fseeko64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -360,6 +361,7 @@ _DEFUN (fseeko64, (fp, offset, whence),
      _off64_t offset _AND
      int whence)
 {
+  __A_VARIABLE = 1;
   return _fseeko64_r (_REENT, fp, offset, whence);
 }
 
diff --git a/newlib/libc/stdio64/fsetpos64.c b/newlib/libc/stdio64/fsetpos64.c
index 046990d..d456d21 100644
--- a/newlib/libc/stdio64/fsetpos64.c
+++ b/newlib/libc/stdio64/fsetpos64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<fsetpos64>>---restore position of a large stream or file
@@ -59,8 +60,11 @@ _DEFUN (_fsetpos64_r, (ptr, iop, pos),
 {
   int x = _fseeko64_r (ptr, iop, (_off64_t)(*pos), SEEK_SET);
 
-  if (x != 0)
+  if (x != 0) {
+    __A_VARIABLE = 1;
     return 1;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -71,6 +75,7 @@ _DEFUN (fsetpos64, (iop, pos),
 	FILE * iop _AND
 	_CONST _fpos64_t * pos)
 {
+  __A_VARIABLE = 1;
   return _fsetpos64_r (_REENT, iop, pos);
 }
 
diff --git a/newlib/libc/stdio64/ftello64.c b/newlib/libc/stdio64/ftello64.c
index c4d6da2..1b2980a 100644
--- a/newlib/libc/stdio64/ftello64.c
+++ b/newlib/libc/stdio64/ftello64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -156,6 +157,7 @@ _off64_t
 _DEFUN (ftello64, (fp),
 	register FILE * fp)
 {
+  __A_VARIABLE = 1;
   return _ftello64_r (_REENT, fp);
 }
 
diff --git a/newlib/libc/stdio64/stdio64.c b/newlib/libc/stdio64/stdio64.c
index dd3b4ad..13e6ba1 100644
--- a/newlib/libc/stdio64/stdio64.c
+++ b/newlib/libc/stdio64/stdio64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* No user fns here.  Pesch 15apr92. */
 
 /*
@@ -43,6 +44,7 @@ _DEFUN(__sseek64, (ptr, cookie, offset, whence),
       fp->_flags |= __SOFF;
       fp->_offset = ret;
     }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -75,6 +77,7 @@ _DEFUN(__swrite64, (ptr, cookie, buf, n),
     setmode(fp->_file, oldmode);
 #endif
 
+  __A_VARIABLE = 1;
   return w;
 }
 
diff --git a/newlib/libc/stdio64/tmpfile64.c b/newlib/libc/stdio64/tmpfile64.c
index 98a7d78..bbc14ed 100644
--- a/newlib/libc/stdio64/tmpfile64.c
+++ b/newlib/libc/stdio64/tmpfile64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<tmpfile64>>---create a large temporary file
@@ -71,20 +72,25 @@ _DEFUN (_tmpfile64_r, (ptr),
 
   do
   {
-     if ((f = _tmpnam_r (ptr, buf)) == NULL)
+     if ((f = _tmpnam_r (ptr, buf)) == NULL) {
+	__A_VARIABLE = 1;
 	return NULL;
+      }
       fd = _open64_r (ptr, f, O_RDWR | O_CREAT | O_EXCL | O_BINARY,
 		      S_IRUSR | S_IWUSR);
   }
   while (fd < 0 && ptr->_errno == EEXIST);
-  if (fd < 0)
+  if (fd < 0) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   fp = _fdopen64_r (ptr, fd, "wb+");
   e = ptr->_errno;
   if (!fp)
     _close_r (ptr, fd);
   _CAST_VOID _remove_r (ptr, f);
   ptr->_errno = e;
+  __A_VARIABLE = 1;
   return fp;
 }
 
@@ -93,6 +99,7 @@ _DEFUN (_tmpfile64_r, (ptr),
 FILE *
 _DEFUN_VOID (tmpfile64)
 {
+  __A_VARIABLE = 1;
   return _tmpfile64_r (_REENT);
 }
 
diff --git a/newlib/libc/stdlib/_Exit.c b/newlib/libc/stdlib/_Exit.c
index 3f189a2..2b583d0 100644
--- a/newlib/libc/stdlib/_Exit.c
+++ b/newlib/libc/stdlib/_Exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<_Exit>>---end program execution with no cleanup processing
@@ -43,4 +44,5 @@ _DEFUN (_Exit, (code),
 	int code)
 {
   _exit (code);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/__adjust.c b/newlib/libc/stdlib/__adjust.c
index d5c7075..3cdc233 100644
--- a/newlib/libc/stdlib/__adjust.c
+++ b/newlib/libc/stdlib/__adjust.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * return (*acc) scaled by 10**dexp.
  */
diff --git a/newlib/libc/stdlib/__atexit.c b/newlib/libc/stdlib/__atexit.c
index 0f4aeb8..b6ff1f0 100644
--- a/newlib/libc/stdlib/__atexit.c
+++ b/newlib/libc/stdlib/__atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *  Common routine to implement atexit-like functionality.
  *
diff --git a/newlib/libc/stdlib/__call_atexit.c b/newlib/libc/stdlib/__call_atexit.c
index 6a809cc..47e481a 100644
--- a/newlib/libc/stdlib/__call_atexit.c
+++ b/newlib/libc/stdlib/__call_atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * COmmon routine to call call registered atexit-like routines.
  */
diff --git a/newlib/libc/stdlib/__exp10.c b/newlib/libc/stdlib/__exp10.c
index 4e368b8..cb6fa98 100644
--- a/newlib/libc/stdlib/__exp10.c
+++ b/newlib/libc/stdlib/__exp10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * compute 10**x by successive squaring.
  */
diff --git a/newlib/libc/stdlib/__ten_mu.c b/newlib/libc/stdlib/__ten_mu.c
index 637197b..bedc63b 100644
--- a/newlib/libc/stdlib/__ten_mu.c
+++ b/newlib/libc/stdlib/__ten_mu.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * [atw] multiply 64 bit accumulator by 10 and add digit.
  * The KA/CA way to do this should be to use
@@ -20,5 +21,6 @@ _DEFUN (__ten_mul, (acc, digit),
   *acc *= 10;
   *acc += digit;
 
+  __A_VARIABLE = 1;
   return 0;			/* no overflow */
 }
diff --git a/newlib/libc/stdlib/a64l.c b/newlib/libc/stdlib/a64l.c
index ee3d40d..279d7ca 100644
--- a/newlib/libc/stdlib/a64l.c
+++ b/newlib/libc/stdlib/a64l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<a64l>>, <<l64a>>---convert between radix-64 ASCII string and long
@@ -72,8 +73,10 @@ _DEFUN (a64l, (input),
   int i, digit;
   unsigned long result = 0;
 
-  if (input == NULL)
+  if (input == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   ptr = input;
 
@@ -185,10 +188,13 @@ _DEFUN (a64l, (input),
 
 #if LONG_MAX > 2147483647
   /* for implementations where long is > 32 bits, the result must be sign-extended */
-  if (result & 0x80000000)
+  if (result & 0x80000000) {
+      __A_VARIABLE = 1;
       return (((long)-1 >> 32) << 32) + result;
+  }
 #endif
 
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/stdlib/abort.c b/newlib/libc/stdlib/abort.c
index 93f7c2f..3dc10a7 100644
--- a/newlib/libc/stdlib/abort.c
+++ b/newlib/libc/stdlib/abort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NetWare can not use this implementation of abort.  It provides its
    own version of abort in clib.nlm.  If we can not use clib.nlm, then
    we must write abort in sys/netware.  */
@@ -62,6 +63,7 @@ _DEFUN_VOID (abort)
       raise (SIGABRT);
       _exit (1);
     }
+    __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdlib/abs.c b/newlib/libc/stdlib/abs.c
index 0308b57..1659eaf 100644
--- a/newlib/libc/stdlib/abs.c
+++ b/newlib/libc/stdlib/abs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<abs>>---integer absolute value (magnitude)
@@ -39,5 +40,6 @@ No supporting OS subroutines are required.
 int
 _DEFUN (abs, (i), int i)
 {
+  __A_VARIABLE = 1;
   return (i < 0) ? -i : i;
 }
diff --git a/newlib/libc/stdlib/aligned_alloc.c b/newlib/libc/stdlib/aligned_alloc.c
index 88413ce..3d53d5e 100644
--- a/newlib/libc/stdlib/aligned_alloc.c
+++ b/newlib/libc/stdlib/aligned_alloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2015 embedded brains GmbH
  * All rights reserved.
@@ -34,5 +35,6 @@ aligned_alloc(size_t alignment, size_t size)
 
 	error = posix_memalign(&p, alignment, size);
 
+	__A_VARIABLE = 1;
 	return (error == 0 ? p : NULL);
 }
diff --git a/newlib/libc/stdlib/arc4random.c b/newlib/libc/stdlib/arc4random.c
index 3cccc3e..44537af 100644
--- a/newlib/libc/stdlib/arc4random.c
+++ b/newlib/libc/stdlib/arc4random.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: arc4random.c,v 1.52 2015/01/16 16:48:51 deraadt Exp $	*/
 
 /*
@@ -69,8 +70,10 @@ static inline void _rs_rekey(u_char *dat, size_t datlen);
 static inline void
 _rs_init(u_char *buf, size_t n)
 {
-	if (n < KEYSZ + IVSZ)
+	if (n < KEYSZ + IVSZ) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	if (rs == NULL) {
 		if (_rs_allocate(&rs, &rsx) == -1)
@@ -79,6 +82,7 @@ _rs_init(u_char *buf, size_t n)
 
 	chacha_keysetup(&rsx->rs_chacha, buf, KEYSZ * 8, 0);
 	chacha_ivsetup(&rsx->rs_chacha, buf + KEYSZ);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -100,6 +104,7 @@ _rs_stir(void)
 	memset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));
 
 	rs->rs_count = 1600000;
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -112,6 +117,7 @@ _rs_stir_if_needed(size_t len)
 		rs->rs_count = 0;
 	else
 		rs->rs_count -= len;
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -135,6 +141,7 @@ _rs_rekey(u_char *dat, size_t datlen)
 	_rs_init(rsx->rs_buf, KEYSZ + IVSZ);
 	memset(rsx->rs_buf, 0, KEYSZ + IVSZ);
 	rs->rs_have = sizeof(rsx->rs_buf) - KEYSZ - IVSZ;
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -159,6 +166,7 @@ _rs_random_buf(void *_buf, size_t n)
 		if (rs->rs_have == 0)
 			_rs_rekey(NULL, 0);
 	}
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -173,6 +181,7 @@ _rs_random_u32(uint32_t *val)
 	memcpy(val, keystream, sizeof(*val));
 	memset(keystream, 0, sizeof(*val));
 	rs->rs_have -= sizeof(*val);
+	__A_VARIABLE = 1;
 }
 
 uint32_t
@@ -187,6 +196,7 @@ arc4random(void)
 #ifndef __SINGLE_THREAD__
 	_ARC4_UNLOCK();
 #endif
+	__A_VARIABLE = 1;
 	return val;
 }
 
@@ -200,4 +210,5 @@ arc4random_buf(void *buf, size_t n)
 #ifndef __SINGLE_THREAD__
 	_ARC4_UNLOCK();
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/arc4random_uniform.c b/newlib/libc/stdlib/arc4random_uniform.c
index 1aa9a62..d976cf8 100644
--- a/newlib/libc/stdlib/arc4random_uniform.c
+++ b/newlib/libc/stdlib/arc4random_uniform.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: arc4random_uniform.c,v 1.1 2014/07/12 13:24:54 deraadt Exp $	*/
 
 /*
@@ -34,8 +35,10 @@ arc4random_uniform(uint32_t upper_bound)
 {
 	uint32_t r, min;
 
-	if (upper_bound < 2)
+	if (upper_bound < 2) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
 	/* 2**32 % x == (2**32 - x) % x */
 	min = -upper_bound % upper_bound;
@@ -52,5 +55,6 @@ arc4random_uniform(uint32_t upper_bound)
 			break;
 	}
 
+	__A_VARIABLE = 1;
 	return r % upper_bound;
 }
diff --git a/newlib/libc/stdlib/assert.c b/newlib/libc/stdlib/assert.c
index 135bf15..0c32d66 100644
--- a/newlib/libc/stdlib/assert.c
+++ b/newlib/libc/stdlib/assert.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<assert>>---macro for debugging diagnostics
@@ -62,6 +63,7 @@ _DEFUN (__assert_func, (file, line, func, failedexpr),
 	   func ? ", function: " : "", func ? func : "");
   abort();
   /* NOTREACHED */
+  __A_VARIABLE = 1;
 }
 #endif /* HAVE_ASSERT_FUNC */
 
@@ -73,4 +75,5 @@ _DEFUN (__assert, (file, line, failedexpr),
 {
    __assert_func (file, line, NULL, failedexpr);
   /* NOTREACHED */
+   __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/atexit.c b/newlib/libc/stdlib/atexit.c
index fa91deb..a8ebb9d 100644
--- a/newlib/libc/stdlib/atexit.c
+++ b/newlib/libc/stdlib/atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 Regents of the University of California.
  * All rights reserved.
@@ -62,5 +63,6 @@ _DEFUN (atexit,
 	(fn),
 	_VOID _EXFNPTR(fn, (_VOID)))
 {
+  __A_VARIABLE = 1;
   return __register_exitproc (__et_atexit, fn, NULL, NULL);
 }
diff --git a/newlib/libc/stdlib/atof.c b/newlib/libc/stdlib/atof.c
index 8497f68..99b4b4c 100644
--- a/newlib/libc/stdlib/atof.c
+++ b/newlib/libc/stdlib/atof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<atof>>, <<atoff>>---string to double or float
@@ -68,5 +69,6 @@ double
 _DEFUN (atof, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtod (s, NULL);
 }
diff --git a/newlib/libc/stdlib/atoff.c b/newlib/libc/stdlib/atoff.c
index c97b78f..81a9ee1 100644
--- a/newlib/libc/stdlib/atoff.c
+++ b/newlib/libc/stdlib/atoff.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 #include <_ansi.h>
 
@@ -5,5 +6,6 @@ float
 _DEFUN (atoff, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtof (s, NULL);
 }
diff --git a/newlib/libc/stdlib/atoi.c b/newlib/libc/stdlib/atoi.c
index 6156eda..87fe64a 100644
--- a/newlib/libc/stdlib/atoi.c
+++ b/newlib/libc/stdlib/atoi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<atoi>>, <<atol>>---string to integer
@@ -67,6 +68,7 @@ int
 _DEFUN (atoi, (s),
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return (int) strtol (s, NULL, 10);
 }
 #endif /* !_REENT_ONLY */
@@ -76,6 +78,7 @@ _DEFUN (_atoi_r, (s),
 	struct _reent *ptr _AND
 	_CONST char *s)
 {
+  __A_VARIABLE = 1;
   return (int) _strtol_r (ptr, s, NULL, 10);
 }
 
diff --git a/newlib/libc/stdlib/atol.c b/newlib/libc/stdlib/atol.c
index 8d0e5cd..ffaea76 100644
--- a/newlib/libc/stdlib/atol.c
+++ b/newlib/libc/stdlib/atol.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Andy Wilson, 2-Oct-89.
  */
@@ -9,6 +10,7 @@
 long
 _DEFUN (atol, (s), _CONST char *s)
 {
+  __A_VARIABLE = 1;
   return strtol (s, NULL, 10);
 }
 #endif /* !_REENT_ONLY */
@@ -16,6 +18,7 @@ _DEFUN (atol, (s), _CONST char *s)
 long
 _DEFUN (_atol_r, (ptr, s), struct _reent *ptr _AND _CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _strtol_r (ptr, s, NULL, 10);
 }
 
diff --git a/newlib/libc/stdlib/atoll.c b/newlib/libc/stdlib/atoll.c
index a6abd95..54db497 100644
--- a/newlib/libc/stdlib/atoll.c
+++ b/newlib/libc/stdlib/atoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<atoll>>---convert a string to a long long integer
@@ -81,6 +82,7 @@ long long
 _DEFUN(atoll, (str),
        _CONST char *str)
 {
+	__A_VARIABLE = 1;
 	return strtoll(str, (char **)NULL, 10);
 }
 #endif /* !_REENT_ONLY */
@@ -90,5 +92,6 @@ _DEFUN(_atoll_r, (ptr, str),
        struct _reent *ptr _AND
        _CONST char *str)
 {
+	__A_VARIABLE = 1;
 	return _strtoll_r(ptr, str, (char **)NULL, 10);
 }
diff --git a/newlib/libc/stdlib/btowc.c b/newlib/libc/stdlib/btowc.c
index 7605ce6..62e15d6 100644
--- a/newlib/libc/stdlib/btowc.c
+++ b/newlib/libc/stdlib/btowc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <wchar.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -13,8 +14,10 @@ btowc (int c)
   wchar_t pwc;
   unsigned char b;
 
-  if (c == EOF)
+  if (c == EOF) {
+    __A_VARIABLE = 1;
     return WEOF;
+  }
 
   b = (unsigned char)c;
 
@@ -25,8 +28,11 @@ btowc (int c)
 
   retval = __MBTOWC (_REENT, &pwc, (const char *) &b, 1, &mbs);
 
-  if (retval != 0 && retval != 1)
+  if (retval != 0 && retval != 1) {
+    __A_VARIABLE = 1;
     return WEOF;
+  }
 
+  __A_VARIABLE = 1;
   return (wint_t)pwc;
 }
diff --git a/newlib/libc/stdlib/calloc.c b/newlib/libc/stdlib/calloc.c
index 4415c65..6be8fd8 100644
--- a/newlib/libc/stdlib/calloc.c
+++ b/newlib/libc/stdlib/calloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef MALLOC_PROVIDED
 int _dummy_calloc = 1;
 #else
@@ -62,6 +63,7 @@ _DEFUN (calloc, (n, size),
 	size_t n _AND
 	size_t size)
 {
+  __A_VARIABLE = 1;
   return _calloc_r (_REENT, n, size);
 }
 
diff --git a/newlib/libc/stdlib/cxa_atexit.c b/newlib/libc/stdlib/cxa_atexit.c
index 39a59d5..14aab8b 100644
--- a/newlib/libc/stdlib/cxa_atexit.c
+++ b/newlib/libc/stdlib/cxa_atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Implementation of __cxa_atexit.
  */
diff --git a/newlib/libc/stdlib/cxa_finalize.c b/newlib/libc/stdlib/cxa_finalize.c
index 17d0526..6776c0a 100644
--- a/newlib/libc/stdlib/cxa_finalize.c
+++ b/newlib/libc/stdlib/cxa_finalize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Implementation if __cxa_finalize.
  */
@@ -17,4 +18,5 @@ _DEFUN (__cxa_finalize, (d),
 	void * d)
 {
   __call_exitprocs (0, d);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/div.c b/newlib/libc/stdlib/div.c
index 816c3fb..70b3082 100644
--- a/newlib/libc/stdlib/div.c
+++ b/newlib/libc/stdlib/div.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<div>>---divide two integers
@@ -128,5 +129,6 @@ _DEFUN (div, (num, denom),
 		--r.quot;
 		r.rem += denom;
 	}
+	__A_VARIABLE = 1;
 	return (r);
 }
diff --git a/newlib/libc/stdlib/drand48.c b/newlib/libc/stdlib/drand48.c
index 89fe6af..e927ed1 100644
--- a/newlib/libc/stdlib/drand48.c
+++ b/newlib/libc/stdlib/drand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -18,6 +19,7 @@ _DEFUN (_drand48_r, (r),
        struct _reent *r)
 {
   _REENT_CHECK_RAND48(r);
+  __A_VARIABLE = 1;
   return _erand48_r(r, __rand48_seed);
 }
 
@@ -25,6 +27,7 @@ _DEFUN (_drand48_r, (r),
 double
 _DEFUN_VOID (drand48)
 {
+  __A_VARIABLE = 1;
   return _drand48_r (_REENT);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/dtoa.c b/newlib/libc/stdlib/dtoa.c
index c72ffac..6a4ba7b 100644
--- a/newlib/libc/stdlib/dtoa.c
+++ b/newlib/libc/stdlib/dtoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
  *
  * The author of this software is David M. Gay.
@@ -51,8 +52,10 @@ _DEFUN (quorem,
   /*debug*/ if (b->_wds > n)
     /*debug*/ Bug ("oversize b in quorem");
 #endif
-  if (b->_wds < n)
+  if (b->_wds < n) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   sx = S->_x;
   sxe = sx + --n;
   bx = b->_x;
@@ -138,6 +141,7 @@ _DEFUN (quorem,
 	  b->_wds = n;
 	}
     }
+  __A_VARIABLE = 1;
   return q;
 }
 
@@ -273,6 +277,7 @@ _DEFUN (_dtoa_r,
 	  s[3] ? s + 8 :
 #endif
 	  s + 3;
+      __A_VARIABLE = 1;
       return s;
     }
 #endif
@@ -285,6 +290,7 @@ _DEFUN (_dtoa_r,
       s = "0";
       if (rve)
 	*rve = s + 1;
+      __A_VARIABLE = 1;
       return s;
     }
 
@@ -858,5 +864,6 @@ ret1:
   *decpt = k + 1;
   if (rve)
     *rve = s;
+  __A_VARIABLE = 1;
   return s0;
 }
diff --git a/newlib/libc/stdlib/dtoastub.c b/newlib/libc/stdlib/dtoastub.c
index f4929f2..97aebf2 100644
--- a/newlib/libc/stdlib/dtoastub.c
+++ b/newlib/libc/stdlib/dtoastub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <stdlib.h>
 #include <reent.h>
@@ -17,6 +18,7 @@ _DEFUN (__dtoa,
 	int *sign _AND
 	char **rve)
 {
+  __A_VARIABLE = 1;
   return _dtoa_r (_REENT, d, mode, ndigits, decpt, sign, rve);
 }
 
diff --git a/newlib/libc/stdlib/ecvtbuf.c b/newlib/libc/stdlib/ecvtbuf.c
index feaa33f..534be0f 100644
--- a/newlib/libc/stdlib/ecvtbuf.c
+++ b/newlib/libc/stdlib/ecvtbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<ecvtbuf>>, <<fcvtbuf>>---double or float to string
@@ -93,6 +94,7 @@ _DEFUN (print_f, (ptr, buf, invalue, ndigit, type, dot, mode),
   if (decpt == 9999)
     {
       strcpy (buf, p);
+      __A_VARIABLE = 1;
       return;
     }
   while (*p && decpt > 0)
@@ -133,6 +135,7 @@ _DEFUN (print_f, (ptr, buf, invalue, ndigit, type, dot, mode),
 	}
     }
   *buf++ = 0;
+  __A_VARIABLE = 1;
 }
 
 /* Print number in e format with width chars after.
@@ -163,6 +166,7 @@ _DEFUN (print_e, (ptr, buf, invalue, width, type, dot),
   if (decpt == 9999)
     {
       strcpy (buf, p);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -217,6 +221,7 @@ _DEFUN (print_e, (ptr, buf, invalue, width, type, dot),
   *buf++ = decpt + '0';
 
   *buf++ = 0;
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -244,8 +249,10 @@ _DEFUN (fcvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
       if (reent->_cvtlen <= ndigit + 35)
 	{
 	  if ((fcvt_buf = (char *) _realloc_r (reent, reent->_cvtbuf,
-					       ndigit + 36)) == NULL)
+					       ndigit + 36)) == NULL) {
+	    __A_VARIABLE = 1;
 	    return NULL;
+	  }
 	  reent->_cvtlen = ndigit + 36;
 	  reent->_cvtbuf = fcvt_buf;
 	}
@@ -279,6 +286,7 @@ _DEFUN (fcvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
       done++;
     }
   *fcvt_buf++ = 0;
+  __A_VARIABLE = 1;
   return save;
 }
 
@@ -301,8 +309,10 @@ _DEFUN (ecvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
       if (reent->_cvtlen <= ndigit)
 	{
 	  if ((fcvt_buf = (char *) _realloc_r (reent, reent->_cvtbuf,
-					       ndigit + 1)) == NULL)
+					       ndigit + 1)) == NULL) {
+	    __A_VARIABLE = 1;
 	    return NULL;
+	  }
 	  reent->_cvtlen = ndigit + 1;
 	  reent->_cvtbuf = fcvt_buf;
 	}
@@ -328,6 +338,7 @@ _DEFUN (ecvtbuf, (invalue, ndigit, decpt, sign, fcvt_buf),
       done++;
     }
   *fcvt_buf++ = 0;
+  __A_VARIABLE = 1;
   return save;
 }
 
@@ -467,5 +478,6 @@ _DEFUN (_dcvt, (ptr, buffer, invalue, precision, width, type, dot),
     case 'E':
       print_e (ptr, buffer, invalue, precision, type, dot);
     }
+  __A_VARIABLE = 1;
   return buffer;
 }
diff --git a/newlib/libc/stdlib/efgcvt.c b/newlib/libc/stdlib/efgcvt.c
index b7d9812..c4bf247 100644
--- a/newlib/libc/stdlib/efgcvt.c
+++ b/newlib/libc/stdlib/efgcvt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<ecvt>>, <<ecvtf>>, <<fcvt>>, <<fcvtf>>---double or float to string
@@ -146,6 +147,7 @@ _DEFUN (fcvt, (d, ndigit, decpt, sign),
 	int *decpt _AND
 	int *sign)
 {
+  __A_VARIABLE = 1;
   return fcvtbuf (d, ndigit, decpt, sign, NULL);
 }
 
@@ -156,6 +158,7 @@ _DEFUN (fcvtf, (d, ndigit, decpt, sign),
 	int *decpt _AND
 	int *sign)
 {
+  __A_VARIABLE = 1;
   return fcvt ((float) d, ndigit, decpt, sign);
 }
 
@@ -167,6 +170,7 @@ _DEFUN (gcvtf, (d, ndigit, buf),
 	char *buf)
 {
   double asd = d;
+  __A_VARIABLE = 1;
   return gcvt (asd, ndigit, buf);
 }
 
@@ -178,6 +182,7 @@ _DEFUN (ecvt, (d, ndigit, decpt, sign),
 	int *decpt _AND
 	int *sign)
 {
+  __A_VARIABLE = 1;
   return ecvtbuf (d, ndigit, decpt, sign, NULL);
 }
 
@@ -188,6 +193,7 @@ _DEFUN (ecvtf, (d, ndigit, decpt, sign),
 	int *decpt _AND
 	int *sign)
 {
+  __A_VARIABLE = 1;
   return ecvt ((double) d, ndigit, decpt, sign);
 }
 
@@ -204,5 +210,6 @@ _DEFUN (gcvt, (d, ndigit, buf),
     buf++;
     ndigit--;
   }
+  __A_VARIABLE = 1;
   return (_gcvt (_REENT, d, ndigit, buf, 'g', 0) ? tbuf : 0);
 }
diff --git a/newlib/libc/stdlib/environ.c b/newlib/libc/stdlib/environ.c
index 8cc2392..03c7271 100644
--- a/newlib/libc/stdlib/environ.c
+++ b/newlib/libc/stdlib/environ.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1995, 1996, 2002 Red Hat Incorporated.
  * All rights reserved.
  * 
diff --git a/newlib/libc/stdlib/envlock.c b/newlib/libc/stdlib/envlock.c
index 410a28a..49daa40 100644
--- a/newlib/libc/stdlib/envlock.c
+++ b/newlib/libc/stdlib/envlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<__env_lock>>, <<__env_unlock>>---lock environ variable
@@ -49,6 +50,7 @@ __env_lock (ptr)
 #ifndef __SINGLE_THREAD__
   __lock_acquire_recursive (__env_recursive_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
 
 void
@@ -58,4 +60,5 @@ __env_unlock (ptr)
 #ifndef __SINGLE_THREAD__
   __lock_release_recursive (__env_recursive_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/eprintf.c b/newlib/libc/stdlib/eprintf.c
index 46cf810..858e694 100644
--- a/newlib/libc/stdlib/eprintf.c
+++ b/newlib/libc/stdlib/eprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is an implementation of the __eprintf function which is
    compatible with the assert.h which is distributed with gcc.
 
@@ -23,4 +24,5 @@ __eprintf (format, file, line, expression)
   (void) fiprintf (stderr, format, file, line, expression);
   abort ();
   /*NOTREACHED*/
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/erand48.c b/newlib/libc/stdlib/erand48.c
index 26b39fb..798d3ba 100644
--- a/newlib/libc/stdlib/erand48.c
+++ b/newlib/libc/stdlib/erand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -19,6 +20,7 @@ _DEFUN (_erand48_r, (r, xseed),
        unsigned short xseed[3])
 {
   __dorand48(r, xseed);
+  __A_VARIABLE = 1;
   return ldexp((double) xseed[0], -48) +
     ldexp((double) xseed[1], -32) +
     ldexp((double) xseed[2], -16);
@@ -29,6 +31,7 @@ double
 _DEFUN (erand48, (xseed),
        unsigned short xseed[3])
 {
+  __A_VARIABLE = 1;
   return _erand48_r (_REENT, xseed);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/exit.c b/newlib/libc/stdlib/exit.c
index 1dc5694..90af83d 100644
--- a/newlib/libc/stdlib/exit.c
+++ b/newlib/libc/stdlib/exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 Regents of the University of California.
  * All rights reserved.
@@ -68,4 +69,5 @@ _DEFUN (exit, (code),
   if (_GLOBAL_REENT->__cleanup)
     (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
   _exit (code);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/gdtoa-gethex.c b/newlib/libc/stdlib/gdtoa-gethex.c
index fd3903c..7f95cb1 100644
--- a/newlib/libc/stdlib/gdtoa-gethex.c
+++ b/newlib/libc/stdlib/gdtoa-gethex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
 
 The author of this software is David M. Gay.
@@ -98,6 +99,7 @@ _DEFUN(rshift, (b, k),
 		}
 	if ((b->_wds = x1 - b->_x) == 0)
 		b->_x[0] = 0;
+	__A_VARIABLE = 1;
 }
 
 static _Bigint *
@@ -117,6 +119,7 @@ _DEFUN (increment, (ptr, b),
 	do {
 		if (*x < (__ULong)0xffffffffL) {
 			++*x;
+			__A_VARIABLE = 1;
 			return b;
 			}
 		*x++ = 0;
@@ -126,8 +129,10 @@ _DEFUN (increment, (ptr, b),
 		y = *x + carry;
 		carry = y >> 16;
 		*x++ = y & 0xffff;
-		if (!carry)
+		if (!carry) {
+			__A_VARIABLE = 1;
 			return b;
+		}
 		} while(x < xe);
 	if (carry)
 #endif
@@ -140,6 +145,7 @@ _DEFUN (increment, (ptr, b),
 			}
 		b->_x[b->_wds++] = 1;
 		}
+	__A_VARIABLE = 1;
 	return b;
 }
 
diff --git a/newlib/libc/stdlib/gdtoa-hexnan.c b/newlib/libc/stdlib/gdtoa-hexnan.c
index 24e3783..36d3b18 100644
--- a/newlib/libc/stdlib/gdtoa-hexnan.c
+++ b/newlib/libc/stdlib/gdtoa-hexnan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
 
 The author of this software is David M. Gay.
@@ -55,10 +56,13 @@ _DEFUN (match, (sp, t),
 	while( (d = *t++) !=0) {
 		if ((c = *++s) >= 'A' && c <= 'Z')
 			c += 'a' - 'A';
-		if (c != d)
+		if (c != d) {
+			__A_VARIABLE = 1;
 			return 0;
 		}
+		}
 	*sp = s + 1;
+	__A_VARIABLE = 1;
 	return 1;
 }
 
@@ -77,6 +81,7 @@ _DEFUN (L_shift, (x, x1, i),
 		*x |= x[1] << j;
 		x[1] >>= i;
 		} while(++x < x1);
+		__A_VARIABLE = 1;
 }
 
 int
diff --git a/newlib/libc/stdlib/getenv.c b/newlib/libc/stdlib/getenv.c
index 79360ac..97f8de0 100644
--- a/newlib/libc/stdlib/getenv.c
+++ b/newlib/libc/stdlib/getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<getenv>>---look up environment variable
@@ -73,6 +74,7 @@ _DEFUN (_findenv, (name, offset),
 	register _CONST char *name _AND
 	int *offset)
 {
+  __A_VARIABLE = 1;
   return _findenv_r (_REENT, name, offset);
 }
 
@@ -87,6 +89,7 @@ _DEFUN (getenv, (name),
 {
   int offset;
 
+  __A_VARIABLE = 1;
   return _findenv_r (_REENT, name, &offset);
 }
 
diff --git a/newlib/libc/stdlib/getenv_r.c b/newlib/libc/stdlib/getenv_r.c
index cdc12c0..5a9b06e 100644
--- a/newlib/libc/stdlib/getenv_r.c
+++ b/newlib/libc/stdlib/getenv_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<_getenv_r>>---look up environment variable
@@ -96,6 +97,7 @@ _DEFUN (_findenv_r, (reent_ptr, name, offset),
   if (!*p_environ)
     {
       ENV_UNLOCK;
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -112,10 +114,12 @@ _DEFUN (_findenv_r, (reent_ptr, name, offset),
 	{
 	  *offset = p - *p_environ;
 	  ENV_UNLOCK;
+	  __A_VARIABLE = 1;
 	  return (char *) (++c);
 	}
     }
   ENV_UNLOCK;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -131,5 +135,6 @@ _DEFUN (_getenv_r, (reent_ptr, name),
 {
   int offset;
 
+  __A_VARIABLE = 1;
   return _findenv_r (reent_ptr, name, &offset);
 }
diff --git a/newlib/libc/stdlib/getopt.c b/newlib/libc/stdlib/getopt.c
index 1094747..b4c16c9 100644
--- a/newlib/libc/stdlib/getopt.c
+++ b/newlib/libc/stdlib/getopt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************************
 
 getopt.c - Read command line options
@@ -134,6 +135,7 @@ reverse_argv_elements (char **argv, int num)
       argv[i] = argv[num - i - 1];
       argv[num - i - 1] = tmp;
     }
+    __A_VARIABLE = 1;
 }
 
 /* permute: swap two blocks of argv-elements given their lengths */
@@ -143,12 +145,14 @@ permute (char *const argv[], int len1, int len2)
   reverse_argv_elements ((char **) argv, len1);
   reverse_argv_elements ((char **) argv, len1 + len2);
   reverse_argv_elements ((char **) argv, len2);
+  __A_VARIABLE = 1;
 }
 
 /* is_option: is this argv-element an option or the end of the option list? */
 static int
 is_option (char *argv_element, int only)
 {
+  __A_VARIABLE = 1;
   return ((argv_element == 0)
 	  || (argv_element[0] == '-') || (only && argv_element[0] == '+'));
 }
@@ -163,6 +167,7 @@ read_globals (struct getopt_data *data)
   data->opterr = opterr;
   data->optopt = optopt;
   data->optwhere = optwhere;
+  __A_VARIABLE = 1;
 }
 
 /* write_globals: write the values into the globals from a getopt_data
@@ -175,6 +180,7 @@ write_globals (struct getopt_data *data)
   opterr = data->opterr;
   optopt = data->optopt;
   optwhere = data->optwhere;
+  __A_VARIABLE = 1;
 }
 
 /* getopt_internal:  the function that does all the dirty work
@@ -460,6 +466,7 @@ getopt (int argc, char *const argv[], const char *optstring)
   read_globals (&data);
   r = getopt_internal (argc, argv, optstring, 0, 0, 0, &data);
   write_globals (&data);
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -473,6 +480,7 @@ getopt_long (int argc, char *const argv[], const char *shortopts,
   read_globals (&data);
   r = getopt_internal (argc, argv, shortopts, longopts, longind, 0, &data);
   write_globals (&data);
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -486,6 +494,7 @@ getopt_long_only (int argc, char *const argv[], const char *shortopts,
   read_globals (&data);
   r = getopt_internal (argc, argv, shortopts, longopts, longind, 1, &data);
   write_globals (&data);
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -493,6 +502,7 @@ int
 __getopt_r (int argc, char *const argv[], const char *optstring,
 	    struct getopt_data *data)
 {
+  __A_VARIABLE = 1;
   return getopt_internal (argc, argv, optstring, 0, 0, 0, data);
 }
 
@@ -501,6 +511,7 @@ __getopt_long_r (int argc, char *const argv[], const char *shortopts,
 		 const struct option *longopts, int *longind,
 		 struct getopt_data *data)
 {
+  __A_VARIABLE = 1;
   return getopt_internal (argc, argv, shortopts, longopts, longind, 0, data);
 }
 
@@ -509,6 +520,7 @@ __getopt_long_only_r (int argc, char *const argv[], const char *shortopts,
 		      const struct option *longopts, int *longind,
 		      struct getopt_data *data)
 {
+  __A_VARIABLE = 1;
   return getopt_internal (argc, argv, shortopts, longopts, longind, 1, data);
 }
 
diff --git a/newlib/libc/stdlib/getsubopt.c b/newlib/libc/stdlib/getsubopt.c
index 250e73d..6cdef45 100644
--- a/newlib/libc/stdlib/getsubopt.c
+++ b/newlib/libc/stdlib/getsubopt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -58,14 +59,17 @@ getsubopt(optionp, tokens, valuep)
 
 	suboptarg = *valuep = NULL;
 
-	if (!optionp || !*optionp)
+	if (!optionp || !*optionp) {
+		__A_VARIABLE = 1;
 		return(-1);
+	}
 
 	/* skip leading white-space, commas */
 	for (p = *optionp; *p && (*p == ',' || *p == ' ' || *p == '\t'); ++p);
 
 	if (!*p) {
 		*optionp = p;
+		__A_VARIABLE = 1;
 		return(-1);
 	}
 
@@ -95,7 +99,10 @@ getsubopt(optionp, tokens, valuep)
 	*optionp = p;
 
 	for (cnt = 0; *tokens; ++tokens, ++cnt)
-		if (!strcmp(suboptarg, *tokens))
+		if (!strcmp(suboptarg, *tokens)) {
+			__A_VARIABLE = 1;
 			return(cnt);
+		}
+	__A_VARIABLE = 1;
 	return(-1);
 }
diff --git a/newlib/libc/stdlib/imaxabs.c b/newlib/libc/stdlib/imaxabs.c
index e438646..3830bf0 100644
--- a/newlib/libc/stdlib/imaxabs.c
+++ b/newlib/libc/stdlib/imaxabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
  * All rights reserved.
@@ -32,5 +33,6 @@ __FBSDID("$FreeBSD: head/lib/libc/stdlib/imaxabs.c 86368 2001-11-15 02:05:03Z mi
 intmax_t
 imaxabs(intmax_t j)
 {
+	__A_VARIABLE = 1;
 	return (j < 0 ? -j : j);
 }
diff --git a/newlib/libc/stdlib/imaxdiv.c b/newlib/libc/stdlib/imaxdiv.c
index eb3e99a..9639156 100644
--- a/newlib/libc/stdlib/imaxdiv.c
+++ b/newlib/libc/stdlib/imaxdiv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
  * All rights reserved.
@@ -44,5 +45,6 @@ imaxdiv(intmax_t numer, intmax_t denom)
 		retval.rem -= denom;
 	}
 #endif
+	__A_VARIABLE = 1;
 	return (retval);
 }
diff --git a/newlib/libc/stdlib/itoa.c b/newlib/libc/stdlib/itoa.c
index 377834d..98b95e2 100644
--- a/newlib/libc/stdlib/itoa.c
+++ b/newlib/libc/stdlib/itoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<itoa>>---integer to string
@@ -42,6 +43,7 @@ _DEFUN (__itoa, (value, str, base),
   if ((base < 2) || (base > 36))
     { 
       str[0] = '\0';
+      __A_VARIABLE = 1;
       return NULL;
     }  
     
@@ -56,6 +58,7 @@ _DEFUN (__itoa, (value, str, base),
     uvalue = (unsigned)value;
   
   __utoa (uvalue, &str[i], base);
+  __A_VARIABLE = 1;
   return str;
 }
 
@@ -65,5 +68,6 @@ _DEFUN (itoa, (value, str, base),
         char *str _AND
         int base)
 {
+  __A_VARIABLE = 1;
   return __itoa (value, str, base);
 }
diff --git a/newlib/libc/stdlib/jrand48.c b/newlib/libc/stdlib/jrand48.c
index 9e2f92c..7720161 100644
--- a/newlib/libc/stdlib/jrand48.c
+++ b/newlib/libc/stdlib/jrand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -19,6 +20,7 @@ _DEFUN (_jrand48_r, (r, xseed),
        unsigned short xseed[3])
 {
   __dorand48(r, xseed);
+  __A_VARIABLE = 1;
   return ((long) xseed[2] << 16) + (long) xseed[1];
 }
 
@@ -27,6 +29,7 @@ long
 _DEFUN (jrand48, (xseed),
        unsigned short xseed[3])
 {
+  __A_VARIABLE = 1;
   return _jrand48_r (_REENT, xseed);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/l64a.c b/newlib/libc/stdlib/l64a.c
index d415d04..d990392 100644
--- a/newlib/libc/stdlib/l64a.c
+++ b/newlib/libc/stdlib/l64a.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* l64a - convert long to radix-64 ascii string
  *          
  * Conversion is performed on at most 32-bits of input value starting 
@@ -30,6 +31,7 @@ char *
 _DEFUN (l64a, (value),
      long value)
 {
+  __A_VARIABLE = 1;
   return _l64a_r (_REENT, value);
 }
 
@@ -60,5 +62,6 @@ _DEFUN (_l64a_r, (rptr, value),
       tmp >>= 6;
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/stdlib/labs.c b/newlib/libc/stdlib/labs.c
index 634cf73..a1501e3 100644
--- a/newlib/libc/stdlib/labs.c
+++ b/newlib/libc/stdlib/labs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<labs>>---long integer absolute value
@@ -45,5 +46,6 @@ _DEFUN (labs, (x),
     {
       x = -x;
     }
+  __A_VARIABLE = 1;
   return x;
 }
diff --git a/newlib/libc/stdlib/lcong48.c b/newlib/libc/stdlib/lcong48.c
index 548f327..6d67fcd 100644
--- a/newlib/libc/stdlib/lcong48.c
+++ b/newlib/libc/stdlib/lcong48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -26,6 +27,7 @@ _DEFUN (_lcong48_r, (r, p),
   __rand48_mult[1] = p[4];
   __rand48_mult[2] = p[5];
   __rand48_add = p[6];
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -34,5 +36,6 @@ _DEFUN (lcong48, (p),
        unsigned short p[7])
 {
   _lcong48_r (_REENT, p);
+  __A_VARIABLE = 1;
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/ldiv.c b/newlib/libc/stdlib/ldiv.c
index d7508f1..cd48aa3 100644
--- a/newlib/libc/stdlib/ldiv.c
+++ b/newlib/libc/stdlib/ldiv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<ldiv>>---divide two long integers
@@ -105,5 +106,6 @@ _DEFUN (ldiv, (num, denom),
 		--r.quot;
 		r.rem += denom;
 	}
+	__A_VARIABLE = 1;
 	return (r);
 }
diff --git a/newlib/libc/stdlib/ldtoa.c b/newlib/libc/stdlib/ldtoa.c
index a44413c..ac971d6 100644
--- a/newlib/libc/stdlib/ldtoa.c
+++ b/newlib/libc/stdlib/ldtoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
  /* Extended precision arithmetic functions for long double I/O.
   * This program has been placed in the public domain.
   */
@@ -463,6 +464,7 @@ eclear (register short unsigned int *x)
 
   for (i = 0; i < NE; i++)
     *x++ = 0;
+  __A_VARIABLE = 1;
 }
 
 
@@ -479,6 +481,7 @@ emov (register _CONST short unsigned int *a, register short unsigned int *b)
 
   for (i = 0; i < NE; i++)
     *b++ = *a++;
+  __A_VARIABLE = 1;
 }
 
 
@@ -606,6 +609,7 @@ einfin (register short unsigned int *x, register LDPARMS * ldp)
 	}
     }
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Move in external format number,
@@ -704,6 +708,7 @@ ecleaz (register short unsigned int *xi)
 
   for (i = 0; i < NI; i++)
     *xi++ = 0;
+  __A_VARIABLE = 1;
 }
 
 /* same, but don't touch the sign. */
@@ -716,6 +721,7 @@ ecleazs (register short unsigned int *xi)
   ++xi;
   for (i = 0; i < NI - 1; i++)
     *xi++ = 0;
+  __A_VARIABLE = 1;
 }
 
 
@@ -732,6 +738,7 @@ emovz (register short unsigned int *a, register short unsigned int *b)
     *b++ = *a++;
 /* clear low guard word */
   *b = 0;
+  __A_VARIABLE = 1;
 }
 
 /* Return nonzero if internal format number is a NaN.
@@ -746,10 +753,13 @@ eiisnan (short unsigned int *x)
     {
       for (i = M + 1; i < NI; i++)
 	{
-	  if (x[i] != 0)
+	  if (x[i] != 0) {
+	    __A_VARIABLE = 1;
 	    return (1);
+	  }
 	}
     }
+  __A_VARIABLE = 1;
   return (0);
 }
 
@@ -827,6 +837,7 @@ eshdn1 (register short unsigned int *x)
       bits <<= 1;
       ++x;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -854,6 +865,7 @@ eshup1 (register short unsigned int *x)
       bits <<= 1;
       --x;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -878,6 +890,7 @@ eshdn8 (register short unsigned int *x)
       oldbyt = newbyt;
       ++x;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -901,6 +914,7 @@ eshup8 (register short unsigned int *x)
       oldbyt = newbyt;
       --x;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -920,6 +934,7 @@ eshup6 (register short unsigned int *x)
     *p++ = *x++;
 
   *p = 0;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -939,6 +954,7 @@ eshdn6 (register short unsigned int *x)
     *(--p) = *(--x);
 
   *(--p) = 0;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -967,6 +983,7 @@ eaddm (short unsigned int *x, short unsigned int *y)
       --x;
       --y;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -995,6 +1012,7 @@ esubm (short unsigned int *x, short unsigned int *y)
       --x;
       --y;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -1040,6 +1058,7 @@ m16m (short unsigned int a, short unsigned int *b, short unsigned int *c)
     }
   for (i = M; i < NI; i++)
     c[i] = p[i];
+  __A_VARIABLE = 1;
 }
 
 
@@ -1132,6 +1151,7 @@ edivm (short unsigned int *den, short unsigned int *num, LDPARMS * ldp)
   for (i = 0; i < NI; i++)
     num[i] = equot[i];
 
+  __A_VARIABLE = 1;
   return ((int) j);
 }
 
@@ -1174,6 +1194,7 @@ emulm (short unsigned int *a, short unsigned int *b, LDPARMS * ldp)
     b[i] = equot[i];
 
 /* return flag for lost nonzero bits */
+  __A_VARIABLE = 1;
   return ((int) j);
 }
 
@@ -2147,6 +2168,7 @@ etoe53 (x, e)
      unsigned short *x, *e;
 {
   etodec (x, e);		/* see etodec.c */
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -2154,6 +2176,7 @@ toe53 (x, y)
      unsigned short *x, *y;
 {
   todec (x, y);
+  __A_VARIABLE = 1;
 }
 
 #else
@@ -2925,6 +2948,7 @@ stripspaces:
   if (rve)
     *rve = outstr + (s - outbuf);
 
+  __A_VARIABLE = 1;
   return outstr;
 }
 
@@ -3750,6 +3774,7 @@ eiremain (short unsigned int *den, short unsigned int *num, LDPARMS * ldp)
       ln -= 1;
     }
   emdnorm (num, 0, 0, ln, 0, ldp);
+  __A_VARIABLE = 1;
 }
 
 /* NaN bit patterns
diff --git a/newlib/libc/stdlib/llabs.c b/newlib/libc/stdlib/llabs.c
index 4963739..86dabcc 100644
--- a/newlib/libc/stdlib/llabs.c
+++ b/newlib/libc/stdlib/llabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<llabs>>---compute the absolute value of an long long integer.
@@ -62,5 +63,6 @@ long long
 _DEFUN(llabs, (j),
        long long j)
 {
+	__A_VARIABLE = 1;
 	return (j < 0 ? -j : j);
 }
diff --git a/newlib/libc/stdlib/lldiv.c b/newlib/libc/stdlib/lldiv.c
index 6b853e4..76eda43 100644
--- a/newlib/libc/stdlib/lldiv.c
+++ b/newlib/libc/stdlib/lldiv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<lldiv>>---divide two long long integers
@@ -110,6 +111,7 @@ _DEFUN (lldiv, (number, denom),
 		retval.quot++;
 		retval.rem -= denom;
 	}
+	__A_VARIABLE = 1;
 	return (retval);
 }
 
diff --git a/newlib/libc/stdlib/lrand48.c b/newlib/libc/stdlib/lrand48.c
index bfc693b..c097512 100644
--- a/newlib/libc/stdlib/lrand48.c
+++ b/newlib/libc/stdlib/lrand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -19,6 +20,7 @@ _DEFUN (_lrand48_r, (r),
 {
   _REENT_CHECK_RAND48(r);
   __dorand48(r, __rand48_seed);
+  __A_VARIABLE = 1;
   return (long)((unsigned long) __rand48_seed[2] << 15) +
     ((unsigned long) __rand48_seed[1] >> 1);
 }
@@ -27,6 +29,7 @@ _DEFUN (_lrand48_r, (r),
 long
 _DEFUN_VOID (lrand48)
 {
+  __A_VARIABLE = 1;
   return _lrand48_r (_REENT);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/malign.c b/newlib/libc/stdlib/malign.c
index 1eded30..1dd8724 100644
--- a/newlib/libc/stdlib/malign.c
+++ b/newlib/libc/stdlib/malign.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef MALLOC_PROVIDED
 /* malign.c -- a wrapper for memalign_r.  */
 
@@ -13,6 +14,7 @@ _DEFUN (memalign, (align, nbytes),
 	size_t align _AND
 	size_t nbytes)
 {
+  __A_VARIABLE = 1;
   return _memalign_r (_REENT, align, nbytes);
 }
 
diff --git a/newlib/libc/stdlib/malloc.c b/newlib/libc/stdlib/malloc.c
index 160a13e..3b269c3 100644
--- a/newlib/libc/stdlib/malloc.c
+++ b/newlib/libc/stdlib/malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* VxWorks provides its own version of malloc, and we can't use this
    one because VxWorks does not provide sbrk.  So we have a hook to
    not compile this code.  */
@@ -212,6 +213,7 @@ _PTR
 _DEFUN (malloc, (nbytes),
 	size_t nbytes)		/* get a block */
 {
+  __A_VARIABLE = 1;
   return _malloc_r (_REENT, nbytes);
 }
 
@@ -220,6 +222,7 @@ _DEFUN (free, (aptr),
 	_PTR aptr)
 {
   _free_r (_REENT, aptr);
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdlib/mallocr.c b/newlib/libc/stdlib/mallocr.c
index ecc445f..bb8dd3b 100644
--- a/newlib/libc/stdlib/mallocr.c
+++ b/newlib/libc/stdlib/mallocr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef MALLOC_PROVIDED
 int _dummy_mallocr = 1;
 #else
@@ -1124,6 +1125,7 @@ GmListElement* makeGmListElement (void* bas)
 		this->next = head;
 		head = this;
 	}
+	__A_VARIABLE = 1;
 	return this;
 }
 
@@ -1146,6 +1148,7 @@ void gcleanup ()
 		LocalFree (head);
 		head = next;
 	}
+	__A_VARIABLE = 1;
 }
 		
 static
@@ -1790,6 +1793,7 @@ static void do_check_chunk(p) mchunkptr p;
   else
     assert((char*)p + sz <= sbrk_base + sbrked_mem);
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -1824,6 +1828,7 @@ static void do_check_free_chunk(p) mchunkptr p;
   }
   else /* markers are always of size SIZE_SZ */
     assert(sz == SIZE_SZ); 
+    __A_VARIABLE = 1;
 }
 
 #if __STD_C
@@ -1856,6 +1861,7 @@ static void do_check_inuse_chunk(p) mchunkptr p;
   else if (!inuse(next))
     do_check_free_chunk(next);
 
+  __A_VARIABLE = 1;
 }
 
 #if __STD_C
@@ -1882,6 +1888,7 @@ static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
   /* ... and was allocated at front of an available chunk */
   assert(prev_inuse(p));
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -2062,6 +2069,7 @@ STATIC void munmap_chunk(p) mchunkptr p;
 
   /* munmap returns non-zero on failure */
   assert(ret == 0);
+  __A_VARIABLE = 1;
 }
 
 #else /* ! DEFINE_FREE */
@@ -2099,7 +2107,10 @@ static mchunkptr mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
 
   cp = (char *)mremap((char *)p - offset, size + offset, new_size, 1);
 
-  if (cp == (char *)-1) return 0;
+  if (cp == (char *)-1) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
 
   p = (mchunkptr)(cp + offset);
 
@@ -2114,6 +2125,7 @@ static mchunkptr mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
     max_mmapped_mem = mmapped_mem;
   if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
     max_total_mem = mmapped_mem + sbrked_mem;
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -3147,6 +3159,7 @@ Void_t* vALLOc(RARG size_t bytes)
 Void_t* vALLOc(RARG bytes) RDECL size_t bytes;
 #endif
 {
+  __A_VARIABLE = 1;
   return mEMALIGn (RCALL malloc_getpagesize, bytes);
 }
 
@@ -3167,6 +3180,7 @@ Void_t* pvALLOc(RARG bytes) RDECL size_t bytes;
 #endif
 {
   size_t pagesize = malloc_getpagesize;
+  __A_VARIABLE = 1;
   return mEMALIGn (RCALL pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
 }
 
@@ -3270,6 +3284,7 @@ void cfree(mem) Void_t *mem;
 #else
   fREe(mem);
 #endif
+  __A_VARIABLE = 1;
 }
 #endif
 #endif
@@ -3452,6 +3467,7 @@ STATIC void malloc_update_mallinfo()
 #endif
   current_mallinfo.keepcost = chunksize(top);
 
+  __A_VARIABLE = 1;
 }
 
 #else /* ! DEFINE_MALLINFO */
@@ -3531,6 +3547,7 @@ void malloc_stats(RONEARG) RDECL
   fprintf(fp, "max mmap regions = %10u\n", 
 	  (unsigned int)local_max_n_mmaps);
 #endif
+  __A_VARIABLE = 1;
 }
 
 #endif /* DEFINE_MALLOC_STATS */
@@ -3553,6 +3570,7 @@ struct mallinfo mALLINFo(RONEARG) RDECL
   malloc_update_mallinfo();
   ret = current_mallinfo;
   MALLOC_UNLOCK;
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -3583,24 +3601,29 @@ int mALLOPt(RARG param_number, value) RDECL int param_number; int value;
   switch(param_number) 
   {
     case M_TRIM_THRESHOLD:
-      trim_threshold = value; MALLOC_UNLOCK; return 1; 
+      trim_threshold = value; MALLOC_UNLOCK; __A_VARIABLE = 1;
+      return 1; 
     case M_TOP_PAD:
-      top_pad = value; MALLOC_UNLOCK; return 1; 
+      top_pad = value; MALLOC_UNLOCK; __A_VARIABLE = 1;
+      return 1; 
     case M_MMAP_THRESHOLD:
 #if HAVE_MMAP
       mmap_threshold = value;
 #endif
       MALLOC_UNLOCK;
+      __A_VARIABLE = 1;
       return 1;
     case M_MMAP_MAX:
 #if HAVE_MMAP
-      n_mmaps_max = value; MALLOC_UNLOCK; return 1;
+      n_mmaps_max = value; MALLOC_UNLOCK; __A_VARIABLE = 1;
+      return 1;
 #else
       MALLOC_UNLOCK; return value == 0;
 #endif
 
     default:
       MALLOC_UNLOCK;
+      __A_VARIABLE = 1;
       return 0;
   }
 }
diff --git a/newlib/libc/stdlib/mblen.c b/newlib/libc/stdlib/mblen.c
index f9fb464..f1822eb 100644
--- a/newlib/libc/stdlib/mblen.c
+++ b/newlib/libc/stdlib/mblen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<mblen>>---minimal multibyte length function
diff --git a/newlib/libc/stdlib/mblen_r.c b/newlib/libc/stdlib/mblen_r.c
index 9c1533e..179c6e1 100644
--- a/newlib/libc/stdlib/mblen_r.c
+++ b/newlib/libc/stdlib/mblen_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<_mblen_r>>---reentrant minimal multibyte length function
@@ -62,9 +63,11 @@ _DEFUN (_mblen_r, (r, s, n, state),
   if (retval < 0)
     {
       state->__count = 0;
+      __A_VARIABLE = 1;
       return -1;
     }
 
+  __A_VARIABLE = 1;
   return retval;
 #else /* not _MB_CAPABLE */
   if (s == NULL || *s == '\0')
diff --git a/newlib/libc/stdlib/mbrlen.c b/newlib/libc/stdlib/mbrlen.c
index 57a733f..7839513 100644
--- a/newlib/libc/stdlib/mbrlen.c
+++ b/newlib/libc/stdlib/mbrlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <newlib.h>
 #include <wchar.h>
@@ -18,5 +19,6 @@ mbrlen(const char *__restrict s, size_t n, mbstate_t *__restrict ps)
     }
 #endif
 
+  __A_VARIABLE = 1;
   return mbrtowc(NULL, s, n, ps);
 }
diff --git a/newlib/libc/stdlib/mbrtowc.c b/newlib/libc/stdlib/mbrtowc.c
index 69e3acb..18107a5 100644
--- a/newlib/libc/stdlib/mbrtowc.c
+++ b/newlib/libc/stdlib/mbrtowc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <newlib.h>
 #include <wchar.h>
diff --git a/newlib/libc/stdlib/mbsinit.c b/newlib/libc/stdlib/mbsinit.c
index e32369a..1008144 100644
--- a/newlib/libc/stdlib/mbsinit.c
+++ b/newlib/libc/stdlib/mbsinit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <wchar.h>
 #include <stdlib.h>
diff --git a/newlib/libc/stdlib/mbsnrtowcs.c b/newlib/libc/stdlib/mbsnrtowcs.c
index 7ab3847..8dc7505 100644
--- a/newlib/libc/stdlib/mbsnrtowcs.c
+++ b/newlib/libc/stdlib/mbsnrtowcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<mbsrtowcs>>, <<mbsnrtowcs>>---convert a character string to a wide-character string
@@ -177,6 +178,7 @@ _DEFUN (mbsnrtowcs, (dst, src, nms, len, ps),
 	size_t len _AND
 	mbstate_t *__restrict ps)
 {
+  __A_VARIABLE = 1;
   return _mbsnrtowcs_r (_REENT, dst, src, nms, len, ps);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/mbsrtowcs.c b/newlib/libc/stdlib/mbsrtowcs.c
index 65e46d3..d70983b 100644
--- a/newlib/libc/stdlib/mbsrtowcs.c
+++ b/newlib/libc/stdlib/mbsrtowcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* doc in mbsnrtowcs.c */
 
 #include <reent.h>
@@ -15,6 +16,7 @@ _DEFUN (_mbsrtowcs_r, (r, dst, src, len, ps),
 	size_t len _AND
 	mbstate_t *ps)
 {
+  __A_VARIABLE = 1;
   return _mbsnrtowcs_r (r, dst, src, (size_t) -1, len, ps);
 }
 
@@ -26,6 +28,7 @@ _DEFUN (mbsrtowcs, (dst, src, len, ps),
 	size_t len _AND
 	mbstate_t *__restrict ps)
 {
+  __A_VARIABLE = 1;
   return _mbsnrtowcs_r (_REENT, dst, src, (size_t) -1, len, ps);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/mbstowcs.c b/newlib/libc/stdlib/mbstowcs.c
index 0954345..2bd6063 100644
--- a/newlib/libc/stdlib/mbstowcs.c
+++ b/newlib/libc/stdlib/mbstowcs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<mbstowcs>>---minimal multibyte string to wide char converter
@@ -63,6 +64,7 @@ _DEFUN (mbstowcs, (pwcs, s, n),
   mbstate_t state;
   state.__count = 0;
   
+  __A_VARIABLE = 1;
   return _mbstowcs_r (_REENT, pwcs, s, n, &state);
 #else /* not _MB_CAPABLE */
   
diff --git a/newlib/libc/stdlib/mbstowcs_r.c b/newlib/libc/stdlib/mbstowcs_r.c
index 4950499..6e6da14 100644
--- a/newlib/libc/stdlib/mbstowcs_r.c
+++ b/newlib/libc/stdlib/mbstowcs_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 #include <wchar.h>
 #include "local.h"
diff --git a/newlib/libc/stdlib/mbtowc.c b/newlib/libc/stdlib/mbtowc.c
index 7b8be77..fdbb3dd 100644
--- a/newlib/libc/stdlib/mbtowc.c
+++ b/newlib/libc/stdlib/mbtowc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<mbtowc>>---minimal multibyte to wide char converter
@@ -75,8 +76,10 @@ _DEFUN (mbtowc, (pwc, s, n),
   if (retval < 0)
     {
       ps->__count = 0;
+      __A_VARIABLE = 1;
       return -1;
     }
+  __A_VARIABLE = 1;
   return retval;
 #else /* not _MB_CAPABLE */
   if (s == NULL)
diff --git a/newlib/libc/stdlib/mbtowc_r.c b/newlib/libc/stdlib/mbtowc_r.c
index 9d78256..658eccc 100644
--- a/newlib/libc/stdlib/mbtowc_r.c
+++ b/newlib/libc/stdlib/mbtowc_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 #include <stdlib.h>
 #include <locale.h>
@@ -15,6 +16,7 @@ _DEFUN (_mbtowc_r, (r, pwc, s, n, state),
         size_t         n   _AND
         mbstate_t      *state)
 {
+  __A_VARIABLE = 1;
   return __MBTOWC (r, pwc, s, n, state);
 }
 
@@ -106,11 +108,15 @@ ___iso_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
   if (pwc == NULL)
     pwc = &dummy;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return -2;
+  }
 
   if (*t >= 0xa0)
     {
@@ -120,17 +126,22 @@ ___iso_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 	  if (*pwc == 0) /* Invalid character */
 	    {
 	      r->_errno = EILSEQ;
+	      __A_VARIABLE = 1;
 	      return -1;
 	    }
+	  __A_VARIABLE = 1;
 	  return 1;
 	}
     }
 
   *pwc = (wchar_t) *t;
   
-  if (*t == '\0')
+  if (*t == '\0') {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -138,6 +149,7 @@ static int
 __iso_8859_1_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, -1, state);
 }
 
@@ -145,6 +157,7 @@ static int
 __iso_8859_2_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 0, state);
 }
 
@@ -152,6 +165,7 @@ static int
 __iso_8859_3_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 1, state);
 }
 
@@ -159,6 +173,7 @@ static int
 __iso_8859_4_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 2, state);
 }
 
@@ -166,6 +181,7 @@ static int
 __iso_8859_5_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 3, state);
 }
 
@@ -173,6 +189,7 @@ static int
 __iso_8859_6_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 4, state);
 }
 
@@ -180,6 +197,7 @@ static int
 __iso_8859_7_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 5, state);
 }
 
@@ -187,6 +205,7 @@ static int
 __iso_8859_8_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 6, state);
 }
 
@@ -194,6 +213,7 @@ static int
 __iso_8859_9_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		     mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 7, state);
 }
 
@@ -201,6 +221,7 @@ static int
 __iso_8859_10_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 8, state);
 }
 
@@ -208,6 +229,7 @@ static int
 __iso_8859_11_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 9, state);
 }
 
@@ -215,6 +237,7 @@ static int
 __iso_8859_13_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 10, state);
 }
 
@@ -222,6 +245,7 @@ static int
 __iso_8859_14_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 11, state);
 }
 
@@ -229,6 +253,7 @@ static int
 __iso_8859_15_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 12, state);
 }
 
@@ -236,6 +261,7 @@ static int
 __iso_8859_16_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		      mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_mbtowc (r, pwc, s, n, 13, state);
 }
 
@@ -264,6 +290,7 @@ static mbtowc_p __iso_8859_mbtowc[17] = {
 mbtowc_p
 __iso_mbtowc (int val)
 {
+  __A_VARIABLE = 1;
   return __iso_8859_mbtowc[val];
 }
 #endif /* _MB_EXTENDED_CHARSETS_ISO */
@@ -279,11 +306,15 @@ ___cp_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
   if (pwc == NULL)
     pwc = &dummy;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return -2;
+  }
 
   if (*t >= 0x80)
     {
@@ -293,17 +324,22 @@ ___cp_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 	  if (*pwc == 0) /* Invalid character */
 	    {
 	      r->_errno = EILSEQ;
+	      __A_VARIABLE = 1;
 	      return -1;
 	    }
+	  __A_VARIABLE = 1;
 	  return 1;
 	}
     }
 
   *pwc = (wchar_t)*t;
   
-  if (*t == '\0')
+  if (*t == '\0') {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -311,6 +347,7 @@ static int
 __cp_437_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 0, state);
 }
 
@@ -318,6 +355,7 @@ static int
 __cp_720_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 1, state);
 }
 
@@ -325,6 +363,7 @@ static int
 __cp_737_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 2, state);
 }
 
@@ -332,6 +371,7 @@ static int
 __cp_775_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 3, state);
 }
 
@@ -339,6 +379,7 @@ static int
 __cp_850_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 4, state);
 }
 
@@ -346,6 +387,7 @@ static int
 __cp_852_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 5, state);
 }
 
@@ -353,6 +395,7 @@ static int
 __cp_855_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 6, state);
 }
 
@@ -360,6 +403,7 @@ static int
 __cp_857_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 7, state);
 }
 
@@ -367,6 +411,7 @@ static int
 __cp_858_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 8, state);
 }
 
@@ -374,6 +419,7 @@ static int
 __cp_862_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 9, state);
 }
 
@@ -381,6 +427,7 @@ static int
 __cp_866_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 10, state);
 }
 
@@ -388,6 +435,7 @@ static int
 __cp_874_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 11, state);
 }
 
@@ -395,6 +443,7 @@ static int
 __cp_1125_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 12, state);
 }
 
@@ -402,6 +451,7 @@ static int
 __cp_1250_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 13, state);
 }
 
@@ -409,6 +459,7 @@ static int
 __cp_1251_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 14, state);
 }
 
@@ -416,6 +467,7 @@ static int
 __cp_1252_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 15, state);
 }
 
@@ -423,6 +475,7 @@ static int
 __cp_1253_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 16, state);
 }
 
@@ -430,6 +483,7 @@ static int
 __cp_1254_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 17, state);
 }
 
@@ -437,6 +491,7 @@ static int
 __cp_1255_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 18, state);
 }
 
@@ -444,6 +499,7 @@ static int
 __cp_1256_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 19, state);
 }
 
@@ -451,6 +507,7 @@ static int
 __cp_1257_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 20, state);
 }
 
@@ -458,6 +515,7 @@ static int
 __cp_1258_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 21, state);
 }
 
@@ -465,6 +523,7 @@ static int
 __cp_20866_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		   mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 22, state);
 }
 
@@ -472,6 +531,7 @@ static int
 __cp_21866_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		   mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 23, state);
 }
 
@@ -479,6 +539,7 @@ static int
 __cp_101_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 24, state);
 }
 
@@ -486,6 +547,7 @@ static int
 __cp_102_mbtowc (struct _reent *r, wchar_t *pwc, const char *s, size_t n,
 		 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_mbtowc (r, pwc, s, n, 25, state);
 }
 
@@ -523,6 +585,7 @@ static mbtowc_p __cp_xxx_mbtowc[26] = {
 mbtowc_p
 __cp_mbtowc (int val)
 {
+  __A_VARIABLE = 1;
   return __cp_xxx_mbtowc[__cp_val_index (val)];
 }
 #endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
@@ -543,11 +606,15 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
   if (pwc == NULL)
     pwc = &dummy;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return -2;
+  }
 
   if (state->__count == 0)
     ch = t[i++];
@@ -558,6 +625,7 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
     {
       *pwc = 0;
       state->__count = 0;
+      __A_VARIABLE = 1;
       return 0; /* s points to the null character */
     }
 
@@ -566,6 +634,7 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
       /* single-byte sequence */
       state->__count = 0;
       *pwc = ch;
+      __A_VARIABLE = 1;
       return 1;
     }
   if (ch >= 0xc0 && ch <= 0xdf)
@@ -576,23 +645,28 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	state->__count = 1;
       else if (n < (size_t)-1)
 	++n;
-      if (n < 2)
+      if (n < 2) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = t[i++];
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       if (state->__value.__wchb[0] < 0xc2)
 	{
 	  /* overlong UTF-8 sequence */
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       state->__count = 0;
       *pwc = (wchar_t)((state->__value.__wchb[0] & 0x1f) << 6)
 	|    (wchar_t)(ch & 0x3f);
+      __A_VARIABLE = 1;
       return i;
     }
   if (ch >= 0xe0 && ch <= 0xef)
@@ -604,18 +678,22 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	state->__count = 1;
       else if (n < (size_t)-1)
 	++n;
-      if (n < 2)
+      if (n < 2) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
       if (state->__value.__wchb[0] == 0xe0 && ch < 0xa0)
 	{
 	  /* overlong UTF-8 sequence */
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       state->__value.__wchb[1] = ch;
@@ -623,12 +701,15 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	state->__count = 2;
       else if (n < (size_t)-1)
 	++n;
-      if (n < 3)
+      if (n < 3) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = t[i++];
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       state->__count = 0;
@@ -636,6 +717,7 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	|    (wchar_t)((state->__value.__wchb[1] & 0x3f) << 6)
 	|     (wchar_t)(ch & 0x3f);
       *pwc = tmp;
+      __A_VARIABLE = 1;
       return i;
     }
   if (ch >= 0xf0 && ch <= 0xf4)
@@ -647,19 +729,23 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	state->__count = 1;
       else if (n < (size_t)-1)
 	++n;
-      if (n < 2)
+      if (n < 2) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = (state->__count == 1) ? t[i++] : state->__value.__wchb[1];
       if ((state->__value.__wchb[0] == 0xf0 && ch < 0x90)
 	  || (state->__value.__wchb[0] == 0xf4 && ch >= 0x90))
 	{
 	  /* overlong UTF-8 sequence or result is > 0x10ffff */
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       state->__value.__wchb[1] = ch;
@@ -667,12 +753,15 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	state->__count = 2;
       else if (n < (size_t)-1)
 	++n;
-      if (n < 3)
+      if (n < 3) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = (state->__count == 2) ? t[i++] : state->__value.__wchb[2];
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       state->__value.__wchb[2] = ch;
@@ -698,14 +787,18 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
 	    |   (wint_t)((state->__value.__wchb[2] & 0x3f) << 6);
 	  state->__count = 4;
 	  *pwc = 0xd800 | ((tmp - 0x10000) >> 10);
+	  __A_VARIABLE = 1;
 	  return i;
 	}
-      if (n < 4)
+      if (n < 4) {
+	__A_VARIABLE = 1;
 	return -2;
+      }
       ch = t[i++];
       if (ch < 0x80 || ch > 0xbf)
 	{
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
       tmp = (wint_t)((state->__value.__wchb[0] & 0x07) << 18)
@@ -719,10 +812,12 @@ _DEFUN (__utf8_mbtowc, (r, pwc, s, n, state),
       else
 	*pwc = tmp;
       state->__count = 0;
+      __A_VARIABLE = 1;
       return i;
     }
 
   r->_errno = EILSEQ;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -892,11 +987,14 @@ _DEFUN (__jis_mbtowc, (r, pwc, s, n, state),
   if (s == NULL)
     {
       state->__state = ASCII;
+      __A_VARIABLE = 1;
       return 1;  /* state-dependent */
     }
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return -2;
+  }
 
   curr_state = state->__state;
   ptr = t;
@@ -944,10 +1042,12 @@ _DEFUN (__jis_mbtowc, (r, pwc, s, n, state),
 	case EMPTY:
 	  state->__state = ASCII;
 	  *pwc = (wchar_t)0;
+	  __A_VARIABLE = 1;
 	  return 0;
 	case COPY_A:
 	  state->__state = ASCII;
 	  *pwc = (wchar_t)*ptr;
+	  __A_VARIABLE = 1;
 	  return (i + 1);
 	case COPY_J1:
 	  state->__value.__wchb[0] = t[i];
@@ -955,6 +1055,7 @@ _DEFUN (__jis_mbtowc, (r, pwc, s, n, state),
 	case COPY_J2:
 	  state->__state = JIS;
 	  *pwc = (((wchar_t)state->__value.__wchb[0]) << 8) + (wchar_t)(t[i]);
+	  __A_VARIABLE = 1;
 	  return (i + 1);
 	case MAKE_A:
 	  ptr = (unsigned char *)(t + i + 1);
@@ -962,12 +1063,14 @@ _DEFUN (__jis_mbtowc, (r, pwc, s, n, state),
 	case ERROR:
 	default:
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
 
     }
 
   state->__state = curr_state;
+  __A_VARIABLE = 1;
   return -2;  /* n < bytes needed */
 }
 #endif /* !__CYGWIN__*/
diff --git a/newlib/libc/stdlib/mlock.c b/newlib/libc/stdlib/mlock.c
index 4c39294..1816e26 100644
--- a/newlib/libc/stdlib/mlock.c
+++ b/newlib/libc/stdlib/mlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef MALLOC_PROVIDED
 /*
 FUNCTION
@@ -50,6 +51,7 @@ __malloc_lock (ptr)
 #ifndef __SINGLE_THREAD__
   __lock_acquire_recursive (__malloc_recursive_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
 
 void
@@ -59,6 +61,7 @@ __malloc_unlock (ptr)
 #ifndef __SINGLE_THREAD__
   __lock_release_recursive (__malloc_recursive_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdlib/mprec.c b/newlib/libc/stdlib/mprec.c
index 2b982ef..c0dc5de 100644
--- a/newlib/libc/stdlib/mprec.c
+++ b/newlib/libc/stdlib/mprec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
  *
  * The author of this software is David M. Gay.
@@ -141,6 +142,7 @@ _DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
       v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
       _REENT_MP_FREELIST(ptr)[v->_k] = v;
     }
+    __A_VARIABLE = 1;
 }
 
 _Bigint *
@@ -187,6 +189,7 @@ _DEFUN (multadd, (ptr, b, m, a),
       b->_x[wds++] = a;
       b->_wds = wds;
     }
+  __A_VARIABLE = 1;
   return b;
 }
 
@@ -227,6 +230,7 @@ _DEFUN (s2b, (ptr, s, nd0, nd, y9),
     s += 10;
   for (; i < nd; i++)
     b = multadd (ptr, b, 10, *s++ - '0');
+  __A_VARIABLE = 1;
   return b;
 }
 
@@ -259,9 +263,12 @@ _DEFUN (hi0bits,
   if (!(x & 0x80000000))
     {
       k++;
-      if (!(x & 0x40000000))
+      if (!(x & 0x40000000)) {
+	__A_VARIABLE = 1;
 	return 32;
+      }
     }
+  __A_VARIABLE = 1;
   return k;
 }
 
@@ -273,14 +280,18 @@ _DEFUN (lo0bits, (y), __ULong *y)
 
   if (x & 7)
     {
-      if (x & 1)
+      if (x & 1) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
       if (x & 2)
 	{
 	  *y = x >> 1;
+	  __A_VARIABLE = 1;
 	  return 1;
 	}
       *y = x >> 2;
+      __A_VARIABLE = 1;
       return 2;
     }
   k = 0;
@@ -308,10 +319,13 @@ _DEFUN (lo0bits, (y), __ULong *y)
     {
       k++;
       x >>= 1;
-      if (!x & 1)
+      if (!x & 1) {
+	__A_VARIABLE = 1;
 	return 32;
+      }
     }
   *y = x;
+  __A_VARIABLE = 1;
   return k;
 }
 
@@ -323,6 +337,7 @@ _DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
   b = Balloc (ptr, 1);
   b->_x[0] = i;
   b->_wds = 1;
+  __A_VARIABLE = 1;
   return b;
 }
 
@@ -415,6 +430,7 @@ _DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b
 #endif
   for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   c->_wds = wc;
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -429,8 +445,10 @@ _DEFUN (pow5mult,
   if ((i = k & 3) != 0)
     b = multadd (ptr, b, p05[i - 1], 0);
 
-  if (!(k >>= 2))
+  if (!(k >>= 2)) {
+    __A_VARIABLE = 1;
     return b;
+  }
   _REENT_CHECK_MP(ptr);
   if (!(p5 = _REENT_MP_P5S(ptr)))
     {
@@ -455,6 +473,7 @@ _DEFUN (pow5mult,
 	}
       p5 = p51;
     }
+  __A_VARIABLE = 1;
   return b;
 }
 
@@ -515,6 +534,7 @@ _DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
     while (x < xe);
   b1->_wds = n1 - 1;
   Bfree (ptr, b);
+  __A_VARIABLE = 1;
   return b1;
 }
 
@@ -532,19 +552,24 @@ _DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
   if (j > 1 && !b->_x[j - 1])
     Bug ("cmp called with b->_x[b->_wds-1] == 0");
 #endif
-  if (i -= j)
+  if (i -= j) {
+    __A_VARIABLE = 1;
     return i;
+  }
   xa0 = a->_x;
   xa = xa0 + j;
   xb0 = b->_x;
   xb = xb0 + j;
   for (;;)
     {
-      if (*--xa != *--xb)
+      if (*--xa != *--xb) {
+	__A_VARIABLE = 1;
 	return *xa < *xb ? -1 : 1;
+      }
       if (xa <= xa0)
 	break;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -566,6 +591,7 @@ _DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
       c = Balloc (ptr, 0);
       c->_wds = 1;
       c->_x[0] = 0;
+      __A_VARIABLE = 1;
       return c;
     }
   if (i < 0)
@@ -629,6 +655,7 @@ _DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
   while (!*--xc)
     wa--;
   c->_wds = wa;
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -675,6 +702,7 @@ _DEFUN (ulp, (_x), double _x)
 	}
     }
 #endif
+  __A_VARIABLE = 1;
   return a.d;
 }
 
@@ -752,6 +780,7 @@ ret_d:
 #undef d0
 #undef d1
 #endif
+  __A_VARIABLE = 1;
   return d.d;
 }
 
@@ -905,6 +934,7 @@ _DEFUN (d2b,
 #endif
     }
 #endif
+  __A_VARIABLE = 1;
   return b;
 }
 #undef d0
@@ -947,6 +977,7 @@ _DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)
       word0 (db) += k * Exp_msk1;
     }
 #endif
+  __A_VARIABLE = 1;
   return da.d / db.d;
 }
 
@@ -980,13 +1011,16 @@ _DEFUN (_mprec_log10, (dig),
 	int dig)
 {
   double v = 1.0;
-  if (dig < 24)
+  if (dig < 24) {
+    __A_VARIABLE = 1;
     return tens[dig];
+  }
   while (dig > 0)
     {
       v *= 10;
       dig--;
     }
+  __A_VARIABLE = 1;
   return v;
 }
 
@@ -1017,6 +1051,7 @@ _DEFUN (copybits, (c, n, b),
 #endif
 	while(c < ce)
 		*c++ = 0;
+	__A_VARIABLE = 1;
 }
 
 __ULong
diff --git a/newlib/libc/stdlib/mrand48.c b/newlib/libc/stdlib/mrand48.c
index 28f4f7d..9470052 100644
--- a/newlib/libc/stdlib/mrand48.c
+++ b/newlib/libc/stdlib/mrand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -19,6 +20,7 @@ _DEFUN (_mrand48_r, (r),
 {
   _REENT_CHECK_RAND48(r);
   __dorand48(r, __rand48_seed);
+  __A_VARIABLE = 1;
   return ((long) __rand48_seed[2] << 16) + (long) __rand48_seed[1];
 }
 
@@ -26,6 +28,7 @@ _DEFUN (_mrand48_r, (r),
 long
 _DEFUN_VOID (mrand48)
 {
+  __A_VARIABLE = 1;
   return _mrand48_r (_REENT);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/msize.c b/newlib/libc/stdlib/msize.c
index e33e4aa..f04378c 100644
--- a/newlib/libc/stdlib/msize.c
+++ b/newlib/libc/stdlib/msize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef MALLOC_PROVIDED
 /* msize.c -- a wrapper for malloc_usable_size.  */
 
@@ -12,6 +13,7 @@ size_t
 _DEFUN (malloc_usable_size, (ptr),
 	_PTR ptr)
 {
+  __A_VARIABLE = 1;
   return _malloc_usable_size_r (_REENT, ptr);
 }
 
diff --git a/newlib/libc/stdlib/mstats.c b/newlib/libc/stdlib/mstats.c
index ba89f49..17c80d0 100644
--- a/newlib/libc/stdlib/mstats.c
+++ b/newlib/libc/stdlib/mstats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* VxWorks provides its own version of malloc, and we can't use this
    one because VxWorks does not provide sbrk.  So we have a hook to
    not compile this code.  */
@@ -107,6 +108,7 @@ not portable.
 struct mallinfo
 _DEFUN_VOID (mallinfo)
 {
+  __A_VARIABLE = 1;
   return _mallinfo_r (_REENT);
 }
 
@@ -115,6 +117,7 @@ void
 _DEFUN_VOID (malloc_stats)
 {
   _malloc_stats_r (_REENT);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -122,6 +125,7 @@ _DEFUN (mallopt, (p, v),
 	int p _AND
 	int v)
 {
+  __A_VARIABLE = 1;
   return _mallopt_r (_REENT, p, v);
 }
 
@@ -143,6 +147,7 @@ _DEFUN (_mstats_r, (ptr, s),
   _REENT_SMALL_CHECK_INIT(ptr);
   fiprintf (_stderr_r (ptr), "Memory allocation statistics %s\n", s);
   _malloc_stats_r (ptr);
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -151,6 +156,7 @@ _DEFUN (mstats, (s),
 	char *s)
 {
   _mstats_r (_REENT, s);
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/stdlib/mtrim.c b/newlib/libc/stdlib/mtrim.c
index 328eb71..ca130de 100644
--- a/newlib/libc/stdlib/mtrim.c
+++ b/newlib/libc/stdlib/mtrim.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef MALLOC_PROVIDED
 /* mtrim.c -- a wrapper for malloc_trim.  */
 
@@ -12,6 +13,7 @@ int
 _DEFUN (malloc_trim, (pad),
 	size_t pad)
 {
+  __A_VARIABLE = 1;
   return _malloc_trim_r (_REENT, pad);
 }
 
diff --git a/newlib/libc/stdlib/nano-mallocr.c b/newlib/libc/stdlib/nano-mallocr.c
index a0accdd..2a4154b 100644
--- a/newlib/libc/stdlib/nano-mallocr.c
+++ b/newlib/libc/stdlib/nano-mallocr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2012, 2013 ARM Ltd
  * All rights reserved.
@@ -200,6 +201,7 @@ static inline chunk * get_chunk_from_ptr(void * ptr)
        the chunk. In which case, c->size is currently the negative offset to
        the true size.  */
     if (c->size < 0) c = (chunk *)((char *)c + c->size);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -225,8 +227,10 @@ static void* sbrk_aligned(RARG malloc_size_t s)
     p = _SBRK_R(RCALL s);
 
     /* sbrk returns -1 if fail to allocate */
-    if (p == (void *)-1)
+    if (p == (void *)-1) {
+        __A_VARIABLE = 1;
         return p;
+    }
 
     align_p = (char*)ALIGN_TO((unsigned long)p, CHUNK_ALIGN);
     if (align_p != p)
@@ -234,9 +238,12 @@ static void* sbrk_aligned(RARG malloc_size_t s)
         /* p is not aligned, ask for a few more bytes so that we have s
          * bytes reserved from align_p. */
         p = _SBRK_R(RCALL align_p - p);
-        if (p == (void *)-1)
+        if (p == (void *)-1) {
+            __A_VARIABLE = 1;
             return p;
+        }
     }
+    __A_VARIABLE = 1;
     return align_p;
 }
 
@@ -261,6 +268,7 @@ void * nano_malloc(RARG malloc_size_t s)
     if (alloc_size >= MAX_ALLOC_SIZE || alloc_size < s)
     {
         RERRNO = ENOMEM;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -311,6 +319,7 @@ void * nano_malloc(RARG malloc_size_t s)
         {
             RERRNO = ENOMEM;
             MALLOC_UNLOCK;
+            __A_VARIABLE = 1;
             return NULL;
         }
         r->size = alloc_size;
@@ -341,6 +350,7 @@ void * nano_malloc(RARG malloc_size_t s)
     }
 
     assert(align_ptr + size <= (char *)r + alloc_size);
+    __A_VARIABLE = 1;
     return align_ptr;
 }
 #endif /* DEFINE_MALLOC */
@@ -451,6 +461,7 @@ void nano_free (RARG void * free_p)
 void nano_cfree(RARG void * ptr)
 {
     nano_free(RCALL ptr);
+    __A_VARIABLE = 1;
 }
 #endif /* DEFINE_CFREE */
 
@@ -461,6 +472,7 @@ void * nano_calloc(RARG malloc_size_t n, malloc_size_t elem)
 {
     void * mem = nano_malloc(RCALL n * elem);
     if (mem != NULL) memset(mem, 0, n * elem);
+    __A_VARIABLE = 1;
     return mem;
 }
 #endif /* DEFINE_CALLOC */
@@ -473,18 +485,24 @@ void * nano_realloc(RARG void * ptr, malloc_size_t size)
     void * mem;
     chunk * p_to_realloc;
 
-    if (ptr == NULL) return nano_malloc(RCALL size);
+    if (ptr == NULL) {
+        __A_VARIABLE = 1;
+        return nano_malloc(RCALL size);
+    }
 
     if (size == 0)
     {
         nano_free(RCALL ptr);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     /* TODO: There is chance to shrink the chunk if newly requested
      * size is much small */
-    if (nano_malloc_usable_size(RCALL ptr) >= size)
+    if (nano_malloc_usable_size(RCALL ptr) >= size) {
+      __A_VARIABLE = 1;
       return ptr;
+    }
 
     mem = nano_malloc(RCALL size);
     if (mem != NULL)
@@ -492,6 +510,7 @@ void * nano_realloc(RARG void * ptr, malloc_size_t size)
         memcpy(mem, ptr, size);
         nano_free(RCALL ptr);
     }
+    __A_VARIABLE = 1;
     return mem;
 }
 #endif /* DEFINE_REALLOC */
@@ -526,6 +545,7 @@ struct mallinfo nano_mallinfo(RONEARG)
     current_mallinfo.uordblks = total_size - free_size;
 
     MALLOC_UNLOCK;
+    __A_VARIABLE = 1;
     return current_mallinfo;
 }
 #endif /* DEFINE_MALLINFO */
@@ -540,6 +560,7 @@ void nano_malloc_stats(RONEARG)
              current_mallinfo.arena);
     fiprintf(stderr, "in use bytes     = %10u\n",
              current_mallinfo.uordblks);
+    __A_VARIABLE = 1;
 }
 #endif /* DEFINE_MALLOC_STATS */
 
@@ -553,8 +574,10 @@ malloc_size_t nano_malloc_usable_size(RARG void * ptr)
     {
         /* Padding is used. Excluding the padding size */
         c = (chunk *)((char *)c + c->size);
+        __A_VARIABLE = 1;
         return c->size - CHUNK_OFFSET + size_or_offset;
     }
+    __A_VARIABLE = 1;
     return c->size - CHUNK_OFFSET;
 }
 #endif /* DEFINE_MALLOC_USABLE_SIZE */
@@ -579,14 +602,20 @@ void * nano_memalign(RARG size_t align, size_t s)
     char * allocated, * aligned_p;
 
     /* Return NULL if align isn't power of 2 */
-    if ((align & (align-1)) != 0) return NULL;
+    if ((align & (align-1)) != 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     align = MAX(align, MALLOC_ALIGN);
     ma_size = ALIGN_TO(MAX(s, MALLOC_MINSIZE), CHUNK_ALIGN);
     size_with_padding = ma_size + align - MALLOC_ALIGN;
 
     allocated = nano_malloc(RCALL size_with_padding);
-    if (allocated == NULL) return NULL;
+    if (allocated == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     chunk_p = get_chunk_from_ptr(allocated);
     aligned_p = (char *)ALIGN_TO(
@@ -625,6 +654,7 @@ void * nano_memalign(RARG size_t align, size_t s)
         tail_chunk->size = size_allocated - chunk_p->size;
         nano_free(RCALL (char *)tail_chunk + CHUNK_OFFSET);
     }
+    __A_VARIABLE = 1;
     return aligned_p;
 }
 #endif /* DEFINE_MEMALIGN */
@@ -632,6 +662,7 @@ void * nano_memalign(RARG size_t align, size_t s)
 #ifdef DEFINE_MALLOPT
 int nano_mallopt(RARG int parameter_number, int parameter_value)
 {
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif /* DEFINE_MALLOPT */
@@ -639,6 +670,7 @@ int nano_mallopt(RARG int parameter_number, int parameter_value)
 #ifdef DEFINE_VALLOC
 void * nano_valloc(RARG size_t s)
 {
+    __A_VARIABLE = 1;
     return nano_memalign(RCALL MALLOC_PAGE_ALIGN, s);
 }
 #endif /* DEFINE_VALLOC */
@@ -646,6 +678,7 @@ void * nano_valloc(RARG size_t s)
 #ifdef DEFINE_PVALLOC
 void * nano_pvalloc(RARG size_t s)
 {
+    __A_VARIABLE = 1;
     return nano_valloc(RCALL ALIGN_TO(s, MALLOC_PAGE_ALIGN));
 }
 #endif /* DEFINE_PVALLOC */
diff --git a/newlib/libc/stdlib/nrand48.c b/newlib/libc/stdlib/nrand48.c
index 39e9fb1..190b996 100644
--- a/newlib/libc/stdlib/nrand48.c
+++ b/newlib/libc/stdlib/nrand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -19,6 +20,7 @@ _DEFUN (_nrand48_r, (r, xseed),
        unsigned short xseed[3])
 {
   __dorand48 (r, xseed);
+  __A_VARIABLE = 1;
   return (long)((unsigned long) xseed[2] << 15) +
     ((unsigned long) xseed[1] >> 1);
 }
@@ -28,6 +30,7 @@ long
 _DEFUN (nrand48, (xseed),
        unsigned short xseed[3])
 {
+  __A_VARIABLE = 1;
   return _nrand48_r (_REENT, xseed);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/on_exit.c b/newlib/libc/stdlib/on_exit.c
index a405b1b..e6a2901 100644
--- a/newlib/libc/stdlib/on_exit.c
+++ b/newlib/libc/stdlib/on_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1990 Regents of the University of California.
  * All rights reserved.
@@ -77,5 +78,6 @@ _DEFUN (on_exit,
 	_VOID _EXFNPTR(fn, (int, _PTR)) _AND
         _PTR arg)
 {
+  __A_VARIABLE = 1;
   return __register_exitproc (__et_onexit, (void (*)(void)) fn, arg, NULL);
 }
diff --git a/newlib/libc/stdlib/on_exit_args.c b/newlib/libc/stdlib/on_exit_args.c
index 88f9ffd..aa559c1 100644
--- a/newlib/libc/stdlib/on_exit_args.c
+++ b/newlib/libc/stdlib/on_exit_args.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Static instance of _on_exit_args struct.
  *
diff --git a/newlib/libc/stdlib/putenv.c b/newlib/libc/stdlib/putenv.c
index 978f7c5..b10d2cc 100644
--- a/newlib/libc/stdlib/putenv.c
+++ b/newlib/libc/stdlib/putenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1988 The Regents of the University of California.
  * All rights reserved.
@@ -26,6 +27,7 @@ int
 _DEFUN (putenv, (str),
 	char *str)
 {
+  __A_VARIABLE = 1;
   return _putenv_r (_REENT, str);
 }
 
diff --git a/newlib/libc/stdlib/putenv_r.c b/newlib/libc/stdlib/putenv_r.c
index a0f4767..314e4c6 100644
--- a/newlib/libc/stdlib/putenv_r.c
+++ b/newlib/libc/stdlib/putenv_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This file may have been modified by DJ Delorie (Jan 1991).  If so,
 ** these modifications are Copyright (C) 1991 DJ Delorie.
 */
@@ -40,12 +41,15 @@ _DEFUN (_putenv_r, (reent_ptr, str),
 
   p = _strdup_r (reent_ptr, str);
 
-  if (!p)
+  if (!p) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   if (!(equal = strchr (p, '=')))
     {
       (void) _free_r (reent_ptr, p);
+      __A_VARIABLE = 1;
       return 1;
     }
 
@@ -53,5 +57,6 @@ _DEFUN (_putenv_r, (reent_ptr, str),
   rval = _setenv_r (reent_ptr, p, equal + 1, 1);
   (void) _free_r (reent_ptr, p);
 
+  __A_VARIABLE = 1;
   return rval;
 }
diff --git a/newlib/libc/stdlib/quick_exit.c b/newlib/libc/stdlib/quick_exit.c
index 5ab2609..65f6bde 100644
--- a/newlib/libc/stdlib/quick_exit.c
+++ b/newlib/libc/stdlib/quick_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2011 David Chisnall
  * Copyright (c) 2015 embedded brains GmbH
@@ -59,8 +60,10 @@ at_quick_exit(void (*func)(void))
 
 	h = malloc(sizeof(*h));
 
-	if (NULL == h)
+	if (NULL == h) {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 	h->cleanup = func;
 #ifndef __SINGLE_THREAD__
 	__lock_acquire(__at_quick_exit_mutex);
@@ -70,6 +73,7 @@ at_quick_exit(void (*func)(void))
 #ifndef __SINGLE_THREAD__
 	__lock_release(__at_quick_exit_mutex);
 #endif
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -85,4 +89,5 @@ quick_exit(int status)
 	for (h = handlers; NULL != h; h = h->next)
 		h->cleanup();
 	_exit(status);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/rand.c b/newlib/libc/stdlib/rand.c
index 42acde4..fc95e28 100644
--- a/newlib/libc/stdlib/rand.c
+++ b/newlib/libc/stdlib/rand.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<rand>>, <<srand>>---pseudo-random numbers
@@ -76,6 +77,7 @@ _DEFUN (srand, (seed), unsigned int seed)
 
   _REENT_CHECK_RAND48(reent);
   _REENT_RAND_NEXT(reent) = seed;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -89,6 +91,7 @@ _DEFUN_VOID (rand)
   _REENT_CHECK_RAND48(reent);
   _REENT_RAND_NEXT(reent) =
      _REENT_RAND_NEXT(reent) * __extension__ 6364136223846793005LL + 1;
+  __A_VARIABLE = 1;
   return (int)((_REENT_RAND_NEXT(reent) >> 32) & RAND_MAX);
 }
 
diff --git a/newlib/libc/stdlib/rand48.c b/newlib/libc/stdlib/rand48.c
index af2be3c..481ccaa 100644
--- a/newlib/libc/stdlib/rand48.c
+++ b/newlib/libc/stdlib/rand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -176,4 +177,5 @@ _DEFUN (__dorand48, (r, xseed),
   xseed[0] = temp[0];
   xseed[1] = temp[1];
   xseed[2] = (unsigned short) accu;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/stdlib/rand_r.c b/newlib/libc/stdlib/rand_r.c
index 437739e..30d0d96 100644
--- a/newlib/libc/stdlib/rand_r.c
+++ b/newlib/libc/stdlib/rand_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 /* Pseudo-random generator based on Minimal Standard by
@@ -33,5 +34,6 @@ _DEFUN (rand_r, (seed), unsigned int *seed)
         if (s < 0)
           s += 2147483647;
         (*seed) = (unsigned int)s;
+        __A_VARIABLE = 1;
         return (int)(s & RAND_MAX);
 }
diff --git a/newlib/libc/stdlib/random.c b/newlib/libc/stdlib/random.c
index de132f3..2fffb8a 100644
--- a/newlib/libc/stdlib/random.c
+++ b/newlib/libc/stdlib/random.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<random>>, <<srandom>>---pseudo-random numbers
@@ -63,6 +64,7 @@ _DEFUN (srandom, (seed), unsigned int seed)
 
   _REENT_CHECK_RAND48(reent);
   _REENT_RAND_NEXT(reent) = seed;
+  __A_VARIABLE = 1;
 }
 
 long int
@@ -76,6 +78,7 @@ _DEFUN_VOID (random)
   _REENT_CHECK_RAND48(reent);
   _REENT_RAND_NEXT(reent) =
      _REENT_RAND_NEXT(reent) * __extension__ 6364136223846793005LL + 1;
+  __A_VARIABLE = 1;
   return (long int)((_REENT_RAND_NEXT(reent) >> 32) & RAND_MAX);
 }
 
diff --git a/newlib/libc/stdlib/realloc.c b/newlib/libc/stdlib/realloc.c
index 2caa6e4..fab76c3 100644
--- a/newlib/libc/stdlib/realloc.c
+++ b/newlib/libc/stdlib/realloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifdef MALLOC_PROVIDED
 int _dummy_calloc = 1;
 #else
@@ -15,6 +16,7 @@ _DEFUN (realloc, (ap, nbytes),
 	_PTR ap _AND
 	size_t nbytes)
 {
+  __A_VARIABLE = 1;
   return _realloc_r (_REENT, ap, nbytes);
 }
 
diff --git a/newlib/libc/stdlib/reallocarray.c b/newlib/libc/stdlib/reallocarray.c
index 4b6cccb..d9234c8 100644
--- a/newlib/libc/stdlib/reallocarray.c
+++ b/newlib/libc/stdlib/reallocarray.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: reallocarray.c,v 1.2 2014/12/08 03:45:00 bcook Exp $	*/
 /*
  * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>
@@ -36,7 +37,9 @@ reallocarray(void *optr, size_t nmemb, size_t size)
 	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
 	    nmemb > 0 && SIZE_MAX / nmemb < size) {
 		errno = ENOMEM;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
+	__A_VARIABLE = 1;
 	return (realloc(optr, size * nmemb));
 }
diff --git a/newlib/libc/stdlib/reallocf.c b/newlib/libc/stdlib/reallocf.c
index a9d3293..2627880 100644
--- a/newlib/libc/stdlib/reallocf.c
+++ b/newlib/libc/stdlib/reallocf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1998, M. Warner Losh <imp@freebsd.org>
  * All rights reserved.
@@ -41,6 +42,7 @@ _DEFUN (_reallocf_r, (reentptr, ptr, size),
 	nptr = _realloc_r(reentptr, ptr, size);
 	if (!nptr && ptr)
 		_free_r(reentptr, ptr);
+	__A_VARIABLE = 1;
 	return (nptr);
 }
 
@@ -50,6 +52,7 @@ _DEFUN (reallocf, (ptr, size),
 	_PTR ptr _AND
 	size_t size)
 {
+  __A_VARIABLE = 1;
   return _reallocf_r(_REENT, ptr, size);
 }
 #endif
diff --git a/newlib/libc/stdlib/rpmatch.c b/newlib/libc/stdlib/rpmatch.c
index 0bbdf43..1b5dc3b 100644
--- a/newlib/libc/stdlib/rpmatch.c
+++ b/newlib/libc/stdlib/rpmatch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<rpmatch>>---determine whether response to question is affirmative or negative
@@ -70,10 +71,13 @@ _DEFUN(rpmatch, (response),
 	regex_t yes, no;
 	int ret;
 
-	if (regcomp(&yes, nl_langinfo(YESEXPR), REG_EXTENDED|REG_NOSUB) != 0)
+	if (regcomp(&yes, nl_langinfo(YESEXPR), REG_EXTENDED|REG_NOSUB) != 0) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	if (regcomp(&no, nl_langinfo(NOEXPR), REG_EXTENDED|REG_NOSUB) != 0) {
 		regfree(&yes);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	if (regexec(&yes, response, 0, NULL, 0) == 0)
@@ -84,5 +88,6 @@ _DEFUN(rpmatch, (response),
 		ret = -1;
 	regfree(&yes);
 	regfree(&no);
+	__A_VARIABLE = 1;
 	return (ret);
 }
diff --git a/newlib/libc/stdlib/sb_charsets.c b/newlib/libc/stdlib/sb_charsets.c
index 961eb15..ea16a72 100644
--- a/newlib/libc/stdlib/sb_charsets.c
+++ b/newlib/libc/stdlib/sb_charsets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 #include <wchar.h>
 
@@ -659,14 +660,19 @@ __micro_atoi (const char *s)
 {
   int ret = 0;
 
-  if (!*s)
+  if (!*s) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   while (*s)
     {
-      if (*s < '0' || *s > '9' || ret >= 100000)
+      if (*s < '0' || *s > '9' || ret >= 100000) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       ret = 10 * ret + (*s++ - '0');
     }
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -679,14 +685,17 @@ __iso_8859_val_index (int val)
       val -= 2;
       if (val > 10)
 	--val;
+      __A_VARIABLE = 1;
       return (int) val;
     }
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 __iso_8859_index (const char *charset_ext)
 {
+  __A_VARIABLE = 1;
   return __iso_8859_val_index (__micro_atoi (charset_ext));
 }
 #endif /* _MB_EXTENDED_CHARSETS_ISO */
@@ -780,12 +789,14 @@ __cp_val_index (int val)
       cp_idx = -1;
       break;
     }
+  __A_VARIABLE = 1;
   return cp_idx;
 }
 
 int
 __cp_index (const char *charset_ext)
 {
+  __A_VARIABLE = 1;
   return __cp_val_index (__micro_atoi (charset_ext));
 }
 
diff --git a/newlib/libc/stdlib/seed48.c b/newlib/libc/stdlib/seed48.c
index 43629cc..5b868d0 100644
--- a/newlib/libc/stdlib/seed48.c
+++ b/newlib/libc/stdlib/seed48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -31,6 +32,7 @@ _DEFUN (_seed48_r, (r, xseed),
   __rand48_mult[1] = _RAND48_MULT_1;
   __rand48_mult[2] = _RAND48_MULT_2;
   __rand48_add = _RAND48_ADD;
+  __A_VARIABLE = 1;
   return sseed;
 }
 
@@ -39,6 +41,7 @@ unsigned short *
 _DEFUN (seed48, (xseed),
        unsigned short xseed[3])
 {
+  __A_VARIABLE = 1;
   return _seed48_r (_REENT, xseed);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/setenv.c b/newlib/libc/stdlib/setenv.c
index d423678..cb4fd4b 100644
--- a/newlib/libc/stdlib/setenv.c
+++ b/newlib/libc/stdlib/setenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1987 Regents of the University of California.
  * All rights reserved.
@@ -37,6 +38,7 @@ _DEFUN (setenv, (name, value, rewrite),
 	_CONST char *value _AND
 	int rewrite)
 {
+  __A_VARIABLE = 1;
   return _setenv_r (_REENT, name, value, rewrite);
 }
 
@@ -48,6 +50,7 @@ int
 _DEFUN (unsetenv, (name),
         _CONST char *name)
 {
+  __A_VARIABLE = 1;
   return _unsetenv_r (_REENT, name);
 }
 
diff --git a/newlib/libc/stdlib/setenv_r.c b/newlib/libc/stdlib/setenv_r.c
index c32c6ac..f10fae1 100644
--- a/newlib/libc/stdlib/setenv_r.c
+++ b/newlib/libc/stdlib/setenv_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This file may have been modified by DJ Delorie (Jan 1991).  If so,
 ** these modifications are Copyright (C) 1991 DJ Delorie.
 */
@@ -144,6 +145,7 @@ _DEFUN (_unsetenv_r, (reent_ptr, name),
   if (name == NULL || name[0] == '\0' || strchr(name, '='))
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -157,5 +159,6 @@ _DEFUN (_unsetenv_r, (reent_ptr, name),
     }
 
   ENV_UNLOCK;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/stdlib/srand48.c b/newlib/libc/stdlib/srand48.c
index 69bdbfc..775b9a0 100644
--- a/newlib/libc/stdlib/srand48.c
+++ b/newlib/libc/stdlib/srand48.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1993 Martin Birgmeier
  * All rights reserved.
@@ -26,6 +27,7 @@ _DEFUN (_srand48_r, (r, seed),
   __rand48_mult[1] = _RAND48_MULT_1;
   __rand48_mult[2] = _RAND48_MULT_2;
   __rand48_add = _RAND48_ADD;
+  __A_VARIABLE = 1;
 }
 
 #ifndef _REENT_ONLY
@@ -34,5 +36,6 @@ _DEFUN (srand48, (seed),
        long seed)
 {
   _srand48_r (_REENT, seed);
+  __A_VARIABLE = 1;
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/strtod.c b/newlib/libc/stdlib/strtod.c
index 82e847c..40c0d68 100644
--- a/newlib/libc/stdlib/strtod.c
+++ b/newlib/libc/stdlib/strtod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<strtod>>, <<strtof>>, <<strtold>>, <<strtod_l>>, <<strtof_l>>, <<strtold_l>>---string to double or float
@@ -198,12 +199,15 @@ _DEFUN (sulp, (x, scale),
         int i;
 
         rv = ulp(dval(x));
-        if (!scale || (i = 2*P + 1 - ((dword0(x) & Exp_mask) >> Exp_shift)) <= 0)
-                return rv; /* Is there an example where i <= 0 ? */
+        if (!scale || (i = 2*P + 1 - ((dword0(x) & Exp_mask) >> Exp_shift)) <= 0) {
+                __A_VARIABLE = 1;
+                return rv;
+        } /* Is there an example where i <= 0 ? */
         dword0(u) = Exp_1 + ((__int32_t)i << Exp_shift);
 #ifndef _DOUBLE_IS_32BITS
         dword1(u) = 0;
 #endif
+        __A_VARIABLE = 1;
         return rv * u.d;
         }
 #endif /*}*/
@@ -246,6 +250,7 @@ _DEFUN (ULtod, (L, bits, exp, k),
 	  }
 	if (k & STRTOG_Neg)
 		L[_0] |= 0x80000000L;
+	__A_VARIABLE = 1;
 }
 #endif /* !NO_HEX_FP */
 
@@ -1272,6 +1277,7 @@ _DEFUN (_strtod_r, (ptr, s00, se),
 	_CONST char *__restrict s00 _AND
 	char **__restrict se)
 {
+  __A_VARIABLE = 1;
   return _strtod_l (ptr, s00, se, __get_current_locale ());
 }
 
@@ -1280,6 +1286,7 @@ _DEFUN (_strtod_r, (ptr, s00, se),
 double
 strtod_l (const char *__restrict s00, char **__restrict se, locale_t loc)
 {
+  __A_VARIABLE = 1;
   return _strtod_l (_REENT, s00, se, loc);
 }
 
@@ -1287,6 +1294,7 @@ double
 _DEFUN (strtod, (s00, se),
 	_CONST char *__restrict s00 _AND char **__restrict se)
 {
+  __A_VARIABLE = 1;
   return _strtod_l (_REENT, s00, se, __get_current_locale ());
 }
 
@@ -1294,13 +1302,16 @@ float
 strtof_l (const char *__restrict s00, char **__restrict se, locale_t loc)
 {
   double val = _strtod_l (_REENT, s00, se, loc);
-  if (isnan (val))
+  if (isnan (val)) {
+    __A_VARIABLE = 1;
     return nanf (NULL);
+  }
   float retval = (float) val;
 #ifndef NO_ERRNO
   if (isinf (retval) && !isinf (val))
     _REENT->_errno = ERANGE;
 #endif
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -1310,13 +1321,16 @@ _DEFUN (strtof, (s00, se),
 	char **__restrict se)
 {
   double val = _strtod_l (_REENT, s00, se, __get_current_locale ());
-  if (isnan (val))
+  if (isnan (val)) {
+    __A_VARIABLE = 1;
     return nanf (NULL);
+  }
   float retval = (float) val;
 #ifndef NO_ERRNO
   if (isinf (retval) && !isinf (val))
     _REENT->_errno = ERANGE;
 #endif
+  __A_VARIABLE = 1;
   return retval;
 }
 
diff --git a/newlib/libc/stdlib/strtodg.c b/newlib/libc/stdlib/strtodg.c
index d8546c3..e6328e6 100644
--- a/newlib/libc/stdlib/strtodg.c
+++ b/newlib/libc/stdlib/strtodg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
 
 The author of this software is David M. Gay.
diff --git a/newlib/libc/stdlib/strtoimax.c b/newlib/libc/stdlib/strtoimax.c
index b0efa3e..be98c1d 100644
--- a/newlib/libc/stdlib/strtoimax.c
+++ b/newlib/libc/stdlib/strtoimax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -141,6 +142,7 @@ noconv:
 		acc = -acc;
 	if (endptr != NULL)
 		*endptr = (char *)(any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -148,6 +150,7 @@ intmax_t
 _strtoimax_r(struct _reent *rptr, const char *__restrict nptr,
 	     char **__restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoimax_l(rptr, nptr, endptr, base, __get_current_locale());
 }
 
@@ -157,12 +160,14 @@ intmax_t
 strtoimax_l(const char * __restrict nptr, char ** __restrict endptr, int base,
 	    locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtoimax_l(_REENT, nptr, endptr, base, loc);
 }
 
 intmax_t
 strtoimax(const char* __restrict nptr, char** __restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoimax_l(_REENT, nptr, endptr, base, __get_current_locale());
 }
 
diff --git a/newlib/libc/stdlib/strtol.c b/newlib/libc/stdlib/strtol.c
index 276ad13..264656a 100644
--- a/newlib/libc/stdlib/strtol.c
+++ b/newlib/libc/stdlib/strtol.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<strtol>>, <<strtol_l>>---string to long
@@ -221,6 +222,7 @@ _strtol_l (struct _reent *rptr, const char *__restrict nptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (char *) (any ? (char *)s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -231,6 +233,7 @@ _DEFUN (_strtol_r, (rptr, nptr, endptr, base),
 	char **__restrict endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtol_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -240,6 +243,7 @@ long
 strtol_l (const char *__restrict s, char **__restrict ptr, int base,
 	  locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtol_l (_REENT, s, ptr, base, loc);
 }
 
@@ -249,6 +253,7 @@ _DEFUN (strtol, (s, ptr, base),
 	char **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtol_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/strtold.c b/newlib/libc/stdlib/strtold.c
index 6bd1c2c..7b83946 100644
--- a/newlib/libc/stdlib/strtold.c
+++ b/newlib/libc/stdlib/strtold.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -51,6 +52,7 @@ __flt_rounds(void)
 
         /* Assume that the x87 and the SSE unit agree on the rounding mode. */
         __asm("fnstcw %0" : "=m" (x));
+        __A_VARIABLE = 1;
         return (map[(x >> 10) & 0x03]);
 }
 #define FLT_ROUNDS __flt_rounds()
diff --git a/newlib/libc/stdlib/strtoll.c b/newlib/libc/stdlib/strtoll.c
index e61a62a..dca72de 100644
--- a/newlib/libc/stdlib/strtoll.c
+++ b/newlib/libc/stdlib/strtoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<strtoll>>, <<strtoll_l>>---string to long long
@@ -223,6 +224,7 @@ _strtoll_l (struct _reent *rptr, _CONST char *__restrict nptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (char *) (any ? (char *)s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -233,6 +235,7 @@ _DEFUN (_strtoll_r, (rptr, nptr, endptr, base),
 	char **__restrict endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoll_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -242,6 +245,7 @@ long long
 strtoll_l (const char *__restrict s, char **__restrict ptr, int base,
 	   locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtoll_l (_REENT, s, ptr, base, loc);
 }
 
@@ -251,6 +255,7 @@ _DEFUN (strtoll, (s, ptr, base),
 	char **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoll_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/strtoll_r.c b/newlib/libc/stdlib/strtoll_r.c
index 2997587..02a09dc 100644
--- a/newlib/libc/stdlib/strtoll_r.c
+++ b/newlib/libc/stdlib/strtoll_r.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy */
diff --git a/newlib/libc/stdlib/strtorx.c b/newlib/libc/stdlib/strtorx.c
index aeeb250..bbd58ca 100644
--- a/newlib/libc/stdlib/strtorx.c
+++ b/newlib/libc/stdlib/strtorx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /****************************************************************
 
 The author of this software is David M. Gay.
@@ -101,6 +102,7 @@ ULtox(__UShort *L, __ULong *bits, Long exp, int k)
 	  }
 	if (k & STRTOG_Neg)
 		L[_0] |= 0x8000;
+	__A_VARIABLE = 1;
 	}
 
  int
@@ -125,6 +127,7 @@ _strtorx_l(struct _reent *p, const char *s, char **sp, int rounding, void *L,
 		}
 	k = _strtodg_l(p, s, sp, fpi, &exp, bits, loc);
 	ULtox((__UShort*)L, bits, exp, k);
+	__A_VARIABLE = 1;
 	return k;
 	}
 
diff --git a/newlib/libc/stdlib/strtoul.c b/newlib/libc/stdlib/strtoul.c
index aa5897e..f93406b 100644
--- a/newlib/libc/stdlib/strtoul.c
+++ b/newlib/libc/stdlib/strtoul.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strtoul>>, <<strtoul_l>>---string to unsigned long
@@ -200,6 +201,7 @@ _strtoul_l (struct _reent *rptr, const char *__restrict nptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (char *) (any ? (char *)s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -210,6 +212,7 @@ _DEFUN (_strtoul_r, (rptr, nptr, endptr, base),
 	char **__restrict endptr _AND
 	int base)
 {
+  __A_VARIABLE = 1;
   return _strtoul_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -219,6 +222,7 @@ unsigned long
 strtoul_l (const char *__restrict s, char **__restrict ptr, int base,
 	   locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtoul_l (_REENT, s, ptr, base, loc);
 }
 
@@ -228,6 +232,7 @@ _DEFUN (strtoul, (s, ptr, base),
 	char **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoul_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/strtoull.c b/newlib/libc/stdlib/strtoull.c
index ba6452e..caff5e5 100644
--- a/newlib/libc/stdlib/strtoull.c
+++ b/newlib/libc/stdlib/strtoull.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strtoull>>, <<strtoull_l>>---string to unsigned long long
@@ -198,6 +199,7 @@ _strtoull_l (struct _reent *rptr, const char *__restrict nptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (char *) (any ? (char *)s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -208,6 +210,7 @@ _DEFUN (_strtoull_r, (rptr, nptr, endptr, base),
 	char **__restrict endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoull_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -217,6 +220,7 @@ unsigned long long
 strtoull_l (const char *__restrict s, char **__restrict ptr, int base,
 	    locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtoull_l (_REENT, s, ptr, base, loc);
 }
 
@@ -226,6 +230,7 @@ _DEFUN (strtoull, (s, ptr, base),
 	char **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoull_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/strtoull_r.c b/newlib/libc/stdlib/strtoull_r.c
index 2997587..02a09dc 100644
--- a/newlib/libc/stdlib/strtoull_r.c
+++ b/newlib/libc/stdlib/strtoull_r.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy */
diff --git a/newlib/libc/stdlib/strtoumax.c b/newlib/libc/stdlib/strtoumax.c
index aa4a0ac..05e7a5c 100644
--- a/newlib/libc/stdlib/strtoumax.c
+++ b/newlib/libc/stdlib/strtoumax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -123,6 +124,7 @@ noconv:
 		acc = -acc;
 	if (endptr != NULL)
 		*endptr = (char *)(any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -130,6 +132,7 @@ uintmax_t
 _strtoumax_r(struct _reent *rptr, const char *__restrict nptr,
 	     char **__restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoumax_l(rptr, nptr, endptr, base, __get_current_locale());
 }
 
@@ -139,12 +142,14 @@ uintmax_t
 strtoumax_l(const char * __restrict nptr, char ** __restrict endptr, int base,
 	    locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _strtoumax_l(_REENT, nptr, endptr, base, loc);
 }
 
 uintmax_t
 strtoumax(const char* __restrict nptr, char** __restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _strtoumax_l(_REENT, nptr, endptr, base, __get_current_locale());
 }
 
diff --git a/newlib/libc/stdlib/system.c b/newlib/libc/stdlib/system.c
index 135a9d0..140ada0 100644
--- a/newlib/libc/stdlib/system.c
+++ b/newlib/libc/stdlib/system.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<system>>---execute command string
@@ -71,6 +72,7 @@ _DEFUN(_system_r, (ptr, s),
      _CONST char *s)
 {
 #if defined(HAVE_SYSTEM)
+  __A_VARIABLE = 1;
   return _system (s);
   ptr = ptr;
 #elif defined(NO_EXEC)
@@ -105,6 +107,7 @@ int
 _DEFUN(system, (s),
      _CONST char *s)
 {
+  __A_VARIABLE = 1;
   return _system_r (_REENT, s);
 }
 
diff --git a/newlib/libc/stdlib/utoa.c b/newlib/libc/stdlib/utoa.c
index 7738c23..536d4e0 100644
--- a/newlib/libc/stdlib/utoa.c
+++ b/newlib/libc/stdlib/utoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<utoa>>---unsigned integer to string
@@ -42,6 +43,7 @@ _DEFUN (__utoa, (value, str, base),
   if ((base < 2) || (base > 36))
     { 
       str[0] = '\0';
+      __A_VARIABLE = 1;
       return NULL;
     }  
     
@@ -63,6 +65,7 @@ _DEFUN (__utoa, (value, str, base),
       str[i] = c; 
     }       
   
+  __A_VARIABLE = 1;
   return str;
 }
 
@@ -72,5 +75,6 @@ _DEFUN (utoa, (value, str, base),
         char *str _AND
         int base)
 {
+  __A_VARIABLE = 1;
   return __utoa (value, str, base);
 }
diff --git a/newlib/libc/stdlib/valloc.c b/newlib/libc/stdlib/valloc.c
index 26a44df..0195fe3 100644
--- a/newlib/libc/stdlib/valloc.c
+++ b/newlib/libc/stdlib/valloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef MALLOC_PROVIDED
 /* valloc.c -- a wrapper for valloc_r and pvalloc_r.  */
 
@@ -12,6 +13,7 @@ _PTR
 _DEFUN (valloc, (nbytes),
 	size_t nbytes)
 {
+  __A_VARIABLE = 1;
   return _valloc_r (_REENT, nbytes);
 }
 
@@ -19,6 +21,7 @@ _PTR
 _DEFUN (pvalloc, (nbytes),
 	size_t nbytes)
 {
+  __A_VARIABLE = 1;
   return _pvalloc_r (_REENT, nbytes);
 }
 
diff --git a/newlib/libc/stdlib/wcrtomb.c b/newlib/libc/stdlib/wcrtomb.c
index df7741a..40a73d1 100644
--- a/newlib/libc/stdlib/wcrtomb.c
+++ b/newlib/libc/stdlib/wcrtomb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <newlib.h>
 #include <wchar.h>
diff --git a/newlib/libc/stdlib/wcsnrtombs.c b/newlib/libc/stdlib/wcsnrtombs.c
index 8e5c387..aea578a 100644
--- a/newlib/libc/stdlib/wcsnrtombs.c
+++ b/newlib/libc/stdlib/wcsnrtombs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<wcsrtombs>>, <<wcsnrtombs>>---convert a wide-character string to a character string
@@ -179,6 +180,7 @@ _DEFUN (_wcsnrtombs_r, (r, dst, src, nwc, len, ps),
 	size_t len _AND
 	mbstate_t *ps)
 {
+  __A_VARIABLE = 1;
   return _wcsnrtombs_l (_REENT, dst, src, nwc, len, ps,
 			__get_current_locale ());
 }
@@ -192,6 +194,7 @@ _DEFUN (wcsnrtombs, (dst, src, nwc, len, ps),
 	size_t len _AND
 	mbstate_t *__restrict ps)
 {
+  __A_VARIABLE = 1;
   return _wcsnrtombs_l (_REENT, dst, src, nwc, len, ps,
 			__get_current_locale ());
 }
diff --git a/newlib/libc/stdlib/wcsrtombs.c b/newlib/libc/stdlib/wcsrtombs.c
index 2b6777c..7d4c8a2 100644
--- a/newlib/libc/stdlib/wcsrtombs.c
+++ b/newlib/libc/stdlib/wcsrtombs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Doc in wcsnrtombs.c */
 
 #include <reent.h>
@@ -12,6 +13,7 @@ _DEFUN (_wcsrtombs_r, (r, dst, src, len, ps),
 	size_t len _AND
 	mbstate_t *ps)
 {
+  __A_VARIABLE = 1;
   return _wcsnrtombs_r (r, dst, src, (size_t) -1, len, ps);
 } 
 
@@ -23,6 +25,7 @@ _DEFUN (wcsrtombs, (dst, src, len, ps),
 	size_t len _AND
 	mbstate_t *__restrict ps)
 {
+  __A_VARIABLE = 1;
   return _wcsnrtombs_r (_REENT, dst, src, (size_t) -1, len, ps);
 }
 #endif /* !_REENT_ONLY */
diff --git a/newlib/libc/stdlib/wcstod.c b/newlib/libc/stdlib/wcstod.c
index 605fca4..6d9ec45 100644
--- a/newlib/libc/stdlib/wcstod.c
+++ b/newlib/libc/stdlib/wcstod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<wcstod>>, <<wcstof>>, <<wcstold>>, <<wcstod_l>>, <<wcstof_l>>, <<wcstold_l>>---wide char string to double or float
@@ -191,10 +192,13 @@ _wcstod_l (struct _reent *ptr, const wchar_t *nptr, wchar_t **endptr,
 	    == (size_t) -1) {
                 if (endptr != NULL)
                         *endptr = (wchar_t *)nptr;
+                __A_VARIABLE = 1;
                 return (0.0);
         }
-        if ((buf = _malloc_r(ptr, len + 1)) == NULL)
+        if ((buf = _malloc_r(ptr, len + 1)) == NULL) {
+                __A_VARIABLE = 1;
                 return (0.0);
+        }
         mbs = initial;
         _wcsnrtombs_l(ptr, buf, &wcp, (size_t) -1, len + 1, &mbs, loc);
 
@@ -230,6 +234,7 @@ _wcstod_l (struct _reent *ptr, const wchar_t *nptr, wchar_t **endptr,
 
         _free_r(ptr, buf);
 
+        __A_VARIABLE = 1;
         return (val);
 }
 
@@ -239,6 +244,7 @@ _DEFUN (_wcstod_r, (ptr, nptr, endptr),
 	_CONST wchar_t *nptr _AND
 	wchar_t **endptr)
 {
+  __A_VARIABLE = 1;
   return _wcstod_l (ptr, nptr, endptr, __get_current_locale ());
 }
 
@@ -249,8 +255,11 @@ _DEFUN (_wcstof_r, (ptr, nptr, endptr),
 	wchar_t **endptr)
 {
   double retval = _wcstod_l (ptr, nptr, endptr, __get_current_locale ());
-  if (isnan (retval))
+  if (isnan (retval)) {
+    __A_VARIABLE = 1;
     return nanf (NULL);
+  }
+  __A_VARIABLE = 1;
   return (float)retval;
 }
 
@@ -260,6 +269,7 @@ double
 wcstod_l (const wchar_t *__restrict nptr, wchar_t **__restrict endptr,
 	  locale_t loc)
 {
+  __A_VARIABLE = 1;
   return _wcstod_l (_REENT, nptr, endptr, loc);
 }
 
@@ -267,6 +277,7 @@ double
 _DEFUN (wcstod, (nptr, endptr),
 	_CONST wchar_t *__restrict nptr _AND wchar_t **__restrict endptr)
 {
+  __A_VARIABLE = 1;
   return _wcstod_l (_REENT, nptr, endptr, __get_current_locale ());
 }
 
@@ -275,13 +286,16 @@ wcstof_l (const wchar_t *__restrict nptr, wchar_t **__restrict endptr,
 	  locale_t loc)
 {
   double val = _wcstod_l (_REENT, nptr, endptr, loc);
-  if (isnan (val))
+  if (isnan (val)) {
+    __A_VARIABLE = 1;
     return nanf (NULL);
+  }
   float retval = (float) val;
 #ifndef NO_ERRNO
   if (isinf (retval) && !isinf (val))
     _REENT->_errno = ERANGE;
 #endif
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -291,14 +305,17 @@ _DEFUN (wcstof, (nptr, endptr),
 	wchar_t **__restrict endptr)
 {
   double val = _wcstod_l (_REENT, nptr, endptr, __get_current_locale ());
-  if (isnan (val))
+  if (isnan (val)) {
+    __A_VARIABLE = 1;
     return nanf (NULL);
+  }
   float retval = (float) val;
 #ifndef NO_ERRNO
   if (isinf (retval) && !isinf (val))
     _REENT->_errno = ERANGE;
 #endif
 
+  __A_VARIABLE = 1;
   return retval;
 }
 
diff --git a/newlib/libc/stdlib/wcstoimax.c b/newlib/libc/stdlib/wcstoimax.c
index 02ab1c1..8b91e8e 100644
--- a/newlib/libc/stdlib/wcstoimax.c
+++ b/newlib/libc/stdlib/wcstoimax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -130,6 +131,7 @@ noconv:
 		acc = -acc;
 	if (endptr != NULL)
 		*endptr = (wchar_t *)(any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -137,6 +139,7 @@ intmax_t
 _wcstoimax_r(struct _reent *rptr, const wchar_t *__restrict nptr,
 	     wchar_t **__restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoimax_l(rptr, nptr, endptr, base, __get_current_locale());
 }
 
@@ -146,12 +149,14 @@ intmax_t
 wcstoimax_l(const wchar_t * __restrict nptr, wchar_t ** __restrict endptr,
 	    int base, locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstoimax_l(_REENT, nptr, endptr, base, loc);
 }
 
 intmax_t
 wcstoimax(const wchar_t* __restrict nptr, wchar_t** __restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoimax_l(_REENT, nptr, endptr, base, __get_current_locale());
 }
 
diff --git a/newlib/libc/stdlib/wcstol.c b/newlib/libc/stdlib/wcstol.c
index 4c74805..8af9319 100644
--- a/newlib/libc/stdlib/wcstol.c
+++ b/newlib/libc/stdlib/wcstol.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<wcstol>>, <<wcstol_l>>---wide string to long
@@ -222,6 +223,7 @@ _wcstol_l (struct _reent *rptr, const wchar_t *nptr, wchar_t **endptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (wchar_t *) (any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -232,6 +234,7 @@ _DEFUN (_wcstol_r, (rptr, nptr, endptr, base),
 	wchar_t **endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstol_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -241,6 +244,7 @@ long
 wcstol_l (const wchar_t *__restrict s, wchar_t **__restrict ptr, int base,
 	  locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstol_l (_REENT, s, ptr, base, loc);
 }
 
@@ -250,6 +254,7 @@ _DEFUN (wcstol, (s, ptr, base),
 	wchar_t **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstol_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/wcstold.c b/newlib/libc/stdlib/wcstold.c
index 4876e11..0d84e2e 100644
--- a/newlib/libc/stdlib/wcstold.c
+++ b/newlib/libc/stdlib/wcstold.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
diff --git a/newlib/libc/stdlib/wcstoll.c b/newlib/libc/stdlib/wcstoll.c
index 2996b11..dd3b468 100644
--- a/newlib/libc/stdlib/wcstoll.c
+++ b/newlib/libc/stdlib/wcstoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
    <<wcstoll>>, <<wcstoll_l>>---wide string to long long
@@ -222,6 +223,7 @@ _wcstoll_l (struct _reent *rptr, const wchar_t *nptr, wchar_t **endptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (wchar_t *) (any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -232,6 +234,7 @@ _DEFUN (_wcstoll_r, (rptr, nptr, endptr, base),
 	wchar_t **endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoll_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -241,6 +244,7 @@ long long
 wcstoll_l (const wchar_t *__restrict s, wchar_t **__restrict ptr, int base,
 	   locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstoll_l (_REENT, s, ptr, base, loc);
 }
 
@@ -250,6 +254,7 @@ _DEFUN (wcstoll, (s, ptr, base),
 	wchar_t **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoll_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/wcstoll_r.c b/newlib/libc/stdlib/wcstoll_r.c
index 2997587..02a09dc 100644
--- a/newlib/libc/stdlib/wcstoll_r.c
+++ b/newlib/libc/stdlib/wcstoll_r.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy */
diff --git a/newlib/libc/stdlib/wcstombs.c b/newlib/libc/stdlib/wcstombs.c
index b0123a3..43b7d0b 100644
--- a/newlib/libc/stdlib/wcstombs.c
+++ b/newlib/libc/stdlib/wcstombs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<wcstombs>>---minimal wide char string to multibyte string converter
@@ -64,6 +65,7 @@ _DEFUN (wcstombs, (s, pwcs, n),
   mbstate_t state;
   state.__count = 0;
   
+  __A_VARIABLE = 1;
   return _wcstombs_r (_REENT, s, pwcs, n, &state);
 #else /* not _MB_CAPABLE */
   int count = 0;
diff --git a/newlib/libc/stdlib/wcstombs_r.c b/newlib/libc/stdlib/wcstombs_r.c
index 0680cd7..aa17820 100644
--- a/newlib/libc/stdlib/wcstombs_r.c
+++ b/newlib/libc/stdlib/wcstombs_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 #include <wchar.h>
 #include "local.h"
diff --git a/newlib/libc/stdlib/wcstoul.c b/newlib/libc/stdlib/wcstoul.c
index e87b2ec..ad78c88 100644
--- a/newlib/libc/stdlib/wcstoul.c
+++ b/newlib/libc/stdlib/wcstoul.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcstoul>>, <<wcstoul_l>>---wide string to unsigned long
@@ -201,6 +202,7 @@ _wcstoul_l (struct _reent *rptr, const wchar_t *nptr, wchar_t **endptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (wchar_t *) (any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -211,6 +213,7 @@ _DEFUN (_wcstoul_r, (rptr, nptr, endptr, base),
 	wchar_t **endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoul_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -220,6 +223,7 @@ unsigned long
 wcstoul_l (const wchar_t *__restrict s, wchar_t **__restrict ptr, int base,
 	   locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstoul_l (_REENT, s, ptr, base, loc);
 }
 
@@ -229,6 +233,7 @@ _DEFUN (wcstoul, (s, ptr, base),
 	wchar_t **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoul_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/wcstoull.c b/newlib/libc/stdlib/wcstoull.c
index 131a837..4540570 100644
--- a/newlib/libc/stdlib/wcstoull.c
+++ b/newlib/libc/stdlib/wcstoull.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcstoull>>, <<wcstoull_l>>---wide string to unsigned long long
@@ -168,6 +169,7 @@ _wcstoull_l (struct _reent *rptr, const wchar_t *nptr, wchar_t **endptr,
 
 	if(base < 0  ||  base == 1  ||  base > 36)  {
 		rptr->_errno = EINVAL;
+		__A_VARIABLE = 1;
 		return(0ULL);
 	}
 	/*
@@ -217,6 +219,7 @@ _wcstoull_l (struct _reent *rptr, const wchar_t *nptr, wchar_t **endptr,
 		acc = -acc;
 	if (endptr != 0)
 		*endptr = (wchar_t *) (any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -227,6 +230,7 @@ _DEFUN (_wcstoull_r, (rptr, nptr, endptr, base),
 	wchar_t **endptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoull_l (rptr, nptr, endptr, base, __get_current_locale ());
 }
 
@@ -236,6 +240,7 @@ unsigned long long
 wcstoull_l (const wchar_t *__restrict s, wchar_t **__restrict ptr, int base,
 	    locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstoull_l (_REENT, s, ptr, base, loc);
 }
 
@@ -245,6 +250,7 @@ _DEFUN (wcstoull, (s, ptr, base),
 	wchar_t **__restrict ptr _AND
 	int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoull_l (_REENT, s, ptr, base, __get_current_locale ());
 }
 
diff --git a/newlib/libc/stdlib/wcstoull_r.c b/newlib/libc/stdlib/wcstoull_r.c
index 2997587..02a09dc 100644
--- a/newlib/libc/stdlib/wcstoull_r.c
+++ b/newlib/libc/stdlib/wcstoull_r.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy */
diff --git a/newlib/libc/stdlib/wcstoumax.c b/newlib/libc/stdlib/wcstoumax.c
index 17b5275..e3ed455 100644
--- a/newlib/libc/stdlib/wcstoumax.c
+++ b/newlib/libc/stdlib/wcstoumax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1992, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -129,6 +130,7 @@ noconv:
 		acc = -acc;
 	if (endptr != NULL)
 		*endptr = (wchar_t *)(any ? s - 1 : nptr);
+	__A_VARIABLE = 1;
 	return (acc);
 }
 
@@ -136,6 +138,7 @@ uintmax_t
 _wcstoumax_r(struct _reent *rptr, const wchar_t *__restrict nptr,
 	     wchar_t **__restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoumax_l(rptr, nptr, endptr, base, __get_current_locale());
 }
 
@@ -145,12 +148,14 @@ uintmax_t
 wcstoumax_l(const wchar_t * __restrict nptr, wchar_t ** __restrict endptr,
 	    int base, locale_t loc)
 {
+	__A_VARIABLE = 1;
 	return _wcstoumax_l(_REENT, nptr, endptr, base, loc);
 }
 
 uintmax_t
 wcstoumax(const wchar_t* __restrict nptr, wchar_t** __restrict endptr, int base)
 {
+	__A_VARIABLE = 1;
 	return _wcstoumax_l(_REENT, nptr, endptr, base, __get_current_locale());
 }
 
diff --git a/newlib/libc/stdlib/wctob.c b/newlib/libc/stdlib/wctob.c
index 61365a1..f500e74 100644
--- a/newlib/libc/stdlib/wctob.c
+++ b/newlib/libc/stdlib/wctob.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <wchar.h>
 #include <stdio.h>
@@ -12,8 +13,10 @@ wctob (wint_t wc)
   mbstate_t mbs;
   unsigned char pmb[MB_LEN_MAX];
 
-  if (wc == WEOF)
+  if (wc == WEOF) {
+    __A_VARIABLE = 1;
     return EOF;
+  }
 
   /* Put mbs in initial state. */
   memset (&mbs, '\0', sizeof (mbs));
@@ -21,5 +24,6 @@ wctob (wint_t wc)
   reent = _REENT;
   _REENT_CHECK_MISC(reent);
 
+  __A_VARIABLE = 1;
   return __WCTOMB (reent, (char *) pmb, wc, &mbs) == 1 ? (int) pmb[0] : EOF;
 }
diff --git a/newlib/libc/stdlib/wctomb.c b/newlib/libc/stdlib/wctomb.c
index 13892ff..abb9074 100644
--- a/newlib/libc/stdlib/wctomb.c
+++ b/newlib/libc/stdlib/wctomb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<wctomb>>---minimal wide char to multibyte converter
@@ -61,6 +62,7 @@ _DEFUN (wctomb, (s, wchar),
 
         _REENT_CHECK_MISC(reent);
 
+        __A_VARIABLE = 1;
         return __WCTOMB (reent, s, wchar, &(_REENT_WCTOMB_STATE(reent)));
 #else /* not _MB_CAPABLE */
         if (s == NULL)
diff --git a/newlib/libc/stdlib/wctomb_r.c b/newlib/libc/stdlib/wctomb_r.c
index 2c018f9..5767f0b 100644
--- a/newlib/libc/stdlib/wctomb_r.c
+++ b/newlib/libc/stdlib/wctomb_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
@@ -13,6 +14,7 @@ _DEFUN (_wctomb_r, (r, s, wchar, state),
         wchar_t        _wchar _AND
         mbstate_t     *state)
 {
+  __A_VARIABLE = 1;
   return __WCTOMB (r, s, _wchar, state);
 }
 
@@ -28,8 +30,10 @@ _DEFUN (__ascii_wctomb, (r, s, wchar, state),
      is 4, as is the case on cygwin.  */
   wint_t wchar = _wchar;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
  
 #ifdef __CYGWIN__
   if ((size_t)wchar >= 0x80)
@@ -38,10 +42,12 @@ _DEFUN (__ascii_wctomb, (r, s, wchar, state),
 #endif
     {
       r->_errno = EILSEQ;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   *s = (char) wchar;
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -59,8 +65,10 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
   wint_t wchar = _wchar;
   int ret = 0;
 
-  if (s == NULL)
-    return 0; /* UTF-8 encoding is not state-dependent */
+  if (s == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  } /* UTF-8 encoding is not state-dependent */
 
   if (sizeof (wchar_t) == 2 && state->__count == -4
       && (wchar < 0xdc00 || wchar > 0xdfff))
@@ -80,12 +88,14 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
   if (wchar <= 0x7f)
     {
       *s = wchar;
+      __A_VARIABLE = 1;
       return ret + 1;
     }
   if (wchar >= 0x80 && wchar <= 0x7ff)
     {
       *s++ = 0xc0 | ((wchar & 0x7c0) >> 6);
       *s   = 0x80 |  (wchar &  0x3f);
+      __A_VARIABLE = 1;
       return ret + 2;
     }
   if (wchar >= 0x800 && wchar <= 0xffff)
@@ -103,6 +113,7 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
 	      state->__value.__wchb[1] = (tmp >> 8) & 0xff;
 	      state->__count = -4;
 	      *s = (0xf0 | ((tmp & 0x1c0000) >> 18));
+	      __A_VARIABLE = 1;
 	      return ret;
 	    }
 	  if (state->__count == -4)
@@ -118,6 +129,7 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
 	      *s++ = 0x80 | ((tmp &  0x3f000) >> 12);
 	      *s++ = 0x80 | ((tmp &    0xfc0) >> 6);
 	      *s   = 0x80 |  (tmp &     0x3f);
+	      __A_VARIABLE = 1;
 	      return 4;
 	    }
 	  /* Otherwise translate into CESU-8 value. */
@@ -125,6 +137,7 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
       *s++ = 0xe0 | ((wchar & 0xf000) >> 12);
       *s++ = 0x80 | ((wchar &  0xfc0) >> 6);
       *s   = 0x80 |  (wchar &   0x3f);
+      __A_VARIABLE = 1;
       return ret + 3;
     }
   if (wchar >= 0x10000 && wchar <= 0x10ffff)
@@ -133,10 +146,12 @@ _DEFUN (__utf8_wctomb, (r, s, wchar, state),
       *s++ = 0x80 | ((wchar &  0x3f000) >> 12);
       *s++ = 0x80 | ((wchar &    0xfc0) >> 6);
       *s   = 0x80 |  (wchar &     0x3f);
+      __A_VARIABLE = 1;
       return 4;
     }
 
   r->_errno = EILSEQ;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -229,8 +244,10 @@ _DEFUN (__jis_wctomb, (r, s, wchar, state),
   unsigned char char2 = (unsigned char)wchar;
   unsigned char char1 = (unsigned char)(wchar >> 8);
 
-  if (s == NULL)
-    return 1;  /* state-dependent */
+  if (s == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* state-dependent */
 
   if (char1 != 0x00)
     {
@@ -248,9 +265,11 @@ _DEFUN (__jis_wctomb, (r, s, wchar, state),
 	    }
 	  *s++ = (char)char1;
 	  *s = (char)char2;
+	  __A_VARIABLE = 1;
 	  return cnt + 2;
 	}
       r->_errno = EILSEQ;
+      __A_VARIABLE = 1;
       return -1;
     }
   if (state->__state != 0)
@@ -263,6 +282,7 @@ _DEFUN (__jis_wctomb, (r, s, wchar, state),
       cnt = 3;
     }
   *s = (char)char2;
+  __A_VARIABLE = 1;
   return cnt + 1;
 }
 #endif /* !__CYGWIN__ */
@@ -274,8 +294,10 @@ ___iso_wctomb (struct _reent *r, char *s, wchar_t _wchar, int iso_idx,
 {
   wint_t wchar = _wchar;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* wchars <= 0x9f translate to all ISO charsets directly. */
   if (wchar >= 0xa0)
@@ -288,9 +310,11 @@ ___iso_wctomb (struct _reent *r, char *s, wchar_t _wchar, int iso_idx,
 	    if (__iso_8859_conv[iso_idx][mb] == wchar)
 	      {
 		*s = (char) (mb + 0xa0);
+		__A_VARIABLE = 1;
 		return 1;
 	      }
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
     }
@@ -298,100 +322,117 @@ ___iso_wctomb (struct _reent *r, char *s, wchar_t _wchar, int iso_idx,
   if ((size_t)wchar >= 0x100)
     {
       r->_errno = EILSEQ;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   *s = (char) wchar;
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int __iso_8859_1_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, -1, state);
 }
 
 int __iso_8859_2_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 0, state);
 }
 
 int __iso_8859_3_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 1, state);
 }
 
 int __iso_8859_4_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 2, state);
 }
 
 int __iso_8859_5_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 3, state);
 }
 
 int __iso_8859_6_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 4, state);
 }
 
 int __iso_8859_7_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 5, state);
 }
 
 int __iso_8859_8_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 6, state);
 }
 
 int __iso_8859_9_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			 mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 7, state);
 }
 
 int __iso_8859_10_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 8, state);
 }
 
 int __iso_8859_11_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 9, state);
 }
 
 int __iso_8859_13_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 10, state);
 }
 
 int __iso_8859_14_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 11, state);
 }
 
 int __iso_8859_15_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 12, state);
 }
 
 int __iso_8859_16_wctomb (struct _reent *r, char *s, wchar_t _wchar,
 			  mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___iso_wctomb (r, s, _wchar, 13, state);
 }
 
@@ -420,6 +461,7 @@ static wctomb_p __iso_8859_wctomb[17] = {
 wctomb_p
 __iso_wctomb (int val)
 {
+  __A_VARIABLE = 1;
   return __iso_8859_wctomb[val];
 }
 #endif /* _MB_EXTENDED_CHARSETS_ISO */
@@ -431,8 +473,10 @@ ___cp_wctomb (struct _reent *r, char *s, wchar_t _wchar, int cp_idx,
 {
   wint_t wchar = _wchar;
 
-  if (s == NULL)
+  if (s == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   if (wchar >= 0x80)
     {
@@ -444,9 +488,11 @@ ___cp_wctomb (struct _reent *r, char *s, wchar_t _wchar, int cp_idx,
 	    if (__cp_conv[cp_idx][mb] == wchar)
 	      {
 		*s = (char) (mb + 0x80);
+		__A_VARIABLE = 1;
 		return 1;
 	      }
 	  r->_errno = EILSEQ;
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
     }
@@ -454,166 +500,194 @@ ___cp_wctomb (struct _reent *r, char *s, wchar_t _wchar, int cp_idx,
   if ((size_t)wchar >= 0x100)
     {
       r->_errno = EILSEQ;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   *s = (char) wchar;
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int
 __cp_437_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 0, state);
 }
 
 static int
 __cp_720_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 1, state);
 }
 
 static int
 __cp_737_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 2, state);
 }
 
 static int
 __cp_775_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 3, state);
 }
 
 static int
 __cp_850_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 4, state);
 }
 
 static int
 __cp_852_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 5, state);
 }
 
 static int
 __cp_855_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 6, state);
 }
 
 static int
 __cp_857_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 7, state);
 }
 
 static int
 __cp_858_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 8, state);
 }
 
 static int
 __cp_862_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 9, state);
 }
 
 static int
 __cp_866_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 10, state);
 }
 
 static int
 __cp_874_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 11, state);
 }
 
 static int
 __cp_1125_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 12, state);
 }
 
 static int
 __cp_1250_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 13, state);
 }
 
 static int
 __cp_1251_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 14, state);
 }
 
 static int
 __cp_1252_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 15, state);
 }
 
 static int
 __cp_1253_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 16, state);
 }
 
 static int
 __cp_1254_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 17, state);
 }
 
 static int
 __cp_1255_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 18, state);
 }
 
 static int
 __cp_1256_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 19, state);
 }
 
 static int
 __cp_1257_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 20, state);
 }
 
 static int
 __cp_1258_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 21, state);
 }
 
 static int
 __cp_20866_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 22, state);
 }
 
 static int
 __cp_21866_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 23, state);
 }
 
 static int
 __cp_101_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 24, state);
 }
 
 static int
 __cp_102_wctomb (struct _reent *r, char *s, wchar_t _wchar, mbstate_t *state)
 {
+  __A_VARIABLE = 1;
   return ___cp_wctomb (r, s, _wchar, 25, state);
 }
 
@@ -651,6 +725,7 @@ static wctomb_p __cp_xxx_wctomb[26] = {
 wctomb_p
 __cp_wctomb (int val)
 {
+  __A_VARIABLE = 1;
   return __cp_xxx_wctomb[__cp_val_index (val)];
 }
 #endif /* _MB_EXTENDED_CHARSETS_WINDOWS */
diff --git a/newlib/libc/string/bcmp.c b/newlib/libc/string/bcmp.c
index 8d6e12f..cd8215e 100644
--- a/newlib/libc/string/bcmp.c
+++ b/newlib/libc/string/bcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<bcmp>>---compare two memory areas
@@ -45,5 +46,6 @@ _DEFUN (bcmp, (m1, m2, n),
 	size_t n)
 
 {
+  __A_VARIABLE = 1;
   return memcmp (m1, m2, n);
 }
diff --git a/newlib/libc/string/bcopy.c b/newlib/libc/string/bcopy.c
index 2881fd9..5c811db 100644
--- a/newlib/libc/string/bcopy.c
+++ b/newlib/libc/string/bcopy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<bcopy>>---copy memory regions
@@ -36,4 +37,5 @@ _DEFUN (bcopy, (b1, b2, length),
 	size_t length)
 {
   memmove (b2, b1, length);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/string/bzero.c b/newlib/libc/string/bzero.c
index e99529a..7045c97 100644
--- a/newlib/libc/string/bzero.c
+++ b/newlib/libc/string/bzero.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<bzero>>---initialize memory to zero
@@ -37,4 +38,5 @@ bzero(void *b, size_t length)
 {
 
 	memset(b, 0, length);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/string/explicit_bzero.c b/newlib/libc/string/explicit_bzero.c
index 5124df2..ade5dbe 100644
--- a/newlib/libc/string/explicit_bzero.c
+++ b/newlib/libc/string/explicit_bzero.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: explicit_bzero.c,v 1.2 2014/06/10 04:17:37 deraadt Exp $ */
 /*
  * Public domain.
@@ -13,4 +14,5 @@ void
 explicit_bzero(void *p, size_t n)
 {
 	bzero(p, n);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/string/ffsl.c b/newlib/libc/string/ffsl.c
index 4b1d52d..ba33b6a 100644
--- a/newlib/libc/string/ffsl.c
+++ b/newlib/libc/string/ffsl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -30,5 +31,6 @@ int
 ffsl(long i)
 {
 
+	__A_VARIABLE = 1;
 	return (__builtin_ffsl(i));
 }
diff --git a/newlib/libc/string/ffsll.c b/newlib/libc/string/ffsll.c
index 7172506..677c8d9 100644
--- a/newlib/libc/string/ffsll.c
+++ b/newlib/libc/string/ffsll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -30,5 +31,6 @@ int
 ffsll(long long i)
 {
 
+	__A_VARIABLE = 1;
 	return (__builtin_ffsll(i));
 }
diff --git a/newlib/libc/string/fls.c b/newlib/libc/string/fls.c
index a3e88d2..acd6c48 100644
--- a/newlib/libc/string/fls.c
+++ b/newlib/libc/string/fls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -31,8 +32,11 @@ int
 fls(int i)
 {
 
-	if (i == 0)
+	if (i == 0) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
+	__A_VARIABLE = 1;
 	return (sizeof(i) * CHAR_BIT - __builtin_clz(i));
 }
diff --git a/newlib/libc/string/flsl.c b/newlib/libc/string/flsl.c
index af6277d..b5c08fc 100644
--- a/newlib/libc/string/flsl.c
+++ b/newlib/libc/string/flsl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -31,8 +32,11 @@ int
 flsl(long i)
 {
 
-	if (i == 0)
+	if (i == 0) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
+	__A_VARIABLE = 1;
 	return (sizeof(i) * CHAR_BIT - __builtin_clzl(i));
 }
diff --git a/newlib/libc/string/flsll.c b/newlib/libc/string/flsll.c
index 3936184..2a1c6aa 100644
--- a/newlib/libc/string/flsll.c
+++ b/newlib/libc/string/flsll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -31,8 +32,11 @@ int
 flsll(long long i)
 {
 
-	if (i == 0)
+	if (i == 0) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
+	__A_VARIABLE = 1;
 	return (sizeof(i) * CHAR_BIT - __builtin_clzll(i));
 }
diff --git a/newlib/libc/string/gnu_basename.c b/newlib/libc/string/gnu_basename.c
index 90e22cc..6449fc4 100644
--- a/newlib/libc/string/gnu_basename.c
+++ b/newlib/libc/string/gnu_basename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_BASENAME
 /* Copyright 2015 Red Hat, Inc.
  * Permission to use, copy, modify, and distribute this software
@@ -18,8 +19,11 @@ _DEFUN (__gnu_basename, (path),
 	const char *path)
 {
   char *p;
-  if ((p = strrchr (path, '/')))
+  if ((p = strrchr (path, '/'))) {
+    __A_VARIABLE = 1;
     return p + 1;
+  }
+  __A_VARIABLE = 1;
   return (char *) path;
 }
 
diff --git a/newlib/libc/string/index.c b/newlib/libc/string/index.c
index ec241ff..aaea6b3 100644
--- a/newlib/libc/string/index.c
+++ b/newlib/libc/string/index.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<index>>---search for character in string
@@ -41,5 +42,6 @@ _DEFUN (index, (s, c),
 	_CONST char *s _AND
 	int c)
 {
+  __A_VARIABLE = 1;
   return strchr (s, c);
 }
diff --git a/newlib/libc/string/memccpy.c b/newlib/libc/string/memccpy.c
index 332ed46..2820b97 100644
--- a/newlib/libc/string/memccpy.c
+++ b/newlib/libc/string/memccpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<memccpy>>---copy memory regions with end-token check
@@ -85,6 +86,7 @@ _DEFUN (memccpy, (dst0, src0, endchar, len0),
         }
     }
 
+  __A_VARIABLE = 1;
   return ptr;
 #else
   _PTR ptr = NULL;
diff --git a/newlib/libc/string/memchr.c b/newlib/libc/string/memchr.c
index db0af7c..a340e44 100644
--- a/newlib/libc/string/memchr.c
+++ b/newlib/libc/string/memchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<memchr>>---find character in memory
diff --git a/newlib/libc/string/memcmp.c b/newlib/libc/string/memcmp.c
index 4a871fa..38d150d 100644
--- a/newlib/libc/string/memcmp.c
+++ b/newlib/libc/string/memcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<memcmp>>---compare two memory areas
@@ -63,11 +64,13 @@ _DEFUN (memcmp, (m1, m2, n),
     {
       if (*s1 != *s2)
 	{
+	  __A_VARIABLE = 1;
 	  return *s1 - *s2;
 	}
       s1++;
       s2++;
     }
+  __A_VARIABLE = 1;
   return 0;
 #else  
   unsigned char *s1 = (unsigned char *) m1;
diff --git a/newlib/libc/string/memcpy.c b/newlib/libc/string/memcpy.c
index 5f27bca..45888d7 100644
--- a/newlib/libc/string/memcpy.c
+++ b/newlib/libc/string/memcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<memcpy>>---copy memory regions
@@ -67,6 +68,7 @@ _DEFUN (memcpy, (dst0, src0, len0),
       *dst++ = *src++;
     }
 
+  __A_VARIABLE = 1;
   return save;
 #else
   char *dst = dst0;
diff --git a/newlib/libc/string/memmem.c b/newlib/libc/string/memmem.c
index 25704e4..8d437a9 100644
--- a/newlib/libc/string/memmem.c
+++ b/newlib/libc/string/memmem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Byte-wise substring search, using the Two-Way algorithm.
  * Copyright (C) 2008 Eric Blake
  * Permission to use, copy, modify, and distribute this software
@@ -57,21 +58,26 @@ _DEFUN (memmem, (haystack_start, haystack_len, needle_start, needle_len),
   const unsigned char *haystack = (const unsigned char *) haystack_start;
   const unsigned char *needle = (const unsigned char *) needle_start;
 
-  if (needle_len == 0)
+  if (needle_len == 0) {
     /* The first occurrence of the empty string is deemed to occur at
        the beginning of the string.  */
+    __A_VARIABLE = 1;
     return (void *) haystack;
+  }
 
 #if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
 
   /* Less code size, but quadratic performance in the worst case.  */
   while (needle_len <= haystack_len)
     {
-      if (!memcmp (haystack, needle, needle_len))
+      if (!memcmp (haystack, needle, needle_len)) {
+        __A_VARIABLE = 1;
         return (void *) haystack;
+      }
       haystack++;
       haystack_len--;
     }
+  __A_VARIABLE = 1;
   return NULL;
 
 #else /* compilation for speed */
diff --git a/newlib/libc/string/memmove.c b/newlib/libc/string/memmove.c
index a037c7c..29688cc 100644
--- a/newlib/libc/string/memmove.c
+++ b/newlib/libc/string/memmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<memmove>>---move possibly overlapping memory
@@ -84,6 +85,7 @@ _DEFUN (memmove, (dst_void, src_void, length),
 	}
     }
 
+  __A_VARIABLE = 1;
   return dst_void;
 #else
   char *dst = dst_void;
diff --git a/newlib/libc/string/mempcpy.c b/newlib/libc/string/mempcpy.c
index 5c6738f..29cd9b3 100644
--- a/newlib/libc/string/mempcpy.c
+++ b/newlib/libc/string/mempcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<mempcpy>>---copy memory regions and return end pointer
@@ -63,6 +64,7 @@ _DEFUN (mempcpy, (dst0, src0, len0),
       *dst++ = *src++;
     }
 
+  __A_VARIABLE = 1;
   return dst;
 #else
   char *dst = dst0;
diff --git a/newlib/libc/string/memrchr.c b/newlib/libc/string/memrchr.c
index 60dee42..9248ef7 100644
--- a/newlib/libc/string/memrchr.c
+++ b/newlib/libc/string/memrchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<memrchr>>---reverse search for character in memory
diff --git a/newlib/libc/string/memset.c b/newlib/libc/string/memset.c
index b84e155..674e59c 100644
--- a/newlib/libc/string/memset.c
+++ b/newlib/libc/string/memset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<memset>>---set an area of memory
diff --git a/newlib/libc/string/rawmemchr.c b/newlib/libc/string/rawmemchr.c
index 4b5a4cd..7c6629d 100644
--- a/newlib/libc/string/rawmemchr.c
+++ b/newlib/libc/string/rawmemchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<rawmemchr>>---find character in memory
diff --git a/newlib/libc/string/rindex.c b/newlib/libc/string/rindex.c
index daa1c52..e274ced 100644
--- a/newlib/libc/string/rindex.c
+++ b/newlib/libc/string/rindex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<rindex>>---reverse search for character in string
@@ -41,5 +42,6 @@ _DEFUN (rindex, (s, c),
 	_CONST char *s _AND
 	int c)
 {
+  __A_VARIABLE = 1;
   return strrchr (s, c);
 }
diff --git a/newlib/libc/string/stpcpy.c b/newlib/libc/string/stpcpy.c
index bc58f47..2af3af4 100644
--- a/newlib/libc/string/stpcpy.c
+++ b/newlib/libc/string/stpcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<stpcpy>>---copy string returning a pointer to its end
@@ -87,5 +88,6 @@ _DEFUN (stpcpy, (dst, src),
 
   while ((*dst++ = *src++))
     ;
+  __A_VARIABLE = 1;
   return --dst;
 }
diff --git a/newlib/libc/string/stpncpy.c b/newlib/libc/string/stpncpy.c
index abd9bbd..08c263f 100644
--- a/newlib/libc/string/stpncpy.c
+++ b/newlib/libc/string/stpncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<stpncpy>>---counted copy string returning a pointer to its end
@@ -111,5 +112,6 @@ _DEFUN (stpncpy, (dst, src),
   while (count-- > 0)
     *dst++ = '\0';
 
+  __A_VARIABLE = 1;
   return ret ? ret : dst;
 }
diff --git a/newlib/libc/string/strcasecmp.c b/newlib/libc/string/strcasecmp.c
index df8510b..9e4181b 100644
--- a/newlib/libc/string/strcasecmp.c
+++ b/newlib/libc/string/strcasecmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcasecmp>>---case-insensitive character string compare
@@ -54,5 +55,6 @@ _DEFUN (strcasecmp, (s1, s2),
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/strcasecmp_l.c b/newlib/libc/string/strcasecmp_l.c
index f87039d..4adb188 100644
--- a/newlib/libc/string/strcasecmp_l.c
+++ b/newlib/libc/string/strcasecmp_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcasecmp_l>>---case-insensitive character string compare
@@ -50,5 +51,6 @@ strcasecmp_l (const char *s1, const char *s2, struct __locale_t *locale)
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/strcasestr.c b/newlib/libc/string/strcasestr.c
index 8fff00b..0d3b274 100644
--- a/newlib/libc/string/strcasestr.c
+++ b/newlib/libc/string/strcasestr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcasestr>>---case-insensitive character string search
@@ -111,12 +112,15 @@ _DEFUN (strcasestr, (s, find),
 		len = strlen(find);
 		do {
 			do {
-				if ((sc = *s++) == 0)
+				if ((sc = *s++) == 0) {
+					__A_VARIABLE = 1;
 					return (NULL);
+				}
 			} while ((char)tolower((unsigned char)sc) != c);
 		} while (strncasecmp(s, find, len) != 0);
 		s--;
 	}
+	__A_VARIABLE = 1;
 	return ((char *)s);
 
 #else /* compilation for speed */
diff --git a/newlib/libc/string/strcat.c b/newlib/libc/string/strcat.c
index 1e46149..8321179 100644
--- a/newlib/libc/string/strcat.c
+++ b/newlib/libc/string/strcat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcat>>---concatenate strings
@@ -72,6 +73,7 @@ _DEFUN (strcat, (s1, s2),
 
   while (*s1++ = *s2++)
     ;
+  __A_VARIABLE = 1;
   return s;
 #else
   char *s = s1;
diff --git a/newlib/libc/string/strchr.c b/newlib/libc/string/strchr.c
index e921b5d..c225a58 100644
--- a/newlib/libc/string/strchr.c
+++ b/newlib/libc/string/strchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strchr>>---search for character in string
diff --git a/newlib/libc/string/strchrnul.c b/newlib/libc/string/strchrnul.c
index afeef43..4a14ac9 100644
--- a/newlib/libc/string/strchrnul.c
+++ b/newlib/libc/string/strchrnul.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strchrnul>>---search for character in string
@@ -43,5 +44,6 @@ _DEFUN (strchrnul, (s1, i),
 {
   char *s = strchr(s1, i);
 
+  __A_VARIABLE = 1;
   return s ? s : (char *)s1 + strlen(s1);
 }
diff --git a/newlib/libc/string/strcmp.c b/newlib/libc/string/strcmp.c
index 81d6527..66d55a8 100644
--- a/newlib/libc/string/strcmp.c
+++ b/newlib/libc/string/strcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcmp>>---character string compare
@@ -69,6 +70,7 @@ _DEFUN (strcmp, (s1, s2),
       s2++;
     }
 
+  __A_VARIABLE = 1;
   return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 #else
   unsigned long *a1;
diff --git a/newlib/libc/string/strcoll.c b/newlib/libc/string/strcoll.c
index a6bb31a..10c91c5 100644
--- a/newlib/libc/string/strcoll.c
+++ b/newlib/libc/string/strcoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcoll>>---locale-specific character string compare
@@ -47,5 +48,6 @@ _DEFUN (strcoll, (a, b),
 	_CONST char *b)
 
 {
+  __A_VARIABLE = 1;
   return strcmp (a, b);
 }
diff --git a/newlib/libc/string/strcoll_l.c b/newlib/libc/string/strcoll_l.c
index 5032f84..c0f7b02 100644
--- a/newlib/libc/string/strcoll_l.c
+++ b/newlib/libc/string/strcoll_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcoll_l>>---locale-specific character string compare
@@ -42,5 +43,6 @@ QUICKREF
 int
 strcoll_l (const char *a, const char *b, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return strcmp (a, b);
 }
diff --git a/newlib/libc/string/strcpy.c b/newlib/libc/string/strcpy.c
index 3dc3c33..7496732 100644
--- a/newlib/libc/string/strcpy.c
+++ b/newlib/libc/string/strcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcpy>>---copy string
@@ -68,6 +69,7 @@ _DEFUN (strcpy, (dst0, src0),
   while (*dst0++ = *src0++)
     ;
 
+  __A_VARIABLE = 1;
   return s;
 #else
   char *dst = dst0;
diff --git a/newlib/libc/string/strcspn.c b/newlib/libc/string/strcspn.c
index 403330c..e17b96e 100644
--- a/newlib/libc/string/strcspn.c
+++ b/newlib/libc/string/strcspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strcspn>>---count characters not in string
@@ -50,5 +51,6 @@ _DEFUN (strcspn, (s1, s2),
       s1++;
     }
 
+  __A_VARIABLE = 1;
   return s1 - s;
 }
diff --git a/newlib/libc/string/strdup.c b/newlib/libc/string/strdup.c
index dbb0692..86ec5d8 100644
--- a/newlib/libc/string/strdup.c
+++ b/newlib/libc/string/strdup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _REENT_ONLY
 
 #include <reent.h>
@@ -7,6 +8,7 @@
 char *
 _DEFUN (strdup, (str), _CONST char *str)
 {
+  __A_VARIABLE = 1;
   return _strdup_r (_REENT, str);
 }
 
diff --git a/newlib/libc/string/strdup_r.c b/newlib/libc/string/strdup_r.c
index ef77a58..51e276d 100644
--- a/newlib/libc/string/strdup_r.c
+++ b/newlib/libc/string/strdup_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <stdlib.h>
 #include <string.h>
@@ -13,5 +14,6 @@ _DEFUN (_strdup_r, (reent_ptr, str),
     {
       memcpy (copy, str, len);
     }
+  __A_VARIABLE = 1;
   return copy;
 }
diff --git a/newlib/libc/string/strerror.c b/newlib/libc/string/strerror.c
index d5f0a3e..ed8a5bc 100644
--- a/newlib/libc/string/strerror.c
+++ b/newlib/libc/string/strerror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /***
 **** CAUTION!!! KEEP DOC CONSISTENT---if you change text of a message
 ****            here, change two places:
@@ -894,6 +895,7 @@ _DEFUN (_strerror_r, (ptr, errnum, internal, errptr),
       break;
     }
 
+  __A_VARIABLE = 1;
   return error;
 }
 
@@ -901,6 +903,7 @@ char *
 _DEFUN(strerror, (int),
        int errnum)
 {
+  __A_VARIABLE = 1;
   return _strerror_r (_REENT, errnum, 0, NULL);
 }
 
@@ -908,5 +911,6 @@ char *
 strerror_l (int errnum, locale_t locale)
 {
   /* We don't support per-locale error messages. */
+  __A_VARIABLE = 1;
   return _strerror_r (_REENT, errnum, 0, NULL);
 }
diff --git a/newlib/libc/string/strerror_r.c b/newlib/libc/string/strerror_r.c
index d26a412..47936a2 100644
--- a/newlib/libc/string/strerror_r.c
+++ b/newlib/libc/string/strerror_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* GNU variant of strerror_r. */
 /*
 FUNCTION
@@ -79,7 +80,10 @@ _DEFUN (strerror_r, (errnum, buffer, n),
 {
   char *error = _strerror_r (_REENT, errnum, 1, NULL);
 
-  if (strlen (error) >= n)
+  if (strlen (error) >= n) {
+    __A_VARIABLE = 1;
     return error;
+  }
+  __A_VARIABLE = 1;
   return strcpy (buffer, error);
 }
diff --git a/newlib/libc/string/strlcat.c b/newlib/libc/string/strlcat.c
index 0c47bd5..969d413 100644
--- a/newlib/libc/string/strlcat.c
+++ b/newlib/libc/string/strlcat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*      $OpenBSD: strlcat.c,v 1.8 2001/05/13 15:40:15 deraadt Exp $        */
 
 /*
@@ -58,8 +59,10 @@ _DEFUN (strlcat, (dst, src, siz),
         dlen = d - dst;
         n = siz - dlen;
 
-        if (n == 0)
+        if (n == 0) {
+                __A_VARIABLE = 1;
                 return(dlen + strlen(s));
+        }
         while (*s != '\0') {
                 if (n != 1) {
                         *d++ = *s;
@@ -69,6 +72,7 @@ _DEFUN (strlcat, (dst, src, siz),
         }
         *d = '\0';
 
+        __A_VARIABLE = 1;
         return(dlen + (s - src));        /* count does not include NUL */
 }
 
diff --git a/newlib/libc/string/strlcpy.c b/newlib/libc/string/strlcpy.c
index c310016..199a7aa 100644
--- a/newlib/libc/string/strlcpy.c
+++ b/newlib/libc/string/strlcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*      $OpenBSD: strlcpy.c,v 1.5 2001/05/13 15:40:16 deraadt Exp $        */
 
 /*
@@ -65,6 +66,7 @@ _DEFUN (strlcpy, (dst, src, siz),
                         ;
         }
 
+        __A_VARIABLE = 1;
         return(s - src - 1);        /* count does not include NUL */
 }
 
diff --git a/newlib/libc/string/strlen.c b/newlib/libc/string/strlen.c
index a796d27..b6211e9 100644
--- a/newlib/libc/string/strlen.c
+++ b/newlib/libc/string/strlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strlen>>---character string length
@@ -65,8 +66,10 @@ _DEFUN (strlen, (str),
   /* Align the pointer, so we can search a word at a time.  */
   while (UNALIGNED (str))
     {
-      if (!*str)
+      if (!*str) {
+	__A_VARIABLE = 1;
 	return str - start;
+      }
       str++;
     }
 
@@ -84,5 +87,6 @@ _DEFUN (strlen, (str),
 
   while (*str)
     str++;
+  __A_VARIABLE = 1;
   return str - start;
 }
diff --git a/newlib/libc/string/strlwr.c b/newlib/libc/string/strlwr.c
index 3b73dba..a13e2a5 100644
--- a/newlib/libc/string/strlwr.c
+++ b/newlib/libc/string/strlwr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strlwr>>---force string to lowercase
@@ -42,5 +43,6 @@ _DEFUN (strlwr, (s),
     {
       *ucs = tolower(*ucs);
     }
+  __A_VARIABLE = 1;
   return s;
 }
diff --git a/newlib/libc/string/strncasecmp.c b/newlib/libc/string/strncasecmp.c
index 828f30b..7fe8ff2 100644
--- a/newlib/libc/string/strncasecmp.c
+++ b/newlib/libc/string/strncasecmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strncasecmp>>---case-insensitive character string compare
@@ -57,5 +58,6 @@ _DEFUN (strncasecmp, (s1, s2, n),
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/strncasecmp_l.c b/newlib/libc/string/strncasecmp_l.c
index 41ae582..e3ac73c 100644
--- a/newlib/libc/string/strncasecmp_l.c
+++ b/newlib/libc/string/strncasecmp_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strncasecmp_l>>---case-insensitive character string compare
@@ -52,5 +53,6 @@ strncasecmp_l (const char *s1, const char *s2, size_t n,
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/strncat.c b/newlib/libc/string/strncat.c
index 2f5a061..ce6cbdf 100644
--- a/newlib/libc/string/strncat.c
+++ b/newlib/libc/string/strncat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strncat>>---concatenate strings
@@ -81,6 +82,7 @@ _DEFUN (strncat, (s1, s2, n),
 	*s1 = '\0';
     }
 
+  __A_VARIABLE = 1;
   return s;
 #else
   char *s = s1;
diff --git a/newlib/libc/string/strncmp.c b/newlib/libc/string/strncmp.c
index 9801b7d..c0f59be 100644
--- a/newlib/libc/string/strncmp.c
+++ b/newlib/libc/string/strncmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strncmp>>---character string compare
@@ -65,8 +66,10 @@ _DEFUN (strncmp, (s1, s2, n),
 	size_t n)
 {
 #if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   while (n-- != 0 && *s1 == *s2)
     {
@@ -76,6 +79,7 @@ _DEFUN (strncmp, (s1, s2, n),
       s2++;
     }
 
+  __A_VARIABLE = 1;
   return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 #else
   unsigned long *a1;
diff --git a/newlib/libc/string/strncpy.c b/newlib/libc/string/strncpy.c
index ff5d0d4..f57853f 100644
--- a/newlib/libc/string/strncpy.c
+++ b/newlib/libc/string/strncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strncpy>>---counted copy string
@@ -86,6 +87,7 @@ _DEFUN (strncpy, (dst0, src0),
   while (count-- > 0)
     *dscan++ = '\0';
 
+  __A_VARIABLE = 1;
   return dst0;
 #else
   char *dst = dst0;
diff --git a/newlib/libc/string/strndup.c b/newlib/libc/string/strndup.c
index caa1b68..c198d81 100644
--- a/newlib/libc/string/strndup.c
+++ b/newlib/libc/string/strndup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _REENT_ONLY
 
 #include <_ansi.h>
@@ -10,6 +11,7 @@ _DEFUN (strndup, (str, n),
 	_CONST char *str _AND
 	size_t n)
 {
+  __A_VARIABLE = 1;
   return _strndup_r (_REENT, str, n);
 }
 
diff --git a/newlib/libc/string/strndup_r.c b/newlib/libc/string/strndup_r.c
index 2acf63d..6e6e92b 100644
--- a/newlib/libc/string/strndup_r.c
+++ b/newlib/libc/string/strndup_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 #include <stdlib.h>
 #include <string.h>
@@ -23,5 +24,6 @@ _DEFUN (_strndup_r, (reent_ptr, str, n),
       memcpy (copy, str, len);
       copy[len] = '\0';
     }
+  __A_VARIABLE = 1;
   return copy;
 }
diff --git a/newlib/libc/string/strnlen.c b/newlib/libc/string/strnlen.c
index ed60e93..ae591af 100644
--- a/newlib/libc/string/strnlen.c
+++ b/newlib/libc/string/strnlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 
 FUNCTION
 	<<strnlen>>---character string length
@@ -45,5 +46,6 @@ _DEFUN (strnlen, (str, n),
   while (n-- > 0 && *str)
     str++;
 
+  __A_VARIABLE = 1;
   return str - start;
 }
diff --git a/newlib/libc/string/strnstr.c b/newlib/libc/string/strnstr.c
index 947355f..031445b 100644
--- a/newlib/libc/string/strnstr.c
+++ b/newlib/libc/string/strnstr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strnstr>>---find string segment
@@ -44,8 +45,11 @@ strnstr(const char *haystack, const char *needle, size_t haystack_len)
 
   if (needle_len < haystack_len || !needle[needle_len]) {
     char *x = memmem(haystack, haystack_len, needle, needle_len);
-    if (x && !memchr(haystack, 0, x - haystack))
+    if (x && !memchr(haystack, 0, x - haystack)) {
+      __A_VARIABLE = 1;
       return x;
+    }
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/strpbrk.c b/newlib/libc/string/strpbrk.c
index 5668db3..d91d836 100644
--- a/newlib/libc/string/strpbrk.c
+++ b/newlib/libc/string/strpbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strpbrk>>---find characters in string
@@ -36,8 +37,10 @@ _DEFUN (strpbrk, (s1, s2),
 	_CONST char *s2)
 {
   _CONST char *c = s2;
-  if (!*s1)
+  if (!*s1) {
+    __A_VARIABLE = 1;
     return (char *) NULL;
+  }
 
   while (*s1)
     {
@@ -54,5 +57,6 @@ _DEFUN (strpbrk, (s1, s2),
   if (*c == '\0')
     s1 = NULL;
 
+  __A_VARIABLE = 1;
   return (char *) s1;
 }
diff --git a/newlib/libc/string/strrchr.c b/newlib/libc/string/strrchr.c
index 4f903af..b9f4b99 100644
--- a/newlib/libc/string/strrchr.c
+++ b/newlib/libc/string/strrchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strrchr>>---reverse search for character in string
@@ -55,5 +56,6 @@ _DEFUN (strrchr, (s, i),
       last = strchr(s, i);
     }
 		  
+  __A_VARIABLE = 1;
   return (char *) last;
 }
diff --git a/newlib/libc/string/strsep.c b/newlib/libc/string/strsep.c
index d3d0ad0..e0253ad 100644
--- a/newlib/libc/string/strsep.c
+++ b/newlib/libc/string/strsep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* BSD strsep function */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -15,5 +16,6 @@ _DEFUN (strsep, (source_ptr, delim),
 	register char **source_ptr _AND
 	register const char *delim)
 {
+	__A_VARIABLE = 1;
 	return __strtok_r (*source_ptr, delim, source_ptr, 0);
 }
diff --git a/newlib/libc/string/strsignal.c b/newlib/libc/string/strsignal.c
index e32c9a7..532c0f8 100644
--- a/newlib/libc/string/strsignal.c
+++ b/newlib/libc/string/strsignal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strsignal>>---convert signal number to string
@@ -72,6 +73,7 @@ _DEFUN (strsignal, (signal),
 #if defined(SIGRTMIN) && defined(SIGRTMAX)
   if ((signal >= SIGRTMIN) && (signal <= SIGRTMAX)) {
     siprintf (buffer, "Real-time signal %d", signal - SIGRTMIN);
+    __A_VARIABLE = 1;
     return buffer;
   }
 #endif
@@ -251,5 +253,6 @@ _DEFUN (strsignal, (signal),
       break;
   }
 
+  __A_VARIABLE = 1;
   return buffer;
 }
diff --git a/newlib/libc/string/strspn.c b/newlib/libc/string/strspn.c
index 32b921b..3fd2c85 100644
--- a/newlib/libc/string/strspn.c
+++ b/newlib/libc/string/strspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strspn>>---find initial match
@@ -55,5 +56,6 @@ _DEFUN (strspn, (s1, s2),
       s1++;
     }
 
+  __A_VARIABLE = 1;
   return s1 - s;
 }
diff --git a/newlib/libc/string/strstr.c b/newlib/libc/string/strstr.c
index 0480bce..bb6bf27 100644
--- a/newlib/libc/string/strstr.c
+++ b/newlib/libc/string/strstr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strstr>>---find string segment
@@ -54,8 +55,11 @@ _DEFUN (strstr, (searchee, lookfor),
   /* Less code size, but quadratic performance in the worst case.  */
   if (*searchee == 0)
     {
-      if (*lookfor)
+      if (*lookfor) {
+	__A_VARIABLE = 1;
 	return (char *) NULL;
+      }
+      __A_VARIABLE = 1;
       return (char *) searchee;
     }
 
@@ -68,6 +72,7 @@ _DEFUN (strstr, (searchee, lookfor),
 	{
 	  if (lookfor[i] == 0)
 	    {
+	      __A_VARIABLE = 1;
 	      return (char *) searchee;
 	    }
 
@@ -80,6 +85,7 @@ _DEFUN (strstr, (searchee, lookfor),
       searchee++;
     }
 
+  __A_VARIABLE = 1;
   return (char *) NULL;
 
 #else /* compilation for speed */
diff --git a/newlib/libc/string/strtok.c b/newlib/libc/string/strtok.c
index 8d07ab3..47c1993 100644
--- a/newlib/libc/string/strtok.c
+++ b/newlib/libc/string/strtok.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strtok>>, <<strtok_r>>, <<strsep>>---get next token from a string
@@ -101,6 +102,7 @@ _DEFUN (strtok, (s, delim),
 	struct _reent *reent = _REENT;
 
 	_REENT_CHECK_MISC(reent);
+	__A_VARIABLE = 1;
 	return __strtok_r (s, delim, &(_REENT_STRTOK_LAST(reent)), 1);
 }
 #endif
diff --git a/newlib/libc/string/strtok_r.c b/newlib/libc/string/strtok_r.c
index 6ace700..5abfb10 100644
--- a/newlib/libc/string/strtok_r.c
+++ b/newlib/libc/string/strtok_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1988 Regents of the University of California.
  * All rights reserved.
@@ -95,5 +96,6 @@ _DEFUN (strtok_r, (s, delim, lasts),
 	register const char *__restrict delim _AND
 	char **__restrict lasts)
 {
+	__A_VARIABLE = 1;
 	return __strtok_r (s, delim, lasts, 1);
 }
diff --git a/newlib/libc/string/strupr.c b/newlib/libc/string/strupr.c
index 350618e..bf0ec84 100644
--- a/newlib/libc/string/strupr.c
+++ b/newlib/libc/string/strupr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strupr>>---force string to uppercase
@@ -42,5 +43,6 @@ _DEFUN (strupr, (s),
     {
       *ucs = toupper(*ucs);
     }
+  __A_VARIABLE = 1;
   return s;
 }
diff --git a/newlib/libc/string/strverscmp.c b/newlib/libc/string/strverscmp.c
index 83f0532..c481900 100644
--- a/newlib/libc/string/strverscmp.c
+++ b/newlib/libc/string/strverscmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strverscmp>>---version string compare
diff --git a/newlib/libc/string/strxfrm.c b/newlib/libc/string/strxfrm.c
index edc1272..94ad23e 100644
--- a/newlib/libc/string/strxfrm.c
+++ b/newlib/libc/string/strxfrm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strxfrm>>---transform string
diff --git a/newlib/libc/string/strxfrm_l.c b/newlib/libc/string/strxfrm_l.c
index a1f4fe2..5dbac3c 100644
--- a/newlib/libc/string/strxfrm_l.c
+++ b/newlib/libc/string/strxfrm_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<strxfrm_l>>---transform string
diff --git a/newlib/libc/string/swab.c b/newlib/libc/string/swab.c
index aee0763..0f88b96 100644
--- a/newlib/libc/string/swab.c
+++ b/newlib/libc/string/swab.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<swab>>---swap adjacent bytes
@@ -41,4 +42,5 @@ _DEFUN (swab, (b1, b2, length),
     }
   if (ptr == length) /* I.e., if length is odd, */
     to[ptr-1] = 0;   /* then pad with a NUL. */
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/string/timingsafe_bcmp.c b/newlib/libc/string/timingsafe_bcmp.c
index 0b73615..44ee5c2 100644
--- a/newlib/libc/string/timingsafe_bcmp.c
+++ b/newlib/libc/string/timingsafe_bcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: timingsafe_bcmp.c,v 1.2 2014/06/10 04:17:37 deraadt Exp $	*/
 /*
  * Copyright (c) 2010 Damien Miller.  All rights reserved.
@@ -25,5 +26,6 @@ timingsafe_bcmp(const void *b1, const void *b2, size_t n)
 
 	for (; n > 0; n--)
 		ret |= *p1++ ^ *p2++;
+	__A_VARIABLE = 1;
 	return (ret != 0);
 }
diff --git a/newlib/libc/string/timingsafe_memcmp.c b/newlib/libc/string/timingsafe_memcmp.c
index 04e2ac5..cceeb3b 100644
--- a/newlib/libc/string/timingsafe_memcmp.c
+++ b/newlib/libc/string/timingsafe_memcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: timingsafe_memcmp.c,v 1.1 2014/06/13 02:12:17 matthew Exp $	*/
 /*
  * Copyright (c) 2014 Google Inc.
@@ -42,5 +43,6 @@ timingsafe_memcmp(const void *b1, const void *b2, size_t len)
                 done |= lt | gt;
         }
 
+        __A_VARIABLE = 1;
         return (res);
 }
diff --git a/newlib/libc/string/u_strerr.c b/newlib/libc/string/u_strerr.c
index 2978df0..a91d369 100644
--- a/newlib/libc/string/u_strerr.c
+++ b/newlib/libc/string/u_strerr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 
 char *
@@ -11,5 +12,6 @@ _DEFUN(_user_strerror, (errnum, internal, errptr),
   _CAST_VOID internal;
   _CAST_VOID errptr;
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/string/wcpcpy.c b/newlib/libc/string/wcpcpy.c
index e1d9ad0..7bb4375 100644
--- a/newlib/libc/string/wcpcpy.c
+++ b/newlib/libc/string/wcpcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcpcpy>>---copy a wide-character string returning a pointer to its end
@@ -37,5 +38,6 @@ _DEFUN (wcpcpy, (s1, s2),
 {
   while ((*s1++ = *s2++))
     ;
+  __A_VARIABLE = 1;
   return --s1;
 }
diff --git a/newlib/libc/string/wcpncpy.c b/newlib/libc/string/wcpncpy.c
index 87843b4..5a56e97 100644
--- a/newlib/libc/string/wcpncpy.c
+++ b/newlib/libc/string/wcpncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcpncpy>>---copy part of a wide-character string returning a pointer to its end
@@ -58,5 +59,6 @@ _DEFUN (wcpncpy, (dst, src, count),
   while (count-- > 0)
     *dst++ = L'\0';
 
+  __A_VARIABLE = 1;
   return ret ? ret : dst;
 }
diff --git a/newlib/libc/string/wcscasecmp.c b/newlib/libc/string/wcscasecmp.c
index 05f9561..a760810 100644
--- a/newlib/libc/string/wcscasecmp.c
+++ b/newlib/libc/string/wcscasecmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscasecmp>>---case-insensitive wide character string compare
@@ -54,5 +55,6 @@ _DEFUN (wcscasecmp, (s1, s2),
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/wcscasecmp_l.c b/newlib/libc/string/wcscasecmp_l.c
index 329be05..3ae5578 100644
--- a/newlib/libc/string/wcscasecmp_l.c
+++ b/newlib/libc/string/wcscasecmp_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscasecmp_l>>---case-insensitive wide character string compare
@@ -50,5 +51,6 @@ wcscasecmp_l (const wchar_t *s1, const wchar_t *s2, struct __locale_t *locale)
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/wcscat.c b/newlib/libc/string/wcscat.c
index 11afbe3..5117f21 100644
--- a/newlib/libc/string/wcscat.c
+++ b/newlib/libc/string/wcscat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscat>>---concatenate two wide-character strings
@@ -82,5 +83,6 @@ _DEFUN (wcscat, (s1, s2),
   while (*r)
     *q++ = *r++;
   *q = '\0';
+  __A_VARIABLE = 1;
   return s1;
 }
diff --git a/newlib/libc/string/wcschr.c b/newlib/libc/string/wcschr.c
index fb35d1f..1a29181 100644
--- a/newlib/libc/string/wcschr.c
+++ b/newlib/libc/string/wcschr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcschr>>---wide-character string scanning operation
@@ -75,8 +76,10 @@ _DEFUN (wcschr, (s, c),
       if (*p == c)
 	{
 	  /* LINTED interface specification */
+	  __A_VARIABLE = 1;
 	  return (wchar_t *) p;
 	}
     } while (*p++);
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/wcscmp.c b/newlib/libc/string/wcscmp.c
index 0308962..d27c536 100644
--- a/newlib/libc/string/wcscmp.c
+++ b/newlib/libc/string/wcscmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscmp>>---compare two wide-character strings
@@ -77,7 +78,10 @@ _DEFUN (wcscmp, (s1, s2),
 {
 
   while (*s1 == *s2++)
-    if (*s1++ == 0)
+    if (*s1++ == 0) {
+      __A_VARIABLE = 1;
       return (0);
+    }
+  __A_VARIABLE = 1;
   return (*s1 - *--s2);
 }
diff --git a/newlib/libc/string/wcscoll.c b/newlib/libc/string/wcscoll.c
index 726f4ca..9e277bb 100644
--- a/newlib/libc/string/wcscoll.c
+++ b/newlib/libc/string/wcscoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscoll>>---locale-specific wide-character string compare
@@ -44,5 +45,6 @@ _DEFUN (wcscoll, (a, b),
 	_CONST wchar_t *b)
 
 {
+  __A_VARIABLE = 1;
   return wcscmp (a, b);
 }
diff --git a/newlib/libc/string/wcscoll_l.c b/newlib/libc/string/wcscoll_l.c
index e71d02a..9aca2e6 100644
--- a/newlib/libc/string/wcscoll_l.c
+++ b/newlib/libc/string/wcscoll_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscoll_l>>---locale-specific wide-character string compare
@@ -39,5 +40,6 @@ PORTABILITY
 int
 wcscoll_l (const wchar_t *a, const wchar_t *b, struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return wcscmp (a, b);
 }
diff --git a/newlib/libc/string/wcscpy.c b/newlib/libc/string/wcscpy.c
index ed8b484..4fb5b4b 100644
--- a/newlib/libc/string/wcscpy.c
+++ b/newlib/libc/string/wcscpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscpy>>---copy a wide-character string 
@@ -76,5 +77,6 @@ _DEFUN (wcscpy, (s1, s2),
     *p++ = *q++;
   *p = '\0';
 
+  __A_VARIABLE = 1;
   return s1;
 }
diff --git a/newlib/libc/string/wcscspn.c b/newlib/libc/string/wcscspn.c
index 5ab9656..9b3f1ef 100644
--- a/newlib/libc/string/wcscspn.c
+++ b/newlib/libc/string/wcscspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcscspn>>---get length of a complementary wide substring 
@@ -82,5 +83,6 @@ _DEFUN (wcscspn, (s, set),
     }
 
 done:
+  __A_VARIABLE = 1;
   return (p - s);
 }
diff --git a/newlib/libc/string/wcsdup.c b/newlib/libc/string/wcsdup.c
index 90be68e..f46ffb3 100644
--- a/newlib/libc/string/wcsdup.c
+++ b/newlib/libc/string/wcsdup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsdup>>---wide character string duplicate
@@ -48,6 +49,7 @@ _wcsdup_r (struct _reent *p, const wchar_t *str)
   wchar_t *copy = _malloc_r (p, len * sizeof (wchar_t));
   if (copy)
     wmemcpy (copy, str, len);
+  __A_VARIABLE = 1;
   return copy;
 }
 
@@ -56,6 +58,7 @@ _wcsdup_r (struct _reent *p, const wchar_t *str)
 wchar_t *
 wcsdup (const wchar_t *str)
 {
+  __A_VARIABLE = 1;
   return _wcsdup_r (_REENT, str);
 }
 
diff --git a/newlib/libc/string/wcslcat.c b/newlib/libc/string/wcslcat.c
index 75c085b..bf432bb 100644
--- a/newlib/libc/string/wcslcat.c
+++ b/newlib/libc/string/wcslcat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcslcat>>---concatenate wide-character strings to specified length
@@ -91,8 +92,10 @@ _DEFUN (wcslcat, (dst, src, siz),
   dlen = d - dst;
   n = siz - dlen;
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return (dlen + wcslen (s));
+  }
   while (*s != '\0')
     {
       if (n != 1)
@@ -104,5 +107,6 @@ _DEFUN (wcslcat, (dst, src, siz),
     }
   *d = '\0';
 
+  __A_VARIABLE = 1;
   return (dlen + (s - src));	/* count does not include NUL */
 }
diff --git a/newlib/libc/string/wcslcpy.c b/newlib/libc/string/wcslcpy.c
index 21c030b..b6b0923 100644
--- a/newlib/libc/string/wcslcpy.c
+++ b/newlib/libc/string/wcslcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcslcpy>>---copy a wide-character string to specified length
@@ -98,5 +99,6 @@ _DEFUN (wcslcpy, (dst, src, siz),
 	;
     }
 
+  __A_VARIABLE = 1;
   return (s - src - 1);		/* count does not include NUL */
 }
diff --git a/newlib/libc/string/wcslen.c b/newlib/libc/string/wcslen.c
index d671551..16cd859 100644
--- a/newlib/libc/string/wcslen.c
+++ b/newlib/libc/string/wcslen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcslen>>---get wide-character string length 
@@ -68,5 +69,6 @@ _DEFUN (wcslen, (s),
   while (*p)
     p++;
 
+  __A_VARIABLE = 1;
   return p - s;
 }
diff --git a/newlib/libc/string/wcsncasecmp.c b/newlib/libc/string/wcsncasecmp.c
index c6fc08e..3e4edec 100644
--- a/newlib/libc/string/wcsncasecmp.c
+++ b/newlib/libc/string/wcsncasecmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsncasecmp>>---case-insensitive wide character string compare
@@ -57,5 +58,6 @@ _DEFUN (wcsncasecmp, (s1, s2, n),
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/wcsncasecmp_l.c b/newlib/libc/string/wcsncasecmp_l.c
index 4b360b8..0367133 100644
--- a/newlib/libc/string/wcsncasecmp_l.c
+++ b/newlib/libc/string/wcsncasecmp_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsncasecmp_l>>---case-insensitive wide character string compare
@@ -52,5 +53,6 @@ wcsncasecmp_l (const wchar_t *s1, const wchar_t *s2, size_t n,
       if (((d = c1 - c2) != 0) || (c2 == '\0'))
         break;
     }
+  __A_VARIABLE = 1;
   return d;
 }
diff --git a/newlib/libc/string/wcsncat.c b/newlib/libc/string/wcsncat.c
index b73f6e9..e8e4403 100644
--- a/newlib/libc/string/wcsncat.c
+++ b/newlib/libc/string/wcsncat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsncat>>---concatenate part of two wide-character strings 
@@ -88,5 +89,6 @@ _DEFUN (wcsncat, (s1, s2, n),
       n--;
     }
   *q = '\0';
+  __A_VARIABLE = 1;
   return s1;
 }
diff --git a/newlib/libc/string/wcsncmp.c b/newlib/libc/string/wcsncmp.c
index 1897f5c..3507441 100644
--- a/newlib/libc/string/wcsncmp.c
+++ b/newlib/libc/string/wcsncmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsncmp>>---compare part of two wide-character strings 
@@ -75,17 +76,21 @@ _DEFUN (wcsncmp, (s1, s2, n),
 	size_t n)
 {
 
-  if (n == 0)
+  if (n == 0) {
+    __A_VARIABLE = 1;
     return (0);
+  }
   do
     {
       if (*s1 != *s2++)
 	{
+	  __A_VARIABLE = 1;
 	  return (*s1 - *--s2);
 	}
       if (*s1++ == 0)
 	break;
     }
   while (--n != 0);
+  __A_VARIABLE = 1;
   return (0);
 }
diff --git a/newlib/libc/string/wcsncpy.c b/newlib/libc/string/wcsncpy.c
index 3d6d70b..ec6d7b4 100644
--- a/newlib/libc/string/wcsncpy.c
+++ b/newlib/libc/string/wcsncpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsncpy>>---copy part of a wide-character string 
@@ -55,5 +56,6 @@ _DEFUN (wcsncpy, (s1, s2, n),
     }
   while(n-- > 0)  *dscan++ = L'\0';
 
+  __A_VARIABLE = 1;
   return s1;
 }
diff --git a/newlib/libc/string/wcsnlen.c b/newlib/libc/string/wcsnlen.c
index 9d680d6..1a2dfa7 100644
--- a/newlib/libc/string/wcsnlen.c
+++ b/newlib/libc/string/wcsnlen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 
 FUNCTION
         <<wcsnlen>>---get fixed-size wide-character string length
@@ -68,6 +69,7 @@ _DEFUN(wcsnlen, (s, maxlen),
   while (*p && maxlen-- > 0)
     p++;
 
+  __A_VARIABLE = 1;
   return (size_t)(p - s);
 }
 
diff --git a/newlib/libc/string/wcspbrk.c b/newlib/libc/string/wcspbrk.c
index fbdf9e4..ced1631 100644
--- a/newlib/libc/string/wcspbrk.c
+++ b/newlib/libc/string/wcspbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcspbrk>>----scan wide-character string for a wide-character code
@@ -78,11 +79,13 @@ _DEFUN (wcspbrk, (s, set),
 	  if (*p == *q)
 	    {
 	      /* LINTED interface specification */
+	      __A_VARIABLE = 1;
 	      return (wchar_t *) p;
 	    }
 	  q++;
 	}
       p++;
     }
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/wcsrchr.c b/newlib/libc/string/wcsrchr.c
index 495d95a..3005d2c 100644
--- a/newlib/libc/string/wcsrchr.c
+++ b/newlib/libc/string/wcsrchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsrchr>>---wide-character string scanning operation 
@@ -80,9 +81,11 @@ _DEFUN (wcsrchr, (s, c),
       if (*p == c)
 	{
 	  /* LINTED interface specification */
+	  __A_VARIABLE = 1;
 	  return (wchar_t *) p;
 	}
       p--;
     }
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/wcsspn.c b/newlib/libc/string/wcsspn.c
index e83f42f..1dd7e26 100644
--- a/newlib/libc/string/wcsspn.c
+++ b/newlib/libc/string/wcsspn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsspn>>---get length of a wide substring 
@@ -84,5 +85,6 @@ _DEFUN (wcsspn, (s, set),
     }
 
 done:
+  __A_VARIABLE = 1;
   return (p - s);
 }
diff --git a/newlib/libc/string/wcsstr.c b/newlib/libc/string/wcsstr.c
index 6e89112..950d4d1 100644
--- a/newlib/libc/string/wcsstr.c
+++ b/newlib/libc/string/wcsstr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsstr>>---find a wide-character substring 
@@ -77,10 +78,13 @@ _DEFUN (wcsstr, (big, little),
   if (!*little)
     {
       /* LINTED interface specification */
+      __A_VARIABLE = 1;
       return (wchar_t *) big;
     }
-  if (wcslen (big) < wcslen (little))
+  if (wcslen (big) < wcslen (little)) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   p = big;
   q = little;
@@ -98,9 +102,11 @@ _DEFUN (wcsstr, (big, little),
       if (!*q)
 	{
 	  /* LINTED interface specification */
+	  __A_VARIABLE = 1;
 	  return (wchar_t *) p;
 	}
       p++;
     }
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/wcstok.c b/newlib/libc/string/wcstok.c
index 144b33e..e52e0c0 100644
--- a/newlib/libc/string/wcstok.c
+++ b/newlib/libc/string/wcstok.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcstok>>---get next token from a string
@@ -107,8 +108,10 @@ _DEFUN (wcstok, (s, delim, lasts),
 	wchar_t *tok;
 
 
-	if (s == NULL && (s = *lasts) == NULL)
+	if (s == NULL && (s = *lasts) == NULL) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 
 	/*
 	 * Skip (span) leading delimiters (s += wcsspn(s, delim), sort of).
@@ -121,6 +124,7 @@ cont:
 
 	if (c == L'\0') {		/* no non-delimiter characters */
 		*lasts = NULL;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 	tok = s - 1;
@@ -139,11 +143,13 @@ cont:
 				else
 					s[-1] = L'\0';
 				*lasts = s;
+				__A_VARIABLE = 1;
 				return (tok);
 			}
 		} while (sc != L'\0');
 	}
 	/* NOTREACHED */
+	__A_VARIABLE = 1;
 }
  
 /* The remainder of this file can serve as a regression test.  Compile
@@ -177,6 +183,7 @@ if(errs)  printf("FAILED %d test cases", errs);
   else    printf("passed");
 printf(".\n");
  
+__A_VARIABLE = 1;
 return(errs);
 }
 #endif /* defined(_REGRESSION_TEST) ] */
diff --git a/newlib/libc/string/wcswidth.c b/newlib/libc/string/wcswidth.c
index 6c0efe6..30cc5d0 100644
--- a/newlib/libc/string/wcswidth.c
+++ b/newlib/libc/string/wcswidth.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcswidth>>---number of column positions of a wide-character string
@@ -46,8 +47,10 @@ _DEFUN (wcswidth, (pwcs, n),
 
 {
   int w, len = 0;
-  if (!pwcs || n == 0)
+  if (!pwcs || n == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   do {
     wint_t wi = *pwcs;
 
@@ -59,15 +62,20 @@ _DEFUN (wcswidth, (pwcs, n),
       wint_t wi2;
 
       /* Extract second half and check for validity. */
-      if (--n == 0 || (wi2 = _jp2uc (*++pwcs)) < 0xdc00 || wi2 > 0xdfff)
+      if (--n == 0 || (wi2 = _jp2uc (*++pwcs)) < 0xdc00 || wi2 > 0xdfff) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       /* Compute actual unicode value to use in call to __wcwidth. */
       wi = (((wi & 0x3ff) << 10) | (wi2 & 0x3ff)) + 0x10000;
     }
 #endif /* _MB_CAPABLE */
-    if ((w = __wcwidth (wi)) < 0)
+    if ((w = __wcwidth (wi)) < 0) {
+      __A_VARIABLE = 1;
       return -1;
+    }
     len += w;
   } while (*pwcs++ && --n > 0);
+  __A_VARIABLE = 1;
   return len;
 }
diff --git a/newlib/libc/string/wcsxfrm.c b/newlib/libc/string/wcsxfrm.c
index d267d27..2868844 100644
--- a/newlib/libc/string/wcsxfrm.c
+++ b/newlib/libc/string/wcsxfrm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsxfrm>>---locale-specific wide-character string transformation
@@ -49,5 +50,6 @@ _DEFUN (wcsxfrm, (a, b, n),
 	size_t n)
 
 {
+  __A_VARIABLE = 1;
   return wcslcpy (a, b, n);
 }
diff --git a/newlib/libc/string/wcsxfrm_l.c b/newlib/libc/string/wcsxfrm_l.c
index c44b0d6..1ec4847 100644
--- a/newlib/libc/string/wcsxfrm_l.c
+++ b/newlib/libc/string/wcsxfrm_l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcsxfrm_l>>---locale-specific wide-character string transformation
@@ -43,5 +44,6 @@ size_t
 wcsxfrm_l (wchar_t *__restrict a, const wchar_t *__restrict b, size_t n,
 	   struct __locale_t *locale)
 {
+  __A_VARIABLE = 1;
   return wcslcpy (a, b, n);
 }
diff --git a/newlib/libc/string/wcwidth.c b/newlib/libc/string/wcwidth.c
index ac5c47f..74d6b18 100644
--- a/newlib/libc/string/wcwidth.c
+++ b/newlib/libc/string/wcwidth.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wcwidth>>---number of column positions of a wide-character code
@@ -282,34 +283,47 @@ _DEFUN (__wcwidth, (ucs),
   };
 
   /* Test for NUL character */
-  if (ucs == 0)
+  if (ucs == 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* Test for printable ASCII characters */
-  if (ucs >= 0x20 && ucs < 0x7f)
+  if (ucs >= 0x20 && ucs < 0x7f) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Test for control characters */
-  if (ucs < 0xa0)
+  if (ucs < 0xa0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* Test for surrogate pair values. */
-  if (ucs >= 0xd800 && ucs <= 0xdfff)
+  if (ucs >= 0xd800 && ucs <= 0xdfff) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* binary search in table of ambiguous characters */
   if (__locale_cjk_lang ()
       && bisearch(ucs, ambiguous,
-		  sizeof(ambiguous) / sizeof(struct interval) - 1))
+		  sizeof(ambiguous) / sizeof(struct interval) - 1)) {
+    __A_VARIABLE = 1;
     return 2;
+  }
 
   /* binary search in table of non-spacing characters */
   if (bisearch(ucs, combining,
-	       sizeof(combining) / sizeof(struct interval) - 1))
+	       sizeof(combining) / sizeof(struct interval) - 1)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* if we arrive here, ucs is not a combining or C0/C1 control character */
 
+  __A_VARIABLE = 1;
   return 1 + 
     (ucs >= 0x1100 &&
      (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
@@ -342,5 +356,6 @@ _DEFUN (wcwidth, (wc),
 #ifdef _MB_CAPABLE
   wi = _jp2uc (wi);
 #endif /* _MB_CAPABLE */
+  __A_VARIABLE = 1;
   return __wcwidth (wi);
 }
diff --git a/newlib/libc/string/wmemchr.c b/newlib/libc/string/wmemchr.c
index b582b89..a35b765 100644
--- a/newlib/libc/string/wmemchr.c
+++ b/newlib/libc/string/wmemchr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wmemchr>>---find a wide character in memory
@@ -81,9 +82,11 @@ _DEFUN (wmemchr, (s, c, n),
       if (*s == c)
 	{
 	  /* LINTED const castaway */
+	  __A_VARIABLE = 1;
 	  return (wchar_t *) s;
 	}
       s++;
     }
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/string/wmemcmp.c b/newlib/libc/string/wmemcmp.c
index af9ee32..5745776 100644
--- a/newlib/libc/string/wmemcmp.c
+++ b/newlib/libc/string/wmemcmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wmemcmp>>---compare wide characters in memory 
@@ -80,10 +81,12 @@ _DEFUN (wmemcmp, (s1, s2, n),
       if (*s1 != *s2)
 	{
 	  /* wchar might be unsigned */
+	  __A_VARIABLE = 1;
 	  return *s1 > *s2 ? 1 : -1;
 	}
       s1++;
       s2++;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/string/wmemcpy.c b/newlib/libc/string/wmemcpy.c
index a57d6a5..99af004 100644
--- a/newlib/libc/string/wmemcpy.c
+++ b/newlib/libc/string/wmemcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wmemcpy>>---copy wide characters in memory 
@@ -73,5 +74,6 @@ _DEFUN (wmemcpy, (d, s, n),
 	size_t n)
 {
 
+  __A_VARIABLE = 1;
   return (wchar_t *) memcpy (d, s, n * sizeof (wchar_t));
 }
diff --git a/newlib/libc/string/wmemmove.c b/newlib/libc/string/wmemmove.c
index e20a26a..422f67e 100644
--- a/newlib/libc/string/wmemmove.c
+++ b/newlib/libc/string/wmemmove.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 	<<wmemmove>>---copy wide characters in memory with overlapping areas 
@@ -78,5 +79,6 @@ _DEFUN (wmemmove, (d, s, n),
 	size_t n)
 {
 
+  __A_VARIABLE = 1;
   return (wchar_t *) memmove (d, s, n * sizeof (wchar_t));
 }
diff --git a/newlib/libc/string/wmemset.c b/newlib/libc/string/wmemset.c
index 0af6f91..a21f691 100644
--- a/newlib/libc/string/wmemset.c
+++ b/newlib/libc/string/wmemset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
        <<wmemset>>---set wide characters in memory 
@@ -78,5 +79,6 @@ _DEFUN(wmemset, (s, c, n),
 		*p = c;
 		p++;
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
diff --git a/newlib/libc/string/xpg_strerror_r.c b/newlib/libc/string/xpg_strerror_r.c
index e503880..85ee2a4 100644
--- a/newlib/libc/string/xpg_strerror_r.c
+++ b/newlib/libc/string/xpg_strerror_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* POSIX variant of strerror_r. */
 #undef __STRICT_ANSI__
 #include <errno.h>
@@ -12,15 +13,19 @@ _DEFUN (__xpg_strerror_r, (errnum, buffer, n),
   char *error;
   int result = 0;
 
-  if (!n)
+  if (!n) {
+    __A_VARIABLE = 1;
     return ERANGE;
+  }
   error = _strerror_r (_REENT, errnum, 1, &result);
   if (strlen (error) >= n)
     {
       memcpy (buffer, error, n - 1);
       buffer[n - 1] = '\0';
+      __A_VARIABLE = 1;
       return ERANGE;
     }
   strcpy (buffer, error);
+  __A_VARIABLE = 1;
   return (result || *error) ? result : EINVAL;
 }
diff --git a/newlib/libc/sys/a29khif/getpid.c b/newlib/libc/sys/a29khif/getpid.c
index 99d88bd..255d3ff 100644
--- a/newlib/libc/sys/a29khif/getpid.c
+++ b/newlib/libc/sys/a29khif/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stub for getpid.  */
 
 #include <_ansi.h>
@@ -8,5 +9,6 @@
 int
 _DEFUN_VOID (_getpid)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/sys/a29khif/kill.c b/newlib/libc/sys/a29khif/kill.c
index ff9fe54..11d69bb 100644
--- a/newlib/libc/sys/a29khif/kill.c
+++ b/newlib/libc/sys/a29khif/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Stub for kill.  */
 
 #include <_ansi.h>
@@ -12,10 +13,14 @@ _DEFUN (_kill, (pid, sig),
 {
   if (pid == 1 || pid < 0)
     {
-      if (sig == 0)
+      if (sig == 0) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
+      __A_VARIABLE = 1;
       return raise (sig);
     }
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/arm/access.c b/newlib/libc/sys/arm/access.c
index 980682e..b71fa38 100644
--- a/newlib/libc/sys/arm/access.c
+++ b/newlib/libc/sys/arm/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/newlib/libc/sys/arm/aeabi_atexit.c b/newlib/libc/sys/arm/aeabi_atexit.c
index 4b600e2..4142c3e 100644
--- a/newlib/libc/sys/arm/aeabi_atexit.c
+++ b/newlib/libc/sys/arm/aeabi_atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 /* Register a function to be called by exit or when a shared library
@@ -6,5 +7,6 @@
 int
 __aeabi_atexit (void *arg, void (*func) (void *), void *d)
 {
+  __A_VARIABLE = 1;
   return __cxa_atexit (func, arg, d);
 }
diff --git a/newlib/libc/sys/arm/libcfunc.c b/newlib/libc/sys/arm/libcfunc.c
index 77583b7..a6cb0b2 100644
--- a/newlib/libc/sys/arm/libcfunc.c
+++ b/newlib/libc/sys/arm/libcfunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support files for GNU libc.  Files in the C namespace go here.
    Files in the system namespace (ie those that start with an underscore)
    go in syscalls.c.
@@ -12,4 +13,5 @@
 void
 alarm (void)
 {
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/arm/syscalls.c b/newlib/libc/sys/arm/syscalls.c
index 04dde45..62617d1 100644
--- a/newlib/libc/sys/arm/syscalls.c
+++ b/newlib/libc/sys/arm/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support files for GNU libc.  Files in the system namespace go here.
    Files in the C namespace (ie those that do not start with an
    underscore) go in .c.  */
@@ -90,6 +91,7 @@ findslot (int fh)
   for (i = 0; i < MAX_OPEN_FILES; i ++)
     if (openfiles[i].handle == fh)
       break;
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -99,13 +101,20 @@ remap_handle (int fh)
 {
   CHECK_INIT(_REENT);
 
-  if (fh == STDIN_FILENO)
+  if (fh == STDIN_FILENO) {
+    __A_VARIABLE = 1;
     return monitor_stdin;
-  if (fh == STDOUT_FILENO)
+  }
+  if (fh == STDOUT_FILENO) {
+    __A_VARIABLE = 1;
     return monitor_stdout;
-  if (fh == STDERR_FILENO)
+  }
+  if (fh == STDERR_FILENO) {
+    __A_VARIABLE = 1;
     return monitor_stderr;
+  }
 
+  __A_VARIABLE = 1;
   return fh - FILE_HANDLE_OFFSET;
 }
 
@@ -152,6 +161,7 @@ initialise_monitor_handles (void)
   openfiles[0].pos = 0;
   openfiles[1].handle = monitor_stdout;
   openfiles[1].pos = 0;
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -168,14 +178,18 @@ static int
 error (int result)
 {
   errno = get_errno ();
+  __A_VARIABLE = 1;
   return result;
 }
 
 static int
 wrap (int result)
 {
-  if (result == -1)
+  if (result == -1) {
+    __A_VARIABLE = 1;
     return error (-1);
+  }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -210,13 +224,16 @@ _read (int file,
   int slot = findslot (remap_handle (file));
   int x = _swiread (file, ptr, len);
 
-  if (x < 0)
+  if (x < 0) {
+    __A_VARIABLE = 1;
     return error (-1);
+  }
 
   if (slot != MAX_OPEN_FILES)
     openfiles [slot].pos += len - x;
 
   /* x == len is not an error, at least if we want feof() to work.  */
+  __A_VARIABLE = 1;
   return len - x;
 }
 
@@ -234,8 +251,10 @@ _swilseek (int file,
 
   if (dir == SEEK_CUR)
     {
-      if (slot == MAX_OPEN_FILES)
+      if (slot == MAX_OPEN_FILES) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       ptr = openfiles[slot].pos + ptr;
       dir = SEEK_SET;
     }
@@ -272,6 +291,7 @@ _swilseek (int file,
     openfiles[slot].pos = ptr;
 
   /* This is expected to return the position in the file.  */
+  __A_VARIABLE = 1;
   return res == 0 ? ptr : -1;
 }
 
@@ -280,6 +300,7 @@ _lseek (int file,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return wrap (_swilseek (file, ptr, dir));
 }
 
@@ -315,12 +336,15 @@ _write (int    file,
   int slot = findslot (remap_handle (file));
   int x = _swiwrite (file, ptr,len);
 
-  if (x == -1 || x == len)
+  if (x == -1 || x == len) {
+    __A_VARIABLE = 1;
     return error (-1);
+  }
   
   if (slot != MAX_OPEN_FILES)
     openfiles[slot].pos += len - x;
   
+  __A_VARIABLE = 1;
   return len - x;
 }
 
@@ -337,8 +361,10 @@ _swiopen (const char * path,
   
   int i = findslot (-1);
   
-  if (i == MAX_OPEN_FILES)
+  if (i == MAX_OPEN_FILES) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* The flags are Unix-style, so we need to convert them.  */
 #ifdef O_BINARY
@@ -381,6 +407,7 @@ _swiopen (const char * path,
       openfiles[i].pos = 0;
     }
 
+  __A_VARIABLE = 1;
   return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
 }
 
@@ -389,6 +416,7 @@ _open (const char * path,
        int          flags,
        ...)
 {
+  __A_VARIABLE = 1;
   return wrap (_swiopen (path, flags));
 }
 
@@ -411,6 +439,7 @@ _swiclose (int file)
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return wrap (_swiclose (file));
 }
 
@@ -442,11 +471,13 @@ _exit (int status)
      Note: The RDI implementation of _kill throws away both its
      arguments.  */
   _kill(status, -1);
+  __A_VARIABLE = 1;
 }
 
 int
 _getpid (int n)
 {
+  __A_VARIABLE = 1;
   return 1;
   n = n;
 }
@@ -492,6 +523,7 @@ _fstat (int file, struct stat * st)
   memset (st, 0, sizeof (* st));
   st->st_mode = S_IFCHR;
   st->st_blksize = 1024;
+  __A_VARIABLE = 1;
   return 0;
   file = file;
 }
@@ -502,19 +534,23 @@ int _stat (const char *fname, struct stat *st)
 
   /* The best we can do is try to open the file readonly.  If it exists,
      then we can guess a few things about it.  */
-  if ((file = _open (fname, O_RDONLY)) < 0)
+  if ((file = _open (fname, O_RDONLY)) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   memset (st, 0, sizeof (* st));
   st->st_mode = S_IFREG | S_IREAD;
   st->st_blksize = 1024;
   _swiclose (file); /* Not interested in the error.  */
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _link (void)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -534,6 +570,7 @@ _unlink (const char *path)
 void
 _raise (void)
 {
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -563,6 +600,7 @@ _gettimeofday (struct timeval * tp, void * tzvp)
       tzp->tz_dsttime = 0;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -586,6 +624,7 @@ _times (struct tms * tp)
       tp->tms_cstime = 0;	/* system time, children */
     }
   
+  __A_VARIABLE = 1;
   return timeval;
 };
 
diff --git a/newlib/libc/sys/d10v/creat.c b/newlib/libc/sys/d10v/creat.c
index 62ec5ea..e0b064b 100644
--- a/newlib/libc/sys/d10v/creat.c
+++ b/newlib/libc/sys/d10v/creat.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 int
 creat(path, mode)
      const char *path;
      int mode;
 {
+  __A_VARIABLE = 1;
   return _creat (path, mode);
 }
diff --git a/newlib/libc/sys/d10v/syscalls.c b/newlib/libc/sys/d10v/syscalls.c
index 4c71db3..25f5044 100644
--- a/newlib/libc/sys/d10v/syscalls.c
+++ b/newlib/libc/sys/d10v/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* syscalls.c - non-trap system calls for D10V
  *
  * This file contains system calls that cannot be implemented with
@@ -45,6 +46,7 @@ _sbrk (int incr)
       abort ();
     }
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -53,6 +55,7 @@ _fstat (int file,
 	struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -60,18 +63,21 @@ int
 _unlink ()
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 _isatty (int fd)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 void
 _raise ()
 {
+	__A_VARIABLE = 1;
 }
 
 /* If this library is compiled with -mint32, provide conversion functions for
@@ -82,6 +88,7 @@ extern short _read16 (short fd, void *ptr, short len);
 int
 _read (int fd, void *ptr, size_t len)
 {
+  __A_VARIABLE = 1;
   return _read16 ((short)fd, ptr, (short)len);
 }
 
@@ -89,6 +96,7 @@ extern short _write16 (short fd, const void *ptr, short len);
 int
 _write (int fd, const void *ptr, size_t len)
 {
+  __A_VARIABLE = 1;
   return _write16 ((short)fd, ptr, (short)len);
 }
 
@@ -96,6 +104,7 @@ extern short _lseek16 (short fd, long offset, short whence);
 int
 _lseek (int fd, off_t offset, int whence)
 {
+  __A_VARIABLE = 1;
   return _lseek16 ((short)fd, offset, (short)whence);
 }
 
@@ -103,6 +112,7 @@ extern short _close16 (short fd);
 int
 _close (int fd)
 {
+  __A_VARIABLE = 1;
   return _close16 ((short)fd);
 }
 
@@ -110,6 +120,7 @@ extern short _open16 (const char *name, short flags, short mode);
 int
 _open (const char *name, int flags, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return _open16 (name, (short)flags, (short)mode);
 }
 
@@ -117,6 +128,7 @@ extern short _creat16 (const char *name, mode_t mode);
 int
 _creat (const char *name, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return _creat16 (name, mode);
 }
 
@@ -125,12 +137,14 @@ void
 _exit (int status)
 {
   _exit16 ((short)status);
+  __A_VARIABLE = 1;
 }
 
 extern short _stat16 (const char *name, struct stat *stat_pkt);
 int
 _stat (const char *name, struct stat *stat_pkt)
 {
+  __A_VARIABLE = 1;
   return _stat16 (name, stat_pkt);
 }
 
@@ -138,6 +152,7 @@ extern short _chmod16 (const char *name, short mode);
 int
 _chmod (const char *name, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return _chmod16 (name, (short)mode);
 }
 
@@ -145,6 +160,7 @@ extern short _chown16 (const char *name, short uid, short gid);
 int
 _chown (const char *name, uid_t uid, gid_t gid)
 {
+  __A_VARIABLE = 1;
   return _chown16 (name, (short)uid, (short)gid);
 }
 
@@ -152,6 +168,7 @@ extern short _fork16 (void);
 int
 _fork (void)
 {
+  __A_VARIABLE = 1;
   return _fork16 ();
 }
 
@@ -175,6 +192,7 @@ extern short _execve16 (const char *filename, const char *argv [], const char *e
 int
 _execve (const char *filename, const char *argv [], const char *envp[])
 {
+  __A_VARIABLE = 1;
   return _execve16 (filename, argv, envp);
 }
 
@@ -182,6 +200,7 @@ extern short _execv16 (const char *filename, const char *argv []);
 int
 _execv (const char *filename, const char *argv [])
 {
+  __A_VARIABLE = 1;
   return _execv16 (filename, argv);
 }
 
@@ -197,6 +216,7 @@ _pipe (int fds[])
       fds[1] = fds16[1];
     }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -204,6 +224,7 @@ extern short _getpid16 (void);
 int
 _getpid (void)
 {
+  __A_VARIABLE = 1;
   return _getpid16 ();
 }
 
@@ -211,6 +232,7 @@ extern short _kill16 (short pid, short sig);
 int
 _kill (int pid, int sig)
 {
+  __A_VARIABLE = 1;
   return _kill16 ((short)pid, (short)sig);
 }
 #endif
diff --git a/newlib/libc/sys/decstation/_main.c b/newlib/libc/sys/decstation/_main.c
index 6487808..4191ec4 100644
--- a/newlib/libc/sys/decstation/_main.c
+++ b/newlib/libc/sys/decstation/_main.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 
 __main()
 {
   
 
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/epiphany/e_printf.c b/newlib/libc/sys/epiphany/e_printf.c
index a93c343..db0bf09 100644
--- a/newlib/libc/sys/epiphany/e_printf.c
+++ b/newlib/libc/sys/epiphany/e_printf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* e_printf.c
 
    Copyright (c) 2011, Adapteva, Inc.
@@ -37,6 +38,7 @@ int trap_7( char *s , int _bsize, int _argsize) {
 	volatile register unsigned argsize asm("r2") = _argsize;
 	volatile register int result asm("r0");
 	__asm__ __volatile__ ("trap 7" : "=r" (result) : "r" (buff_adrr), "r" (bsize) , "r" (argsize));
+	__A_VARIABLE = 1;
 	return result;
 
 }
@@ -49,6 +51,7 @@ volatile static int*fp_int =0;
 volatile int getIntFromFloat(float *f) {
 	fp_int= (int*)f;
 
+	__A_VARIABLE = 1;
 	return *fp_int;
 }
 
@@ -145,6 +148,7 @@ int e_printf(const char *fmt, ...) {
 
 	//printf(" +++  %d %d \n" , strlen(fmt), pos);
 
+	__A_VARIABLE = 1;
 	return trap_7((char*)buf ,fmt_len, pos) ;
 	//return 1;
 }
diff --git a/newlib/libc/sys/h8300hms/crt1.c b/newlib/libc/sys/h8300hms/crt1.c
index bd4ccf2..6a50d40 100644
--- a/newlib/libc/sys/h8300hms/crt1.c
+++ b/newlib/libc/sys/h8300hms/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
 #ifndef __ELF__
@@ -15,4 +16,5 @@ void __main ()
 
     }
 #endif
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/h8300hms/misc.c b/newlib/libc/sys/h8300hms/misc.c
index 6021b5c..aa8ba91 100644
--- a/newlib/libc/sys/h8300hms/misc.c
+++ b/newlib/libc/sys/h8300hms/misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Misc. operating system stubs.  */
 
 #include <_ansi.h>
@@ -10,11 +11,13 @@
 int _DEFUN(_raise,(sig),
 	   int sig)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int _DEFUN(_getpid,(),)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -30,5 +33,6 @@ int _DEFUN(_kill,(pid, sig),
 	 The format of r0 is defined by devo/include/wait.h.  */
       asm ("mov.w %0,r0\n\tsleep" : : "r" (sig2) : "r0");
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/h8300hms/sbrk.c b/newlib/libc/sys/h8300hms/sbrk.c
index 1456a67..fddf0a8 100644
--- a/newlib/libc/sys/h8300hms/sbrk.c
+++ b/newlib/libc/sys/h8300hms/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -23,6 +24,7 @@ caddr_t
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t)prev_heap_end;
 }
 
diff --git a/newlib/libc/sys/h8300hms/syscalls.c b/newlib/libc/sys/h8300hms/syscalls.c
index b9ec17a..2d45c84 100644
--- a/newlib/libc/sys/h8300hms/syscalls.c
+++ b/newlib/libc/sys/h8300hms/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Operating system stubs, set up for the MRI simulator */
 
 #include <_ansi.h>
@@ -6,6 +7,7 @@
 int _isatty(file)
      int file;
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -14,5 +16,6 @@ _unlink (path)
      const char *path;
 {
   errno = EIO;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/h8500hms/crt0.c b/newlib/libc/sys/h8500hms/crt0.c
index fa7d1b9..1bb3679 100644
--- a/newlib/libc/sys/h8500hms/crt0.c
+++ b/newlib/libc/sys/h8500hms/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 extern char _start_bss;
 extern char end;
@@ -16,6 +17,7 @@ start()
   /* Can't have anything else in here, since the fp won't be set up
      so local variables won't work */
   zeroandrun();
+  __A_VARIABLE = 1;
 }
 
 static
@@ -29,4 +31,5 @@ zeroandrun()
     }
   main();
   _exit();
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/h8500hms/misc.c b/newlib/libc/sys/h8500hms/misc.c
index a791704..00c623c 100644
--- a/newlib/libc/sys/h8500hms/misc.c
+++ b/newlib/libc/sys/h8500hms/misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Misc. operating system stubs.  */
 
 #include <_ansi.h>
@@ -11,11 +12,13 @@
 int _DEFUN(_raise,(sig),
 	   int sig)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int _DEFUN(_getpid,(),)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -25,5 +28,6 @@ int _DEFUN(_kill,(pid, sig),
 {
   if (sig == SIGABRT)
     asm ("mov.w #34,r3; trapa #15");
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/h8500hms/syscalls.c b/newlib/libc/sys/h8500hms/syscalls.c
index 0f3471a..4685910 100644
--- a/newlib/libc/sys/h8500hms/syscalls.c
+++ b/newlib/libc/sys/h8500hms/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include <_ansi.h>
 #include <sys/types.h>
@@ -11,6 +12,7 @@ _read (file, ptr, len)
      size_t len;
 
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -22,6 +24,7 @@ _lseek (file, ptr, dir)
      int dir;
 
 {
+  __A_VARIABLE = 1;
   return 0;
 
 }
@@ -35,6 +38,7 @@ writechar (c)
   register int n asm ("r3");
   n = c;
 asm ("clr.w	r1;mov.w %0,r0; mov.w #6,r3; trapa #15": :"g" (n) : "r3","r1","r0");
+__A_VARIABLE = 1;
 }
 
 
@@ -52,6 +56,7 @@ _write (file, ptr, len)
     {
       writechar (*ptr++);
     }
+  __A_VARIABLE = 1;
   return len;
 
 }
@@ -63,6 +68,7 @@ _close (file)
      int file;
 {
 
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -87,6 +93,7 @@ _sbrk (incr)
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -96,6 +103,7 @@ int
 _isatty (file)
      int file;
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -108,6 +116,7 @@ _fstat (file, stat)
 
 {
   stat->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -117,6 +126,7 @@ _open (path, flags)
      int flags;
 
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -126,4 +136,5 @@ _exit (status)
      int status;
 {
   asm (" mov.w #33,r3; trapa #15");
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/aio.c b/newlib/libc/sys/linux/aio.c
index 9a2e4ce..9ba6ff0 100644
--- a/newlib/libc/sys/linux/aio.c
+++ b/newlib/libc/sys/linux/aio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/aio.c - asychronous I/O */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -14,6 +15,7 @@ int
 aio_cancel (int fd, struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -21,6 +23,7 @@ int
 aio_error (const struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -28,6 +31,7 @@ int
 aio_fsync (int op, struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -35,6 +39,7 @@ int
 aio_read (struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -42,6 +47,7 @@ ssize_t
 aio_return (struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -50,6 +56,7 @@ aio_suspend (const struct aiocb *const list[], int nent,
              const struct timespec *timeout)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -57,6 +64,7 @@ int
 aio_write (struct aiocb *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -65,6 +73,7 @@ lio_listio (int mode, struct aiocb * const list[], int nent,
             struct sigevent *sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -73,5 +82,6 @@ void
 aio_init (const struct aioinit *INIT)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/aio64.c b/newlib/libc/sys/linux/aio64.c
index 5a9cdd9..dd2df46 100644
--- a/newlib/libc/sys/linux/aio64.c
+++ b/newlib/libc/sys/linux/aio64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/aio64.c - asychronous I/O */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -12,6 +13,7 @@ int
 aio_cancel64 (int fd, struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -19,6 +21,7 @@ int
 aio_error64 (const struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -26,6 +29,7 @@ int
 aio_fsync64 (int op, struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -33,6 +37,7 @@ int
 aio_read64 (struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -40,6 +45,7 @@ ssize_t
 aio_return64 (struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -48,6 +54,7 @@ aio_suspend64 (const struct aiocb64 *const list[], int nent,
              const struct timespec *timeout)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -55,6 +62,7 @@ int
 aio_write64 (struct aiocb64 *cb)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -63,5 +71,6 @@ lio_listio64 (int mode, struct aiocb64 * const list[], int nent,
               struct sigevent *sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/linux/argp/argp-ba.c b/newlib/libc/sys/linux/argp/argp-ba.c
index f5270c8..8443e95 100644
--- a/newlib/libc/sys/linux/argp/argp-ba.c
+++ b/newlib/libc/sys/linux/argp/argp-ba.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Default definition for ARGP_PROGRAM_BUG_ADDRESS.
    Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/argp/argp-eexst.c b/newlib/libc/sys/linux/argp/argp-eexst.c
index a94c346..5e1a6ae 100644
--- a/newlib/libc/sys/linux/argp/argp-eexst.c
+++ b/newlib/libc/sys/linux/argp/argp-eexst.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Default definition for ARGP_ERR_EXIT_STATUS
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/argp/argp-fmtstream.c b/newlib/libc/sys/linux/argp/argp-fmtstream.c
index f783b80..4b1be14 100644
--- a/newlib/libc/sys/linux/argp/argp-fmtstream.c
+++ b/newlib/libc/sys/linux/argp/argp-fmtstream.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Word-wrapping and line-truncating streams
    Copyright (C) 1997, 1998, 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -85,6 +86,7 @@ __argp_make_fmtstream (FILE *stream,
 	}
     }
 
+  __A_VARIABLE = 1;
   return fs;
 }
 #ifdef weak_alias
@@ -107,6 +109,7 @@ __argp_fmtstream_free (argp_fmtstream_t fs)
     }
   free (fs->buf);
   free (fs);
+  __A_VARIABLE = 1;
 }
 #ifdef weak_alias
 weak_alias (__argp_fmtstream_free, argp_fmtstream_free)
@@ -339,6 +342,7 @@ __argp_fmtstream_update (argp_fmtstream_t fs)
 
   /* Remember that we've scanned as far as the end of the buffer.  */
   fs->point_offs = fs->p - fs->buf;
+  __A_VARIABLE = 1;
 }
 
 /* Ensure that FS has space for AMOUNT more bytes in its buffer, either by
@@ -407,8 +411,10 @@ __argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)
     {
       va_list args;
 
-      if (! __argp_fmtstream_ensure (fs, size_guess))
+      if (! __argp_fmtstream_ensure (fs, size_guess)) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
 
       va_start (args, fmt);
       avail = fs->end - fs->p;
@@ -421,6 +427,7 @@ __argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)
 
   fs->p += out;
 
+  __A_VARIABLE = 1;
   return out;
 }
 #ifdef weak_alias
diff --git a/newlib/libc/sys/linux/argp/argp-fs-xinl.c b/newlib/libc/sys/linux/argp/argp-fs-xinl.c
index 9b836d1..04c61f3 100644
--- a/newlib/libc/sys/linux/argp/argp-fs-xinl.c
+++ b/newlib/libc/sys/linux/argp/argp-fs-xinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Real definitions for extern inline functions in argp-fmtstream.h
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/argp/argp-help.c b/newlib/libc/sys/linux/argp/argp-help.c
index d152369..3bd3b26 100644
--- a/newlib/libc/sys/linux/argp/argp-help.c
+++ b/newlib/libc/sys/linux/argp/argp-help.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Hierarchial argument parsing help output
    Copyright (C) 1995-2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -234,6 +235,7 @@ fill_in_uparams (const struct argp_state *state)
 	    break;
 	  }
       }
+      __A_VARIABLE = 1;
 }
 
 /* Returns true if OPT hasn't been marked invisible.  Visibility only affects
@@ -471,6 +473,7 @@ make_hol (const struct argp *argp, struct hol_cluster *cluster)
       *so = '\0';		/* null terminated so we can find the length */
     }
 
+  __A_VARIABLE = 1;
   return hol;
 }
 
@@ -495,6 +498,7 @@ hol_add_cluster (struct hol *hol, int group, const char *header, int index,
       cl->next = hol->clusters;
       hol->clusters = cl;
     }
+  __A_VARIABLE = 1;
   return cl;
 }
 
@@ -518,6 +522,7 @@ hol_free (struct hol *hol)
     }
 
   free (hol);
+  __A_VARIABLE = 1;
 }
 
 static inline int
@@ -542,6 +547,7 @@ hol_entry_short_iterate (const struct hol_entry *entry,
 	so++;
       }
 
+  __A_VARIABLE = 1;
   return val;
 }
 
@@ -565,6 +571,7 @@ hol_entry_long_iterate (const struct hol_entry *entry,
 	  val = (*func)(opt, real, domain, cookie);
       }
 
+  __A_VARIABLE = 1;
   return val;
 }
 
@@ -573,6 +580,7 @@ static inline int
 until_short (const struct argp_option *opt, const struct argp_option *real,
 	     const char *domain, void *cookie)
 {
+  __A_VARIABLE = 1;
   return oshort (opt) ? opt->key : 0;
 }
 
@@ -580,6 +588,7 @@ until_short (const struct argp_option *opt, const struct argp_option *real,
 static char
 hol_entry_first_short (const struct hol_entry *entry)
 {
+  __A_VARIABLE = 1;
   return hol_entry_short_iterate (entry, until_short,
 				  entry->argp->argp_domain, 0);
 }
@@ -591,8 +600,11 @@ hol_entry_first_long (const struct hol_entry *entry)
   const struct argp_option *opt;
   unsigned num;
   for (opt = entry->opt, num = entry->num; num > 0; opt++, num--)
-    if (opt->name && ovisible (opt))
+    if (opt->name && ovisible (opt)) {
+      __A_VARIABLE = 1;
       return opt->name;
+    }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -629,6 +641,7 @@ hol_set_group (struct hol *hol, const char *name, int group)
   struct hol_entry *entry = hol_find_entry (hol, name);
   if (entry)
     entry->group = group;
+  __A_VARIABLE = 1;
 }
 
 /* Order by group:  0, 1, 2, ..., n, -m, ..., -2, -1.
@@ -661,6 +674,7 @@ hol_cluster_cmp (const struct hol_cluster *cl1, const struct hol_cluster *cl2)
   while (cl1->parent != cl2->parent)
     cl1 = cl1->parent, cl2 = cl2->parent;
 
+  __A_VARIABLE = 1;
   return group_cmp (cl1->group, cl2->group, cl2->index - cl1->index);
 }
 
@@ -671,6 +685,7 @@ hol_cluster_base (struct hol_cluster *cl)
 {
   while (cl->parent)
     cl = cl->parent;
+  __A_VARIABLE = 1;
   return cl;
 }
 
@@ -681,6 +696,7 @@ hol_cluster_is_child (const struct hol_cluster *cl1,
 {
   while (cl1 && cl1 != cl2)
     cl1 = cl1->parent;
+  __A_VARIABLE = 1;
   return cl1 == cl2;
 }
 
@@ -699,6 +715,7 @@ canon_doc_option (const char **name)
   /* Skip until part of name used for sorting.  */
   while (**name && !isalnum (**name))
     (*name)++;
+  __A_VARIABLE = 1;
   return non_opt;
 }
 
@@ -781,6 +798,7 @@ hol_entry_cmp (const struct hol_entry *entry1,
 static int
 hol_entry_qcmp (const void *entry1_v, const void *entry2_v)
 {
+  __A_VARIABLE = 1;
   return hol_entry_cmp (entry1_v, entry2_v);
 }
 
@@ -793,6 +811,7 @@ hol_sort (struct hol *hol)
   if (hol->num_entries > 0)
     qsort (hol->entries, hol->num_entries, sizeof (struct hol_entry),
 	   hol_entry_qcmp);
+  __A_VARIABLE = 1;
 }
 
 /* Append MORE to HOL, destroying MORE in the process.  Options in HOL shadow
@@ -885,6 +904,7 @@ hol_append (struct hol *hol, struct hol *more)
     }
 
   hol_free (more);
+  __A_VARIABLE = 1;
 }
 
 /* Inserts enough spaces to make sure STREAM is at column COL.  */
@@ -894,6 +914,7 @@ indent_to (argp_fmtstream_t stream, unsigned col)
   int needed = col - __argp_fmtstream_point (stream);
   while (needed-- > 0)
     __argp_fmtstream_putc (stream, ' ');
+  __A_VARIABLE = 1;
 }
 
 /* Output to STREAM either a space, or a newline if there isn't room for at
@@ -906,6 +927,7 @@ space (argp_fmtstream_t stream, size_t ensure)
     __argp_fmtstream_putc (stream, '\n');
   else
     __argp_fmtstream_putc (stream, ' ');
+  __A_VARIABLE = 1;
 }
 
 /* If the option REAL has an argument, we print it in using the printf
@@ -924,6 +946,7 @@ arg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,
 	__argp_fmtstream_printf (stream, req_fmt,
 				 dgettext (domain, real->arg));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper functions for hol_entry_help.  */
@@ -1007,6 +1030,7 @@ print_header (const char *str, const struct argp *argp,
 
   if (fstr != tstr)
     free ((char *) fstr);
+  __A_VARIABLE = 1;
 }
 
 /* Inserts a comma if this isn't the first item on the line, and then makes
@@ -1044,6 +1068,7 @@ comma (unsigned col, struct pentry_state *pest)
     __argp_fmtstream_puts (pest->stream, ", ");
 
   indent_to (pest->stream, col);
+  __A_VARIABLE = 1;
 }
 
 /* Print help for ENTRY to STREAM.  */
@@ -1172,6 +1197,7 @@ hol_entry_help (struct hol_entry *entry, const struct argp_state *state,
 cleanup:
   __argp_fmtstream_set_lmargin (stream, old_lm);
   __argp_fmtstream_set_wmargin (stream, old_wm);
+  __A_VARIABLE = 1;
 }
 
 /* Output a long help message about the options in HOL to STREAM.  */
@@ -1202,6 +1228,7 @@ optional for any corresponding short options.");
       if (fstr && fstr != tstr)
 	free ((char *) fstr);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper functions for hol_usage.  */
@@ -1217,6 +1244,7 @@ add_argless_short_opt (const struct argp_option *opt,
   if (!(opt->arg || real->arg)
       && !((opt->flags | real->flags) & OPTION_NO_USAGE))
     *(*snao_end)++ = opt->key;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1249,6 +1277,7 @@ usage_argful_short_opt (const struct argp_option *opt,
 	}
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1280,6 +1309,7 @@ usage_long_opt (const struct argp_option *opt,
 	__argp_fmtstream_printf (stream, " [--%s]", opt->name);
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1320,6 +1350,7 @@ hol_usage (struct hol *hol, argp_fmtstream_t stream)
 	hol_entry_long_iterate (entry, usage_long_opt,
 				entry->argp->argp_domain, stream);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Make a HOL containing all levels of options in ARGP.  CLUSTER is the
@@ -1342,6 +1373,7 @@ argp_hol (const struct argp *argp, struct hol_cluster *cluster)
 	hol_append (hol, argp_hol (child->argp, child_cluster)) ;
 	child++;
       }
+  __A_VARIABLE = 1;
   return hol;
 }
 
@@ -1360,6 +1392,7 @@ argp_args_levels (const struct argp *argp)
     while (child->argp)
       levels += argp_args_levels ((child++)->argp);
 
+  __A_VARIABLE = 1;
   return levels;
 }
 
@@ -1434,6 +1467,7 @@ argp_args_usage (const struct argp *argp, const struct argp_state *state,
 	*our_level = 0;
     }
 
+  __A_VARIABLE = 1;
   return !advance;
 }
 
@@ -1533,6 +1567,7 @@ argp_doc (const struct argp *argp, const struct argp_state *state,
 		  post, anything || pre_blank, first_only,
 		  stream);
 
+  __A_VARIABLE = 1;
   return anything;
 }
 
@@ -1548,8 +1583,10 @@ _help (const struct argp *argp, const struct argp_state *state, FILE *stream,
   struct hol *hol = 0;
   argp_fmtstream_t fs;
 
-  if (! stream)
+  if (! stream) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   _flockfile (stream);
 
@@ -1560,6 +1597,7 @@ _help (const struct argp *argp, const struct argp_state *state, FILE *stream,
   if (! fs)
     {
       _funlockfile (stream);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -1673,6 +1711,7 @@ Try `%s --help' or `%s --usage' for more information.\n"),
     hol_free (hol);
 
   __argp_fmtstream_free (fs);
+  __A_VARIABLE = 1;
 }
 
 /* Output a usage message for ARGP to STREAM.  FLAGS are from the set
@@ -1681,6 +1720,7 @@ void __argp_help (const struct argp *argp, FILE *stream,
 		  unsigned flags, char *name)
 {
   _help (argp, 0, stream, flags, name);
+  __A_VARIABLE = 1;
 }
 #ifdef weak_alias
 weak_alias (__argp_help, argp_help)
@@ -1707,6 +1747,7 @@ __argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)
 	    exit (0);
 	}
   }
+  __A_VARIABLE = 1;
 }
 #ifdef weak_alias
 weak_alias (__argp_state_help, argp_state_help)
@@ -1764,6 +1805,7 @@ __argp_error (const struct argp_state *state, const char *fmt, ...)
 	  _funlockfile (stream);
 	}
     }
+    __A_VARIABLE = 1;
 }
 #ifdef weak_alias
 weak_alias (__argp_error, argp_error)
@@ -1857,6 +1899,7 @@ __argp_failure (const struct argp_state *state, int status, int errnum,
 	    exit (status);
 	}
     }
+    __A_VARIABLE = 1;
 }
 #ifdef weak_alias
 weak_alias (__argp_failure, argp_failure)
diff --git a/newlib/libc/sys/linux/argp/argp-parse.c b/newlib/libc/sys/linux/argp/argp-parse.c
index 38211e3..758b2a6 100644
--- a/newlib/libc/sys/linux/argp/argp-parse.c
+++ b/newlib/libc/sys/linux/argp/argp-parse.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Hierarchial argument parsing, layered over getopt
    Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -140,8 +141,10 @@ argp_default_parser (int key, char *arg, struct argp_state *state)
       break;
 
     default:
+      __A_VARIABLE = 1;
       return EBADKEY;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -172,8 +175,10 @@ argp_version_parser (int key, char *arg, struct argp_state *state)
 	exit (0);
       break;
     default:
+      __A_VARIABLE = 1;
       return EBADKEY;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -232,6 +237,7 @@ void
 _argp_unlock_xxx (void)
 {
   UNLOCK_GETOPT;
+  __A_VARIABLE = 1;
 }
 
 /* The state of a `group' during parsing.  Each group corresponds to a
@@ -427,6 +433,7 @@ convert_options (const struct argp *argp,
 	  convert_options (children++->argp, parent, index++, group, cvt);
     }
 
+  __A_VARIABLE = 1;
   return group;
 }
 
@@ -455,6 +462,7 @@ parser_convert (struct parser *parser, const struct argp *argp, int flags)
     parser->egroup = convert_options (argp, 0, 0, parser->groups, &cvt);
   else
     parser->egroup = parser->groups; /* No parsers at all! */
+  __A_VARIABLE = 1;
 }
 
 /* Lengths of various parser fields which we will allocated.  */
@@ -495,6 +503,7 @@ calc_sizes (const struct argp *argp,  struct parser_sizes *szs)
 	calc_sizes ((child++)->argp, szs);
 	szs->num_child_inputs++;
       }
+  __A_VARIABLE = 1;
 }
 
 /* Initializes PARSER to parse ARGP in a manner described by FLAGS.  */
@@ -521,8 +530,10 @@ parser_init (struct parser *parser, const struct argp *argp,
 #define SLEN (szs.short_len + 1)
 
   parser->storage = malloc (GLEN + CLEN + LLEN + SLEN);
-  if (! parser->storage)
+  if (! parser->storage) {
+    __A_VARIABLE = 1;
     return ENOMEM;
+  }
 
   parser->groups = parser->storage;
   parser->child_inputs = parser->storage + GLEN;
@@ -568,8 +579,10 @@ parser_init (struct parser *parser, const struct argp *argp,
   if (err == EBADKEY)
     err = 0;			/* Some parser didn't understand.  */
 
-  if (err)
+  if (err) {
+    __A_VARIABLE = 1;
     return err;
+  }
 
   /* Getopt is (currently) non-reentrant.  */
   LOCK_GETOPT;
@@ -594,6 +607,7 @@ parser_init (struct parser *parser, const struct argp *argp,
   else
     parser->state.name = program_invocation_short_name;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -688,6 +702,7 @@ parser_finalize (struct parser *parser,
 
   free (parser->storage);
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -742,6 +757,7 @@ parser_parse_arg (struct parser *parser, char *val)
 	parser->try_getopt = 1;
     }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -799,6 +815,7 @@ parser_parse_opt (struct parser *parser, int opt, char *val)
 	}
     }
 
+  __A_VARIABLE = 1;
   return err;
 }
 
@@ -938,6 +955,7 @@ __argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,
       err = parser_finalize (&parser, err, arg_ebadkey, end_index);
     }
 
+  __A_VARIABLE = 1;
   return err;
 }
 #ifdef weak_alias
@@ -955,10 +973,13 @@ __argp_input (const struct argp *argp, const struct argp_state *state)
       struct parser *parser = state->pstate;
 
       for (group = parser->groups; group < parser->egroup; group++)
-	if (group->argp == argp)
+	if (group->argp == argp) {
+	  __A_VARIABLE = 1;
 	  return group->input;
+	}
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 #ifdef weak_alias
diff --git a/newlib/libc/sys/linux/argp/argp-pv.c b/newlib/libc/sys/linux/argp/argp-pv.c
index 5987956..5bb80fd 100644
--- a/newlib/libc/sys/linux/argp/argp-pv.c
+++ b/newlib/libc/sys/linux/argp/argp-pv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Default definition for ARGP_PROGRAM_VERSION.
    Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/argp/argp-pvh.c b/newlib/libc/sys/linux/argp/argp-pvh.c
index 8a8fd30..4d2a256 100644
--- a/newlib/libc/sys/linux/argp/argp-pvh.c
+++ b/newlib/libc/sys/linux/argp/argp-pvh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Default definition for ARGP_PROGRAM_VERSION_HOOK.
    Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/argp/argp-xinl.c b/newlib/libc/sys/linux/argp/argp-xinl.c
index 644836d..3323dc4 100644
--- a/newlib/libc/sys/linux/argp/argp-xinl.c
+++ b/newlib/libc/sys/linux/argp/argp-xinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Real definitions for extern inline functions in argp.h
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/brk.c b/newlib/libc/sys/linux/brk.c
index 91bb367..26692c5 100644
--- a/newlib/libc/sys/linux/brk.c
+++ b/newlib/libc/sys/linux/brk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/brk.c - Change data segment size */
 
 /* Written 2000 by Werner Almesberger */
@@ -34,8 +35,12 @@ void *sbrk(ptrdiff_t increment) /* SHOULD be ptrdiff_t */
 
     if (!curr_brk) curr_brk = __brk(NULL);
     new_brk = __brk(curr_brk+increment);
-    if (new_brk != curr_brk+increment) return (void *) -1;
+    if (new_brk != curr_brk+increment) {
+        __A_VARIABLE = 1;
+        return (void *) -1;
+    }
     old_brk = curr_brk;
     curr_brk = new_brk;
+    __A_VARIABLE = 1;
     return old_brk;
 }
diff --git a/newlib/libc/sys/linux/calloc.c b/newlib/libc/sys/linux/calloc.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/calloc.c
+++ b/newlib/libc/sys/linux/calloc.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/callocr.c b/newlib/libc/sys/linux/callocr.c
index bff43b8..7acf3d4 100644
--- a/newlib/libc/sys/linux/callocr.c
+++ b/newlib/libc/sys/linux/callocr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void *
 _calloc_r (struct _reent *ptr, size_t size, size_t len)
 {
+  __A_VARIABLE = 1;
   return calloc (size, len);
 }
diff --git a/newlib/libc/sys/linux/cfreer.c b/newlib/libc/sys/linux/cfreer.c
index c7e6c25..81c13d3 100644
--- a/newlib/libc/sys/linux/cfreer.c
+++ b/newlib/libc/sys/linux/cfreer.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void
 _cfree_r (struct _reent *ptr, void *mem)
 {
+  __A_VARIABLE = 1;
   return cfree (mem);
 }
diff --git a/newlib/libc/sys/linux/cfspeed.c b/newlib/libc/sys/linux/cfspeed.c
index e935bf1..362107c 100644
--- a/newlib/libc/sys/linux/cfspeed.c
+++ b/newlib/libc/sys/linux/cfspeed.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* `struct termios' speed frobnication functions.  Linux version.
    Copyright (C) 1991, 92, 93, 95, 96, 97, 98, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -29,6 +30,7 @@ speed_t
 cfgetospeed (termios_p)
      const struct termios *termios_p;
 {
+  __A_VARIABLE = 1;
   return termios_p->c_cflag & (CBAUD | CBAUDEX);
 }
 
@@ -39,6 +41,7 @@ speed_t
 cfgetispeed (termios_p)
      const struct termios *termios_p;
 {
+  __A_VARIABLE = 1;
   return termios_p->c_cflag & (CBAUD | CBAUDEX);
 }
 
@@ -52,12 +55,14 @@ cfsetospeed  (termios_p, speed)
       && (speed < B57600 || speed > __MAX_BAUD))
     {
       errno = (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
 
   termios_p->c_cflag &= ~(CBAUD | CBAUDEX);
   termios_p->c_cflag |= speed;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -75,6 +80,7 @@ cfsetispeed (termios_p, speed)
       && (speed < B57600 || speed > __MAX_BAUD))
     {
       errno = (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -84,5 +90,6 @@ cfsetispeed (termios_p, speed)
       termios_p->c_cflag |= speed;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/clock_getres.c b/newlib/libc/sys/linux/clock_getres.c
index 8bf648f..69e38fc 100644
--- a/newlib/libc/sys/linux/clock_getres.c
+++ b/newlib/libc/sys/linux/clock_getres.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/clock_gettime.c b/newlib/libc/sys/linux/clock_gettime.c
index a86786b..eb66da7 100644
--- a/newlib/libc/sys/linux/clock_gettime.c
+++ b/newlib/libc/sys/linux/clock_gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/clock_settime.c b/newlib/libc/sys/linux/clock_settime.c
index 79a9b56..c68ea2c 100644
--- a/newlib/libc/sys/linux/clock_settime.c
+++ b/newlib/libc/sys/linux/clock_settime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/cmath/s_cacos.c b/newlib/libc/sys/linux/cmath/s_cacos.c
index f986447..32b7287 100644
--- a/newlib/libc/sys/linux/cmath/s_cacos.c
+++ b/newlib/libc/sys/linux/cmath/s_cacos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cacosf.c b/newlib/libc/sys/linux/cmath/s_cacosf.c
index bf01890..d6da0d6 100644
--- a/newlib/libc/sys/linux/cmath/s_cacosf.c
+++ b/newlib/libc/sys/linux/cmath/s_cacosf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cacosh.c b/newlib/libc/sys/linux/cmath/s_cacosh.c
index 6ca3426..c3efe38 100644
--- a/newlib/libc/sys/linux/cmath/s_cacosh.c
+++ b/newlib/libc/sys/linux/cmath/s_cacosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole cosine for double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cacoshf.c b/newlib/libc/sys/linux/cmath/s_cacoshf.c
index 69054cd..68b95b9 100644
--- a/newlib/libc/sys/linux/cmath/s_cacoshf.c
+++ b/newlib/libc/sys/linux/cmath/s_cacoshf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole cosine for float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cacoshl.c b/newlib/libc/sys/linux/cmath/s_cacoshl.c
index 3d0cd7f..0522ec8 100644
--- a/newlib/libc/sys/linux/cmath/s_cacoshl.c
+++ b/newlib/libc/sys/linux/cmath/s_cacoshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole cosine for long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cacosl.c b/newlib/libc/sys/linux/cmath/s_cacosl.c
index d4bbfec..1241f7b 100644
--- a/newlib/libc/sys/linux/cmath/s_cacosl.c
+++ b/newlib/libc/sys/linux/cmath/s_cacosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casin.c b/newlib/libc/sys/linux/cmath/s_casin.c
index 4c164b5..aa808fd 100644
--- a/newlib/libc/sys/linux/cmath/s_casin.c
+++ b/newlib/libc/sys/linux/cmath/s_casin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc sine of complex double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casinf.c b/newlib/libc/sys/linux/cmath/s_casinf.c
index 09e52b4..c3ff2ec 100644
--- a/newlib/libc/sys/linux/cmath/s_casinf.c
+++ b/newlib/libc/sys/linux/cmath/s_casinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc sine of complex float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casinh.c b/newlib/libc/sys/linux/cmath/s_casinh.c
index 30b9dbb..8860706 100644
--- a/newlib/libc/sys/linux/cmath/s_casinh.c
+++ b/newlib/libc/sys/linux/cmath/s_casinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole sine for double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casinhf.c b/newlib/libc/sys/linux/cmath/s_casinhf.c
index f9fc4e7..c39d422 100644
--- a/newlib/libc/sys/linux/cmath/s_casinhf.c
+++ b/newlib/libc/sys/linux/cmath/s_casinhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole sine for float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casinhl.c b/newlib/libc/sys/linux/cmath/s_casinhl.c
index b48c609..459e329 100644
--- a/newlib/libc/sys/linux/cmath/s_casinhl.c
+++ b/newlib/libc/sys/linux/cmath/s_casinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole sine for long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_casinl.c b/newlib/libc/sys/linux/cmath/s_casinl.c
index d6b7a80..88ffbaa 100644
--- a/newlib/libc/sys/linux/cmath/s_casinl.c
+++ b/newlib/libc/sys/linux/cmath/s_casinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc sine of complex long double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catan.c b/newlib/libc/sys/linux/cmath/s_catan.c
index 1d0673a..0283c65 100644
--- a/newlib/libc/sys/linux/cmath/s_catan.c
+++ b/newlib/libc/sys/linux/cmath/s_catan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc tangent of complex double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catanf.c b/newlib/libc/sys/linux/cmath/s_catanf.c
index cc9e5ea..095a196 100644
--- a/newlib/libc/sys/linux/cmath/s_catanf.c
+++ b/newlib/libc/sys/linux/cmath/s_catanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc tangent of complex float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catanh.c b/newlib/libc/sys/linux/cmath/s_catanh.c
index e15c073..b1c0b4c 100644
--- a/newlib/libc/sys/linux/cmath/s_catanh.c
+++ b/newlib/libc/sys/linux/cmath/s_catanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole tangent for double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catanhf.c b/newlib/libc/sys/linux/cmath/s_catanhf.c
index 30a5a1b..3374d30 100644
--- a/newlib/libc/sys/linux/cmath/s_catanhf.c
+++ b/newlib/libc/sys/linux/cmath/s_catanhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole tangent for float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catanhl.c b/newlib/libc/sys/linux/cmath/s_catanhl.c
index c3fb0ce..8296345 100644
--- a/newlib/libc/sys/linux/cmath/s_catanhl.c
+++ b/newlib/libc/sys/linux/cmath/s_catanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc hyperbole tangent for long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_catanl.c b/newlib/libc/sys/linux/cmath/s_catanl.c
index 6cb45e5..f3364dc 100644
--- a/newlib/libc/sys/linux/cmath/s_catanl.c
+++ b/newlib/libc/sys/linux/cmath/s_catanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return arc tangent of complex long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cbrtl.c b/newlib/libc/sys/linux/cmath/s_cbrtl.c
index d668e37..e044668 100644
--- a/newlib/libc/sys/linux/cmath/s_cbrtl.c
+++ b/newlib/libc/sys/linux/cmath/s_cbrtl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include <stdio.h>
 #include <errno.h>
@@ -7,6 +8,7 @@ __cbrtl(long double x)
 {
   fputs ("__cbrtl not implemented\n", stderr);
   __set_errno (ENOSYS);
+  __A_VARIABLE = 1;
   return 0.0;
 }
 
diff --git a/newlib/libc/sys/linux/cmath/s_ccos.c b/newlib/libc/sys/linux/cmath/s_ccos.c
index e65ea38..feeb808 100644
--- a/newlib/libc/sys/linux/cmath/s_ccos.c
+++ b/newlib/libc/sys/linux/cmath/s_ccos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ccosf.c b/newlib/libc/sys/linux/cmath/s_ccosf.c
index 016d806..51d5546 100644
--- a/newlib/libc/sys/linux/cmath/s_ccosf.c
+++ b/newlib/libc/sys/linux/cmath/s_ccosf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex float value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ccosh.c b/newlib/libc/sys/linux/cmath/s_ccosh.c
index f5b29db..305fe68 100644
--- a/newlib/libc/sys/linux/cmath/s_ccosh.c
+++ b/newlib/libc/sys/linux/cmath/s_ccosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex cosine hyperbole function for double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ccoshf.c b/newlib/libc/sys/linux/cmath/s_ccoshf.c
index 339b6bc..d2667d2 100644
--- a/newlib/libc/sys/linux/cmath/s_ccoshf.c
+++ b/newlib/libc/sys/linux/cmath/s_ccoshf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex cosine hyperbole function for float.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ccoshl.c b/newlib/libc/sys/linux/cmath/s_ccoshl.c
index 61ffb49..9e9c619 100644
--- a/newlib/libc/sys/linux/cmath/s_ccoshl.c
+++ b/newlib/libc/sys/linux/cmath/s_ccoshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex cosine hyperbole function for long double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ccosl.c b/newlib/libc/sys/linux/cmath/s_ccosl.c
index 4ebe2c3..087cfd9 100644
--- a/newlib/libc/sys/linux/cmath/s_ccosl.c
+++ b/newlib/libc/sys/linux/cmath/s_ccosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return cosine of complex long double value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cexp.c b/newlib/libc/sys/linux/cmath/s_cexp.c
index 5a299b7..17e15c3 100644
--- a/newlib/libc/sys/linux/cmath/s_cexp.c
+++ b/newlib/libc/sys/linux/cmath/s_cexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return value of complex exponential function for double complex value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cexpf.c b/newlib/libc/sys/linux/cmath/s_cexpf.c
index 93bfe20..17c845b 100644
--- a/newlib/libc/sys/linux/cmath/s_cexpf.c
+++ b/newlib/libc/sys/linux/cmath/s_cexpf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return value of complex exponential function for float complex value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cexpl.c b/newlib/libc/sys/linux/cmath/s_cexpl.c
index cf6bc97..1580cb1 100644
--- a/newlib/libc/sys/linux/cmath/s_cexpl.c
+++ b/newlib/libc/sys/linux/cmath/s_cexpl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return value of complex exponential function for long double complex value.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clog.c b/newlib/libc/sys/linux/cmath/s_clog.c
index f796024..21db1d7 100644
--- a/newlib/libc/sys/linux/cmath/s_clog.c
+++ b/newlib/libc/sys/linux/cmath/s_clog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex natural logarithm.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clog10.c b/newlib/libc/sys/linux/cmath/s_clog10.c
index 62c2ca7..785c323 100644
--- a/newlib/libc/sys/linux/cmath/s_clog10.c
+++ b/newlib/libc/sys/linux/cmath/s_clog10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex base 10 logarithm.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clog10f.c b/newlib/libc/sys/linux/cmath/s_clog10f.c
index 6d60c5f..47d793a 100644
--- a/newlib/libc/sys/linux/cmath/s_clog10f.c
+++ b/newlib/libc/sys/linux/cmath/s_clog10f.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex base 10 logarithm.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clog10l.c b/newlib/libc/sys/linux/cmath/s_clog10l.c
index f901543..e33ca67 100644
--- a/newlib/libc/sys/linux/cmath/s_clog10l.c
+++ b/newlib/libc/sys/linux/cmath/s_clog10l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex base 10 logarithm.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clogf.c b/newlib/libc/sys/linux/cmath/s_clogf.c
index c7151f2..9f8d0b9 100644
--- a/newlib/libc/sys/linux/cmath/s_clogf.c
+++ b/newlib/libc/sys/linux/cmath/s_clogf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex natural logarithm.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_clogl.c b/newlib/libc/sys/linux/cmath/s_clogl.c
index 43118f7..22d963a 100644
--- a/newlib/libc/sys/linux/cmath/s_clogl.c
+++ b/newlib/libc/sys/linux/cmath/s_clogl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute complex natural logarithm.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cpow.c b/newlib/libc/sys/linux/cmath/s_cpow.c
index 9018a8a..15ed8b7 100644
--- a/newlib/libc/sys/linux/cmath/s_cpow.c
+++ b/newlib/libc/sys/linux/cmath/s_cpow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex power of double values.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -25,6 +26,7 @@
 __complex__ double
 __cpow (__complex__ double x, __complex__ double c)
 {
+  __A_VARIABLE = 1;
   return __cexp (c * __clog (x));
 }
 weak_alias (__cpow, cpow)
diff --git a/newlib/libc/sys/linux/cmath/s_cpowf.c b/newlib/libc/sys/linux/cmath/s_cpowf.c
index b0c0324..26a73ff 100644
--- a/newlib/libc/sys/linux/cmath/s_cpowf.c
+++ b/newlib/libc/sys/linux/cmath/s_cpowf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex power of float values.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -25,6 +26,7 @@
 __complex__ float
 __cpowf (__complex__ float x, __complex__ float c)
 {
+  __A_VARIABLE = 1;
   return __cexpf (c * __clogf (x));
 }
 weak_alias (__cpowf, cpowf)
diff --git a/newlib/libc/sys/linux/cmath/s_cpowl.c b/newlib/libc/sys/linux/cmath/s_cpowl.c
index 4c358b3..a6fb596 100644
--- a/newlib/libc/sys/linux/cmath/s_cpowl.c
+++ b/newlib/libc/sys/linux/cmath/s_cpowl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex power of long double values.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -25,6 +26,7 @@
 __complex__ long double
 __cpowl (__complex__ long double x, __complex__ long double c)
 {
+  __A_VARIABLE = 1;
   return __cexpl (c * __clogl (x));
 }
 weak_alias (__cpowl, cpowl)
diff --git a/newlib/libc/sys/linux/cmath/s_cproj.c b/newlib/libc/sys/linux/cmath/s_cproj.c
index 6c9e417..ffb476e 100644
--- a/newlib/libc/sys/linux/cmath/s_cproj.c
+++ b/newlib/libc/sys/linux/cmath/s_cproj.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute projection of complex double value to Riemann sphere.
    Copyright (C) 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cprojf.c b/newlib/libc/sys/linux/cmath/s_cprojf.c
index a302078..cbcaa17 100644
--- a/newlib/libc/sys/linux/cmath/s_cprojf.c
+++ b/newlib/libc/sys/linux/cmath/s_cprojf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute projection of complex float value to Riemann sphere.
    Copyright (C) 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_cprojl.c b/newlib/libc/sys/linux/cmath/s_cprojl.c
index c70cdc4..9565ff2 100644
--- a/newlib/libc/sys/linux/cmath/s_cprojl.c
+++ b/newlib/libc/sys/linux/cmath/s_cprojl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compute projection of complex long double value to Riemann sphere.
    Copyright (C) 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csin.c b/newlib/libc/sys/linux/cmath/s_csin.c
index eb380e2..c7a40e2 100644
--- a/newlib/libc/sys/linux/cmath/s_csin.c
+++ b/newlib/libc/sys/linux/cmath/s_csin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine function for double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csinf.c b/newlib/libc/sys/linux/cmath/s_csinf.c
index b727881..bb69fca 100644
--- a/newlib/libc/sys/linux/cmath/s_csinf.c
+++ b/newlib/libc/sys/linux/cmath/s_csinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine function for float.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csinh.c b/newlib/libc/sys/linux/cmath/s_csinh.c
index f0e0cc6..7b172a7 100644
--- a/newlib/libc/sys/linux/cmath/s_csinh.c
+++ b/newlib/libc/sys/linux/cmath/s_csinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine hyperbole function for double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csinhf.c b/newlib/libc/sys/linux/cmath/s_csinhf.c
index 5cf80d0..89bb1cf 100644
--- a/newlib/libc/sys/linux/cmath/s_csinhf.c
+++ b/newlib/libc/sys/linux/cmath/s_csinhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine hyperbole function for float.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csinhl.c b/newlib/libc/sys/linux/cmath/s_csinhl.c
index 2260756..08a0e8a 100644
--- a/newlib/libc/sys/linux/cmath/s_csinhl.c
+++ b/newlib/libc/sys/linux/cmath/s_csinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine hyperbole function for long double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csinl.c b/newlib/libc/sys/linux/cmath/s_csinl.c
index f7a1c43..e2f2921 100644
--- a/newlib/libc/sys/linux/cmath/s_csinl.c
+++ b/newlib/libc/sys/linux/cmath/s_csinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex sine function for long double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csqrt.c b/newlib/libc/sys/linux/cmath/s_csqrt.c
index 0bb6690..a371472 100644
--- a/newlib/libc/sys/linux/cmath/s_csqrt.c
+++ b/newlib/libc/sys/linux/cmath/s_csqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex square root of double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csqrtf.c b/newlib/libc/sys/linux/cmath/s_csqrtf.c
index f7b1836..7e71921 100644
--- a/newlib/libc/sys/linux/cmath/s_csqrtf.c
+++ b/newlib/libc/sys/linux/cmath/s_csqrtf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex square root of float value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_csqrtl.c b/newlib/libc/sys/linux/cmath/s_csqrtl.c
index 8e27750..1cd2f31 100644
--- a/newlib/libc/sys/linux/cmath/s_csqrtl.c
+++ b/newlib/libc/sys/linux/cmath/s_csqrtl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex square root of long double value.
    Copyright (C) 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctan.c b/newlib/libc/sys/linux/cmath/s_ctan.c
index 6a09fe4..7b0c35f 100644
--- a/newlib/libc/sys/linux/cmath/s_ctan.c
+++ b/newlib/libc/sys/linux/cmath/s_ctan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex tangent function for double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctanf.c b/newlib/libc/sys/linux/cmath/s_ctanf.c
index 89bc847..f21fd30 100644
--- a/newlib/libc/sys/linux/cmath/s_ctanf.c
+++ b/newlib/libc/sys/linux/cmath/s_ctanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex tangent function for float.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctanh.c b/newlib/libc/sys/linux/cmath/s_ctanh.c
index 971cd90..abdf871 100644
--- a/newlib/libc/sys/linux/cmath/s_ctanh.c
+++ b/newlib/libc/sys/linux/cmath/s_ctanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex hyperbole tangent for double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctanhf.c b/newlib/libc/sys/linux/cmath/s_ctanhf.c
index b9e3c57..dfb4331 100644
--- a/newlib/libc/sys/linux/cmath/s_ctanhf.c
+++ b/newlib/libc/sys/linux/cmath/s_ctanhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex hyperbole tangent for float.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctanhl.c b/newlib/libc/sys/linux/cmath/s_ctanhl.c
index 7bf6b39..dd21557 100644
--- a/newlib/libc/sys/linux/cmath/s_ctanhl.c
+++ b/newlib/libc/sys/linux/cmath/s_ctanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex hyperbole tangent for long double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/cmath/s_ctanl.c b/newlib/libc/sys/linux/cmath/s_ctanl.c
index fa153e9..e54fc1c 100644
--- a/newlib/libc/sys/linux/cmath/s_ctanl.c
+++ b/newlib/libc/sys/linux/cmath/s_ctanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Complex tangent function for long double.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/confstr.c b/newlib/libc/sys/linux/confstr.c
index 6b566b3..fea031f 100644
--- a/newlib/libc/sys/linux/confstr.c
+++ b/newlib/libc/sys/linux/confstr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -144,6 +145,7 @@ confstr (name, buf, len)
 
     default:
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -157,5 +159,6 @@ confstr (name, buf, len)
 	  buf[len - 1] = '\0';
 	}
     }
+  __A_VARIABLE = 1;
   return string_len;
 }
diff --git a/newlib/libc/sys/linux/crt1.c b/newlib/libc/sys/linux/crt1.c
index 018e9a2..86a6a42 100644
--- a/newlib/libc/sys/linux/crt1.c
+++ b/newlib/libc/sys/linux/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* dummy crt1.c file to override the one normally used by
    gcc which refers to glibc variables that don't exist in
    newlib.  */
diff --git a/newlib/libc/sys/linux/ctermid.c b/newlib/libc/sys/linux/ctermid.c
index 05914ff..95a3af2 100644
--- a/newlib/libc/sys/linux/ctermid.c
+++ b/newlib/libc/sys/linux/ctermid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ctermid */
 
 #include <stdio.h>
@@ -9,8 +10,11 @@ char *
 _DEFUN (ctermid, (buf),
      char *buf)
 {
-  if (buf == NULL)
+  if (buf == NULL) {
+    __A_VARIABLE = 1;
     return devname;
+  }
 
+  __A_VARIABLE = 1;
   return strcpy (buf, "/dev/tty");
 }
diff --git a/newlib/libc/sys/linux/dl/dl-addr.c b/newlib/libc/sys/linux/dl/dl-addr.c
index 2386749..5168bc5 100644
--- a/newlib/libc/sys/linux/dl/dl-addr.c
+++ b/newlib/libc/sys/linux/dl/dl-addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Locate the shared object symbol nearest a given address.
    Copyright (C) 1996-2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/dl/dl-cache.c b/newlib/libc/sys/linux/dl/dl-cache.c
index 9511da1..1c36caa 100644
--- a/newlib/libc/sys/linux/dl/dl-cache.c
+++ b/newlib/libc/sys/linux/dl/dl-cache.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -197,9 +198,11 @@ _dl_load_cache_lookup (const char *name)
       assert (cache != NULL);
     }
 
-  if (cache == (void *) -1)
+  if (cache == (void *) -1) {
     /* Previously looked for the cache file and didn't find it.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   best = NULL;
 
@@ -251,6 +254,7 @@ _dl_load_cache_lookup (const char *name)
   if (__builtin_expect (_dl_debug_mask & DL_DEBUG_LIBS, 0) && best != NULL)
     _dl_debug_printf ("  trying file=%s\n", best);
 
+  __A_VARIABLE = 1;
   return best;
 }
 
@@ -267,5 +271,6 @@ _dl_unload_cache (void)
       munmap (cache, cachesize);
       cache = NULL;
     }
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/dl/dl-close.c b/newlib/libc/sys/linux/dl/dl-close.c
index ef53868..7b478af 100644
--- a/newlib/libc/sys/linux/dl/dl-close.c
+++ b/newlib/libc/sys/linux/dl/dl-close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Close a shared object opened by `_dl_open'.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -330,5 +331,6 @@ free_mem (void)
       /* Now free the old map.  */
       free (old);
     }
+    __A_VARIABLE = 1;
 }
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/dl/dl-debug.c b/newlib/libc/sys/linux/dl/dl-debug.c
index 5a51b53..703baa6 100644
--- a/newlib/libc/sys/linux/dl/dl-debug.c
+++ b/newlib/libc/sys/linux/dl/dl-debug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Communicate dynamic linker state to the debugger at runtime.
    Copyright (C) 1996, 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -43,6 +44,7 @@ _dl_debug_initialize (ElfW(Addr) ldbase)
       _r_debug.r_brk = (ElfW(Addr)) &_dl_debug_state;
     }
 
+  __A_VARIABLE = 1;
   return &_r_debug;
 }
 
@@ -54,4 +56,5 @@ _dl_debug_initialize (ElfW(Addr) ldbase)
 void
 _dl_debug_state (void)
 {
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-deps.c b/newlib/libc/sys/linux/dl/dl-deps.c
index 4596a85..0f3116e 100644
--- a/newlib/libc/sys/linux/dl/dl-deps.c
+++ b/newlib/libc/sys/linux/dl/dl-deps.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Load the dependencies of a mapped object.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -68,6 +69,7 @@ openaux (void *a)
 			      (args->map->l_type == lt_executable
 			       ? lt_library : args->map->l_type),
 			      args->trace_mode, 0);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/newlib/libc/sys/linux/dl/dl-error.c b/newlib/libc/sys/linux/dl/dl-error.c
index 9c0f55f..6434514 100644
--- a/newlib/libc/sys/linux/dl/dl-error.c
+++ b/newlib/libc/sys/linux/dl/dl-error.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Error handling for runtime dynamic linker.
    Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -114,6 +115,7 @@ _dl_signal_error (int errcode, const char *objname, const char *occation,
 			 ? __strerror_r (errcode, buffer, sizeof buffer)
 			 : ""));
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -131,6 +133,7 @@ _dl_signal_cerror (int errcode, const char *objname, const char *occation,
     }
   else
     _dl_signal_error (errcode, objname, occation, errstring);
+  __A_VARIABLE = 1;
 }
 
 
@@ -158,6 +161,7 @@ _dl_catch_error (const char **objname, const char **errstring,
       tsd_setspecific (old);
       *objname = NULL;
       *errstring = NULL;
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -165,6 +169,7 @@ _dl_catch_error (const char **objname, const char **errstring,
   tsd_setspecific (old);
   *objname = c.objname;
   *errstring = c.errstring;
+  __A_VARIABLE = 1;
   return errcode == -1 ? 0 : errcode;
 }
 
@@ -186,4 +191,5 @@ _dl_receive_error (receiver_fct fct, void (*operate) (void *), void *args)
 
   tsd_setspecific (old_catch);
   receiver = old_receiver;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-fini.c b/newlib/libc/sys/linux/dl/dl-fini.c
index fc4f4b6..c95fcb0 100644
--- a/newlib/libc/sys/linux/dl/dl-fini.c
+++ b/newlib/libc/sys/linux/dl/dl-fini.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Call the termination functions of loaded shared objects.
    Copyright (C) 1995,96,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/dl/dl-init.c b/newlib/libc/sys/linux/dl/dl-init.c
index 5448b03..9cbb1a7 100644
--- a/newlib/libc/sys/linux/dl/dl-init.c
+++ b/newlib/libc/sys/linux/dl/dl-init.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return the next shared object initializer function not yet run.
    Copyright (C) 1995,1996,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/dl/dl-iteratephdr.c b/newlib/libc/sys/linux/dl/dl-iteratephdr.c
index a39a493..7520b4e 100644
--- a/newlib/libc/sys/linux/dl/dl-iteratephdr.c
+++ b/newlib/libc/sys/linux/dl/dl-iteratephdr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get loaded objects program headers.
    Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -57,6 +58,7 @@ __dl_iterate_phdr (int (*callback) (struct dl_phdr_info *info,
 #endif
 
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/sys/linux/dl/dl-libc.c b/newlib/libc/sys/linux/dl/dl-libc.c
index c83448d..de3e15d 100644
--- a/newlib/libc/sys/linux/dl/dl-libc.c
+++ b/newlib/libc/sys/linux/dl/dl-libc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Handle loading and unloading shared objects for internal libc purposes.
    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -45,6 +46,7 @@ dlerror_run (void (*operate) (void *), void *args)
   if (result && last_errstring != _dl_out_of_memory)
     free ((char *) last_errstring);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -76,6 +78,7 @@ do_dlopen (void *ptr)
   struct do_dlopen_args *args = (struct do_dlopen_args *) ptr;
   /* Open and relocate the shared object.  */
   args->map = _dl_open (args->name, RTLD_LAZY, NULL);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -85,12 +88,14 @@ do_dlsym (void *ptr)
   args->ref = NULL;
   args->loadbase = _dl_lookup_symbol (args->name, args->map, &args->ref,
 				      args->map->l_local_scope, 0, 1);
+  __A_VARIABLE = 1;
 }
 
 static void
 do_dlclose (void *ptr)
 {
   _dl_close ((struct link_map *) ptr);
+  __A_VARIABLE = 1;
 }
 
 /* ... and these functions call dlerror_run. */
@@ -101,6 +106,7 @@ __libc_dlopen (const char *__name)
   struct do_dlopen_args args;
   args.name = __name;
 
+  __A_VARIABLE = 1;
   return (dlerror_run (do_dlopen, &args) ? NULL : (void *) args.map);
 }
 
@@ -111,6 +117,7 @@ __libc_dlsym (void *__map, const char *__name)
   args.map = __map;
   args.name = __name;
 
+  __A_VARIABLE = 1;
   return (dlerror_run (do_dlsym, &args) ? NULL
 	  : (void *) (DL_SYMBOL_ADDRESS (args.loadbase, args.ref)));
 }
@@ -118,6 +125,7 @@ __libc_dlsym (void *__map, const char *__name)
 int
 __libc_dlclose (void *__map)
 {
+  __A_VARIABLE = 1;
   return dlerror_run (do_dlclose, __map);
 }
 
@@ -152,5 +160,6 @@ free_mem (void)
 	    free (old);
 	}
     }
+    __A_VARIABLE = 1;
 }
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/dl/dl-load.c b/newlib/libc/sys/linux/dl/dl-load.c
index 4e32d60..ad2b4a5 100644
--- a/newlib/libc/sys/linux/dl/dl-load.c
+++ b/newlib/libc/sys/linux/dl/dl-load.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Map in a shared object's segments from the file.
    Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -152,9 +153,12 @@ local_strdup (const char *s)
   size_t len = strlen (s) + 1;
   void *new = malloc (len);
 
-  if (new == NULL)
+  if (new == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
+  __A_VARIABLE = 1;
   return (char *) memcpy (new, s, len);
 }
 
@@ -209,6 +213,7 @@ _dl_dst_count (const char *name, int is_path)
     }
   while (name != NULL);
 
+  __A_VARIABLE = 1;
   return cnt;
 }
 
@@ -273,6 +278,7 @@ _dl_dst_substitute (struct link_map *l, const char *name, char *result,
 
   *wp = '\0';
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -297,17 +303,22 @@ expand_dynamic_string_token (struct link_map *l, const char *s)
   cnt = DL_DST_COUNT (s, 1);
 
   /* If we do not have to replace anything simply copy the string.  */
-  if (__builtin_expect (cnt, 0) == 0)
+  if (__builtin_expect (cnt, 0) == 0) {
+    __A_VARIABLE = 1;
     return local_strdup (s);
+  }
 
   /* Determine the length of the substituted string.  */
   total = DL_DST_REQUIRED (l, s, strlen (s), cnt);
 
   /* Allocate the necessary memory.  */
   result = (char *) malloc (total + 1);
-  if (result == NULL)
+  if (result == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
+  __A_VARIABLE = 1;
   return DL_DST_SUBSTITUTE (l, s, result, 1);
 }
 
@@ -326,8 +337,10 @@ add_name_to_object (struct link_map *l, const char *name)
 
   lastp = NULL;
   for (lnp = l->l_libname; lnp != NULL; lastp = lnp, lnp = lnp->next)
-    if (strcmp (name, lnp->name) == 0)
+    if (strcmp (name, lnp->name) == 0) {
+      __A_VARIABLE = 1;
       return;
+    }
 
   name_len = strlen (name) + 1;
   newname = (struct libname_list *) malloc (sizeof *newname + name_len);
@@ -335,6 +348,7 @@ add_name_to_object (struct link_map *l, const char *name)
     {
       /* No more memory.  */
       _dl_signal_error (ENOMEM, name, NULL, N_("cannot allocate name record"));
+      __A_VARIABLE = 1;
       return;
     }
   /* The object should have a libname set from _dl_new_object.  */
@@ -344,6 +358,7 @@ add_name_to_object (struct link_map *l, const char *name)
   newname->next = NULL;
   newname->dont_free = 0;
   lastp->next = newname;
+  __A_VARIABLE = 1;
 }
 
 /* All known directories in sorted order.  */
@@ -479,6 +494,7 @@ fillin_rpath (char *rpath, struct r_search_path_elem **result, const char *sep,
   /* Terminate the array.  */
   result[nelems] = NULL;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -525,6 +541,7 @@ decompose_rpath (struct r_search_path_struct *sps,
 	      sps->dirs = result;
 	      sps->malloced = 1;
 
+	      __A_VARIABLE = 1;
 	      return;
 	    }
 	}
@@ -561,6 +578,7 @@ decompose_rpath (struct r_search_path_struct *sps,
   sps->dirs = result;
   /* The caller will change this value if we haven't used a real malloc.  */
   sps->malloced = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -724,6 +742,7 @@ _dl_init_paths (const char *llp)
 
   /* Remember the last search directory added at startup.  */
   _dl_init_all_dirs = _dl_all_dirs;
+  __A_VARIABLE = 1;
 }
 
 
@@ -763,6 +782,7 @@ lose (int code, int fd, const char *name, char *realname, struct link_map *l,
     }
   free (realname);
   _dl_signal_error (code, name, NULL, msg);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1234,6 +1254,7 @@ print_search_path (struct r_search_path_elem **list,
 			name[0] ? name : _dl_argv[0]);
   else
     _dl_debug_printf_c ("\t\t(%s)\n", what);
+  __A_VARIABLE = 1;
 }
 
 /* Open a file and verify it is an ELF file for this architecture.  We
diff --git a/newlib/libc/sys/linux/dl/dl-lookup.c b/newlib/libc/sys/linux/dl/dl-lookup.c
index 9fc296c..c9e764d 100644
--- a/newlib/libc/sys/linux/dl/dl-lookup.c
+++ b/newlib/libc/sys/linux/dl/dl-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Look up a symbol in the loaded objects.
    Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -88,8 +89,10 @@ add_dependency (struct link_map *undef_map, struct link_map *map)
   int result = 0;
 
   /* Avoid self-references.  */
-  if (undef_map == map)
+  if (undef_map == map) {
+    __A_VARIABLE = 1;
     return 0;
+    }
 
   /* Make sure nobody can unload the object while we are at it.  */
 #ifdef HAVE_DD_LOCK
@@ -186,6 +189,7 @@ add_dependency (struct link_map *undef_map, struct link_map *map)
 #endif
 
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -617,8 +621,10 @@ _dl_setup_hash (struct link_map *map)
   Elf_Symndx *hash;
   Elf_Symndx nchain;
 
-  if (!map->l_info[DT_HASH])
+  if (!map->l_info[DT_HASH]) {
+    __A_VARIABLE = 1;
     return;
+  }
   hash = (void *)(map->l_addr + map->l_info[DT_HASH]->d_un.d_ptr);
 
   map->l_nbuckets = *hash++;
@@ -626,6 +632,7 @@ _dl_setup_hash (struct link_map *map)
   map->l_buckets = hash;
   hash += map->l_nbuckets;
   map->l_chain = hash;
+  __A_VARIABLE = 1;
 }
 
 /* These are here so that we only inline do_lookup{,_versioned} in the common
@@ -637,6 +644,7 @@ _dl_do_lookup (const char *undef_name, unsigned long int hash,
 	       struct r_scope_elem *scope, size_t i,
 	       struct link_map *skip, int type_class)
 {
+  __A_VARIABLE = 1;
   return do_lookup (undef_name, hash, ref, result, scope, i, skip,
 		    type_class);
 }
@@ -649,6 +657,7 @@ _dl_do_lookup_versioned (const char *undef_name, unsigned long int hash,
 			 const struct r_found_version *const version,
 			 struct link_map *skip, int type_class)
 {
+  __A_VARIABLE = 1;
   return do_lookup_versioned (undef_name, hash, ref, result, scope, i,
 			      version, skip, type_class);
 }
diff --git a/newlib/libc/sys/linux/dl/dl-minimal.c b/newlib/libc/sys/linux/dl/dl-minimal.c
index 807bfad..fbe1ac0 100644
--- a/newlib/libc/sys/linux/dl/dl-minimal.c
+++ b/newlib/libc/sys/linux/dl/dl-minimal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Minimal replacements for basic facilities used in the dynamic linker.
    Copyright (C) 1995,96,97,98,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -83,6 +84,7 @@ malloc (size_t n)
 
   alloc_last_block = (void *) alloc_ptr;
   alloc_ptr += n;
+  __A_VARIABLE = 1;
   return alloc_last_block;
 }
 
@@ -94,6 +96,7 @@ calloc (size_t nmemb, size_t size)
 {
   size_t total = nmemb * size;
   void *result = malloc (total);
+  __A_VARIABLE = 1;
   return memset (result, '\0', total);
 }
 
@@ -104,6 +107,7 @@ free (void *ptr)
   /* We can free only the last block allocated.  */
   if (ptr == alloc_last_block)
     alloc_ptr = alloc_last_block;
+  __A_VARIABLE = 1;
 }
 
 /* This is only called with the most recent block returned by malloc.  */
@@ -111,12 +115,15 @@ void * weak_function
 realloc (void *ptr, size_t n)
 {
   void *new;
-  if (ptr == NULL)
+  if (ptr == NULL) {
+    __A_VARIABLE = 1;
     return malloc (n);
+  }
   assert (ptr == alloc_last_block);
   alloc_ptr = alloc_last_block;
   new = malloc (n);
   assert (new == ptr);
+  __A_VARIABLE = 1;
   return new;
 }
 
@@ -157,6 +164,7 @@ __strerror_r (int errnum, char *buf, size_t buflen)
       break;
     }
 
+  __A_VARIABLE = 1;
   return msg;
 }
 
@@ -175,6 +183,7 @@ Inconsistency detected by ld.so: %s: %u: %s%sAssertion `%s' failed!\n",
 		    file, line, function ?: "", function ? ": " : "",
 		    assertion);
 
+  __A_VARIABLE = 1;
 }
 
 void weak_function
@@ -187,6 +196,7 @@ __assert_perror_fail (int errnum,
 Inconsistency detected by ld.so: %s: %u: %s%sUnexpected error: %s\n",
 		    file, line, function ?: "", function ? ": " : "",
 		    __strerror_r (errnum, errbuf, sizeof (errbuf)));
+  __A_VARIABLE = 1;
 }
 
 #endif
@@ -212,6 +222,7 @@ __strtoul_internal (const char *nptr, char **endptr, int base, int group)
     {
       if (endptr != NULL)
 	*endptr = (char *) nptr;
+      __A_VARIABLE = 1;
       return 0UL;
     }
 
@@ -237,6 +248,7 @@ __strtoul_internal (const char *nptr, char **endptr, int base, int group)
 	  errno = ERANGE;
 	  if (endptr != NULL)
 	    *endptr = (char *) nptr;
+	  __A_VARIABLE = 1;
 	  return ULONG_MAX;
 	}
       result *= base;
@@ -246,5 +258,6 @@ __strtoul_internal (const char *nptr, char **endptr, int base, int group)
 
   if (endptr != NULL)
     *endptr = (char *) nptr;
+  __A_VARIABLE = 1;
   return result * sign;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-misc.c b/newlib/libc/sys/linux/dl/dl-misc.c
index 1a4c297..f707d56 100644
--- a/newlib/libc/sys/linux/dl/dl-misc.c
+++ b/newlib/libc/sys/linux/dl/dl-misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Miscellaneous support functions for dynamic linker
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -38,6 +39,7 @@
 int
 _dl_sysdep_open_zero_fill (void)
 {
+  __A_VARIABLE = 1;
   return __open ("/dev/zero", O_RDONLY);
 }
 #endif
@@ -75,6 +77,7 @@ _dl_sysdep_read_whole_file (const char *file, size_t *sizep, int prot)
 	}
       close (fd);
     }
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -238,6 +241,7 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
 
   /* Finally write the result.  */
   writev (fd, iov, niov);
+  __A_VARIABLE = 1;
 }
 
 
@@ -250,6 +254,7 @@ _dl_debug_printf (const char *fmt, ...)
   va_start (arg, fmt);
   _dl_debug_vdprintf (_dl_debug_fd, 1, fmt, arg);
   va_end (arg);
+  __A_VARIABLE = 1;
 }
 
 
@@ -262,6 +267,7 @@ _dl_debug_printf_c (const char *fmt, ...)
   va_start (arg, fmt);
   _dl_debug_vdprintf (_dl_debug_fd, -1, fmt, arg);
   va_end (arg);
+  __A_VARIABLE = 1;
 }
 
 
@@ -274,4 +280,5 @@ _dl_dprintf (int fd, const char *fmt, ...)
   va_start (arg, fmt);
   _dl_debug_vdprintf (fd, 0, fmt, arg);
   va_end (arg);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-object.c b/newlib/libc/sys/linux/dl/dl-object.c
index 1e2049e..5f8d317 100644
--- a/newlib/libc/sys/linux/dl/dl-object.c
+++ b/newlib/libc/sys/linux/dl/dl-object.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Storage management for the chain of loaded shared objects.
    Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -42,8 +43,10 @@ _dl_new_object (char *realname, const char *libname, int type,
 
   new = (struct link_map *) calloc (sizeof (*new) + sizeof (*newname)
 				    + libname_len, 1);
-  if (new == NULL)
+  if (new == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   new->l_libname = newname = (struct libname_list *) (new + 1);
   newname->name = (char *) memcpy (newname + 1, libname, libname_len);
@@ -159,5 +162,6 @@ _dl_new_object (char *realname, const char *libname, int type,
       new->l_origin = origin;
     }
 
+  __A_VARIABLE = 1;
   return new;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-open.c b/newlib/libc/sys/linux/dl/dl-open.c
index 4e068d4..d018b56 100644
--- a/newlib/libc/sys/linux/dl/dl-open.c
+++ b/newlib/libc/sys/linux/dl/dl-open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Load a shared object at runtime, relocate it, and run its initializer.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -213,6 +214,7 @@ dl_open_worker (void *a)
   if (new == NULL)
     {
       assert (mode & RTLD_NOLOAD);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -232,6 +234,7 @@ dl_open_worker (void *a)
       /* Increment just the reference counter of the object.  */
       ++new->l_opencount;
 
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -356,9 +359,11 @@ dl_open_worker (void *a)
   /* Now we can make the new map available in the global scope.  */
   if (mode & RTLD_GLOBAL)
     /* Move the object in the global namespace.  */
-    if (add_to_global (new) != 0)
+    if (add_to_global (new) != 0) {
       /* It failed.  */
+      __A_VARIABLE = 1;
       return;
+    }
 
   /* Mark the object as not deletable if the RTLD_NODELETE flags was
      passed.  */
@@ -369,6 +374,7 @@ dl_open_worker (void *a)
   if (__builtin_expect (_dl_debug_mask & DL_DEBUG_FILES, 0))
     _dl_debug_printf ("opening file=%s; opencount == %u\n\n",
 		      new->l_name, new->l_opencount);
+  __A_VARIABLE = 1;
 }
 
 
@@ -454,6 +460,7 @@ _dl_open (const char *file, int mode, const void *caller)
   DL_STATIC_INIT (args.map);
 #endif
 
+  __A_VARIABLE = 1;
   return args.map;
 }
 
@@ -483,5 +490,6 @@ show_scope (struct link_map *new)
 
       _dl_printf ("\n");
     }
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/dl/dl-profile.c b/newlib/libc/sys/linux/dl/dl-profile.c
index 52c533f..e819986 100644
--- a/newlib/libc/sys/linux/dl/dl-profile.c
+++ b/newlib/libc/sys/linux/dl/dl-profile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Profiling of shared libraries.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -438,8 +439,10 @@ _dl_mcount (ElfW(Addr) frompc, ElfW(Addr) selfpc)
   size_t i, fromindex;
   struct here_fromstruct *fromp;
 
-  if (! running)
+  if (! running) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Compute relative addresses.  The shared object can be loaded at
      any address.  The value of frompc could be anything.  We cannot
@@ -536,4 +539,5 @@ _dl_mcount (ElfW(Addr) frompc, ElfW(Addr) selfpc)
 
  done:
   ;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-profstub.c b/newlib/libc/sys/linux/dl/dl-profstub.c
index 4175886..39b89d4 100644
--- a/newlib/libc/sys/linux/dl/dl-profstub.c
+++ b/newlib/libc/sys/linux/dl/dl-profstub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Helper definitions for profiling of shared libraries.
    Copyright (C) 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -32,6 +33,7 @@ void
 _dl_mcount_wrapper (void *selfpc)
 {
   _dl_mcount ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);
+  __A_VARIABLE = 1;
 }
 
 
@@ -40,4 +42,5 @@ _dl_mcount_wrapper_check (void *selfpc)
 {
   if (_dl_profile_map != NULL)
     _dl_mcount ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-reloc.c b/newlib/libc/sys/linux/dl/dl-reloc.c
index 0bffa4e..a25b0be 100644
--- a/newlib/libc/sys/linux/dl/dl-reloc.c
+++ b/newlib/libc/sys/linux/dl/dl-reloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Relocate a shared object and resolve its references to other loaded objects.
    Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -208,4 +209,5 @@ _dl_reloc_bad_type (struct link_map *map, unsigned int type, int plt)
   strcpy (msgbuf, msg[plt]);
 
   _dl_signal_error (0, map->l_name, NULL, msgbuf);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-runtime.c b/newlib/libc/sys/linux/dl/dl-runtime.c
index 4fb81cf..95a8579 100644
--- a/newlib/libc/sys/linux/dl/dl-runtime.c
+++ b/newlib/libc/sys/linux/dl/dl-runtime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* On-demand PLT fixup for shared objects.
    Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/dl/dl-support.c b/newlib/libc/sys/linux/dl/dl-support.c
index ce53491..a087519 100644
--- a/newlib/libc/sys/linux/dl/dl-support.c
+++ b/newlib/libc/sys/linux/dl/dl-support.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support for dynamic linking code in static libc.
    Copyright (C) 1996, 97, 98, 99, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -132,6 +133,7 @@ _dl_aux_init (ElfW(auxv_t) *av)
 	_dl_clktck = av->a_un.a_val;
 	break;
       }
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -165,6 +167,7 @@ non_dynamic_init (void)
   /* Now determine the length of the platform string.  */
   if (_dl_platform != NULL)
     _dl_platformlen = strlen (_dl_platform);
+  __A_VARIABLE = 1;
 }
 text_set_element (__libc_subinit, non_dynamic_init);
 
@@ -180,5 +183,6 @@ _dl_important_hwcaps (const char *platform, size_t platform_len, size_t *sz,
   result.len = 0;
 
   *sz = 1;
+  __A_VARIABLE = 1;
   return &result;
 }
diff --git a/newlib/libc/sys/linux/dl/dl-sym.c b/newlib/libc/sys/linux/dl/dl-sym.c
index 85d084f..743e0e7 100644
--- a/newlib/libc/sys/linux/dl/dl-sym.c
+++ b/newlib/libc/sys/linux/dl/dl-sym.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Look up a symbol in a shared object loaded by `dlopen'.
    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/dl/dl-version.c b/newlib/libc/sys/linux/dl/dl-version.c
index eefbea7..857f9d5 100644
--- a/newlib/libc/sys/linux/dl/dl-version.c
+++ b/newlib/libc/sys/linux/dl/dl-version.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Handle symbol and library versioning.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -61,16 +62,21 @@ find_needed (const char *name, struct link_map *map)
   unsigned int n;
 
   for (tmap = _dl_loaded; tmap != NULL; tmap = tmap->l_next)
-    if (_dl_name_match_p (name, tmap))
+    if (_dl_name_match_p (name, tmap)) {
+      __A_VARIABLE = 1;
       return tmap;
+    }
 
   /* The required object is not in the global scope, look to see if it is
      a dependency of the current object.  */
   for (n = 0; n < map->l_searchlist.r_nlist; n++)
-    if (_dl_name_match_p (name, map->l_searchlist.r_list[n]))
+    if (_dl_name_match_p (name, map->l_searchlist.r_list[n])) {
+      __A_VARIABLE = 1;
       return map->l_searchlist.r_list[n];
+    }
 
   /* Should never happen.  */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -381,5 +387,6 @@ _dl_check_all_versions (struct link_map *map, int verbose, int trace_mode)
   for (l = map; l != NULL; l = l->l_next)
     result |= ! l->l_faked && _dl_check_map_versions (l, verbose, trace_mode);
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/fclean.c b/newlib/libc/sys/linux/fclean.c
index 2fb11fc..a31e189 100644
--- a/newlib/libc/sys/linux/fclean.c
+++ b/newlib/libc/sys/linux/fclean.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 
 int
 fclean (FILE *fp)
 {
+  __A_VARIABLE = 1;
   return fflush (fp);
 }
diff --git a/newlib/libc/sys/linux/flockfile.c b/newlib/libc/sys/linux/flockfile.c
index 4a6cbc4..76a130b 100644
--- a/newlib/libc/sys/linux/flockfile.c
+++ b/newlib/libc/sys/linux/flockfile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stub to allow libpthread to override */
 
 #include <stdio.h>
@@ -5,5 +6,6 @@
 
 void __libc_flockfile (FILE *fp)
 {
+	__A_VARIABLE = 1;
 }
 weak_alias(__libc_flockfile,flockfile)
diff --git a/newlib/libc/sys/linux/fpathconf.c b/newlib/libc/sys/linux/fpathconf.c
index 6d006a1..b3c607f 100644
--- a/newlib/libc/sys/linux/fpathconf.c
+++ b/newlib/libc/sys/linux/fpathconf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linux specific extensions to fpathconf.
    Copyright (C) 1991,95,96,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -47,49 +48,62 @@ __fpathconf (fd, name)
       /* Determine the filesystem type.  */
       if (__fstatfs (fd, &fsbuf) < 0)
 	{
-	  if (errno == ENOSYS)
+	  if (errno == ENOSYS) {
 	    /* not possible, return the default value.  */
+	    __A_VARIABLE = 1;
 	    return LINUX_LINK_MAX;
+          }
 
 	  /* Some error occured.  */
+          __A_VARIABLE = 1;
           return -1;
 	}
 
       switch (fsbuf.f_type)
 	{
 	case EXT2_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return EXT2_LINK_MAX;
 
 	case MINIX_SUPER_MAGIC:
 	case MINIX_SUPER_MAGIC2:
+	  __A_VARIABLE = 1;
 	  return MINIX_LINK_MAX;
 
 	case MINIX2_SUPER_MAGIC:
 	case MINIX2_SUPER_MAGIC2:
+	  __A_VARIABLE = 1;
 	  return MINIX2_LINK_MAX;
 
 	case XENIX_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return XENIX_LINK_MAX;
 
 	case SYSV4_SUPER_MAGIC:
 	case SYSV2_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return SYSV_LINK_MAX;
 
 	case COH_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return COH_LINK_MAX;
 
 	case UFS_MAGIC:
 	case UFS_CIGAM:
+	  __A_VARIABLE = 1;
 	  return UFS_LINK_MAX;
 
 	case REISERFS_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return REISERFS_LINK_MAX;
 
 	default:
+	  __A_VARIABLE = 1;
 	  return LINUX_LINK_MAX;
 	}
     }
 
+  __A_VARIABLE = 1;
   return posix_fpathconf (fd, name);
 }
 
diff --git a/newlib/libc/sys/linux/free.c b/newlib/libc/sys/linux/free.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/free.c
+++ b/newlib/libc/sys/linux/free.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/freer.c b/newlib/libc/sys/linux/freer.c
index d8d7f98..9103b84 100644
--- a/newlib/libc/sys/linux/freer.c
+++ b/newlib/libc/sys/linux/freer.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void
 _free_r (struct _reent *ptr, void *addr)
 {
   free (addr);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/fstab.c b/newlib/libc/sys/linux/fstab.c
index f98f4b7..6a023f3 100644
--- a/newlib/libc/sys/linux/fstab.c
+++ b/newlib/libc/sys/linux/fstab.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -44,6 +45,7 @@ static struct fstab_state fstab_state;
 int
 setfsent (void)
 {
+  __A_VARIABLE = 1;
   return fstab_init (1) != NULL;
 }
 
@@ -54,10 +56,15 @@ getfsent (void)
   struct fstab_state *state;
 
   state = fstab_init (0);
-  if (state == NULL)
+  if (state == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
-  if (fstab_fetch (state) == NULL)
+  }
+  if (fstab_fetch (state) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
+  __A_VARIABLE = 1;
   return fstab_convert (state);
 }
 
@@ -70,11 +77,16 @@ getfsspec (name)
   struct mntent *m;
 
   state = fstab_init (1);
-  if (state == NULL)
+  if (state == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   while ((m = fstab_fetch (state)) != NULL)
-    if (strcmp (m->mnt_fsname, name) == 0)
+    if (strcmp (m->mnt_fsname, name) == 0) {
+      __A_VARIABLE = 1;
       return fstab_convert (state);
+    }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -87,11 +99,16 @@ getfsfile (name)
   struct mntent *m;
 
   state = fstab_init (1);
-  if (state == NULL)
+  if (state == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   while ((m = fstab_fetch (state)) != NULL)
-    if (strcmp (m->mnt_dir, name) == 0)
+    if (strcmp (m->mnt_dir, name) == 0) {
+      __A_VARIABLE = 1;
       return fstab_convert (state);
+    }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -107,6 +124,7 @@ endfsent ()
       (void) __endmntent (state->fs_fp);
       state->fs_fp = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -149,6 +167,7 @@ fstab_init (int opt_rewind)
 static struct mntent *
 fstab_fetch (struct fstab_state *state)
 {
+  __A_VARIABLE = 1;
   return __getmntent_r (state->fs_fp, &state->fs_mntres,
 			state->fs_buffer, BUFFER_SIZE);
 }
@@ -175,6 +194,7 @@ fstab_convert (struct fstab_state *state)
 		"??");
   f->fs_freq = m->mnt_freq;
   f->fs_passno = m->mnt_passno;
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -190,6 +210,7 @@ fstab_free (void)
   buffer = fstab_state.fs_buffer;
   if (buffer != NULL)
     free ((void *) buffer);
+  __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, fstab_free);
diff --git a/newlib/libc/sys/linux/fstatvfs.c b/newlib/libc/sys/linux/fstatvfs.c
index e1a1260..b94f984 100644
--- a/newlib/libc/sys/linux/fstatvfs.c
+++ b/newlib/libc/sys/linux/fstatvfs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
@@ -36,12 +37,15 @@ fstatvfs (int fd, struct statvfs *buf)
   struct stat64 st;
 
   /* Get as much information as possible from the system.  */
-  if (__fstatfs (fd, &fsbuf) < 0)
+  if (__fstatfs (fd, &fsbuf) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
 #define STAT(st) fstat64 (fd, st)
 #include "internal_statvfs.c"
 
   /* We signal success if the statfs call succeeded.  */
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/fstatvfs64.c b/newlib/libc/sys/linux/fstatvfs64.c
index 65c9e60..e760fb4 100644
--- a/newlib/libc/sys/linux/fstatvfs64.c
+++ b/newlib/libc/sys/linux/fstatvfs64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return information about the filesystem on which FD resides.
    Copyright (C) 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,8 +29,10 @@ __fstatvfs64 (int fd, struct statvfs64 *buf)
 {
   struct statvfs buf32;
 
-  if (fstatvfs (fd, &buf32) < 0)
+  if (fstatvfs (fd, &buf32) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   buf->f_bsize = buf32.f_bsize;
   buf->f_frsize = buf32.f_frsize;
@@ -44,6 +47,7 @@ __fstatvfs64 (int fd, struct statvfs64 *buf)
   buf->f_namemax = buf32.f_namemax;
   memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
 
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__fstatvfs64, fstatvfs64)
diff --git a/newlib/libc/sys/linux/ftok.c b/newlib/libc/sys/linux/ftok.c
index 2f4b684..2dadf65 100644
--- a/newlib/libc/sys/linux/ftok.c
+++ b/newlib/libc/sys/linux/ftok.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, August 1995.
@@ -37,11 +38,14 @@ ftok (pathname, proj_id)
   struct STAT st;
   key_t key;
 
-  if (STAT (pathname, &st) < 0)
+  if (STAT (pathname, &st) < 0) {
+    __A_VARIABLE = 1;
     return (key_t) -1;
+  }
 
   key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)
 	 | ((proj_id & 0xff) << 24));
 
+  __A_VARIABLE = 1;
   return key;
 }
diff --git a/newlib/libc/sys/linux/ftw.c b/newlib/libc/sys/linux/ftw.c
index a7f7259..b6573fb 100644
--- a/newlib/libc/sys/linux/ftw.c
+++ b/newlib/libc/sys/linux/ftw.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* File tree walker functions.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -125,8 +126,11 @@ object_compare (const void *p1, const void *p2)
   const struct known_object *kp1 = p1, *kp2 = p2;
   int cmp1;
   cmp1 = (kp1->dev > kp2->dev) - (kp1->dev < kp2->dev);
-  if (cmp1 != 0)
+  if (cmp1 != 0) {
+    __A_VARIABLE = 1;
     return cmp1;
+  }
+  __A_VARIABLE = 1;
   return (kp1->ino > kp2->ino) - (kp1->ino < kp2->ino);
 }
 
@@ -135,10 +139,13 @@ static inline int
 add_object (struct ftw_data *data, struct STAT *st)
 {
   struct known_object *newp = malloc (sizeof (struct known_object));
-  if (newp == NULL)
+  if (newp == NULL) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   newp->dev = st->st_dev;
   newp->ino = st->st_ino;
+  __A_VARIABLE = 1;
   return tsearch (newp, &data->known_objects, object_compare) ? 0 : -1;
 }
 
@@ -147,6 +154,7 @@ static inline int
 find_object (struct ftw_data *data, struct STAT *st)
 {
   struct known_object obj = { dev: st->st_dev, ino: st->st_ino };
+  __A_VARIABLE = 1;
   return tfind (&obj, &data->known_objects, object_compare) != NULL;
 }
 
@@ -236,6 +244,7 @@ open_dir_stream (struct ftw_data *data, struct dir_data *dirp)
 	}
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -249,9 +258,11 @@ process_entry (struct ftw_data *data, struct dir_data *dir, const char *name,
   int flag = 0;
 
   if (name[0] == '.' && (name[1] == '\0'
-			 || (name[1] == '.' && name[2] == '\0')))
+			 || (name[1] == '.' && name[2] == '\0'))) {
     /* Don't process the "." and ".." entries.  */
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   if (data->dirbufsize < data->ftw.base + namlen + 2)
     {
@@ -260,8 +271,10 @@ process_entry (struct ftw_data *data, struct dir_data *dir, const char *name,
 
       data->dirbufsize *= 2;
       newp = realloc (data->dirbuf, data->dirbufsize);
-      if (newp == NULL)
+      if (newp == NULL) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       data->dirbuf = newp;
     }
 
@@ -337,6 +350,7 @@ process_entry (struct ftw_data *data, struct dir_data *dir, const char *name,
 				&data->ftw);
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -359,6 +373,7 @@ ftw_dir (struct ftw_data *data, struct STAT *st)
 	/* We cannot read the directory.  Signal this with a special flag.  */
 	result = (*data->func) (data->dirbuf, st, FTW_DNR, &data->ftw);
 
+      __A_VARIABLE = 1;
       return result;
     }
 
@@ -366,8 +381,10 @@ ftw_dir (struct ftw_data *data, struct STAT *st)
   if (!(data->flags & FTW_DEPTH))
     {
       result = (*data->func) (data->dirbuf, st, FTW_D, &data->ftw);
-      if (result != 0)
+      if (result != 0) {
+	__A_VARIABLE = 1;
 	return result;
+      }
     }
 
   /* If necessary, change to this directory.  */
@@ -394,6 +411,7 @@ ftw_dir (struct ftw_data *data, struct STAT *st)
 	    data->actdir = data->maxdir - 1;
 	  data->dirstreams[data->actdir] = NULL;
 
+	  __A_VARIABLE = 1;
 	  return result;
 	}
     }
@@ -457,6 +475,7 @@ ftw_dir (struct ftw_data *data, struct STAT *st)
   if (result == 0 && (data->flags & FTW_DEPTH))
     result = (*data->func) (data->dirbuf, st, FTW_DP, &data->ftw);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -477,11 +496,14 @@ ftw_startup (const char *dir, int is_nftw, void *func, int descriptors,
   if (dir[0] == '\0')
     {
       __set_errno (ENOENT);
+      __A_VARIABLE = 1;
       return -1;
     }
 
-  if (access (dir, R_OK) != 0)
+  if (access (dir, R_OK) != 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   data.maxdir = descriptors < 1 ? 1 : descriptors;
   data.actdir = 0;
@@ -495,8 +517,10 @@ ftw_startup (const char *dir, int is_nftw, void *func, int descriptors,
   data.dirbufsize = 2 * strlen (dir);
 #endif
   data.dirbuf = (char *) malloc (data.dirbufsize);
-  if (data.dirbuf == NULL)
+  if (data.dirbuf == NULL) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   len = strlen (dir);
   cp = mempcpy (data.dirbuf, dir, len);
   /* Strip trailing slashes.  */
@@ -613,6 +637,7 @@ ftw_startup (const char *dir, int is_nftw, void *func, int descriptors,
   free (data.dirbuf);
   __set_errno (save_err);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -626,6 +651,7 @@ FTW_NAME (path, func, descriptors)
      FTW_FUNC_T func;
      int descriptors;
 {
+  __A_VARIABLE = 1;
   return ftw_startup (path, 0, func, descriptors, 0);
 }
 
@@ -636,5 +662,6 @@ NFTW_NAME (path, func, descriptors, flags)
      int descriptors;
      int flags;
 {
+  __A_VARIABLE = 1;
   return ftw_startup (path, 1, func, descriptors, flags);
 }
diff --git a/newlib/libc/sys/linux/ftw64.c b/newlib/libc/sys/linux/ftw64.c
index 216549a..2b9824d 100644
--- a/newlib/libc/sys/linux/ftw64.c
+++ b/newlib/libc/sys/linux/ftw64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* File tree walker functions.  LFS version.
    Copyright (C) 1996, 1997, 1998, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/funlockfile.c b/newlib/libc/sys/linux/funlockfile.c
index 82466d3..8eb3a2e 100644
--- a/newlib/libc/sys/linux/funlockfile.c
+++ b/newlib/libc/sys/linux/funlockfile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stub to allow libpthread to override */
 
 #include <stdio.h>
@@ -5,5 +6,6 @@
 
 void __libc_funlockfile (FILE *fp)
 {
+	__A_VARIABLE = 1;
 }
 weak_alias(__libc_funlockfile,funlockfile)
diff --git a/newlib/libc/sys/linux/getdate.c b/newlib/libc/sys/linux/getdate.c
index 5c056c7..ba4b353 100644
--- a/newlib/libc/sys/linux/getdate.c
+++ b/newlib/libc/sys/linux/getdate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Convert a string representation of time to a time value.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -120,8 +121,10 @@ first_wday (int year, int mon, int wday)
 {
   struct tm tm;
 
-  if (wday == INT_MIN)
+  if (wday == INT_MIN) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   memset (&tm, 0, sizeof (struct tm));
   tm.tm_year = year;
@@ -129,6 +132,7 @@ first_wday (int year, int mon, int wday)
   tm.tm_mday = 1;
   mktime (&tm);
 
+  __A_VARIABLE = 1;
   return (1 + (wday - tm.tm_wday + 7) % 7);
 }
 
@@ -147,22 +151,29 @@ check_mday (int year, int mon, int mday)
     case 7:
     case 9:
     case 11:
-      if (mday >= 1 && mday <= 31)
+      if (mday >= 1 && mday <= 31) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
       break;
     case 3:
     case 5:
     case 8:
     case 10:
-      if (mday >= 1 && mday <= 30)
+      if (mday >= 1 && mday <= 30) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
       break;
     case 1:
-      if (mday >= 1 && mday <= (isleap (year) ? 29 : 28))
+      if (mday >= 1 && mday <= (isleap (year) ? 29 : 28)) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
       break;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -181,22 +192,32 @@ getdate_r (const char *string, struct tm *tp)
   int mday_ok = 0;
 
   datemsk = getenv ("DATEMSK");
-  if (datemsk == NULL || *datemsk == '\0')
+  if (datemsk == NULL || *datemsk == '\0') {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
-  if (STAT (datemsk, &st) < 0)
+  if (STAT (datemsk, &st) < 0) {
+    __A_VARIABLE = 1;
     return 3;
+  }
 
-  if (!S_ISREG (st.st_mode))
+  if (!S_ISREG (st.st_mode)) {
+    __A_VARIABLE = 1;
     return 4;
+  }
 
-  if (access (datemsk, R_OK) < 0)
+  if (access (datemsk, R_OK) < 0) {
+    __A_VARIABLE = 1;
     return 2;
+  }
 
   /* Open the template file.  */
   fp = fopen (datemsk, "r");
-  if (fp == NULL)
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
     return 2;
+  }
 
   line = NULL;
   len = 0;
@@ -227,14 +248,17 @@ getdate_r (const char *string, struct tm *tp)
   if (__sferror (fp))
     {
       fclose (fp);
+      __A_VARIABLE = 1;
       return 5;
     }
 
   /* Close template file.  */
   fclose (fp);
 
-  if (result == NULL || *result != '\0')
+  if (result == NULL || *result != '\0') {
+    __A_VARIABLE = 1;
     return 7;
+  }
 
   /* Get current time.  */
   time (&timer);
@@ -300,9 +324,12 @@ getdate_r (const char *string, struct tm *tp)
      call normalizes the struct tm.  */
   if ((!mday_ok && !check_mday (TM_YEAR_BASE + tp->tm_year, tp->tm_mon,
 				tp->tm_mday))
-      || mktime (tp) == (time_t) -1)
+      || mktime (tp) == (time_t) -1) {
+    __A_VARIABLE = 1;
     return 8;
+  }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -317,9 +344,11 @@ getdate (const char *string)
   if (errval != 0)
     {
       getdate_err = errval;
+      __A_VARIABLE = 1;
       return NULL;
     }
 
+  __A_VARIABLE = 1;
   return &tmbuf;
 }
 #endif /* _REENT_ONLY */
diff --git a/newlib/libc/sys/linux/getdate_err.c b/newlib/libc/sys/linux/getdate_err.c
index e90b74b..6115022 100644
--- a/newlib/libc/sys/linux/getdate_err.c
+++ b/newlib/libc/sys/linux/getdate_err.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The getdate_err variable is stored in the reentrancy structure.  This
    function returns its address for use by the getdate_err macro defined in
    time.h.  */
@@ -12,6 +13,7 @@ __getdate_err ()
 {
   struct _reent *ptr = _REENT;
   _REENT_CHECK_MISC(ptr);
+  __A_VARIABLE = 1;
   return _REENT_GETDATE_ERR_P(ptr);
 }
 
diff --git a/newlib/libc/sys/linux/gethostid.c b/newlib/libc/sys/linux/gethostid.c
index bf801c7..8e8c4ac 100644
--- a/newlib/libc/sys/linux/gethostid.c
+++ b/newlib/libc/sys/linux/gethostid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1995,1996,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -41,13 +42,16 @@ sethostid (id)
 
   /* Open file for writing.  Everybody is allowed to read this file.  */
   fd = OPEN (HOSTIDFILE, O_CREAT|O_WRONLY|O_TRUNC, 0644);
-  if (fd < 0)
+  if (fd < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   written = __write (fd, &id, sizeof (id));
 
   __close (fd);
 
+  __A_VARIABLE = 1;
   return written != sizeof (id) ? -1 : 0;
 }
 
diff --git a/newlib/libc/sys/linux/gethostname.c b/newlib/libc/sys/linux/gethostname.c
index ef52691..3cce024 100644
--- a/newlib/libc/sys/linux/gethostname.c
+++ b/newlib/libc/sys/linux/gethostname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <errno.h>
@@ -12,8 +13,10 @@ __gethostname (char *name, size_t len)
 	struct utsname nodebuf;
 	size_t nodelen;
 
-	if (uname (&nodebuf))
+	if (uname (&nodebuf)) {
+		__A_VARIABLE = 1;
 		return -1;
+	}
 
 	nodelen = strlen (nodebuf.nodename) + 1;
 	if (len < nodelen)
@@ -24,8 +27,10 @@ __gethostname (char *name, size_t len)
 	if (nodelen > len)
 	{
 		errno = ENAMETOOLONG;
+		__A_VARIABLE = 1;
 		return -1;
 	}
+	__A_VARIABLE = 1;
 	return 0;
 }
 weak_alias(__gethostname, gethostname)
diff --git a/newlib/libc/sys/linux/getlogin.c b/newlib/libc/sys/linux/getlogin.c
index 3931e77..90de636 100644
--- a/newlib/libc/sys/linux/getlogin.c
+++ b/newlib/libc/sys/linux/getlogin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* FIXME: dummy stub for now.  */
 #include <errno.h>
 #include <unistd.h>
@@ -6,6 +7,7 @@ char *
 _DEFUN_VOID (getlogin)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
diff --git a/newlib/libc/sys/linux/getopt.c b/newlib/libc/sys/linux/getopt.c
index cc035d6..921fb66 100644
--- a/newlib/libc/sys/linux/getopt.c
+++ b/newlib/libc/sys/linux/getopt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Getopt for GNU.
    NOTE: getopt is now part of the C library, so if you don't know what
    "Keep this file name-space clean" means, talk to drepper@gnu.org
diff --git a/newlib/libc/sys/linux/getopt1.c b/newlib/libc/sys/linux/getopt1.c
index 2f149bc..be20de2 100644
--- a/newlib/libc/sys/linux/getopt1.c
+++ b/newlib/libc/sys/linux/getopt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getopt_long and getopt_long_only entry points for GNU getopt.
    Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
      Free Software Foundation, Inc.
@@ -69,6 +70,7 @@ getopt_long (argc, argv, options, long_options, opt_index)
      const struct option *long_options;
      int *opt_index;
 {
+  __A_VARIABLE = 1;
   return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
 }
 
@@ -85,6 +87,7 @@ getopt_long_only (argc, argv, options, long_options, opt_index)
      const struct option *long_options;
      int *opt_index;
 {
+  __A_VARIABLE = 1;
   return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
 }
 
@@ -180,6 +183,7 @@ main (argc, argv)
     }
 
   exit (0);
+  __A_VARIABLE = 1;
 }
 
 #endif /* TEST */
diff --git a/newlib/libc/sys/linux/getpwent.c b/newlib/libc/sys/linux/getpwent.c
index 9479021..d9073c3 100644
--- a/newlib/libc/sys/linux/getpwent.c
+++ b/newlib/libc/sys/linux/getpwent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* FIXME: dummy stub for now.  */
 #include <errno.h>
 #include <pwd.h>
@@ -7,6 +8,7 @@ _DEFUN (getpwnam, (name),
 	_CONST char *name)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -16,6 +18,7 @@ _DEFUN (getpwuid, (uid),
 	uid_t uid)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -25,6 +28,7 @@ _DEFUN (getpwent, (uid),
 	uid_t uid)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return NULL;
 }
 
diff --git a/newlib/libc/sys/linux/getreent.c b/newlib/libc/sys/linux/getreent.c
index 2d84207..28debf7 100644
--- a/newlib/libc/sys/linux/getreent.c
+++ b/newlib/libc/sys/linux/getreent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* default function used by _REENT when not using multithreading */
 
 #include <reent.h>
@@ -6,6 +7,7 @@
 struct _reent *
 __libc_getreent (void)
 {
+  __A_VARIABLE = 1;
   return _impure_ptr;
 }
 weak_alias(__libc_getreent,__getreent)
diff --git a/newlib/libc/sys/linux/getrlimit64.c b/newlib/libc/sys/linux/getrlimit64.c
index dcd67cf..7eb6c3b 100644
--- a/newlib/libc/sys/linux/getrlimit64.c
+++ b/newlib/libc/sys/linux/getrlimit64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -27,8 +28,10 @@ getrlimit64 (enum __rlimit_resource resource, struct rlimit64 *rlimits)
 {
   struct rlimit rlimits32;
 
-  if (__getrlimit (resource, &rlimits32) < 0)
+  if (__getrlimit (resource, &rlimits32) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   if (rlimits32.rlim_cur == RLIM_INFINITY)
     rlimits->rlim_cur = RLIM64_INFINITY;
@@ -39,5 +42,6 @@ getrlimit64 (enum __rlimit_resource resource, struct rlimit64 *rlimits)
   else
     rlimits->rlim_max = rlimits32.rlim_max;
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/getwd.c b/newlib/libc/sys/linux/getwd.c
index 72db338..9b8302d 100644
--- a/newlib/libc/sys/linux/getwd.c
+++ b/newlib/libc/sys/linux/getwd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
@@ -10,11 +11,15 @@ getwd (char *buf)
   if (buf == NULL)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return NULL;
     }
 
-  if (getcwd (tmp, MAXPATHLEN) == NULL)
+  if (getcwd (tmp, MAXPATHLEN) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
+  __A_VARIABLE = 1;
   return strncpy (buf, tmp, MAXPATHLEN);
 }
diff --git a/newlib/libc/sys/linux/iconv/dummy-repertoire.c b/newlib/libc/sys/linux/iconv/dummy-repertoire.c
index a195460..3c269c5 100644
--- a/newlib/libc/sys/linux/iconv/dummy-repertoire.c
+++ b/newlib/libc/sys/linux/iconv/dummy-repertoire.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
@@ -26,6 +27,7 @@ uint32_t
 repertoire_find_value (const struct repertoire_t *repertoire, const char *name,
 		       size_t len)
 {
+  __A_VARIABLE = 1;
   return ILLEGAL_CHAR_VALUE;
 }
 
@@ -33,5 +35,6 @@ repertoire_find_value (const struct repertoire_t *repertoire, const char *name,
 const char *
 repertoire_find_symbol (const struct repertoire_t *repertoire, uint32_t ucs)
 {
+  __A_VARIABLE = 1;
   return NULL;
 }
diff --git a/newlib/libc/sys/linux/iconv/gconv.c b/newlib/libc/sys/linux/iconv/gconv.c
index b413e26..9b12c7d 100644
--- a/newlib/libc/sys/linux/iconv/gconv.c
+++ b/newlib/libc/sys/linux/iconv/gconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Convert characters in input buffer using conversion descriptor to
    output buffer.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@@ -34,8 +35,10 @@ __gconv (__gconv_t cd, const unsigned char **inbuf,
   size_t last_step;
   int result;
 
-  if (cd == (__gconv_t) -1L)
+  if (cd == (__gconv_t) -1L) {
+    __A_VARIABLE = 1;
     return __GCONV_ILLEGAL_DESCRIPTOR;
+  }
 
   last_step = cd->__nsteps - 1;
 
@@ -69,5 +72,6 @@ __gconv (__gconv_t cd, const unsigned char **inbuf,
   if (outbuf != NULL && *outbuf != NULL)
     *outbuf = cd->__data[last_step].__outbuf;
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/iconv/gconv_builtin.c b/newlib/libc/sys/linux/iconv/gconv_builtin.c
index 45bd4e7..1eb92f9 100644
--- a/newlib/libc/sys/linux/iconv/gconv_builtin.c
+++ b/newlib/libc/sys/linux/iconv/gconv_builtin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Table for builtin transformation mapping.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -81,4 +82,5 @@ __gconv_get_builtin_trans (const char *name, struct __gconv_step *step)
 
   /* None of the builtin converters handles stateful encoding.  */
   step->__stateful = 0;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/iconv/gconv_cache.c b/newlib/libc/sys/linux/iconv/gconv_cache.c
index c887be9..560b410 100644
--- a/newlib/libc/sys/linux/iconv/gconv_cache.c
+++ b/newlib/libc/sys/linux/iconv/gconv_cache.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Cache handling for iconv modules.
    Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -47,14 +48,18 @@ __gconv_load_cache (void)
   /* We cannot use the cache if the GCONV_PATH environment variable is
      set.  */
   __gconv_path_envvar = getenv ("GCONV_PATH");
-  if (__gconv_path_envvar != NULL)
+  if (__gconv_path_envvar != NULL) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* See whether the cache file exists.  */
   fd = open (GCONV_MODULES_CACHE, O_RDONLY);
-  if (__builtin_expect (fd, 0) == -1)
+  if (__builtin_expect (fd, 0) == -1) {
     /* Not available.  */
+    __A_VARIABLE = 1;
     return -1;
+  }
 
 #ifdef	_POSIX_ASYNC_IO
   /* Get information about the file.  */
@@ -66,6 +71,7 @@ __gconv_load_cache (void)
 #endif
     close_and_exit:
       close (fd);
+      __A_VARIABLE = 1;
       return -1;
 #ifdef	_POSIX_ASYNC_IO
     }
@@ -129,10 +135,12 @@ __gconv_load_cache (void)
 #endif
       __gconv_cache = NULL;
 
+      __A_VARIABLE = 1;
       return -1;
     }
 
   /* That worked.  */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -206,6 +214,7 @@ find_module (const char *directory, const char *filename,
 	status = result->__init_fct (result);
     }
 
+  __A_VARIABLE = 1;
   return status;
 }
 #endif
@@ -218,8 +227,10 @@ __gconv_compare_alias_cache (const char *name1, const char *name2, int *result)
   size_t name1_idx;
   size_t name2_idx;
 
-  if (__gconv_cache == NULL)
+  if (__gconv_cache == NULL) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   if (find_module_idx (name1, &name1_idx) != 0
       || find_module_idx (name2, &name2_idx) != 0)
@@ -227,6 +238,7 @@ __gconv_compare_alias_cache (const char *name1, const char *name2, int *result)
   else
     *result = (int) (name1_idx - name2_idx);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -441,6 +453,7 @@ __gconv_release_cache (struct __gconv_step *steps, size_t nsteps)
     /* The only thing we have to deallocate is the record with the
        steps.  */
     free (steps);
+  __A_VARIABLE = 1;
 }
 
 
@@ -454,6 +467,7 @@ free_mem (void)
   else
     __munmap (__gconv_cache, cache_size);
 #endif
+  __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/iconv/gconv_close.c b/newlib/libc/sys/linux/iconv/gconv_close.c
index cc0ecd6..3880c78 100644
--- a/newlib/libc/sys/linux/iconv/gconv_close.c
+++ b/newlib/libc/sys/linux/iconv/gconv_close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Release any resource associated with given conversion descriptor.
    Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -61,5 +62,6 @@ __gconv_close (__gconv_t cd)
   free (cd);
 
   /* Close the participating modules.  */
+  __A_VARIABLE = 1;
   return __gconv_close_transform (srunp, nsteps);
 }
diff --git a/newlib/libc/sys/linux/iconv/gconv_conf.c b/newlib/libc/sys/linux/iconv/gconv_conf.c
index c714102..3df5a97 100644
--- a/newlib/libc/sys/linux/iconv/gconv_conf.c
+++ b/newlib/libc/sys/linux/iconv/gconv_conf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Handle configuration data.
    Copyright (C) 1997,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -143,6 +144,7 @@ add_alias (char *rp, void *modules)
     {
       setlocale(LC_ALL, old_locale);
       /* There is no `to' string on the line.  Ignore it.  */
+      __A_VARIABLE = 1;
       return;
     }
   *wp++ = '\0';
@@ -155,6 +157,7 @@ add_alias (char *rp, void *modules)
     {
       setlocale(LC_ALL, old_locale);
       /* No `to' string, ignore the line.  */
+      __A_VARIABLE = 1;
       return;
     }
   *wp++ = '\0';
@@ -164,6 +167,7 @@ add_alias (char *rp, void *modules)
     {
       setlocale(LC_ALL, old_locale);
       /* It does conflict, don't add the alias.  */
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -184,6 +188,7 @@ add_alias (char *rp, void *modules)
 	free (new_alias);
     }
   setlocale(LC_ALL, old_locale);
+  __A_VARIABLE = 1;
 }
 
 
@@ -283,6 +288,7 @@ add_module (char *rp, const char *directory, size_t dir_len, void **modules,
   if (*rp == '\0')
     {
       setlocale(LC_ALL, old_locale);
+      __A_VARIABLE = 1;
       return;
     }
   *rp++ = '\0';
@@ -297,6 +303,7 @@ add_module (char *rp, const char *directory, size_t dir_len, void **modules,
   if (*rp == '\0')
     {
       setlocale(LC_ALL, old_locale);
+      __A_VARIABLE = 1;
       return;
     }
   *wp++ = '\0';
@@ -328,6 +335,7 @@ add_module (char *rp, const char *directory, size_t dir_len, void **modules,
     {
       setlocale(LC_ALL, old_locale);
       /* No module name given.  */
+      __A_VARIABLE = 1;
       return;
     }
   if (module[0] == '/')
@@ -352,6 +360,7 @@ add_module (char *rp, const char *directory, size_t dir_len, void **modules,
     {
       setlocale(LC_ALL, old_locale);
       /* This module duplicates an alias.  */
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -392,6 +401,7 @@ add_module (char *rp, const char *directory, size_t dir_len, void **modules,
       insert_module (new_module, 1);
     }
   setlocale(LC_ALL, old_locale);
+  __A_VARIABLE = 1;
 }
 
 
@@ -409,8 +419,10 @@ read_conf_file (const char *filename, const char *directory, size_t dir_len,
 
   /* Don't complain if a file is not present or readable, simply silently
      ignore it.  */
-  if (fp == NULL)
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Set locale to default C locale. */
   old_locale_p = setlocale(LC_ALL, "C");
@@ -462,6 +474,7 @@ read_conf_file (const char *filename, const char *directory, size_t dir_len,
   fclose (fp);
 
   setlocale(LC_ALL, old_locale);
+  __A_VARIABLE = 1;
 }
 
 
@@ -588,6 +601,7 @@ __gconv_get_path (void)
 #ifdef HAVE_DD_LOCK
   __lock_release(path_lock);
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -610,6 +624,7 @@ __gconv_read_conf (void)
     {
       /* Yes, we are done.  */
       __set_errno (save_errno);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -665,6 +680,7 @@ __gconv_read_conf (void)
 
   /* Restore the error number.  */
   __set_errno (save_errno);
+  __A_VARIABLE = 1;
 }
 
 
@@ -675,6 +691,7 @@ free_mem (void)
 {
   if (__gconv_path_elem != NULL && __gconv_path_elem != &empty_path_elem)
     free ((void *) __gconv_path_elem);
+  __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/iconv/gconv_db.c b/newlib/libc/sys/linux/iconv/gconv_db.c
index 749995e..5fc04db 100644
--- a/newlib/libc/sys/linux/iconv/gconv_db.c
+++ b/newlib/libc/sys/linux/iconv/gconv_db.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Provide access to the collection of available transformation modules.
    Copyright (C) 1997,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -47,6 +48,7 @@ __gconv_alias_compare (const void *p1, const void *p2)
 {
   const struct gconv_alias *s1 = (const struct gconv_alias *) p1;
   const struct gconv_alias *s2 = (const struct gconv_alias *) p2;
+  __A_VARIABLE = 1;
   return strcmp (s1->fromname, s2->fromname);
 }
 
@@ -98,6 +100,7 @@ derivation_compare (const void *p1, const void *p2)
   result = strcmp (s1->from, s2->from);
   if (result == 0)
     result = strcmp (s1->to, s2->to);
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -115,14 +118,17 @@ derivation_lookup (const char *fromset, const char *toset,
 
   result = tfind (&key, &known_derivations, derivation_compare);
 
-  if (result == NULL)
+  if (result == NULL) {
+    __A_VARIABLE = 1;
     return __GCONV_NOCONV;
+  }
 
   *handle = (*result)->steps;
   *nsteps = (*result)->nsteps;
 
   /* Please note that we return GCONV_OK even if the last search for
      this transformation was unsuccessful.  */
+  __A_VARIABLE = 1;
   return __GCONV_OK;
 }
 
@@ -159,6 +165,7 @@ add_derivation (const char *fromset, const char *toset,
   /* Please note that we don't complain if the allocation failed.  This
      is not tragically but in case we use the memory debugging facilities
      not all memory will be freed.  */
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -178,6 +185,7 @@ free_derivation (void *p)
 
   free ((struct __gconv_step *) deriv->steps);
   free (deriv);
+  __A_VARIABLE = 1;
 }
 
 
@@ -202,6 +210,7 @@ __gconv_release_step (struct __gconv_step *step)
 	}
 #endif
     }
+    __A_VARIABLE = 1;
 }
 
 static int
@@ -302,6 +311,7 @@ gen_steps (struct derivation_step *best, const char *toset,
       *handle = NULL;
     }
 
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -348,6 +358,7 @@ increment_counter (struct __gconv_step *steps, size_t nsteps)
 	    step->__init_fct (step);
 	}
     }
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -375,6 +386,7 @@ find_derivation (const char *toset, const char *toset_expand,
 #ifndef STATIC_GCONV
       result = increment_counter (*handle, *nsteps);
 #endif
+      __A_VARIABLE = 1;
       return result;
     }
 
@@ -615,6 +627,7 @@ find_derivation (const char *toset, const char *toset_expand,
   add_derivation (fromset_expand ?: fromset, toset_expand ?: toset,
 		  *handle, *nsteps);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -631,6 +644,7 @@ do_lookup_alias (const char *name)
 
   key.fromname = (char *) name;
   found = tfind (&key, &__gconv_alias_db, __gconv_alias_compare);
+  __A_VARIABLE = 1;
   return found != NULL ? (*found)->toname : NULL;
 }
 
@@ -648,6 +662,7 @@ __gconv_compare_alias (const char *name1, const char *name2)
     result = strcmp (do_lookup_alias (name1) ?: name1,
 		     do_lookup_alias (name2) ?: name2);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -678,6 +693,7 @@ __gconv_find_transform (const char *toset, const char *fromset,
       __lock_release(lock);
 #endif
 
+      __A_VARIABLE = 1;
       return result;
     }
 
@@ -688,6 +704,7 @@ __gconv_find_transform (const char *toset, const char *fromset,
   __lock_release(lock);
 #endif
 
+      __A_VARIABLE = 1;
       return __GCONV_NOCONV;
     }
 
@@ -710,6 +727,7 @@ __gconv_find_transform (const char *toset, const char *fromset,
   __lock_release(lock);
 #endif
 
+      __A_VARIABLE = 1;
       return __GCONV_NOCONV;
     }
 
@@ -725,6 +743,7 @@ __gconv_find_transform (const char *toset, const char *fromset,
   /* The following code is necessary since `find_derivation' will return
      GCONV_OK even when no derivation was found but the same request
      was processed before.  I.e., negative results will also be cached.  */
+  __A_VARIABLE = 1;
   return (result == __GCONV_OK
 	  ? (*handle == NULL ? __GCONV_NOCONV : __GCONV_OK)
 	  : result);
@@ -762,6 +781,7 @@ __gconv_close_transform (struct __gconv_step *steps, size_t nsteps)
 #endif
 
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -783,6 +803,7 @@ free_modules_db (struct gconv_module *node)
 	free (act);
     }
   while (node != NULL);
+  __A_VARIABLE = 1;
 }
 
 
@@ -798,6 +819,7 @@ free_mem (void)
 
   if (known_derivations != NULL)
     tdestroy (known_derivations, free_derivation);
+  __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/iconv/gconv_dl.c b/newlib/libc/sys/linux/iconv/gconv_dl.c
index ee72514..2855894 100644
--- a/newlib/libc/sys/linux/iconv/gconv_dl.c
+++ b/newlib/libc/sys/linux/iconv/gconv_dl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Handle loading/unloading of shared object for transformation.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -58,6 +59,7 @@ known_compare (const void *p1, const void *p2)
   const struct __gconv_loaded_object *s2 =
     (const struct __gconv_loaded_object *) p2;
 
+  __A_VARIABLE = 1;
   return strcmp (s1->name, s2->name);
 }
 
@@ -143,6 +145,7 @@ __gconv_find_shlib (const char *name)
 	found->counter = MAX (found->counter + 1, 1);
     }
 
+  __A_VARIABLE = 1;
   return found;
 }
 
@@ -159,8 +162,10 @@ do_release_shlib (void *nodep, VISIT value, int level)
 
   
 
-  if (value != preorder && value != leaf)
+  if (value != preorder && value != leaf) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   if (obj == release_handle)
     {
@@ -176,6 +181,7 @@ do_release_shlib (void *nodep, VISIT value, int level)
       __libc_dlclose (obj->handle);
       obj->handle = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -191,6 +197,7 @@ __gconv_release_shlib (struct __gconv_loaded_object *handle)
      with release counts <= 0.  This way we can finally unload them
      if necessary.  */
   twalk (loaded, (void *) do_release_shlib);
+  __A_VARIABLE = 1;
 }
 
 
@@ -206,12 +213,14 @@ do_release_all (void *nodep)
     __libc_dlclose (obj->handle);
 
   free (obj);
+  __A_VARIABLE = 1;
 }
 
 static void __attribute__ ((unused))
 free_mem (void)
 {
   tdestroy (loaded, do_release_all);
+  __A_VARIABLE = 1;
 }
 text_set_element (__libc_subfreeres, free_mem);
 
@@ -227,11 +236,13 @@ do_print (const void *nodep, VISIT value, int level)
 	  value == preorder ? "preorder" :
 	  value == postorder ? "postorder" : "endorder",
 	  obj->name, obj->counter);
+  __A_VARIABLE = 1;
 }
 
 static void
 print_all (void)
 {
   __twalk (loaded, do_print);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/iconv/gconv_open.c b/newlib/libc/sys/linux/iconv/gconv_open.c
index 1b2fbb5..4044c18 100644
--- a/newlib/libc/sys/linux/iconv/gconv_open.c
+++ b/newlib/libc/sys/linux/iconv/gconv_open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Find matching transformation algorithms and initialize steps.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -325,5 +326,6 @@ __gconv_open (const char *toset, const char *fromset, __gconv_t *handle,
 
   *handle = result;
   setlocale(LC_ALL, old_locale);
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/newlib/libc/sys/linux/iconv/gconv_simple.c b/newlib/libc/sys/linux/iconv/gconv_simple.c
index edc091f..567617c 100644
--- a/newlib/libc/sys/linux/iconv/gconv_simple.c
+++ b/newlib/libc/sys/linux/iconv/gconv_simple.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Simple transformations functions.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -99,6 +100,7 @@ internal_ucs4_loop (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -147,6 +149,7 @@ internal_ucs4_loop_unaligned (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -172,6 +175,7 @@ internal_ucs4_loop_single (struct __gconv_step *step,
       state->__count &= ~7;
       state->__count |= cnt;
 
+      __A_VARIABLE = 1;
       return __GCONV_INCOMPLETE_INPUT;
     }
 
@@ -197,6 +201,7 @@ internal_ucs4_loop_single (struct __gconv_step *step,
   /* Clear the state buffer.  */
   state->__count &= ~7;
 
+  __A_VARIABLE = 1;
   return __GCONV_OK;
 }
 
@@ -245,9 +250,11 @@ ucs4_internal_loop (struct __gconv_step *step,
 	     this is not an error because of the lack of possibilities to
 	     represent the result.  This is a genuine bug in the input since
 	     UCS4 does not allow such values.  */
-	  if (irreversible == NULL)
+	  if (irreversible == NULL) {
 	    /* We are transliterating, don't try to correct anything.  */
+	    __A_VARIABLE = 1;
 	    return __GCONV_ILLEGAL_INPUT;
+	  }
 
 	  if (flags & __GCONV_IGNORE_ERRORS)
 	    {
@@ -258,6 +265,7 @@ ucs4_internal_loop (struct __gconv_step *step,
 
 	  *inptrp = inptr;
 	  *outptrp = outptr;
+	  __A_VARIABLE = 1;
 	  return __GCONV_ILLEGAL_INPUT;
 	}
 
@@ -276,6 +284,7 @@ ucs4_internal_loop (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -303,9 +312,11 @@ ucs4_internal_loop_unaligned (struct __gconv_step *step,
 	     this is not an error because of the lack of possibilities to
 	     represent the result.  This is a genuine bug in the input since
 	     UCS4 does not allow such values.  */
-	  if (irreversible == NULL)
+	  if (irreversible == NULL) {
 	    /* We are transliterating, don't try to correct anything.  */
+	    __A_VARIABLE = 1;
 	    return __GCONV_ILLEGAL_INPUT;
+	  }
 
 	  if (flags & __GCONV_IGNORE_ERRORS)
 	    {
@@ -316,6 +327,7 @@ ucs4_internal_loop_unaligned (struct __gconv_step *step,
 
 	  *inptrp = inptr;
 	  *outptrp = outptr;
+ 	  __A_VARIABLE = 1;
  	  return __GCONV_ILLEGAL_INPUT;
 	}
 
@@ -344,6 +356,7 @@ ucs4_internal_loop_unaligned (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -461,6 +474,7 @@ internal_ucs4le_loop (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -509,6 +523,7 @@ internal_ucs4le_loop_unaligned (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -534,6 +549,7 @@ internal_ucs4le_loop_single (struct __gconv_step *step,
       state->__count &= ~7;
       state->__count |= cnt;
 
+      __A_VARIABLE = 1;
       return __GCONV_INCOMPLETE_INPUT;
     }
 
@@ -557,6 +573,7 @@ internal_ucs4le_loop_single (struct __gconv_step *step,
   /* Clear the state buffer.  */
   state->__count &= ~7;
 
+  __A_VARIABLE = 1;
   return __GCONV_OK;
 }
 
@@ -604,9 +621,11 @@ ucs4le_internal_loop (struct __gconv_step *step,
 	     this is not an error because of the lack of possibilities to
 	     represent the result.  This is a genuine bug in the input since
 	     UCS4 does not allow such values.  */
-	  if (irreversible == NULL)
+	  if (irreversible == NULL) {
 	    /* We are transliterating, don't try to correct anything.  */
+	    __A_VARIABLE = 1;
 	    return __GCONV_ILLEGAL_INPUT;
+	  }
 
 	  if (flags & __GCONV_IGNORE_ERRORS)
 	    {
@@ -615,6 +634,7 @@ ucs4le_internal_loop (struct __gconv_step *step,
 	      continue;
 	    }
 
+	  __A_VARIABLE = 1;
 	  return __GCONV_ILLEGAL_INPUT;
 	}
 
@@ -633,6 +653,7 @@ ucs4le_internal_loop (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -660,9 +681,11 @@ ucs4le_internal_loop_unaligned (struct __gconv_step *step,
 	     this is not an error because of the lack of possibilities to
 	     represent the result.  This is a genuine bug in the input since
 	     UCS4 does not allow such values.  */
-	  if (irreversible == NULL)
+	  if (irreversible == NULL) {
 	    /* We are transliterating, don't try to correct anything.  */
+	    __A_VARIABLE = 1;
 	    return __GCONV_ILLEGAL_INPUT;
+	  }
 
 	  if (flags & __GCONV_IGNORE_ERRORS)
 	    {
@@ -673,6 +696,7 @@ ucs4le_internal_loop_unaligned (struct __gconv_step *step,
 
 	  *inptrp = inptr;
 	  *outptrp = outptr;
+ 	  __A_VARIABLE = 1;
  	  return __GCONV_ILLEGAL_INPUT;
 	}
 
@@ -702,6 +726,7 @@ ucs4le_internal_loop_unaligned (struct __gconv_step *step,
   else
     result = __GCONV_INCOMPLETE_INPUT;
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
diff --git a/newlib/libc/sys/linux/iconv/gconv_trans.c b/newlib/libc/sys/linux/iconv/gconv_trans.c
index dcc1004..e124f78 100644
--- a/newlib/libc/sys/linux/iconv/gconv_trans.c
+++ b/newlib/libc/sys/linux/iconv/gconv_trans.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Transliteration using the locale's data.
    Copyright (C) 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -39,6 +40,7 @@ __gconv_transliterate (struct __gconv_step *step,
 		       const unsigned char *inbufend,
 		       unsigned char **outbufstart, size_t *irreversible)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -69,6 +71,7 @@ trans_compare (const void *p1, const void *p2)
   const struct known_trans *s1 = (const struct known_trans *) p1;
   const struct known_trans *s2 = (const struct known_trans *) p2;
 
+  __A_VARIABLE = 1;
   return strcmp (s1->info.name, s2->info.name);
 }
 
@@ -81,9 +84,11 @@ open_translit (struct known_trans *trans)
   __gconv_trans_query_fct queryfct;
 
   trans->handle = __libc_dlopen (trans->fname);
-  if (trans->handle == NULL)
+  if (trans->handle == NULL) {
     /* Not available.  */
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Find the required symbol.  */
   queryfct = __libc_dlsym (trans->handle, "gconv_trans_context");
@@ -93,6 +98,7 @@ open_translit (struct known_trans *trans)
     close_and_out:
       __libc_dlclose (trans->handle);
       trans->handle = NULL;
+      __A_VARIABLE = 1;
       return 1;
     }
 
@@ -116,6 +122,7 @@ open_translit (struct known_trans *trans)
 
   trans->open_count = 1;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -226,5 +233,6 @@ __gconv_translit_find (struct trans_struct *trans)
   __lock_release(lock);
 #endif
 
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/newlib/libc/sys/linux/iconv/iconv.c b/newlib/libc/sys/linux/iconv/iconv.c
index 65c6cfc..5ac3511 100644
--- a/newlib/libc/sys/linux/iconv/iconv.c
+++ b/newlib/libc/sys/linux/iconv/iconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Convert characters in input buffer using conversion descriptor to
    output buffer.
    Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@@ -94,5 +95,6 @@ iconv (iconv_t cd, char **__restrict inbuf,
       assert (!"Nothing like this should happen");
     }
 
+  __A_VARIABLE = 1;
   return irreversible;
 }
diff --git a/newlib/libc/sys/linux/iconv/iconv_charmap.c b/newlib/libc/sys/linux/iconv/iconv_charmap.c
index 141c8ec..6d192f4 100644
--- a/newlib/libc/sys/linux/iconv/iconv_charmap.c
+++ b/newlib/libc/sys/linux/iconv/iconv_charmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Convert using charmaps and possibly iconv().
    Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -52,6 +53,7 @@ struct convtable
 static inline struct convtable *
 allocate_table (void)
 {
+  __A_VARIABLE = 1;
   return (struct convtable *) xcalloc (1, sizeof (struct convtable));
 }
 
@@ -59,6 +61,7 @@ allocate_table (void)
 static inline int
 is_term (struct convtable *tbl, unsigned int idx)
 {
+  __A_VARIABLE = 1;
   return tbl->term[idx / 8] & (1 << (idx % 8));
 }
 
@@ -67,6 +70,7 @@ static inline void
 clear_term (struct convtable *tbl, unsigned int idx)
 {
   tbl->term[idx / 8] &= ~(1 << (idx % 8));
+  __A_VARIABLE = 1;
 }
 
 
@@ -74,6 +78,7 @@ static inline void
 set_term (struct convtable *tbl, unsigned int idx)
 {
   tbl->term[idx / 8] |= 1 << (idx % 8);
+  __A_VARIABLE = 1;
 }
 
 
@@ -130,8 +135,10 @@ charmap_conversion (const char *from_code, struct charmap_t *from_charmap,
     }
 
   /* If we couldn't generate a table stop now.  */
-  if (cvtbl == NULL)
+  if (cvtbl == NULL) {
+    __A_VARIABLE = 1;
     return EXIT_FAILURE;
+  }
 
   /* We can now start the conversion.  */
   if (remaining == argc)
@@ -218,6 +225,7 @@ charmap_conversion (const char *from_code, struct charmap_t *from_charmap,
     while (++remaining < argc);
 
   /* All done.  */
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -254,6 +262,7 @@ add_bytes (struct convtable *tbl, struct charseq *in, struct charseq *out)
       set_term (tbl, byte);
       tbl->val[byte].out = out;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -271,9 +280,11 @@ use_from_charmap (struct charmap_t *from_charmap, const char *to_code)
   void *data;
 
   cd = iconv_open (to_code, "WCHAR_T");
-  if (cd == (iconv_t) -1)
+  if (cd == (iconv_t) -1) {
     /* We cannot do anything.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   rettbl = allocate_table ();
 
@@ -319,6 +330,7 @@ use_from_charmap (struct charmap_t *from_charmap, const char *to_code)
 
   iconv_close (cd);
 
+  __A_VARIABLE = 1;
   return rettbl;
 }
 
@@ -341,9 +353,11 @@ use_to_charmap (const char *from_code, struct charmap_t *to_charmap)
      character we are looking for.  Therefore we determine it the other
      way round.  */
   cd = iconv_open (from_code, "WCHAR_T");
-  if (cd == (iconv_t) -1)
+  if (cd == (iconv_t) -1) {
     /* We cannot do anything.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   rettbl = allocate_table ();
 
@@ -389,6 +403,7 @@ use_to_charmap (const char *from_code, struct charmap_t *to_charmap)
 
   iconv_close (cd);
 
+  __A_VARIABLE = 1;
   return rettbl;
 }
 
@@ -416,6 +431,7 @@ use_both_charmaps (struct charmap_t *from_charmap,
 	add_bytes (rettbl, in, out);
     }
 
+  __A_VARIABLE = 1;
   return rettbl;
 }
 
@@ -505,6 +521,7 @@ process_fd (struct convtable *tbl, int fd, FILE *output)
 	{
 	  /* Error while reading.  */
 	  error (0, errno, _("error while reading the input"));
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
 
@@ -536,6 +553,7 @@ process_fd (struct convtable *tbl, int fd, FILE *output)
 	      {
 		/* Error while reading.  */
 		error (0, errno, _("error while reading the input"));
+		__A_VARIABLE = 1;
 		return -1;
 	      }
 
@@ -550,6 +568,7 @@ process_fd (struct convtable *tbl, int fd, FILE *output)
       }
 
   /* Now we have all the input in the buffer.  Process it in one run.  */
+  __A_VARIABLE = 1;
   return process_block (tbl, inbuf, actlen, output);
 }
 
@@ -559,5 +578,6 @@ process_file (struct convtable *tbl, FILE *input, FILE *output)
 {
   /* This should be safe since we use this function only for `stdin' and
      we haven't read anything so far.  */
+  __A_VARIABLE = 1;
   return process_fd (tbl, fileno (input), output);
 }
diff --git a/newlib/libc/sys/linux/iconv/iconv_close.c b/newlib/libc/sys/linux/iconv/iconv_close.c
index 038acc6..e44adf5 100644
--- a/newlib/libc/sys/linux/iconv/iconv_close.c
+++ b/newlib/libc/sys/linux/iconv/iconv_close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Release any resource associated with given conversion descriptor.
    Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -30,8 +31,10 @@ iconv_close (iconv_t cd)
   if (__builtin_expect (cd == (iconv_t *) -1L, 0))
     {
       __set_errno (EBADF);
+      __A_VARIABLE = 1;
       return -1;
     }
 
+  __A_VARIABLE = 1;
   return __gconv_close ((__gconv_t) cd) ? -1 : 0;
 }
diff --git a/newlib/libc/sys/linux/iconv/iconv_open.c b/newlib/libc/sys/linux/iconv/iconv_open.c
index ac44af8..fa0b015 100644
--- a/newlib/libc/sys/linux/iconv/iconv_open.c
+++ b/newlib/libc/sys/linux/iconv/iconv_open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get descriptor for character set conversion.
    Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -58,8 +59,10 @@ iconv_open (const char *tocode, const char *fromcode)
       if (res == __GCONV_NOCONV || res == __GCONV_NODB)
 	__set_errno (EINVAL);
 
+      __A_VARIABLE = 1;
       return (iconv_t) -1;
     }
 
+  __A_VARIABLE = 1;
   return (iconv_t) cd;
 }
diff --git a/newlib/libc/sys/linux/iconv/loop.c b/newlib/libc/sys/linux/iconv/loop.c
index 7d3bf47..ef0d28d 100644
--- a/newlib/libc/sys/linux/iconv/loop.c
+++ b/newlib/libc/sys/linux/iconv/loop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Conversion loop frame work.
    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -288,6 +289,7 @@ FCTNAME (LOOPFCT) (struct __gconv_step *step,
   UPDATE_PARAMS;
 #endif
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -361,14 +363,17 @@ SINGLE(LOOPFCT) (struct __gconv_step *step,
 	state->__value.__wchb[inlen++] = *inptr++;
 #endif
 
+      __A_VARIABLE = 1;
       return __GCONV_INCOMPLETE_INPUT;
     }
 
   /* Enough space in output buffer.  */
   if ((MIN_NEEDED_OUTPUT != 1 && outptr + MIN_NEEDED_OUTPUT > outend)
-      || (MIN_NEEDED_OUTPUT == 1 && outptr >= outend))
+      || (MIN_NEEDED_OUTPUT == 1 && outptr >= outend)) {
     /* Overflow in the output buffer.  */
+    __A_VARIABLE = 1;
     return __GCONV_FULL_OUTPUT;
+  }
 
   /*  Now add characters from the normal input buffer.  */
   do
@@ -420,6 +425,7 @@ SINGLE(LOOPFCT) (struct __gconv_step *step,
 #endif
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 # undef SINGLE
diff --git a/newlib/libc/sys/linux/iconv/skeleton.c b/newlib/libc/sys/linux/iconv/skeleton.c
index cde8533..681c045 100644
--- a/newlib/libc/sys/linux/iconv/skeleton.c
+++ b/newlib/libc/sys/linux/iconv/skeleton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Skeleton for a conversion module.
    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/ids.c b/newlib/libc/sys/linux/ids.c
index f3a95b1..f6d9e7b 100644
--- a/newlib/libc/sys/linux/ids.c
+++ b/newlib/libc/sys/linux/ids.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/ids.c - System calls related to user and group ids  */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/inode.c b/newlib/libc/sys/linux/inode.c
index 3738ade..ccaecbe 100644
--- a/newlib/libc/sys/linux/inode.c
+++ b/newlib/libc/sys/linux/inode.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/inode.c - Inode-related system calls */
 
 /* Written 2000 by Werner Almesberger */
@@ -77,6 +78,7 @@ umask (mode_t mask)
   old_mask = __umask (mask);
   __lock_release(umask_lock);
 
+  __A_VARIABLE = 1;
   return old_mask;
 }
 
@@ -92,6 +94,7 @@ getumask (void)
 
   __lock_release(umask_lock);
 
+  __A_VARIABLE = 1;
   return mask;
 }
 
diff --git a/newlib/libc/sys/linux/internal_statvfs.c b/newlib/libc/sys/linux/internal_statvfs.c
index 9efb7c2..3f53f6f 100644
--- a/newlib/libc/sys/linux/internal_statvfs.c
+++ b/newlib/libc/sys/linux/internal_statvfs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
diff --git a/newlib/libc/sys/linux/intl/bindtextdom.c b/newlib/libc/sys/linux/intl/bindtextdom.c
index afd5030..eb82499 100644
--- a/newlib/libc/sys/linux/intl/bindtextdom.c
+++ b/newlib/libc/sys/linux/intl/bindtextdom.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the bindtextdomain(3) function
    Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -126,6 +127,7 @@ set_binding_values (domainname, dirnamep, codesetp)
 	*dirnamep = NULL;
       if (codesetp)
 	*codesetp = NULL;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -356,6 +358,7 @@ set_binding_values (domainname, dirnamep, codesetp)
     ++_nl_msg_cat_cntr;
 
   __libc_rwlock_unlock (_nl_state_lock);
+  __A_VARIABLE = 1;
 }
 
 /* Specify that the DOMAINNAME message catalog will be found
@@ -366,6 +369,7 @@ BINDTEXTDOMAIN (domainname, dirname)
      const char *dirname;
 {
   set_binding_values (domainname, &dirname, NULL);
+  __A_VARIABLE = 1;
   return (char *) dirname;
 }
 
@@ -377,6 +381,7 @@ BIND_TEXTDOMAIN_CODESET (domainname, codeset)
      const char *codeset;
 {
   set_binding_values (domainname, NULL, &codeset);
+  __A_VARIABLE = 1;
   return (char *) codeset;
 }
 
diff --git a/newlib/libc/sys/linux/intl/catgets.c b/newlib/libc/sys/linux/intl/catgets.c
index b11cc59..6880f6b 100644
--- a/newlib/libc/sys/linux/intl/catgets.c
+++ b/newlib/libc/sys/linux/intl/catgets.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996-2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.org>.
@@ -65,14 +66,19 @@ catopen (const char *cat_name, int flag)
     }
 
   result = (__nl_catd) malloc (sizeof (*result));
-  if (result == NULL)
+  if (result == NULL) {
     /* We cannot get enough memory.  */
+    __A_VARIABLE = 1;
     return (nl_catd) -1;
+  }
 
-  if (__open_catalog (cat_name, nlspath, env_var, result) != 0)
+  if (__open_catalog (cat_name, nlspath, env_var, result) != 0) {
     /* Couldn't open the file.  */
+    __A_VARIABLE = 1;
     return (nl_catd) -1;
+  }
 
+  __A_VARIABLE = 1;
   return (nl_catd) result;
 }
 
@@ -86,8 +92,10 @@ catgets (nl_catd catalog_desc, int set, int message, const char *string)
   size_t cnt;
 
   /* Be generous if catalog which failed to be open is used.  */
-  if (catalog_desc == (nl_catd) -1 || ++set <= 0 || message < 0)
+  if (catalog_desc == (nl_catd) -1 || ++set <= 0 || message < 0) {
+    __A_VARIABLE = 1;
     return (char *) string;
+  }
 
   catalog = (__nl_catd) catalog_desc;
 
@@ -96,14 +104,17 @@ catgets (nl_catd catalog_desc, int set, int message, const char *string)
   do
     {
       if (catalog->name_ptr[idx + 0] == (u_int32_t) set
-	  && catalog->name_ptr[idx + 1] == (u_int32_t) message)
+	  && catalog->name_ptr[idx + 1] == (u_int32_t) message) {
+	__A_VARIABLE = 1;
 	return (char *) &catalog->strings[catalog->name_ptr[idx + 2]];
+      }
 
       idx += catalog->plane_size * 3;
     }
   while (++cnt < catalog->plane_depth);
 
   __set_errno (ENOMSG);
+  __A_VARIABLE = 1;
   return (char *) string;
 }
 
diff --git a/newlib/libc/sys/linux/intl/dcgettext.c b/newlib/libc/sys/linux/intl/dcgettext.c
index c250da4..aec6d87 100644
--- a/newlib/libc/sys/linux/intl/dcgettext.c
+++ b/newlib/libc/sys/linux/intl/dcgettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the dcgettext(3) function.
    Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -50,6 +51,7 @@ DCGETTEXT (domainname, msgid, category)
      const char *msgid;
      int category;
 {
+  __A_VARIABLE = 1;
   return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
 }
 
diff --git a/newlib/libc/sys/linux/intl/dcigettext.c b/newlib/libc/sys/linux/intl/dcigettext.c
index c3b0e1d..fa8f1aa 100644
--- a/newlib/libc/sys/linux/intl/dcigettext.c
+++ b/newlib/libc/sys/linux/intl/dcigettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the internal dcigettext function.
    Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -268,6 +269,7 @@ transcmp (p1, p2)
 	result = s1->category - s2->category;
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -979,12 +981,15 @@ plural_lookup (domain, n, translation, translation_len)
       /* And skip over the NUL byte.  */
       p++;
 
-      if (p >= translation + translation_len)
+      if (p >= translation + translation_len) {
 	/* This should never happen.  It means the plural expression
 	   evaluated to a value larger than the number of variants
 	   available for MSGID1.  */
+	__A_VARIABLE = 1;
 	return (char *) translation;
+      }
     }
+  __A_VARIABLE = 1;
   return (char *) p;
 }
 
@@ -1127,6 +1132,7 @@ category_to_name (category)
     retval = "LC_XXX";
   }
 
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -1188,6 +1194,7 @@ stpcpy (dest, src)
 {
   while ((*dest++ = *src++) != '\0')
     /* Do nothing. */ ;
+  __A_VARIABLE = 1;
   return dest - 1;
 }
 #endif
@@ -1199,6 +1206,7 @@ mempcpy (dest, src, n)
      const void *src;
      size_t n;
 {
+  __A_VARIABLE = 1;
   return (void *) ((char *) memcpy (dest, src, n) + n);
 }
 #endif
@@ -1237,6 +1245,7 @@ free_mem (void)
       transmem_list = transmem_list->next;
       free (old);
     }
+    __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
@@ -1279,8 +1288,11 @@ __dcigettext (domainname, msgid1, msgid2, plural, n, category)
      unsigned long int n;
      int category;
 {
-  if (plural && n > 1)
+  if (plural && n > 1) {
+    __A_VARIABLE = 1;
     return msgid2;
+  }
+  __A_VARIABLE = 1;
   return msgid1;
 }
 weak_alias(__dcigettext, dcigettext)
diff --git a/newlib/libc/sys/linux/intl/dcngettext.c b/newlib/libc/sys/linux/intl/dcngettext.c
index 068d5fa..2870375 100644
--- a/newlib/libc/sys/linux/intl/dcngettext.c
+++ b/newlib/libc/sys/linux/intl/dcngettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the dcngettext(3) function.
    Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -52,6 +53,7 @@ DCNGETTEXT (domainname, msgid1, msgid2, n, category)
      unsigned long int n;
      int category;
 {
+  __A_VARIABLE = 1;
   return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
 }
 
diff --git a/newlib/libc/sys/linux/intl/dgettext.c b/newlib/libc/sys/linux/intl/dgettext.c
index d0e5ed2..cf57922 100644
--- a/newlib/libc/sys/linux/intl/dgettext.c
+++ b/newlib/libc/sys/linux/intl/dgettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the dgettext(3) function.
    Copyright (C) 1995-1997, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -53,6 +54,7 @@ DGETTEXT (domainname, msgid)
      const char *domainname;
      const char *msgid;
 {
+  __A_VARIABLE = 1;
   return DCGETTEXT (domainname, msgid, LC_MESSAGES);
 }
 
diff --git a/newlib/libc/sys/linux/intl/dngettext.c b/newlib/libc/sys/linux/intl/dngettext.c
index a620024..9823b46 100644
--- a/newlib/libc/sys/linux/intl/dngettext.c
+++ b/newlib/libc/sys/linux/intl/dngettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the dngettext(3) function.
    Copyright (C) 1995-1997, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -55,6 +56,7 @@ DNGETTEXT (domainname, msgid1, msgid2, n)
      const char *msgid2;
      unsigned long int n;
 {
+  __A_VARIABLE = 1;
   return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
 }
 
diff --git a/newlib/libc/sys/linux/intl/explodename.c b/newlib/libc/sys/linux/intl/explodename.c
index 6effd33..f108b0a 100644
--- a/newlib/libc/sys/linux/intl/explodename.c
+++ b/newlib/libc/sys/linux/intl/explodename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 
 #ifdef _MB_CAPABLE
@@ -57,6 +58,7 @@ _nl_find_language (name)
 	 && name[0] != '+' && name[0] != ',')
     ++name;
 
+  __A_VARIABLE = 1;
   return (char *) name;
 }
 
@@ -200,6 +202,7 @@ _nl_explode_name (name, language, modifier, territory, codeset,
 	mask &= ~XPG_MODIFIER;
     }
 
+  __A_VARIABLE = 1;
   return mask;
 }
 
diff --git a/newlib/libc/sys/linux/intl/finddomain.c b/newlib/libc/sys/linux/intl/finddomain.c
index 4f27790..5bc3afd 100644
--- a/newlib/libc/sys/linux/intl/finddomain.c
+++ b/newlib/libc/sys/linux/intl/finddomain.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 
 #ifdef _MB_CAPABLE
@@ -214,6 +215,7 @@ free_mem (void)
       free ((char *) here->filename);
       free (here);
     }
+    __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/intl/gettext.c b/newlib/libc/sys/linux/intl/gettext.c
index 2b107d5..bd15d06 100644
--- a/newlib/libc/sys/linux/intl/gettext.c
+++ b/newlib/libc/sys/linux/intl/gettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of gettext(3) function.
    Copyright (C) 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -66,6 +67,7 @@ char *
 GETTEXT (msgid)
      const char *msgid;
 {
+  __A_VARIABLE = 1;
   return DCGETTEXT (NULL, msgid, LC_MESSAGES);
 }
 
diff --git a/newlib/libc/sys/linux/intl/l10nflist.c b/newlib/libc/sys/linux/intl/l10nflist.c
index cb02019..5d78614 100644
--- a/newlib/libc/sys/linux/intl/l10nflist.c
+++ b/newlib/libc/sys/linux/intl/l10nflist.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 
 #ifdef _MB_CAPABLE
@@ -104,6 +105,7 @@ argz_count__ (argz, len)
       len -= part_len + 1;
       count++;
     }
+  __A_VARIABLE = 1;
   return count;
 }
 # undef __argz_count
@@ -129,6 +131,7 @@ argz_stringify__ (argz, len, sep)
       if (len > 0)
 	*argz++ = sep;
     }
+    __A_VARIABLE = 1;
 }
 # undef __argz_stringify
 # define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)
@@ -175,6 +178,7 @@ pop (x)
   x = ((x >> 4) + x) & 0x0f0f;
   x = ((x >> 8) + x) & 0xff;
 
+  __A_VARIABLE = 1;
   return x;
 }
 
@@ -227,8 +231,10 @@ _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
 					   ? strlen (revision) + 1 : 0)) : 0)
 				  + 1 + strlen (filename) + 1);
 
-  if (abs_filename == NULL)
+  if (abs_filename == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   retval = NULL;
   last = NULL;
@@ -305,6 +311,7 @@ _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
   if (retval != NULL || do_allocate == 0)
     {
       free (abs_filename);
+      __A_VARIABLE = 1;
       return retval;
     }
 
@@ -312,8 +319,10 @@ _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
     malloc (sizeof (*retval) + (argz_count (dirlist, dirlist_len)
 				* (1 << pop (mask))
 				* sizeof (struct loaded_l10nfile *)));
-  if (retval == NULL)
+  if (retval == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   retval->filename = abs_filename;
   retval->decided = (argz_count (dirlist, dirlist_len) != 1
@@ -355,6 +364,7 @@ _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
       }
   retval->successor[entries] = NULL;
 
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -400,6 +410,7 @@ _nl_normalize_codeset (codeset, name_len)
       *wp = '\0';
     }
 
+  __A_VARIABLE = 1;
   return (const char *) retval;
 }
 
@@ -418,6 +429,7 @@ stpcpy (dest, src)
 {
   while ((*dest++ = *src++) != '\0')
     /* Do nothing. */ ;
+  __A_VARIABLE = 1;
   return dest - 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/intl/lcl_stpcpy.c b/newlib/libc/sys/linux/intl/lcl_stpcpy.c
index 0af6c67..2c2069e 100644
--- a/newlib/libc/sys/linux/intl/lcl_stpcpy.c
+++ b/newlib/libc/sys/linux/intl/lcl_stpcpy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 char *
 __stpcpy (dest, src)
      char *dest;
@@ -5,6 +6,7 @@ __stpcpy (dest, src)
 {
   while ((*dest++ = *src++) != '\0')
     /* Do nothing. */ ;
+  __A_VARIABLE = 1;
   return dest - 1;
 }
 
diff --git a/newlib/libc/sys/linux/intl/loadmsgcat.c b/newlib/libc/sys/linux/intl/loadmsgcat.c
index 0e5464a..93ebb66 100644
--- a/newlib/libc/sys/linux/intl/loadmsgcat.c
+++ b/newlib/libc/sys/linux/intl/loadmsgcat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 
 #ifdef _MB_CAPABLE 
@@ -188,6 +189,7 @@ init_germanic_plural ()
       germanic_plural.val.args[0] = &plvar;
       germanic_plural.val.args[1] = &plone;
     }
+    __A_VARIABLE = 1;
 }
 
 # define INIT_GERMANIC_PLURAL() init_germanic_plural ()
@@ -305,6 +307,7 @@ _nl_init_domain_conv (domain_file, domain, domainbinding)
 #endif /* _LIBC || HAVE_ICONV */
     }
 
+  __A_VARIABLE = 1;
   return nullentry;
 }
 
@@ -326,6 +329,7 @@ _nl_free_domain_conv (domain)
     iconv_close (domain->conv);
 # endif
 #endif
+  __A_VARIABLE = 1;
 }
 
 /* Load the message catalogs specified by FILENAME.  If it is no valid
@@ -359,13 +363,17 @@ _nl_load_domain (domain_file, domainbinding)
      might be NULL.  This can happen when according to the given
      specification the locale file name is different for XPG and CEN
      syntax.  */
-  if (domain_file->filename == NULL)
+  if (domain_file->filename == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Try to open the addressed file.  */
   fd = open (domain_file->filename, O_RDONLY);
-  if (fd == -1)
+  if (fd == -1) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* We must know about the size of the file.  */
   if (
@@ -379,6 +387,7 @@ _nl_load_domain (domain_file, domainbinding)
     {
       /* Something went wrong.  */
       close (fd);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -404,8 +413,10 @@ _nl_load_domain (domain_file, domainbinding)
       char *read_ptr;
 
       data = (struct mo_file_header *) malloc (size);
-      if (data == NULL)
+      if (data == NULL) {
+	__A_VARIABLE = 1;
 	return;
+      }
 
       to_read = size;
       read_ptr = (char *) data;
@@ -419,6 +430,7 @@ _nl_load_domain (domain_file, domainbinding)
 		continue;
 #endif
 	      close (fd);
+	      __A_VARIABLE = 1;
 	      return;
 	    }
 	  read_ptr += nb;
@@ -441,12 +453,15 @@ _nl_load_domain (domain_file, domainbinding)
       else
 #endif
 	free (data);
+      __A_VARIABLE = 1;
       return;
     }
 
   domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
-  if (domain == NULL)
+  if (domain == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
   domain_file->data = domain;
 
   domain->data = (char *) data;
@@ -477,6 +492,7 @@ _nl_load_domain (domain_file, domainbinding)
 	free (data);
       free (domain);
       domain_file->data = NULL;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -536,6 +552,7 @@ _nl_load_domain (domain_file, domainbinding)
       domain->plural = &germanic_plural;
       domain->nplurals = 2;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -558,6 +575,7 @@ _nl_unload_domain (domain)
     free ((void *) domain->data);
 
   free (domain);
+  __A_VARIABLE = 1;
 }
 #endif
 
diff --git a/newlib/libc/sys/linux/intl/localealias.c b/newlib/libc/sys/linux/intl/localealias.c
index f3a8923..5bcb8bf 100644
--- a/newlib/libc/sys/linux/intl/localealias.c
+++ b/newlib/libc/sys/linux/intl/localealias.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <newlib.h>
 
 #ifdef _MB_CAPABLE
@@ -217,6 +218,7 @@ _nl_expand_alias (name)
   __libc_lock_unlock (lock);
 #endif
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -243,8 +245,10 @@ read_alias_file (fname, fname_len)
 
   fp = fopen (full_fname, "r");
   freea (full_fname);
-  if (fp == NULL)
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
 #ifdef HAVE___FSETLOCKING
   /* No threads present.  */
@@ -321,8 +325,10 @@ read_alias_file (fname, fname_len)
 		*cp++ = '\0';
 
 	      if (nmap >= maxmap)
-		if (__builtin_expect (extend_alias_table (), 0))
+		if (__builtin_expect (extend_alias_table (), 0)) {
+		  __A_VARIABLE = 1;
 		  return added;
+		}
 
 	      alias_len = strlen (alias) + 1;
 	      value_len = strlen (value) + 1;
@@ -334,8 +340,10 @@ read_alias_file (fname, fname_len)
 				     + (alias_len + value_len > 1024
 					? alias_len + value_len : 1024));
 		  char *new_pool = (char *) realloc (string_space, new_size);
-		  if (new_pool == NULL)
+		  if (new_pool == NULL) {
+		    __A_VARIABLE = 1;
 		    return added;
+		  }
 
 		  if (__builtin_expect (string_space != new_pool, 0))
 		    {
@@ -374,6 +382,7 @@ read_alias_file (fname, fname_len)
     qsort (map, nmap, sizeof (struct alias_map),
 	   (int (*) PARAMS ((const void *, const void *))) alias_compare);
 
+  __A_VARIABLE = 1;
   return added;
 }
 
@@ -387,12 +396,15 @@ extend_alias_table ()
   new_size = maxmap == 0 ? 100 : 2 * maxmap;
   new_map = (struct alias_map *) realloc (map, (new_size
 						* sizeof (struct alias_map)));
-  if (new_map == NULL)
+  if (new_map == NULL) {
     /* Simply don't extend: we don't have any more core.  */
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   map = new_map;
   maxmap = new_size;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -405,6 +417,7 @@ free_mem (void)
     free (string_space);
   if (map != NULL)
     free (map);
+  __A_VARIABLE = 1;
 }
 text_set_element (__libc_subfreeres, free_mem);
 #endif
diff --git a/newlib/libc/sys/linux/intl/ngettext.c b/newlib/libc/sys/linux/intl/ngettext.c
index 70d4383..ea053f3 100644
--- a/newlib/libc/sys/linux/intl/ngettext.c
+++ b/newlib/libc/sys/linux/intl/ngettext.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of ngettext(3) function.
    Copyright (C) 1995, 1997, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -68,6 +69,7 @@ NGETTEXT (msgid1, msgid2, n)
      const char *msgid2;
      unsigned long int n;
 {
+  __A_VARIABLE = 1;
   return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
 }
 
diff --git a/newlib/libc/sys/linux/intl/open_catalog.c b/newlib/libc/sys/linux/intl/open_catalog.c
index a0c4a80..f6f84ed 100644
--- a/newlib/libc/sys/linux/intl/open_catalog.c
+++ b/newlib/libc/sys/linux/intl/open_catalog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996-2000, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper, <drepper@gnu.org>.
@@ -187,8 +188,10 @@ __open_catalog (const char *cat_name, const char *nlspath, const char *env_var,
     }
 
   /* Avoid dealing with directories and block devices */
-  if (__builtin_expect (fd, 0) < 0)
+  if (__builtin_expect (fd, 0) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   if (__builtin_expect (fstat64 (fd, &st), 0) < 0)
     goto close_unlock_return;
@@ -330,5 +333,6 @@ __open_catalog (const char *cat_name, const char *nlspath, const char *env_var,
  close_unlock_return:
   __close (fd);
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/intl/plural.c b/newlib/libc/sys/linux/intl/plural.c
index 7585c27..0d49902 100644
--- a/newlib/libc/sys/linux/intl/plural.c
+++ b/newlib/libc/sys/linux/intl/plural.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /*  A Bison parser, made from plural.y
     by GNU Bison version 1.28  */
@@ -122,6 +123,7 @@ static inline struct expression *
 new_exp_0 (op)
      enum operator op;
 {
+  __A_VARIABLE = 1;
   return new_exp (0, op, NULL);
 }
 
@@ -133,6 +135,7 @@ new_exp_1 (op, right)
   struct expression *args[1];
 
   args[0] = right;
+  __A_VARIABLE = 1;
   return new_exp (1, op, args);
 }
 
@@ -146,6 +149,7 @@ new_exp_2 (op, left, right)
 
   args[0] = left;
   args[1] = right;
+  __A_VARIABLE = 1;
   return new_exp (2, op, args);
 }
 
@@ -161,6 +165,7 @@ new_exp_3 (op, bexp, tbranch, fbranch)
   args[0] = bexp;
   args[1] = tbranch;
   args[2] = fbranch;
+  __A_VARIABLE = 1;
   return new_exp (3, op, args);
 }
 
@@ -490,6 +495,7 @@ __yy_memcpy (to, from, count)
 
   while (i-- > 0)
     *t++ = *f++;
+  __A_VARIABLE = 1;
 }
 
 #else /* __cplusplus */
@@ -661,6 +667,7 @@ yynewstate:
 	      free (yyls);
 #endif
 	    }
+	  __A_VARIABLE = 1;
 	  return 2;
 	}
       yystacksize *= 2;
@@ -1121,6 +1128,7 @@ yyerrhandle:
       free (yyls);
 #endif
     }
+  __A_VARIABLE = 1;
   return 0;
 
  yyabortlab:
@@ -1133,6 +1141,7 @@ yyerrhandle:
       free (yyls);
 #endif
     }
+  __A_VARIABLE = 1;
   return 1;
 }
 #line 226 "plural.y"
@@ -1143,8 +1152,10 @@ internal_function
 FREE_EXPRESSION (exp)
      struct expression *exp;
 {
-  if (exp == NULL)
+  if (exp == NULL) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Handle the recursive case.  */
   switch (exp->nargs)
@@ -1163,6 +1174,7 @@ FREE_EXPRESSION (exp)
     }
 
   free (exp);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1179,6 +1191,7 @@ yylex (lval, pexp)
       if (exp[0] == '\0')
 	{
 	  *pexp = exp;
+	  __A_VARIABLE = 1;
 	  return YYEOF;
 	}
 
@@ -1307,6 +1320,7 @@ yylex (lval, pexp)
 
   *pexp = exp;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -1316,4 +1330,5 @@ yyerror (str)
      const char *str;
 {
   /* Do nothing.  We don't print error messages here.  */
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/intl/textdomain.c b/newlib/libc/sys/linux/intl/textdomain.c
index b03ad80..d1f1712 100644
--- a/newlib/libc/sys/linux/intl/textdomain.c
+++ b/newlib/libc/sys/linux/intl/textdomain.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of the textdomain(3) function.
    Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -97,8 +98,10 @@ TEXTDOMAIN (domainname)
   char *old_domain;
 
   /* A NULL pointer requests the current setting.  */
-  if (domainname == NULL)
+  if (domainname == NULL) {
+    __A_VARIABLE = 1;
     return (char *) _nl_current_default_domain;
+  }
 
   __libc_rwlock_wrlock (_nl_state_lock);
 
@@ -146,6 +149,7 @@ TEXTDOMAIN (domainname)
 
   __libc_rwlock_unlock (_nl_state_lock);
 
+  __A_VARIABLE = 1;
   return new_domain;
 }
 
diff --git a/newlib/libc/sys/linux/io.c b/newlib/libc/sys/linux/io.c
index 25dccc6..5152e14 100644
--- a/newlib/libc/sys/linux/io.c
+++ b/newlib/libc/sys/linux/io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/io.c - Basic input/output system calls */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/io64.c b/newlib/libc/sys/linux/io64.c
index ba3ee3c..a81ba85 100644
--- a/newlib/libc/sys/linux/io64.c
+++ b/newlib/libc/sys/linux/io64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/io64.c - large file input/output system calls */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -58,6 +59,7 @@ int __libc_open64(const char *path, int oflag, ...)
        mode = va_arg(list, int);
        va_end(list);
      }
+   __A_VARIABLE = 1;
    return __libc_open(path, oflag | O_LARGEFILE, mode);
 }
 weak_alias(__libc_open64,open64);
diff --git a/newlib/libc/sys/linux/ipc.c b/newlib/libc/sys/linux/ipc.c
index 31e2252..f0f2b24 100644
--- a/newlib/libc/sys/linux/ipc.c
+++ b/newlib/libc/sys/linux/ipc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/ipc.c - IPC semaphore and message queue functions */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -24,6 +25,7 @@ static _syscall5(int,ipc,int,op,int,arg1,int,arg2,int,arg3,void *,arg4);
 int
 semget (key_t key, int nsems, int semflgs)
 {
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_semget, (int)key, nsems, semflgs, NULL);
 }
 
@@ -43,30 +45,35 @@ semctl (int semid, int semnum, int cmd, ...)
 
   va_end (va);
 
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_semctl, semid, semnum, cmd | IPC_64, &arg);
 }
 
 int
 semop (int semid, struct sembuf *sops, size_t nsems)
 {
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_semop, semid, (int)nsems, 0, sops);
 }
 
 int
 msgget (key_t key, int msgflg)
 {
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_msgget, (int)key, msgflg, 0, NULL);
 }
 
 int
 msgctl (int msqid, int cmd, struct msqid_ds *buf)
 {
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_msgctl, msqid, cmd | IPC_64, 0, buf);
 }
 
 int
 msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg)
 {
+  __A_VARIABLE = 1;
   return __libc_ipc(IPCOP_msgsnd, msqid, (int)msgsz, msgflg, (void *)msgp);
 }
 
@@ -82,6 +89,7 @@ msgrcv (int msqid, void *msgp, size_t msgsz, long int msgtyp, int msgflg)
   args.msgp = msgp;
   args.msgtyp = msgtyp;
 
+  __A_VARIABLE = 1;
   return (ssize_t)__libc_ipc(IPCOP_msgrcv, msqid, (int)msgsz, msgflg, &args);
 }
 
diff --git a/newlib/libc/sys/linux/isatty.c b/newlib/libc/sys/linux/isatty.c
index 45e0940..00fceb3 100644
--- a/newlib/libc/sys/linux/isatty.c
+++ b/newlib/libc/sys/linux/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -28,6 +29,7 @@ __isatty (fd)
 {
   struct termios term;
 
+  __A_VARIABLE = 1;
   return tcgetattr (fd, &term) == 0;
 }
 
diff --git a/newlib/libc/sys/linux/linux.c b/newlib/libc/sys/linux/linux.c
index ae11c3f..7386f75 100644
--- a/newlib/libc/sys/linux/linux.c
+++ b/newlib/libc/sys/linux/linux.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/linux.c - System-specific system calls */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/linuxthreads/attr.c b/newlib/libc/sys/linux/linuxthreads/attr.c
index dc964c9..7ca1dc1 100644
--- a/newlib/libc/sys/linux/linuxthreads/attr.c
+++ b/newlib/libc/sys/linux/linuxthreads/attr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -36,6 +37,7 @@ int __pthread_attr_init_2_1(pthread_attr_t *attr)
   attr->__stackaddr = NULL;
   attr->__stackaddr_set = 0;
   attr->__stacksize = STACK_SIZE - ps;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -50,6 +52,7 @@ int __pthread_attr_init_2_0(pthread_attr_t *attr)
   attr->__schedparam.__sched_priority = 0;
   attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
   attr->__scope = PTHREAD_SCOPE_SYSTEM;
+  __A_VARIABLE = 1;
   return 0;
 }
 compat_symbol (libpthread, __pthread_attr_init_2_0, pthread_attr_init,
@@ -58,21 +61,26 @@ compat_symbol (libpthread, __pthread_attr_init_2_0, pthread_attr_init,
 
 int pthread_attr_destroy(pthread_attr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
 {
   if (detachstate < PTHREAD_CREATE_JOINABLE ||
-      detachstate > PTHREAD_CREATE_DETACHED)
+      detachstate > PTHREAD_CREATE_DETACHED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   attr->__detachstate = detachstate;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
 {
   *detachstate = attr->__detachstate;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -82,9 +90,12 @@ int pthread_attr_setschedparam(pthread_attr_t *attr,
   int max_prio = __sched_get_priority_max(attr->__schedpolicy);
   int min_prio = __sched_get_priority_min(attr->__schedpolicy);
 
-  if (param->sched_priority < min_prio || param->sched_priority > max_prio)
+  if (param->sched_priority < min_prio || param->sched_priority > max_prio) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   memcpy (&attr->__schedparam, param, sizeof (struct sched_param));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -92,34 +103,43 @@ int pthread_attr_getschedparam(const pthread_attr_t *attr,
                                struct sched_param *param)
 {
   memcpy (param, &attr->__schedparam, sizeof (struct sched_param));
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
 {
-  if (policy != SCHED_OTHER && policy != SCHED_FIFO && policy != SCHED_RR)
+  if (policy != SCHED_OTHER && policy != SCHED_FIFO && policy != SCHED_RR) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   attr->__schedpolicy = policy;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
 {
   *policy = attr->__schedpolicy;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
 {
-  if (inherit != PTHREAD_INHERIT_SCHED && inherit != PTHREAD_EXPLICIT_SCHED)
+  if (inherit != PTHREAD_INHERIT_SCHED && inherit != PTHREAD_EXPLICIT_SCHED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   attr->__inheritsched = inherit;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
 {
   *inherit = attr->__inheritsched;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -128,10 +148,13 @@ int pthread_attr_setscope(pthread_attr_t *attr, int scope)
   switch (scope) {
   case PTHREAD_SCOPE_SYSTEM:
     attr->__scope = scope;
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_SCOPE_PROCESS:
+    __A_VARIABLE = 1;
     return ENOTSUP;
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -139,16 +162,21 @@ int pthread_attr_setscope(pthread_attr_t *attr, int scope)
 int pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
 {
   *scope = attr->__scope;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int __pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize)
 {
   /* The guard size must not be larger than the stack itself */
-  if (guardsize >= attr->__stacksize) return EINVAL;
+  if (guardsize >= attr->__stacksize) {
+    __A_VARIABLE = 1;
+    return EINVAL;
+  }
 
   attr->__guardsize = guardsize;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_setguardsize, pthread_attr_setguardsize)
@@ -156,6 +184,7 @@ weak_alias (__pthread_attr_setguardsize, pthread_attr_setguardsize)
 int __pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize)
 {
   *guardsize = attr->__guardsize;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_getguardsize, pthread_attr_getguardsize)
@@ -164,6 +193,7 @@ int __pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr)
 {
   attr->__stackaddr = stackaddr;
   attr->__stackaddr_set = 1;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_setstackaddr, pthread_attr_setstackaddr)
@@ -177,6 +207,7 @@ int __pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr)
      no error value but what is if no stack address was set?  We simply
      return the value we have in the member.  */
   *stackaddr = attr->__stackaddr;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_getstackaddr, pthread_attr_getstackaddr)
@@ -214,6 +245,7 @@ weak_alias (__pthread_attr_setstacksize, pthread_attr_setstacksize)
 int __pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize)
 {
   *stacksize = attr->__stacksize;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_getstacksize, pthread_attr_getstacksize)
@@ -238,6 +270,7 @@ int __pthread_attr_setstack (pthread_attr_t *attr, void *stackaddr,
       attr->__stackaddr_set = 1;
     }
 
+  __A_VARIABLE = 1;
   return err;
 }
 weak_alias (__pthread_attr_setstack, pthread_attr_setstack)
@@ -254,6 +287,7 @@ int __pthread_attr_getstack (const pthread_attr_t *attr, void **stackaddr,
   *stackaddr = attr->__stackaddr;
 #endif
   *stacksize = attr->__stacksize;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_attr_getstack, pthread_attr_getstack)
@@ -263,8 +297,10 @@ int pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
   pthread_handle handle = thread_handle (thread);
   pthread_descr descr;
 
-  if (handle == NULL)
+  if (handle == NULL) {
+    __A_VARIABLE = 1;
     return ENOENT;
+  }
 
   descr = handle->h_descr;
 
@@ -273,12 +309,16 @@ int pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
 			 : PTHREAD_CREATE_JOINABLE);
 
   attr->__schedpolicy = __sched_getscheduler (descr->p_pid);
-  if (attr->__schedpolicy == -1)
+  if (attr->__schedpolicy == -1) {
+    __A_VARIABLE = 1;
     return errno;
+  }
 
   if (__sched_getparam (descr->p_pid,
-			(struct sched_param *) &attr->__schedparam) != 0)
+			(struct sched_param *) &attr->__schedparam) != 0) {
+    __A_VARIABLE = 1;
     return errno;
+  }
 
   attr->__inheritsched = descr->p_inheritsched;
   attr->__scope = PTHREAD_SCOPE_SYSTEM;
@@ -304,5 +344,6 @@ int pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
   attr->__stackaddr = (char *)descr;
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/barrier.c b/newlib/libc/sys/linux/linuxthreads/barrier.c
index 1293bad..eb77e43 100644
--- a/newlib/libc/sys/linux/linuxthreads/barrier.c
+++ b/newlib/libc/sys/linux/linuxthreads/barrier.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* POSIX barrier implementation for LinuxThreads.
    Copyright (C) 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -68,6 +69,7 @@ pthread_barrier_wait(pthread_barrier_t *barrier)
 	restart(th);
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -76,20 +78,27 @@ pthread_barrier_init(pthread_barrier_t *barrier,
 				const pthread_barrierattr_t *attr,
 				unsigned int count)
 {
-  if (count == 0)
+  if (count == 0) {
+     __A_VARIABLE = 1;
      return EINVAL;
+  }
 
   __pthread_init_lock(&barrier->__ba_lock);
   barrier->__ba_required = count;
   barrier->__ba_present = 0;
   barrier->__ba_waiting = NULL;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 pthread_barrier_destroy(pthread_barrier_t *barrier)
 {
-  if (barrier->__ba_waiting != NULL) return EBUSY;
+  if (barrier->__ba_waiting != NULL) {
+    __A_VARIABLE = 1;
+    return EBUSY;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -97,12 +106,14 @@ int
 pthread_barrierattr_init(pthread_barrierattr_t *attr)
 {
   attr->__pshared = PTHREAD_PROCESS_PRIVATE;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 pthread_barrierattr_destroy(pthread_barrierattr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -111,15 +122,19 @@ __pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr,
 				 int *pshared)
 {
   *pshared = attr->__pshared;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared)
 {
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
+  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   attr->__pshared = pshared;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/cancel.c b/newlib/libc/sys/linux/linuxthreads/cancel.c
index 0fd6cd0..2e052a4 100644
--- a/newlib/libc/sys/linux/linuxthreads/cancel.c
+++ b/newlib/libc/sys/linux/linuxthreads/cancel.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -33,28 +34,34 @@
 int pthread_setcancelstate(int state, int * oldstate)
 {
   pthread_descr self = thread_self();
-  if (state < PTHREAD_CANCEL_ENABLE || state > PTHREAD_CANCEL_DISABLE)
+  if (state < PTHREAD_CANCEL_ENABLE || state > PTHREAD_CANCEL_DISABLE) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   if (oldstate != NULL) *oldstate = THREAD_GETMEM(self, p_cancelstate);
   THREAD_SETMEM(self, p_cancelstate, state);
   if (THREAD_GETMEM(self, p_canceled) &&
       THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
       THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_setcanceltype(int type, int * oldtype)
 {
   pthread_descr self = thread_self();
-  if (type < PTHREAD_CANCEL_DEFERRED || type > PTHREAD_CANCEL_ASYNCHRONOUS)
+  if (type < PTHREAD_CANCEL_DEFERRED || type > PTHREAD_CANCEL_ASYNCHRONOUS) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   if (oldtype != NULL) *oldtype = THREAD_GETMEM(self, p_canceltype);
   THREAD_SETMEM(self, p_canceltype, type);
   if (THREAD_GETMEM(self, p_canceled) &&
       THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
       THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -70,6 +77,7 @@ int pthread_cancel(pthread_t thread)
   __pthread_lock(&handle->h_lock, NULL);
   if (invalid_handle(handle, thread)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return ESRCH;
   }
 
@@ -80,6 +88,7 @@ int pthread_cancel(pthread_t thread)
 
   if (th->p_cancelstate == PTHREAD_CANCEL_DISABLE || already_canceled) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -113,6 +122,7 @@ int pthread_cancel(pthread_t thread)
   else
     kill(pid, __pthread_sig_cancel);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -122,6 +132,7 @@ void pthread_testcancel(void)
   if (THREAD_GETMEM(self, p_canceled)
       && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
 }
 
 void _pthread_cleanup_push(struct _pthread_cleanup_buffer * buffer,
@@ -134,6 +145,7 @@ void _pthread_cleanup_push(struct _pthread_cleanup_buffer * buffer,
   if (buffer->__prev != NULL && FRAME_LEFT (buffer, buffer->__prev))
     buffer->__prev = NULL;
   THREAD_SETMEM(self, p_cleanup, buffer);
+  __A_VARIABLE = 1;
 }
 
 void _pthread_cleanup_pop(struct _pthread_cleanup_buffer * buffer,
@@ -142,6 +154,7 @@ void _pthread_cleanup_pop(struct _pthread_cleanup_buffer * buffer,
   pthread_descr self = thread_self();
   if (execute) buffer->__routine(buffer->__arg);
   THREAD_SETMEM(self, p_cleanup, buffer->__prev);
+  __A_VARIABLE = 1;
 }
 
 void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
@@ -156,6 +169,7 @@ void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
     buffer->__prev = NULL;
   THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
   THREAD_SETMEM(self, p_cleanup, buffer);
+  __A_VARIABLE = 1;
 }
 
 void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
@@ -169,6 +183,7 @@ void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
       THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
       THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
 }
 
 void __pthread_perform_cleanup(char *currentframe)
@@ -206,6 +221,7 @@ void __pthread_perform_cleanup(char *currentframe)
   if (THREAD_GETMEM(self, p_libc_specific[_LIBC_TSD_KEY_RPC_VARS]) != NULL)
     __rpc_thread_destroy ();
 #endif
+  __A_VARIABLE = 1;
 }
 
 #ifndef SHARED
diff --git a/newlib/libc/sys/linux/linuxthreads/condvar.c b/newlib/libc/sys/linux/linuxthreads/condvar.c
index a06211f..7b4ad02 100644
--- a/newlib/libc/sys/linux/linuxthreads/condvar.c
+++ b/newlib/libc/sys/linux/linuxthreads/condvar.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -30,12 +31,17 @@ int pthread_cond_init(pthread_cond_t *cond,
 {
   __pthread_init_lock(&cond->__c_lock);
   cond->__c_waiting = NULL;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_cond_destroy(pthread_cond_t *cond)
 {
-  if (cond->__c_waiting != NULL) return EBUSY;
+  if (cond->__c_waiting != NULL) {
+    __A_VARIABLE = 1;
+    return EBUSY;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -52,6 +58,7 @@ static int cond_extricate_func(void *obj, pthread_descr th)
   did_remove = remove_from_queue(&cond->__c_waiting, th);
   __pthread_unlock(&cond->__c_lock);
 
+  __A_VARIABLE = 1;
   return did_remove;
 }
 
@@ -65,8 +72,10 @@ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
   /* Check whether the mutex is locked and owned by this thread.  */
   if (mutex->__m_kind != PTHREAD_MUTEX_TIMED_NP
       && mutex->__m_kind != PTHREAD_MUTEX_ADAPTIVE_NP
-      && mutex->__m_owner != self)
+      && mutex->__m_owner != self) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /* Set up extrication interface */
   extr.pu_object = cond;
@@ -130,6 +139,7 @@ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
     restart(self);
 
   pthread_mutex_lock(mutex);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -146,8 +156,10 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
   /* Check whether the mutex is locked and owned by this thread.  */
   if (mutex->__m_kind != PTHREAD_MUTEX_TIMED_NP
       && mutex->__m_kind != PTHREAD_MUTEX_ADAPTIVE_NP
-      && mutex->__m_owner != self)
+      && mutex->__m_owner != self) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /* Set up extrication interface */
   extr.pu_object = cond;
@@ -189,6 +201,7 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
 	if (was_on_queue) {
 	  __pthread_set_own_extricate_if(self, 0);
 	  pthread_mutex_lock(mutex);
+	  __A_VARIABLE = 1;
 	  return ETIMEDOUT;
 	}
 
@@ -224,6 +237,7 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
     restart(self);
 
   pthread_mutex_lock(mutex);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -231,6 +245,7 @@ int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
                            const struct timespec * abstime)
 {
   /* Indirect call through pointer! */
+  __A_VARIABLE = 1;
   return pthread_cond_timedwait_relative(cond, mutex, abstime);
 }
 
@@ -246,6 +261,7 @@ int pthread_cond_signal(pthread_cond_t *cond)
     WRITE_MEMORY_BARRIER();
     restart(th);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -264,16 +280,19 @@ int pthread_cond_broadcast(pthread_cond_t *cond)
     WRITE_MEMORY_BARRIER();
     restart(th);
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_condattr_init(pthread_condattr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_condattr_destroy(pthread_condattr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -282,18 +301,24 @@ int pthread_condattr_destroy(pthread_condattr_t *attr)
 int pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
 {
   *pshared = PTHREAD_PROCESS_PRIVATE;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)
 {
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
+  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
+  if (pshared != PTHREAD_PROCESS_PRIVATE) {
+    __A_VARIABLE = 1;
     return ENOSYS;
+  }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/ecmutex.c b/newlib/libc/sys/linux/linuxthreads/ecmutex.c
index ce54ddf..f0e4e27 100644
--- a/newlib/libc/sys/linux/linuxthreads/ecmutex.c
+++ b/newlib/libc/sys/linux/linuxthreads/ecmutex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Test of the error checking mutex and incidently also barriers.  */
 
 #include <errno.h>
@@ -125,6 +126,7 @@ worker (void *arg)
 	}
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -151,6 +153,7 @@ do_test (void)
     if (pthread_join (threads[i], &res) != 0 || res != NULL)
       result = 1;
 
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/events.c b/newlib/libc/sys/linux/linuxthreads/events.c
index c65bafc..e972c75 100644
--- a/newlib/libc/sys/linux/linuxthreads/events.c
+++ b/newlib/libc/sys/linux/linuxthreads/events.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Event functions used while debugging.
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -24,14 +25,17 @@
 void
 __linuxthreads_create_event (void)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __linuxthreads_death_event (void)
 {
+	__A_VARIABLE = 1;
 }
 
 void
 __linuxthreads_reap_event (void)
 {
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/getcpuclockid.c b/newlib/libc/sys/linux/linuxthreads/getcpuclockid.c
index 76d39a5..bbad3b6 100644
--- a/newlib/libc/sys/linux/linuxthreads/getcpuclockid.c
+++ b/newlib/libc/sys/linux/linuxthreads/getcpuclockid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/linuxthreads/getreent.c b/newlib/libc/sys/linux/linuxthreads/getreent.c
index e73c4a5..ff03343 100644
--- a/newlib/libc/sys/linux/linuxthreads/getreent.c
+++ b/newlib/libc/sys/linux/linuxthreads/getreent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* get thread-specific reentrant pointer */
 
 #include <internals.h>
@@ -6,6 +7,7 @@ struct _reent *
 __getreent (void)
 {
   pthread_descr self = thread_self();
+  __A_VARIABLE = 1;
   return THREAD_GETMEM(self, p_reentp);
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/join.c b/newlib/libc/sys/linux/linuxthreads/join.c
index a6ed08c..bd14105 100644
--- a/newlib/libc/sys/linux/linuxthreads/join.c
+++ b/newlib/libc/sys/linux/linuxthreads/join.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -26,6 +27,7 @@
 void pthread_exit(void * retval)
 {
   __pthread_do_exit (retval, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
 }
 
 void __pthread_do_exit(void *retval, char *currentframe)
@@ -88,6 +90,7 @@ void __pthread_do_exit(void *retval, char *currentframe)
   /* Threads other than the main one  terminate without flushing stdio streams
      or running atexit functions. */
   _exit(0);
+  __A_VARIABLE = 1;
 }
 
 /* Function called by pthread_cancel to remove the thread from
@@ -106,6 +109,7 @@ static int join_extricate_func(void *obj, pthread_descr th)
   jo->p_joining = NULL;
   __pthread_unlock(&handle->h_lock);
 
+  __A_VARIABLE = 1;
   return did_remove;
 }
 
@@ -125,16 +129,19 @@ int pthread_join(pthread_t thread_id, void ** thread_return)
   __pthread_lock(&handle->h_lock, self);
   if (nonexisting_handle(handle, thread_id)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return ESRCH;
   }
   th = handle->h_descr;
   if (th == self) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return EDEADLK;
   }
   /* If detached or already joined, error */
   if (th->p_detached || th->p_joining != NULL) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return EINVAL;
   }
   /* If not terminated yet, suspend ourselves. */
@@ -176,6 +183,7 @@ int pthread_join(pthread_t thread_id, void ** thread_return)
     TEMP_FAILURE_RETRY(__libc_write(__pthread_manager_request,
 				    (char *) &request, sizeof(request)));
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -189,17 +197,20 @@ int pthread_detach(pthread_t thread_id)
   __pthread_lock(&handle->h_lock, NULL);
   if (nonexisting_handle(handle, thread_id)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return ESRCH;
   }
   th = handle->h_descr;
   /* If already detached, error */
   if (th->p_detached) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return EINVAL;
   }
   /* If already joining, don't do anything. */
   if (th->p_joining != NULL) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return 0;
   }
   /* Mark as detached */
@@ -214,5 +225,6 @@ int pthread_detach(pthread_t thread_id)
     TEMP_FAILURE_RETRY(__libc_write(__pthread_manager_request,
 				    (char *) &request, sizeof(request)));
   }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/joinrace.c b/newlib/libc/sys/linux/linuxthreads/joinrace.c
index 163e0b2..4cd439a 100644
--- a/newlib/libc/sys/linux/linuxthreads/joinrace.c
+++ b/newlib/libc/sys/linux/linuxthreads/joinrace.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Test case by Permaine Cheung <pcheung@cygnus.com>.  */
 
 #include <errno.h>
@@ -9,6 +10,7 @@ static void *
 sub1 (void *arg)
 {
   /* Nothing.  */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -32,6 +34,7 @@ main (void)
       if (istatus != ESRCH)
 	{
 	  printf ("pthread_getschedparam returns: %d\n", istatus);
+	  __A_VARIABLE = 1;
 	  return 1;
 	}
 
@@ -40,9 +43,11 @@ main (void)
       if (istatus != ESRCH)
 	{
 	  printf ("pthread_setschedparam returns: %d\n", istatus);
+	  __A_VARIABLE = 1;
 	  return 2;
 	}
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/lockfile.c b/newlib/libc/sys/linux/linuxthreads/lockfile.c
index 0aeb150..516e2fb 100644
--- a/newlib/libc/sys/linux/linuxthreads/lockfile.c
+++ b/newlib/libc/sys/linux/linuxthreads/lockfile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lockfile - Handle locking and unlocking of stream.
    Copyright (C) 1996, 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -36,6 +37,7 @@ void
 __flockfile (FILE *stream)
 {
   __lock_acquire_recursive (*(_LOCK_RECURSIVE_T *)&stream->_lock);
+  __A_VARIABLE = 1;
 }
 #undef _IO_flockfile
 strong_alias (__flockfile, _IO_flockfile)
@@ -46,6 +48,7 @@ void
 __funlockfile (FILE *stream)
 {
   __lock_release_recursive (*(_LOCK_RECURSIVE_T *)&stream->_lock);
+  __A_VARIABLE = 1;
 }
 #undef _IO_funlockfile
 strong_alias (__funlockfile, _IO_funlockfile)
@@ -55,6 +58,7 @@ weak_alias (__funlockfile, funlockfile);
 int
 __ftrylockfile (FILE *stream)
 {
+  __A_VARIABLE = 1;
   return __lock_try_acquire_recursive (*(_LOCK_RECURSIVE_T *)&stream->_lock);
 }
 strong_alias (__ftrylockfile, _IO_ftrylockfile)
@@ -66,6 +70,7 @@ __flockfilelist(void)
 #ifdef USE_IN_LIBIO
   _IO_list_lock();
 #endif
+  __A_VARIABLE = 1;
 }
 
 void
@@ -74,6 +79,7 @@ __funlockfilelist(void)
 #ifdef USE_IN_LIBIO
   _IO_list_unlock();
 #endif
+  __A_VARIABLE = 1;
 }
 
 void
@@ -94,4 +100,5 @@ __fresetlockfiles (void)
 
   _IO_list_resetlock();
 #endif
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/machine/i386/pspinlock.c b/newlib/libc/sys/linux/linuxthreads/machine/i386/pspinlock.c
index 5d24238..9eaf2ae 100644
--- a/newlib/libc/sys/linux/linuxthreads/machine/i386/pspinlock.c
+++ b/newlib/libc/sys/linux/linuxthreads/machine/i386/pspinlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* POSIX spinlock implementation.  x86 version.
    Copyright (C) 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -46,6 +47,7 @@ __pthread_spin_lock (pthread_spinlock_t *lock)
      "jmp 1b\n\t"
      ".previous"
      : "=m" (*lock));
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_spin_lock, pthread_spin_lock)
@@ -60,6 +62,7 @@ __pthread_spin_trylock (pthread_spinlock_t *lock)
     ("xchgl %0,%1"
      : "=r" (oldval), "=m" (*lock)
      : "0" (0));
+  __A_VARIABLE = 1;
   return oldval > 0 ? 0 : EBUSY;
 }
 weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
@@ -71,6 +74,7 @@ __pthread_spin_unlock (pthread_spinlock_t *lock)
   asm volatile
     ("movl $1,%0"
      : "=m" (*lock));
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
@@ -83,6 +87,7 @@ __pthread_spin_init (pthread_spinlock_t *lock, int pshared)
      all processes which can access the memory location `lock' points
      to can use the spinlock.  */
   *lock = 1;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_spin_init, pthread_spin_init)
@@ -92,6 +97,7 @@ int
 __pthread_spin_destroy (pthread_spinlock_t *lock)
 {
   /* Nothing to do.  */
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/newlib/libc/sys/linux/linuxthreads/manager.c b/newlib/libc/sys/linux/linuxthreads/manager.c
index 492b956..1f27a4c 100644
--- a/newlib/libc/sys/linux/linuxthreads/manager.c
+++ b/newlib/libc/sys/linux/linuxthreads/manager.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -70,6 +71,7 @@ volatile pthread_descr __pthread_last_event;
 #else
 static inline pthread_descr thread_segment(int seg)
 {
+  __A_VARIABLE = 1;
   return (pthread_descr)(THREAD_STACK_START_ADDRESS - (seg - 1) * STACK_SIZE)
          - 1;
 }
@@ -222,6 +224,7 @@ __pthread_manager(void *arg)
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 int __pthread_manager_event(void *arg)
@@ -236,6 +239,7 @@ int __pthread_manager_event(void *arg)
   /* Free it immediately.  */
   __pthread_unlock (THREAD_GETMEM((&__pthread_manager_thread), p_lock));
 
+  __A_VARIABLE = 1;
   return __pthread_manager(arg);
 }
 
@@ -293,6 +297,7 @@ pthread_start_thread(void *arg)
 							   p_start_args.arg));
   /* Exit with the given return value */
   __pthread_do_exit(outcome, CURRENT_STACK_FRAME);
+  __A_VARIABLE = 1;
 }
 
 static int
@@ -314,6 +319,7 @@ pthread_start_thread_event(void *arg)
 
   /* Continue with the real function.  */
   pthread_start_thread (arg);
+  __A_VARIABLE = 1;
 }
 
 static int pthread_allocate_stack(const pthread_attr_t *attr,
@@ -539,13 +545,17 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
      we can  do this.  Normally this should be done by examining the
      return value of the __sched_setscheduler call in pthread_start_thread
      but this is hard to implement.  FIXME  */
-  if (attr != NULL && attr->__schedpolicy != SCHED_OTHER && geteuid () != 0)
+  if (attr != NULL && attr->__schedpolicy != SCHED_OTHER && geteuid () != 0) {
+    __A_VARIABLE = 1;
     return EPERM;
+  }
   /* Find a free segment for the thread, and allocate a stack if needed */
   for (sseg = 2; ; sseg++)
     {
-      if (sseg >= PTHREAD_THREADS_MAX)
+      if (sseg >= PTHREAD_THREADS_MAX) {
+	__A_VARIABLE = 1;
 	return EAGAIN;
+      }
       if (__pthread_handles[sseg].h_descr != NULL)
 	continue;
       if (pthread_allocate_stack(attr, thread_segment(sseg),
@@ -709,6 +719,7 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
     __pthread_handles[sseg].h_descr = NULL;
     __pthread_handles[sseg].h_bottom = NULL;
     __pthread_handles_num--;
+    __A_VARIABLE = 1;
     return errno;
   }
   /* Insert new thread in doubly linked list of active threads */
@@ -719,6 +730,7 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
   /* Set pid field of the new thread, in case we get there before the
      child starts. */
   new_thread->p_pid = pid;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -782,6 +794,7 @@ static void pthread_free(pthread_descr th)
       /* Unmap the stack.  */
       munmap(guardaddr, stacksize + guardsize);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Handle threads that have exited */
@@ -834,6 +847,7 @@ static void pthread_exited(pid_t pid)
     restart(__pthread_main_thread);
     /* Same logic as REQ_MAIN_THREAD_EXIT. */
   }
+  __A_VARIABLE = 1;
 }
 
 static void pthread_reap_children(void)
@@ -850,6 +864,7 @@ static void pthread_reap_children(void)
       _exit(0);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 /* Try to free the resources of a thread when requested by pthread_join
@@ -865,6 +880,7 @@ static void pthread_handle_free(pthread_t th_id)
     /* pthread_reap_children has deallocated the thread already,
        nothing needs to be done */
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return;
   }
   th = handle->h_descr;
@@ -878,6 +894,7 @@ static void pthread_handle_free(pthread_t th_id)
     th->p_detached = 1;
     __pthread_unlock(&handle->h_lock);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Send a signal to all running threads */
@@ -893,6 +910,7 @@ static void pthread_kill_all_threads(int sig, int main_thread_also)
   if (main_thread_also) {
     kill(__pthread_main_thread->p_pid, sig);
   }
+  __A_VARIABLE = 1;
 }
 
 static void pthread_for_each_thread(void *arg, 
@@ -907,6 +925,7 @@ static void pthread_for_each_thread(void *arg,
   }
 
   fn(arg, __pthread_main_thread);
+  __A_VARIABLE = 1;
 }
 
 /* Process-wide exit() */
@@ -941,6 +960,7 @@ static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
   __fresetlockfiles();
   restart(issuing_thread);
   _exit(0);
+  __A_VARIABLE = 1;
 }
 
 /* Handler for __pthread_sig_cancel in thread manager thread */
@@ -964,6 +984,7 @@ void __pthread_manager_sighandler(int sig)
     TEMP_FAILURE_RETRY(__libc_write(__pthread_manager_request,
 				    (char *) &request, sizeof(request)));
   }
+  __A_VARIABLE = 1;
 }
 
 /* Adjust priority of thread manager so that it always run at a priority
@@ -973,10 +994,14 @@ void __pthread_manager_adjust_prio(int thread_prio)
 {
   struct sched_param param;
 
-  if (thread_prio <= __pthread_manager_thread.p_priority) return;
+  if (thread_prio <= __pthread_manager_thread.p_priority) {
+    __A_VARIABLE = 1;
+    return;
+  }
   param.sched_priority =
     thread_prio < __sched_get_priority_max(SCHED_FIFO)
     ? thread_prio + 1 : thread_prio;
   __sched_setscheduler(__pthread_manager_thread.p_pid, SCHED_FIFO, &param);
   __pthread_manager_thread.p_priority = thread_prio;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/mq_notify.c b/newlib/libc/sys/linux/linuxthreads/mq_notify.c
index 46492e4..3f86469 100644
--- a/newlib/libc/sys/linux/linuxthreads/mq_notify.c
+++ b/newlib/libc/sys/linux/linuxthreads/mq_notify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -21,6 +22,7 @@ __cleanup_mq_notify (struct libc_mq *info)
   /* kill notification thread and allow other processes to set a notification */
   pthread_cancel ((pthread_t)info->th);
   semop (info->semid, &sb4, 1);
+  __A_VARIABLE = 1;
 }
   
 static void *
@@ -56,6 +58,7 @@ mq_notify_process (void *arg)
 	}
     }
   pthread_exit (NULL);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -71,6 +74,7 @@ mq_notify (mqd_t msgid, const struct sigevent *notification)
   if (info == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -80,6 +84,7 @@ mq_notify (mqd_t msgid, const struct sigevent *notification)
   if (rc == -1)
     {
       errno = EBUSY;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -95,6 +100,7 @@ mq_notify (mqd_t msgid, const struct sigevent *notification)
   else
     info->cleanup_notify = &__cleanup_mq_notify;
 
+  __A_VARIABLE = 1;
   return rc;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/mutex.c b/newlib/libc/sys/linux/linuxthreads/mutex.c
index fb2e607..456fccc 100644
--- a/newlib/libc/sys/linux/linuxthreads/mutex.c
+++ b/newlib/libc/sys/linux/linuxthreads/mutex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -33,6 +34,7 @@ int __pthread_mutex_init(pthread_mutex_t * mutex,
     mutex_attr == NULL ? PTHREAD_MUTEX_TIMED_NP : mutex_attr->__mutexkind;
   mutex->__m_count = 0;
   mutex->__m_owner = NULL;
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_mutex_init, pthread_mutex_init)
@@ -42,15 +44,22 @@ int __pthread_mutex_destroy(pthread_mutex_t * mutex)
   switch (mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
   case PTHREAD_MUTEX_RECURSIVE_NP:
-    if ((mutex->__m_lock.__status & 1) != 0)
+    if ((mutex->__m_lock.__status & 1) != 0) {
+      __A_VARIABLE = 1;
       return EBUSY;
+    }
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
   case PTHREAD_MUTEX_TIMED_NP:
-    if (mutex->__m_lock.__status != 0)
+    if (mutex->__m_lock.__status != 0) {
+      __A_VARIABLE = 1;
       return EBUSY;
+    }
+    __A_VARIABLE = 1;
     return 0;
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -64,11 +73,13 @@ int __pthread_mutex_trylock(pthread_mutex_t * mutex)
   switch(mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
     retcode = __pthread_trylock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return retcode;
   case PTHREAD_MUTEX_RECURSIVE_NP:
     self = thread_self();
     if (mutex->__m_owner == self) {
       mutex->__m_count++;
+      __A_VARIABLE = 1;
       return 0;
     }
     retcode = __pthread_trylock(&mutex->__m_lock);
@@ -76,17 +87,21 @@ int __pthread_mutex_trylock(pthread_mutex_t * mutex)
       mutex->__m_owner = self;
       mutex->__m_count = 0;
     }
+    __A_VARIABLE = 1;
     return retcode;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
     retcode = __pthread_alt_trylock(&mutex->__m_lock);
     if (retcode == 0) {
       mutex->__m_owner = thread_self();
     }
+    __A_VARIABLE = 1;
     return retcode;
   case PTHREAD_MUTEX_TIMED_NP:
     retcode = __pthread_alt_trylock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return retcode;
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -99,27 +114,36 @@ int __pthread_mutex_lock(pthread_mutex_t * mutex)
   switch(mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
     __pthread_lock(&mutex->__m_lock, NULL);
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_RECURSIVE_NP:
     self = thread_self();
     if (mutex->__m_owner == self) {
       mutex->__m_count++;
+      __A_VARIABLE = 1;
       return 0;
     }
     __pthread_lock(&mutex->__m_lock, self);
     mutex->__m_owner = self;
     mutex->__m_count = 0;
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
     self = thread_self();
-    if (mutex->__m_owner == self) return EDEADLK;
+    if (mutex->__m_owner == self) {
+      __A_VARIABLE = 1;
+      return EDEADLK;
+    }
     __pthread_alt_lock(&mutex->__m_lock, self);
     mutex->__m_owner = self;
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_TIMED_NP:
     __pthread_alt_lock(&mutex->__m_lock, NULL);
+    __A_VARIABLE = 1;
     return 0;
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -132,38 +156,50 @@ int __pthread_mutex_timedlock (pthread_mutex_t *mutex,
   int res;
 
   if (__builtin_expect (abstime->tv_nsec, 0) < 0
-      || __builtin_expect (abstime->tv_nsec, 0) >= 1000000000)
+      || __builtin_expect (abstime->tv_nsec, 0) >= 1000000000) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   switch(mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
     __pthread_lock(&mutex->__m_lock, NULL);
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_RECURSIVE_NP:
     self = thread_self();
     if (mutex->__m_owner == self) {
       mutex->__m_count++;
+      __A_VARIABLE = 1;
       return 0;
     }
     __pthread_lock(&mutex->__m_lock, self);
     mutex->__m_owner = self;
     mutex->__m_count = 0;
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
     self = thread_self();
-    if (mutex->__m_owner == self) return EDEADLK;
+    if (mutex->__m_owner == self) {
+	__A_VARIABLE = 1;
+	return EDEADLK;
+    }
     res = __pthread_alt_timedlock(&mutex->__m_lock, self, abstime);
     if (res != 0)
       {
 	mutex->__m_owner = self;
+	__A_VARIABLE = 1;
 	return 0;
       }
+    __A_VARIABLE = 1;
     return ETIMEDOUT;
   case PTHREAD_MUTEX_TIMED_NP:
     /* Only this type supports timed out lock. */
+    __A_VARIABLE = 1;
     return (__pthread_alt_timedlock(&mutex->__m_lock, NULL, abstime)
 	    ? 0 : ETIMEDOUT);
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -174,27 +210,37 @@ int __pthread_mutex_unlock(pthread_mutex_t * mutex)
   switch (mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
     __pthread_unlock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_RECURSIVE_NP:
-    if (mutex->__m_owner != thread_self())
+    if (mutex->__m_owner != thread_self()) {
+      __A_VARIABLE = 1;
       return EPERM;
+    }
     if (mutex->__m_count > 0) {
       mutex->__m_count--;
+      __A_VARIABLE = 1;
       return 0;
     }
     mutex->__m_owner = NULL;
     __pthread_unlock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_ERRORCHECK_NP:
-    if (mutex->__m_owner != thread_self() || mutex->__m_lock.__status == 0)
+    if (mutex->__m_owner != thread_self() || mutex->__m_lock.__status == 0) {
+      __A_VARIABLE = 1;
       return EPERM;
+    }
     mutex->__m_owner = NULL;
     __pthread_alt_unlock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return 0;
   case PTHREAD_MUTEX_TIMED_NP:
     __pthread_alt_unlock(&mutex->__m_lock);
+    __A_VARIABLE = 1;
     return 0;
   default:
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 }
@@ -203,12 +249,14 @@ strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
 int __pthread_mutexattr_init(pthread_mutexattr_t *attr)
 {
   attr->__mutexkind = PTHREAD_MUTEX_TIMED_NP;
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_mutexattr_init, pthread_mutexattr_init)
 
 int __pthread_mutexattr_destroy(pthread_mutexattr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_mutexattr_destroy, pthread_mutexattr_destroy)
@@ -218,9 +266,12 @@ int __pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
   if (kind != PTHREAD_MUTEX_ADAPTIVE_NP
       && kind != PTHREAD_MUTEX_RECURSIVE_NP
       && kind != PTHREAD_MUTEX_ERRORCHECK_NP
-      && kind != PTHREAD_MUTEX_TIMED_NP)
+      && kind != PTHREAD_MUTEX_TIMED_NP) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   attr->__mutexkind = kind;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_mutexattr_settype, pthread_mutexattr_settype)
@@ -232,6 +283,7 @@ weak_alias (__pthread_mutexattr_setkind_np, pthread_mutexattr_setkind_np)
 int __pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind)
 {
   *kind = attr->__mutexkind;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_mutexattr_gettype, pthread_mutexattr_gettype)
@@ -247,19 +299,25 @@ int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
 				   int *pshared)
 {
   *pshared = PTHREAD_PROCESS_PRIVATE;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_mutexattr_getpshared, pthread_mutexattr_getpshared)
 
 int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared)
 {
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
+  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
+  if (pshared != PTHREAD_PROCESS_PRIVATE) {
+    __A_VARIABLE = 1;
     return ENOSYS;
+  }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_mutexattr_setpshared, pthread_mutexattr_setpshared)
@@ -286,6 +344,7 @@ static void pthread_once_cancelhandler(void *arg)
     *once_control = NEVER;
     pthread_mutex_unlock(&once_masterlock);
     pthread_cond_broadcast(&once_finished);
+    __A_VARIABLE = 1;
 }
 
 int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
@@ -296,6 +355,7 @@ int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
   /* Test without locking first for speed */
   if (*once_control == DONE) {
     READ_MEMORY_BARRIER();
+    __A_VARIABLE = 1;
     return 0;
   }
   /* Lock and test again */
@@ -331,6 +391,7 @@ int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
   if (state_changed)
     pthread_cond_broadcast(&once_finished);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_once, pthread_once)
@@ -348,11 +409,13 @@ strong_alias (__pthread_once, pthread_once)
 void __pthread_once_fork_prepare(void)
 {
   pthread_mutex_lock(&once_masterlock);
+  __A_VARIABLE = 1;
 }
 
 void __pthread_once_fork_parent(void)
 {
   pthread_mutex_unlock(&once_masterlock);
+  __A_VARIABLE = 1;
 }
 
 void __pthread_once_fork_child(void)
@@ -363,4 +426,5 @@ void __pthread_once_fork_child(void)
     fork_generation += 4;	/* leave least significant two bits zero */
   else
     fork_generation = 0;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/no-tsd.c b/newlib/libc/sys/linux/linuxthreads/no-tsd.c
index 84abb6f..bb1a07f 100644
--- a/newlib/libc/sys/linux/linuxthreads/no-tsd.c
+++ b/newlib/libc/sys/linux/linuxthreads/no-tsd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc-internal interface for thread-specific data.
    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/oldsemaphore.c b/newlib/libc/sys/linux/linuxthreads/oldsemaphore.c
index 80a82df..3dbebed 100644
--- a/newlib/libc/sys/linux/linuxthreads/oldsemaphore.c
+++ b/newlib/libc/sys/linux/linuxthreads/oldsemaphore.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file contains the old semaphore code that we need to
  * preserve for glibc-2.0 backwards compatibility. Port to glibc 2.1
@@ -47,6 +48,7 @@ extern int __old_sem_destroy (old_sem_t *__sem);
 
 static inline int sem_compare_and_swap(old_sem_t *sem, long oldval, long newval)
 {
+    __A_VARIABLE = 1;
     return compare_and_swap(&sem->sem_status, oldval, newval, &sem->sem_spinlock);
 }
 
@@ -67,14 +69,17 @@ int __old_sem_init(old_sem_t *sem, int pshared, unsigned int value)
 {
     if (value > SEM_VALUE_MAX) {
 	errno = EINVAL;
+	__A_VARIABLE = 1;
 	return -1;
     }
     if (pshared) {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
     }
   sem->sem_spinlock = __LT_SPINLOCK_INIT;
   sem->sem_status = ((long)value << 1) + 1;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -84,6 +89,7 @@ int __old_sem_init(old_sem_t *sem, int pshared, unsigned int value)
 
 static int old_sem_extricate_func(void *obj, pthread_descr th)
 {
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -115,6 +121,7 @@ int __old_sem_wait(old_sem_t * sem)
 	    /* We got the semaphore. */
 	    __pthread_set_own_extricate_if(self, 0);
 	    self->p_nextwaiting = NULL;
+	    __A_VARIABLE = 1;
 	    return 0;
 	}
 	/* Wait for sem_post or cancellation */
@@ -148,6 +155,7 @@ int __old_sem_wait(old_sem_t * sem)
             __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 int __old_sem_trywait(old_sem_t * sem)
@@ -158,11 +166,13 @@ int __old_sem_trywait(old_sem_t * sem)
     oldstatus = sem->sem_status;
     if ((oldstatus & 1) == 0 || (oldstatus == 1)) {
       errno = EAGAIN;
+      __A_VARIABLE = 1;
       return -1;
     }
     newstatus = oldstatus - 2;
   }
   while (! sem_compare_and_swap(sem, oldstatus, newstatus));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -196,6 +206,7 @@ int __old_sem_getvalue(old_sem_t * sem, int * sval)
     *sval = (int)((unsigned long) status >> 1);
   else
     *sval = 0;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -203,8 +214,10 @@ int __old_sem_destroy(old_sem_t * sem)
 {
   if ((sem->sem_status & 1) == 0) {
     errno = EBUSY;
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -233,6 +246,7 @@ static void sem_restart_list(pthread_descr waiting)
     th->p_nextwaiting = NULL;
     restart(th);
   }
+  __A_VARIABLE = 1;
 }
 
 compat_symbol (libpthread, __old_sem_init, sem_init, GLIBC_2_0);
diff --git a/newlib/libc/sys/linux/linuxthreads/prio.c b/newlib/libc/sys/linux/linuxthreads/prio.c
index 4753711..f4578ca 100644
--- a/newlib/libc/sys/linux/linuxthreads/prio.c
+++ b/newlib/libc/sys/linux/linuxthreads/prio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stddef.h>
 #include <unistd.h>
 #include <errno.h>
@@ -11,6 +12,7 @@ __pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr,
                                  int *priority)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutexattr_getprotocol,pthread_mutexattr_getprotocol)
@@ -20,6 +22,7 @@ __pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr,
                                  int priority)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutexattr_setprotocol,pthread_mutexattr_setprotocol)
@@ -29,6 +32,7 @@ __pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr,
                                     int *prioceiling)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutexattr_getprioceiling,pthread_mutexattr_getprioceiling)
@@ -38,6 +42,7 @@ __pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr,
                                     int prioceiling)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutexattr_setprioceiling,pthread_mutexattr_setprioceiling)
@@ -49,6 +54,7 @@ __pthread_mutex_getprioceiling (const pthread_mutex_t *mutex,
                                 int *prioceiling)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutex_getprioceiling,pthread_mutex_getprioceiling)
@@ -58,6 +64,7 @@ __pthread_mutex_setprioceiling (pthread_mutex_t *mutex,
                                 int prioceiling, int *oldceiling)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return ENOSYS;
 }
 weak_alias(__pthread_mutex_setprioceiling,pthread_mutex_setprioceiling)
diff --git a/newlib/libc/sys/linux/linuxthreads/pt-machine.c b/newlib/libc/sys/linux/linuxthreads/pt-machine.c
index f6298c4..cc2a21c 100644
--- a/newlib/libc/sys/linux/linuxthreads/pt-machine.c
+++ b/newlib/libc/sys/linux/linuxthreads/pt-machine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* "Instantiation of machine-dependent pthreads inline functions.
    Copyright (C) 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/ptclock_gettime.c b/newlib/libc/sys/linux/linuxthreads/ptclock_gettime.c
index 3323edb..4044d18 100644
--- a/newlib/libc/sys/linux/linuxthreads/ptclock_gettime.c
+++ b/newlib/libc/sys/linux/linuxthreads/ptclock_gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -41,6 +42,7 @@ __pthread_clock_gettime (hp_timing_t freq, struct timespec *tp)
      we get machines with about 16GHz frequency.  */
   tp->tv_nsec = ((tsc % freq) * 1000000000ull) / freq;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif
diff --git a/newlib/libc/sys/linux/linuxthreads/ptclock_settime.c b/newlib/libc/sys/linux/linuxthreads/ptclock_settime.c
index e293e0d..7b21a68 100644
--- a/newlib/libc/sys/linux/linuxthreads/ptclock_settime.c
+++ b/newlib/libc/sys/linux/linuxthreads/ptclock_settime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -29,5 +30,6 @@ __pthread_clock_settime (hp_timing_t offset)
 
   /* Compute the offset since the start time of the process.  */
   THREAD_SETMEM (self, p_cpuclock_offset, offset);
+  __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/linux/linuxthreads/ptfork.c b/newlib/libc/sys/linux/linuxthreads/ptfork.c
index 6e31b77..4e54277 100644
--- a/newlib/libc/sys/linux/linuxthreads/ptfork.c
+++ b/newlib/libc/sys/linux/linuxthreads/ptfork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -37,13 +38,17 @@ static void pthread_insert_list(struct handler_list ** list,
                                 struct handler_list * newlist,
                                 int at_end)
 {
-  if (handler == NULL) return;
+  if (handler == NULL) {
+    __A_VARIABLE = 1;
+    return;
+  }
   if (at_end) {
     while(*list != NULL) list = &((*list)->next);
   }
   newlist->handler = handler;
   newlist->next = *list;
   *list = newlist;
+  __A_VARIABLE = 1;
 }
 
 struct handler_list_block {
@@ -56,7 +61,10 @@ int __pthread_atfork(void (*prepare)(void),
 {
   struct handler_list_block * block =
     (struct handler_list_block *) malloc(sizeof(struct handler_list_block));
-  if (block == NULL) return ENOMEM;
+  if (block == NULL) {
+  	__A_VARIABLE = 1;
+  	return ENOMEM;
+  }
   pthread_mutex_lock(&pthread_atfork_lock);
   /* "prepare" handlers are called in LIFO */
   pthread_insert_list(&pthread_atfork_prepare, prepare, &block->prepare, 0);
@@ -65,6 +73,7 @@ int __pthread_atfork(void (*prepare)(void),
   /* "child" handlers are called in FIFO */
   pthread_insert_list(&pthread_atfork_child, child, &block->child, 1);
   pthread_mutex_unlock(&pthread_atfork_lock);
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_atfork, pthread_atfork)
@@ -72,6 +81,7 @@ strong_alias (__pthread_atfork, pthread_atfork)
 static inline void pthread_call_handlers(struct handler_list * list)
 {
   for (/*nothing*/; list != NULL; list = list->next) (list->handler)();
+  __A_VARIABLE = 1;
 }
 
 extern int __libc_fork(void);
@@ -104,6 +114,7 @@ pid_t __fork(void)
     pthread_mutex_unlock(&pthread_atfork_lock);
   }
 
+  __A_VARIABLE = 1;
   return pid;
 }
 
@@ -113,6 +124,7 @@ weak_alias (__fork, fork);
 
 pid_t __vfork(void)
 {
+  __A_VARIABLE = 1;
   return __fork();
 }
 weak_alias (__vfork, vfork);
diff --git a/newlib/libc/sys/linux/linuxthreads/pthread.c b/newlib/libc/sys/linux/linuxthreads/pthread.c
index b42d9d6..74dd15a 100644
--- a/newlib/libc/sys/linux/linuxthreads/pthread.c
+++ b/newlib/libc/sys/linux/linuxthreads/pthread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
@@ -333,6 +334,7 @@ init_rtsigs (void)
     }
 
   rtsigs_initialized = 1;
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -344,6 +346,7 @@ __libc_current_sigrtmin (void)
   if (__builtin_expect (!rtsigs_initialized, 0))
     init_rtsigs ();
 #endif
+  __A_VARIABLE = 1;
   return current_rtmin;
 }
 
@@ -355,6 +358,7 @@ __libc_current_sigrtmax (void)
   if (__builtin_expect (!rtsigs_initialized, 0))
     init_rtsigs ();
 #endif
+  __A_VARIABLE = 1;
   return current_rtmax;
 }
 
@@ -407,6 +411,7 @@ is_smp_system (void)
       __close (fd);
     }
 
+  __A_VARIABLE = 1;
   return strstr (buf, "SMP") != NULL;
 }
 
@@ -438,6 +443,7 @@ __pthread_initialize_minimal(void)
 #if HP_TIMING_AVAIL
   __pthread_initial_thread.p_cpuclock_offset = _dl_cpuclock_offset;
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -472,6 +478,7 @@ __pthread_init_max_stacksize(void)
   }
 #endif
   __pthread_max_stacksize = max_stack;
+  __A_VARIABLE = 1;
 }
 
 
@@ -481,7 +488,10 @@ static void pthread_initialize(void)
   sigset_t mask;
 
   /* If already done (e.g. by a constructor called earlier!), bail out */
-  if (__pthread_initial_thread_bos != NULL) return;
+  if (__pthread_initial_thread_bos != NULL) {
+    __A_VARIABLE = 1;
+    return;
+  }
 #ifdef TEST_FOR_COMPARE_AND_SWAP
   /* Test if compare-and-swap is available */
   __pthread_has_cas = compare_and_swap_is_available();
@@ -545,11 +555,13 @@ static void pthread_initialize(void)
     on_exit (pthread_onexit_process, NULL);
   /* How many processors.  */
   __pthread_smp_kernel = is_smp_system ();
+  __A_VARIABLE = 1;
 }
 
 void __pthread_initialize(void)
 {
   pthread_initialize();
+  __A_VARIABLE = 1;
 }
 
 int __pthread_initialize_manager(void)
@@ -571,12 +583,16 @@ int __pthread_initialize_manager(void)
   if (__pthread_initial_thread_bos == NULL) pthread_initialize();
   /* Setup stack for thread manager */
   __pthread_manager_thread_bos = malloc(THREAD_MANAGER_STACK_SIZE);
-  if (__pthread_manager_thread_bos == NULL) return -1;
+  if (__pthread_manager_thread_bos == NULL) {
+    __A_VARIABLE = 1;
+    return -1;
+  }
   __pthread_manager_thread_tos =
     __pthread_manager_thread_bos + THREAD_MANAGER_STACK_SIZE;
   /* Setup pipe to communicate with thread manager */
   if (__libc_pipe(manager_pipe) == -1) {
     free(__pthread_manager_thread_bos);
+    __A_VARIABLE = 1;
     return -1;
   }
   /* Start the thread manager */
@@ -655,6 +671,7 @@ int __pthread_initialize_manager(void)
     free(__pthread_manager_thread_bos);
     __libc_close(manager_pipe[0]);
     __libc_close(manager_pipe[1]);
+    __A_VARIABLE = 1;
     return -1;
   }
   __pthread_manager_request = manager_pipe[1]; /* writing end */
@@ -673,6 +690,7 @@ int __pthread_initialize_manager(void)
   request.req_kind = REQ_DEBUG;
   TEMP_FAILURE_RETRY(__libc_write(__pthread_manager_request,
 				  (char *) &request, sizeof(request)));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -685,7 +703,10 @@ int __pthread_create_2_1(pthread_t *thread, const pthread_attr_t *attr,
   struct pthread_request request;
   int retval;
   if (__builtin_expect (__pthread_manager_request, 0) < 0) {
-    if (__pthread_initialize_manager() < 0) return EAGAIN;
+    if (__pthread_initialize_manager() < 0) {
+      __A_VARIABLE = 1;
+      return EAGAIN;
+    }
   }
   request.req_thread = self;
   request.req_kind = REQ_CREATE;
@@ -700,6 +721,7 @@ int __pthread_create_2_1(pthread_t *thread, const pthread_attr_t *attr,
   retval = THREAD_GETMEM(self, p_retcode);
   if (__builtin_expect (retval, 0) == 0)
     *thread = (pthread_t) THREAD_GETMEM(self, p_retval);
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -727,6 +749,7 @@ int __pthread_create_2_0(pthread_t *thread, const pthread_attr_t *attr,
       new_attr.__stacksize = STACK_SIZE - ps;
       attr = &new_attr;
     }
+  __A_VARIABLE = 1;
   return __pthread_create_2_1 (thread, attr, start_routine, arg);
 }
 compat_symbol (libpthread, __pthread_create_2_0, pthread_create, GLIBC_2_0);
@@ -737,11 +760,13 @@ compat_symbol (libpthread, __pthread_create_2_0, pthread_create, GLIBC_2_0);
 pthread_t pthread_self(void)
 {
   pthread_descr self = thread_self();
+  __A_VARIABLE = 1;
   return THREAD_GETMEM(self, p_tid);
 }
 
 int pthread_equal(pthread_t thread1, pthread_t thread2)
 {
+  __A_VARIABLE = 1;
   return thread1 == thread2;
 }
 
@@ -758,6 +783,7 @@ pthread_descr __pthread_find_self(void)
      the manager threads handled specially in thread_self(), so start at 2 */
   h = __pthread_handles + 2;
   while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom)) h++;
+  __A_VARIABLE = 1;
   return h->h_descr;
 }
 
@@ -768,11 +794,14 @@ static pthread_descr thread_self_stack(void)
   char *sp = CURRENT_STACK_FRAME;
   pthread_handle h;
 
-  if (sp >= __pthread_manager_thread_bos && sp < __pthread_manager_thread_tos)
+  if (sp >= __pthread_manager_thread_bos && sp < __pthread_manager_thread_tos) {
+    __A_VARIABLE = 1;
     return &__pthread_manager_thread;
+  }
   h = __pthread_handles + 2;
   while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom))
     h++;
+  __A_VARIABLE = 1;
   return h->h_descr;
 }
 
@@ -789,18 +818,21 @@ int pthread_setschedparam(pthread_t thread, int policy,
   __pthread_lock(&handle->h_lock, NULL);
   if (__builtin_expect (invalid_handle(handle, thread), 0)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return ESRCH;
   }
   th = handle->h_descr;
   if (__builtin_expect (__sched_setscheduler(th->p_pid, policy, param) == -1,
 			0)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return errno;
   }
   th->p_priority = policy == SCHED_OTHER ? 0 : param->sched_priority;
   __pthread_unlock(&handle->h_lock);
   if (__pthread_manager_request >= 0)
     __pthread_manager_adjust_prio(th->p_priority);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -813,20 +845,29 @@ int pthread_getschedparam(pthread_t thread, int *policy,
   __pthread_lock(&handle->h_lock, NULL);
   if (__builtin_expect (invalid_handle(handle, thread), 0)) {
     __pthread_unlock(&handle->h_lock);
+    __A_VARIABLE = 1;
     return ESRCH;
   }
   pid = handle->h_descr->p_pid;
   __pthread_unlock(&handle->h_lock);
   pol = __sched_getscheduler(pid);
-  if (__builtin_expect (pol, 0) == -1) return errno;
-  if (__sched_getparam(pid, param) == -1) return errno;
+  if (__builtin_expect (pol, 0) == -1) {
+    __A_VARIABLE = 1;
+    return errno;
+  }
+  if (__sched_getparam(pid, param) == -1) {
+    __A_VARIABLE = 1;
+    return errno;
+  }
   *policy = pol;
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int __pthread_yield (void)
 {
   /* For now this is equivalent with the POSIX call.  */
+  __A_VARIABLE = 1;
   return sched_yield ();
 }
 weak_alias (__pthread_yield, pthread_yield)
@@ -856,6 +897,7 @@ static void pthread_onexit_process(int retcode, void *arg)
 	__pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
       }
   }
+  __A_VARIABLE = 1;
 }
 
 #ifndef HAVE_Z_NODELETE
@@ -864,11 +906,13 @@ static int __pthread_atexit_retcode;
 static void pthread_atexit_process(void *arg, int retcode)
 {
   pthread_onexit_process (retcode ?: __pthread_atexit_retcode, arg);
+  __A_VARIABLE = 1;
 }
 
 static void pthread_atexit_retcode(void *arg, int retcode)
 {
   __pthread_atexit_retcode = retcode;
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -882,6 +926,7 @@ static void pthread_handle_sigrestart(int sig)
   THREAD_SETMEM(self, p_signal, sig);
   if (THREAD_GETMEM(self, p_signal_jmp) != NULL)
     siglongjmp(*THREAD_GETMEM(self, p_signal_jmp), 1);
+  __A_VARIABLE = 1;
 }
 
 /* The handler for the CANCEL signal checks for cancellation
@@ -949,6 +994,7 @@ static void pthread_handle_sigcancel(int sig)
 static void pthread_handle_sigdebug(int sig)
 {
   /* Nothing */
+	__A_VARIABLE = 1;
 }
 
 /* Reset the state of the thread machinery after a fork().
@@ -986,6 +1032,7 @@ void __pthread_reset_main_thread(void)
     limit.rlim_cur = limit.rlim_max;
     __libc_setrlimit(RLIMIT_STACK, &limit);
   }
+  __A_VARIABLE = 1;
 }
 
 /* Process-wide exec() request */
@@ -1011,6 +1058,7 @@ void __pthread_kill_other_threads_np(void)
   __libc_sigaction(__pthread_sig_cancel, &sa, NULL);
   if (__pthread_sig_debug > 0)
     __libc_sigaction(__pthread_sig_debug, &sa, NULL);
+  __A_VARIABLE = 1;
 }
 weak_alias (__pthread_kill_other_threads_np, pthread_kill_other_threads_np)
 
@@ -1023,12 +1071,14 @@ int __pthread_setconcurrency(int level)
 {
   /* We don't do anything unless we have found a useful interpretation.  */
   current_level = level;
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__pthread_setconcurrency, pthread_setconcurrency)
 
 int __pthread_getconcurrency(void)
 {
+  __A_VARIABLE = 1;
   return current_level;
 }
 weak_alias (__pthread_getconcurrency, pthread_getconcurrency)
@@ -1047,6 +1097,7 @@ void __pthread_wait_for_restart_signal(pthread_descr self)
   } while (THREAD_GETMEM(self, p_signal) !=__pthread_sig_restart);
 
   READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
+  __A_VARIABLE = 1;
 }
 
 #if !__ASSUME_REALTIME_SIGNALS
@@ -1061,12 +1112,14 @@ void __pthread_restart_old(pthread_descr th)
 {
   if (atomic_increment(&th->p_resume_count) == -1)
     kill(th->p_pid, __pthread_sig_restart);
+  __A_VARIABLE = 1;
 }
 
 void __pthread_suspend_old(pthread_descr self)
 {
   if (atomic_decrement(&self->p_resume_count) <= 0)
     __pthread_wait_for_restart_signal(self);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -1137,12 +1190,15 @@ __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
       __pthread_wait_for_restart_signal(self);
       atomic_decrement(&self->p_resume_count); /* should be zero now! */
       /* woke spontaneously and consumed restart signal */
+      __A_VARIABLE = 1;
       return 1;
     }
     /* woke spontaneously but did not consume restart---caller must resolve */
+    __A_VARIABLE = 1;
     return 0;
   }
   /* woken due to restart signal */
+  __A_VARIABLE = 1;
   return 1;
 }
 #endif /* __ASSUME_REALTIME_SIGNALS */
@@ -1155,6 +1211,7 @@ void __pthread_restart_new(pthread_descr th)
      read barriers are present to the suspend functions. */
   WRITE_MEMORY_BARRIER();
   kill(th->p_pid, __pthread_sig_restart);
+  __A_VARIABLE = 1;
 }
 
 /* There is no __pthread_suspend_new because it would just
@@ -1213,6 +1270,7 @@ __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime)
      so there is a race. */
 
   READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
+  __A_VARIABLE = 1;
   return was_signalled;
 }
 
@@ -1231,6 +1289,7 @@ void __pthread_message(char * fmt, ...)
   vsnprintf(buffer + 8, sizeof(buffer) - 8, fmt, args);
   va_end(args);
   TEMP_FAILURE_RETRY(__libc_write(2, buffer, strlen(buffer)));
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/sys/linux/linuxthreads/ptlongjmp.c b/newlib/libc/sys/linux/linuxthreads/ptlongjmp.c
index c2ac55f..20c9fde 100644
--- a/newlib/libc/sys/linux/linuxthreads/ptlongjmp.c
+++ b/newlib/libc/sys/linux/linuxthreads/ptlongjmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -58,16 +59,19 @@ static void pthread_cleanup_upto(jmp_buf target)
   if (THREAD_GETMEM(self, p_in_sighandler)
       && _JMPBUF_UNWINDS(target, THREAD_GETMEM(self, p_in_sighandler)))
     THREAD_SETMEM(self, p_in_sighandler, NULL);
+  __A_VARIABLE = 1;
 }
 
 void siglongjmp(sigjmp_buf env, int val)
 {
   pthread_cleanup_upto(env.__buf);
   __libc_siglongjmp(env, val);
+  __A_VARIABLE = 1;
 }
 
 void longjmp(jmp_buf env, int val)
 {
   pthread_cleanup_upto(env);
   __libc_longjmp(env, val);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/reent.c b/newlib/libc/sys/linux/linuxthreads/reent.c
index 44d6f78..c0ed907 100644
--- a/newlib/libc/sys/linux/linuxthreads/reent.c
+++ b/newlib/libc/sys/linux/linuxthreads/reent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Define the location of _REENT for the newlib C library */
 
 #include <reent.h>
@@ -7,6 +8,7 @@
 struct _reent * __thread_reent()
 {
   pthread_descr self = thread_self();
+  __A_VARIABLE = 1;
   return THREAD_GETMEM (self, p_reentp);
 }
 
@@ -14,5 +16,6 @@ struct _reent * __thread_reent()
 struct __res_state * __res_state()
 {
   pthread_descr self = thread_self();
+  __A_VARIABLE = 1;
   return THREAD_GETMEM (self, p_resp);
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/reqsyscalls.c b/newlib/libc/sys/linux/linuxthreads/reqsyscalls.c
index 714a8ba..a966711 100644
--- a/newlib/libc/sys/linux/linuxthreads/reqsyscalls.c
+++ b/newlib/libc/sys/linux/linuxthreads/reqsyscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* EL/IX level 1 and 2 libraries don't have the following syscalls,
    but we need them due to our threading model based on processes */
 
diff --git a/newlib/libc/sys/linux/linuxthreads/rwlock.c b/newlib/libc/sys/linux/linuxthreads/rwlock.c
index e395970..79ac02e 100644
--- a/newlib/libc/sys/linux/linuxthreads/rwlock.c
+++ b/newlib/libc/sys/linux/linuxthreads/rwlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Read-write lock implementation.
    Copyright (C) 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -40,6 +41,7 @@ static int rwlock_rd_extricate_func(void *obj, pthread_descr th)
   did_remove = remove_from_queue(&rwlock->__rw_read_waiting, th);
   __pthread_unlock(&rwlock->__rw_lock);
 
+  __A_VARIABLE = 1;
   return did_remove;
 }
 
@@ -52,6 +54,7 @@ static int rwlock_wr_extricate_func(void *obj, pthread_descr th)
   did_remove = remove_from_queue(&rwlock->__rw_write_waiting, th);
   __pthread_unlock(&rwlock->__rw_lock);
 
+  __A_VARIABLE = 1;
   return did_remove;
 }
 
@@ -69,10 +72,13 @@ rwlock_is_in_list(pthread_descr self, pthread_rwlock_t *rwlock)
   for (info = THREAD_GETMEM (self, p_readlock_list); info != NULL;
        info = info->pr_next)
     {
-      if (info->pr_lock == rwlock)
+      if (info->pr_lock == rwlock) {
+	__A_VARIABLE = 1;
 	return info;
+      }
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -94,14 +100,17 @@ rwlock_add_to_list(pthread_descr self, pthread_rwlock_t *rwlock)
   else
     info = malloc(sizeof *info);
 
-  if (info == NULL)
+  if (info == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   info->pr_lock_count = 1;
   info->pr_lock = rwlock;
   info->pr_next = THREAD_GETMEM (self, p_readlock_list);
   THREAD_SETMEM (self, p_readlock_list, info);
 
+  __A_VARIABLE = 1;
   return info;
 }
 
@@ -126,10 +135,12 @@ rwlock_remove_from_list(pthread_descr self, pthread_rwlock_t *rwlock)
 	  pthread_readlock_info *info = *pinfo;
 	  if (--info->pr_lock_count == 0)
 	    *pinfo = info->pr_next;
+	  __A_VARIABLE = 1;
 	  return info;
 	}
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -143,22 +154,31 @@ static int
 rwlock_can_rdlock(pthread_rwlock_t *rwlock, int have_lock_already)
 {
   /* Can't readlock; it is write locked. */
-  if (rwlock->__rw_writer != NULL)
+  if (rwlock->__rw_writer != NULL) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* Lock prefers readers; get it. */
-  if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP)
+  if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Lock prefers writers, but none are waiting. */
-  if (queue_is_empty(&rwlock->__rw_write_waiting))
+  if (queue_is_empty(&rwlock->__rw_write_waiting)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Writers are waiting, but this thread already has a read lock */
-  if (have_lock_already)
+  if (have_lock_already) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Writers are waiting, and this is a new lock */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -208,6 +228,7 @@ rwlock_have_already(pthread_descr *pself, pthread_rwlock_t *rwlock,
   *pout_of_mem = out_of_mem;
   *pexisting = existing;
 
+  __A_VARIABLE = 1;
   return have_lock_already;
 }
 
@@ -232,6 +253,7 @@ __pthread_rwlock_init (pthread_rwlock_t *rwlock,
       rwlock->__rw_pshared = attr->__pshared;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_rwlock_init, pthread_rwlock_init)
@@ -248,9 +270,12 @@ __pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
   writer = rwlock->__rw_writer;
   __pthread_unlock (&rwlock->__rw_lock);
 
-  if (readers > 0 || writer != NULL)
+  if (readers > 0 || writer != NULL) {
+    __A_VARIABLE = 1;
     return EBUSY;
+  }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_rwlock_destroy, pthread_rwlock_destroy)
@@ -291,6 +316,7 @@ __pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
 	++self->p_untracked_readlock_count;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_rwlock_rdlock, pthread_rwlock_rdlock)
@@ -304,8 +330,10 @@ __pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
   int out_of_mem, have_lock_already;
   pthread_extricate_if extr;
 
-  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   have_lock_already = rwlock_have_already(&self, rwlock,
 					  &existing, &out_of_mem);
@@ -341,6 +369,7 @@ __pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
 	  if (was_on_queue)
 	    {
 	      __pthread_set_own_extricate_if (self, 0);
+	      __A_VARIABLE = 1;
 	      return ETIMEDOUT;
 	    }
 
@@ -362,6 +391,7 @@ __pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
 	++self->p_untracked_readlock_count;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_rwlock_timedrdlock, pthread_rwlock_timedrdlock)
@@ -404,6 +434,7 @@ __pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
 	}
     }
 
+  __A_VARIABLE = 1;
   return retval;
 }
 strong_alias (__pthread_rwlock_tryrdlock, pthread_rwlock_tryrdlock)
@@ -421,6 +452,7 @@ __pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
 	{
 	  rwlock->__rw_writer = self;
 	  __pthread_unlock (&rwlock->__rw_lock);
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
 
@@ -429,6 +461,7 @@ __pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
       __pthread_unlock (&rwlock->__rw_lock);
       suspend (self); /* This is not a cancellation point */
     }
+    __A_VARIABLE = 1;
 }
 strong_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)
 
@@ -440,8 +473,10 @@ __pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
   pthread_descr self;
   pthread_extricate_if extr;
 
-  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   self = thread_self ();
 
@@ -461,6 +496,7 @@ __pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
 	  rwlock->__rw_writer = self;
 	  __pthread_set_own_extricate_if (self, 0);
 	  __pthread_unlock (&rwlock->__rw_lock);
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
 
@@ -479,6 +515,7 @@ __pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
 	  if (was_on_queue)
 	    {
 	      __pthread_set_own_extricate_if (self, 0);
+	      __A_VARIABLE = 1;
 	      return ETIMEDOUT;
 	    }
 
@@ -486,6 +523,7 @@ __pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
 	  suspend (self);
 	}
     }
+    __A_VARIABLE = 1;
 }
 strong_alias (__pthread_rwlock_timedwrlock, pthread_rwlock_timedwrlock)
 
@@ -503,6 +541,7 @@ __pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
     }
   __pthread_unlock (&rwlock->__rw_lock);
 
+  __A_VARIABLE = 1;
   return result;
 }
 strong_alias (__pthread_rwlock_trywrlock, pthread_rwlock_trywrlock)
@@ -599,6 +638,7 @@ pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
   attr->__lockkind = 0;
   attr->__pshared = PTHREAD_PROCESS_PRIVATE;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -606,6 +646,7 @@ pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
 int
 __pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_rwlockattr_destroy, pthread_rwlockattr_destroy)
@@ -615,6 +656,7 @@ int
 pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
 {
   *pshared = attr->__pshared;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -622,15 +664,20 @@ pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
 int
 pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
 {
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
+  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
+  if (pshared != PTHREAD_PROCESS_PRIVATE) {
+    __A_VARIABLE = 1;
     return ENOSYS;
+  }
 
   attr->__pshared = pshared;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -639,6 +686,7 @@ int
 pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *attr, int *pref)
 {
   *pref = attr->__lockkind;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -649,10 +697,13 @@ pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *attr, int pref)
   if (pref != PTHREAD_RWLOCK_PREFER_READER_NP
       && pref != PTHREAD_RWLOCK_PREFER_WRITER_NP
       && pref != PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
-      && pref != PTHREAD_RWLOCK_DEFAULT_NP)
+      && pref != PTHREAD_RWLOCK_DEFAULT_NP) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   attr->__lockkind = pref;
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/semaphore.c b/newlib/libc/sys/linux/linuxthreads/semaphore.c
index e0dac41..66c2278 100644
--- a/newlib/libc/sys/linux/linuxthreads/semaphore.c
+++ b/newlib/libc/sys/linux/linuxthreads/semaphore.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -27,15 +28,18 @@ int __new_sem_init(sem_t *sem, int pshared, unsigned int value)
 {
   if (value > SEM_VALUE_MAX) {
     errno = EINVAL;
+    __A_VARIABLE = 1;
     return -1;
   }
   if (pshared) {
     errno = ENOSYS;
+    __A_VARIABLE = 1;
     return -1;
   }
   __pthread_init_lock(&sem->__sem_lock);
   sem->__sem_value = value;
   sem->__sem_waiting = NULL;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -52,6 +56,7 @@ static int new_sem_extricate_func(void *obj, pthread_descr th)
   did_remove = remove_from_queue(&sem->__sem_waiting, th);
   __pthread_unlock(&sem->__sem_lock);
 
+  __A_VARIABLE = 1;
   return did_remove;
 }
 
@@ -70,6 +75,7 @@ int __new_sem_wait(sem_t * sem)
   if (sem->__sem_value > 0) {
     sem->__sem_value--;
     __pthread_unlock(&sem->__sem_lock);
+    __A_VARIABLE = 1;
     return 0;
   }
   /* Register extrication interface */
@@ -114,6 +120,7 @@ int __new_sem_wait(sem_t * sem)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
   /* We got the semaphore */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -130,6 +137,7 @@ int __new_sem_trywait(sem_t * sem)
     retval = 0;
   }
   __pthread_unlock(&sem->__sem_lock);
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -177,6 +185,7 @@ int __new_sem_post(sem_t * sem)
 int __new_sem_getvalue(sem_t * sem, int * sval)
 {
   *sval = sem->__sem_value;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -184,26 +193,31 @@ int __new_sem_destroy(sem_t * sem)
 {
   if (sem->__sem_waiting != NULL) {
     __set_errno (EBUSY);
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 sem_t *sem_open(const char *name, int oflag, ...)
 {
   __set_errno (ENOSYS);
+  __A_VARIABLE = 1;
   return SEM_FAILED;
 }
 
 int sem_close(sem_t *sem)
 {
   __set_errno (ENOSYS);
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int sem_unlink(const char *name)
 {
   __set_errno (ENOSYS);
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -218,6 +232,7 @@ int sem_timedwait(sem_t *sem, const struct timespec *abstime)
   if (sem->__sem_value > 0) {
     --sem->__sem_value;
     __pthread_unlock(&sem->__sem_lock);
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -225,6 +240,7 @@ int sem_timedwait(sem_t *sem, const struct timespec *abstime)
     /* The standard requires that if the function would block and the
        time value is illegal, the function returns with an error.  */
     __pthread_unlock(&sem->__sem_lock);
+    __A_VARIABLE = 1;
     return EINVAL;
   }
 
@@ -263,6 +279,7 @@ int sem_timedwait(sem_t *sem, const struct timespec *abstime)
 
 	if (was_on_queue) {
 	  __pthread_set_own_extricate_if(self, 0);
+	  __A_VARIABLE = 1;
 	  return ETIMEDOUT;
 	}
 
@@ -292,6 +309,7 @@ int sem_timedwait(sem_t *sem, const struct timespec *abstime)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
   /* We got the semaphore */
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/signals.c b/newlib/libc/sys/linux/linuxthreads/signals.c
index da3ce69..9e4006c 100644
--- a/newlib/libc/sys/linux/linuxthreads/signals.c
+++ b/newlib/libc/sys/linux/linuxthreads/signals.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -87,6 +88,7 @@ static void pthread_sighandler(int signo, SIGCONTEXT ctx)
   if (THREAD_GETMEM(self, p_sigwaiting)) {
     THREAD_SETMEM(self, p_sigwaiting, 0);
     THREAD_SETMEM(self, p_signal, signo);
+    __A_VARIABLE = 1;
     return;
   }
   /* Record that we're in a signal handler and call the user's
@@ -97,6 +99,7 @@ static void pthread_sighandler(int signo, SIGCONTEXT ctx)
   CALL_SIGHANDLER(sighandler[signo].old, signo, ctx);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, NULL);
+  __A_VARIABLE = 1;
 }
 
 /* The same, this time for real-time signals.  */
@@ -111,6 +114,7 @@ static void pthread_sighandler_rt(int signo, struct siginfo *si,
   if (THREAD_GETMEM(self, p_sigwaiting)) {
     THREAD_SETMEM(self, p_sigwaiting, 0);
     THREAD_SETMEM(self, p_signal, signo);
+    __A_VARIABLE = 1;
     return;
   }
   /* Record that we're in a signal handler and call the user's
@@ -121,6 +125,7 @@ static void pthread_sighandler_rt(int signo, struct siginfo *si,
   sighandler[signo].rt(signo, si, uc);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, NULL);
+  __A_VARIABLE = 1;
 }
 
 /* The wrapper around sigaction.  Install our own signal handler
@@ -136,6 +141,7 @@ int __sigaction(int sig, const struct sigaction * act,
       (sig == __pthread_sig_debug && __pthread_sig_debug > 0))
     {
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
   if (act)
@@ -153,8 +159,10 @@ int __sigaction(int sig, const struct sigaction * act,
     }
   else
     newactp = NULL;
-  if (__libc_sigaction(sig, newactp, oact) == -1)
+  if (__libc_sigaction(sig, newactp, oact) == -1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
   if (sig > 0 && sig < NSIG)
     {
       if (oact != NULL
@@ -168,12 +176,14 @@ int __sigaction(int sig, const struct sigaction * act,
 	   or real-time signal.  */
 	sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias(__sigaction, sigaction)
 
 /* A signal handler that does nothing */
-static void pthread_null_sighandler(int sig) { }
+static void pthread_null_sighandler(int sig) { __A_VARIABLE = 1;
+}
 
 /* sigwait -- synchronously wait for a signal */
 int sigwait(const sigset_t * set, int * sig)
@@ -226,6 +236,7 @@ int sigwait(const sigset_t * set, int * sig)
   pthread_testcancel();
   /* We should have self->p_signal != 0 and equal to the signal received */
   *sig = THREAD_GETMEM(self, p_signal);
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/specific.c b/newlib/libc/sys/linux/linuxthreads/specific.c
index 2dbf205..b22b932 100644
--- a/newlib/libc/sys/linux/linuxthreads/specific.c
+++ b/newlib/libc/sys/linux/linuxthreads/specific.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -51,10 +52,12 @@ int __pthread_key_create(pthread_key_t * key, destr_function destr)
       pthread_keys[i].destr = destr;
       pthread_mutex_unlock(&pthread_keys_mutex);
       *key = i;
+      __A_VARIABLE = 1;
       return 0;
     }
   }
   pthread_mutex_unlock(&pthread_keys_mutex);
+  __A_VARIABLE = 1;
   return EAGAIN;
 }
 strong_alias (__pthread_key_create, pthread_key_create)
@@ -85,6 +88,7 @@ static void pthread_key_delete_helper(void *arg, pthread_descr th)
       th->p_specific[idx1st][idx2nd] = NULL;
     __pthread_unlock(THREAD_GETMEM(th, p_lock));
   }
+  __A_VARIABLE = 1;
 }
 
 /* Delete a key */
@@ -95,6 +99,7 @@ int pthread_key_delete(pthread_key_t key)
   pthread_mutex_lock(&pthread_keys_mutex);
   if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use) {
     pthread_mutex_unlock(&pthread_keys_mutex);
+    __A_VARIABLE = 1;
     return EINVAL;
   }
   pthread_keys[key].in_use = 0;
@@ -126,6 +131,7 @@ int pthread_key_delete(pthread_key_t key)
     }
 
   pthread_mutex_unlock(&pthread_keys_mutex);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -136,17 +142,22 @@ int __pthread_setspecific(pthread_key_t key, const void * pointer)
   pthread_descr self = thread_self();
   unsigned int idx1st, idx2nd;
 
-  if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use)
+  if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
   idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
   idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
   if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL) {
     void *newp = calloc(PTHREAD_KEY_2NDLEVEL_SIZE, sizeof (void *));
-    if (newp == NULL)
+    if (newp == NULL) {
+      __A_VARIABLE = 1;
       return ENOMEM;
+    }
     THREAD_SETMEM_NC(self, p_specific[idx1st], newp);
   }
   THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd] = (void *) pointer;
+  __A_VARIABLE = 1;
   return 0;
 }
 strong_alias (__pthread_setspecific, pthread_setspecific)
@@ -158,13 +169,18 @@ void * __pthread_getspecific(pthread_key_t key)
   pthread_descr self = thread_self();
   unsigned int idx1st, idx2nd;
 
-  if (key >= PTHREAD_KEYS_MAX)
+  if (key >= PTHREAD_KEYS_MAX) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
   idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
   idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
   if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL
-      || !pthread_keys[key].in_use)
+      || !pthread_keys[key].in_use) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
+  __A_VARIABLE = 1;
   return THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd];
 }
 strong_alias (__pthread_getspecific, pthread_getspecific)
@@ -202,6 +218,7 @@ void __pthread_destroy_specifics()
     }
   }
   __pthread_unlock(THREAD_GETMEM(self, p_lock));
+  __A_VARIABLE = 1;
 }
 
 /* Thread-specific data for libc. */
@@ -212,6 +229,7 @@ libc_internal_tsd_set(enum __libc_tsd_key_t key, const void * pointer)
   pthread_descr self = thread_self();
 
   THREAD_SETMEM_NC(self, p_libc_specific[key], (void *) pointer);
+  __A_VARIABLE = 1;
   return 0;
 }
 int (*__libc_internal_tsd_set)(enum __libc_tsd_key_t key, const void * pointer)
@@ -222,6 +240,7 @@ libc_internal_tsd_get(enum __libc_tsd_key_t key)
 {
   pthread_descr self = thread_self();
 
+  __A_VARIABLE = 1;
   return THREAD_GETMEM_NC(self, p_libc_specific[key]);
 }
 void * (*__libc_internal_tsd_get)(enum __libc_tsd_key_t key)
diff --git a/newlib/libc/sys/linux/linuxthreads/spinlock.c b/newlib/libc/sys/linux/linuxthreads/spinlock.c
index f21426f..18cfe3f 100644
--- a/newlib/libc/sys/linux/linuxthreads/spinlock.c
+++ b/newlib/libc/sys/linux/linuxthreads/spinlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -32,6 +33,7 @@ static inline void __pthread_release(int * spinlock)
   WRITE_MEMORY_BARRIER();
   *spinlock = __LT_SPINLOCK_INIT;
   __asm __volatile ("" : "=m" (*spinlock) : "m" (*spinlock));
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -74,6 +76,7 @@ void internal_function __pthread_lock(struct _pthread_fastlock * lock,
 #if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
   {
     __pthread_acquire(&lock->__spinlock);
+    __A_VARIABLE = 1;
     return;
   }
 #endif
@@ -81,8 +84,10 @@ void internal_function __pthread_lock(struct _pthread_fastlock * lock,
 #if defined HAS_COMPARE_AND_SWAP
   /* First try it without preparation.  Maybe it's a completely
      uncontested lock.  */
-  if (lock->__status == 0 && __compare_and_swap (&lock->__status, 0, 1))
+  if (lock->__status == 0 && __compare_and_swap (&lock->__status, 0, 1)) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   spurious_wakeup_count = 0;
   spin_count = 0;
@@ -104,6 +109,7 @@ again:
 	  if (spin_count)
 	    lock->__spinlock += (spin_count - lock->__spinlock) / 8;
 	  READ_MEMORY_BARRIER();
+	  __A_VARIABLE = 1;
 	  return;
 	}
       }
@@ -164,6 +170,7 @@ again:
 
   READ_MEMORY_BARRIER();
 #endif
+  __A_VARIABLE = 1;
 }
 
 int __pthread_unlock(struct _pthread_fastlock * lock)
@@ -180,6 +187,7 @@ int __pthread_unlock(struct _pthread_fastlock * lock)
 #if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
   {
     __pthread_release(&lock->__spinlock);
+    __A_VARIABLE = 1;
     return 0;
   }
 #endif
@@ -190,8 +198,10 @@ int __pthread_unlock(struct _pthread_fastlock * lock)
 again:
   while ((oldstatus = lock->__status) == 1) {
     if (__compare_and_swap_with_release_semantics(&lock->__status,
-	oldstatus, 0))
+	oldstatus, 0)) {
+      __A_VARIABLE = 1;
       return 0;
+    }
   }
 
   /* Find thread in waiting queue with maximal priority */
@@ -255,6 +265,7 @@ again:
   thr->p_nextlock = NULL;
   restart(thr);
 
+  __A_VARIABLE = 1;
   return 0;
 #endif
 }
@@ -306,9 +317,12 @@ static struct wait_node *wait_node_alloc(void)
     WRITE_MEMORY_BARRIER();
     wait_node_free_list_spinlock = 0;
 
-    if (new_node == 0)
+    if (new_node == 0) {
+      __A_VARIABLE = 1;
       return malloc(sizeof *wait_node_alloc());
+    }
 
+    __A_VARIABLE = 1;
     return new_node;
   }
 #endif
@@ -317,14 +331,17 @@ static struct wait_node *wait_node_alloc(void)
   do {
     oldvalue = wait_node_free_list;
 
-    if (oldvalue == 0)
+    if (oldvalue == 0) {
+      __A_VARIABLE = 1;
       return malloc(sizeof *wait_node_alloc());
+    }
 
     /* Ensure we don't read stale next link through oldvalue pointer. */
     READ_MEMORY_BARRIER();
     newvalue = (long) ((struct wait_node *) oldvalue)->next;
   } while (! __compare_and_swap(&wait_node_free_list, oldvalue, newvalue));
 
+  __A_VARIABLE = 1;
   return (struct wait_node *) oldvalue;
 #endif
 }
@@ -348,6 +365,7 @@ static void wait_node_free(struct wait_node *wn)
     wait_node_free_list = (long) wn;
     WRITE_MEMORY_BARRIER();
     wait_node_free_list_spinlock = 0;
+    __A_VARIABLE = 1;
     return;
   }
 #endif
@@ -361,6 +379,7 @@ static void wait_node_free(struct wait_node *wn)
     WRITE_MEMORY_BARRIER();
   } while (! __compare_and_swap(&wait_node_free_list, oldvalue, newvalue));
 #endif
+  __A_VARIABLE = 1;
 }
 
 #if defined HAS_COMPARE_AND_SWAP
@@ -385,8 +404,10 @@ static void wait_node_dequeue(struct wait_node **pp_head,
     long oldvalue = (long) p_node;
     long newvalue = (long) p_node->next;
 
-    if (__compare_and_swap((long *) pp_node, oldvalue, newvalue))
+    if (__compare_and_swap((long *) pp_node, oldvalue, newvalue)) {
+      __A_VARIABLE = 1;
       return;
+    }
 
     /* Oops! Compare and swap failed, which means the node is
        no longer first. We delete it using the ordinary method.  But we don't
@@ -400,6 +421,7 @@ static void wait_node_dequeue(struct wait_node **pp_head,
   }
 
   *pp_node = p_node->next;
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -438,6 +460,7 @@ void __pthread_alt_lock(struct _pthread_fastlock * lock,
 
     if (suspend_needed)
       suspend (self);
+    __A_VARIABLE = 1;
     return;
   }
 #endif
@@ -470,6 +493,7 @@ void __pthread_alt_lock(struct _pthread_fastlock * lock,
 
   READ_MEMORY_BARRIER();
 #endif
+  __A_VARIABLE = 1;
 }
 
 /* Timed-out lock operation; returns 0 to indicate timeout. */
@@ -486,6 +510,7 @@ int __pthread_alt_timedlock(struct _pthread_fastlock * lock,
   /* Out of memory, just give up and do ordinary lock. */
   if (p_wait_node == 0) {
     __pthread_alt_lock(lock, self);
+    __A_VARIABLE = 1;
     return 1;
   }
 
@@ -546,8 +571,10 @@ int __pthread_alt_timedlock(struct _pthread_fastlock * lock,
 
   if (oldstatus != 0) {
     if (timedsuspend(self, abstime) == 0) {
-      if (!testandset(&p_wait_node->abandoned))
-	return 0; /* Timeout! */
+      if (!testandset(&p_wait_node->abandoned)) {
+	__A_VARIABLE = 1;
+	return 0;
+      } /* Timeout! */
 
       /* Eat oustanding resume from owner, otherwise wait_node_free() below
 	 will race with owner's wait_node_dequeue(). */
@@ -559,6 +586,7 @@ int __pthread_alt_timedlock(struct _pthread_fastlock * lock,
 
   READ_MEMORY_BARRIER();
 
+  __A_VARIABLE = 1;
   return 1; /* Got the lock! */
 }
 
@@ -701,6 +729,7 @@ void __pthread_alt_unlock(struct _pthread_fastlock *lock)
     __pthread_release(&lock->__spinlock);
   }
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -727,6 +756,7 @@ int __pthread_compare_and_swap(long * ptr, long oldval, long newval,
 
   __pthread_release(spinlock);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -769,6 +799,7 @@ static void __pthread_acquire(int * spinlock)
       cnt = 0;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 #endif
diff --git a/newlib/libc/sys/linux/linuxthreads/sysctl.c b/newlib/libc/sys/linux/linuxthreads/sysctl.c
index 2512f17..f1851d7 100644
--- a/newlib/libc/sys/linux/linuxthreads/sysctl.c
+++ b/newlib/libc/sys/linux/linuxthreads/sysctl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Read or write system information.  Linux version.
    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/td_init.c b/newlib/libc/sys/linux/linuxthreads/td_init.c
index c9d08e9..0a7de55 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_init.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_init.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Initialization function of thread debugger support library.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,5 +29,6 @@ td_init (void)
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_init");
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_log.c b/newlib/libc/sys/linux/linuxthreads/td_log.c
index 531cf87..6a2607d 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_log.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Noop, left for historical reasons.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,5 +29,6 @@ td_log (void)
      for compatibility but don't do anyhting ourself.  We might in
      future do some logging if this seems reasonable.  */
   LOG ("td_log");
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_symbol_list.c b/newlib/libc/sys/linux/linuxthreads/td_symbol_list.c
index e64d298..53f8851 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_symbol_list.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_symbol_list.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return list of symbols the library can request.
    Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -43,6 +44,7 @@ static const char *symbol_list_arr[] =
 const char **
 td_symbol_list (void)
 {
+  __A_VARIABLE = 1;
   return symbol_list_arr;
 }
 
@@ -51,5 +53,6 @@ int
 td_lookup (struct ps_prochandle *ps, int idx, psaddr_t *sym_addr)
 {
   assert (idx >= 0 && idx < NUM_MESSAGES);
+  __A_VARIABLE = 1;
   return ps_pglobal_lookup (ps, LIBPTHREAD_SO, symbol_list_arr[idx], sym_addr);
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_clear_event.c b/newlib/libc/sys/linux/linuxthreads/td_ta_clear_event.c
index 1512833..33bc54e 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_clear_event.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_clear_event.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Globally disable events.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -32,13 +33,17 @@ td_ta_clear_event (ta, event)
   LOG ("td_ta_clear_event");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   /* Write the new value into the thread data structure.  */
   if (ps_pdread (ta->ph, ta->pthread_threads_eventsp,
-		 &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Remove the set bits in.  */
   for (i = 0; i < TD_EVENTSIZE; ++i)
@@ -46,8 +51,11 @@ td_ta_clear_event (ta, event)
 
   /* Write the new value into the thread data structure.  */
   if (ps_pdwrite (ta->ph, ta->pthread_threads_eventsp,
-		  &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_delete.c b/newlib/libc/sys/linux/linuxthreads/td_ta_delete.c
index 6af4368..0efb149 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_delete.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_delete.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Detach to target process.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_enable_stats.c b/newlib/libc/sys/linux/linuxthreads/td_ta_enable_stats.c
index 43de1b2..b643d99 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_enable_stats.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_enable_stats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Enable collection of statistics for process.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,8 +29,11 @@ td_ta_enable_stats (const td_thragent_t *ta, int enable)
   LOG ("td_ta_enable_stats");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_event_addr.c b/newlib/libc/sys/linux/linuxthreads/td_ta_event_addr.c
index 8bce35a..86d2836 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_event_addr.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_event_addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get event address.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -30,8 +31,10 @@ td_ta_event_addr (const td_thragent_t *ta, td_event_e event, td_notify_t *addr)
   LOG ("td_ta_event_addr");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   switch (event)
     {
@@ -69,5 +72,6 @@ td_ta_event_addr (const td_thragent_t *ta, td_event_e event, td_notify_t *addr)
 	res = TD_ERR;
     }
 
+  __A_VARIABLE = 1;
   return res;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_event_getmsg.c b/newlib/libc/sys/linux/linuxthreads/td_ta_event_getmsg.c
index a4ccba3..dcd19e9 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_event_getmsg.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_event_getmsg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Retrieve event.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -35,24 +36,32 @@ td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
   LOG ("td_ta_event_getmsg");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   /* Get the pointer to the thread descriptor with the last event.  */
   if (ps_pdread (ta->ph, ta->pthread_last_event,
-		 &addr, sizeof (void *)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &addr, sizeof (void *)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* If the pointer is NULL no event occurred.  */
-  if (addr == 0)
+  if (addr == 0) {
+    __A_VARIABLE = 1;
     return TD_NOMSG;
+  }
 
   /* Read the even structure from the target.  */
   if (ps_pdread (ta->ph,
 		 ((char *) addr
 		  + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		 &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &event, sizeof (td_eventbuf_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Check whether an event occurred.  */
   if (event.eventnum == TD_EVENT_NONE)
@@ -65,13 +74,17 @@ td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
 
       /* Read the number of currently active threads.  */
       if (ps_pdread (ta->ph, ta->pthread_handles_num, &num, sizeof (int))
-	  != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
+	  != PS_OK) {
+	__A_VARIABLE = 1;
+	return TD_ERR;
+      }	/* XXX Other error value?  */
 
       /* Now read the handles.  */
       if (ps_pdread (ta->ph, ta->handles, handles,
-		     ta->pthread_threads_max * sizeof (handles[0])) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
+		     ta->pthread_threads_max * sizeof (handles[0])) != PS_OK) {
+	__A_VARIABLE = 1;
+	return TD_ERR;
+      }	/* XXX Other error value?  */
 
       for (i = 0; i < ta->pthread_threads_max && num > 0; ++i)
 	{
@@ -91,8 +104,10 @@ td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
 			 ((char *) handles[i].h_descr
 			  + offsetof (struct _pthread_descr_struct,
 				      p_eventbuf)),
-			 &event, sizeof (td_eventbuf_t)) != PS_OK)
+			 &event, sizeof (td_eventbuf_t)) != PS_OK) {
+	    __A_VARIABLE = 1;
 	    return TD_ERR;
+	  }
 
 	  if (event.eventnum != TD_EVENT_NONE)
 	    {
@@ -103,8 +118,10 @@ td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
 	}
 
       /* If we haven't found any other event signal this to the user.  */
-      if (event.eventnum == TD_EVENT_NONE)
+      if (event.eventnum == TD_EVENT_NONE) {
+	__A_VARIABLE = 1;
 	return TD_NOMSG;
+      }
     }
 
   /* Generate the thread descriptor.  */
@@ -121,8 +138,11 @@ td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
   if (ps_pdwrite (ta->ph,
 		  ((char *) addr
 		   + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		  &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &event, sizeof (td_eventbuf_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_get_nthreads.c b/newlib/libc/sys/linux/linuxthreads/td_ta_get_nthreads.c
index 839b56b..b1bae57 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_get_nthreads.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_get_nthreads.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get the number of threads in the process.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,15 +29,22 @@ td_ta_get_nthreads (const td_thragent_t *ta, int *np)
   LOG ("td_ta_get_nthreads");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   /* Access the variable `__pthread_handles_num'.  */
-  if (td_lookup (ta->ph, PTHREAD_HANDLES_NUM, &addr) != PS_OK)
-     return TD_ERR;	/* XXX Other error value?  */
+  if (td_lookup (ta->ph, PTHREAD_HANDLES_NUM, &addr) != PS_OK) {
+     __A_VARIABLE = 1;
+     return TD_ERR;
+  }	/* XXX Other error value?  */
 
-  if (ps_pdread (ta->ph, addr, np, sizeof (int)) != PS_OK)
-     return TD_ERR;	/* XXX Other error value?  */
+  if (ps_pdread (ta->ph, addr, np, sizeof (int)) != PS_OK) {
+     __A_VARIABLE = 1;
+     return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_get_ph.c b/newlib/libc/sys/linux/linuxthreads/td_ta_get_ph.c
index ffa833d..49f988b 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_get_ph.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_get_ph.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get external process handle.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -27,10 +28,13 @@ td_ta_get_ph (const td_thragent_t *ta, struct ps_prochandle **ph)
   LOG ("td_ta_get_ph");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   *ph = ta->ph;
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_get_stats.c b/newlib/libc/sys/linux/linuxthreads/td_ta_get_stats.c
index d2ba342..85b06e1 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_get_stats.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_get_stats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Retrieve statistics for process.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,8 +29,11 @@ td_ta_get_stats (const td_thragent_t *ta, td_ta_stats_t *statsp)
   LOG ("td_ta_get_stats");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_map_id2thr.c b/newlib/libc/sys/linux/linuxthreads/td_ta_map_id2thr.c
index 184f2de..e843a1d 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_map_id2thr.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_map_id2thr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Map thread ID to thread handle.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -31,36 +32,49 @@ td_ta_map_id2thr (const td_thragent_t *ta, pthread_t pt, td_thrhandle_t *th)
   LOG ("td_ta_map_id2thr");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   /* Make the following expression a bit smaller.  */
   pthread_threads_max = ta->pthread_threads_max;
 
   /* We can compute the entry in the handle array we want.  */
   if (ps_pdread (ta->ph, ta->handles + pt % pthread_threads_max, &phc,
-		 sizeof (struct pthread_handle_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 sizeof (struct pthread_handle_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Test whether this entry is in use.  */
-  if (phc.h_descr == NULL)
+  if (phc.h_descr == NULL) {
+    __A_VARIABLE = 1;
     return TD_BADTH;
+  }
 
   /* Next test: get the descriptor to see whether this is not an old
      thread handle.  */
   if (ps_pdread (ta->ph, phc.h_descr, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 sizeof (struct _pthread_descr_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
-  if (pds.p_tid != pt)
+  if (pds.p_tid != pt) {
+    __A_VARIABLE = 1;
     return TD_BADTH;
+  }
 
-  if (pds.p_terminated != 0)
+  if (pds.p_terminated != 0) {
+    __A_VARIABLE = 1;
     return TD_NOTHR;
+  }
 
   /* Create the `td_thrhandle_t' object.  */
   th->th_ta_p = (td_thragent_t *) ta;
   th->th_unique = phc.h_descr;
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c b/newlib/libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c
index 78b9fbb..61ff54f 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_map_lwp2thr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Which thread is running on an lwp?
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_new.c b/newlib/libc/sys/linux/linuxthreads/td_ta_new.c
index 7505f53..e4c2bb5 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_new.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_new.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Attach to target process.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -40,13 +41,17 @@ td_ta_new (struct ps_prochandle *ps, td_thragent_t **ta)
   /* Get the global event mask.  This is one of the variables which
      are new in the thread library to enable debugging.  If it is
      not available we cannot debug.  */
-  if (td_lookup (ps, PTHREAD_THREADS_EVENTS, &addr) != PS_OK)
+  if (td_lookup (ps, PTHREAD_THREADS_EVENTS, &addr) != PS_OK) {
+    __A_VARIABLE = 1;
     return TD_NOLIBTHREAD;
+  }
 
   /* Fill in the appropriate information.  */
   *ta = (td_thragent_t *) malloc (sizeof (td_thragent_t));
-  if (*ta == NULL)
+  if (*ta == NULL) {
+    __A_VARIABLE = 1;
     return TD_MALLOC;
+  }
 
   /* Store the proc handle which we will pass to the callback functions
      back into the debugger.  */
@@ -61,6 +66,7 @@ td_ta_new (struct ps_prochandle *ps, td_thragent_t **ta)
     {
     free_return:
       free (*ta);
+      __A_VARIABLE = 1;
       return TD_ERR;
     }
 
@@ -120,6 +126,7 @@ td_ta_new (struct ps_prochandle *ps, td_thragent_t **ta)
     {
       /* Argh, now that everything else worked...  */
       free (*ta);
+      __A_VARIABLE = 1;
       return TD_MALLOC;
     }
 
@@ -128,5 +135,6 @@ td_ta_new (struct ps_prochandle *ps, td_thragent_t **ta)
   elemp->next = __td_agent_list;
   __td_agent_list = elemp;
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_reset_stats.c b/newlib/libc/sys/linux/linuxthreads/td_ta_reset_stats.c
index 533d4c4..e94b9a2 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_reset_stats.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_reset_stats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Reset statistics.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,8 +29,11 @@ td_ta_reset_stats (const td_thragent_t *ta)
   LOG ("td_ta_reset_stats");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_set_event.c b/newlib/libc/sys/linux/linuxthreads/td_ta_set_event.c
index 041aaec..bab879e 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_set_event.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_set_event.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Globally enable events.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -32,13 +33,17 @@ td_ta_set_event (ta, event)
   LOG ("td_ta_set_event");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   /* Write the new value into the thread data structure.  */
   if (ps_pdread (ta->ph, ta->pthread_threads_eventsp,
-		 &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Or the new bits in.  */
   for (i = 0; i < TD_EVENTSIZE; ++i)
@@ -46,8 +51,11 @@ td_ta_set_event (ta, event)
 
   /* Write the new value into the thread data structure.  */
   if (ps_pdwrite (ta->ph, ta->pthread_threads_eventsp,
-		  &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_setconcurrency.c b/newlib/libc/sys/linux/linuxthreads/td_ta_setconcurrency.c
index da15a0f..50c3cd1 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_setconcurrency.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_setconcurrency.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set suggested concurrency level for process.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -28,8 +29,11 @@ td_ta_setconcurrency (const td_thragent_t *ta, int level)
   LOG ("td_ta_setconcurrency");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
+  __A_VARIABLE = 1;
   return TD_NOCAPAB;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_thr_iter.c b/newlib/libc/sys/linux/linuxthreads/td_ta_thr_iter.c
index a77186d..b5efcc1 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_thr_iter.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_thr_iter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Iterate over a process's threads.
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -30,43 +31,56 @@ handle_descr (const td_thragent_t *ta, td_thr_iter_f *callback,
   size_t sizeof_descr = ta->sizeof_descr;
   td_thrhandle_t th;
 
-  if (ps_pdread (ta->ph, descr, &pds, sizeof_descr) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+  if (ps_pdread (ta->ph, descr, &pds, sizeof_descr) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* The manager thread must be handled special.  The descriptor
      exists but the thread only gets created when the first
      `pthread_create' call is issued.  A clear indication that this
      happened is when the p_pid field is non-zero.  */
-  if (cnt == 1 && pds.p_pid == 0)
+  if (cnt == 1 && pds.p_pid == 0) {
+    __A_VARIABLE = 1;
     return TD_OK;
+  }
 
   /* Now test whether this thread matches the specified
      conditions.  */
 
   /* Only if the priority level is as high or higher.  */
-  if (pds.p_priority < ti_pri)
+  if (pds.p_priority < ti_pri) {
+    __A_VARIABLE = 1;
     return TD_OK;
+  }
 
   /* Test the state.
      XXX This is incomplete.  */
-  if (state != TD_THR_ANY_STATE)
+  if (state != TD_THR_ANY_STATE) {
+    __A_VARIABLE = 1;
     return TD_OK;
+  }
 
   /* XXX For now we ignore threads which are not running anymore.
      The reason is that gdb tries to get the registers and fails.
      In future we should have a special mode of the thread library
      in which we keep the process around until the actual join
      operation happened.  */
-  if (pds.p_exited != 0)
+  if (pds.p_exited != 0) {
+    __A_VARIABLE = 1;
     return TD_OK;
+  }
 
   /* Yep, it matches.  Call the callback function.  */
   th.th_ta_p = (td_thragent_t *) ta;
   th.th_unique = descr;
-  if (callback (&th, cbdata_p) != 0)
+  if (callback (&th, cbdata_p) != 0) {
+    __A_VARIABLE = 1;
     return TD_DBERR;
+  }
 
   /* All done successfully.  */
+  __A_VARIABLE = 1;
   return TD_OK;
 }
 
diff --git a/newlib/libc/sys/linux/linuxthreads/td_ta_tsd_iter.c b/newlib/libc/sys/linux/linuxthreads/td_ta_tsd_iter.c
index 92ceb1f..2a6f2d5 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_ta_tsd_iter.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_ta_tsd_iter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Iterate over a process's thread-specific data.
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -32,8 +33,10 @@ td_ta_tsd_iter (const td_thragent_t *ta, td_key_iter_f *callback,
   LOG ("td_ta_tsd_iter");
 
   /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
+  if (! ta_ok (ta)) {
+    __A_VARIABLE = 1;
     return TD_BADTA;
+  }
 
   pthread_keys_max = ta->pthread_keys_max;
   keys = (struct pthread_key_struct *) alloca (sizeof (keys[0])
@@ -41,15 +44,20 @@ td_ta_tsd_iter (const td_thragent_t *ta, td_key_iter_f *callback,
 
   /* Read all the information about the keys.  */
   if (ps_pdread (ta->ph, ta->keys, keys,
-		 sizeof (keys[0]) * pthread_keys_max) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
+		 sizeof (keys[0]) * pthread_keys_max) != PS_OK) {
+	__A_VARIABLE = 1;
+	return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Now get all descriptors, one after the other.  */
   for (cnt = 0; cnt < pthread_keys_max; ++cnt)
     if (keys[cnt].in_use
 	/* Return with an error if the callback returns a nonzero value.  */
-	&& callback (cnt, keys[cnt].destr, cbdata_p) != 0)
+	&& callback (cnt, keys[cnt].destr, cbdata_p) != 0) {
+      __A_VARIABLE = 1;
       return TD_DBERR;
+    }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_clear_event.c b/newlib/libc/sys/linux/linuxthreads/td_thr_clear_event.c
index e40e4c3..d13a7a6 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_clear_event.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_clear_event.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Disable specific event for thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -38,8 +39,10 @@ td_thr_clear_event (th, event)
 		 ((char *) th->th_unique
 		  + offsetof (struct _pthread_descr_struct,
 			      p_eventbuf.eventmask)),
-		 &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Remove the set bits in.  */
   for (i = 0; i < TD_EVENTSIZE; ++i)
@@ -50,8 +53,11 @@ td_thr_clear_event (th, event)
 		  ((char *) th->th_unique
 		   + offsetof (struct _pthread_descr_struct,
 			       p_eventbuf.eventmask)),
-		  &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_dbresume.c b/newlib/libc/sys/linux/linuxthreads/td_thr_dbresume.c
index dbe10bc..fa11d87 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_dbresume.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_dbresume.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Resume execution of given thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_dbresume (const td_thrhandle_t *th)
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_thr_dbresume");
+  __A_VARIABLE = 1;
   return TD_NOCAPAB;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_dbsuspend.c b/newlib/libc/sys/linux/linuxthreads/td_thr_dbsuspend.c
index f96be36..16c334a 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_dbsuspend.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_dbsuspend.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Suspend execution of given thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_dbsuspend (const td_thrhandle_t *th)
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_thr_dbsuspend");
+  __A_VARIABLE = 1;
   return TD_NOCAPAB;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_event_enable.c b/newlib/libc/sys/linux/linuxthreads/td_thr_event_enable.c
index 3eecd21..4b2d5c6 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_event_enable.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_event_enable.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Enable event process-wide.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -34,8 +35,11 @@ td_thr_event_enable (th, onoff)
   if (ps_pdwrite (th->th_ta_p->ph,
 		  ((char *) th->th_unique
 		   + offsetof (struct _pthread_descr_struct, p_report_events)),
-		  &onoff, sizeof (int)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &onoff, sizeof (int)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_event_getmsg.c b/newlib/libc/sys/linux/linuxthreads/td_thr_event_getmsg.c
index 582e89e..28489ed 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_event_getmsg.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_event_getmsg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Retrieve event.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -35,13 +36,17 @@ td_thr_event_getmsg (const td_thrhandle_t *th, td_event_msg_t *msg)
   if (ps_pdread (th->th_ta_p->ph,
 		 ((char *) th->th_unique
 		  + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		 &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &event, sizeof (td_eventbuf_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Check whether an event occurred.  */
-  if (event.eventnum == TD_EVENT_NONE)
+  if (event.eventnum == TD_EVENT_NONE) {
     /* Nothing.  */
+    __A_VARIABLE = 1;
     return TD_NOMSG;
+  }
 
   /* Fill the user's data structure.  */
   msg->event = event.eventnum;
@@ -53,8 +58,11 @@ td_thr_event_getmsg (const td_thrhandle_t *th, td_event_msg_t *msg)
   if (ps_pdwrite (th->th_ta_p->ph,
 		  ((char *) th->th_unique
 		   + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		  &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &event, sizeof (td_eventbuf_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_get_info.c b/newlib/libc/sys/linux/linuxthreads/td_thr_get_info.c
index b497958..c70ef64 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_get_info.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_get_info.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get thread information.
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -33,8 +34,10 @@ td_thr_get_info (const td_thrhandle_t *th, td_thrinfo_t *infop)
 
   /* Get the thread descriptor.  */
   if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		 th->th_ta_p->sizeof_descr) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 th->th_ta_p->sizeof_descr) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Fill in information.  Clear first to provide reproducable
      results for the fields we do not fill in.  */
@@ -72,5 +75,6 @@ td_thr_get_info (const td_thrhandle_t *th, td_thrinfo_t *infop)
 	  sizeof (td_thr_events_t));
   infop->ti_traceme = pds.p_report_events != 0;
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_getfpregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_getfpregs.c
index b453cc0..3cd8160 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_getfpregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_getfpregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get a thread's floating-point register set.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_getgregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_getgregs.c
index 462a1a1..d35ae90 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_getgregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_getgregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get a thread's general register set.
    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_getxregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_getxregs.c
index a519456..962eaff 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_getxregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_getxregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get a thread's extra state register set.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_getxregs (const td_thrhandle_t *th, void *xregs)
 {
   /* XXX This might be platform specific.  */
   LOG ("td_thr_getxregs");
+  __A_VARIABLE = 1;
   return TD_NOXREGS;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_getxregsize.c b/newlib/libc/sys/linux/linuxthreads/td_thr_getxregsize.c
index ddf8cbb..cb0ea79 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_getxregsize.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_getxregsize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get the size of the extra state register set for this architecture.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_getxregsize (const td_thrhandle_t *th, int *sizep)
 {
   /* XXX This might be platform specific.  */
   LOG ("td_thr_getxregsize");
+  __A_VARIABLE = 1;
   return TD_NOXREGS;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_set_event.c b/newlib/libc/sys/linux/linuxthreads/td_thr_set_event.c
index 6171155..7ac769a 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_set_event.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_set_event.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Enable specific event for thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -38,8 +39,10 @@ td_thr_set_event (th, event)
 		 ((char *) th->th_unique
 		  + offsetof (struct _pthread_descr_struct,
 			      p_eventbuf.eventmask)),
-		 &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Or the new bits in.  */
   for (i = 0; i < TD_EVENTSIZE; ++i)
@@ -50,8 +53,11 @@ td_thr_set_event (th, event)
 		  ((char *) th->th_unique
 		   + offsetof (struct _pthread_descr_struct,
 			       p_eventbuf.eventmask)),
-		  &old_event, sizeof (td_thrhandle_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		  &old_event, sizeof (td_thrhandle_t)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_setfpregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_setfpregs.c
index 0d4fce5..0206fe7 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_setfpregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_setfpregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set a thread's floating-point register set.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -30,17 +31,22 @@ td_thr_setfpregs (const td_thrhandle_t *th, const prfpregset_t *fpregs)
 
   /* We have to get the state and the PID for this thread.  */
   if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-                 sizeof (struct _pthread_descr_struct)) != PS_OK)
+                 sizeof (struct _pthread_descr_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
     return TD_ERR;
+  }
 
   /* Only set the registers if the thread hasn't yet terminated.  */
   if (pds.p_terminated == 0)
     {
       pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
 
-      if (ps_lsetfpregs (th->th_ta_p->ph, pid, fpregs) != PS_OK)
+      if (ps_lsetfpregs (th->th_ta_p->ph, pid, fpregs) != PS_OK) {
+	__A_VARIABLE = 1;
 	return TD_ERR;
+      }
     }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_setgregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_setgregs.c
index 3cf6539..c809c3f 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_setgregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_setgregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set a thread's general register set.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -30,17 +31,22 @@ td_thr_setgregs (const td_thrhandle_t *th, prgregset_t gregs)
 
   /* We have to get the state and the PID for this thread.  */
   if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-                 sizeof (struct _pthread_descr_struct)) != PS_OK)
+                 sizeof (struct _pthread_descr_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
     return TD_ERR;
+  }
 
   /* Only set the registers if the thread hasn't yet terminated.  */
   if (pds.p_terminated == 0)
     {
       pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
 
-      if (ps_lsetregs (th->th_ta_p->ph, pid, gregs) != PS_OK)
+      if (ps_lsetregs (th->th_ta_p->ph, pid, gregs) != PS_OK) {
+	__A_VARIABLE = 1;
 	return TD_ERR;
+      }
     }
 
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_setprio.c b/newlib/libc/sys/linux/linuxthreads/td_thr_setprio.c
index 01eab48..f00fba3 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_setprio.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_setprio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set a thread's priority.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_setprio (const td_thrhandle_t *th, int prio)
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_thr_setprio");
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_setsigpending.c b/newlib/libc/sys/linux/linuxthreads/td_thr_setsigpending.c
index 6ecd747..3a3e173 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_setsigpending.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_setsigpending.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Raise a signal for a thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -27,5 +28,6 @@ td_thr_setsigpending (const td_thrhandle_t *th, unsigned char n,
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_thr_setsigpending");
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_setxregs.c b/newlib/libc/sys/linux/linuxthreads/td_thr_setxregs.c
index 15ea14a..7331352 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_setxregs.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_setxregs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set a thread's extra state register set.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_setxregs (const td_thrhandle_t *ta, const void *addr)
 {
   /* XXX This might have to be platform specific.  */
   LOG ("td_thr_setxregs");
+  __A_VARIABLE = 1;
   return TD_NOXREGS;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_sigsetmask.c b/newlib/libc/sys/linux/linuxthreads/td_thr_sigsetmask.c
index 79f1443..d3f8310 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_sigsetmask.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_sigsetmask.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Set a thread's signal mask.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -26,5 +27,6 @@ td_thr_sigsetmask (const td_thrhandle_t *th, const sigset_t *ss)
 {
   /* XXX We have to figure out what has to be done.  */
   LOG ("td_thr_sigsetmask");
+  __A_VARIABLE = 1;
   return TD_OK;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_tsd.c b/newlib/libc/sys/linux/linuxthreads/td_thr_tsd.c
index 192b425..b2b14c4 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_tsd.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_tsd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get a thread-specific data pointer for a thread.
    Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -37,40 +38,53 @@ td_thr_tsd (const td_thrhandle_t *th, const thread_key_t tk, void **data)
 
   /* Get the thread descriptor.  */
   if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 sizeof (struct _pthread_descr_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Check correct value of key.  */
-  if (tk >= pthread_keys_max)
+  if (tk >= pthread_keys_max) {
+    __A_VARIABLE = 1;
     return TD_BADKEY;
+  }
 
   /* Get the key entry.  */
   if (ps_pdread (th->th_ta_p->ph, keys, &key,
-		 sizeof (struct pthread_key_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
+		 sizeof (struct pthread_key_struct)) != PS_OK) {
+    __A_VARIABLE = 1;
+    return TD_ERR;
+  }	/* XXX Other error value?  */
 
   /* Fail if this key is not at all used.  */
-  if (! key.in_use)
+  if (! key.in_use) {
+    __A_VARIABLE = 1;
     return TD_BADKEY;
+  }
 
   /* Compute the indeces.  */
   idx1st = tk / pthread_key_2ndlevel_size;
   idx2nd = tk % pthread_key_2ndlevel_size;
 
   /* Check the pointer to the second level array.  */
-  if (pds.p_specific[idx1st] == NULL)
+  if (pds.p_specific[idx1st] == NULL) {
+    __A_VARIABLE = 1;
     return TD_NOTSD;
+  }
 
   /* Now get the real key.
      XXX I don't know whether it's correct but there is currently no
      easy way to determine whether a key was never set or the value
      is NULL.  We return an error whenever the value is NULL.  */
   if (ps_pdread (th->th_ta_p->ph, &pds.p_specific[idx1st][idx2nd], &p,
-		 sizeof (void *)) != PS_OK)
+		 sizeof (void *)) != PS_OK) {
+    __A_VARIABLE = 1;
     return TD_ERR;
+  }
 
   if (p != NULL)
     *data = p;
 
+  __A_VARIABLE = 1;
   return p != NULL ? TD_OK : TD_NOTSD;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/td_thr_validate.c b/newlib/libc/sys/linux/linuxthreads/td_thr_validate.c
index 8821f0e..3c602b9 100644
--- a/newlib/libc/sys/linux/linuxthreads/td_thr_validate.c
+++ b/newlib/libc/sys/linux/linuxthreads/td_thr_validate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Validate a thread handle.
    Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -36,22 +37,28 @@ td_thr_validate (const td_thrhandle_t *th)
       struct pthread_handle_struct phc;
 
       if (ps_pdread (th->th_ta_p->ph, handles, &phc,
-		     sizeof (struct pthread_handle_struct)) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
+		     sizeof (struct pthread_handle_struct)) != PS_OK) {
+	__A_VARIABLE = 1;
+	return TD_ERR;
+      }	/* XXX Other error value?  */
 
       if (phc.h_descr != NULL && phc.h_descr == th->th_unique)
 	{
 	  struct _pthread_descr_struct pds;
 
 	  if (ps_pdread (th->th_ta_p->ph, phc.h_descr, &pds,
-			 th->th_ta_p->sizeof_descr) != PS_OK)
-	    return TD_ERR;	/* XXX Other error value?  */
+			 th->th_ta_p->sizeof_descr) != PS_OK) {
+	    __A_VARIABLE = 1;
+	    return TD_ERR;
+	  }	/* XXX Other error value?  */
 
 	  /* XXX There should be another test using the TID but this is
 	     currently not available.  */
+	  __A_VARIABLE = 1;
 	  return pds.p_terminated != 0 ? TD_NOTHR : TD_OK;
 	}
     }
 
+  __A_VARIABLE = 1;
   return TD_ERR;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_create.c b/newlib/libc/sys/linux/linuxthreads/timer_create.c
index 5eff1fc..3ff8c25 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_create.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_create.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
@@ -47,6 +48,7 @@ timer_create (clock_id, evp, timerid)
       )
     {
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -55,6 +57,7 @@ timer_create (clock_id, evp, timerid)
   if (__timer_init_failed)
     {
       __set_errno (ENOMEM);
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -175,5 +178,6 @@ timer_create (clock_id, evp, timerid)
 
   pthread_mutex_unlock (&__timer_mutex);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_delete.c b/newlib/libc/sys/linux/linuxthreads/timer_delete.c
index 24f4ffe..a1148c7 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_delete.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_delete.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
@@ -66,5 +67,6 @@ timer_delete (timerid)
 
   pthread_mutex_unlock (&__timer_mutex);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_getoverr.c b/newlib/libc/sys/linux/linuxthreads/timer_getoverr.c
index 204addc..ecaacdd 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_getoverr.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_getoverr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
@@ -41,5 +42,6 @@ timer_getoverrun (timerid)
 
   pthread_mutex_unlock (&__timer_mutex);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_gettime.c b/newlib/libc/sys/linux/linuxthreads/timer_gettime.c
index dbee9d9..fd7c7c9 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_gettime.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
@@ -67,5 +68,6 @@ timer_gettime (timerid, value)
   else
     __set_errno (EINVAL);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_routines.c b/newlib/libc/sys/linux/linuxthreads/timer_routines.c
index 65dc5dc..1800506 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_routines.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_routines.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Helper code for POSIX timer implementation on LinuxThreads.
    Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -75,6 +76,7 @@ static inline void
 list_init (struct list_links *list)
 {
   list->next = list->prev = list;
+  __A_VARIABLE = 1;
 }
 
 static inline void
@@ -84,12 +86,14 @@ list_append (struct list_links *list, struct list_links *newp)
   newp->next = list;
   list->prev->next = newp;
   list->prev = newp;
+  __A_VARIABLE = 1;
 }
 
 static inline void
 list_insbefore (struct list_links *list, struct list_links *newp)
 {
   list_append (list, newp);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -104,29 +108,34 @@ list_unlink (struct list_links *list)
 
   lnext->prev = lprev;
   lprev->next = lnext;
+  __A_VARIABLE = 1;
 }
 
 static inline struct list_links *
 list_first (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return list->next;
 }
 
 static inline struct list_links *
 list_null (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return list;
 }
 
 static inline struct list_links *
 list_next (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return list->next;
 }
 
 static inline int
 list_isempty (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return list->next == list;
 }
 
@@ -135,6 +144,7 @@ list_isempty (struct list_links *list)
 static inline struct thread_node *
 thread_links2ptr (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return (struct thread_node *) ((char *) list
 				 - offsetof (struct thread_node, links));
 }
@@ -142,6 +152,7 @@ thread_links2ptr (struct list_links *list)
 static inline struct timer_node *
 timer_links2ptr (struct list_links *list)
 {
+  __A_VARIABLE = 1;
   return (struct timer_node *) ((char *) list
 				- offsetof (struct timer_node, links));
 }
@@ -165,6 +176,7 @@ thread_init (struct thread_node *thread, const pthread_attr_t *attr, clockid_t c
   thread->current_timer = 0;
   thread->captured = pthread_self ();
   thread->clock_id = clock_id;
+  __A_VARIABLE = 1;
 }
 
 
@@ -196,6 +208,7 @@ init_module (void)
 #ifdef _POSIX_THREAD_CPUTIME
   thread_init (&__timer_signal_thread_tclk, 0, CLOCK_THREAD_CPUTIME_ID);
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -208,6 +221,7 @@ reinit_after_fork (void)
 {
   init_module ();
   pthread_mutex_init (&__timer_mutex, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -221,6 +235,7 @@ __timer_init_once (void)
 #if !defined(_ELIX_LEVEL) || _ELIX_LEVEL >= 3
   pthread_atfork (0, 0, reinit_after_fork);
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -230,6 +245,7 @@ thread_deinit (struct thread_node *thread)
 {
   assert (list_isempty (&thread->timer_queue));
   pthread_cond_destroy (&thread->cond);
+  __A_VARIABLE = 1;
 }
 
 
@@ -247,9 +263,11 @@ __timer_thread_alloc (const pthread_attr_t *desired_attr, clockid_t clock_id)
       list_unlink (node);
       thread_init (thread, desired_attr, clock_id);
       list_append (&thread_active_list, node);
+      __A_VARIABLE = 1;
       return thread;
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -262,6 +280,7 @@ __timer_thread_dealloc (struct thread_node *thread)
   thread_deinit (thread);
   list_unlink (&thread->links);
   list_append (&thread_free_list, &thread->links);
+  __A_VARIABLE = 1;
 }
 
 
@@ -306,6 +325,7 @@ thread_cleanup (void *val)
       /* Unblock potentially blocked timer_delete().  */
       pthread_cond_broadcast (&thread->cond);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -364,6 +384,7 @@ thread_expire_timer (struct thread_node *self, struct timer_node *timer)
   self->current_timer = 0;
 
   pthread_cond_broadcast (&self->cond);
+  __A_VARIABLE = 1;
 }
 
 
@@ -444,6 +465,7 @@ thread_func (void *arg)
      forever - but we have to add it for proper nesting.  */
   pthread_cleanup_pop (1);
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -470,6 +492,7 @@ __timer_thread_queue_timer (struct thread_node *thread,
     }
 
   list_insbefore (iter, &insert->links);
+  __A_VARIABLE = 1;
   return athead;
 }
 
@@ -490,6 +513,7 @@ __timer_thread_start (struct thread_node *thread)
       retval = -1;
     }
 
+  __A_VARIABLE = 1;
   return retval;
 }
 
@@ -498,6 +522,7 @@ void
 __timer_thread_wakeup (struct thread_node *thread)
 {
   pthread_cond_broadcast (&thread->cond);
+  __A_VARIABLE = 1;
 }
 
 
@@ -509,6 +534,7 @@ __timer_thread_wakeup (struct thread_node *thread)
 static int
 thread_attr_compare (const pthread_attr_t *left, const pthread_attr_t *right)
 {
+  __A_VARIABLE = 1;
   return (left->__detachstate == right->__detachstate
 	  && left->__schedpolicy == right->__schedpolicy
 	  && (left->__schedparam.sched_priority
@@ -534,12 +560,14 @@ __timer_thread_find_matching (const pthread_attr_t *desired_attr,
 	  && desired_clock_id == candidate->clock_id)
 	{
 	  list_unlink (iter);
+	  __A_VARIABLE = 1;
 	  return candidate;
         }
 
       iter = list_next (iter);
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -557,9 +585,11 @@ __timer_alloc (void)
       list_unlink_ip (node);
       timer->inuse = TIMER_INUSE;
       timer->refcount = 1;
+      __A_VARIABLE = 1;
       return timer;
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -573,6 +603,7 @@ __timer_dealloc (struct timer_node *timer)
   timer->thread = NULL;	/* Break association between timer and thread.  */
   timer->inuse = TIMER_FREE;
   list_append (&timer_free_list, &timer->links);
+  __A_VARIABLE = 1;
 }
 
 
@@ -581,4 +612,5 @@ void
 __timer_mutex_cancel_handler (void *arg)
 {
   pthread_mutex_unlock (arg);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/timer_settime.c b/newlib/libc/sys/linux/linuxthreads/timer_settime.c
index 6976407..70b65c2 100644
--- a/newlib/libc/sys/linux/linuxthreads/timer_settime.c
+++ b/newlib/libc/sys/linux/linuxthreads/timer_settime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
@@ -133,5 +134,6 @@ bail:
   if (thread != NULL && need_wakeup)
     __timer_thread_wakeup (thread);
 
+  __A_VARIABLE = 1;
   return retval;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/tst-cancel.c b/newlib/libc/sys/linux/linuxthreads/tst-cancel.c
index da32aaf..0bca3f6 100644
--- a/newlib/libc/sys/linux/linuxthreads/tst-cancel.c
+++ b/newlib/libc/sys/linux/linuxthreads/tst-cancel.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Tests for cancelation handling.  */
 
 #include <pthread.h>
@@ -22,6 +23,7 @@ cleanup (void *arg)
   *cp++ = '\n';
   __libc_lseek (fd, 0, SEEK_END);
   __libc_write (fd, s, cp - s);
+  __A_VARIABLE = 1;
 }
 
 
@@ -29,6 +31,7 @@ static void *
 t1 (void *arg)
 {
   pthread_cleanup_push (cleanup, (void *) (long int) 1);
+  __A_VARIABLE = 1;
   return NULL;
   pthread_cleanup_pop (0);
 }
@@ -38,9 +41,12 @@ static void
 inner (int a)
 {
   pthread_cleanup_push (cleanup, (void *) (long int) a);
-  if (a)
+  if (a) {
+    __A_VARIABLE = 1;
     return;
+  }
   pthread_cleanup_pop (0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -49,6 +55,7 @@ t2 (void *arg)
 {
   pthread_cleanup_push (cleanup, (void *) (long int) 2);
   inner ((int) (long int) arg);
+  __A_VARIABLE = 1;
   return NULL;
   pthread_cleanup_pop (0);
 }
@@ -61,6 +68,7 @@ static void
 cleanupok (void *arg)
 {
   ++cleanupokcnt;
+  __A_VARIABLE = 1;
 }
 
 
@@ -71,6 +79,7 @@ t3 (void *arg)
   inner ((int) (long int) arg);
   pthread_exit (NULL);
   pthread_cleanup_pop (0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -80,6 +89,7 @@ innerok (int a)
   pthread_cleanup_push (cleanupok, (void *) (long int) a);
   pthread_exit (NULL);
   pthread_cleanup_pop (0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -89,6 +99,7 @@ t4 (void *arg)
   pthread_cleanup_push (cleanupok, (void *) (long int) 6);
   innerok ((int) (long int) arg);
   pthread_cleanup_pop (0);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -209,5 +220,6 @@ main (int argc, char *argv[])
       result = 1;
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/tst-context.c b/newlib/libc/sys/linux/linuxthreads/tst-context.c
index 9066e83..13ab2c6 100644
--- a/newlib/libc/sys/linux/linuxthreads/tst-context.c
+++ b/newlib/libc/sys/linux/linuxthreads/tst-context.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <errno.h>
 #include <error.h>
 #include <pthread.h>
@@ -21,6 +22,7 @@ fct (long int n)
   /* Just to use the thread local descriptor.  */
   printf ("%ld: in %s now\n", n, __FUNCTION__);
   errno = 0;
+  __A_VARIABLE = 1;
 }
 
 static void *
@@ -51,6 +53,7 @@ threadfct (void *arg)
   else
     printf ("%d: back in %s\n", n, __FUNCTION__);
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 #endif
diff --git a/newlib/libc/sys/linux/linuxthreads/tststack.c b/newlib/libc/sys/linux/linuxthreads/tststack.c
index 6789ff8..f03f5ab 100644
--- a/newlib/libc/sys/linux/linuxthreads/tststack.c
+++ b/newlib/libc/sys/linux/linuxthreads/tststack.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Tests for variable stack size handling.
    Copyright (C) 2000 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2000.
@@ -37,6 +38,7 @@ main (void)
   if (pthread_attr_setstacksize (&attr, 70*1024) != 0)
     {
       puts ("invalid stack size");
+      __A_VARIABLE = 1;
       return 1;
     }
 
@@ -49,6 +51,7 @@ main (void)
   printf ("res1 = %p\n", res1);
   printf ("res2 = %p\n", res2);
 
+  __A_VARIABLE = 1;
   return res1 != (void *) 1 || res2 != (void *) 2;
 }
 
@@ -58,6 +61,7 @@ f1 (void *parm)
   printf ("This is `%s'\n", __FUNCTION__);
   fflush (stdout);
 
+  __A_VARIABLE = 1;
   return (void *) 1;
 }
 
@@ -68,5 +72,6 @@ f2 (void *parm)
   fflush (stdout);
   sleep (1);
 
+  __A_VARIABLE = 1;
   return (void *) 2;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/unload.c b/newlib/libc/sys/linux/linuxthreads/unload.c
index c528df2..d198fdf 100644
--- a/newlib/libc/sys/linux/linuxthreads/unload.c
+++ b/newlib/libc/sys/linux/linuxthreads/unload.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Tests for non-unloading of libpthread.
    Copyright (C) 2000 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2000.
@@ -42,4 +43,5 @@ main (void)
   puts ("seems to work");
 
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/weaks.c b/newlib/libc/sys/linux/linuxthreads/weaks.c
index 6e2cf4b..bf8cc0c 100644
--- a/newlib/libc/sys/linux/linuxthreads/weaks.c
+++ b/newlib/libc/sys/linux/linuxthreads/weaks.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The weak pthread functions for Linux.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -101,21 +102,25 @@ weak_function
 pthread_exit (void *retval)
 {
   exit (EXIT_SUCCESS);
+  __A_VARIABLE = 1;
 }
 
 int
 __pthread_return_0 (void)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 __pthread_return_1 (void)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 void
 __pthread_return_void (void)
 {
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/linuxthreads/wrapsyscall.c b/newlib/libc/sys/linux/linuxthreads/wrapsyscall.c
index ec1bc2a..da1f05e 100644
--- a/newlib/libc/sys/linux/linuxthreads/wrapsyscall.c
+++ b/newlib/libc/sys/linux/linuxthreads/wrapsyscall.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Wrapper arpund system calls to provide cancelation points.
    Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/machine/i386/crt0.c b/newlib/libc/sys/linux/machine/i386/crt0.c
index 4364f61..c79198e 100644
--- a/newlib/libc/sys/linux/machine/i386/crt0.c
+++ b/newlib/libc/sys/linux/machine/i386/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/crt0.c - Run-time initialization */
 
 /* FIXME: This should be rewritten in assembler and
@@ -42,4 +43,5 @@ void _start(int args)
 
     tzset(); /* initialize timezone info */
     exit(main(argc,argv,environ));
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/machine/i386/dl-procinfo.c b/newlib/libc/sys/linux/machine/i386/dl-procinfo.c
index 75732b4..2e17658 100644
--- a/newlib/libc/sys/linux/machine/i386/dl-procinfo.c
+++ b/newlib/libc/sys/linux/machine/i386/dl-procinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Data for Linux/i386 version of processor capability information.
    Copyright (C) 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/machine/i386/get_clockfreq.c b/newlib/libc/sys/linux/machine/i386/get_clockfreq.c
index 0f49fb0..2af2e81 100644
--- a/newlib/libc/sys/linux/machine/i386/get_clockfreq.c
+++ b/newlib/libc/sys/linux/machine/i386/get_clockfreq.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Get frequency of the system processor.  i386/Linux version.
    Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -36,8 +37,10 @@ __get_clockfreq (void)
   int fd;
 
   /* If this function was called before, we know the result.  */
-  if (result != 0)
+  if (result != 0) {
+    __A_VARIABLE = 1;
     return result;
+  }
 
   fd = open ("/proc/cpuinfo", O_RDONLY);
   if (__builtin_expect (fd != -1, 1))
@@ -86,5 +89,6 @@ __get_clockfreq (void)
       close (fd);
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/machine/i386/getpagesize.c b/newlib/libc/sys/linux/machine/i386/getpagesize.c
index 3f80a7a..a299284 100644
--- a/newlib/libc/sys/linux/machine/i386/getpagesize.c
+++ b/newlib/libc/sys/linux/machine/i386/getpagesize.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 /* default pagesize */
 int __getpagesize ()
 {
+  __A_VARIABLE = 1;
   return 4096;
 }
 
diff --git a/newlib/libc/sys/linux/machine/i386/hp-timing.c b/newlib/libc/sys/linux/machine/i386/hp-timing.c
index c52099c..0b497af 100644
--- a/newlib/libc/sys/linux/machine/i386/hp-timing.c
+++ b/newlib/libc/sys/linux/machine/i386/hp-timing.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Support for high precision, low overhead timing functions.  i686 version.
    Copyright (C) 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/machine/i386/sigaction.c b/newlib/libc/sys/linux/machine/i386/sigaction.c
index 6edcb0a..18bd8ce 100644
--- a/newlib/libc/sys/linux/machine/i386/sigaction.c
+++ b/newlib/libc/sys/linux/machine/i386/sigaction.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* POSIX.1 `sigaction' call for Linux/i386.
    Copyright (C) 1991, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/malign.c b/newlib/libc/sys/linux/malign.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/malign.c
+++ b/newlib/libc/sys/linux/malign.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/malignr.c b/newlib/libc/sys/linux/malignr.c
index 5b2e14a..db85a65 100644
--- a/newlib/libc/sys/linux/malignr.c
+++ b/newlib/libc/sys/linux/malignr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void *
 _memalign_r (struct _reent *ptr, size_t alignment, size_t bytes)
 {
+  __A_VARIABLE = 1;
   return memalign (alignment, bytes);
 }
diff --git a/newlib/libc/sys/linux/mallinfor.c b/newlib/libc/sys/linux/mallinfor.c
index a2ee627..a635dd6 100644
--- a/newlib/libc/sys/linux/mallinfor.c
+++ b/newlib/libc/sys/linux/mallinfor.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <malloc.h>
 
 struct mallinfo
 _mallinfo_r (struct _reent *ptr)
 {
+  __A_VARIABLE = 1;
   return mallinfo ();
 }
diff --git a/newlib/libc/sys/linux/malloc.c b/newlib/libc/sys/linux/malloc.c
index 25007e8..99b8ec5 100644
--- a/newlib/libc/sys/linux/malloc.c
+++ b/newlib/libc/sys/linux/malloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Malloc implementation for multiple threads without lock contention.
    Copyright (C) 1996-2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -1663,6 +1664,7 @@ ptmalloc_lock_all __MALLOC_P((void))
   tsd_getspecific(arena_key, save_arena);
   tsd_setspecific(arena_key, ATFORK_ARENA_PTR);
 #endif
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -1681,6 +1683,7 @@ ptmalloc_unlock_all __MALLOC_P((void))
     if(ar_ptr == &main_arena) break;
   }
   (void)mutex_unlock(&list_lock);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -1699,6 +1702,7 @@ ptmalloc_init_all __MALLOC_P((void))
     if(ar_ptr == &main_arena) break;
   }
   (void)mutex_init(&list_lock);
+  __A_VARIABLE = 1;
 }
 
 #endif /* !defined NO_THREADS */
@@ -1741,6 +1745,7 @@ next_env_entry (char ***position)
       ++current;
     }
 
+  __A_VARIABLE = 1;
   return result;
 }
 #endif
@@ -1761,7 +1766,10 @@ ptmalloc_init __MALLOC_P((void))
 #endif
   int secure;
 
-  if(__malloc_initialized >= 0) return;
+  if(__malloc_initialized >= 0) {
+    __A_VARIABLE = 1;
+    return;
+  }
   __malloc_initialized = 0;
 #ifdef _LIBC
   __libc_pagesize = __getpagesize();
@@ -1860,6 +1868,7 @@ ptmalloc_init __MALLOC_P((void))
     (*__malloc_initialize_hook)();
 #endif
   __malloc_initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 /* There are platforms (e.g. Hurd) with a link-time hook mechanism. */
@@ -1883,6 +1892,7 @@ malloc_hook_ini(sz, caller)
 {
   __malloc_hook = NULL;
   ptmalloc_init();
+  __A_VARIABLE = 1;
   return mALLOc(sz);
 }
 
@@ -1897,6 +1907,7 @@ realloc_hook_ini(ptr, sz, caller)
   __malloc_hook = NULL;
   __realloc_hook = NULL;
   ptmalloc_init();
+  __A_VARIABLE = 1;
   return rEALLOc(ptr, sz);
 }
 
@@ -1910,6 +1921,7 @@ memalign_hook_ini(alignment, sz, caller)
 {
   __memalign_hook = NULL;
   ptmalloc_init();
+  __A_VARIABLE = 1;
   return mEMALIGn(alignment, sz);
 }
 
@@ -1950,6 +1962,7 @@ __malloc_check_init()
 {
   if (disallow_malloc_check) {
     disallow_malloc_check = 0;
+    __A_VARIABLE = 1;
     return;
   }
   using_malloc_checking = 1;
@@ -1959,6 +1972,7 @@ __malloc_check_init()
   __memalign_hook = memalign_check;
   if(check_action & 1)
     fprintf(stderr, "malloc: using debugging hooks\n");
+  __A_VARIABLE = 1;
 }
 
 #endif
@@ -2008,7 +2022,10 @@ mmap_chunk(size) size_t size;
   size = (size + SIZE_SZ + page_mask) & ~page_mask;
 
   p = (mchunkptr)MMAP(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE);
-  if(p == (mchunkptr) MAP_FAILED) return 0;
+  if(p == (mchunkptr) MAP_FAILED) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
 
   n_mmaps++;
   if (n_mmaps > max_n_mmaps) max_n_mmaps = n_mmaps;
@@ -2030,6 +2047,7 @@ mmap_chunk(size) size_t size;
   if ((unsigned long)(mmapped_mem + arena_mem + sbrked_mem) > max_total_mem)
     max_total_mem = mmapped_mem + arena_mem + sbrked_mem;
 #endif
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -2056,6 +2074,7 @@ munmap_chunk(p) mchunkptr p;
 
   /* munmap returns non-zero on failure */
   assert(ret == 0);
+  __A_VARIABLE = 1;
 }
 
 #if HAVE_MREMAP
@@ -2084,7 +2103,10 @@ mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
   cp = (char *)mremap((char *)p - offset, size + offset, new_size,
                       MREMAP_MAYMOVE);
 
-  if (cp == MAP_FAILED) return 0;
+  if (cp == MAP_FAILED) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
 
   p = (mchunkptr)(cp + offset);
 
@@ -2101,6 +2123,7 @@ mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
   if ((unsigned long)(mmapped_mem + arena_mem + sbrked_mem) > max_total_mem)
     max_total_mem = mmapped_mem + arena_mem + sbrked_mem;
 #endif
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -2415,6 +2438,7 @@ static void do_check_free_chunk(ar_ptr, p) arena *ar_ptr; mchunkptr p;
   /* ... and has minimally sane links */
   assert(p->fd->bk == p);
   assert(p->bk->fd == p);
+  __A_VARIABLE = 1;
 }
 
 #if __STD_C
@@ -2450,6 +2474,7 @@ static void do_check_inuse_chunk(ar_ptr, p) arena *ar_ptr; mchunkptr p;
   else if (!inuse(next))
     do_check_free_chunk(ar_ptr, next);
 
+  __A_VARIABLE = 1;
 }
 
 #if __STD_C
@@ -2478,6 +2503,7 @@ arena *ar_ptr; mchunkptr p; INTERNAL_SIZE_T s;
   /* ... and was allocated at front of an available chunk */
   assert(prev_inuse(p));
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -3239,6 +3265,7 @@ chunk_free(ar_ptr, p) arena *ar_ptr; mchunkptr p;
         heap_trim(heap, top_pad);
     }
 #endif
+    __A_VARIABLE = 1;
     return;
   }
 
@@ -3291,6 +3318,7 @@ chunk_free(ar_ptr, p) arena *ar_ptr; mchunkptr p;
       heap_trim(heap, top_pad);
   }
 #endif
+  __A_VARIABLE = 1;
 }
 
 
@@ -3788,6 +3816,7 @@ Void_t* vALLOc(bytes) size_t bytes;
 {
   if(__malloc_initialized < 0)
     ptmalloc_init ();
+  __A_VARIABLE = 1;
   return mEMALIGn (malloc_getpagesize, bytes);
 }
 
@@ -3807,6 +3836,7 @@ Void_t* pvALLOc(bytes) size_t bytes;
   if(__malloc_initialized < 0)
     ptmalloc_init ();
   pagesize = malloc_getpagesize;
+  __A_VARIABLE = 1;
   return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
 }
 
@@ -3928,6 +3958,7 @@ void cfree(mem) Void_t *mem;
 #endif
 {
   fREe(mem);
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -3967,6 +3998,7 @@ int mALLOC_TRIm(pad) size_t pad;
   (void)mutex_lock(&main_arena.mutex);
   res = main_trim(pad);
   (void)mutex_unlock(&main_arena.mutex);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -3992,13 +4024,17 @@ main_trim(pad) size_t pad;
   top_size = chunksize(top_chunk);
   extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 
-  if (extra < (long)pagesz) /* Not enough memory to release */
+  if (extra < (long)pagesz) /* Not enough memory to release */ {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* Test to make sure no one else called sbrk */
   current_brk = (char*)(MORECORE (0));
-  if (current_brk != (char*)(top_chunk) + top_size)
-    return 0;     /* Apparently we don't own memory; must fail */
+  if (current_brk != (char*)(top_chunk) + top_size) {
+    __A_VARIABLE = 1;
+    return 0;
+  }     /* Apparently we don't own memory; must fail */
 
   new_brk = (char*)(MORECORE (-extra));
 
@@ -4018,6 +4054,7 @@ main_trim(pad) size_t pad;
       set_head(top_chunk, top_size | PREV_INUSE);
     }
     check_chunk(&main_arena, top_chunk);
+    __A_VARIABLE = 1;
     return 0;
   }
   sbrked_mem -= extra;
@@ -4025,6 +4062,7 @@ main_trim(pad) size_t pad;
   /* Success. Adjust top accordingly. */
   set_head(top_chunk, (top_size - extra) | PREV_INUSE);
   check_chunk(&main_arena, top_chunk);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -4073,17 +4111,22 @@ heap_trim(heap, pad) heap_info *heap; size_t pad;
   }
   top_size = chunksize(top_chunk);
   extra = ((top_size - pad - MINSIZE + (pagesz-1))/pagesz - 1) * pagesz;
-  if(extra < (long)pagesz)
+  if(extra < (long)pagesz) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   /* Try to shrink. */
-  if(grow_heap(heap, -extra) != 0)
+  if(grow_heap(heap, -extra) != 0) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   ar_ptr->size -= extra;
   arena_mem -= extra;
 
   /* Success. Adjust top accordingly. */
   set_head(top_chunk, (top_size - extra) | PREV_INUSE);
   check_chunk(ar_ptr, top_chunk);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -4176,6 +4219,7 @@ malloc_update_mallinfo(ar_ptr, mi) arena *ar_ptr; struct mallinfo *mi;
   mi->keepcost = chunksize(top(ar_ptr));
 
   (void)mutex_unlock(&ar_ptr->mutex);
+  __A_VARIABLE = 1;
 }
 
 #if USE_ARENAS && MALLOC_DEBUG > 1
@@ -4209,6 +4253,7 @@ dump_heap(heap) heap_info *heap;
     fprintf(stderr, "\n");
     p = next_chunk(p);
   }
+  __A_VARIABLE = 1;
 }
 
 #endif
@@ -4288,6 +4333,7 @@ void mALLOC_STATs()
   fprintf(stderr, "locked total     = %10ld\n",
           stat_lock_direct + stat_lock_loop + stat_lock_wait);
 #endif
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -4306,6 +4352,7 @@ struct mallinfo mALLINFo()
     vptr = (Void_t*)&main_arena;
 #endif
   malloc_update_mallinfo((vptr ? (arena*)vptr : &main_arena), &mi);
+  __A_VARIABLE = 1;
   return mi;
 }
 
@@ -4334,25 +4381,34 @@ int mALLOPt(param_number, value) int param_number; int value;
   switch(param_number)
   {
     case M_TRIM_THRESHOLD:
-      trim_threshold = value; return 1;
+      trim_threshold = value; __A_VARIABLE = 1;
+      return 1;
     case M_TOP_PAD:
-      top_pad = value; return 1;
+      top_pad = value; __A_VARIABLE = 1;
+      return 1;
     case M_MMAP_THRESHOLD:
 #if USE_ARENAS
       /* Forbid setting the threshold too high. */
-      if((unsigned long)value > HEAP_MAX_SIZE/2) return 0;
+      if((unsigned long)value > HEAP_MAX_SIZE/2) {
+        __A_VARIABLE = 1;
+        return 0;
+      }
 #endif
-      mmap_threshold = value; return 1;
+      mmap_threshold = value; __A_VARIABLE = 1;
+      return 1;
     case M_MMAP_MAX:
 #if HAVE_MMAP
-      n_mmaps_max = value; return 1;
+      n_mmaps_max = value; __A_VARIABLE = 1;
+      return 1;
 #else
       if (value != 0) return 0; else  n_mmaps_max = value; return 1;
 #endif
     case M_CHECK_ACTION:
-      check_action = value; return 1;
+      check_action = value; __A_VARIABLE = 1;
+      return 1;
 
     default:
+      __A_VARIABLE = 1;
       return 0;
   }
 }
@@ -4406,8 +4462,10 @@ mALLOC_GET_STATe()
   mbinptr b;
 
   ms = (struct malloc_state*)mALLOc(sizeof(*ms));
-  if (!ms)
+  if (!ms) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   (void)mutex_lock(&main_arena.mutex);
   ms->magic = MALLOC_STATE_MAGIC;
   ms->version = MALLOC_STATE_VERSION;
@@ -4445,6 +4503,7 @@ mALLOC_GET_STATe()
   ms->using_malloc_checking = 0;
 #endif
   (void)mutex_unlock(&main_arena.mutex);
+  __A_VARIABLE = 1;
   return (Void_t*)ms;
 }
 
@@ -4463,9 +4522,15 @@ mALLOC_SET_STATe(msptr) Void_t* msptr;
   disallow_malloc_check = 1;
 #endif
   ptmalloc_init();
-  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
+  if(ms->magic != MALLOC_STATE_MAGIC) {
+    __A_VARIABLE = 1;
+    return -1;
+  }
   /* Must fail if the major version is too high. */
-  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
+  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) {
+    __A_VARIABLE = 1;
+    return -2;
+  }
   (void)mutex_lock(&main_arena.mutex);
   main_arena.av[0] = ms->av[0];
   main_arena.av[1] = ms->av[1];
@@ -4517,6 +4582,7 @@ mALLOC_SET_STATe(msptr) Void_t* msptr;
   }
 
   (void)mutex_unlock(&main_arena.mutex);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -4555,6 +4621,7 @@ chunk2mem_check(p, sz) mchunkptr p; size_t sz;
     m_ptr[i] = 0xFF;
   }
   m_ptr[sz] = MAGICBYTE(p);
+  __A_VARIABLE = 1;
   return (Void_t*)m_ptr;
 }
 
@@ -4630,7 +4697,10 @@ top_check()
   unsigned long pagesz = malloc_getpagesize;
 
   if((char*)t + chunksize(t) == sbrk_base + sbrked_mem ||
-     t == initial_top(&main_arena)) return 0;
+     t == initial_top(&main_arena)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
 
   if(check_action & 1)
     fprintf(stderr, "malloc: top chunk is corrupt\n");
@@ -4645,12 +4715,16 @@ top_check()
   sbrk_size = front_misalign + top_pad + MINSIZE;
   sbrk_size += pagesz - ((unsigned long)(brk + sbrk_size) & (pagesz - 1));
   new_brk = (char*)(MORECORE (sbrk_size));
-  if (new_brk == (char*)(MORECORE_FAILURE)) return -1;
+  if (new_brk == (char*)(MORECORE_FAILURE)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }
   sbrked_mem = (new_brk - sbrk_base) + sbrk_size;
 
   top(&main_arena) = (mchunkptr)(brk + front_misalign);
   set_head(top(&main_arena), (sbrk_size - front_misalign) | PREV_INUSE);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -4664,12 +4738,18 @@ malloc_check(sz, caller) size_t sz; const Void_t *caller;
   mchunkptr victim;
   INTERNAL_SIZE_T nb;
 
-  if(request2size(sz+1, nb))
+  if(request2size(sz+1, nb)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   (void)mutex_lock(&main_arena.mutex);
   victim = (top_check() >= 0) ? chunk_alloc(&main_arena, nb) : NULL;
   (void)mutex_unlock(&main_arena.mutex);
-  if(!victim) return NULL;
+  if(!victim) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
+  __A_VARIABLE = 1;
   return chunk2mem_check(victim, sz);
 }
 
@@ -4718,7 +4798,10 @@ realloc_check(oldmem, bytes, caller)
   mchunkptr oldp, newp;
   INTERNAL_SIZE_T nb, oldsize;
 
-  if (oldmem == 0) return malloc_check(bytes, NULL);
+  if (oldmem == 0) {
+    __A_VARIABLE = 1;
+    return malloc_check(bytes, NULL);
+  }
   (void)mutex_lock(&main_arena.mutex);
   oldp = mem2chunk_check(oldmem);
   if(!oldp) {
@@ -4727,12 +4810,14 @@ realloc_check(oldmem, bytes, caller)
       fprintf(stderr, "realloc(): invalid pointer %p!\n", oldmem);
     if(check_action & 2)
       abort();
+    __A_VARIABLE = 1;
     return malloc_check(bytes, NULL);
   }
   oldsize = chunksize(oldp);
 
   if(request2size(bytes+1, nb)) {
     (void)mutex_unlock(&main_arena.mutex);
+    __A_VARIABLE = 1;
     return 0;
   }
 
@@ -4775,7 +4860,11 @@ realloc_check(oldmem, bytes, caller)
 #endif
   (void)mutex_unlock(&main_arena.mutex);
 
-  if(!newp) return NULL;
+  if(!newp) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
+  __A_VARIABLE = 1;
   return chunk2mem_check(newp, bytes);
 }
 
@@ -4790,15 +4879,24 @@ memalign_check(alignment, bytes, caller)
   INTERNAL_SIZE_T nb;
   mchunkptr p;
 
-  if (alignment <= MALLOC_ALIGNMENT) return malloc_check(bytes, NULL);
+  if (alignment <= MALLOC_ALIGNMENT) {
+    __A_VARIABLE = 1;
+    return malloc_check(bytes, NULL);
+  }
   if (alignment <  MINSIZE) alignment = MINSIZE;
 
-  if(request2size(bytes+1, nb))
+  if(request2size(bytes+1, nb)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   (void)mutex_lock(&main_arena.mutex);
   p = (top_check() >= 0) ? chunk_align(&main_arena, nb, alignment) : NULL;
   (void)mutex_unlock(&main_arena.mutex);
-  if(!p) return NULL;
+  if(!p) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
+  __A_VARIABLE = 1;
   return chunk2mem_check(p, bytes);
 }
 
@@ -4817,10 +4915,13 @@ malloc_starter(sz, caller) size_t sz; const Void_t *caller;
   INTERNAL_SIZE_T nb;
   mchunkptr victim;
 
-  if(request2size(sz, nb))
+  if(request2size(sz, nb)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   victim = chunk_alloc(&main_arena, nb);
 
+  __A_VARIABLE = 1;
   return victim ? BOUNDED_N(chunk2mem(victim), sz) : 0;
 }
 
@@ -4928,8 +5029,11 @@ __malloc_ptr_t
 __default_morecore (int inc)
 {
   __malloc_ptr_t result = (__malloc_ptr_t)sbrk (inc);
-  if (result == (__malloc_ptr_t)-1)
+  if (result == (__malloc_ptr_t)-1) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
+  __A_VARIABLE = 1;
   return result;
 }
  
@@ -4941,17 +5045,21 @@ __posix_memalign (void **memptr, size_t alignment, size_t size)
 
   /* Test whether the ALIGNMENT argument is valid.  It must be a power
      of two multiple of sizeof (void *).  */
-  if (alignment % sizeof (void *) != 0 || (alignment & (alignment - 1)) != 0)
+  if (alignment % sizeof (void *) != 0 || (alignment & (alignment - 1)) != 0) {
+    __A_VARIABLE = 1;
     return EINVAL;
+  }
 
   mem = __libc_memalign (alignment, size);
 
   if (mem != NULL)
     {
       *memptr = mem;
+      __A_VARIABLE = 1;
       return 0;
     }
 
+  __A_VARIABLE = 1;
   return ENOMEM;
 }
 weak_alias (__posix_memalign, posix_memalign)
diff --git a/newlib/libc/sys/linux/mallocr.c b/newlib/libc/sys/linux/mallocr.c
index b5129a5..4cd0441 100644
--- a/newlib/libc/sys/linux/mallocr.c
+++ b/newlib/libc/sys/linux/mallocr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void *
 _malloc_r (struct _reent *ptr, size_t size)
 {
+  __A_VARIABLE = 1;
   return malloc (size);
 }
diff --git a/newlib/libc/sys/linux/malloptr.c b/newlib/libc/sys/linux/malloptr.c
index 13d4e9f..9f9fc7b 100644
--- a/newlib/libc/sys/linux/malloptr.c
+++ b/newlib/libc/sys/linux/malloptr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 int 
 _mallopt_r (struct _reent *ptr, int param_number, int value)
 {
+  __A_VARIABLE = 1;
   return mallopt (param_number, value);
 }
diff --git a/newlib/libc/sys/linux/mallstatsr.c b/newlib/libc/sys/linux/mallstatsr.c
index 8a1f642..31c6d9e 100644
--- a/newlib/libc/sys/linux/mallstatsr.c
+++ b/newlib/libc/sys/linux/mallstatsr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void
 _malloc_stats_r (struct _reent *ptr)
 {
   malloc_stats ();
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/mcheck.c b/newlib/libc/sys/linux/mcheck.c
index eeb99da..9dc0be3 100644
--- a/newlib/libc/sys/linux/mcheck.c
+++ b/newlib/libc/sys/linux/mcheck.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Standard debugging hooks for `malloc'.
    Copyright (C) 1990-1997, 1999, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -80,6 +81,7 @@ flood (ptr, val, size)
   char *cp = ptr;
   while (size--)
     *cp++ = val;
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -90,10 +92,12 @@ checkhdr (hdr)
 {
   enum mcheck_status status;
 
-  if (!mcheck_used)
+  if (!mcheck_used) {
     /* Maybe the mcheck used is disabled?  This happens when we find
        an error and report it.  */
+    __A_VARIABLE = 1;
     return MCHECK_OK;
+  }
 
   switch (hdr->magic ^ ((uintptr_t) hdr->prev + (uintptr_t) hdr->next))
     {
@@ -116,6 +120,7 @@ checkhdr (hdr)
       (*abortfunc) (status);
       mcheck_used = 1;
     }
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -138,6 +143,7 @@ mcheck_check_all ()
 
   /* Turn checks on again.  */
   pedantic = 1;
+  __A_VARIABLE = 1;
 }
 
 static void unlink_blk __P ((struct hdr *ptr));
@@ -159,6 +165,7 @@ unlink_blk (ptr)
     }
   else
     root = ptr->next;
+  __A_VARIABLE = 1;
 }
 
 static void link_blk  __P ((struct hdr *ptr));
@@ -178,6 +185,7 @@ link_blk (hdr)
       hdr->next->magic = MAGICWORD ^ ((uintptr_t) hdr
 				      + (uintptr_t) hdr->next->next);
     }
+    __A_VARIABLE = 1;
 }
 
 static void freehook __P ((__ptr_t, const __ptr_t));
@@ -204,6 +212,7 @@ freehook (ptr, caller)
   else
     free (ptr);
   __free_hook = freehook;
+  __A_VARIABLE = 1;
 }
 
 static __ptr_t mallochook __P ((__malloc_size_t, const __ptr_t));
@@ -224,13 +233,16 @@ mallochook (size, caller)
   else
     hdr = (struct hdr *) malloc (sizeof (struct hdr) + size + 1);
   __malloc_hook = mallochook;
-  if (hdr == NULL)
+  if (hdr == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   hdr->size = size;
   link_blk (hdr);
   ((char *) &hdr[1])[size] = MAGICBYTE;
   flood ((__ptr_t) (hdr + 1), MALLOCFLOOD, size);
+  __A_VARIABLE = 1;
   return (__ptr_t) (hdr + 1);
 }
 
@@ -275,14 +287,17 @@ reallochook (ptr, size, caller)
   __free_hook = freehook;
   __malloc_hook = mallochook;
   __realloc_hook = reallochook;
-  if (hdr == NULL)
+  if (hdr == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   hdr->size = size;
   link_blk (hdr);
   ((char *) &hdr[1])[size] = MAGICBYTE;
   if (size > osize)
     flood ((char *) (hdr + 1) + osize, MALLOCFLOOD, size - osize);
+  __A_VARIABLE = 1;
   return (__ptr_t) (hdr + 1);
 }
 
@@ -314,6 +329,7 @@ mabort (status)
   fprintf (stderr, "mcheck: %s", msg);
   fflush (stderr);
   abort ();
+  __A_VARIABLE = 1;
 }
 
 int
@@ -354,5 +370,6 @@ mcheck_pedantic (func)
 enum mcheck_status
 mprobe (__ptr_t ptr)
 {
+  __A_VARIABLE = 1;
   return mcheck_used ? checkhdr (((struct hdr *) ptr) - 1) : MCHECK_DISABLED;
 }
diff --git a/newlib/libc/sys/linux/mmap.c b/newlib/libc/sys/linux/mmap.c
index f4a8f23..a4d95ed 100644
--- a/newlib/libc/sys/linux/mmap.c
+++ b/newlib/libc/sys/linux/mmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/mmap.c - Memory mapping functions */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/mntent.c b/newlib/libc/sys/linux/mntent.c
index 0101b94..1c619dc 100644
--- a/newlib/libc/sys/linux/mntent.c
+++ b/newlib/libc/sys/linux/mntent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Utilities for reading/writing fstab, mtab, etc.
    Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -38,6 +39,7 @@ static void
 allocate (void)
 {
   getmntent_buffer = (char *) malloc (BUFFER_SIZE);
+  __A_VARIABLE = 1;
 }
 
 
@@ -57,12 +59,15 @@ getmntent (FILE *stream)
   } while (0);
 
 
-  if (getmntent_buffer == NULL)
+  if (getmntent_buffer == NULL) {
     /* If no core is available we don't have a chance to run the
        program successfully and so returning NULL is an acceptable
        result.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
+  __A_VARIABLE = 1;
   return __getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);
 }
 
@@ -74,6 +79,7 @@ __attribute__ ((unused))
 free_mem (void)
 {
   free (getmntent_buffer);
+  __A_VARIABLE = 1;
 }
 
 text_set_element (__libc_subfreeres, free_mem);
diff --git a/newlib/libc/sys/linux/mntent_r.c b/newlib/libc/sys/linux/mntent_r.c
index b534fb6..2c04ca8 100644
--- a/newlib/libc/sys/linux/mntent_r.c
+++ b/newlib/libc/sys/linux/mntent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Utilities for reading/writing fstab, mtab, etc.
    Copyright (C) 1995-2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -31,6 +32,7 @@ __setmntent (const char *file, const char *mode)
 {
   FILE *result = fopen (file, mode);
 
+  __A_VARIABLE = 1;
   return result;
 }
 weak_alias (__setmntent, setmntent)
@@ -42,6 +44,7 @@ __endmntent (FILE *stream)
 {
   if (stream)		/* SunOS 4.x allows for NULL stream */
     fclose (stream);
+  __A_VARIABLE = 1;
   return 1;		/* SunOS 4.x says to always return 1 */
 }
 weak_alias (__endmntent, endmntent)
@@ -80,6 +83,7 @@ decode_name (char *buf)
       *wp++ = *rp;
   while (*rp++ != '\0');
 
+  __A_VARIABLE = 1;
   return buf;
 }
 
@@ -101,6 +105,7 @@ __getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
       if (fgets (buffer, bufsiz, stream) == NULL)
 	{
 	  funlockfile (stream);
+	  __A_VARIABLE = 1;
 	  return NULL;
 	}
 
@@ -146,6 +151,7 @@ __getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
     }
   funlockfile (stream);
 
+  __A_VARIABLE = 1;
   return mp;
 }
 weak_alias (__getmntent_r, getmntent_r)
@@ -207,8 +213,10 @@ int
 __addmntent (FILE *stream, const struct mntent *mnt)
 {
   struct mntent mntcopy = *mnt;
-  if (fseek (stream, 0, SEEK_END))
+  if (fseek (stream, 0, SEEK_END)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
   /* Encode spaces and tabs in the names.  */
   encode_name (mntcopy.mnt_fsname);
@@ -216,6 +224,7 @@ __addmntent (FILE *stream, const struct mntent *mnt)
   encode_name (mntcopy.mnt_type);
   encode_name (mntcopy.mnt_opts);
 
+  __A_VARIABLE = 1;
   return (fprintf (stream, "%s %s %s %s %d %d\n",
 		   mntcopy.mnt_fsname,
 		   mntcopy.mnt_dir,
@@ -242,8 +251,10 @@ __hasmntopt (const struct mntent *mnt, const char *opt)
 	  || (p[-1] == ','
 	      && (p[optlen] == '\0' ||
 		  p[optlen] == '='  ||
-		  p[optlen] == ',')))
+		  p[optlen] == ','))) {
+	__A_VARIABLE = 1;
 	return p;
+      }
 
       rest = strchr (rest, ',');
       if (rest == NULL)
@@ -251,6 +262,7 @@ __hasmntopt (const struct mntent *mnt, const char *opt)
       ++rest;
     }
 
+  __A_VARIABLE = 1;
   return NULL;
 }
 weak_alias (__hasmntopt, hasmntopt)
diff --git a/newlib/libc/sys/linux/mq_close.c b/newlib/libc/sys/linux/mq_close.c
index 884c30f..0af98c3 100644
--- a/newlib/libc/sys/linux/mq_close.c
+++ b/newlib/libc/sys/linux/mq_close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -22,6 +23,7 @@ mq_close (mqd_t msgid)
   if (info == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -38,6 +40,7 @@ mq_close (mqd_t msgid)
       semop (semid, &sb0, 1);
     }
 
+  __A_VARIABLE = 1;
   return rc;
 }
       
diff --git a/newlib/libc/sys/linux/mq_getattr.c b/newlib/libc/sys/linux/mq_getattr.c
index 65813f3..35a7de9 100644
--- a/newlib/libc/sys/linux/mq_getattr.c
+++ b/newlib/libc/sys/linux/mq_getattr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -23,6 +24,7 @@ mq_getattr (mqd_t msgid, struct mq_attr *mqstat)
   if (info == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -42,6 +44,7 @@ mq_getattr (mqd_t msgid, struct mq_attr *mqstat)
   sb0.sem_op = 1;
   semop (info->semid, &sb0, 1);
 
+  __A_VARIABLE = 1;
   return rc;
 }
       
diff --git a/newlib/libc/sys/linux/mq_notify.c b/newlib/libc/sys/linux/mq_notify.c
index fd4606b..e6c254a 100644
--- a/newlib/libc/sys/linux/mq_notify.c
+++ b/newlib/libc/sys/linux/mq_notify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -10,6 +11,7 @@ int
 __libc_mq_notify (mqd_t msgid, const struct sigevent *notification)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
 weak_alias (__libc_mq_notify, mq_notify)
diff --git a/newlib/libc/sys/linux/mq_open.c b/newlib/libc/sys/linux/mq_open.c
index 9b72e90..981c2ec 100644
--- a/newlib/libc/sys/linux/mq_open.c
+++ b/newlib/libc/sys/linux/mq_open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -60,6 +61,7 @@ mq_open (const char *name, int oflag, ...)
       errno = ENOSPC;
       if (real_name)
 	free (real_name);
+      __A_VARIABLE = 1;
       return (mqd_t)-1;
     }
   
@@ -95,6 +97,7 @@ mq_open (const char *name, int oflag, ...)
 	  /* we failed and the user wanted exclusive create */
 	  free (real_name);
 	  free (info);
+	  __A_VARIABLE = 1;
 	  return (mqd_t)-1;
 	}
       errno = saved_errno;
@@ -243,6 +246,7 @@ mq_open (const char *name, int oflag, ...)
 	free (wrbuf);
       if (rdbuf)
 	free (rdbuf);
+      __A_VARIABLE = 1;
       return (mqd_t)-1;
     }
 
@@ -270,6 +274,7 @@ mq_open (const char *name, int oflag, ...)
   mq_hash[LOCHASH(index)] = info;
   __lock_release(mq_hash_lock);
 
+  __A_VARIABLE = 1;
   return (mqd_t)index;
 }
 
@@ -291,6 +296,7 @@ __find_mq (mqd_t mq)
 
   __lock_release(mq_hash_lock);
 
+  __A_VARIABLE = 1;
   return ptr;
 }
       
@@ -338,6 +344,7 @@ __cleanup_mq (mqd_t mq)
     }
 
   __lock_release(mq_hash_lock);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/newlib/libc/sys/linux/mq_receive.c b/newlib/libc/sys/linux/mq_receive.c
index 4dae081..de7e588 100644
--- a/newlib/libc/sys/linux/mq_receive.c
+++ b/newlib/libc/sys/linux/mq_receive.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -29,12 +30,14 @@ mq_receive (mqd_t msgid, char *msg, size_t msg_len, unsigned int *msg_prio)
   if (info == NULL || (info->oflag & O_ACCMODE) == O_WRONLY)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   if (msg_len < info->attr->mq_msgsize)
     {
       errno = EMSGSIZE;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -57,6 +60,7 @@ mq_receive (mqd_t msgid, char *msg, size_t msg_len, unsigned int *msg_prio)
     }
   
   __lock_release (mq_rdbuf_lock);
+  __A_VARIABLE = 1;
   return num_bytes;
 }
       
diff --git a/newlib/libc/sys/linux/mq_send.c b/newlib/libc/sys/linux/mq_send.c
index d3291fd..c06e76c 100644
--- a/newlib/libc/sys/linux/mq_send.c
+++ b/newlib/libc/sys/linux/mq_send.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -29,18 +30,21 @@ mq_send (mqd_t msgid, const char *msg, size_t msg_len, unsigned int msg_prio)
   if (info == NULL || (info->oflag & O_ACCMODE) == O_RDONLY)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   if (msg_len > info->attr->mq_msgsize)
     {
       errno = EMSGSIZE;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   if (msg_prio > MQ_PRIO_MAX)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -62,6 +66,7 @@ mq_send (mqd_t msgid, const char *msg, size_t msg_len, unsigned int msg_prio)
     semop (info->semid, &sb3, 1);  /* increment number of reads */
 
   __lock_release (mq_wrbuf_lock);
+  __A_VARIABLE = 1;
   return rc;
 }
       
diff --git a/newlib/libc/sys/linux/mq_setattr.c b/newlib/libc/sys/linux/mq_setattr.c
index 69f6cd5..33b19b1 100644
--- a/newlib/libc/sys/linux/mq_setattr.c
+++ b/newlib/libc/sys/linux/mq_setattr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -23,6 +24,7 @@ mq_setattr (mqd_t msgid, const struct mq_attr *mqstat, struct mq_attr *omqstat)
   if (info == NULL)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -49,6 +51,7 @@ mq_setattr (mqd_t msgid, const struct mq_attr *mqstat, struct mq_attr *omqstat)
   sb0.sem_op = 1;
   semop (info->semid, &sb0, 1);
 
+  __A_VARIABLE = 1;
   return rc;
 }
       
diff --git a/newlib/libc/sys/linux/mq_unlink.c b/newlib/libc/sys/linux/mq_unlink.c
index ce7bd0e..d9b986b 100644
--- a/newlib/libc/sys/linux/mq_unlink.c
+++ b/newlib/libc/sys/linux/mq_unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <mqueue.h>
@@ -35,6 +36,7 @@ mq_unlink (const char *name)
   if ((real_name = (char *)malloc (size + sizeof(MSGQ_PREFIX))) == NULL)
     {
       errno = ENOSPC;
+      __A_VARIABLE = 1;
       return -1;
     }
   
@@ -51,8 +53,10 @@ mq_unlink (const char *name)
     }
 
   /* get key and then unlink shared memory file */
-  if ((key = ftok(real_name, 255)) == (key_t)-1)
+  if ((key = ftok(real_name, 255)) == (key_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   rc = unlink (real_name);
 
@@ -69,5 +73,6 @@ mq_unlink (const char *name)
       errno = saved_errno;
     }
 
+  __A_VARIABLE = 1;
   return rc;
 }
diff --git a/newlib/libc/sys/linux/msize.c b/newlib/libc/sys/linux/msize.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/msize.c
+++ b/newlib/libc/sys/linux/msize.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/msizer.c b/newlib/libc/sys/linux/msizer.c
index 7b79053..8897648 100644
--- a/newlib/libc/sys/linux/msizer.c
+++ b/newlib/libc/sys/linux/msizer.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 size_t 
 _malloc_usable_size_r (struct _reent *ptr, void *mem)
 {
+  __A_VARIABLE = 1;
   return malloc_usable_size (mem);
 }
diff --git a/newlib/libc/sys/linux/mstats.c b/newlib/libc/sys/linux/mstats.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/mstats.c
+++ b/newlib/libc/sys/linux/mstats.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/mtrim.c b/newlib/libc/sys/linux/mtrim.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/mtrim.c
+++ b/newlib/libc/sys/linux/mtrim.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/mtrimr.c b/newlib/libc/sys/linux/mtrimr.c
index 3b2fbf3..50275b0 100644
--- a/newlib/libc/sys/linux/mtrimr.c
+++ b/newlib/libc/sys/linux/mtrimr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void *
 _malloc_trim_r (struct _reent *ptr, size_t pad)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/net/XXX-lookup.c b/newlib/libc/sys/linux/net/XXX-lookup.c
index da0e6f4..43b0fe3 100644
--- a/newlib/libc/sys/linux/net/XXX-lookup.c
+++ b/newlib/libc/sys/linux/net/XXX-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/addr2ascii.c b/newlib/libc/sys/linux/net/addr2ascii.c
index f095339..e256276 100644
--- a/newlib/libc/sys/linux/net/addr2ascii.c
+++ b/newlib/libc/sys/linux/net/addr2ascii.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright 1996 Massachusetts Institute of Technology
  *
@@ -73,6 +74,7 @@ addr2ascii(af, addrp, len, buf)
 	case AF_INET:
 		if (len != sizeof(struct in_addr)) {
 			errno = ENAMETOOLONG;
+			__A_VARIABLE = 1;
 			return 0;
 		}
 		strcpy(buf, inet_ntoa(*(const struct in_addr *)addrp));
@@ -80,7 +82,9 @@ addr2ascii(af, addrp, len, buf)
 
 	default:
 		errno = EPROTONOSUPPORT;
+		__A_VARIABLE = 1;
 		return 0;
 	}
+	__A_VARIABLE = 1;
 	return buf;
 }
diff --git a/newlib/libc/sys/linux/net/alias-lookup.c b/newlib/libc/sys/linux/net/alias-lookup.c
index 6aba466..08ea591 100644
--- a/newlib/libc/sys/linux/net/alias-lookup.c
+++ b/newlib/libc/sys/linux/net/alias-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/ascii2addr.c b/newlib/libc/sys/linux/net/ascii2addr.c
index f69e029..dce9703 100644
--- a/newlib/libc/sys/linux/net/ascii2addr.c
+++ b/newlib/libc/sys/linux/net/ascii2addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright 1996 Massachusetts Institute of Technology
  *
@@ -56,8 +57,10 @@ ascii2addr(af, ascii, result)
 		ina = result;
 		strbuf[0] = '\0';
 		strncat(strbuf, ascii, (sizeof strbuf)-1);
-		if (inet_aton(strbuf, ina))
+		if (inet_aton(strbuf, ina)) {
+			__A_VARIABLE = 1;
 			return sizeof(struct in_addr);
+		}
 		errno = EINVAL;
 		break;
 
@@ -66,5 +69,6 @@ ascii2addr(af, ascii, result)
 		break;
 	}
 
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/linux/net/base64.c b/newlib/libc/sys/linux/net/base64.c
index 76c966f..530e0f8 100644
--- a/newlib/libc/sys/linux/net/base64.c
+++ b/newlib/libc/sys/linux/net/base64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996-1999 by Internet Software Consortium.
  *
@@ -151,8 +152,10 @@ b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize) {
 		Assert(output[2] < 64);
 		Assert(output[3] < 64);
 
-		if (datalength + 4 > targsize)
+		if (datalength + 4 > targsize) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		target[datalength++] = Base64[output[0]];
 		target[datalength++] = Base64[output[1]];
 		target[datalength++] = Base64[output[2]];
@@ -173,8 +176,10 @@ b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize) {
 		Assert(output[1] < 64);
 		Assert(output[2] < 64);
 
-		if (datalength + 4 > targsize)
+		if (datalength + 4 > targsize) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		target[datalength++] = Base64[output[0]];
 		target[datalength++] = Base64[output[1]];
 		if (srclength == 1)
@@ -183,9 +188,12 @@ b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize) {
 			target[datalength++] = Base64[output[2]];
 		target[datalength++] = Pad64;
 	}
-	if (datalength >= targsize)
+	if (datalength >= targsize) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	target[datalength] = '\0';	/* Returned value doesn't count \0. */
+	__A_VARIABLE = 1;
 	return (datalength);
 }
 libresolv_hidden_def (b64_ntop)
diff --git a/newlib/libc/sys/linux/net/check_pf.c b/newlib/libc/sys/linux/net/check_pf.c
index 086879e..b9313ab 100644
--- a/newlib/libc/sys/linux/net/check_pf.c
+++ b/newlib/libc/sys/linux/net/check_pf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Determine protocol families for which interfaces exist.  Linux version.
    Copyright (C) 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -60,8 +61,10 @@ make_request (int fd, pid_t pid, bool *seen_ipv4, bool *seen_ipv6)
 
   if (TEMP_FAILURE_RETRY (sendto (fd, (void *) &req, sizeof (req), 0,
 				    (struct sockaddr *) &nladdr,
-				    sizeof (nladdr))) < 0)
+				    sizeof (nladdr))) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   *seen_ipv4 = false;
   *seen_ipv6 = false;
@@ -81,11 +84,15 @@ make_request (int fd, pid_t pid, bool *seen_ipv4, bool *seen_ipv6)
 	};
 
       ssize_t read_len = TEMP_FAILURE_RETRY (recvmsg (fd, &msg, 0));
-      if (read_len < 0)
+      if (read_len < 0) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
 
-      if (msg.msg_flags & MSG_TRUNC)
+      if (msg.msg_flags & MSG_TRUNC) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
 
       struct nlmsghdr *nlmh;
       for (nlmh = (struct nlmsghdr *) buf;
@@ -123,6 +130,7 @@ make_request (int fd, pid_t pid, bool *seen_ipv4, bool *seen_ipv6)
 
   close (fd);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/sys/linux/net/digits_dots.c b/newlib/libc/sys/linux/net/digits_dots.c
index 9576dd5..71e96da 100644
--- a/newlib/libc/sys/linux/net/digits_dots.c
+++ b/newlib/libc/sys/linux/net/digits_dots.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1997, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by H.J. Lu <hjl@gnu.ai.mit.edu>, 1997.
@@ -48,6 +49,7 @@ __nss_hostname_digits_dots (const char *name, struct hostent *resbuf,
       if (h_errnop)
 	*h_errnop = NETDB_INTERNAL;
       *result = NULL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -309,9 +311,11 @@ __nss_hostname_digits_dots (const char *name, struct hostent *resbuf,
 	}
     }
 
+  __A_VARIABLE = 1;
   return 0;
 
 done:
+  __A_VARIABLE = 1;
   return 1;
 }
 libc_hidden_def (__nss_hostname_digits_dots)
diff --git a/newlib/libc/sys/linux/net/ether_aton.c b/newlib/libc/sys/linux/net/ether_aton.c
index 071f329..5a26f11 100644
--- a/newlib/libc/sys/linux/net/ether_aton.c
+++ b/newlib/libc/sys/linux/net/ether_aton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -25,5 +26,6 @@ ether_aton (const char *asc)
 {
   static struct ether_addr result;
 
+  __A_VARIABLE = 1;
   return ether_aton_r (asc, &result);
 }
diff --git a/newlib/libc/sys/linux/net/ether_aton_r.c b/newlib/libc/sys/linux/net/ether_aton_r.c
index 1e9f15a..4f5f77d 100644
--- a/newlib/libc/sys/linux/net/ether_aton_r.c
+++ b/newlib/libc/sys/linux/net/ether_aton_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996,97,98,99,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -34,22 +35,28 @@ ether_aton_r (const char *asc, struct ether_addr *addr)
       char ch;
 
       ch = _tolower (*asc++);
-      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) {
+	__A_VARIABLE = 1;
 	return NULL;
+      }
       number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);
 
       ch = _tolower (*asc);
       if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\0' && !isspace (ch)))
 	{
 	  ++asc;
-	  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+	  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) {
+	    __A_VARIABLE = 1;
 	    return NULL;
+	  }
 	  number <<= 4;
 	  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);
 
 	  ch = *asc;
-	  if (cnt < 5 && ch != ':')
+	  if (cnt < 5 && ch != ':') {
+	    __A_VARIABLE = 1;
 	    return NULL;
+	  }
 	}
 
       /* Store result.  */
@@ -59,6 +66,7 @@ ether_aton_r (const char *asc, struct ether_addr *addr)
       ++asc;
     }
 
+  __A_VARIABLE = 1;
   return addr;
 }
 libc_hidden_def (ether_aton_r)
diff --git a/newlib/libc/sys/linux/net/ether_hton.c b/newlib/libc/sys/linux/net/ether_hton.c
index a226d9f..d9e6aff 100644
--- a/newlib/libc/sys/linux/net/ether_hton.c
+++ b/newlib/libc/sys/linux/net/ether_hton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -79,5 +80,6 @@ ether_hostton (const char *hostname, struct ether_addr *addr)
     memcpy (addr, etherent.e_addr.ether_addr_octet,
 	    sizeof (struct ether_addr));
 
+  __A_VARIABLE = 1;
   return status == NSS_STATUS_SUCCESS ? 0 : -1;
 }
diff --git a/newlib/libc/sys/linux/net/ether_line.c b/newlib/libc/sys/linux/net/ether_line.c
index 8be593e..ea1f5c9 100644
--- a/newlib/libc/sys/linux/net/ether_line.c
+++ b/newlib/libc/sys/linux/net/ether_line.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -35,23 +36,29 @@ ether_line (const char *line, struct ether_addr *addr, char *hostname)
       char ch;
 
       ch = _tolower (*line++);
-      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
       number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);
 
       ch = _tolower (*line);
       if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\0' && !isspace (ch)))
 	{
 	  ++line;
-	  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))
+	  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) {
+	    __A_VARIABLE = 1;
 	    return -1;
+	  }
 	  number <<= 4;
 	  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);
 
 	  ch = *line;
-	  if (cnt < 5 && ch != ':')
+	  if (cnt < 5 && ch != ':') {
+	    __A_VARIABLE = 1;
 	    return -1;
 	}
+	}
 
       /* Store result.  */
       addr->ether_addr_octet[cnt] = (unsigned char) number;
@@ -68,14 +75,17 @@ ether_line (const char *line, struct ether_addr *addr, char *hostname)
   while (cp > line && isspace (cp[-1]))
     --cp;
 
-  if (cp == line)
+  if (cp == line) {
     /* No hostname.  */
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* XXX This can cause trouble because the hostname might be too long
      but we have no possibility to check it here.  */
   memcpy (hostname, line, cp - line);
   hostname [cp - line] = '\0';
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/net/ether_ntoa.c b/newlib/libc/sys/linux/net/ether_ntoa.c
index 815aebe..2b016d8 100644
--- a/newlib/libc/sys/linux/net/ether_ntoa.c
+++ b/newlib/libc/sys/linux/net/ether_ntoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -26,5 +27,6 @@ ether_ntoa (const struct ether_addr *addr)
 {
   static char asc[18];
 
+  __A_VARIABLE = 1;
   return ether_ntoa_r (addr, asc);
 }
diff --git a/newlib/libc/sys/linux/net/ether_ntoa_r.c b/newlib/libc/sys/linux/net/ether_ntoa_r.c
index c5f347c..52bee3f 100644
--- a/newlib/libc/sys/linux/net/ether_ntoa_r.c
+++ b/newlib/libc/sys/linux/net/ether_ntoa_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996,97,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -29,6 +30,7 @@ ether_ntoa_r (const struct ether_addr *addr, char *buf)
 	   addr->ether_addr_octet[0], addr->ether_addr_octet[1],
 	   addr->ether_addr_octet[2], addr->ether_addr_octet[3],
 	   addr->ether_addr_octet[4], addr->ether_addr_octet[5]);
+  __A_VARIABLE = 1;
   return buf;
 }
 libc_hidden_def (ether_ntoa_r)
diff --git a/newlib/libc/sys/linux/net/ether_ntoh.c b/newlib/libc/sys/linux/net/ether_ntoh.c
index de8c41e..8dbb220 100644
--- a/newlib/libc/sys/linux/net/ether_ntoh.c
+++ b/newlib/libc/sys/linux/net/ether_ntoh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1999, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -82,5 +83,6 @@ ether_ntohost (char *hostname, const struct ether_addr *addr)
        provide this information.  */
     strcpy (hostname, etherent.e_name);
 
+  __A_VARIABLE = 1;
   return status == NSS_STATUS_SUCCESS ? 0 : -1;
 }
diff --git a/newlib/libc/sys/linux/net/ethers-lookup.c b/newlib/libc/sys/linux/net/ethers-lookup.c
index d31ea84..35fdcfa 100644
--- a/newlib/libc/sys/linux/net/ethers-lookup.c
+++ b/newlib/libc/sys/linux/net/ethers-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getXXbyYY.c b/newlib/libc/sys/linux/net/getXXbyYY.c
index 4fa25fa..c6cec98 100644
--- a/newlib/libc/sys/linux/net/getXXbyYY.c
+++ b/newlib/libc/sys/linux/net/getXXbyYY.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996-2001,2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getXXbyYY_r.c b/newlib/libc/sys/linux/net/getXXbyYY_r.c
index 326df94..0c0a9dc 100644
--- a/newlib/libc/sys/linux/net/getXXbyYY_r.c
+++ b/newlib/libc/sys/linux/net/getXXbyYY_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996-2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getXXent.c b/newlib/libc/sys/linux/net/getXXent.c
index a2d5f40..7fa6042 100644
--- a/newlib/libc/sys/linux/net/getXXent.c
+++ b/newlib/libc/sys/linux/net/getXXent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -90,6 +91,7 @@ GETFUNC_NAME (void)
   save = errno;
   __libc_lock_unlock (lock);
   __set_errno (save);
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libc/sys/linux/net/getXXent_r.c b/newlib/libc/sys/linux/net/getXXent_r.c
index e0228e4..cd6cc44 100644
--- a/newlib/libc/sys/linux/net/getXXent_r.c
+++ b/newlib/libc/sys/linux/net/getXXent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996,97,98,99,2000,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
@@ -130,6 +131,7 @@ SETFUNC_NAME (STAYOPEN)
   save = errno;
   __libc_lock_unlock (lock);
   __set_errno (save);
+  __A_VARIABLE = 1;
 }
 
 
@@ -148,6 +150,7 @@ ENDFUNC_NAME (void)
       __libc_lock_unlock (lock);
       __set_errno (save);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -166,6 +169,7 @@ INTERNAL (REENTRANT_GETNAME) (LOOKUP_TYPE *resbuf, char *buffer, size_t buflen,
   save = errno;
   __libc_lock_unlock (lock);
   __set_errno (save);
+  __A_VARIABLE = 1;
   return status;
 }
 
diff --git a/newlib/libc/sys/linux/net/getaddrinfo.c b/newlib/libc/sys/linux/net/getaddrinfo.c
index 4ad1789..5667ee8 100644
--- a/newlib/libc/sys/linux/net/getaddrinfo.c
+++ b/newlib/libc/sys/linux/net/getaddrinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The Inner Net License, Version 2.00
 
   The author(s) grant permission for redistribution and use in source and
@@ -1190,6 +1191,7 @@ get_scope (const struct sockaddr_storage *ss)
     /* XXX What is a good default?  */
     scope = 15;
 
+  __A_VARIABLE = 1;
   return scope;
 }
 
@@ -1310,6 +1312,7 @@ static int
 get_label (const struct sockaddr_storage *ss)
 {
   /* XXX What is a good default value?  */
+  __A_VARIABLE = 1;
   return match_prefix (ss, default_labels, INT_MAX);
 }
 
@@ -1318,6 +1321,7 @@ static int
 get_precedence (const struct sockaddr_storage *ss)
 {
   /* XXX What is a good default value?  */
+  __A_VARIABLE = 1;
   return match_prefix (ss, default_precedence, 0);
 }
 
@@ -1330,10 +1334,14 @@ rfc3484_sort (const void *p1, const void *p2)
 
   /* Rule 1: Avoid unusable destinations.
      We have the got_source_addr flag set if the destination is reachable.  */
-  if (a1->got_source_addr && ! a2->got_source_addr)
+  if (a1->got_source_addr && ! a2->got_source_addr) {
+    __A_VARIABLE = 1;
     return -1;
-  if (! a1->got_source_addr && a2->got_source_addr)
+  }
+  if (! a1->got_source_addr && a2->got_source_addr) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
 
   /* Rule 2: Prefer matching scope.  Only interesting if both
@@ -1349,10 +1357,14 @@ rfc3484_sort (const void *p1, const void *p2)
       int a1_src_scope = get_scope (&a1->source_addr);
       int a2_src_scope = get_scope (&a2->source_addr);
 
-      if (a1_dst_scope == a1_src_scope && a2_dst_scope != a2_src_scope)
+      if (a1_dst_scope == a1_src_scope && a2_dst_scope != a2_src_scope) {
+	__A_VARIABLE = 1;
 	return -1;
-      if (a1_dst_scope != a1_src_scope && a2_dst_scope == a2_src_scope)
+      }
+      if (a1_dst_scope != a1_src_scope && a2_dst_scope == a2_src_scope) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
     }
 
 
@@ -1373,10 +1385,14 @@ rfc3484_sort (const void *p1, const void *p2)
 	= get_label ((struct sockaddr_storage *) a2->dest_addr->ai_addr);
       int a2_src_label = get_label (&a2->source_addr);
 
-      if (a1_dst_label == a1_src_label && a2_dst_label != a2_src_label)
+      if (a1_dst_label == a1_src_label && a2_dst_label != a2_src_label) {
+	__A_VARIABLE = 1;
 	return -1;
-      if (a1_dst_label != a1_src_label && a2_dst_label == a2_src_label)
+      }
+      if (a1_dst_label != a1_src_label && a2_dst_label == a2_src_label) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
     }
 
 
@@ -1386,10 +1402,14 @@ rfc3484_sort (const void *p1, const void *p2)
   int a2_prec
     = get_precedence ((struct sockaddr_storage *) a2->dest_addr->ai_addr);
 
-  if (a1_prec > a2_prec)
+  if (a1_prec > a2_prec) {
+    __A_VARIABLE = 1;
     return -1;
-  if (a1_prec < a2_prec)
+  }
+  if (a1_prec < a2_prec) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
 
   /* Rule 7: Prefer native transport.
@@ -1397,10 +1417,14 @@ rfc3484_sort (const void *p1, const void *p2)
 
 
   /* Rule 8: Prefer smaller scope.  */
-  if (a1_dst_scope < a2_dst_scope)
+  if (a1_dst_scope < a2_dst_scope) {
+    __A_VARIABLE = 1;
     return -1;
-  if (a1_dst_scope > a2_dst_scope)
+  }
+  if (a1_dst_scope > a2_dst_scope) {
+    __A_VARIABLE = 1;
     return 1;
+  }
 
 
   /* Rule 9: Use longest matching prefix.  */
@@ -1460,14 +1484,19 @@ rfc3484_sort (const void *p1, const void *p2)
 	    }
 	}
 
-      if (bit1 > bit2)
+      if (bit1 > bit2) {
+	__A_VARIABLE = 1;
 	return -1;
-      if (bit1 < bit2)
+      }
+      if (bit1 < bit2) {
+	__A_VARIABLE = 1;
 	return 1;
+      }
     }
 
 
   /* Rule 10: Otherwise, leave the order unchanged.  */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1697,5 +1726,6 @@ freeaddrinfo (struct addrinfo *ai)
       free (p->ai_canonname);
       free (p);
     }
+    __A_VARIABLE = 1;
 }
 libc_hidden_def (freeaddrinfo)
diff --git a/newlib/libc/sys/linux/net/getaliasent.c b/newlib/libc/sys/linux/net/getaliasent.c
index e323475..e62ce4b 100644
--- a/newlib/libc/sys/linux/net/getaliasent.c
+++ b/newlib/libc/sys/linux/net/getaliasent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getaliasent_r.c b/newlib/libc/sys/linux/net/getaliasent_r.c
index 70dbc26..2e8e8c9 100644
--- a/newlib/libc/sys/linux/net/getaliasent_r.c
+++ b/newlib/libc/sys/linux/net/getaliasent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getaliasname.c b/newlib/libc/sys/linux/net/getaliasname.c
index 2ad315f..c985080 100644
--- a/newlib/libc/sys/linux/net/getaliasname.c
+++ b/newlib/libc/sys/linux/net/getaliasname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getaliasname_r.c b/newlib/libc/sys/linux/net/getaliasname_r.c
index ec3519d..cee316f 100644
--- a/newlib/libc/sys/linux/net/getaliasname_r.c
+++ b/newlib/libc/sys/linux/net/getaliasname_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbyad.c b/newlib/libc/sys/linux/net/gethstbyad.c
index 97992ad..a189e6b 100644
--- a/newlib/libc/sys/linux/net/gethstbyad.c
+++ b/newlib/libc/sys/linux/net/gethstbyad.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbyad_r.c b/newlib/libc/sys/linux/net/gethstbyad_r.c
index 244828e..c31bc1e 100644
--- a/newlib/libc/sys/linux/net/gethstbyad_r.c
+++ b/newlib/libc/sys/linux/net/gethstbyad_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996,1997,1998,1999,2000,2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbynm.c b/newlib/libc/sys/linux/net/gethstbynm.c
index e94eb0a..d4d3699 100644
--- a/newlib/libc/sys/linux/net/gethstbynm.c
+++ b/newlib/libc/sys/linux/net/gethstbynm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbynm2.c b/newlib/libc/sys/linux/net/gethstbynm2.c
index b365511..f2c1431 100644
--- a/newlib/libc/sys/linux/net/gethstbynm2.c
+++ b/newlib/libc/sys/linux/net/gethstbynm2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbynm2_r.c b/newlib/libc/sys/linux/net/gethstbynm2_r.c
index c7a2201..2e76fc1 100644
--- a/newlib/libc/sys/linux/net/gethstbynm2_r.c
+++ b/newlib/libc/sys/linux/net/gethstbynm2_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstbynm_r.c b/newlib/libc/sys/linux/net/gethstbynm_r.c
index ccdd6c2..17321f6 100644
--- a/newlib/libc/sys/linux/net/gethstbynm_r.c
+++ b/newlib/libc/sys/linux/net/gethstbynm_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1998, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/gethstent.c b/newlib/libc/sys/linux/net/gethstent.c
index eab9f8f..fbd0966 100644
--- a/newlib/libc/sys/linux/net/gethstent.c
+++ b/newlib/libc/sys/linux/net/gethstent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/gethstent_r.c b/newlib/libc/sys/linux/net/gethstent_r.c
index c8afa81..1de6b85 100644
--- a/newlib/libc/sys/linux/net/gethstent_r.c
+++ b/newlib/libc/sys/linux/net/gethstent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getnameinfo.c b/newlib/libc/sys/linux/net/getnameinfo.c
index 838a2d2..7ae2c65 100644
--- a/newlib/libc/sys/linux/net/getnameinfo.c
+++ b/newlib/libc/sys/linux/net/getnameinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The Inner Net License, Version 2.00
 
   The author(s) grant permission for redistribution and use in source and
@@ -155,6 +156,7 @@ nrl_domainname (void)
       __libc_lock_unlock (lock);
     }
 
+  __A_VARIABLE = 1;
   return domain;
 };
 
diff --git a/newlib/libc/sys/linux/net/getnetbyad.c b/newlib/libc/sys/linux/net/getnetbyad.c
index 73ae203..74cda35 100644
--- a/newlib/libc/sys/linux/net/getnetbyad.c
+++ b/newlib/libc/sys/linux/net/getnetbyad.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getnetbyad_r.c b/newlib/libc/sys/linux/net/getnetbyad_r.c
index 7af3cb4..d0dee88 100644
--- a/newlib/libc/sys/linux/net/getnetbyad_r.c
+++ b/newlib/libc/sys/linux/net/getnetbyad_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getnetbynm.c b/newlib/libc/sys/linux/net/getnetbynm.c
index cacf148..0c7a9d2 100644
--- a/newlib/libc/sys/linux/net/getnetbynm.c
+++ b/newlib/libc/sys/linux/net/getnetbynm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getnetbynm_r.c b/newlib/libc/sys/linux/net/getnetbynm_r.c
index 3acd2d3..506a0a7 100644
--- a/newlib/libc/sys/linux/net/getnetbynm_r.c
+++ b/newlib/libc/sys/linux/net/getnetbynm_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getnetent.c b/newlib/libc/sys/linux/net/getnetent.c
index b42ef16..8d1aaf3 100644
--- a/newlib/libc/sys/linux/net/getnetent.c
+++ b/newlib/libc/sys/linux/net/getnetent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getnetent_r.c b/newlib/libc/sys/linux/net/getnetent_r.c
index bb69819..1e5a989 100644
--- a/newlib/libc/sys/linux/net/getnetent_r.c
+++ b/newlib/libc/sys/linux/net/getnetent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getnetgrent.c b/newlib/libc/sys/linux/net/getnetgrent.c
index 050af80..ab8421a 100644
--- a/newlib/libc/sys/linux/net/getnetgrent.c
+++ b/newlib/libc/sys/linux/net/getnetgrent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -34,6 +35,7 @@ static void
 allocate (void)
 {
   buffer = (char *) malloc (BUFSIZE);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -45,8 +47,10 @@ getnetgrent (char **hostp, char **userp, char **domainp)
   if (buffer == NULL)
     {
       __set_errno (ENOMEM);
+      __A_VARIABLE = 1;
       return -1;
     }
 
+  __A_VARIABLE = 1;
   return __getnetgrent_r (hostp, userp, domainp, buffer, BUFSIZE);
 }
diff --git a/newlib/libc/sys/linux/net/getnetgrent_r.c b/newlib/libc/sys/linux/net/getnetgrent_r.c
index ebc2ac5..1f8485d 100644
--- a/newlib/libc/sys/linux/net/getnetgrent_r.c
+++ b/newlib/libc/sys/linux/net/getnetgrent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996,1997,1998,1999,2002,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -87,6 +88,7 @@ free_memory (struct __netgrent *data)
       data->needed_groups = data->needed_groups->next;
       free (tmp);
     }
+    __A_VARIABLE = 1;
 }
 
 static int
@@ -128,6 +130,7 @@ __internal_setnetgrent_reuse (const char *group, struct __netgrent *datap,
       datap->known_groups = new_elem;
     }
 
+  __A_VARIABLE = 1;
   return status == NSS_STATUS_SUCCESS;
 }
 
@@ -140,6 +143,7 @@ internal_setnetgrent (const char *group, struct __netgrent *datap)
   /* Free list of all netgroup names from last run.  */
   free_memory (datap);
 
+  __A_VARIABLE = 1;
   return __internal_setnetgrent_reuse (group, datap, &errno);
 }
 libc_hidden_def (internal_setnetgrent)
@@ -156,6 +160,7 @@ setnetgrent (const char *group)
 
   __libc_lock_unlock (lock);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -189,6 +194,7 @@ internal_endnetgrent (struct __netgrent *datap)
 
   /* Now free list of all netgroup names from last run.  */
   free_memory (datap);
+  __A_VARIABLE = 1;
 }
 libc_hidden_def (internal_endnetgrent)
 strong_alias (internal_endnetgrent, __internal_endnetgrent)
@@ -202,6 +208,7 @@ endnetgrent (void)
   internal_endnetgrent (&dataset);
 
   __libc_lock_unlock (lock);
+  __A_VARIABLE = 1;
 }
 
 
@@ -291,6 +298,7 @@ internal_getnetgrent_r (char **hostp, char **userp, char **domainp,
       *domainp = (char *) datap->val.triple.domain;
     }
 
+  __A_VARIABLE = 1;
   return status == NSS_STATUS_SUCCESS ? 1 : 0;
 }
 libc_hidden_def (internal_getnetgrent_r)
@@ -310,6 +318,7 @@ __getnetgrent_r (char **hostp, char **userp, char **domainp,
 
   __libc_lock_unlock (lock);
 
+  __A_VARIABLE = 1;
   return status;
 }
 weak_alias (__getnetgrent_r, getnetgrent_r)
@@ -441,6 +450,7 @@ innetgr (const char *netgroup, const char *host, const char *user,
   /* Free the memory.  */
   free_memory (&entry);
 
+  __A_VARIABLE = 1;
   return result;
 }
 libc_hidden_def (innetgr)
diff --git a/newlib/libc/sys/linux/net/getnssent.c b/newlib/libc/sys/linux/net/getnssent.c
index 1f7573d..dff792b 100644
--- a/newlib/libc/sys/linux/net/getnssent.c
+++ b/newlib/libc/sys/linux/net/getnssent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -54,5 +55,6 @@ __nss_getent (getent_r_function func, void **resbuf, char **buffer,
   if (*buffer == NULL)
     result = NULL;
 
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/net/getnssent_r.c b/newlib/libc/sys/linux/net/getnssent_r.c
index 517f19d..9c624b2 100644
--- a/newlib/libc/sys/linux/net/getnssent_r.c
+++ b/newlib/libc/sys/linux/net/getnssent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -63,6 +64,7 @@ __nss_setent (const char *func_name, db_lookup_function lookup_fct,
   if (res && __res_maybe_init (&_res, 0) == -1)
     {
       h_errno = (NETDB_INTERNAL);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -88,6 +90,7 @@ __nss_setent (const char *func_name, db_lookup_function lookup_fct,
 
   if (stayopen_tmp)
     *stayopen_tmp = stayopen;
+  __A_VARIABLE = 1;
 }
 
 
@@ -106,6 +109,7 @@ __nss_endent (const char *func_name, db_lookup_function lookup_fct,
   if (res && __res_maybe_init (&_res, 0) == -1)
     {
       h_errno = (NETDB_INTERNAL);
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -123,6 +127,7 @@ __nss_endent (const char *func_name, db_lookup_function lookup_fct,
       no_more = __nss_next (nip, func_name, &fct.ptr, 0, 1);
     }
   *last_nip = *nip = NULL;
+  __A_VARIABLE = 1;
 }
 
 
@@ -147,6 +152,7 @@ __nss_getent_r (const char *getent_func_name,
     {
       *h_errnop = NETDB_INTERNAL;
       *result = NULL;
+      __A_VARIABLE = 1;
       return errno;
     }
 
@@ -210,6 +216,7 @@ __nss_getent_r (const char *getent_func_name,
     }
 
   *result = status == NSS_STATUS_SUCCESS ? resbuf : NULL;
+  __A_VARIABLE = 1;
   return (status == NSS_STATUS_SUCCESS ? 0
 	  : status != NSS_STATUS_TRYAGAIN ? ENOENT
 	  /* h_errno functions only set errno if h_errno is NETDB_INTERNAL.  */
diff --git a/newlib/libc/sys/linux/net/getproto.c b/newlib/libc/sys/linux/net/getproto.c
index 750c109..0ee1634 100644
--- a/newlib/libc/sys/linux/net/getproto.c
+++ b/newlib/libc/sys/linux/net/getproto.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getproto_r.c b/newlib/libc/sys/linux/net/getproto_r.c
index 486df1d..4f1b89d 100644
--- a/newlib/libc/sys/linux/net/getproto_r.c
+++ b/newlib/libc/sys/linux/net/getproto_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getprtent.c b/newlib/libc/sys/linux/net/getprtent.c
index 16a7e57..7aae6e9 100644
--- a/newlib/libc/sys/linux/net/getprtent.c
+++ b/newlib/libc/sys/linux/net/getprtent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getprtent_r.c b/newlib/libc/sys/linux/net/getprtent_r.c
index 2f0ca47..5ff7b09 100644
--- a/newlib/libc/sys/linux/net/getprtent_r.c
+++ b/newlib/libc/sys/linux/net/getprtent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getprtname.c b/newlib/libc/sys/linux/net/getprtname.c
index 1222dae..7389fba 100644
--- a/newlib/libc/sys/linux/net/getprtname.c
+++ b/newlib/libc/sys/linux/net/getprtname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getprtname_r.c b/newlib/libc/sys/linux/net/getprtname_r.c
index b0dee38..da638e0 100644
--- a/newlib/libc/sys/linux/net/getprtname_r.c
+++ b/newlib/libc/sys/linux/net/getprtname_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getrpcbyname.c b/newlib/libc/sys/linux/net/getrpcbyname.c
index 266967a..57cd9d8 100644
--- a/newlib/libc/sys/linux/net/getrpcbyname.c
+++ b/newlib/libc/sys/linux/net/getrpcbyname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getrpcbyname_r.c b/newlib/libc/sys/linux/net/getrpcbyname_r.c
index 3e7c2df..e02ee0f 100644
--- a/newlib/libc/sys/linux/net/getrpcbyname_r.c
+++ b/newlib/libc/sys/linux/net/getrpcbyname_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getrpcbynumber.c b/newlib/libc/sys/linux/net/getrpcbynumber.c
index f9513eb..83dd98c 100644
--- a/newlib/libc/sys/linux/net/getrpcbynumber.c
+++ b/newlib/libc/sys/linux/net/getrpcbynumber.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getrpcbynumber_r.c b/newlib/libc/sys/linux/net/getrpcbynumber_r.c
index 8394422..d7fff6c 100644
--- a/newlib/libc/sys/linux/net/getrpcbynumber_r.c
+++ b/newlib/libc/sys/linux/net/getrpcbynumber_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getrpcent.c b/newlib/libc/sys/linux/net/getrpcent.c
index 1b4eb03..72296b0 100644
--- a/newlib/libc/sys/linux/net/getrpcent.c
+++ b/newlib/libc/sys/linux/net/getrpcent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getrpcent_r.c b/newlib/libc/sys/linux/net/getrpcent_r.c
index e212b5f..420d3e4 100644
--- a/newlib/libc/sys/linux/net/getrpcent_r.c
+++ b/newlib/libc/sys/linux/net/getrpcent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getservent.c b/newlib/libc/sys/linux/net/getservent.c
index 76a0ead..eccf16a 100644
--- a/newlib/libc/sys/linux/net/getservent.c
+++ b/newlib/libc/sys/linux/net/getservent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getservent_r.c b/newlib/libc/sys/linux/net/getservent_r.c
index 93708bd..914831b 100644
--- a/newlib/libc/sys/linux/net/getservent_r.c
+++ b/newlib/libc/sys/linux/net/getservent_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/net/getsrvbynm.c b/newlib/libc/sys/linux/net/getsrvbynm.c
index c3d2b2a..f003d13 100644
--- a/newlib/libc/sys/linux/net/getsrvbynm.c
+++ b/newlib/libc/sys/linux/net/getsrvbynm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getsrvbynm_r.c b/newlib/libc/sys/linux/net/getsrvbynm_r.c
index 3abf997..e97cadc 100644
--- a/newlib/libc/sys/linux/net/getsrvbynm_r.c
+++ b/newlib/libc/sys/linux/net/getsrvbynm_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getsrvbypt.c b/newlib/libc/sys/linux/net/getsrvbypt.c
index f6b383d..0b6e296 100644
--- a/newlib/libc/sys/linux/net/getsrvbypt.c
+++ b/newlib/libc/sys/linux/net/getsrvbypt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/getsrvbypt_r.c b/newlib/libc/sys/linux/net/getsrvbypt_r.c
index 100a9b2..12842a6 100644
--- a/newlib/libc/sys/linux/net/getsrvbypt_r.c
+++ b/newlib/libc/sys/linux/net/getsrvbypt_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/grp-lookup.c b/newlib/libc/sys/linux/net/grp-lookup.c
index 9373045..07abac1 100644
--- a/newlib/libc/sys/linux/net/grp-lookup.c
+++ b/newlib/libc/sys/linux/net/grp-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/herrno.c b/newlib/libc/sys/linux/net/herrno.c
index bb6d3f5..2486514 100644
--- a/newlib/libc/sys/linux/net/herrno.c
+++ b/newlib/libc/sys/linux/net/herrno.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include <reent.h>
 
 int *__h_errno_location() {
+  __A_VARIABLE = 1;
   return &(_REENT->_new._reent._h_errno);
 }
 
diff --git a/newlib/libc/sys/linux/net/hosts-lookup.c b/newlib/libc/sys/linux/net/hosts-lookup.c
index 8dff71f..7969441 100644
--- a/newlib/libc/sys/linux/net/hosts-lookup.c
+++ b/newlib/libc/sys/linux/net/hosts-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/ifname.c b/newlib/libc/sys/linux/net/ifname.c
index d2609b1..b28c99b 100644
--- a/newlib/libc/sys/linux/net/ifname.c
+++ b/newlib/libc/sys/linux/net/ifname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: ifname.c,v 1.4 2001/08/20 02:32:40 itojun Exp $	*/
 
 /*
@@ -62,18 +63,23 @@ if_onametoindex(ifname)
 	struct if_nameindex *iff = if_nameindex(), *ifx;
 	int ret;
 
-	if (iff == NULL) return 0;
+	if (iff == NULL) {
+		__A_VARIABLE = 1;
+		return 0;
+	}
 	ifx = iff;
 	while (ifx->if_name != NULL) {
 		if (strcmp(ifx->if_name, ifname) == 0) {
 			ret = ifx->if_index;
 			if_freenameindex(iff);
+			__A_VARIABLE = 1;
 			return ret;
 		}
 		ifx++;
 	}
 	if_freenameindex(iff);
 	errno = ENXIO;
+	__A_VARIABLE = 1;
 	return 0;
 }
  
@@ -85,14 +91,18 @@ if_nametoindex(ifname)
 	struct ifreq ifr;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
-	if (s == -1)
+	if (s == -1) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
 	if (ioctl(s, SIOCGIFINDEX, &ifr) == -1) {
 		close (s);
+		__A_VARIABLE = 1;
 		return (if_onametoindex(ifname));
 	}
 	close(s);
+	__A_VARIABLE = 1;
 	return (ifr.ifr_index);
 }
 
@@ -104,7 +114,10 @@ if_indextoname(ifindex, ifname)
 	struct if_nameindex *iff = if_nameindex(), *ifx;
 	char *cp, *dp;
 
-	if (iff == NULL) return NULL;
+	if (iff == NULL) {
+		__A_VARIABLE = 1;
+		return NULL;
+	}
 	ifx = iff;
 	while (ifx->if_index != 0) {
 		if (ifx->if_index == ifindex) {
@@ -112,12 +125,14 @@ if_indextoname(ifindex, ifname)
 			dp = ifx->if_name;
 			while ((*cp++ = *dp++)) ;
 			if_freenameindex(iff);
+			__A_VARIABLE = 1;
 			return (ifname);
 		}
 		ifx++;
 	}
 	if_freenameindex(iff);
 	errno = ENXIO;
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -144,8 +159,10 @@ if_nameindex()
 	mib[3] = 0;		/* wildcard address family */
 	mib[4] = 0;
 	mib[5] = 0;		/* no flags */
-	if (__sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
+	if (__sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 	if ((buf = malloc(needed)) == NULL) {
 		errno = ENOMEM;
 		goto end;
@@ -218,6 +235,7 @@ if_nameindex()
 	if (ifbuf) free(ifbuf);
 	if (ifx) free(ifx);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -225,4 +243,5 @@ void if_freenameindex(ptr)
 	struct if_nameindex *ptr;
 {
 	free(ptr);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/ifreq.c b/newlib/libc/sys/linux/net/ifreq.c
index 9d6a612..ea461c8 100644
--- a/newlib/libc/sys/linux/net/ifreq.c
+++ b/newlib/libc/sys/linux/net/ifreq.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>.
@@ -42,6 +43,7 @@ __ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
     {
       *num_ifs = 0;
       *ifreqs = NULL;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -81,6 +83,7 @@ __ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
 
 	  *num_ifs = 0;
 	  *ifreqs = NULL;
+	  __A_VARIABLE = 1;
 	  return;
 	}
 
@@ -97,4 +100,5 @@ __ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
 
   *num_ifs = nifs;
   *ifreqs = realloc (ifc.ifc_buf, nifs * sizeof (struct ifreq));
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/in6_addr.c b/newlib/libc/sys/linux/net/in6_addr.c
index a75b64e..c159b56 100644
--- a/newlib/libc/sys/linux/net/in6_addr.c
+++ b/newlib/libc/sys/linux/net/in6_addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1997, 1998, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Philip Blundell <pjb27@cam.ac.uk>, 1997.
diff --git a/newlib/libc/sys/linux/net/inet6_option.c b/newlib/libc/sys/linux/net/inet6_option.c
index 182cfe9..0acc19a 100644
--- a/newlib/libc/sys/linux/net/inet6_option.c
+++ b/newlib/libc/sys/linux/net/inet6_option.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
@@ -48,6 +49,7 @@ add_pad (struct cmsghdr *cmsg, int len)
 
   /* Account for the bytes.  */
   cmsg->cmsg_len += len;
+  __A_VARIABLE = 1;
 }
 
 
@@ -55,25 +57,31 @@ static int
 get_opt_end (const uint8_t **result, const uint8_t *startp,
 	     const uint8_t *endp)
 {
-  if (startp >= endp)
+  if (startp >= endp) {
     /* Out of bounds.  */
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   if (*startp == IP6OPT_PAD1)
     {
       /* Just this one byte.  */
       *result = startp + 1;
+      __A_VARIABLE = 1;
       return 0;
     }
 
   /* Now we know there must be at least two bytes.  */
   if (startp + 2 > endp
       /* Now we can get the length byte.  */
-      || startp + startp[1] + 2 > endp)
+      || startp + startp[1] + 2 > endp) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   *result = startp + startp[1] + 2;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -94,6 +102,7 @@ inet6_option_space (nbytes)
   /* Add room for the extension header.  */
   nbytes += sizeof (struct ip6_ext);
 
+  __A_VARIABLE = 1;
   return CMSG_SPACE (roundup (nbytes, 8));
 }
 
@@ -110,8 +119,10 @@ inet6_option_init (bp, cmsgp, type)
      int type;
 {
   /* Only Hop-by-Hop or Destination options allowed.  */
-  if (type != IPV6_HOPOPTS && type != IPV6_DSTOPTS)
+  if (type != IPV6_HOPOPTS && type != IPV6_DSTOPTS) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* BP is a pointer to the previously allocated space.  */
   struct cmsghdr *newp = (struct cmsghdr *) bp;
@@ -128,6 +139,7 @@ inet6_option_init (bp, cmsgp, type)
   /* Pass up the result.  */
   *cmsgp = newp;
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -154,13 +166,16 @@ inet6_option_append (cmsg, typep, multx, plusy)
 
   /* Get the pointer to the space in the message.  */
   uint8_t *ptr = inet6_option_alloc (cmsg, len, multx, plusy);
-  if (ptr == NULL)
+  if (ptr == NULL) {
     /* Some problem with the parameters.  */
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   /* Copy the content.  */
   memcpy (ptr, typep, len);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -181,8 +196,10 @@ inet6_option_alloc (cmsg, datalen, multx, plusy)
 {
   /* The RFC limits the value of the alignment values.  */
   if ((multx != 1 && multx != 2 && multx != 4 && multx != 8)
-      || ! (plusy >= 0 && plusy <= 7))
+      || ! (plusy >= 0 && plusy <= 7)) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* Current data size.  */
   int dsize = cmsg->cmsg_len - CMSG_LEN (0);
@@ -209,12 +226,15 @@ inet6_option_alloc (cmsg, datalen, multx, plusy)
   /* Record the new length of the option.  */
   assert (((cmsg->cmsg_len - CMSG_LEN (0)) % 8) == 0);
   int len8b = (cmsg->cmsg_len - CMSG_LEN (0)) / 8 - 1;
-  if (len8b >= 256)
+  if (len8b >= 256) {
     /* Too long.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   ((struct ip6_ext *) CMSG_DATA (cmsg))->ip6e_len = len8b;
 
+  __A_VARIABLE = 1;
   return result;
 }
 libc_hidden_def (inet6_option_alloc)
diff --git a/newlib/libc/sys/linux/net/inet_addr.c b/newlib/libc/sys/linux/net/inet_addr.c
index 874ca80..4bbde5c 100644
--- a/newlib/libc/sys/linux/net/inet_addr.c
+++ b/newlib/libc/sys/linux/net/inet_addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: inet_addr.c,v 1.5 2001/08/20 02:32:40 itojun Exp $	*/
 
 /*
@@ -82,8 +83,11 @@ inet_addr(cp)
 {
 	struct in_addr val;
 
-	if (inet_aton(cp, &val))
+	if (inet_aton(cp, &val)) {
+		__A_VARIABLE = 1;
 		return (val.s_addr);
+	}
+	__A_VARIABLE = 1;
 	return (INADDR_NONE);
 }
 
diff --git a/newlib/libc/sys/linux/net/inet_lnaof.c b/newlib/libc/sys/linux/net/inet_lnaof.c
index 0e115a4..5389e55 100644
--- a/newlib/libc/sys/linux/net/inet_lnaof.c
+++ b/newlib/libc/sys/linux/net/inet_lnaof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
diff --git a/newlib/libc/sys/linux/net/inet_mkadr.c b/newlib/libc/sys/linux/net/inet_mkadr.c
index 26d54f2..1b469cc 100644
--- a/newlib/libc/sys/linux/net/inet_mkadr.c
+++ b/newlib/libc/sys/linux/net/inet_mkadr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -55,6 +56,7 @@ inet_makeaddr(net, host)
 	else
 		in.s_addr = net | host;
 	in.s_addr = htonl(in.s_addr);
+	__A_VARIABLE = 1;
 	return in;
 }
 libc_hidden_def (inet_makeaddr)
diff --git a/newlib/libc/sys/linux/net/inet_net.c b/newlib/libc/sys/linux/net/inet_net.c
index e9331c5..212d289 100644
--- a/newlib/libc/sys/linux/net/inet_net.c
+++ b/newlib/libc/sys/linux/net/inet_net.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -58,8 +59,10 @@ again:
 		base = 16, cp++;
 	while ((c = *cp) != 0) {
 		if (isdigit(c)) {
-			if (base == 8 && (c == '8' || c == '9'))
+			if (base == 8 && (c == '8' || c == '9')) {
+				__A_VARIABLE = 1;
 				return (INADDR_NONE);
+			}
 			val = (val * base) + (c - '0');
 			cp++;
 			digit = 1;
@@ -73,23 +76,32 @@ again:
 		}
 		break;
 	}
-	if (!digit)
+	if (!digit) {
+		__A_VARIABLE = 1;
 		return (INADDR_NONE);
-	if (pp >= parts + 4 || val > 0xff)
+	}
+	if (pp >= parts + 4 || val > 0xff) {
+		__A_VARIABLE = 1;
 		return (INADDR_NONE);
+	}
 	if (*cp == '.') {
 		*pp++ = val, cp++;
 		goto again;
 	}
-	if (*cp && !isspace(*cp))
+	if (*cp && !isspace(*cp)) {
+		__A_VARIABLE = 1;
 		return (INADDR_NONE);
-	if (pp >= parts + 4 || val > 0xff)
+	}
+	if (pp >= parts + 4 || val > 0xff) {
+		__A_VARIABLE = 1;
 		return (INADDR_NONE);
+	}
 	*pp++ = val;
 	n = pp - parts;
 	for (val = 0, i = 0; i < n; i++) {
 		val <<= 8;
 		val |= parts[i] & 0xff;
 	}
+	__A_VARIABLE = 1;
 	return (val);
 }
diff --git a/newlib/libc/sys/linux/net/inet_net_ntop.c b/newlib/libc/sys/linux/net/inet_net_ntop.c
index caa99f0..61184c4 100644
--- a/newlib/libc/sys/linux/net/inet_net_ntop.c
+++ b/newlib/libc/sys/linux/net/inet_net_ntop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
  *
@@ -60,9 +61,11 @@ inet_net_ntop(af, src, bits, dst, size)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return (inet_net_ntop_ipv4(src, bits, dst, size));
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 }
@@ -94,6 +97,7 @@ inet_net_ntop_ipv4(src, bits, dst, size)
 
 	if (bits < 0 || bits > 32) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 	if (bits == 0) {
@@ -133,10 +137,12 @@ inet_net_ntop_ipv4(src, bits, dst, size)
 	if (size < sizeof "/32")
 		goto emsgsize;
 	dst += SPRINTF((dst, "/%u", bits));
+	__A_VARIABLE = 1;
 	return (odst);
 
  emsgsize:
 	errno = EMSGSIZE;
+	__A_VARIABLE = 1;
 	return (NULL);
 }
 
diff --git a/newlib/libc/sys/linux/net/inet_net_pton.c b/newlib/libc/sys/linux/net/inet_net_pton.c
index 9386d05..8f239d1 100644
--- a/newlib/libc/sys/linux/net/inet_net_pton.c
+++ b/newlib/libc/sys/linux/net/inet_net_pton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
  *
@@ -63,9 +64,11 @@ inet_net_pton(af, src, dst, size)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return (inet_net_pton_ipv4(src, dst, size));
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 }
@@ -195,14 +198,17 @@ inet_net_pton_ipv4(src, dst, size)
 			goto emsgsize;
 		*dst++ = '\0';
 	}
+	__A_VARIABLE = 1;
 	return (bits);
 
  enoent:
 	errno = ENOENT;
+	__A_VARIABLE = 1;
 	return (-1);
 
  emsgsize:
 	errno = EMSGSIZE;
+	__A_VARIABLE = 1;
 	return (-1);
 }
 
diff --git a/newlib/libc/sys/linux/net/inet_neta.c b/newlib/libc/sys/linux/net/inet_neta.c
index c455783..8d3497d 100644
--- a/newlib/libc/sys/linux/net/inet_neta.c
+++ b/newlib/libc/sys/linux/net/inet_neta.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
  *
@@ -77,10 +78,12 @@ inet_neta(src, dst, size)
 			goto emsgsize;
 		strcpy(dst, "0.0.0.0");
 	}
+	__A_VARIABLE = 1;
 	return (odst);
 
  emsgsize:
 	errno = EMSGSIZE;
+	__A_VARIABLE = 1;
 	return (NULL);
 }
 
diff --git a/newlib/libc/sys/linux/net/inet_netof.c b/newlib/libc/sys/linux/net/inet_netof.c
index 3035f34..b54b299 100644
--- a/newlib/libc/sys/linux/net/inet_netof.c
+++ b/newlib/libc/sys/linux/net/inet_netof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
diff --git a/newlib/libc/sys/linux/net/inet_ntoa.c b/newlib/libc/sys/linux/net/inet_ntoa.c
index b0b7a15..5cb75aa 100644
--- a/newlib/libc/sys/linux/net/inet_ntoa.c
+++ b/newlib/libc/sys/linux/net/inet_ntoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Convert Inet number to ASCII representation.
    Copyright (C) 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -73,6 +74,7 @@ inet_ntoa (struct in_addr in)
   snprintf (buffer, 18, "%d.%d.%d.%d",
 	      bytes[0], bytes[1], bytes[2], bytes[3]);
 
+  __A_VARIABLE = 1;
   return buffer;
 }
 
@@ -86,6 +88,7 @@ init (void)
        wrong.  In any case use a static buffer which is better than
        nothing.  */
     static_buf = local_buf;
+  __A_VARIABLE = 1;
 }
 
 
@@ -95,4 +98,5 @@ free_key_mem (void *mem)
 {
   free (mem);
   __libc_setspecific (key, NULL);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/inet_ntop.c b/newlib/libc/sys/linux/net/inet_ntop.c
index 31746e4..6406194 100644
--- a/newlib/libc/sys/linux/net/inet_ntop.c
+++ b/newlib/libc/sys/linux/net/inet_ntop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1996 by Internet Software Consortium.
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -57,11 +58,14 @@ inet_ntop(af, src, dst, size)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return (inet_ntop4(src, dst, size));
 	case AF_INET6:
+		__A_VARIABLE = 1;
 		return (inet_ntop6(src, dst, size));
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 	/* NOTREACHED */
@@ -89,9 +93,11 @@ inet_ntop4(src, dst, size)
 
 	if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) > size) {
 		errno = ENOSPC;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 	strcpy(dst, tmp);
+	__A_VARIABLE = 1;
 	return (dst);
 }
 
@@ -168,8 +174,10 @@ inet_ntop6(src, dst, size)
 		/* Is this address an encapsulated IPv4? */
 		if (i == 6 && best.base == 0 &&
 		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
-			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp))) {
+				__A_VARIABLE = 1;
 				return (NULL);
+			}
 			tp += strlen(tp);
 			break;
 		}
@@ -186,9 +194,11 @@ inet_ntop6(src, dst, size)
 	 */
 	if ((socklen_t)(tp - tmp) > size) {
 		errno = ENOSPC;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 	strcpy(dst, tmp);
+	__A_VARIABLE = 1;
 	return (dst);
 }
 
diff --git a/newlib/libc/sys/linux/net/inet_pton.c b/newlib/libc/sys/linux/net/inet_pton.c
index eeabbb4..6265e14 100644
--- a/newlib/libc/sys/linux/net/inet_pton.c
+++ b/newlib/libc/sys/linux/net/inet_pton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: inet_pton.c,v 1.5 2001/08/20 02:32:40 itojun Exp $	*/
 
 /* Copyright (c) 1996 by Internet Software Consortium.
@@ -55,11 +56,14 @@ inet_pton(af, src, dst)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return (inet_pton4(src, dst));
 	case AF_INET6:
+		__A_VARIABLE = 1;
 		return (inet_pton6(src, dst));
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	/* NOTREACHED */
@@ -146,8 +150,10 @@ inet_pton6(src, dst)
 	colonp = NULL;
 	/* Leading :: requires some special handling. */
 	if (*src == ':')
-		if (*++src != ':')
+		if (*++src != ':') {
+			__A_VARIABLE = 1;
 			return (0);
+		}
 	curtok = src;
 	saw_xdigit = 0;
 	val = 0;
@@ -159,21 +165,27 @@ inet_pton6(src, dst)
 		if (pch != NULL) {
 			val <<= 4;
 			val |= (pch - xdigits);
-			if (val > 0xffff)
+			if (val > 0xffff) {
+				__A_VARIABLE = 1;
 				return (0);
+			}
 			saw_xdigit = 1;
 			continue;
 		}
 		if (ch == ':') {
 			curtok = src;
 			if (!saw_xdigit) {
-				if (colonp)
+				if (colonp) {
+					__A_VARIABLE = 1;
 					return (0);
+				}
 				colonp = tp;
 				continue;
 			}
-			if (tp + NS_INT16SZ > endp)
+			if (tp + NS_INT16SZ > endp) {
+				__A_VARIABLE = 1;
 				return (0);
+			}
 			*tp++ = (u_char) (val >> 8) & 0xff;
 			*tp++ = (u_char) val & 0xff;
 			saw_xdigit = 0;
@@ -186,11 +198,14 @@ inet_pton6(src, dst)
 			saw_xdigit = 0;
 			break;	/* '\0' was seen by inet_pton4(). */
 		}
+		__A_VARIABLE = 1;
 		return (0);
 	}
 	if (saw_xdigit) {
-		if (tp + NS_INT16SZ > endp)
+		if (tp + NS_INT16SZ > endp) {
+			__A_VARIABLE = 1;
 			return (0);
+		}
 		*tp++ = (u_char) (val >> 8) & 0xff;
 		*tp++ = (u_char) val & 0xff;
 	}
@@ -208,9 +223,12 @@ inet_pton6(src, dst)
 		}
 		tp = endp;
 	}
-	if (tp != endp)
+	if (tp != endp) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	memcpy(dst, tmp, NS_IN6ADDRSZ);
+	__A_VARIABLE = 1;
 	return (1);
 }
 
diff --git a/newlib/libc/sys/linux/net/issetugid-stub.c b/newlib/libc/sys/linux/net/issetugid-stub.c
index b3aac0b..85b4699 100644
--- a/newlib/libc/sys/linux/net/issetugid-stub.c
+++ b/newlib/libc/sys/linux/net/issetugid-stub.c
@@ -1,5 +1,7 @@
+static volatile int __A_VARIABLE;
 int
 issetugid(void)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libc/sys/linux/net/key-lookup.c b/newlib/libc/sys/linux/net/key-lookup.c
index e2c4c14..2a8dbe7 100644
--- a/newlib/libc/sys/linux/net/key-lookup.c
+++ b/newlib/libc/sys/linux/net/key-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/netgrp-lookup.c b/newlib/libc/sys/linux/net/netgrp-lookup.c
index 526755a..7788f0d 100644
--- a/newlib/libc/sys/linux/net/netgrp-lookup.c
+++ b/newlib/libc/sys/linux/net/netgrp-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/network-lookup.c b/newlib/libc/sys/linux/net/network-lookup.c
index 8bfaab8..8ce57ae 100644
--- a/newlib/libc/sys/linux/net/network-lookup.c
+++ b/newlib/libc/sys/linux/net/network-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/ns_name.c b/newlib/libc/sys/linux/net/ns_name.c
index d6c4cc8..18d4b3f 100644
--- a/newlib/libc/sys/linux/net/ns_name.c
+++ b/newlib/libc/sys/linux/net/ns_name.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996,1999 by Internet Software Consortium.
  *
@@ -318,11 +319,13 @@ ns_name_ntol(const u_char *src, u_char *dst, size_t dstsiz) {
 		if ((n & NS_CMPRSFLGS) != 0) {
 			/* Some kind of compression pointer. */
 			__set_errno (EMSGSIZE);
+			__A_VARIABLE = 1;
 			return (-1);
 		}
 		*dn++ = n;
 		if (dn + n >= eom) {
 			__set_errno (EMSGSIZE);
+			__A_VARIABLE = 1;
 			return (-1);
 		}
 		for ((void)NULL; n > 0; n--) {
@@ -334,6 +337,7 @@ ns_name_ntol(const u_char *src, u_char *dst, size_t dstsiz) {
 		}
 	}
 	*dn++ = '\0';
+	__A_VARIABLE = 1;
 	return (dn - dst);
 }
 
@@ -470,6 +474,7 @@ ns_name_pack(const u_char *src, u_char *dst, int dstsiz,
 		n = *srcp;
 		if ((n & NS_CMPRSFLGS) != 0 && n != 0x41) {
 			__set_errno (EMSGSIZE);
+			__A_VARIABLE = 1;
 			return (-1);
 		}
 		if (n == 0x41)
@@ -477,6 +482,7 @@ ns_name_pack(const u_char *src, u_char *dst, int dstsiz,
 		l += n + 1;
 		if (l > MAXCDNAME) {
 			__set_errno (EMSGSIZE);
+			__A_VARIABLE = 1;
 			return (-1);
 		}
 		srcp += n + 1;
@@ -496,6 +502,7 @@ ns_name_pack(const u_char *src, u_char *dst, int dstsiz,
 				}
 				*dstp++ = (l >> 8) | NS_CMPRSFLGS;
 				*dstp++ = l % 256;
+				__A_VARIABLE = 1;
 				return (dstp - dst);
 			}
 			/* Not found, save it. */
@@ -529,8 +536,10 @@ cleanup:
 		if (msg != NULL)
 			*lpp = NULL;
 		__set_errno (EMSGSIZE);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (dstp - dst);
 }
 
@@ -549,10 +558,15 @@ ns_name_uncompress(const u_char *msg, const u_char *eom, const u_char *src,
 	u_char tmp[NS_MAXCDNAME];
 	int n;
 
-	if ((n = ns_name_unpack(msg, eom, src, tmp, sizeof tmp)) == -1)
+	if ((n = ns_name_unpack(msg, eom, src, tmp, sizeof tmp)) == -1) {
+		__A_VARIABLE = 1;
 		return (-1);
-	if (ns_name_ntop(tmp, dst, dstsiz) == -1)
+	}
+	if (ns_name_ntop(tmp, dst, dstsiz) == -1) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
+	__A_VARIABLE = 1;
 	return (n);
 }
 
@@ -576,8 +590,11 @@ ns_name_compress(const char *src, u_char *dst, size_t dstsiz,
 {
 	u_char tmp[NS_MAXCDNAME];
 
-	if (ns_name_pton(src, tmp, sizeof tmp) == -1)
+	if (ns_name_pton(src, tmp, sizeof tmp) == -1) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
+	__A_VARIABLE = 1;
 	return (ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr));
 }
 
@@ -596,6 +613,7 @@ ns_name_rollback(const u_char *src, const u_char **dnptrs,
 		}
 		dnptrs++;
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -621,15 +639,18 @@ ns_name_skip(const u_char **ptrptr, const u_char *eom) {
 			break;
 		default:		/* illegal type */
 			__set_errno (EMSGSIZE);
+			__A_VARIABLE = 1;
 			return (-1);
 		}
 		break;
 	}
 	if (cp > eom) {
 		__set_errno (EMSGSIZE);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	*ptrptr = cp;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -652,8 +673,10 @@ special(int ch) {
 	/* Special modifiers in zone files. */
 	case 0x40: /* '@' */
 	case 0x24: /* '$' */
+		__A_VARIABLE = 1;
 		return (1);
 	default:
+		__A_VARIABLE = 1;
 		return (0);
 	}
 }
@@ -667,6 +690,7 @@ special(int ch) {
  */
 static int
 printable(int ch) {
+	__A_VARIABLE = 1;
 	return (ch > 0x20 && ch < 0x7f);
 }
 
@@ -676,8 +700,11 @@ printable(int ch) {
  */
 static int
 mklower(int ch) {
-	if (ch >= 0x41 && ch <= 0x5A)
+	if (ch >= 0x41 && ch <= 0x5A) {
+		__A_VARIABLE = 1;
 		return (ch + 0x20);
+	}
+	__A_VARIABLE = 1;
 	return (ch);
 }
 
@@ -724,8 +751,10 @@ dn_find(const u_char *domain, const u_char *msg,
 						    mklower(*cp++))
 							goto next;
 					/* Is next root for both ? */
-					if (*dn == '\0' && *cp == '\0')
+					if (*dn == '\0' && *cp == '\0') {
+						__A_VARIABLE = 1;
 						return (sp - msg);
+					}
 					if (*dn)
 						continue;
 					goto next;
@@ -736,6 +765,7 @@ dn_find(const u_char *domain, const u_char *msg,
 
 				default:	/* illegal type */
 					__set_errno (EMSGSIZE);
+					__A_VARIABLE = 1;
 					return (-1);
 				}
 			}
@@ -744,5 +774,6 @@ dn_find(const u_char *domain, const u_char *msg,
 		}
 	}
 	__set_errno (ENOENT);
+	__A_VARIABLE = 1;
 	return (-1);
 }
diff --git a/newlib/libc/sys/linux/net/ns_netint.c b/newlib/libc/sys/linux/net/ns_netint.c
index 16282e5..73f7a13 100644
--- a/newlib/libc/sys/linux/net/ns_netint.c
+++ b/newlib/libc/sys/linux/net/ns_netint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996,1999 by Internet Software Consortium.
  *
@@ -32,6 +33,7 @@ ns_get16(const u_char *src) {
 	u_int dst;
 
 	NS_GET16(dst, src);
+	__A_VARIABLE = 1;
 	return (dst);
 }
 libresolv_hidden_def (ns_get16)
@@ -41,6 +43,7 @@ ns_get32(const u_char *src) {
 	u_long dst;
 
 	NS_GET32(dst, src);
+	__A_VARIABLE = 1;
 	return (dst);
 }
 libresolv_hidden_def (ns_get32)
@@ -48,9 +51,11 @@ libresolv_hidden_def (ns_get32)
 void
 ns_put16(u_int src, u_char *dst) {
 	NS_PUT16(src, dst);
+	__A_VARIABLE = 1;
 }
 
 void
 ns_put32(u_long src, u_char *dst) {
 	NS_PUT32(src, dst);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/ns_parse.c b/newlib/libc/sys/linux/net/ns_parse.c
index 5311e24..e8a03e1 100644
--- a/newlib/libc/sys/linux/net/ns_parse.c
+++ b/newlib/libc/sys/linux/net/ns_parse.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996,1999 by Internet Software Consortium.
  *
@@ -83,6 +84,7 @@ ns_skiprr(const u_char *ptr, const u_char *eom, ns_sect section, int count) {
 	}
 	if (ptr > eom)
 		RETERR(EMSGSIZE);
+	__A_VARIABLE = 1;
 	return (ptr - optr);
 }
 
@@ -144,8 +146,10 @@ ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr) {
 		b = ns_skiprr(handle->_ptr, handle->_eom, section,
 			      rrnum - handle->_rrnum);
 
-		if (b < 0)
+		if (b < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		handle->_ptr += b;
 		handle->_rrnum = rrnum;
 	}
@@ -153,8 +157,10 @@ ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr) {
 	/* Do the parse. */
 	b = dn_expand(handle->_msg, handle->_eom,
 		      handle->_ptr, rr->name, NS_MAXDNAME);
-	if (b < 0)
+	if (b < 0) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	handle->_ptr += b;
 	if (handle->_ptr + NS_INT16SZ + NS_INT16SZ > handle->_eom)
 		RETERR(EMSGSIZE);
@@ -178,6 +184,7 @@ ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr) {
 		setsection(handle, (ns_sect)((int)section + 1));
 
 	/* All done. */
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -193,4 +200,5 @@ setsection(ns_msg *msg, ns_sect sect) {
 		msg->_rrnum = 0;
 		msg->_ptr = msg->_sections[(int)sect];
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/ns_print.c b/newlib/libc/sys/linux/net/ns_print.c
index bc11aa3..09d4362 100644
--- a/newlib/libc/sys/linux/net/ns_print.c
+++ b/newlib/libc/sys/linux/net/ns_print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996-1999 by Internet Software Consortium.
  *
@@ -90,6 +91,7 @@ ns_sprintrr(const ns_msg *handle, const ns_rr *rr,
 			 ns_rr_name(*rr), ns_rr_class(*rr), ns_rr_type(*rr),
 			 ns_rr_ttl(*rr), ns_rr_rdata(*rr), ns_rr_rdlen(*rr),
 			 name_ctx, origin, buf, buflen);
+	__A_VARIABLE = 1;
 	return (n);
 }
 
@@ -682,8 +684,10 @@ prune_origin(const char *name, const char *origin) {
 	const char *oname = name;
 
 	while (*name != '\0') {
-		if (origin != NULL && ns_samename(name, origin) == 1)
+		if (origin != NULL && ns_samename(name, origin) == 1) {
+			__A_VARIABLE = 1;
 			return (name - oname - (name > oname));
+		}
 		while (*name != '\0') {
 			if (*name == '\\') {
 				name++;
@@ -697,6 +701,7 @@ prune_origin(const char *name, const char *origin) {
 			name++;
 		}
 	}
+	__A_VARIABLE = 1;
 	return (name - oname);
 }
 
@@ -737,11 +742,13 @@ charstr(const u_char *rdata, const u_char *edata, char **buf, size_t *buflen) {
 	}
 	if (addstr("\"", 1, buf, buflen) < 0)
 		goto enospc;
+	__A_VARIABLE = 1;
 	return (rdata - odata);
  enospc:
 	__set_errno (ENOSPC);
 	*buf = save_buf;
 	*buflen = save_buflen;
+	__A_VARIABLE = 1;
 	return (-1);
 }
 
@@ -778,11 +785,13 @@ addname(const u_char *msg, size_t msglen,
 	*pp += n;
 	addlen(newlen, buf, buflen);
 	**buf = '\0';
+	__A_VARIABLE = 1;
 	return (newlen);
  enospc:
 	__set_errno (ENOSPC);
 	*buf = save_buf;
 	*buflen = save_buflen;
+	__A_VARIABLE = 1;
 	return (-1);
 }
 
@@ -791,17 +800,20 @@ addlen(size_t len, char **buf, size_t *buflen) {
 	assert(len <= *buflen);
 	*buf += len;
 	*buflen -= len;
+	__A_VARIABLE = 1;
 }
 
 static int
 addstr(const char *src, size_t len, char **buf, size_t *buflen) {
 	if (len >= *buflen) {
 		__set_errno (ENOSPC);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	memcpy(*buf, src, len);
 	addlen(len, buf, buflen);
 	**buf = '\0';
+	__A_VARIABLE = 1;
 	return (0);
 }
 
diff --git a/newlib/libc/sys/linux/net/ns_samedomain.c b/newlib/libc/sys/linux/net/ns_samedomain.c
index 9648637..738c417 100644
--- a/newlib/libc/sys/linux/net/ns_samedomain.c
+++ b/newlib/libc/sys/linux/net/ns_samedomain.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1995,1999 by Internet Software Consortium.
  *
@@ -86,16 +87,22 @@ ns_samedomain(const char *a, const char *b) {
 	}
 
 	/* lb == 0 means 'b' is the root domain, so 'a' must be in 'b'. */
-	if (lb == 0)
+	if (lb == 0) {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 
 	/* 'b' longer than 'a' means 'a' can't be in 'b'. */
-	if (lb > la)
+	if (lb > la) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 
 	/* 'a' and 'b' being equal at this point indicates sameness. */
-	if (lb == la)
+	if (lb == la) {
+		__A_VARIABLE = 1;
 		return (strncasecmp(a, b, lb) == 0);
+	}
 
 	/* Ok, we know la > lb. */
 
@@ -106,16 +113,20 @@ ns_samedomain(const char *a, const char *b) {
 	 * a subdomain of 'b' (because of the need for the '.' label
 	 * separator).
 	 */
-	if (diff < 2)
+	if (diff < 2) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 
 	/*
 	 * If the character before the last 'lb' characters of 'b'
 	 * isn't '.', then it can't be a match (this lets us avoid
 	 * having "foobar.com" match "bar.com").
 	 */
-	if (a[diff - 1] != '.')
+	if (a[diff - 1] != '.') {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 
 	/*
 	 * We're not sure about that '.', however.  It could be escaped
@@ -130,11 +141,14 @@ ns_samedomain(const char *a, const char *b) {
 				escaped = 1;
 		else
 			break;
-	if (escaped)
+	if (escaped) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	  
 	/* Now compare aligned trailing substring. */
 	cp = a + diff;
+	__A_VARIABLE = 1;
 	return (strncasecmp(cp, b, lb) == 0);
 }
 
@@ -145,6 +159,7 @@ ns_samedomain(const char *a, const char *b) {
  */
 int
 ns_subdomain(const char *a, const char *b) {
+	__A_VARIABLE = 1;
 	return (ns_samename(a, b) != 1 && ns_samedomain(a, b));
 }
 
@@ -166,6 +181,7 @@ ns_makecanon(const char *src, char *dst, size_t dstsize) {
 
 	if (n + sizeof "." > dstsize) {
 		__set_errno (EMSGSIZE);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 	strcpy(dst, src);
@@ -177,6 +193,7 @@ ns_makecanon(const char *src, char *dst, size_t dstsize) {
 			dst[--n] = '\0';
 	dst[n++] = '.';
 	dst[n] = '\0';
+	__A_VARIABLE = 1;
 	return (0);
 }
 
diff --git a/newlib/libc/sys/linux/net/ns_ttl.c b/newlib/libc/sys/linux/net/ns_ttl.c
index 87cd7b1..8b37859 100644
--- a/newlib/libc/sys/linux/net/ns_ttl.c
+++ b/newlib/libc/sys/linux/net/ns_ttl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996,1999 by Internet Software Consortium.
  *
@@ -88,6 +89,7 @@ ns_format_ttl(u_long src, char *dst, size_t dstlen) {
 				*p = tolower(ch);
 	}
 
+	__A_VARIABLE = 1;
 	return (dst - odst);
 }
 
@@ -136,10 +138,12 @@ ns_parse_ttl(const char *src, u_long *dst) {
 			ttl += tmp;
 	}
 	*dst = ttl;
+	__A_VARIABLE = 1;
 	return (0);
 
  einval:
 	__set_errno (EINVAL);
+	__A_VARIABLE = 1;
 	return (-1);
 }
 #endif
@@ -152,10 +156,13 @@ fmt1(int t, char s, char **buf, size_t *buflen) {
 	size_t len;
 
 	len = SPRINTF((tmp, "%d%c", t, s));
-	if (len + 1 > *buflen)
+	if (len + 1 > *buflen) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	strcpy(*buf, tmp);
 	*buf += len;
 	*buflen -= len;
+	__A_VARIABLE = 1;
 	return (0);
 }
diff --git a/newlib/libc/sys/linux/net/nsap_addr.c b/newlib/libc/sys/linux/net/nsap_addr.c
index 5c0855f..0a1ee57 100644
--- a/newlib/libc/sys/linux/net/nsap_addr.c
+++ b/newlib/libc/sys/linux/net/nsap_addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996-1999 by Internet Software Consortium.
  *
@@ -34,6 +35,7 @@ static const char rcsid[] = "$BINDId: nsap_addr.c,v 8.10 1999/10/13 16:39:28 vix
 
 static char
 xtob(int c) {
+	__A_VARIABLE = 1;
 	return (c - (((c >= '0') && (c <= '9')) ? '0' : '7'));
 }
 
@@ -94,5 +96,6 @@ inet_nsap_ntoa(int binlen, const u_char *binary, char *ascii) {
 			*ascii++ = '.';
 	}
 	*ascii = '\0';
+	__A_VARIABLE = 1;
 	return (start);
 }
diff --git a/newlib/libc/sys/linux/net/nsswitch.c b/newlib/libc/sys/linux/net/nsswitch.c
index 6c5d1f8..97dd4ea 100644
--- a/newlib/libc/sys/linux/net/nsswitch.c
+++ b/newlib/libc/sys/linux/net/nsswitch.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997, 1998, 1999, 2001, 2002, 2003, 2004
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -99,6 +100,7 @@ __nss_database_lookup (const char *database, const char *alternate_name,
   if (*ni != NULL)
     {
       __libc_lock_unlock (lock);
+      __A_VARIABLE = 1;
       return 0;
     }
 
@@ -138,6 +140,7 @@ __nss_database_lookup (const char *database, const char *alternate_name,
 
   __libc_lock_unlock (lock);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 libc_hidden_def (__nss_database_lookup)
@@ -160,6 +163,7 @@ __nss_lookup (service_user **ni, const char *fct_name, void **fctp)
       *fctp = __nss_lookup_function (*ni, fct_name);
     }
 
+  __A_VARIABLE = 1;
   return *fctp != NULL ? 0 : (*ni)->next == NULL ? 1 : -1;
 }
 
@@ -224,6 +228,7 @@ __nss_configure_lookup (const char *dbname, const char *service_line)
       if (cmp < 0)
 	{
 	  __set_errno (EINVAL);
+	  __A_VARIABLE = 1;
 	  return -1;
 	}
     }
@@ -231,13 +236,16 @@ __nss_configure_lookup (const char *dbname, const char *service_line)
   if (cnt == sizeof databases)
     {
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
 
   /* Test whether it is really used.  */
-  if (databases[cnt].dbp == NULL)
+  if (databases[cnt].dbp == NULL) {
     /* Nothing to do, but we could do.  */
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   /* Try to generate new data.  */
   new_db = nss_parse_service_list (service_line);
@@ -245,6 +253,7 @@ __nss_configure_lookup (const char *dbname, const char *service_line)
     {
       /* Illegal service specification.  */
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -256,6 +265,7 @@ __nss_configure_lookup (const char *dbname, const char *service_line)
 
   __libc_lock_unlock (lock);
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -264,6 +274,7 @@ __nss_configure_lookup (const char *dbname, const char *service_line)
 static int
 known_compare (const void *p1, const void *p2)
 {
+  __A_VARIABLE = 1;
   return p1 == p2 ? 0 : strcmp (*(const char *const *) p1,
 				*(const char *const *) p2);
 }
@@ -418,6 +429,7 @@ __nss_lookup_function (service_user *ni, const char *fct_name)
   /* Remove the lock.  */
   __libc_lock_unlock (lock);
 
+  __A_VARIABLE = 1;
   return result;
 }
 libc_hidden_def (__nss_lookup_function)
@@ -435,15 +447,19 @@ nss_parse_file (const char *fname)
 
   /* Open the configuration file.  */
   fp = fopen (fname, "rc");
-  if (fp == NULL)
+  if (fp == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* No threads use this stream.  */
   __fsetlocking (fp, FSETLOCKING_BYCALLER);
 
   result = (name_database *) malloc (sizeof (name_database));
-  if (result == NULL)
+  if (result == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   result->entry = NULL;
   result->library = NULL;
@@ -493,6 +509,7 @@ nss_parse_file (const char *fname)
   /* Close configuration file.  */
   fclose (fp);
 
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -660,16 +677,20 @@ nss_getline (char *line)
   name = line;
   while (line[0] != '\0' && !isspace (line[0]) && line[0] != ':')
     ++line;
-  if (line[0] == '\0' || name == line)
+  if (line[0] == '\0' || name == line) {
     /* Syntax error.  */
+    __A_VARIABLE = 1;
     return NULL;
+  }
   *line++ = '\0';
 
   len = strlen (name) + 1;
 
   result = (name_database_entry *) malloc (sizeof (name_database_entry) + len);
-  if (result == NULL)
+  if (result == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   /* Save the database name.  */
   memcpy (result->name, name, len);
@@ -678,6 +699,7 @@ nss_getline (char *line)
   result->service = nss_parse_service_list (line);
 
   result->next = NULL;
+  __A_VARIABLE = 1;
   return result;
 }
 
@@ -690,20 +712,25 @@ nss_new_service (name_database *database, const char *name)
 
   while (*currentp != NULL)
     {
-      if (strcmp ((*currentp)->name, name) == 0)
+      if (strcmp ((*currentp)->name, name) == 0) {
+	__A_VARIABLE = 1;
 	return *currentp;
+      }
       currentp = &(*currentp)->next;
     }
 
   /* We have to add the new service.  */
   *currentp = (service_library *) malloc (sizeof (service_library));
-  if (*currentp == NULL)
+  if (*currentp == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   (*currentp)->name = name;
   (*currentp)->lib_handle = NULL;
   (*currentp)->next = NULL;
 
+  __A_VARIABLE = 1;
   return *currentp;
 }
 
@@ -717,6 +744,7 @@ __nss_disable_nscd (void)
   __nss_not_use_nscd_passwd = -1;
   __nss_not_use_nscd_group = -1;
   __nss_not_use_nscd_hosts = -1;
+  __A_VARIABLE = 1;
 }
 #endif
 
@@ -728,9 +756,11 @@ libc_freeres_fn (free_mem)
   name_database_entry *entry;
   service_library *library;
 
-  if (top == NULL)
+  if (top == NULL) {
     /* Maybe we have not read the nsswitch.conf file.  */
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* Don't disturb ongoing other threads (if there are any).  */
   service_table = NULL;
@@ -769,4 +799,5 @@ libc_freeres_fn (free_mem)
     }
 
   free (top);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/opensock.c b/newlib/libc/sys/linux/net/opensock.c
index 7ff3f69..91debf6 100644
--- a/newlib/libc/sys/linux/net/opensock.c
+++ b/newlib/libc/sys/linux/net/opensock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -69,10 +70,12 @@ __opensock (void)
       assert (last_type != 0);
 
       result = socket (last_family, last_type, 0);
-      if (result != -1 || errno != EAFNOSUPPORT)
+      if (result != -1 || errno != EAFNOSUPPORT) {
 	/* Maybe the socket type isn't supported anymore (module is
 	   unloaded).  In this case again try to find the type.  */
+	__A_VARIABLE = 1;
 	return result;
+      }
 
       /* Reset the values.  They seem not valid anymore.  */
       last_family = 0;
@@ -109,6 +112,7 @@ __opensock (void)
 	  /* Found an available family.  */
 	  last_type = type;
 	  last_family = afs[cnt].family;
+	  __A_VARIABLE = 1;
 	  return result;
 	}
     }
@@ -116,5 +120,6 @@ __opensock (void)
   /* None of the protocol families is available.  It is unclear what kind
      of error is returned.  ENOENT seems like a reasonable choice.  */
   __set_errno (ENOENT);
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/linux/net/proto-lookup.c b/newlib/libc/sys/linux/net/proto-lookup.c
index 8f98158..4dba548 100644
--- a/newlib/libc/sys/linux/net/proto-lookup.c
+++ b/newlib/libc/sys/linux/net/proto-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/pwd-lookup.c b/newlib/libc/sys/linux/net/pwd-lookup.c
index 1def3a0..18233f2 100644
--- a/newlib/libc/sys/linux/net/pwd-lookup.c
+++ b/newlib/libc/sys/linux/net/pwd-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/rcmd.c b/newlib/libc/sys/linux/net/rcmd.c
index ab3ade8..38d29e0 100644
--- a/newlib/libc/sys/linux/net/rcmd.c
+++ b/newlib/libc/sys/linux/net/rcmd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 1998 WIDE Project.
  * All rights reserved.
@@ -412,6 +413,7 @@ rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 	const char *locuser, *remuser, *cmd;
 	int *fd2p;
 {
+  __A_VARIABLE = 1;
   return rcmd_af (ahost, rport, locuser, remuser, cmd, fd2p, AF_INET);
 }
 
@@ -436,11 +438,14 @@ rresvport_af(alport, family)
 		break;
 	default:
 		__set_errno (EAFNOSUPPORT);
+		__A_VARIABLE = 1;
 		return -1;
 	}
 	s = __socket(family, SOCK_STREAM, 0);
-	if (s < 0)
+	if (s < 0) {
+		__A_VARIABLE = 1;
 		return -1;
+	}
 
 	memset (&ss, '\0', sizeof(ss));
 #ifdef SALEN
@@ -457,10 +462,13 @@ rresvport_af(alport, family)
 	int start = *alport;
 	do {
 		*sport = htons((uint16_t) *alport);
-		if (__bind(s, (struct sockaddr *)&ss, len) >= 0)
+		if (__bind(s, (struct sockaddr *)&ss, len) >= 0) {
+			__A_VARIABLE = 1;
 			return s;
+		}
 		if (errno != EADDRINUSE) {
 			(void)__close(s);
+			__A_VARIABLE = 1;
 			return -1;
 		}
 		if ((*alport)-- == IPPORT_RESERVED/2)
@@ -468,6 +476,7 @@ rresvport_af(alport, family)
 	} while (*alport != start);
 	(void)__close(s);
 	__set_errno (EAGAIN);
+	__A_VARIABLE = 1;
 	return -1;
 }
 libc_hidden_def (rresvport_af)
@@ -476,6 +485,7 @@ int
 rresvport(alport)
 	int *alport;
 {
+	__A_VARIABLE = 1;
 	return rresvport_af(alport, AF_INET);
 }
 
@@ -495,8 +505,10 @@ ruserok_af(rhost, superuser, ruser, luser, af)
 	memset (&hints, '\0', sizeof(hints));
 	hints.ai_family = af;
 	gai = getaddrinfo(rhost, NULL, &hints, &res0);
-	if (gai)
+	if (gai) {
+		__A_VARIABLE = 1;
 		return -1;
+	}
 	ret = -1;
 	for (res=res0; res; res=res->ai_next)
 		if (ruserok2_sa(res->ai_addr, res->ai_addrlen,
@@ -505,6 +517,7 @@ ruserok_af(rhost, superuser, ruser, luser, af)
 			break;
 		}
 	freeaddrinfo(res0);
+	__A_VARIABLE = 1;
 	return (ret);
 }
 libc_hidden_def (ruserok_af)
@@ -514,6 +527,7 @@ ruserok(rhost, superuser, ruser, luser)
 	const char *rhost, *ruser, *luser;
 	int superuser;
 {
+	__A_VARIABLE = 1;
 	return ruserok_af(rhost, superuser, ruser, luser, AF_INET);
 }
 
@@ -554,12 +568,14 @@ iruserfopen (const char *file, uid_t okuser)
       __rcmd_errstr = cp;
       if (res)
 	fclose (res);
+      __A_VARIABLE = 1;
       return NULL;
     }
 
   /* No threads use this stream.  */
   __fsetlocking (res, FSETLOCKING_BYCALLER);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -590,8 +606,10 @@ ruserok2_sa (ra, ralen, superuser, ruser, luser, rhost)
       isbad = __validuser2_sa (hostf, ra, ralen, luser, ruser, rhost);
       fclose (hostf);
 
-      if (!isbad)
+      if (!isbad) {
+	__A_VARIABLE = 1;
 	return 0;
+      }
     }
 
   if (__check_rhosts_file || superuser)
@@ -604,8 +622,10 @@ ruserok2_sa (ra, ralen, superuser, ruser, luser, rhost)
       uid_t uid;
 
       if (__getpwnam_r (luser, &pwdbuf, buffer, buflen, &pwd) != 0
-	  || pwd == NULL)
+	  || pwd == NULL) {
+	__A_VARIABLE = 1;
 	return -1;
+      }
 
       dirlen = strlen (pwd->pw_dir);
       pbuf = alloca (dirlen + sizeof "/.rhosts");
@@ -626,8 +646,10 @@ ruserok2_sa (ra, ralen, superuser, ruser, luser, rhost)
 	 }
 
        seteuid (uid);
+       __A_VARIABLE = 1;
        return isbad;
     }
+  __A_VARIABLE = 1;
   return -1;
 }
 /*
@@ -640,6 +662,7 @@ static int ruserok_sa(ra, ralen, superuser, ruser, luser)
      int superuser;
      const char *ruser, *luser;
 {
+  __A_VARIABLE = 1;
   return ruserok2_sa(ra, ralen, superuser, ruser, luser, "-");
 }
 
@@ -669,8 +692,10 @@ iruserok_af (raddr, superuser, ruser, luser, af)
     ralen = sizeof(struct sockaddr_in6);
     break;
   default:
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return ruserok_sa ((struct sockaddr *)&ra, ralen, superuser, ruser, luser);
 }
 libc_hidden_def (iruserok_af)
@@ -681,6 +706,7 @@ iruserok (raddr, superuser, ruser, luser)
      int superuser;
      const char *ruser, *luser;
 {
+  __A_VARIABLE = 1;
   return iruserok_af (&raddr, superuser, ruser, luser, AF_INET);
 }
 
@@ -775,21 +801,30 @@ __icheckuser (const char *luser, const char *ruser)
       */
 
     /* [-+]@netgroup */
-    if (strncmp ("+@", luser, 2) == 0)
+    if (strncmp ("+@", luser, 2) == 0) {
+	__A_VARIABLE = 1;
 	return innetgr (&luser[2], NULL, ruser, NULL);
+    }
 
-    if (strncmp ("-@", luser,2) == 0)
+    if (strncmp ("-@", luser,2) == 0) {
+	__A_VARIABLE = 1;
 	return -innetgr (&luser[2], NULL, ruser, NULL);
+    }
 
     /* -user */
-    if (strncmp ("-", luser, 1) == 0)
+    if (strncmp ("-", luser, 1) == 0) {
+	__A_VARIABLE = 1;
 	return -(strcmp (&luser[1], ruser) == 0);
+    }
 
     /* + */
-    if (strcmp ("+", luser) == 0)
+    if (strcmp ("+", luser) == 0) {
+	__A_VARIABLE = 1;
 	return 1;
+    }
 
     /* simple string match */
+    __A_VARIABLE = 1;
     return strcmp (ruser, luser) == 0;
 }
 
@@ -803,6 +838,7 @@ __isempty (char *p)
 	++p;
     }
 
+    __A_VARIABLE = 1;
     return (*p == '\0' || *p == '#') ? 1 : 0 ;
 }
 
@@ -881,5 +917,6 @@ __validuser2_sa(hostf, ra, ralen, luser, ruser, rhost)
     if (buf != NULL)
       free (buf);
 
+    __A_VARIABLE = 1;
     return retval;
 }
diff --git a/newlib/libc/sys/linux/net/rcmdsh.c b/newlib/libc/sys/linux/net/rcmdsh.c
index 741814c..234e3a6 100644
--- a/newlib/libc/sys/linux/net/rcmdsh.c
+++ b/newlib/libc/sys/linux/net/rcmdsh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$OpenBSD: rcmdsh.c,v 1.5 1998/04/25 16:23:58 millert Exp $	*/
 
 /*
diff --git a/newlib/libc/sys/linux/net/recv.c b/newlib/libc/sys/linux/net/recv.c
index 43e537b..481a32a 100644
--- a/newlib/libc/sys/linux/net/recv.c
+++ b/newlib/libc/sys/linux/net/recv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1988, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -50,5 +51,6 @@ recv(s, buf, len, flags)
 	size_t len;
 	void *buf;
 {
+	__A_VARIABLE = 1;
 	return (recvfrom(s, buf, len, flags, NULL, 0));
 }
diff --git a/newlib/libc/sys/linux/net/res_comp.c b/newlib/libc/sys/linux/net/res_comp.c
index 51211f7..4653b72 100644
--- a/newlib/libc/sys/linux/net/res_comp.c
+++ b/newlib/libc/sys/linux/net/res_comp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -95,6 +96,7 @@ dn_expand(const u_char *msg, const u_char *eom, const u_char *src,
 
 	if (n > 0 && dst[0] == '.')
 		dst[0] = '\0';
+	__A_VARIABLE = 1;
 	return (n);
 }
 libresolv_hidden_def (dn_expand)
@@ -108,6 +110,7 @@ int
 dn_comp(const char *src, u_char *dst, int dstsiz,
 	u_char **dnptrs, u_char **lastdnptr)
 {
+	__A_VARIABLE = 1;
 	return (ns_name_compress(src, dst, (size_t)dstsiz,
 				 (const u_char **)dnptrs,
 				 (const u_char **)lastdnptr));
@@ -121,8 +124,11 @@ int
 dn_skipname(const u_char *ptr, const u_char *eom) {
 	const u_char *saveptr = ptr;
 
-	if (ns_name_skip(&ptr, eom) == -1)
+	if (ns_name_skip(&ptr, eom) == -1) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
+	__A_VARIABLE = 1;
 	return (ptr - saveptr);
 }
 libresolv_hidden_def (dn_skipname)
@@ -183,11 +189,16 @@ libresolv_hidden_def (res_hnok)
 int
 res_ownok(const char *dn) {
 	if (asterchar(dn[0])) {
-		if (periodchar(dn[1]))
+		if (periodchar(dn[1])) {
+			__A_VARIABLE = 1;
 			return (res_hnok(dn+2));
-		if (dn[1] == '\0')
+		}
+		if (dn[1] == '\0') {
+			__A_VARIABLE = 1;
 			return (1);
+		}
 	}
+	__A_VARIABLE = 1;
 	return (res_hnok(dn));
 }
 
@@ -200,13 +211,17 @@ res_mailok(const char *dn) {
 	int ch, escaped = 0;
 
 	/* "." is a valid missing representation */
-	if (*dn == '\0')
+	if (*dn == '\0') {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 
 	/* otherwise <label>.<hostname> */
 	while ((ch = *dn++) != '\0') {
-		if (!domainchar(ch))
+		if (!domainchar(ch)) {
+			__A_VARIABLE = 1;
 			return (0);
+		}
 		if (!escaped && periodchar(ch))
 			break;
 		if (escaped)
@@ -214,8 +229,11 @@ res_mailok(const char *dn) {
 		else if (bslashchar(ch))
 			escaped = 1;
 	}
-	if (periodchar(ch))
+	if (periodchar(ch)) {
+		__A_VARIABLE = 1;
 		return (res_hnok(dn));
+	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -228,8 +246,11 @@ res_dnok(const char *dn) {
 	int ch;
 
 	while ((ch = *dn++) != '\0')
-		if (!domainchar(ch))
+		if (!domainchar(ch)) {
+			__A_VARIABLE = 1;
 			return (0);
+		}
+	__A_VARIABLE = 1;
 	return (1);
 }
 libresolv_hidden_def (res_dnok)
@@ -243,13 +264,17 @@ libresolv_hidden_def (res_dnok)
  *	__getshort
  * Note that one _ comes from C and the others come from us.
  */
-void __putlong(u_int32_t src, u_char *dst) { ns_put32(src, dst); }
+void __putlong(u_int32_t src, u_char *dst) { ns_put32(src, dst); __A_VARIABLE = 1;
+}
 libresolv_hidden_def (__putlong)
-void __putshort(u_int16_t src, u_char *dst) { ns_put16(src, dst); }
+void __putshort(u_int16_t src, u_char *dst) { ns_put16(src, dst); __A_VARIABLE = 1;
+}
 libresolv_hidden_def (__putshort)
 #ifndef __ultrix__
-u_int32_t _getlong(const u_char *src) { return (ns_get32(src)); }
-u_int16_t _getshort(const u_char *src) { return (ns_get16(src)); }
+u_int32_t _getlong(const u_char *src) { __A_VARIABLE = 1;
+	return (ns_get32(src)); }
+u_int16_t _getshort(const u_char *src) { __A_VARIABLE = 1;
+	return (ns_get16(src)); }
 #endif /*__ultrix__*/
 #endif /*BIND_4_COMPAT*/
 
diff --git a/newlib/libc/sys/linux/net/res_data.c b/newlib/libc/sys/linux/net/res_data.c
index cb140ee..53260b5 100644
--- a/newlib/libc/sys/linux/net/res_data.c
+++ b/newlib/libc/sys/linux/net/res_data.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1995-1999 by Internet Software Consortium.
  *
@@ -127,6 +128,7 @@ res_init(void) {
 	if (!_res.id)
 		_res.id = res_randomid();
 
+	__A_VARIABLE = 1;
 	return (__res_vinit(&_res, 1));
 }
 #endif
@@ -134,20 +136,25 @@ res_init(void) {
 void
 p_query(const u_char *msg) {
 	fp_query(msg, stdout);
+	__A_VARIABLE = 1;
 }
 
 void
 fp_query(const u_char *msg, FILE *file) {
 	fp_nquery(msg, PACKETSZ, file);
+	__A_VARIABLE = 1;
 }
 libresolv_hidden_def (fp_query)
 
 void
 fp_nquery(const u_char *msg, int len, FILE *file) {
-	if (__res_maybe_init (&_res, 0) == -1)
+	if (__res_maybe_init (&_res, 0) == -1) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	res_pquery(&_res, msg, len, file);
+	__A_VARIABLE = 1;
 }
 libresolv_hidden_def (fp_nquery)
 
@@ -163,8 +170,10 @@ res_mkquery(int op,			/* opcode of query */
 {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (res_nmkquery(&_res, op, dname, class, type,
 			     data, datalen,
 			     newrr_in, buf, buflen));
@@ -175,9 +184,11 @@ int
 res_mkupdate(ns_updrec *rrecp_in, u_char *buf, int buflen) {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nmkupdate(&_res, rrecp_in, buf, buflen));
 }
 #endif
@@ -190,23 +201,28 @@ res_query(const char *name,	/* domain name */
 {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (res_nquery(&_res, name, class, type, answer, anslen));
 }
 
 void
 res_send_setqhook(res_send_qhook hook) {
 	_res.qhook = hook;
+	__A_VARIABLE = 1;
 }
 
 void
 res_send_setrhook(res_send_rhook hook) {
 	_res.rhook = hook;
+	__A_VARIABLE = 1;
 }
 
 int
 res_isourserver(const struct sockaddr_in *inp) {
+	__A_VARIABLE = 1;
 	return (res_ourserver_p(&_res, (const struct sockaddr_in6 *) inp));
 }
 
@@ -214,9 +230,11 @@ int
 res_send(const u_char *buf, int buflen, u_char *ans, int anssiz) {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		/* errno should have been set by res_init() in this case. */
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nsend(&_res, buf, buflen, ans, anssiz));
 }
 
@@ -227,9 +245,11 @@ res_sendsigned(const u_char *buf, int buflen, ns_tsig_key *key,
 {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		/* errno should have been set by res_init() in this case. */
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nsendsigned(&_res, buf, buflen, key, ans, anssiz));
 }
 #endif
@@ -255,9 +275,11 @@ int
 res_update(ns_updrec *rrecp_in) {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nupdate(&_res, rrecp_in, NULL));
 }
 #endif
@@ -270,9 +292,11 @@ res_search(const char *name,	/* domain name */
 {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nsearch(&_res, name, class, type, answer, anslen));
 }
 
@@ -285,9 +309,11 @@ res_querydomain(const char *name,
 {
 	if (__res_maybe_init (&_res, 1) == -1) {
 		RES_SET_H_ERRNO(&_res, NETDB_INTERNAL);
+		__A_VARIABLE = 1;
 		return (-1);
 	}
 
+	__A_VARIABLE = 1;
 	return (res_nquerydomain(&_res, name, domain,
 				 class, type,
 				 answer, anslen));
@@ -297,6 +323,7 @@ const char *
 hostalias(const char *name) {
 	static char abuf[MAXDNAME];
 
+	__A_VARIABLE = 1;
 	return (res_hostalias(&_res, name, abuf, sizeof abuf));
 }
 libresolv_hidden_def (hostalias)
@@ -312,8 +339,11 @@ local_hostname_length(const char *hostname) {
 	len_domain = strlen(_res.defdname);
 	if (len_host > len_domain &&
 	    !strcasecmp(hostname + len_host - len_domain, _res.defdname) &&
-	    hostname[len_host - len_domain - 1] == '.')
+	    hostname[len_host - len_domain - 1] == '.') {
+		__A_VARIABLE = 1;
 		return (len_host - len_domain - 1);
+	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 #endif /*ultrix*/
diff --git a/newlib/libc/sys/linux/net/res_debug.c b/newlib/libc/sys/linux/net/res_debug.c
index cd50fe5..9256e2c 100644
--- a/newlib/libc/sys/linux/net/res_debug.c
+++ b/newlib/libc/sys/linux/net/res_debug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985
  *    The Regents of the University of California.  All rights reserved.
@@ -133,6 +134,7 @@ fp_resstat(const res_state statp, FILE *file) {
 		if (statp->options & mask)
 			fprintf(file, " %s", p_option(mask));
 	putc('\n', file);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -221,6 +223,7 @@ res_pquery(const res_state statp, const u_char *msg, int len, FILE *file) {
 
 	if (ns_initparse(msg, len, &handle) < 0) {
 		fprintf(file, ";; ns_initparse: %s\n", strerror(errno));
+		__A_VARIABLE = 1;
 		return;
 	}
 	opcode = ns_msg_getflag(handle, ns_f_opcode);
@@ -283,6 +286,7 @@ res_pquery(const res_state statp, const u_char *msg, int len, FILE *file) {
 	if (qdcount == 0 && ancount == 0 &&
 	    nscount == 0 && arcount == 0)
 		putc('\n', file);
+	__A_VARIABLE = 1;
 }
 
 const u_char *
@@ -290,18 +294,22 @@ p_cdnname(const u_char *cp, const u_char *msg, int len, FILE *file) {
 	char name[MAXDNAME];
 	int n;
 
-	if ((n = dn_expand(msg, msg + len, cp, name, sizeof name)) < 0)
+	if ((n = dn_expand(msg, msg + len, cp, name, sizeof name)) < 0) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	if (name[0] == '\0')
 		putc('.', file);
 	else
 		fputs(name, file);
+	__A_VARIABLE = 1;
 	return (cp + n);
 }
 libresolv_hidden_def (p_cdnname)
 
 const u_char *
 p_cdname(const u_char *cp, const u_char *msg, FILE *file) {
+	__A_VARIABLE = 1;
 	return (p_cdnname(cp, msg, PACKETSZ, file));
 }
 
@@ -338,9 +346,12 @@ p_fqname(const u_char *cp, const u_char *msg, FILE *file) {
 	const u_char *n;
 
 	n = p_fqnname(cp, msg, MAXCDNAME, name, sizeof name);
-	if (n == NULL)
+	if (n == NULL) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	fputs(name, file);
+	__A_VARIABLE = 1;
 	return (n);
 }
 
@@ -483,11 +494,13 @@ sym_ston(const struct res_sym *syms, const char *name, int *success) {
 		if (strcasecmp (name, syms->name) == 0) {
 			if (success)
 				*success = 1;
+			__A_VARIABLE = 1;
 			return (syms->number);
 		}
 	}
 	if (success)
 		*success = 0;
+	__A_VARIABLE = 1;
 	return (syms->number);		/* The default value. */
 }
 
@@ -532,6 +545,7 @@ sym_ntop(const struct res_sym *syms, int number, int *success) {
  */
 const char *
 p_type(int type) {
+	__A_VARIABLE = 1;
 	return (sym_ntos(__p_type_syms, type, (int *)0));
 }
 libresolv_hidden_def (p_type)
@@ -551,6 +565,7 @@ p_section(int section, int opcode) {
 		symbols = __p_default_section_syms;
 		break;
 	}
+	__A_VARIABLE = 1;
 	return (sym_ntos(symbols, section, (int *)0));
 }
 
@@ -559,6 +574,7 @@ p_section(int section, int opcode) {
  */
 const char *
 p_class(int class) {
+	__A_VARIABLE = 1;
 	return (sym_ntos(__p_class_syms, class, (int *)0));
 }
 libresolv_hidden_def (p_class)
@@ -611,6 +627,7 @@ p_time(u_int32_t value) {
  */
 const char *
 p_rcode(int rcode) {
+	__A_VARIABLE = 1;
 	return (sym_ntos(__p_rcode_syms, rcode, (int *)0));
 }
 libresolv_hidden_def (p_rcode)
@@ -682,6 +699,7 @@ precsize_aton(strptr)
 
 	*strptr = cp;
 
+	__A_VARIABLE = 1;
 	return (retval);
 }
 
@@ -780,6 +798,7 @@ latlon2ul(latlonstrptr,which)
 
 	*latlonstrptr = cp;
 
+	__A_VARIABLE = 1;
 	return (retval);
 }
 
@@ -1027,6 +1046,7 @@ dn_count_labels(const char *name) {
 	/* count to include last label */
 	if (len > 0 && name[len-1] != '.')
 		count++;
+	__A_VARIABLE = 1;
 	return (count);
 }
 
diff --git a/newlib/libc/sys/linux/net/res_hconf.c b/newlib/libc/sys/linux/net/res_hconf.c
index ad15940..856dcd2 100644
--- a/newlib/libc/sys/linux/net/res_hconf.c
+++ b/newlib/libc/sys/linux/net/res_hconf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1993, 1995-2003, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by David Mosberger (davidm@azstarnet.com).
@@ -94,6 +95,7 @@ static const char *
 skip_ws (const char *str)
 {
   while (isspace (*str)) ++str;
+  __A_VARIABLE = 1;
   return str;
 }
 
@@ -104,6 +106,7 @@ skip_string (const char *str)
 {
   while (*str && !isspace (*str) && *str != '#' && *str != ',')
     ++str;
+  __A_VARIABLE = 1;
   return str;
 }
 
@@ -149,8 +152,10 @@ arg_service_list (const char *fname, int line_num, const char *args,
 
 	  if (asprintf (&buf,
 			  _("%s: line %d: expected service, found `%s'\n"),
-			  fname, line_num, start) < 0)
+			  fname, line_num, start) < 0) {
+	    __A_VARIABLE = 1;
 	    return 0;
+	  }
 
 #ifdef USE_IN_LIBIO
 	  if (_IO_fwide (stderr, 0) > 0)
@@ -160,6 +165,7 @@ arg_service_list (const char *fname, int line_num, const char *args,
 	    fputs (buf, stderr);
 
 	  free (buf);
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
       if (_res_hconf.num_services >= SERVICE_MAX)
@@ -168,8 +174,10 @@ arg_service_list (const char *fname, int line_num, const char *args,
 
 	  if (asprintf (&buf, _("\
 %s: line %d: cannot specify more than %d services"),
-			  fname, line_num, SERVICE_MAX) < 0)
+			  fname, line_num, SERVICE_MAX) < 0) {
+	    __A_VARIABLE = 1;
 	    return 0;
+	  }
 
 #ifdef USE_IN_LIBIO
 	  if (_IO_fwide (stderr, 0) > 0)
@@ -179,6 +187,7 @@ arg_service_list (const char *fname, int line_num, const char *args,
 	    fputs (buf, stderr);
 
 	  free (buf);
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
       _res_hconf.service[_res_hconf.num_services++] = service;
@@ -196,8 +205,10 @@ arg_service_list (const char *fname, int line_num, const char *args,
 
 	      if (asprintf (&buf, _("\
 %s: line %d: list delimiter not followed by keyword"),
-			      fname, line_num) < 0)
+			      fname, line_num) < 0) {
+		__A_VARIABLE = 1;
 		return 0;
+	      }
 
 #ifdef USE_IN_LIBIO
 	      if (_IO_fwide (stderr, 0) > 0)
@@ -207,6 +218,7 @@ arg_service_list (const char *fname, int line_num, const char *args,
 		fputs (buf, stderr);
 
 	      free (buf);
+	      __A_VARIABLE = 1;
 	      return 0;
 	    }
 	default:
@@ -214,6 +226,7 @@ arg_service_list (const char *fname, int line_num, const char *args,
 	}
     }
   while (*args && *args != '#');
+  __A_VARIABLE = 1;
   return args;
 }
 
@@ -237,8 +250,10 @@ arg_trimdomain_list (const char *fname, int line_num, const char *args,
 
 	  if (asprintf (&buf, _("\
 %s: line %d: cannot specify more than %d trim domains"),
-			  fname, line_num, TRIMDOMAINS_MAX) < 0)
+			  fname, line_num, TRIMDOMAINS_MAX) < 0) {
+	    __A_VARIABLE = 1;
 	    return 0;
+	      }
 
 #ifdef USE_IN_LIBIO
 	      if (_IO_fwide (stderr, 0) > 0)
@@ -248,6 +263,7 @@ arg_trimdomain_list (const char *fname, int line_num, const char *args,
 		fputs (buf, stderr);
 
 	      free (buf);
+	  __A_VARIABLE = 1;
 	  return 0;
 	}
       _res_hconf.trimdomain[_res_hconf.num_trimdomains++] =
@@ -263,8 +279,10 @@ arg_trimdomain_list (const char *fname, int line_num, const char *args,
 
 	      if (asprintf (&buf, _("\
 %s: line %d: list delimiter not followed by domain"),
-			      fname, line_num) < 0)
+			      fname, line_num) < 0) {
+		__A_VARIABLE = 1;
 		return 0;
+	      }
 
 #ifdef USE_IN_LIBIO
 	      if (_IO_fwide (stderr, 0) > 0)
@@ -274,6 +292,7 @@ arg_trimdomain_list (const char *fname, int line_num, const char *args,
 		fputs (buf, stderr);
 
 	      free (buf);
+	      __A_VARIABLE = 1;
 	      return 0;
 	    }
 	default:
@@ -281,6 +300,7 @@ arg_trimdomain_list (const char *fname, int line_num, const char *args,
 	}
     }
   while (*args && *args != '#');
+  __A_VARIABLE = 1;
   return args;
 }
 
@@ -303,6 +323,7 @@ arg_spoof (const char *fname, int line_num, const char *args, unsigned flag)
 	  || !(len == 4 && strncasecmp (start, "warn", len) == 0))
 	_res_hconf.flags &= ~HCONF_FLAG_SPOOFALERT;
     }
+  __A_VARIABLE = 1;
   return args;
 }
 
@@ -354,7 +375,10 @@ parse_line (const char *fname, int line_num, const char *str)
   str = skip_ws (str);
 
   /* skip line comment and empty lines: */
-  if (*str == '\0' || *str == '#') return;
+  if (*str == '\0' || *str == '#') {
+      __A_VARIABLE = 1;
+      return;
+  }
 
   start = str;
   str = skip_string (str);
@@ -374,8 +398,10 @@ parse_line (const char *fname, int line_num, const char *str)
       char *buf;
 
       if (asprintf (&buf, _("%s: line %d: bad command `%s'\n"),
-		      fname, line_num, start) < 0)
+		      fname, line_num, start) < 0) {
+	__A_VARIABLE = 1;
 	return;
+      }
 
 #ifdef USE_IN_LIBIO
       if (_IO_fwide (stderr, 0) > 0)
@@ -385,14 +411,17 @@ parse_line (const char *fname, int line_num, const char *str)
 	fputs (buf, stderr);
 
       free (buf);
+      __A_VARIABLE = 1;
       return;
     }
 
   /* process args: */
   str = skip_ws (str);
   str = (*c->parse_args) (fname, line_num, str, c->arg);
-  if (!str)
+  if (!str) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   /* rest of line must contain white space or comment only: */
   while (*str)
@@ -420,6 +449,7 @@ parse_line (const char *fname, int line_num, const char *str)
       }
       ++str;
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -489,6 +519,7 @@ do_init (void)
     }
 
   _res_hconf.initialized = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -500,6 +531,7 @@ _res_hconf_init (void)
   __libc_once_define (static, once);
 
   __libc_once (once, do_init);
+  __A_VARIABLE = 1;
 }
 
 
@@ -657,6 +689,7 @@ _res_hconf_trim_domain (char *hostname)
 	  break;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -667,10 +700,13 @@ _res_hconf_trim_domains (struct hostent *hp)
 {
   int i;
 
-  if (_res_hconf.num_trimdomains == 0)
+  if (_res_hconf.num_trimdomains == 0) {
+    __A_VARIABLE = 1;
     return;
+  }
 
   _res_hconf_trim_domain (hp->h_name);
   for (i = 0; hp->h_aliases[i]; ++i)
     _res_hconf_trim_domain (hp->h_aliases[i]);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/res_init.c b/newlib/libc/sys/linux/net/res_init.c
index 81b06e7..f6a98e8 100644
--- a/newlib/libc/sys/linux/net/res_init.c
+++ b/newlib/libc/sys/linux/net/res_init.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985, 1989, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -140,6 +141,7 @@ int
 res_ninit(res_state statp) {
 	extern int __res_vinit(res_state, int);
 
+	__A_VARIABLE = 1;
 	return (__res_vinit(statp, 0));
 }
 #ifdef _LIBC
@@ -445,6 +447,7 @@ __res_vinit(res_state statp, int preinit) {
 	if ((cp = getenv("RES_OPTIONS")) != NULL)
 		res_setoptions(statp, cp, "env");
 	statp->options |= RES_INIT;
+	__A_VARIABLE = 1;
 	return (0);
 }
 
@@ -518,6 +521,7 @@ res_setoptions(res_state statp, const char *options, const char *source) {
 		while (*cp && *cp != ' ' && *cp != '\t')
 			cp++;
 	}
+	__A_VARIABLE = 1;
 }
 
 #ifdef RESOLVSORT
@@ -541,6 +545,7 @@ res_randomid(void) {
 	struct timeval now;
 
 	gettimeofday(&now, NULL);
+	__A_VARIABLE = 1;
 	return (0xffff & (now.tv_sec ^ now.tv_usec ^ getpid()));
 }
 #ifdef _LIBC
@@ -575,6 +580,7 @@ res_nclose(res_state statp) {
 			statp->_u._ext.nssocks[ns] = -1;
 		}
 	statp->_u._ext.nsinit = 0;
+	__A_VARIABLE = 1;
 }
 #ifdef _LIBC
 libc_hidden_def (__res_nclose)
diff --git a/newlib/libc/sys/linux/net/res_libc.c b/newlib/libc/sys/linux/net/res_libc.c
index 739a51f..a6370ba 100644
--- a/newlib/libc/sys/linux/net/res_libc.c
+++ b/newlib/libc/sys/linux/net/res_libc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1995-1999 by Internet Software Consortium.
  *
@@ -95,6 +96,7 @@ res_init(void) {
 	atomicinc (__res_initstamp);
 	atomicincunlock (lock);
 
+	__A_VARIABLE = 1;
 	return (__res_vinit(&_res, 1));
 }
 
diff --git a/newlib/libc/sys/linux/net/res_mkquery.c b/newlib/libc/sys/linux/net/res_mkquery.c
index fa1ccd8..a103152 100644
--- a/newlib/libc/sys/linux/net/res_mkquery.c
+++ b/newlib/libc/sys/linux/net/res_mkquery.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -118,8 +119,10 @@ res_nmkquery(res_state statp,
 	/*
 	 * Initialize header fields.
 	 */
-	if ((buf == NULL) || (buflen < HFIXEDSZ))
+	if ((buf == NULL) || (buflen < HFIXEDSZ)) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	memset(buf, 0, HFIXEDSZ);
 	hp = (HEADER *) buf;
 	/* We randomize the IDs every time.  The old code just
@@ -159,10 +162,14 @@ res_nmkquery(res_state statp,
 	switch (op) {
 	case QUERY:	/*FALLTHROUGH*/
 	case NS_NOTIFY_OP:
-		if ((buflen -= QFIXEDSZ) < 0)
+		if ((buflen -= QFIXEDSZ) < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
-		if ((n = dn_comp(dname, cp, buflen, dnptrs, lastdnptr)) < 0)
+		}
+		if ((n = dn_comp(dname, cp, buflen, dnptrs, lastdnptr)) < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		cp += n;
 		buflen -= n;
 		__putshort(type, cp);
@@ -177,8 +184,10 @@ res_nmkquery(res_state statp,
 		 */
 		buflen -= RRFIXEDSZ;
 		n = dn_comp((char *)data, cp, buflen, dnptrs, lastdnptr);
-		if (n < 0)
+		if (n < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		cp += n;
 		buflen -= n;
 		__putshort(T_NULL, cp);
@@ -196,8 +205,10 @@ res_nmkquery(res_state statp,
 		/*
 		 * Initialize answer section
 		 */
-		if (buflen < 1 + RRFIXEDSZ + datalen)
+		if (buflen < 1 + RRFIXEDSZ + datalen) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		*cp++ = '\0';	/* no domain name */
 		__putshort(type, cp);
 		cp += INT16SZ;
@@ -215,8 +226,10 @@ res_nmkquery(res_state statp,
 		break;
 
 	default:
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (cp - buf);
 }
 libresolv_hidden_def (res_nmkquery)
diff --git a/newlib/libc/sys/linux/net/res_query.c b/newlib/libc/sys/linux/net/res_query.c
index fcb624e..cc61a89 100644
--- a/newlib/libc/sys/linux/net/res_query.c
+++ b/newlib/libc/sys/linux/net/res_query.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1988, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -150,6 +151,7 @@ __libc_res_nquery(res_state statp,
 		RES_SET_H_ERRNO(statp, NO_RECOVERY);
 		if (use_malloc)
 			free (buf);
+		__A_VARIABLE = 1;
 		return (n);
 	}
 	n = __libc_res_nsend(statp, buf, n, answer, anslen, answerp);
@@ -161,6 +163,7 @@ __libc_res_nquery(res_state statp,
 			printf(";; res_query: send error\n");
 #endif
 		RES_SET_H_ERRNO(statp, TRY_AGAIN);
+		__A_VARIABLE = 1;
 		return (n);
 	}
 
@@ -187,8 +190,10 @@ __libc_res_nquery(res_state statp,
 			RES_SET_H_ERRNO(statp, NO_RECOVERY);
 			break;
 		}
+		__A_VARIABLE = 1;
 		return (-1);
 	}
+	__A_VARIABLE = 1;
 	return (n);
 }
 libresolv_hidden_def (__libc_res_nquery)
@@ -200,6 +205,7 @@ res_nquery(res_state statp,
 	   u_char *answer,	/* buffer to put answer */
 	   int anslen)		/* size of answer buffer */
 {
+	__A_VARIABLE = 1;
 	return __libc_res_nquery(statp, name, class, type, answer, anslen,
 				 NULL);
 }
@@ -238,9 +244,11 @@ __libc_res_nsearch(res_state statp,
 		trailing_dot++;
 
 	/* If there aren't any dots, it could be a user-level alias. */
-	if (!dots && (cp = res_hostalias(statp, name, tmp, sizeof tmp))!= NULL)
+	if (!dots && (cp = res_hostalias(statp, name, tmp, sizeof tmp))!= NULL) {
+		__A_VARIABLE = 1;
 		return (__libc_res_nquery(statp, cp, class, type, answer,
 					  anslen, answerp));
+	}
 
 #ifdef DEBUG
 	if (statp->options & RES_DEBUG)
@@ -257,8 +265,10 @@ __libc_res_nsearch(res_state statp,
 	if (dots >= statp->ndots || trailing_dot) {
 		ret = __libc_res_nquerydomain(statp, name, NULL, class, type,
 					      answer, anslen, answerp);
-		if (ret > 0 || trailing_dot)
+		if (ret > 0 || trailing_dot) {
+			__A_VARIABLE = 1;
 			return (ret);
+		}
 		saved_herrno = h_errno;
 		tried_as_is++;
 		if (answerp && *answerp != answer) {
@@ -288,8 +298,10 @@ __libc_res_nsearch(res_state statp,
 			ret = __libc_res_nquerydomain(statp, name, *domain,
 						      class, type,
 						      answer, anslen, answerp);
-			if (ret > 0)
+			if (ret > 0) {
+				__A_VARIABLE = 1;
 				return (ret);
+			}
 
 			if (answerp && *answerp != answer) {
 				answer = *answerp;
@@ -311,6 +323,7 @@ __libc_res_nsearch(res_state statp,
 			 */
 			if (errno == ECONNREFUSED) {
 				RES_SET_H_ERRNO(statp, TRY_AGAIN);
+				__A_VARIABLE = 1;
 				return (-1);
 			}
 
@@ -349,8 +362,10 @@ __libc_res_nsearch(res_state statp,
 	if (dots && !(tried_as_is || root_on_list)) {
 		ret = __libc_res_nquerydomain(statp, name, NULL, class, type,
 					      answer, anslen, answerp);
-		if (ret > 0)
+		if (ret > 0) {
+			__A_VARIABLE = 1;
 			return (ret);
+		}
 	}
 
 	/* if we got here, we didn't satisfy the search.
@@ -366,6 +381,7 @@ __libc_res_nsearch(res_state statp,
 		RES_SET_H_ERRNO(statp, NO_DATA);
 	else if (got_servfail)
 		RES_SET_H_ERRNO(statp, TRY_AGAIN);
+	__A_VARIABLE = 1;
 	return (-1);
 }
 libresolv_hidden_def (__libc_res_nsearch)
@@ -377,6 +393,7 @@ res_nsearch(res_state statp,
 	    u_char *answer,	/* buffer to put answer */
 	    int anslen)		/* size of answer */
 {
+	__A_VARIABLE = 1;
 	return __libc_res_nsearch(statp, name, class, type, answer,
 				  anslen, NULL);
 }
@@ -441,6 +458,7 @@ res_nquerydomain(res_state statp,
 	    u_char *answer,		/* buffer to put answer */
 	    int anslen)		/* size of answer */
 {
+	__A_VARIABLE = 1;
 	return __libc_res_nquerydomain(statp, name, domain, class, type,
 				       answer, anslen, NULL);
 }
@@ -452,11 +470,15 @@ res_hostalias(const res_state statp, const char *name, char *dst, size_t siz) {
 	char buf[BUFSIZ];
 	FILE *fp;
 
-	if (statp->options & RES_NOALIASES)
+	if (statp->options & RES_NOALIASES) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	file = getenv("HOSTALIASES");
-	if (file == NULL || (fp = fopen(file, "r")) == NULL)
+	if (file == NULL || (fp = fopen(file, "r")) == NULL) {
+		__A_VARIABLE = 1;
 		return (NULL);
+	}
 	setbuf(fp, NULL);
 	buf[sizeof(buf) - 1] = '\0';
 	while (fgets(buf, sizeof(buf), fp)) {
@@ -476,10 +498,12 @@ res_hostalias(const res_state statp, const char *name, char *dst, size_t siz) {
 			strncpy(dst, cp1, siz - 1);
 			dst[siz - 1] = '\0';
 			fclose(fp);
+			__A_VARIABLE = 1;
 			return (dst);
 		}
 	}
 	fclose(fp);
+	__A_VARIABLE = 1;
 	return (NULL);
 }
 libresolv_hidden_def (res_hostalias)
diff --git a/newlib/libc/sys/linux/net/res_send.c b/newlib/libc/sys/linux/net/res_send.c
index 5c2bcf7..6494c6e 100644
--- a/newlib/libc/sys/linux/net/res_send.c
+++ b/newlib/libc/sys/linux/net/res_send.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985, 1989, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -113,6 +114,7 @@ evConsIovec(void *buf, size_t cnt, struct iovec *vec) {
 	memset(vec, 0xf5, sizeof (*vec));
 	vec->iov_base = buf;
 	vec->iov_len = cnt;
+	__A_VARIABLE = 1;
 }
 
 /* From ev_timers.c.  */
@@ -123,6 +125,7 @@ static inline void
 evConsTime(struct timespec *res, time_t sec, long nsec) {
 	res->tv_sec = sec;
 	res->tv_nsec = nsec;
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -134,6 +137,7 @@ evAddTime(struct timespec *res, const struct timespec *addend1,
 		res->tv_sec++;
 		res->tv_nsec -= BILLION;
 	}
+	__A_VARIABLE = 1;
 }
 
 static inline void
@@ -147,6 +151,7 @@ evSubTime(struct timespec *res, const struct timespec *minuend,
 				- subtrahend->tv_nsec + minuend->tv_nsec);
 		res->tv_sec--;
 	}
+	__A_VARIABLE = 1;
 }
 
 static inline int
@@ -155,6 +160,7 @@ evCmpTime(struct timespec a, struct timespec b) {
 
 	if (x == 0L)
 		x = a.tv_nsec - b.tv_nsec;
+	__A_VARIABLE = 1;
 	return (x < 0L ? (-1) : x > 0L ? (1) : (0));
 }
 
@@ -166,6 +172,7 @@ evNowTime(struct timespec *res) {
 		evConsTime(res, 0, 0);
 	else
 		TIMEVAL_TO_TIMESPEC (&now, res);
+	__A_VARIABLE = 1;
 }
 
 
@@ -264,17 +271,24 @@ res_nameinquery(const char *name, int type, int class,
 		int n, ttype, tclass;
 
 		n = dn_expand(buf, eom, cp, tname, sizeof tname);
-		if (n < 0)
+		if (n < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		cp += n;
-		if (cp + 2 * INT16SZ > eom)
+		if (cp + 2 * INT16SZ > eom) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		ttype = ns_get16(cp); cp += INT16SZ;
 		tclass = ns_get16(cp); cp += INT16SZ;
 		if (ttype == type && tclass == class &&
-		    ns_samename(tname, name) == 1)
+		    ns_samename(tname, name) == 1) {
+			__A_VARIABLE = 1;
 			return (1);
+		}
 	}
+	__A_VARIABLE = 1;
 	return (0);
 }
 libresolv_hidden_def (res_nameinquery)
@@ -297,34 +311,47 @@ res_queriesmatch(const u_char *buf1, const u_char *eom1,
 	const u_char *cp = buf1 + HFIXEDSZ;
 	int qdcount = ntohs(((HEADER*)buf1)->qdcount);
 
-	if (buf1 + HFIXEDSZ > eom1 || buf2 + HFIXEDSZ > eom2)
+	if (buf1 + HFIXEDSZ > eom1 || buf2 + HFIXEDSZ > eom2) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 
 	/*
 	 * Only header section present in replies to
 	 * dynamic update packets.
 	 */
 	if ((((HEADER *)buf1)->opcode == ns_o_update) &&
-	    (((HEADER *)buf2)->opcode == ns_o_update))
+	    (((HEADER *)buf2)->opcode == ns_o_update)) {
+		__A_VARIABLE = 1;
 		return (1);
+	}
 
-	if (qdcount != ntohs(((HEADER*)buf2)->qdcount))
+	if (qdcount != ntohs(((HEADER*)buf2)->qdcount)) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	while (qdcount-- > 0) {
 		char tname[MAXDNAME+1];
 		int n, ttype, tclass;
 
 		n = dn_expand(buf1, eom1, cp, tname, sizeof tname);
-		if (n < 0)
+		if (n < 0) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		cp += n;
-		if (cp + 2 * INT16SZ > eom1)
+		if (cp + 2 * INT16SZ > eom1) {
+			__A_VARIABLE = 1;
 			return (-1);
+		}
 		ttype = ns_get16(cp);	cp += INT16SZ;
 		tclass = ns_get16(cp); cp += INT16SZ;
-		if (!res_nameinquery(tname, ttype, tclass, buf2, eom2))
+		if (!res_nameinquery(tname, ttype, tclass, buf2, eom2)) {
+			__A_VARIABLE = 1;
 			return (0);
+		}
 	}
+	__A_VARIABLE = 1;
 	return (1);
 }
 libresolv_hidden_def (res_queriesmatch)
@@ -606,6 +633,7 @@ int
 res_nsend(res_state statp,
 	  const u_char *buf, int buflen, u_char *ans, int anssiz)
 {
+	__A_VARIABLE = 1;
 	return __libc_res_nsend(statp, buf, buflen, ans, anssiz, NULL);
 }
 libresolv_hidden_def (res_nsend)
@@ -1059,6 +1087,7 @@ Aerror(const res_state statp, FILE *file, const char *string, int error,
 			strerror(error));
 	}
 	__set_errno (save);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1069,6 +1098,7 @@ Perror(const res_state statp, FILE *file, const char *string, int error) {
 		fprintf(file, "res_send: %s: %s\n",
 			string, strerror(error));
 	__set_errno (save);
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -1113,4 +1143,5 @@ convaddr4to6(struct sockaddr_in6 *sa)
     sa->sin6_addr.s6_addr32[1] = 0;
     sa->sin6_addr.s6_addr32[2] = htonl(0xFFFF);
     sa->sin6_addr.s6_addr32[3] = addr;
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/net/rexec.c b/newlib/libc/sys/linux/net/rexec.c
index f6ae42d..4107c0e 100644
--- a/newlib/libc/sys/linux/net/rexec.c
+++ b/newlib/libc/sys/linux/net/rexec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1980, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -198,5 +199,6 @@ rexec(ahost, rport, name, pass, cmd, fd2p)
 	const char *name, *pass, *cmd;
 	int *fd2p;
 {
+	__A_VARIABLE = 1;
 	return rexec_af(ahost, rport, name, pass, cmd, fd2p, AF_INET);
 }
diff --git a/newlib/libc/sys/linux/net/rpc-lookup.c b/newlib/libc/sys/linux/net/rpc-lookup.c
index 2de497c..4b98a77 100644
--- a/newlib/libc/sys/linux/net/rpc-lookup.c
+++ b/newlib/libc/sys/linux/net/rpc-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/ruserpass.c b/newlib/libc/sys/linux/net/ruserpass.c
index 5c429b0..72b4a76 100644
--- a/newlib/libc/sys/linux/net/ruserpass.c
+++ b/newlib/libc/sys/linux/net/ruserpass.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1985, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
@@ -111,6 +112,7 @@ ruserpass(host, aname, apass)
 		   which is no improvement. This really should call
 		   getpwuid(getuid()).  */
 		/*hdir = ".";*/
+	  	__A_VARIABLE = 1;
 	  	return -1;
 	}
 
@@ -123,6 +125,7 @@ ruserpass(host, aname, apass)
 			char *t = asprintf("%s", buf);
 			perror(t);
 		}
+		__A_VARIABLE = 1;
 		return (0);
 	}
 	/* No threads use this stream.  */
@@ -289,9 +292,11 @@ next:
 	}
 done:
 	(void) fclose(cfile);
+	__A_VARIABLE = 1;
 	return (0);
 bad:
 	(void) fclose(cfile);
+	__A_VARIABLE = 1;
 	return (-1);
 }
 libc_hidden_def (ruserpass)
@@ -303,13 +308,17 @@ token()
 	int c;
 	int i;
 
-	if (feof(cfile) || ferror(cfile))
+	if (feof(cfile) || ferror(cfile)) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	while ((c = getc_unlocked(cfile)) != EOF &&
 	    (c == '\n' || c == '\t' || c == ' ' || c == ','))
 		continue;
-	if (c == EOF)
+	if (c == EOF) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	cp = tokval;
 	if (c == '"') {
 		while ((c = getc_unlocked(cfile)) != EOF && c != '"') {
@@ -327,10 +336,15 @@ token()
 		}
 	}
 	*cp = 0;
-	if (tokval[0] == 0)
+	if (tokval[0] == 0) {
+		__A_VARIABLE = 1;
 		return (0);
+	}
 	for (i = 0; i < (int) (sizeof (toktab) / sizeof (toktab[0])); ++i)
-		if (!strcmp(&tokstr[toktab[i].tokstr_off], tokval))
+		if (!strcmp(&tokstr[toktab[i].tokstr_off], tokval)) {
+			__A_VARIABLE = 1;
 			return toktab[i].tval;
+		}
+	__A_VARIABLE = 1;
 	return (ID);
 }
diff --git a/newlib/libc/sys/linux/net/send.c b/newlib/libc/sys/linux/net/send.c
index 658c92b..2cf73b9 100644
--- a/newlib/libc/sys/linux/net/send.c
+++ b/newlib/libc/sys/linux/net/send.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1988, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -49,5 +50,6 @@ send(s, msg, len, flags)
 	size_t len;
 	const void *msg;
 {
+	__A_VARIABLE = 1;
 	return (sendto(s, msg, len, flags, NULL, 0));
 }
diff --git a/newlib/libc/sys/linux/net/service-lookup.c b/newlib/libc/sys/linux/net/service-lookup.c
index 67d401e..148ff9f 100644
--- a/newlib/libc/sys/linux/net/service-lookup.c
+++ b/newlib/libc/sys/linux/net/service-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/net/spwd-lookup.c b/newlib/libc/sys/linux/net/spwd-lookup.c
index 40c2f61..8a84ac1 100644
--- a/newlib/libc/sys/linux/net/spwd-lookup.c
+++ b/newlib/libc/sys/linux/net/spwd-lookup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1996 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
diff --git a/newlib/libc/sys/linux/ntp_gettime.c b/newlib/libc/sys/linux/ntp_gettime.c
index 2bcabbc..92d5e5d 100644
--- a/newlib/libc/sys/linux/ntp_gettime.c
+++ b/newlib/libc/sys/linux/ntp_gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -34,5 +35,6 @@ ntp_gettime (ntv)
   ntv->time = tntx.time;
   ntv->maxerror = tntx.maxerror;
   ntv->esterror = tntx.esterror;
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/sys/linux/pathconf.c b/newlib/libc/sys/linux/pathconf.c
index 7969459..5ab6a51 100644
--- a/newlib/libc/sys/linux/pathconf.c
+++ b/newlib/libc/sys/linux/pathconf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linux specific extensions to pathconf.
    Copyright (C) 1991,95,96,98,99,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -49,49 +50,62 @@ __pathconf (path, name)
       /* Determine the filesystem type.  */
       if (__statfs (path, &fsbuf) < 0)
 	{
-	  if (errno == ENOSYS)
+	  if (errno == ENOSYS) {
 	    /* not possible, return the default value.  */
+	    __A_VARIABLE = 1;
 	    return LINUX_LINK_MAX;
+          }
 
 	  /* Some error occured.  */
+          __A_VARIABLE = 1;
           return -1;
 	}
 
       switch (fsbuf.f_type)
 	{
 	case EXT2_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return EXT2_LINK_MAX;
 
 	case MINIX_SUPER_MAGIC:
 	case MINIX_SUPER_MAGIC2:
+	  __A_VARIABLE = 1;
 	  return MINIX_LINK_MAX;
 
 	case MINIX2_SUPER_MAGIC:
 	case MINIX2_SUPER_MAGIC2:
+	  __A_VARIABLE = 1;
 	  return MINIX2_LINK_MAX;
 
 	case XENIX_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return XENIX_LINK_MAX;
 
 	case SYSV4_SUPER_MAGIC:
 	case SYSV2_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return SYSV_LINK_MAX;
 
 	case COH_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return COH_LINK_MAX;
 
 	case UFS_MAGIC:
 	case UFS_CIGAM:
+	  __A_VARIABLE = 1;
 	  return UFS_LINK_MAX;
 
 	case REISERFS_SUPER_MAGIC:
+	  __A_VARIABLE = 1;
 	  return REISERFS_LINK_MAX;
 
 	default:
+	  __A_VARIABLE = 1;
 	  return LINUX_LINK_MAX;
 	}
     }
 
+  __A_VARIABLE = 1;
   return posix_pathconf (path, name);
 }
 
diff --git a/newlib/libc/sys/linux/pread.c b/newlib/libc/sys/linux/pread.c
index ff8371e..da7d10c 100644
--- a/newlib/libc/sys/linux/pread.c
+++ b/newlib/libc/sys/linux/pread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linux version of pread so we can have a weak_alias */
 
 #include <_ansi.h>
@@ -16,17 +17,24 @@ _DEFUN (_pread_r, (rptr, fd, buf, n, off),
   off_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_read;
   
-  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1)
+  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_read = _read_r (rptr, fd, buf, n);
 
-  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_read;
 }
 
@@ -39,6 +47,7 @@ _DEFUN (__libc_pread, (fd, buf, n, off),
      size_t n _AND
      off_t off)
 {
+  __A_VARIABLE = 1;
   return _pread_r (_REENT, fd, buf, n, off);
 }
 weak_alias(__libc_pread,pread)
diff --git a/newlib/libc/sys/linux/pread64.c b/newlib/libc/sys/linux/pread64.c
index c4bdca7..af1cd1e 100644
--- a/newlib/libc/sys/linux/pread64.c
+++ b/newlib/libc/sys/linux/pread64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<pread64>>---read a large file from specified position
@@ -47,17 +48,24 @@ _DEFUN (__libc_pread64, (fd, buf, n, off),
   loff_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_read;
   
-  if ((cur_pos = lseek64 (fd, 0, SEEK_CUR)) == (loff_t)-1)
+  if ((cur_pos = lseek64 (fd, 0, SEEK_CUR)) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (lseek64 (fd, off, SEEK_SET) == (loff_t)-1)
+  if (lseek64 (fd, off, SEEK_SET) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_read = read (fd, buf, n);
 
-  if (lseek64 (fd, cur_pos, SEEK_SET) == (loff_t)-1)
+  if (lseek64 (fd, cur_pos, SEEK_SET) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_read;
 }
 weak_alias(__libc_pread64,pread64);
diff --git a/newlib/libc/sys/linux/process.c b/newlib/libc/sys/linux/process.c
index 160b801..4cbcfae 100644
--- a/newlib/libc/sys/linux/process.c
+++ b/newlib/libc/sys/linux/process.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/process.c - Process-related system calls */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/prof-freq.c b/newlib/libc/sys/linux/prof-freq.c
index 829979b..5a157da 100644
--- a/newlib/libc/sys/linux/prof-freq.c
+++ b/newlib/libc/sys/linux/prof-freq.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return frequency of ticks reported by profil.  Generic version. */
 /*-
  * Copyright (c) 1983, 1992, 1993
@@ -48,7 +49,10 @@ __profile_frequency (void)
   tim.it_value.tv_usec = 0;
   setitimer(ITIMER_REAL, &tim, 0);
   setitimer(ITIMER_REAL, 0, &tim);
-  if (tim.it_interval.tv_usec < 2)
+  if (tim.it_interval.tv_usec < 2) {
+    __A_VARIABLE = 1;
     return 0;
+  }
+  __A_VARIABLE = 1;
   return (1000000 / tim.it_interval.tv_usec);
 }
diff --git a/newlib/libc/sys/linux/profile.c b/newlib/libc/sys/linux/profile.c
index f36e2c7..7a7c887 100644
--- a/newlib/libc/sys/linux/profile.c
+++ b/newlib/libc/sys/linux/profile.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/profile.c - profiling system call */
 
 #include <errno.h>
diff --git a/newlib/libc/sys/linux/pvallocr.c b/newlib/libc/sys/linux/pvallocr.c
index 716ea0c..058f81e 100644
--- a/newlib/libc/sys/linux/pvallocr.c
+++ b/newlib/libc/sys/linux/pvallocr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void * 
 _pvalloc_r (struct _reent *ptr, size_t bytes)
 {
+  __A_VARIABLE = 1;
   return pvalloc (bytes);
 }
diff --git a/newlib/libc/sys/linux/pwrite.c b/newlib/libc/sys/linux/pwrite.c
index 239463e..2094451 100644
--- a/newlib/libc/sys/linux/pwrite.c
+++ b/newlib/libc/sys/linux/pwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linux version of pwrite so we can have a weak alias */
 
 #include <_ansi.h>
@@ -16,17 +17,24 @@ _DEFUN (_pwrite_r, (rptr, fd, buf, n, off),
   off_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_written;
   
-  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1)
+  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_written = _write_r (rptr, fd, buf, n);
 
-  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_written;
 }
 
@@ -39,6 +47,7 @@ _DEFUN (__libc_pwrite, (fd, buf, n, off),
      size_t n _AND
      off_t off)
 {
+  __A_VARIABLE = 1;
   return _pwrite_r (_REENT, fd, buf, n, off);
 }
 weak_alias(__libc_pwrite,pwrite)
diff --git a/newlib/libc/sys/linux/pwrite64.c b/newlib/libc/sys/linux/pwrite64.c
index f1d6784..a87010f 100644
--- a/newlib/libc/sys/linux/pwrite64.c
+++ b/newlib/libc/sys/linux/pwrite64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<pwrite64>>---write a large file from specified position
@@ -47,17 +48,24 @@ _DEFUN (__libc_pwrite64, (fd, buf, n, off),
   loff_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_written;
   
-  if ((cur_pos = lseek64 (fd, 0, SEEK_CUR)) == (loff_t)-1)
+  if ((cur_pos = lseek64 (fd, 0, SEEK_CUR)) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (lseek64 (fd, off, SEEK_SET) == (loff_t)-1)
+  if (lseek64 (fd, off, SEEK_SET) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_written = write (fd, buf, n);
 
-  if (lseek64 (fd, cur_pos, SEEK_SET) == (loff_t)-1)
+  if (lseek64 (fd, cur_pos, SEEK_SET) == (loff_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_written;
 }
 weak_alias(__libc_pwrite64,pwrite64)
diff --git a/newlib/libc/sys/linux/raise.c b/newlib/libc/sys/linux/raise.c
index d69561b..f422a08 100644
--- a/newlib/libc/sys/linux/raise.c
+++ b/newlib/libc/sys/linux/raise.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* empty file so we override regular raise */
 
 
diff --git a/newlib/libc/sys/linux/readdir64.c b/newlib/libc/sys/linux/readdir64.c
index 78fe98e..dad6eaf 100644
--- a/newlib/libc/sys/linux/readdir64.c
+++ b/newlib/libc/sys/linux/readdir64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/sys/linux/realloc.c b/newlib/libc/sys/linux/realloc.c
index 818e05a..8d2ca83 100644
--- a/newlib/libc/sys/linux/realloc.c
+++ b/newlib/libc/sys/linux/realloc.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* dummy file to override one object in stdlib directory */
diff --git a/newlib/libc/sys/linux/reallocr.c b/newlib/libc/sys/linux/reallocr.c
index 873c1b0..04fadee 100644
--- a/newlib/libc/sys/linux/reallocr.c
+++ b/newlib/libc/sys/linux/reallocr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void *
 _realloc_r (struct _reent *ptr, void *old, size_t newlen)
 {
+  __A_VARIABLE = 1;
   return realloc (old, newlen);
 }
diff --git a/newlib/libc/sys/linux/realpath.c b/newlib/libc/sys/linux/realpath.c
index 63793c6..7b0ca84 100644
--- a/newlib/libc/sys/linux/realpath.c
+++ b/newlib/libc/sys/linux/realpath.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* realpath.c - Return the canonicalized absolute pathname */
 
 /* Written 2000 by Werner Almesberger */
@@ -77,16 +78,30 @@ char *realpath(const char *__restrict path,char *__restrict resolved_path)
 
     if (!*path) {
 	errno = ENOENT; /* SUSv2 */
+	__A_VARIABLE = 1;
+	return NULL;
+    }
+    if (!getcwd(cwd,sizeof(cwd))) {
+	__A_VARIABLE = 1;
 	return NULL;
     }
-    if (!getcwd(cwd,sizeof(cwd))) return NULL;
     strcpy(resolved_path,"/");
-    if (resolve_path(cwd,resolved_path,resolved_path)) return NULL;
+    if (resolve_path(cwd,resolved_path,resolved_path)) {
+	__A_VARIABLE = 1;
+	return NULL;
+    }
     strcat(resolved_path,"/");
     path_copy = strdup(path);
-    if (!path_copy) return NULL;
+    if (!path_copy) {
+	__A_VARIABLE = 1;
+	return NULL;
+    }
     res = resolve_path(path_copy,resolved_path,strchr(resolved_path,0));
     free(path_copy);
-    if (res) return NULL;
+    if (res) {
+	__A_VARIABLE = 1;
+	return NULL;
+    }
+    __A_VARIABLE = 1;
     return resolved_path;
 }
diff --git a/newlib/libc/sys/linux/rename.c b/newlib/libc/sys/linux/rename.c
index d6bf459..dd4cdfc 100644
--- a/newlib/libc/sys/linux/rename.c
+++ b/newlib/libc/sys/linux/rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/rename.c - rename a file */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/resource.c b/newlib/libc/sys/linux/resource.c
index 54a049d..eb1beb2 100644
--- a/newlib/libc/sys/linux/resource.c
+++ b/newlib/libc/sys/linux/resource.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/resource.c - Process resource functions */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/scandir64.c b/newlib/libc/sys/linux/scandir64.c
index b21b423..1a1ea8e 100644
--- a/newlib/libc/sys/linux/scandir64.c
+++ b/newlib/libc/sys/linux/scandir64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -83,8 +84,10 @@ scandir64(dirname, namelist, select, dcomp)
 	long arraysz;
 	DIR *dirp;
 
-	if ((dirp = opendir(dirname)) == NULL)
+	if ((dirp = opendir(dirname)) == NULL) {
+		__A_VARIABLE = 1;
 		return(-1);
+	}
 #ifdef HAVE_DD_LOCK
 	__lock_acquire_recursive(dirp->dd_lock);
 #endif
@@ -92,6 +95,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 		__lock_release_recursive(dirp->dd_lock);
 #endif
+		__A_VARIABLE = 1;
 		return(-1);
 	}
 
@@ -105,6 +109,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 		__lock_release_recursive(dirp->dd_lock);
 #endif
+		__A_VARIABLE = 1;
 		return(-1);
 	}
 
@@ -120,6 +125,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 			__lock_release_recursive(dirp->dd_lock);
 #endif
+			__A_VARIABLE = 1;
 			return(-1);
 		}
 		p->d_ino = d->d_ino;
@@ -139,6 +145,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 				__lock_release_recursive(dirp->dd_lock);
 #endif
+				__A_VARIABLE = 1;
 				return(-1);	/* just might have grown */
 			}
 			arraysz = stb.st_size / 12;
@@ -148,6 +155,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 				__lock_release_recursive(dirp->dd_lock);
 #endif
+				__A_VARIABLE = 1;
 				return(-1);
 			}
 		}
@@ -160,6 +168,7 @@ scandir64(dirname, namelist, select, dcomp)
 #ifdef HAVE_DD_LOCK
 	__lock_release_recursive(dirp->dd_lock);
 #endif
+	__A_VARIABLE = 1;
 	return(nitems);
 }
 
@@ -171,6 +180,7 @@ alphasort64(d1, d2)
        const struct dirent64 **d1;
        const struct dirent64 **d2;
 {
+       __A_VARIABLE = 1;
        return(strcmp((*d1)->d_name, (*d2)->d_name));
 }
 
diff --git a/newlib/libc/sys/linux/sched.c b/newlib/libc/sys/linux/sched.c
index 031b1b5..1cebe5c 100644
--- a/newlib/libc/sys/linux/sched.c
+++ b/newlib/libc/sys/linux/sched.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/sched.c - Process scheduling functions */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/select.c b/newlib/libc/sys/linux/select.c
index 882f541..3832beb 100644
--- a/newlib/libc/sys/linux/select.c
+++ b/newlib/libc/sys/linux/select.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/select.c - The select system calls */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/seteuid.c b/newlib/libc/sys/linux/seteuid.c
index c3fa384..586e093 100644
--- a/newlib/libc/sys/linux/seteuid.c
+++ b/newlib/libc/sys/linux/seteuid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright 2002, Red Hat Inc. */
 
 #include <errno.h>
@@ -11,8 +12,10 @@ seteuid (uid_t uid)
 	if (uid == (uid_t) ~0)
 	{
 		errno = (EINVAL);
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return setresuid (-1, uid, -1);
 }
diff --git a/newlib/libc/sys/linux/sethostid.c b/newlib/libc/sys/linux/sethostid.c
index eb71b74..7853efa 100644
--- a/newlib/libc/sys/linux/sethostid.c
+++ b/newlib/libc/sys/linux/sethostid.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define SET_PROCEDURE 1
 #include "gethostid.c"
diff --git a/newlib/libc/sys/linux/sethostname.c b/newlib/libc/sys/linux/sethostname.c
index 669df3d..6ea5e1e 100644
--- a/newlib/libc/sys/linux/sethostname.c
+++ b/newlib/libc/sys/linux/sethostname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/sethostname.c - Set host name */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/setrlimit64.c b/newlib/libc/sys/linux/setrlimit64.c
index d4b4bfc..78bb402 100644
--- a/newlib/libc/sys/linux/setrlimit64.c
+++ b/newlib/libc/sys/linux/setrlimit64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991,1995,1996,1997,1998,2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -39,5 +40,6 @@ setrlimit64 (resource, rlimits)
   else
     rlimits32.rlim_max = rlimits->rlim_max;
 
+  __A_VARIABLE = 1;
   return __setrlimit (resource, &rlimits32);
 }
diff --git a/newlib/libc/sys/linux/shm_open.c b/newlib/libc/sys/linux/shm_open.c
index cb92c3a..df56062 100644
--- a/newlib/libc/sys/linux/shm_open.c
+++ b/newlib/libc/sys/linux/shm_open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* shm_open - open a shared memory file */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -44,5 +45,6 @@ shm_open (const char *name, int oflag, mode_t mode)
         }
     }
 
+  __A_VARIABLE = 1;
   return fd;
 }
diff --git a/newlib/libc/sys/linux/shm_unlink.c b/newlib/libc/sys/linux/shm_unlink.c
index cf259c6..766862c 100644
--- a/newlib/libc/sys/linux/shm_unlink.c
+++ b/newlib/libc/sys/linux/shm_unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* shm_unlink - remove a shared memory file */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -24,5 +25,6 @@ shm_unlink (const char *name)
 
   rc = unlink (shm_name);
 
+  __A_VARIABLE = 1;
   return rc;
 }
diff --git a/newlib/libc/sys/linux/sig.c b/newlib/libc/sys/linux/sig.c
index 6e22873..14104f9 100644
--- a/newlib/libc/sys/linux/sig.c
+++ b/newlib/libc/sys/linux/sig.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/signal.c - Signal handling functions */
 
 /* Written 2000 by Werner Almesberger */
@@ -34,23 +35,27 @@ weak_alias(__sigsuspend,sigsuspend)
 
 int sigmask(int signum) /* BSD */
 {
+    __A_VARIABLE = 1;
     return 1 << signum;
 }
 
 int __libc_raise(int sig)
 {
+    __A_VARIABLE = 1;
     return kill(getpid(),sig);
 }
 weak_alias(__libc_raise,raise)
 
 int __sigpending(sigset_t *set)
 {
+  __A_VARIABLE = 1;
   return __rt_sigpending(set, NSIG/8);
 }
 weak_alias(__sigpending,sigpending)
 
 int __sigprocmask (int how,const sigset_t *set,sigset_t *oldset)
 {
+  __A_VARIABLE = 1;
   return __rt_sigprocmask(how, set, oldset, NSIG/8);
 }
 weak_alias(__sigprocmask,sigprocmask)
@@ -58,11 +63,13 @@ weak_alias(__sigprocmask,sigprocmask)
 int sigtimedwait(const sigset_t *set, siginfo_t *info,
                  struct timespec *timeout)
 {
+  __A_VARIABLE = 1;
   return __rt_sigtimedwait(set, info, timeout, NSIG/8);
 }
 
 int sigwaitinfo(const sigset_t *set, siginfo_t *info)
 {
+  __A_VARIABLE = 1;
   return __rt_sigtimedwait(set, info, NULL, NSIG/8);
 }
 
@@ -78,6 +85,7 @@ int sigblock(int mask) /* BSD */
 
 int sigsetmask(int newmask) /* BSD */
 {
+    __A_VARIABLE = 1;
     return __ssetmask(newmask);
 }
 #endif
diff --git a/newlib/libc/sys/linux/sigaction.c b/newlib/libc/sys/linux/sigaction.c
index 6ee3fa2..e16a475 100644
--- a/newlib/libc/sys/linux/sigaction.c
+++ b/newlib/libc/sys/linux/sigaction.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/siglongjmp.c b/newlib/libc/sys/linux/siglongjmp.c
index bc3c5b7..b748528 100644
--- a/newlib/libc/sys/linux/siglongjmp.c
+++ b/newlib/libc/sys/linux/siglongjmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/siglongjmp.c - siglongjmp function */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -14,5 +15,6 @@ __libc_siglongjmp (sigjmp_buf env, int val)
     sigprocmask (SIG_SETMASK, &env.__saved_mask, NULL);
 
   __libc_longjmp (env.__buf, val);
+  __A_VARIABLE = 1;
 }
 weak_alias(__libc_siglongjmp,siglongjmp);
diff --git a/newlib/libc/sys/linux/signal.c b/newlib/libc/sys/linux/signal.c
index b43cd77..645106c 100644
--- a/newlib/libc/sys/linux/signal.c
+++ b/newlib/libc/sys/linux/signal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* BSD-like signal function.
    Copyright (C) 1991, 1992, 1996, 1997, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -36,17 +37,23 @@ __bsd_signal (sig, handler)
   if (handler == SIG_ERR || sig < 1 || sig >= NSIG)
     {
       errno = (EINVAL);
+      __A_VARIABLE = 1;
       return SIG_ERR;
     }
 
   act.sa_handler = handler;
   if (sigemptyset (&act.sa_mask) < 0
-      || sigaddset (&act.sa_mask, sig) < 0)
+      || sigaddset (&act.sa_mask, sig) < 0) {
+    __A_VARIABLE = 1;
     return SIG_ERR;
+  }
   act.sa_flags = sigismember (&_sigintr, sig) ? 0 : SA_RESTART;
-  if (sigaction (sig, &act, &oact) < 0)
+  if (sigaction (sig, &act, &oact) < 0) {
+    __A_VARIABLE = 1;
     return SIG_ERR;
+  }
 
+  __A_VARIABLE = 1;
   return oact.sa_handler;
 }
 weak_alias (__bsd_signal, bsd_signal)
diff --git a/newlib/libc/sys/linux/sigqueue.c b/newlib/libc/sys/linux/sigqueue.c
index 60c4fed..1c598d6 100644
--- a/newlib/libc/sys/linux/sigqueue.c
+++ b/newlib/libc/sys/linux/sigqueue.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/sigset.c b/newlib/libc/sys/linux/sigset.c
index b6f2d79..d7d92aa 100644
--- a/newlib/libc/sys/linux/sigset.c
+++ b/newlib/libc/sys/linux/sigset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sigset.c - signal set manipulation functions */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -23,6 +24,7 @@ sigaddset (sigset_t *set, const int signo)
   if (signo > NSIG)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -30,6 +32,7 @@ sigaddset (sigset_t *set, const int signo)
   mask = 1 << ((signo - 1) % (8 * sizeof(long)));
 
   st->__val[index] |= mask;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -44,6 +47,7 @@ sigdelset (sigset_t *set, const int signo)
   if (signo > NSIG)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -51,6 +55,7 @@ sigdelset (sigset_t *set, const int signo)
   mask = 1 << ((signo - 1) % (8 * sizeof(long)));
 
   st->__val[index] &= ~mask;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -62,6 +67,7 @@ sigemptyset (sigset_t *set)
   int size = NSIG / 8;
   __sigset_t *st = (__sigset_t *)set;
   memset (st->__val, 0, size);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -73,6 +79,7 @@ sigfillset (sigset_t *set)
   int size = NSIG / 8;
   __sigset_t *st = (__sigset_t *)set;
   memset (st->__val, 0xff, size);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -87,12 +94,14 @@ sigismember (const sigset_t *set, int signo)
   if (signo > NSIG)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
   index = (signo - 1) / (8 * sizeof(long));
   mask = 1 << ((signo - 1) % (8 * sizeof(long)));
 
+  __A_VARIABLE = 1;
   return (st->__val[index] & mask) != 0;
 }
 
diff --git a/newlib/libc/sys/linux/sigwait.c b/newlib/libc/sys/linux/sigwait.c
index 09a4190..39272cb 100644
--- a/newlib/libc/sys/linux/sigwait.c
+++ b/newlib/libc/sys/linux/sigwait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of sigwait function from POSIX.1c.
    Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -80,6 +81,7 @@ __sigwait (const sigset_t *set, int *sig)
 
   /* Store the result and return.  */
   *sig = was_sig;
+  __A_VARIABLE = 1;
   return was_sig == -1 ? -1 : 0;
 }
 weak_alias (__sigwait, sigwait)
@@ -90,4 +92,5 @@ ignore_signal (int sig)
 {
   /* Remember the signal.  */
   was_sig = sig;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/linux/sleep.c b/newlib/libc/sys/linux/sleep.c
index 7cc2bed..5dbe70e 100644
--- a/newlib/libc/sys/linux/sleep.c
+++ b/newlib/libc/sys/linux/sleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/sleep.c - sleep function */
 
 /* Written 2000 by Werner Almesberger */
@@ -14,7 +15,14 @@ unsigned int sleep(unsigned int seconds)
 
     ts.tv_sec = seconds;
     ts.tv_nsec = 0;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/newlib/libc/sys/linux/socket.c b/newlib/libc/sys/linux/socket.c
index daba989..62cdb04 100644
--- a/newlib/libc/sys/linux/socket.c
+++ b/newlib/libc/sys/linux/socket.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/socket.c - socket system calls */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/stack.c b/newlib/libc/sys/linux/stack.c
index 52a181c..c1f5cc1 100644
--- a/newlib/libc/sys/linux/stack.c
+++ b/newlib/libc/sys/linux/stack.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/stack.c - Basic stack system calls */
 
 /* Copyright 2002, Red Hat Inc. */
diff --git a/newlib/libc/sys/linux/statvfs.c b/newlib/libc/sys/linux/statvfs.c
index be125c2..adf9ace 100644
--- a/newlib/libc/sys/linux/statvfs.c
+++ b/newlib/libc/sys/linux/statvfs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
@@ -36,12 +37,15 @@ statvfs (const char *__restrict file, struct statvfs *__restrict buf)
   struct stat64 st;
 
   /* Get as much information as possible from the system.  */
-  if (__statfs (file, &fsbuf) < 0)
+  if (__statfs (file, &fsbuf) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
 #define STAT(st) stat64 (file, st)
 #include "internal_statvfs.c"
 
   /* We signal success if the statfs call succeeded.  */
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/linux/statvfs64.c b/newlib/libc/sys/linux/statvfs64.c
index f612b99..d48461f 100644
--- a/newlib/libc/sys/linux/statvfs64.c
+++ b/newlib/libc/sys/linux/statvfs64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Return information about the filesystem on which FILE resides.
    Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -29,8 +30,10 @@ __statvfs64 (const char *file, struct statvfs64 *buf)
 {
   struct statvfs buf32;
 
-  if (statvfs (file, &buf32) < 0)
+  if (statvfs (file, &buf32) < 0) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   buf->f_bsize = buf32.f_bsize;
   buf->f_frsize = buf32.f_frsize;
@@ -45,6 +48,7 @@ __statvfs64 (const char *file, struct statvfs64 *buf)
   buf->f_namemax = buf32.f_namemax;
   memcpy (buf->__f_spare, buf32.__f_spare, sizeof (buf32.__f_spare));
 
+  __A_VARIABLE = 1;
   return 0;
 }
 weak_alias (__statvfs64, statvfs64)
diff --git a/newlib/libc/sys/linux/strsignal.c b/newlib/libc/sys/linux/strsignal.c
index 3f95e18..67cff3b 100644
--- a/newlib/libc/sys/linux/strsignal.c
+++ b/newlib/libc/sys/linux/strsignal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <string.h>
 #include <signal.h>
 #include <stdio.h>
diff --git a/newlib/libc/sys/linux/strverscmp.c b/newlib/libc/sys/linux/strverscmp.c
index 2a9cbf4..42feb59 100644
--- a/newlib/libc/sys/linux/strverscmp.c
+++ b/newlib/libc/sys/linux/strverscmp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Compare strings while treating digits characters numerically.
    Copyright (C) 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -76,8 +77,10 @@ __strverscmp (s1, s2)
                  -1,  CMP, CMP, CMP
   };
 
-  if (p1 == p2)
+  if (p1 == p2) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   c1 = *p1++;
   c2 = *p2++;
@@ -97,16 +100,21 @@ __strverscmp (s1, s2)
   switch (state)
   {
     case CMP:
+      __A_VARIABLE = 1;
       return diff;
 
     case LEN:
       while (isdigit (*p1++))
-	if (!isdigit (*p2++))
+	if (!isdigit (*p2++)) {
+	  __A_VARIABLE = 1;
 	  return 1;
+	}
 
+      __A_VARIABLE = 1;
       return isdigit (*p2) ? -1 : diff;
 
     default:
+      __A_VARIABLE = 1;
       return state;
   }
 }
diff --git a/newlib/libc/sys/linux/sysconf.c b/newlib/libc/sys/linux/sysconf.c
index 037ae54..557e93b 100644
--- a/newlib/libc/sys/linux/sysconf.c
+++ b/newlib/libc/sys/linux/sysconf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/sysconf.c - The sysconf function */
 
 /* Copyright 2002, Red Hat Inc. */
@@ -16,6 +17,7 @@ sysconf (int name)
     {
     case _SC_AIO_LISTIO_MAX:
 #ifdef AIO_LISTIO_MAX
+      __A_VARIABLE = 1;
       return AIO_LISTIO_MAX;
 #else
       return -1;
@@ -23,6 +25,7 @@ sysconf (int name)
 
     case _SC_AIO_MAX:
 #ifdef AIO_MAX
+      __A_VARIABLE = 1;
       return AIO_MAX;
 #else
       return -1;
@@ -30,6 +33,7 @@ sysconf (int name)
 
     case _SC_AIO_PRIO_DELTA_MAX:
 #ifdef AIO_PRIO_DELTA_MAX
+      __A_VARIABLE = 1;
       return AIO_PRIO_DELTA_MAX;
 #else
       return -1;
@@ -37,6 +41,7 @@ sysconf (int name)
 
     case _SC_ARG_MAX:
 #ifdef ARG_MAX
+      __A_VARIABLE = 1;
       return ARG_MAX;
 #else
       return -1;
@@ -44,16 +49,19 @@ sysconf (int name)
     
     case _SC_CHILD_MAX:
 #ifdef CHILD_MAX
+      __A_VARIABLE = 1;
       return CHILD_MAX;
 #else
       return -1;
 #endif
 
     case _SC_CLK_TCK:
+      __A_VARIABLE = 1;
       return CLK_TCK;
 
     case _SC_DELAYTIMER_MAX:
 #ifdef DELAYTIMER_MAX
+      __A_VARIABLE = 1;
       return DELAYTIMER_MAX;
 #else
       return -1;
@@ -61,6 +69,7 @@ sysconf (int name)
 
     case _SC_GETGR_R_SIZE_MAX:
 #ifdef _GETGR_R_SIZE_MAX
+      __A_VARIABLE = 1;
       return _GETGR_R_SIZE_MAX;
 #else
       return -1;
@@ -68,6 +77,7 @@ sysconf (int name)
 
     case _SC_GETPW_R_SIZE_MAX:
 #ifdef _GETPW_R_SIZE_MAX
+      __A_VARIABLE = 1;
       return _GETPW_R_SIZE_MAX;
 #else
       return -1;
@@ -75,6 +85,7 @@ sysconf (int name)
 
     case _SC_LOGIN_NAME_MAX:
 #ifdef LOGIN_NAME_MAX
+      __A_VARIABLE = 1;
       return LOGIN_NAME_MAX;
 #else
       return -1;
@@ -82,6 +93,7 @@ sysconf (int name)
    
     case _SC_MQ_OPEN_MAX:
 #ifdef MQ_OPEN_MAX
+      __A_VARIABLE = 1;
       return MQ_OPEN_MAX;
 #else
       return -1;
@@ -89,6 +101,7 @@ sysconf (int name)
    
     case _SC_MQ_PRIO_MAX:
 #ifdef MQ_PRIO_MAX
+      __A_VARIABLE = 1;
       return MQ_PRIO_MAX;
 #else
       return -1;
@@ -96,6 +109,7 @@ sysconf (int name)
    
     case _SC_NGROUPS_MAX:
 #ifdef NGROUPS_MAX
+      __A_VARIABLE = 1;
       return NGROUPS_MAX;
 #else
       return -1;
@@ -103,6 +117,7 @@ sysconf (int name)
   
     case _SC_OPEN_MAX:
 #ifdef OPEN_MAX
+      __A_VARIABLE = 1;
       return OPEN_MAX;
 #else
       return -1;
@@ -110,6 +125,7 @@ sysconf (int name)
   
     case _SC_PAGESIZE:
 #ifdef PAGESIZE
+      __A_VARIABLE = 1;
       return PAGESIZE;
 #else
       return -1;
@@ -117,6 +133,7 @@ sysconf (int name)
   
     case _SC_RTSIG_MAX:
 #ifdef RTSIG_MAX
+      __A_VARIABLE = 1;
       return RTSIG_MAX;
 #else
       return -1;
@@ -124,6 +141,7 @@ sysconf (int name)
   
     case _SC_SEM_NSEMS_MAX:
 #ifdef SEM_NSEMS_MAX
+      __A_VARIABLE = 1;
       return SEM_NSEMS_MAX;
 #else
       return -1;
@@ -131,6 +149,7 @@ sysconf (int name)
   
     case _SC_SEM_VALUE_MAX:
 #ifdef SEM_VALUE_MAX
+      __A_VARIABLE = 1;
       return SEM_VALUE_MAX;
 #else
       return -1;
@@ -138,6 +157,7 @@ sysconf (int name)
   
     case _SC_SIGQUEUE_MAX:
 #ifdef SIGQUEUE_MAX
+      __A_VARIABLE = 1;
       return SIGQUEUE_MAX;
 #else
       return -1;
@@ -145,6 +165,7 @@ sysconf (int name)
   
     case _SC_STREAM_MAX:
 #ifdef STREAM_MAX
+      __A_VARIABLE = 1;
       return STREAM_MAX;
 #else
       return -1;
@@ -152,6 +173,7 @@ sysconf (int name)
   
     case _SC_THREAD_DESTRUCTOR_ITERATIONS:
 #ifdef PTHREAD_DESTRUCTOR_ITERATIONS
+      __A_VARIABLE = 1;
       return PTHREAD_DESTRUCTOR_ITERATIONS;
 #else
       return -1;
@@ -159,6 +181,7 @@ sysconf (int name)
   
     case _SC_THREAD_KEYS_MAX:
 #ifdef PTHREAD_KEYS_MAX
+      __A_VARIABLE = 1;
       return PTHREAD_KEYS_MAX;
 #else
       return -1;
@@ -166,6 +189,7 @@ sysconf (int name)
   
     case _SC_THREAD_STACK_MIN:
 #ifdef PTHREAD_STACK_MIN
+      __A_VARIABLE = 1;
       return PTHREAD_STACK_MIN;
 #else
       return -1;
@@ -173,6 +197,7 @@ sysconf (int name)
   
     case _SC_THREAD_THREADS_MAX:
 #ifdef PTHREAD_THREADS_MAX
+      __A_VARIABLE = 1;
       return PTHREAD_THREADS_MAX;
 #else
       return -1;
@@ -180,6 +205,7 @@ sysconf (int name)
   
     case _SC_TIMER_MAX:
 #ifdef TIMER_MAX
+      __A_VARIABLE = 1;
       return TIMER_MAX;
 #else
       return -1;
@@ -187,6 +213,7 @@ sysconf (int name)
   
     case _SC_TTY_NAME_MAX:
 #ifdef TTY_NAME_MAX
+      __A_VARIABLE = 1;
       return TTY_NAME_MAX;
 #else
       return -1;
@@ -194,6 +221,7 @@ sysconf (int name)
   
     case _SC_TZNAME_MAX:
 #ifdef TZNAME_MAX
+      __A_VARIABLE = 1;
       return TZNAME_MAX;
 #else
       return -1;
@@ -201,6 +229,7 @@ sysconf (int name)
   
     case _SC_ASYNCHRONOUS_IO:
 #ifdef _POSIX_ASYNCHRONOUS_IO
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -208,6 +237,7 @@ sysconf (int name)
   
     case _SC_FSYNC:
 #ifdef _POSIX_FSYNC
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -215,6 +245,7 @@ sysconf (int name)
   
     case _SC_JOB_CONTROL:
 #ifdef _POSIX_JOB_CONTROL
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -222,6 +253,7 @@ sysconf (int name)
   
     case _SC_MAPPED_FILES:
 #ifdef _POSIX_MAPPED_FILES
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -229,6 +261,7 @@ sysconf (int name)
   
     case _SC_MEMLOCK:
 #ifdef _POSIX_MEMLOCK
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -236,6 +269,7 @@ sysconf (int name)
   
     case _SC_MEMLOCK_RANGE:
 #ifdef _POSIX_MEMLOCK_RANGE
+      __A_VARIABLE = 1;
       return _POSIX_MEMLOCK_RANGE;
 #else
       return -1;
@@ -243,6 +277,7 @@ sysconf (int name)
   
     case _SC_MEMORY_PROTECTION:
 #ifdef _POSIX_MEMORY_PROTECTION
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -250,6 +285,7 @@ sysconf (int name)
   
     case _SC_MESSAGE_PASSING:
 #ifdef _POSIX_MESSAGE_PASSING
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -257,6 +293,7 @@ sysconf (int name)
   
     case _SC_PRIORITIZED_IO:
 #ifdef _POSIX_PRIORITIZED_IO
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -264,6 +301,7 @@ sysconf (int name)
   
     case _SC_PRIORITY_SCHEDULING:
 #ifdef _POSIX_PRIORITY_SCHEDULING
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -271,6 +309,7 @@ sysconf (int name)
   
     case _SC_REALTIME_SIGNALS:
 #ifdef _POSIX_REALTIME_SIGNALS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -278,6 +317,7 @@ sysconf (int name)
   
     case _SC_SAVED_IDS:
 #ifdef _POSIX_SAVED_IDS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -285,6 +325,7 @@ sysconf (int name)
   
     case _SC_SEMAPHORES:
 #ifdef _POSIX_SEMAPHORES
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -292,6 +333,7 @@ sysconf (int name)
   
     case _SC_SHARED_MEMORY_OBJECTS:
 #ifdef _POSIX_SHARED_MEMORY_OBJECTS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -299,6 +341,7 @@ sysconf (int name)
   
     case _SC_SYNCHRONIZED_IO:
 #ifdef _POSIX_SYNCHRONIZED_IO
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -306,6 +349,7 @@ sysconf (int name)
   
     case _SC_TIMERS:
 #ifdef _POSIX_TIMERS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -313,6 +357,7 @@ sysconf (int name)
   
     case _SC_THREADS:
 #ifdef _POSIX_THREADS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -320,6 +365,7 @@ sysconf (int name)
   
     case _SC_THREAD_ATTR_STACKADDR:
 #ifdef _POSIX_THREAD_ATTR_STACKADDR
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -327,6 +373,7 @@ sysconf (int name)
   
     case _SC_THREAD_ATTR_STACKSIZE:
 #ifdef _POSIX_THREAD_ATTR_STACKSIZE
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -334,6 +381,7 @@ sysconf (int name)
   
     case _SC_THREAD_PRIORITY_SCHEDULING:
 #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -341,6 +389,7 @@ sysconf (int name)
   
     case _SC_THREAD_PRIO_INHERIT:
 #ifdef _POSIX_THREAD_PRIO_INHERIT
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -348,6 +397,7 @@ sysconf (int name)
   
     case _SC_THREAD_PRIO_PROTECT:
 #ifdef _POSIX_THREAD_PRIO_PROTECT
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -355,6 +405,7 @@ sysconf (int name)
   
     case _SC_THREAD_PROCESS_SHARED:
 #ifdef _POSIX_THREAD_PROCESS_SHARED
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -362,6 +413,7 @@ sysconf (int name)
   
     case _SC_THREAD_SAFE_FUNCTIONS:
 #ifdef _POSIX_THREAD_SAFE_FUNCTIONS
+      __A_VARIABLE = 1;
       return 1;
 #else
       return -1;
@@ -369,6 +421,7 @@ sysconf (int name)
   
     case _SC_VERSION:
 #ifdef _POSIX_VERSION
+      __A_VARIABLE = 1;
       return _POSIX_VERSION;
 #else
       return -1;
@@ -376,6 +429,7 @@ sysconf (int name)
 
     default:
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
 
diff --git a/newlib/libc/sys/linux/sysctl.c b/newlib/libc/sys/linux/sysctl.c
index 020d431..d27e93f 100644
--- a/newlib/libc/sys/linux/sysctl.c
+++ b/newlib/libc/sys/linux/sysctl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Read or write system information.  Linux version.
    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
diff --git a/newlib/libc/sys/linux/systat.c b/newlib/libc/sys/linux/systat.c
index 9a57aa7..38e4266 100644
--- a/newlib/libc/sys/linux/systat.c
+++ b/newlib/libc/sys/linux/systat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/systat.c - System calls related to overall system state */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/system.c b/newlib/libc/sys/linux/system.c
index f8edfbf..2d2e72e 100644
--- a/newlib/libc/sys/linux/system.c
+++ b/newlib/libc/sys/linux/system.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991-1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
diff --git a/newlib/libc/sys/linux/tcdrain.c b/newlib/libc/sys/linux/tcdrain.c
index 364fc03..f0d1030 100644
--- a/newlib/libc/sys/linux/tcdrain.c
+++ b/newlib/libc/sys/linux/tcdrain.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* tcdrain - wait for transmission of output */
 
 #include <termios.h>
@@ -7,6 +8,7 @@
 int
 __libc_tcdrain (int fd)
 { 
+  __A_VARIABLE = 1;
   return ioctl (fd, TCSBRK, 1);
 }
 weak_alias (__libc_tcdrain, tcdrain)
diff --git a/newlib/libc/sys/linux/tcsendbrk.c b/newlib/libc/sys/linux/tcsendbrk.c
index a35a4d8..7ae0a2a 100644
--- a/newlib/libc/sys/linux/tcsendbrk.c
+++ b/newlib/libc/sys/linux/tcsendbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1992, 1996, 1997 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -34,12 +35,15 @@ tcsendbreak (fd, duration)
   /* The break lasts 0.25 to 0.5 seconds if DURATION is zero,
      and an implementation-defined period if DURATION is nonzero.
      We define a positive DURATION to be number of milliseconds to break.  */
-  if (duration <= 0)
+  if (duration <= 0) {
+    __A_VARIABLE = 1;
     return ioctl (fd, TCSBRK, 0);
+  }
 
   /* ioctl can't send a break of any other duration for us.
      This could be changed to use trickery (e.g. lower speed and
      send a '\0') to send the break, but for now just return an error.  */
   errno = (EINVAL);
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/linux/termios.c b/newlib/libc/sys/linux/termios.c
index ac15520..0e3d667 100644
--- a/newlib/libc/sys/linux/termios.c
+++ b/newlib/libc/sys/linux/termios.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/termios.c - Terminal control */
 
 /* Written 2000 by Werner Almesberger */
@@ -12,6 +13,7 @@
 int 
 tcgetattr(int fd,struct termios *termios_p)
 {
+  __A_VARIABLE = 1;
   return ioctl(fd,TCGETS,termios_p);
 }
 
@@ -33,8 +35,10 @@ tcsetattr(int fd,int optional_actions,const struct termios *termios_p)
     break;
     default:
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
+  __A_VARIABLE = 1;
   return ioctl(fd,cmd,termios_p);
 }
 
@@ -44,8 +48,11 @@ tcgetpgrp(int fd)
 {
   int p;
     
-  if (ioctl(fd,TIOCGPGRP,&p) < 0)
+  if (ioctl(fd,TIOCGPGRP,&p) < 0) {
+    __A_VARIABLE = 1;
     return (pid_t)-1;
+  }
+  __A_VARIABLE = 1;
   return (pid_t)p;
 }
 
@@ -54,6 +61,7 @@ int
 tcsetpgrp(int fd, pid_t pid)
 {
   int p = (int)pid;
+  __A_VARIABLE = 1;
   return ioctl(fd,TIOCSPGRP,&p);
 }
 #endif /* !_ELIX_LEVEL || _ELIX_LEVEL >= 4 */
@@ -61,12 +69,14 @@ tcsetpgrp(int fd, pid_t pid)
 int
 tcflow (int fd, int action)
 {
+  __A_VARIABLE = 1;
   return ioctl (fd, TCXONC, action);
 }
 
 int
 tcflush (int fd, int queue_selector)
 {
+  __A_VARIABLE = 1;
   return ioctl (fd, TCFLSH, queue_selector);
 }
 
diff --git a/newlib/libc/sys/linux/time.c b/newlib/libc/sys/linux/time.c
index a731350..ad4e0b7 100644
--- a/newlib/libc/sys/linux/time.c
+++ b/newlib/libc/sys/linux/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/time.c - Time-related system calls */
 
 /* Written 2000 by Werner Almesberger */
diff --git a/newlib/libc/sys/linux/ttyname_r.c b/newlib/libc/sys/linux/ttyname_r.c
index efad76a..a327256 100644
--- a/newlib/libc/sys/linux/ttyname_r.c
+++ b/newlib/libc/sys/linux/ttyname_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1991,92,93,1995-1999,2000,2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -47,6 +48,7 @@ getttyname_r (char *buf, size_t buflen, dev_t mydev, ino64_t myino,
   if (dirstream == NULL)
     {
       *dostat = -1;
+      __A_VARIABLE = 1;
       return errno;
     }
 
@@ -64,6 +66,7 @@ getttyname_r (char *buf, size_t buflen, dev_t mydev, ino64_t myino,
 	      *dostat = -1;
 	      (void) closedir (dirstream);
 	      __set_errno (ERANGE);
+	      __A_VARIABLE = 1;
 	      return ERANGE;
 	    }
 
@@ -79,6 +82,7 @@ getttyname_r (char *buf, size_t buflen, dev_t mydev, ino64_t myino,
 	    {
 	      (void) closedir (dirstream);
 	      __set_errno (save);
+	      __A_VARIABLE = 1;
 	      return 0;
 	    }
         }
@@ -88,6 +92,7 @@ getttyname_r (char *buf, size_t buflen, dev_t mydev, ino64_t myino,
   __set_errno (save);
   /* It is not clear what to return in this case.  `isatty' says FD
      refers to a TTY but no entry in /dev has this inode.  */
+  __A_VARIABLE = 1;
   return ENOTTY;
 }
 
@@ -107,18 +112,21 @@ __ttyname_r (int fd, char *buf, size_t buflen)
   if (!buf)
     {
       __set_errno (EINVAL);
+      __A_VARIABLE = 1;
       return EINVAL;
     }
 
   if (buflen < sizeof ("/dev/pts/"))
     {
       __set_errno (ERANGE);
+      __A_VARIABLE = 1;
       return ERANGE;
     }
 
   if (!isatty (fd))
     {
       __set_errno (ENOTTY);
+      __A_VARIABLE = 1;
       return ENOTTY;
     }
 
@@ -129,16 +137,20 @@ __ttyname_r (int fd, char *buf, size_t buflen)
   if (ret != -1 && buf[0] != '[')
     {
       buf[ret] = '\0';
+      __A_VARIABLE = 1;
       return 0;
     }
   if (ret == -1 && errno == ENAMETOOLONG)
     {
       __set_errno (ERANGE);
+      __A_VARIABLE = 1;
       return ERANGE;
     }
 
-  if (fstat64 (fd, &st) < 0)
+  if (fstat64 (fd, &st) < 0) {
+    __A_VARIABLE = 1;
     return errno;
+  }
 
   /* Prepare the result buffer.  */
   memcpy (buf, "/dev/pts/", sizeof ("/dev/pts/"));
@@ -186,6 +198,7 @@ __ttyname_r (int fd, char *buf, size_t buflen)
 #endif
     }
 
+  __A_VARIABLE = 1;
   return ret;
 }
 
diff --git a/newlib/libc/sys/linux/usleep.c b/newlib/libc/sys/linux/usleep.c
index fab6911..eb5a91b 100644
--- a/newlib/libc/sys/linux/usleep.c
+++ b/newlib/libc/sys/linux/usleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/usleep.c - usleep function */
 
 /* Written 2002 by Jeff Johnston */
@@ -14,7 +15,14 @@ int usleep(__useconds_t useconds)
 
     ts.tv_sec = (long int)useconds / 1000000;
     ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
+    if (!nanosleep(&ts,&ts)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (errno == EINTR) {
+        __A_VARIABLE = 1;
+        return ts.tv_sec;
+    }
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/newlib/libc/sys/linux/utimes.c b/newlib/libc/sys/linux/utimes.c
index 0bee551..1ab1ffa 100644
--- a/newlib/libc/sys/linux/utimes.c
+++ b/newlib/libc/sys/linux/utimes.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -38,6 +39,7 @@ __utimes (const char *file, const struct timeval tvp[2])
   else
     times = NULL;
 
+  __A_VARIABLE = 1;
   return utime (file, times);
 }
 
diff --git a/newlib/libc/sys/linux/vallocr.c b/newlib/libc/sys/linux/vallocr.c
index 8de7ffc..b6695a7 100644
--- a/newlib/libc/sys/linux/vallocr.c
+++ b/newlib/libc/sys/linux/vallocr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 void * 
 _valloc_r (struct _reent *ptr, size_t bytes)
 {
+  __A_VARIABLE = 1;
   return valloc (bytes);
 }
diff --git a/newlib/libc/sys/linux/versionsort.c b/newlib/libc/sys/linux/versionsort.c
index 13cbdcc..4262f4a 100644
--- a/newlib/libc/sys/linux/versionsort.c
+++ b/newlib/libc/sys/linux/versionsort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <dirent.h>
 #include <string.h>
 
@@ -6,6 +7,7 @@ extern int __strverscmp (char *, char *);
 int
 versionsort (const void *a, const void *b)
 {
+  __A_VARIABLE = 1;
   return __strverscmp ((*(const struct dirent **)a)->d_name,
                        (*(const struct dirent **)b)->d_name);
 }
diff --git a/newlib/libc/sys/linux/versionsort64.c b/newlib/libc/sys/linux/versionsort64.c
index 45147b0..ca630df 100644
--- a/newlib/libc/sys/linux/versionsort64.c
+++ b/newlib/libc/sys/linux/versionsort64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <dirent.h>
 #include <string.h>
 
@@ -6,6 +7,7 @@ extern int __strverscmp (char *, char *);
 int
 versionsort64 (const void *a, const void *b)
 {
+  __A_VARIABLE = 1;
   return __strverscmp ((*(const struct dirent64 **)a)->d_name,
                        (*(const struct dirent64 **)b)->d_name);
 }
diff --git a/newlib/libc/sys/linux/wait.c b/newlib/libc/sys/linux/wait.c
index 31d1cc7..55aada7 100644
--- a/newlib/libc/sys/linux/wait.c
+++ b/newlib/libc/sys/linux/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* libc/sys/linux/wait.c - Wait function wrappers */
 
 /* Written 2000 by Werner Almesberger */
@@ -13,12 +14,14 @@ _syscall4(pid_t,wait4,pid_t,pid,int *,status,int,options,struct rusage *,rusage)
 
 pid_t __libc_wait3(int *status,int options,struct rusage *rusage)
 {
+    __A_VARIABLE = 1;
     return __libc_wait4(-1,status,options,rusage);
 }
 weak_alias(__libc_wait3,wait3)
 
 pid_t __libc_wait(int *status)
 {
+    __A_VARIABLE = 1;
     return __libc_waitpid(-1,status,0);
 }
 
diff --git a/newlib/libc/sys/m88kbug/crt0.c b/newlib/libc/sys/m88kbug/crt0.c
index d0d95e4..d16de30 100644
--- a/newlib/libc/sys/m88kbug/crt0.c
+++ b/newlib/libc/sys/m88kbug/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int main(int argc, char **argv);
 
 extern char edata;
@@ -16,4 +17,5 @@ _start()
 
   main(0, 0);
   _exit();
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/m88kbug/syscalls.c b/newlib/libc/sys/m88kbug/syscalls.c
index 954dcf6..eb5afc6 100644
--- a/newlib/libc/sys/m88kbug/syscalls.c
+++ b/newlib/libc/sys/m88kbug/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Operating system  and traps for mvme187bug, the motorolola BUG
    monitor for m88k */
 
@@ -12,12 +13,14 @@ static void writechar(int c) {
   register int n asm ("r2");
   n = c;
   SYSTRAP(OUTCHR);
+  __A_VARIABLE = 1;
   return;
 }
 
 static int readchar(void) {
   register int n asm ("r2");
   SYSTRAP(INCHR);
+  __A_VARIABLE = 1;
   return(n);
 }
 
@@ -28,10 +31,12 @@ int read(int file, char *ptr, int len) {
     *ptr++ = readchar();
   }
 
+  __A_VARIABLE = 1;
   return(len);
 }
 
 int lseek(int file, int ptr, int dir) {
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -41,10 +46,12 @@ int write(int file, char *ptr, int len) {
   for (todo = len; todo; --todo) {
     writechar(*ptr++);
   }
+  __A_VARIABLE = 1;
   return(len);
 }
 
 int close(int file) {
+  __A_VARIABLE = 1;
   return(-1);
 }
 
@@ -64,67 +71,81 @@ caddr_t sbrk(int incr) {
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return((caddr_t) prev_heap_end);
 }
 
 int isatty(int file) {
+  __A_VARIABLE = 1;
   return(1);
 }
 
 int fstat(int file, struct stat *st) {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return(0);
 }
 
 int stat(char *__restrict filename, struct stat *__restrict st) {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return(0);
 }
 
 int open(const char *path, int flags) {
+  __A_VARIABLE = 1;
   return(0);
 }
 
 
 int _exit() {
   SYSTRAP(RETURN);
+  __A_VARIABLE = 1;
 }
 
 int execve(char *name, char **argv, char **env) {
   errno = ENOMEM;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 int fork() {
   errno = EAGAIN;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 int getpid() {
+  __A_VARIABLE = 1;
   return(1);
 }
 
 int kill(int pid, int sig) {
   errno = EINVAL;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 int link(char *old, char *new) {
   errno = EMLINK;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 clock_t times(struct tms *buf) {
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 int unlink(char *name) {
   errno = ENOENT;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
 int wait(int *status) {
   errno = ECHILD;
+  __A_VARIABLE = 1;
   return(-1);
 }
 
diff --git a/newlib/libc/sys/mmixware/_exit.c b/newlib/libc/sys/mmixware/_exit.c
index 2f70154..05bbc13 100644
--- a/newlib/libc/sys/mmixware/_exit.c
+++ b/newlib/libc/sys/mmixware/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* _exit for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -27,4 +28,5 @@ void _exit (int n)
 	   : /* No outputs.  */
 	   : "r" (n)
 	   : "memory");
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/mmixware/access.c b/newlib/libc/sys/mmixware/access.c
index 8927b91..85a651c 100644
--- a/newlib/libc/sys/mmixware/access.c
+++ b/newlib/libc/sys/mmixware/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* access for MMIXware.
 
    Copyright (C) 2001, 2007 Hans-Peter Nilsson
@@ -34,9 +35,11 @@ access (const char *fn, int flags)
       /* Yes, this was readable.  As in other simulator access functions,
 	 we always return success in this case (though the others check
 	 for directory access).  */
+      __A_VARIABLE = 1;
       return _close (fd);
     }
 
   errno = EACCES;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/chmod.c b/newlib/libc/sys/mmixware/chmod.c
index a328d6c..7d1ef14 100644
--- a/newlib/libc/sys/mmixware/chmod.c
+++ b/newlib/libc/sys/mmixware/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* chmod stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ chmod (const char *path, mode_t mode)
 {
   UNIMPLEMENTED (("path: %s, mode: %lu", path, (unsigned long) mode));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/chown.c b/newlib/libc/sys/mmixware/chown.c
index f4fc49c..4321746 100644
--- a/newlib/libc/sys/mmixware/chown.c
+++ b/newlib/libc/sys/mmixware/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* chown stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ chown (const char *path, short owner, short group)
 {
   UNIMPLEMENTED (("path: %s, owner: %d, group: %d", path, owner, group));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/close.c b/newlib/libc/sys/mmixware/close.c
index d8203f4..91a6bec 100644
--- a/newlib/libc/sys/mmixware/close.c
+++ b/newlib/libc/sys/mmixware/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* close for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -24,6 +25,7 @@ _close (int file)
       || _MMIX_allocated_filehandle[file] == 0)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -32,7 +34,9 @@ _close (int file)
   if (TRAP1f (SYS_Fclose, file) != 0)
     {
       errno = EIO;
+      __A_VARIABLE = 1;
       return -1;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/mmixware/creat.c b/newlib/libc/sys/mmixware/creat.c
index 622dcfa..4bd2553 100644
--- a/newlib/libc/sys/mmixware/creat.c
+++ b/newlib/libc/sys/mmixware/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* creat for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -23,5 +24,6 @@ creat (const char *path,
        /* We can't set the mode, so we have to ignore it.  */
        mode_t mode)
 {
+  __A_VARIABLE = 1;
   return open (path, O_CREAT|O_WRONLY|O_TRUNC);
 }
diff --git a/newlib/libc/sys/mmixware/crt0.c b/newlib/libc/sys/mmixware/crt0.c
index 63fda50..33ce7af 100644
--- a/newlib/libc/sys/mmixware/crt0.c
+++ b/newlib/libc/sys/mmixware/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* crt0 stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
diff --git a/newlib/libc/sys/mmixware/execv.c b/newlib/libc/sys/mmixware/execv.c
index cae2813..b30a9e0 100644
--- a/newlib/libc/sys/mmixware/execv.c
+++ b/newlib/libc/sys/mmixware/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* execv stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ execv (const char *path, char *const argv[])
 {
   UNIMPLEMENTED (("path: %s, argv: %p", path, argv));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/execve.c b/newlib/libc/sys/mmixware/execve.c
index 6477dae..bf6c562 100644
--- a/newlib/libc/sys/mmixware/execve.c
+++ b/newlib/libc/sys/mmixware/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* execve stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ _execve (const char *path, char *const argv[], char *const envp[])
 {
   UNIMPLEMENTED (("path: %s, argv: %p, envp: %p", path, argv, envp));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/fork.c b/newlib/libc/sys/mmixware/fork.c
index ad27058..0d0ecce 100644
--- a/newlib/libc/sys/mmixware/fork.c
+++ b/newlib/libc/sys/mmixware/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fork stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ _fork ()
 {
   UNIMPLEMENTED ((""));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/fstat.c b/newlib/libc/sys/mmixware/fstat.c
index 63a9ac7..d49a9f8 100644
--- a/newlib/libc/sys/mmixware/fstat.c
+++ b/newlib/libc/sys/mmixware/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fstat for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ _fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/mmixware/getpid.c b/newlib/libc/sys/mmixware/getpid.c
index 5190726..d7784a4 100644
--- a/newlib/libc/sys/mmixware/getpid.c
+++ b/newlib/libc/sys/mmixware/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* getpid stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -18,5 +19,6 @@
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/sys/mmixware/gettime.c b/newlib/libc/sys/mmixware/gettime.c
index 973c6df..dc45f2e 100644
--- a/newlib/libc/sys/mmixware/gettime.c
+++ b/newlib/libc/sys/mmixware/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* gettime stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -23,5 +24,6 @@ _gettimeofday (struct timeval *tp, void *tzp)
 {
   UNIMPLEMENTED (("timeval: %p, tzp: %p", tp, tzp));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/isatty.c b/newlib/libc/sys/mmixware/isatty.c
index 1e1db64..a8c89a5 100644
--- a/newlib/libc/sys/mmixware/isatty.c
+++ b/newlib/libc/sys/mmixware/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty for MMIXware.
 
    Copyright (C) 2001, 2008 Hans-Peter Nilsson
@@ -19,5 +20,6 @@
 int
 _isatty (int fd)
 {
+  __A_VARIABLE = 1;
   return fd == 0 || fd == 1 || fd == 2;
 }
diff --git a/newlib/libc/sys/mmixware/kill.c b/newlib/libc/sys/mmixware/kill.c
index c01f53c..578557c 100644
--- a/newlib/libc/sys/mmixware/kill.c
+++ b/newlib/libc/sys/mmixware/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kill for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
diff --git a/newlib/libc/sys/mmixware/link.c b/newlib/libc/sys/mmixware/link.c
index 0629163..4489780 100644
--- a/newlib/libc/sys/mmixware/link.c
+++ b/newlib/libc/sys/mmixware/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* link stub for MMIXware.
 
    Copyright (C) 2002 Hans-Peter Nilsson
@@ -21,5 +22,6 @@ int
 _link ()
 {
   errno = EMLINK;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/lseek.c b/newlib/libc/sys/mmixware/lseek.c
index 13a6ce1..12699d1 100644
--- a/newlib/libc/sys/mmixware/lseek.c
+++ b/newlib/libc/sys/mmixware/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lseek for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
diff --git a/newlib/libc/sys/mmixware/open.c b/newlib/libc/sys/mmixware/open.c
index f0b9fba..9b61b5e 100644
--- a/newlib/libc/sys/mmixware/open.c
+++ b/newlib/libc/sys/mmixware/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* open for MMIXware.
 
    Copyright (C) 2001, 2002 Hans-Peter Nilsson
diff --git a/newlib/libc/sys/mmixware/pipe.c b/newlib/libc/sys/mmixware/pipe.c
index f980bcd..d82243e 100644
--- a/newlib/libc/sys/mmixware/pipe.c
+++ b/newlib/libc/sys/mmixware/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* pipe stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -22,5 +23,6 @@ pipe (int *fd)
 {
   UNIMPLEMENTED (("fd: %p", fd));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/read.c b/newlib/libc/sys/mmixware/read.c
index f0f5e22..5a1bdfe 100644
--- a/newlib/libc/sys/mmixware/read.c
+++ b/newlib/libc/sys/mmixware/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* read for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -27,6 +28,7 @@ _read (int file,
   if ((unsigned int) file >= 32 || _MMIX_allocated_filehandle[file] == 0)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -34,9 +36,12 @@ _read (int file,
     {
       ret = TRAP3f (SYS_Fgets, file, ptr, len);
 
-      if (ret == -1)
+      if (ret == -1) {
+        __A_VARIABLE = 1;
         return 0;
+      }
 
+      __A_VARIABLE = 1;
       return ret;
     }
 
@@ -46,16 +51,20 @@ _read (int file,
      -1-len: an error.  We return -1.
      0: success.  We return len.
      n-len: end-of-file after n chars read.  We return n. */
-  if (ret == 0)
+  if (ret == 0) {
+    __A_VARIABLE = 1;
     return len;
+  }
 
   if (ret == -1 - (long) len)
     {
       /* We don't know the nature of the failure, so this is an
 	 approximation.  */
       errno = EIO;
+      __A_VARIABLE = 1;
       return -1;
     }
 
+  __A_VARIABLE = 1;
   return ret + len;
 }
diff --git a/newlib/libc/sys/mmixware/sbrk.c b/newlib/libc/sys/mmixware/sbrk.c
index f50886d..a23a95f 100644
--- a/newlib/libc/sys/mmixware/sbrk.c
+++ b/newlib/libc/sys/mmixware/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sbrk for MMIXware.
 
    Copyright (C) 2001, 2012 Hans-Peter Nilsson
@@ -55,5 +56,6 @@ _sbrk (size_t incr)
     }
 
   _Sbrk_high += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/newlib/libc/sys/mmixware/stat.c b/newlib/libc/sys/mmixware/stat.c
index b008a82..5443e90 100644
--- a/newlib/libc/sys/mmixware/stat.c
+++ b/newlib/libc/sys/mmixware/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* stat stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -23,5 +24,6 @@ _stat (const char *path, struct stat *st)
 {
   UNIMPLEMENTED (("path: %s, st: %p", path, st));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/time.c b/newlib/libc/sys/mmixware/time.c
index 14be19b..de917e0 100644
--- a/newlib/libc/sys/mmixware/time.c
+++ b/newlib/libc/sys/mmixware/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* time stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -26,5 +27,6 @@ time (time_t *tloc)
   if (tloc)
     *tloc = thetime;
 
+  __A_VARIABLE = 1;
   return thetime;
 }
diff --git a/newlib/libc/sys/mmixware/times.c b/newlib/libc/sys/mmixware/times.c
index 6275ef3..9b2bddc 100644
--- a/newlib/libc/sys/mmixware/times.c
+++ b/newlib/libc/sys/mmixware/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* times stub for MMIXware.
 
    Copyright (C) 2001, 2002 Hans-Peter Nilsson
@@ -21,5 +22,6 @@ clock_t
 _times (struct tms *buffer)
 {
   memset (buffer, 0, sizeof (*buffer));
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/mmixware/unlink.c b/newlib/libc/sys/mmixware/unlink.c
index b70df2d..31864b1 100644
--- a/newlib/libc/sys/mmixware/unlink.c
+++ b/newlib/libc/sys/mmixware/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* unlink stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -19,5 +20,6 @@
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/utime.c b/newlib/libc/sys/mmixware/utime.c
index 47259fc..2d52314 100644
--- a/newlib/libc/sys/mmixware/utime.c
+++ b/newlib/libc/sys/mmixware/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* utime stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -24,5 +25,6 @@ utime (path, times)
 {
   UNIMPLEMENTED (("path: %s, times: %p", path, times));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/wait.c b/newlib/libc/sys/mmixware/wait.c
index 9c66f3b..38302da 100644
--- a/newlib/libc/sys/mmixware/wait.c
+++ b/newlib/libc/sys/mmixware/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wait stub for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -23,5 +24,6 @@ _wait (statusp)
 {
   UNIMPLEMENTED (("statusp: %p", statusp));
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/mmixware/write.c b/newlib/libc/sys/mmixware/write.c
index 74d5fca..806181b 100644
--- a/newlib/libc/sys/mmixware/write.c
+++ b/newlib/libc/sys/mmixware/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* write for MMIXware.
 
    Copyright (C) 2001 Hans-Peter Nilsson
@@ -27,6 +28,7 @@ _write ( int file,
   if ((unsigned int) file >= 32 || _MMIX_allocated_filehandle[file] == 0)
     {
       errno = EBADF;
+      __A_VARIABLE = 1;
       return -1;
     }
 
@@ -35,8 +37,10 @@ _write ( int file,
   if (ret < 0)
     {
       errno = EIO;
+      __A_VARIABLE = 1;
       return -1;
     }
 
+  __A_VARIABLE = 1;
   return len;
 }
diff --git a/newlib/libc/sys/netware/crt0.c b/newlib/libc/sys/netware/crt0.c
index 1d796d0..88c477a 100644
--- a/newlib/libc/sys/netware/crt0.c
+++ b/newlib/libc/sys/netware/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* I have a copy of something that would serve as a NetWare crt0.o,
    but it is copyright by Novell.  */
 
diff --git a/newlib/libc/sys/netware/getpid.c b/newlib/libc/sys/netware/getpid.c
index 9218dfc..f37a909 100644
--- a/newlib/libc/sys/netware/getpid.c
+++ b/newlib/libc/sys/netware/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NetWare version of getpid.  This is supposed to return a unique
    identifier which is used to create temporary file names.  We use
    the thread ID.  I hope this is unique.  */
@@ -7,5 +8,6 @@
 pid_t
 getpid ()
 {
+  __A_VARIABLE = 1;
   return GetThreadID ();
 }
diff --git a/newlib/libc/sys/netware/link.c b/newlib/libc/sys/netware/link.c
index d816d0a..8cde732 100644
--- a/newlib/libc/sys/netware/link.c
+++ b/newlib/libc/sys/netware/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NetWare version of link.  This can not be implemented using an
    MS-DOS file system.  */
 
@@ -13,5 +14,6 @@ link (path1, path2)
      const char *path2;
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/or1k/mlock.c b/newlib/libc/sys/or1k/mlock.c
index ccb8401..3a2cd04 100644
--- a/newlib/libc/sys/or1k/mlock.c
+++ b/newlib/libc/sys/or1k/mlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* malloc-lock.c. Lock malloc.
  *
  * Copyright (C) 2014, Authors
@@ -72,6 +73,7 @@ void __malloc_lock(struct _reent *ptr) {
 	// Increment counter. The lock may be accessed recursively
 	_or1k_malloc_lock_cnt++;
 
+	__A_VARIABLE = 1;
 	return;
 }
 
@@ -90,5 +92,6 @@ void __malloc_unlock(struct _reent *ptr) {
 		or1k_critical_end(restore);
 	}
 
+	__A_VARIABLE = 1;
 	return;
 }
diff --git a/newlib/libc/sys/phoenix/alarm.c b/newlib/libc/sys/phoenix/alarm.c
index 8a5f0ac..be7a781 100644
--- a/newlib/libc/sys/phoenix/alarm.c
+++ b/newlib/libc/sys/phoenix/alarm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -25,5 +26,6 @@
 unsigned int alarm(unsigned int seconds)
 {
 	/* TODO: implement. */
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libc/sys/phoenix/chmod.c b/newlib/libc/sys/phoenix/chmod.c
index fea2290..2f38d36 100644
--- a/newlib/libc/sys/phoenix/chmod.c
+++ b/newlib/libc/sys/phoenix/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int chmod(const char *pathname, mode_t mode)
 	int ret = syscall2(int, SYS_CHMOD, pathname, mode);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,8 +46,10 @@ int fchmod(int fd, mode_t mode)
 	int ret = syscall2(int, SYS_FCHMOD, fd, mode);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/chown.c b/newlib/libc/sys/phoenix/chown.c
index c2cea2c..cfc55b2 100644
--- a/newlib/libc/sys/phoenix/chown.c
+++ b/newlib/libc/sys/phoenix/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int chown(const char *pathname, uid_t owner, gid_t group)
 	int ret = syscall3(int, SYS_CHOWN, pathname, (unsigned int) owner, (unsigned int) group);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
     }
 
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -43,9 +46,11 @@ int fchown(int fd, uid_t owner, gid_t group)
 	int ret = syscall3(int, SYS_FCHOWN, fd, (unsigned int) owner, (unsigned int) group);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -54,8 +59,10 @@ int lchown(const char *pathname, uid_t owner, gid_t group)
 	int ret = syscall3(int, SYS_LCHOWN, pathname, (unsigned int) owner, (unsigned int) group);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/clocks.c b/newlib/libc/sys/phoenix/clocks.c
index 78700cf..8ed19c1 100644
--- a/newlib/libc/sys/phoenix/clocks.c
+++ b/newlib/libc/sys/phoenix/clocks.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int clock_gettime(clockid_t clock_id, struct timespec *tp)
 	int ret = syscall2(int, SYS_CLOCK_GETTIME, clock_id, tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,8 +46,10 @@ int clock_settime(clockid_t clock_id, const struct timespec *tp)
 	int ret = syscall2(int, SYS_CLOCK_SETTIME, clock_id, tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/dup.c b/newlib/libc/sys/phoenix/dup.c
index f355463..d2d24b1 100644
--- a/newlib/libc/sys/phoenix/dup.c
+++ b/newlib/libc/sys/phoenix/dup.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int dup(int oldfd)
 	int ret = fcntl(oldfd, F_DUPFD, 0);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,8 +46,10 @@ int dup2(int oldfd, int newfd)
 	int ret = syscall2(int, SYS_DUP2, oldfd, newfd);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/endmntent.c b/newlib/libc/sys/phoenix/endmntent.c
index ada7607..564c231 100644
--- a/newlib/libc/sys/phoenix/endmntent.c
+++ b/newlib/libc/sys/phoenix/endmntent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -27,5 +28,6 @@
 int endmntent(FILE *fp)
 {
 	fclose(fp);
+	__A_VARIABLE = 1;
 	return 1;
 }
diff --git a/newlib/libc/sys/phoenix/exec.c b/newlib/libc/sys/phoenix/exec.c
index 341ef97..ec14de3 100644
--- a/newlib/libc/sys/phoenix/exec.c
+++ b/newlib/libc/sys/phoenix/exec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,14 +33,17 @@ int execve(const char *filename, char *const argv[], char *const envp[])
 	int ret = syscall3(int, SYS_EXECVE, filename, argv, envp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int _execve(const char *filename, char *const argv[], char *const envp[])
 {
+	__A_VARIABLE = 1;
 	return execve(filename, argv, envp);
 }
 
@@ -47,9 +51,11 @@ void exit(int status)
 {
     fflush(NULL);
 	syscall1(int, SYS_EXIT, status);
+	__A_VARIABLE = 1;
 }
 
 void _exit(int status)
 {
 	exit(status);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/phoenix/fcntl.c b/newlib/libc/sys/phoenix/fcntl.c
index d897065..86472a9 100644
--- a/newlib/libc/sys/phoenix/fcntl.c
+++ b/newlib/libc/sys/phoenix/fcntl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -41,8 +42,10 @@ int fcntl( int fd , int cmd, ...)
 	int ret = syscall3(int, SYS_FCNTL, fd, cmd, arg);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/fork.c b/newlib/libc/sys/phoenix/fork.c
index 7e8d591..01fe77e 100644
--- a/newlib/libc/sys/phoenix/fork.c
+++ b/newlib/libc/sys/phoenix/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -35,14 +36,17 @@ pid_t fork()
 	int ret = syscall3(int, SYS_FORK, 0x10, 0x20, 0x30);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 pid_t vfork()
 {
+	__A_VARIABLE = 1;
 	return fork();
 }
 
@@ -50,6 +54,7 @@ int daemon(int nochdir, int noclose)
 {
 	switch(fork()) {
 	case -1:
+		__A_VARIABLE = 1;
 		return -1;
 	case 0:
 		break;
@@ -57,8 +62,10 @@ int daemon(int nochdir, int noclose)
 		exit(0);
 	}
 
-	if (setsid() == -1)
+	if (setsid() == -1) {
+		__A_VARIABLE = 1;
 		return -1;
+	}
 
 	if (nochdir == 0)
 		chdir("/");
@@ -66,5 +73,6 @@ int daemon(int nochdir, int noclose)
 	if (noclose == 0)
 		freopen("/dev/null", "a+", stdout);
 
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libc/sys/phoenix/fs.c b/newlib/libc/sys/phoenix/fs.c
index bde35e1..085d73d 100644
--- a/newlib/libc/sys/phoenix/fs.c
+++ b/newlib/libc/sys/phoenix/fs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -38,9 +39,11 @@ int mkdir(const char *pathname, mode_t mode)
 	int ret = syscall2(int, SYS_MKDIR, pathname, mode);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -49,9 +52,11 @@ int rmdir(const char *pathname)
 	int ret = syscall1(int, SYS_RMDIR, pathname);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -60,9 +65,11 @@ int chdir(const char *path)
 	int ret = syscall1(int, SYS_SETCWD, path);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -74,9 +81,11 @@ char *getcwd(char *buf, size_t size)
 	int ret = syscall2(int, SYS_GETCWD, buf, size);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return buf;
 }
 
@@ -85,9 +94,11 @@ int unlink(const char *pathname)
 	int ret = syscall1(int, SYS_UNLINK, pathname);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -96,9 +107,11 @@ int	mkfifo(const char *pathname, mode_t mode)
 	int ret = syscall3(int, SYS_OPEN, pathname, O_CREAT, (mode | S_IFIFO));
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -107,9 +120,11 @@ int	mknod(const char *pathname, mode_t mode, dev_t dev)
 	int ret = syscall3(int, SYS_MKNOD, pathname, mode, dev);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -118,13 +133,16 @@ int getdents(unsigned int fd, struct dirent *dirp, unsigned int count)
 	int ret = syscall3(int, SYS_GETDENTS, fd, dirp, count);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int chroot(const char *path)
 {
+	__A_VARIABLE = 1;
 	return chdir(path);
 }
diff --git a/newlib/libc/sys/phoenix/getentropy.c b/newlib/libc/sys/phoenix/getentropy.c
index 097fb90..3e7ba31 100644
--- a/newlib/libc/sys/phoenix/getentropy.c
+++ b/newlib/libc/sys/phoenix/getentropy.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -34,6 +35,7 @@ int getentropy(void *buf, size_t buflen)
 {
 	if (buflen > MAX_ENTROPY) {
 		errno = -EIO;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
@@ -44,5 +46,6 @@ int getentropy(void *buf, size_t buflen)
 		close(fd);
 	}
 
+    __A_VARIABLE = 1;
     return (ret > 0) ? 0 : -1;
 }
diff --git a/newlib/libc/sys/phoenix/getmntent.c b/newlib/libc/sys/phoenix/getmntent.c
index e61d245..40bbfa0 100644
--- a/newlib/libc/sys/phoenix/getmntent.c
+++ b/newlib/libc/sys/phoenix/getmntent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -49,6 +50,7 @@ struct mntent *getmntent_r(FILE *fp, struct mntent *result, char *buffer, int bu
 
 	if (getline(&line, &size, fp) == -1 || feof(fp)) {
 		free(line);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -56,6 +58,7 @@ struct mntent *getmntent_r(FILE *fp, struct mntent *result, char *buffer, int bu
 		if (((buff_ptr + strlen(token) + 1) - buffer) > bufsize) {
 			errno = ENOBUFS;
 			free(line);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 
@@ -80,6 +83,7 @@ struct mntent *getmntent_r(FILE *fp, struct mntent *result, char *buffer, int bu
 			break;
 		default:
 			free(line);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 
@@ -87,6 +91,7 @@ struct mntent *getmntent_r(FILE *fp, struct mntent *result, char *buffer, int bu
 	}
 
 	free(line);
+	__A_VARIABLE = 1;
 	return result;
 }
 
@@ -97,5 +102,6 @@ struct mntent *getmntent(FILE *fp)
 	memset(&result, 0, sizeof(struct mntent));
 	memset(buffer, 0, sizeof(buffer));
 
+	__A_VARIABLE = 1;
 	return getmntent_r(fp, &result, buffer, sizeof(buffer));
 }
diff --git a/newlib/libc/sys/phoenix/getpagesize.c b/newlib/libc/sys/phoenix/getpagesize.c
index 3b39422..2d677e4 100644
--- a/newlib/libc/sys/phoenix/getpagesize.c
+++ b/newlib/libc/sys/phoenix/getpagesize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -27,5 +28,6 @@
 int getpagesize()
 {
 	/* TODO: consider making it a syscall. */
+	__A_VARIABLE = 1;
 	return PHOENIX_PAGESIZE;
 }
diff --git a/newlib/libc/sys/phoenix/groups.c b/newlib/libc/sys/phoenix/groups.c
index b231475..66cc7fa 100644
--- a/newlib/libc/sys/phoenix/groups.c
+++ b/newlib/libc/sys/phoenix/groups.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,9 +34,11 @@ int initgroups(const char *user, gid_t group)
 	/* TODO: implement. */
 	if(user == NULL) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -44,9 +47,11 @@ int getgroups(int size, gid_t list[])
 	int ret = syscall2(int, SYS_GETGROUPS, size, list);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -55,9 +60,11 @@ int setgroups(size_t size, const gid_t *list)
 	int ret = syscall2(int, SYS_SETGROUPS, size, list);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -65,23 +72,27 @@ struct group *getgrent()
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 void setgrent()
 {
 	/* TODO: implement. */
+	__A_VARIABLE = 1;
 }
 
 void endgrent()
 {
 	/* TODO: implement. */
+	__A_VARIABLE = 1;
 }
 
 struct group *getgrnam(const char *name)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -89,6 +100,7 @@ struct group *getgrgid(gid_t gid)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -96,5 +108,6 @@ int setpgrp(pid_t pid, pid_t pgid)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/ids.c b/newlib/libc/sys/phoenix/ids.c
index 7f88edf..e5d911e 100644
--- a/newlib/libc/sys/phoenix/ids.c
+++ b/newlib/libc/sys/phoenix/ids.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -30,11 +31,13 @@
 
 uid_t getuid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETUID);
 }
 
 uid_t geteuid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETEUID);
 }
 
@@ -43,9 +46,11 @@ int setuid(uid_t uid)
 	int ret = syscall1(int, SYS_SETUID, (unsigned int) uid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -54,9 +59,11 @@ int seteuid(uid_t euid)
 	int ret = syscall1(int, SYS_SETEUID, (unsigned int) euid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -65,19 +72,23 @@ int setreuid(uid_t ruid, uid_t euid)
 	int ret = syscall2(int, SYS_SETREUID, (unsigned int) ruid, (unsigned int) euid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 gid_t getgid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETGID);
 }
 
 gid_t getegid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETEGID);
 }
 
@@ -86,9 +97,11 @@ int setgid(gid_t gid)
 	int ret = syscall2(int, SYS_SETGID, (unsigned int) gid, 0);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -97,9 +110,11 @@ int setegid(gid_t egid)
 	int ret = syscall1(int, SYS_SETEGID, (unsigned int) egid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -108,9 +123,11 @@ int setregid(gid_t rgid, gid_t egid)
 	int ret = syscall2(int, SYS_SETREGID, (unsigned int) rgid, (unsigned int) egid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -119,19 +136,23 @@ int setpgid(pid_t pid, pid_t pgid)
 	int ret = syscall2(int, SYS_SETGID, pgid, pid);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 pid_t getsid(pid_t pid)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
 pid_t setsid()
 {
+	__A_VARIABLE = 1;
 	return getpid();
 }
diff --git a/newlib/libc/sys/phoenix/io.c b/newlib/libc/sys/phoenix/io.c
index 1e059ee..ed36b83 100644
--- a/newlib/libc/sys/phoenix/io.c
+++ b/newlib/libc/sys/phoenix/io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -44,9 +45,11 @@ int open(const char *pathname, int flags, ...)
 	int ret = syscall3(int, SYS_OPEN, pathname, flags, mode);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -55,9 +58,11 @@ ssize_t read(int fd, void *buf, size_t count)
 	int ret = syscall3(int, SYS_READ, fd, buf, count);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -66,9 +71,11 @@ ssize_t write(int fd, const void *buf, size_t count)
 	int ret = syscall3(int, SYS_WRITE, fd, buf, count);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -77,9 +84,11 @@ off_t lseek(int fd, off_t offset, int whence)
 	int ret = syscall3(int, SYS_LSEEK, fd, offset, whence);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -88,13 +97,16 @@ int close(int fd)
 	int ret = syscall1(int, SYS_CLOSE, fd);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int _close(int fd)
 {
+	__A_VARIABLE = 1;
 	return close(fd);
 }
diff --git a/newlib/libc/sys/phoenix/ioctl.c b/newlib/libc/sys/phoenix/ioctl.c
index 4971606..e4c20d1 100644
--- a/newlib/libc/sys/phoenix/ioctl.c
+++ b/newlib/libc/sys/phoenix/ioctl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -36,8 +37,10 @@ int ioctl(int d, int request, ...)
 
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/mmap.c b/newlib/libc/sys/phoenix/mmap.c
index ea71307..281ab55 100644
--- a/newlib/libc/sys/phoenix/mmap.c
+++ b/newlib/libc/sys/phoenix/mmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -79,8 +80,10 @@ int munmap(void *addr, size_t length)
 	int ret = syscall2(int, SYS_MUNMAP, addr, length);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/mount.c b/newlib/libc/sys/phoenix/mount.c
index 859c8ec..4ce2aee 100644
--- a/newlib/libc/sys/phoenix/mount.c
+++ b/newlib/libc/sys/phoenix/mount.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,9 +32,11 @@ int mount(const char *source, const char *target, const char *filesystemtype, un
 	int ret = syscall5(int, SYS_MOUNT, source, target, filesystemtype, mountflags, data);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -42,13 +45,16 @@ int umount2(const char *target, int flags)
 	int ret = syscall2(int, SYS_UMOUNT, target, flags);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int umount(const char *target)
 {
+	__A_VARIABLE = 1;
 	return umount2(target, 0);
 }
diff --git a/newlib/libc/sys/phoenix/nanosleep.c b/newlib/libc/sys/phoenix/nanosleep.c
index 0424233..1450f74 100644
--- a/newlib/libc/sys/phoenix/nanosleep.c
+++ b/newlib/libc/sys/phoenix/nanosleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,8 +34,10 @@ int nanosleep(const struct timespec *req, struct timespec *rem)
 	int ret = syscall2(int, SYS_NANOSLEEP, req, rem);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/net/domainname.c b/newlib/libc/sys/phoenix/net/domainname.c
index 12ed1fe..97fc5ca 100644
--- a/newlib/libc/sys/phoenix/net/domainname.c
+++ b/newlib/libc/sys/phoenix/net/domainname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -34,9 +35,11 @@ int getdomainname(char *name, size_t len)
 	int ret = syscall3(int, SYS_DOMAINNAME, name, len, NAME_GET);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -45,8 +48,10 @@ int setdomainname(const char *name, size_t len)
 	int ret = syscall3(int, SYS_DOMAINNAME, name, len, NAME_SET);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/net/freeaddrinfo.c b/newlib/libc/sys/phoenix/net/freeaddrinfo.c
index 19b8bd7..fac8d29 100644
--- a/newlib/libc/sys/phoenix/net/freeaddrinfo.c
+++ b/newlib/libc/sys/phoenix/net/freeaddrinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The Inner Net License, Version 2.00
 
   The author(s) grant permission for redistribution and use in source and
@@ -49,4 +50,5 @@ void freeaddrinfo(struct addrinfo *res)
       free(p->ai_canonname);
       free(p);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/phoenix/net/getaddrinfo.c b/newlib/libc/sys/phoenix/net/getaddrinfo.c
index ad9166d..9147382 100644
--- a/newlib/libc/sys/phoenix/net/getaddrinfo.c
+++ b/newlib/libc/sys/phoenix/net/getaddrinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Mar  8, 2000 by Hajimu UMEMOTO <ume@mahoroba.org>
  * $Id: getaddrinfo.c,v 1.2 2002/05/22 17:56:56 snsimon Exp $
@@ -83,9 +84,11 @@ static struct addrinfo *malloc_ai(int port, u_long addr, int socktype, int proto
 		((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;
 		ai->ai_socktype = socktype;
 		ai->ai_protocol = proto;
+		__A_VARIABLE = 1;
 		return ai;
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
diff --git a/newlib/libc/sys/phoenix/net/gethostbyaddr.c b/newlib/libc/sys/phoenix/net/gethostbyaddr.c
index 0a40a44..2cd467b 100644
--- a/newlib/libc/sys/phoenix/net/gethostbyaddr.c
+++ b/newlib/libc/sys/phoenix/net/gethostbyaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,5 +30,6 @@ struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
diff --git a/newlib/libc/sys/phoenix/net/gethostbyname.c b/newlib/libc/sys/phoenix/net/gethostbyname.c
index a7dbe6a..7e67726 100644
--- a/newlib/libc/sys/phoenix/net/gethostbyname.c
+++ b/newlib/libc/sys/phoenix/net/gethostbyname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,5 +30,6 @@ struct hostent *gethostbyname(const char *name)
 {
 	/* TODO: implement. */ 
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
diff --git a/newlib/libc/sys/phoenix/net/getnameinfo.c b/newlib/libc/sys/phoenix/net/getnameinfo.c
index db670f7..9e70dc8 100644
--- a/newlib/libc/sys/phoenix/net/getnameinfo.c
+++ b/newlib/libc/sys/phoenix/net/getnameinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,5 +30,6 @@ int	getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_
 {
 	/* TODO: implement. */ 
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return EAI_SYSTEM;
 }
diff --git a/newlib/libc/sys/phoenix/net/getservbyname.c b/newlib/libc/sys/phoenix/net/getservbyname.c
index 97ac465..af71355 100644
--- a/newlib/libc/sys/phoenix/net/getservbyname.c
+++ b/newlib/libc/sys/phoenix/net/getservbyname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,5 +30,6 @@ struct servent *getservbyname(const char *name, const char *proto)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
diff --git a/newlib/libc/sys/phoenix/net/getservbyport.c b/newlib/libc/sys/phoenix/net/getservbyport.c
index ac23fc8..6af8cba 100644
--- a/newlib/libc/sys/phoenix/net/getservbyport.c
+++ b/newlib/libc/sys/phoenix/net/getservbyport.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,5 +30,6 @@ struct servent *getservbyport(int port, const char *proto)
 {
 	/* TODO: implement. */ 
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
diff --git a/newlib/libc/sys/phoenix/net/herror.c b/newlib/libc/sys/phoenix/net/herror.c
index f45ae65..6104807 100644
--- a/newlib/libc/sys/phoenix/net/herror.c
+++ b/newlib/libc/sys/phoenix/net/herror.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -29,10 +30,12 @@
 const char *hstrerror(int err)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return NULL;
 }
   
 int *__h_errno_location()
 {
+	__A_VARIABLE = 1;
 	return &(_REENT->_new._reent._h_errno);
 }
diff --git a/newlib/libc/sys/phoenix/net/hostname.c b/newlib/libc/sys/phoenix/net/hostname.c
index 280750b..b101655 100644
--- a/newlib/libc/sys/phoenix/net/hostname.c
+++ b/newlib/libc/sys/phoenix/net/hostname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -34,9 +35,11 @@ int gethostname(char *name, size_t len)
 	int ret = syscall3(int, SYS_HOSTNAME, name, len, NAME_GET);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -45,8 +48,10 @@ int sethostname(const char *name, size_t len)
 	int ret = syscall3(int, SYS_HOSTNAME, name, len, NAME_SET);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_addr.c b/newlib/libc/sys/phoenix/net/inet_addr.c
index a95b6e2..b7278d2 100644
--- a/newlib/libc/sys/phoenix/net/inet_addr.c
+++ b/newlib/libc/sys/phoenix/net/inet_addr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: inet_addr.c,v 1.5 2001/08/20 02:32:40 itojun Exp $	*/
 
 /*
@@ -63,8 +64,11 @@ in_addr_t inet_addr(const char *cp)
 {
 	struct in_addr val;
 
-	if (inet_aton(cp, &val))
+	if (inet_aton(cp, &val)) {
+		__A_VARIABLE = 1;
 		return val.s_addr;
+	}
 
+	__A_VARIABLE = 1;
 	return INADDR_NONE;	
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_aton.c b/newlib/libc/sys/phoenix/net/inet_aton.c
index 9013bca..0324515 100644
--- a/newlib/libc/sys/phoenix/net/inet_aton.c
+++ b/newlib/libc/sys/phoenix/net/inet_aton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: inet_addr.c,v 1.5 2001/08/20 02:32:40 itojun Exp $	*/
 
 /*
diff --git a/newlib/libc/sys/phoenix/net/inet_lnaof.c b/newlib/libc/sys/phoenix/net/inet_lnaof.c
index 8af1e22..9dd313e 100644
--- a/newlib/libc/sys/phoenix/net/inet_lnaof.c
+++ b/newlib/libc/sys/phoenix/net/inet_lnaof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
diff --git a/newlib/libc/sys/phoenix/net/inet_makeaddr.c b/newlib/libc/sys/phoenix/net/inet_makeaddr.c
index 5af4541..d62b605 100644
--- a/newlib/libc/sys/phoenix/net/inet_makeaddr.c
+++ b/newlib/libc/sys/phoenix/net/inet_makeaddr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -47,5 +48,6 @@ struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host)
 		in.s_addr = net | host;
 
 	in.s_addr = htonl(in.s_addr);
+	__A_VARIABLE = 1;
 	return in;
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_net_ntop.c b/newlib/libc/sys/phoenix/net/inet_net_ntop.c
index 7b25143..1582b1c 100644
--- a/newlib/libc/sys/phoenix/net/inet_net_ntop.c
+++ b/newlib/libc/sys/phoenix/net/inet_net_ntop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
  *
@@ -39,6 +40,7 @@ static char *inet_net_ntop_ipv4(const u_char *src, int bits, char *dst, size_t s
 
 	if (bits < 0 || bits > 32) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return (NULL);
 	}
 
@@ -88,9 +90,11 @@ static char *inet_net_ntop_ipv4(const u_char *src, int bits, char *dst, size_t s
 		goto emsgsize;
 
 	dst += SPRINTF((dst, "/%u", bits));
+	__A_VARIABLE = 1;
 	return (odst);
 emsgsize:
 	errno = EMSGSIZE;
+	__A_VARIABLE = 1;
 	return (NULL);
 }
 
@@ -98,10 +102,12 @@ char *inet_net_ntop(int af, const void *netp, int bits, char *pres, size_t psize
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return inet_net_ntop_ipv4(netp, bits, pres, psize);
 
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_net_pton.c b/newlib/libc/sys/phoenix/net/inet_net_pton.c
index 071ada9..6c06535 100644
--- a/newlib/libc/sys/phoenix/net/inet_net_pton.c
+++ b/newlib/libc/sys/phoenix/net/inet_net_pton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
  *
@@ -167,13 +168,16 @@ static int inet_net_pton_ipv4(const char *src, u_char *dst, size_t size)
 		*dst++ = '\0';
 	}
 
+	__A_VARIABLE = 1;
 	return (bits);
 enoent:
 	errno = ENOENT;
+	__A_VARIABLE = 1;
 	return -1;
 
 emsgsize:
 	errno = EMSGSIZE;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -181,10 +185,12 @@ int inet_net_pton(int af, const char *pres, void *netp, size_t nsize)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return inet_net_pton_ipv4(pres, netp, nsize);
 
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_netof.c b/newlib/libc/sys/phoenix/net/inet_netof.c
index b92ce20..19a420b 100644
--- a/newlib/libc/sys/phoenix/net/inet_netof.c
+++ b/newlib/libc/sys/phoenix/net/inet_netof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
diff --git a/newlib/libc/sys/phoenix/net/inet_network.c b/newlib/libc/sys/phoenix/net/inet_network.c
index 831b8ee..5de1ef3 100644
--- a/newlib/libc/sys/phoenix/net/inet_network.c
+++ b/newlib/libc/sys/phoenix/net/inet_network.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -54,8 +55,10 @@ again:
 
 	while ((c = *cp) != 0) {
 		if (isdigit(c)) {
-			if (base == 8 && (c == '8' || c == '9'))
+			if (base == 8 && (c == '8' || c == '9')) {
+				__A_VARIABLE = 1;
 				return INADDR_NONE;
+			}
 
 			val = (val * base) + (c - '0');
 			cp++;
@@ -73,22 +76,30 @@ again:
 		break;
 	}
 
-	if (!digit)
+	if (!digit) {
+		__A_VARIABLE = 1;
 		return INADDR_NONE;
+	}
 
-	if (pp >= parts + 4 || val > 0xff)
+	if (pp >= parts + 4 || val > 0xff) {
+		__A_VARIABLE = 1;
 		return INADDR_NONE;
+	}
 
 	if (*cp == '.') {
 		*pp++ = val, cp++;
 		goto again;
 	}
 
-	if (*cp && !isspace(*cp))
+	if (*cp && !isspace(*cp)) {
+		__A_VARIABLE = 1;
 		return INADDR_NONE;
+	}
 
-	if (pp >= parts + 4 || val > 0xff)
+	if (pp >= parts + 4 || val > 0xff) {
+		__A_VARIABLE = 1;
 		return INADDR_NONE;
+	}
 
 	*pp++ = val;
 	n = pp - parts;
@@ -98,5 +109,6 @@ again:
 		val |= parts[i] & 0xff;
 	}
 
+	__A_VARIABLE = 1;
 	return val;
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_ntoa.c b/newlib/libc/sys/phoenix/net/inet_ntoa.c
index 211049c..48c5f03 100644
--- a/newlib/libc/sys/phoenix/net/inet_ntoa.c
+++ b/newlib/libc/sys/phoenix/net/inet_ntoa.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,5 +32,6 @@ char *inet_ntoa(struct in_addr in)
 {
 	unsigned char *bytes = (unsigned char *) &in;
 	snprintf(static_buffer, sizeof(static_buffer), "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
+	__A_VARIABLE = 1;
 	return static_buffer;
 }
diff --git a/newlib/libc/sys/phoenix/net/inet_ntop.c b/newlib/libc/sys/phoenix/net/inet_ntop.c
index 5ad0711..80c0586 100644
--- a/newlib/libc/sys/phoenix/net/inet_ntop.c
+++ b/newlib/libc/sys/phoenix/net/inet_ntop.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 1996 by Internet Software Consortium.
  *
  * Permission to use, copy, modify, and distribute this software for any
@@ -40,10 +41,12 @@ static const char *inet_ntop4(const u_char *src, char *dst, socklen_t size)
 
 	if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) > size) {
 		errno = ENOSPC;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	strcpy(dst, tmp);
+	__A_VARIABLE = 1;
 	return dst;
 }
 
@@ -124,8 +127,10 @@ static const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)
 		/* Is this address an encapsulated IPv4? */
 		if (i == 6 && best.base == 0 &&
 		        (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
-			if (!inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp)))
+			if (!inet_ntop4(src + 12, tp, sizeof tmp - (tp - tmp))) {
+				__A_VARIABLE = 1;
 				return NULL;
+			}
 
 			tp += strlen(tp);
 			break;
@@ -146,10 +151,12 @@ static const char *inet_ntop6(const u_char *src, char *dst, socklen_t size)
 	 */
 	if ((socklen_t)(tp - tmp) > size) {
 		errno = ENOSPC;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	strcpy(dst, tmp);
+	__A_VARIABLE = 1;
 	return dst;
 }
 
@@ -157,13 +164,16 @@ const char *inet_ntop(int af, const void *src, char *dst, socklen_t size)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return inet_ntop4(src, dst, size);
 
 	case AF_INET6:
+		__A_VARIABLE = 1;
 		return inet_ntop6(src, dst, size);
 
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
diff --git a/newlib/libc/sys/phoenix/net/inet_pton.c b/newlib/libc/sys/phoenix/net/inet_pton.c
index 3b3296a..8f915fc 100644
--- a/newlib/libc/sys/phoenix/net/inet_pton.c
+++ b/newlib/libc/sys/phoenix/net/inet_pton.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$KAME: inet_pton.c,v 1.5 2001/08/20 02:32:40 itojun Exp $	*/
 
 /* Copyright (c) 1996 by Internet Software Consortium.
@@ -94,8 +95,10 @@ static int inet_pton6(const char *src, u_char *dst)
 
 	/* Leading :: requires some special handling. */
 	if (*src == ':')
-		if (*++src != ':')
+		if (*++src != ':') {
+			__A_VARIABLE = 1;
 			return 0;
+		}
 
 	curtok = src;
 	saw_xdigit = 0;
@@ -111,8 +114,10 @@ static int inet_pton6(const char *src, u_char *dst)
 			val <<= 4;
 			val |= (pch - xdigits);
 
-			if (val > 0xffff)
+			if (val > 0xffff) {
+				__A_VARIABLE = 1;
 				return 0;
+			}
 
 			saw_xdigit = 1;
 			continue;
@@ -122,15 +127,19 @@ static int inet_pton6(const char *src, u_char *dst)
 			curtok = src;
 
 			if (!saw_xdigit) {
-				if (colonp)
+				if (colonp) {
+					__A_VARIABLE = 1;
 					return 0;
+				}
 
 				colonp = tp;
 				continue;
 			}
 
-			if (tp + NS_INT16SZ > endp)
+			if (tp + NS_INT16SZ > endp) {
+				__A_VARIABLE = 1;
 				return 0;
+			}
 
 			*tp++ = (u_char) (val >> 8) & 0xff;
 			*tp++ = (u_char) val & 0xff;
@@ -146,12 +155,15 @@ static int inet_pton6(const char *src, u_char *dst)
 			break;	/* '\0' was seen by inet_pton4(). */
 		}
 
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
 	if (saw_xdigit) {
-		if (tp + NS_INT16SZ > endp)
+		if (tp + NS_INT16SZ > endp) {
+			__A_VARIABLE = 1;
 			return 0;
+		}
 
 		*tp++ = (u_char) (val >> 8) & 0xff;
 		*tp++ = (u_char) val & 0xff;
@@ -173,10 +185,13 @@ static int inet_pton6(const char *src, u_char *dst)
 		tp = endp;
 	}
 
-	if (tp != endp)
+	if (tp != endp) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
 	memcpy(dst, tmp, NS_IN6ADDRSZ);
+	__A_VARIABLE = 1;
 	return 1;
 }
 
@@ -184,13 +199,16 @@ int inet_pton(int af, const char *src, void *dst)
 {
 	switch (af) {
 	case AF_INET:
+		__A_VARIABLE = 1;
 		return inet_pton4(src, dst);
 
 	case AF_INET6:
+		__A_VARIABLE = 1;
 		return inet_pton6(src, dst);
 
 	default:
 		errno = EAFNOSUPPORT;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
diff --git a/newlib/libc/sys/phoenix/net/nametoindex.c b/newlib/libc/sys/phoenix/net/nametoindex.c
index b11b10f..4c1d234 100644
--- a/newlib/libc/sys/phoenix/net/nametoindex.c
+++ b/newlib/libc/sys/phoenix/net/nametoindex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ unsigned int if_nametoindex(const char *ifname)
 {
 	if (strcmp(ifname, "eth0") != 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
+	__A_VARIABLE = 1;
 	return 1;
 }
 
@@ -42,9 +45,11 @@ char *if_indextoname(unsigned int ifindex, char *ifname)
 {
 	if (ifindex != 1) {
 		errno = ENXIO;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	strcpy(ifname, "eth0");
+	__A_VARIABLE = 1;
 	return ifname;
 }
diff --git a/newlib/libc/sys/phoenix/net/network.c b/newlib/libc/sys/phoenix/net/network.c
index 2f49574..2f8dc48 100644
--- a/newlib/libc/sys/phoenix/net/network.c
+++ b/newlib/libc/sys/phoenix/net/network.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,9 +32,11 @@ int network_setUp(const char *interface)
 	int ret = syscall2(int, SYS_NET_CONFIGURE, interface, 1);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -42,8 +45,10 @@ int network_setDown(const char *interface)
 	int ret = syscall2(int, SYS_NET_CONFIGURE, interface, 0);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/phoenix.c b/newlib/libc/sys/phoenix/phoenix.c
index 8d57546..dee21c8 100644
--- a/newlib/libc/sys/phoenix/phoenix.c
+++ b/newlib/libc/sys/phoenix/phoenix.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
diff --git a/newlib/libc/sys/phoenix/pid.c b/newlib/libc/sys/phoenix/pid.c
index 09b2636..36ba4cb 100644
--- a/newlib/libc/sys/phoenix/pid.c
+++ b/newlib/libc/sys/phoenix/pid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -28,10 +29,12 @@
 
 pid_t getpid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETPID);
 }
 
 pid_t getppid()
 {
+	__A_VARIABLE = 1;
 	return syscall0(int, SYS_GETPPID);
 }
diff --git a/newlib/libc/sys/phoenix/pipe.c b/newlib/libc/sys/phoenix/pipe.c
index 4743362..920aae8 100644
--- a/newlib/libc/sys/phoenix/pipe.c
+++ b/newlib/libc/sys/phoenix/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,8 +32,10 @@ int pipe(int pipefd[2])
 	int ret = syscall1(int, SYS_PIPE, pipefd);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/poll.c b/newlib/libc/sys/phoenix/poll.c
index f15e1ca..b2709e6 100644
--- a/newlib/libc/sys/phoenix/poll.c
+++ b/newlib/libc/sys/phoenix/poll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,8 +33,10 @@ int poll(struct pollfd *fds, nfds_t nfds, int timeout)
 	int ret = syscall3(int, SYS_POLL, fds, nfds, timeout);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/realpath.c b/newlib/libc/sys/phoenix/realpath.c
index 0727402..4430d79 100644
--- a/newlib/libc/sys/phoenix/realpath.c
+++ b/newlib/libc/sys/phoenix/realpath.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Written 2000 by Werner Almesberger */
 
 #include <errno.h>
@@ -80,25 +81,35 @@ char *realpath(const char *path, char *resolved_path)
 
 	if (!*path) {
 		errno = ENOENT;
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
-	if (!getcwd(cwd, sizeof(cwd)))
+	if (!getcwd(cwd, sizeof(cwd))) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
     
 	strcpy(resolved_path, "/");
-	if (resolve_path(cwd, resolved_path, resolved_path))
+	if (resolve_path(cwd, resolved_path, resolved_path)) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
 	strcat(resolved_path, "/");
 	path_copy = strdup(path);
-	if (!path_copy)
+	if (!path_copy) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
 	res = resolve_path(path_copy, resolved_path, strchr(resolved_path, 0));
 	free(path_copy);
-	if (res)
+	if (res) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 
+	__A_VARIABLE = 1;
 	return resolved_path;
 }
diff --git a/newlib/libc/sys/phoenix/reboot.c b/newlib/libc/sys/phoenix/reboot.c
index 4769d78..0a07957 100644
--- a/newlib/libc/sys/phoenix/reboot.c
+++ b/newlib/libc/sys/phoenix/reboot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,8 +32,10 @@ int reboot(int how)
 	int ret = syscall1(int, SYS_REBOOT, how);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/resource.c b/newlib/libc/sys/phoenix/resource.c
index 12ba5b2..9a809f4 100644
--- a/newlib/libc/sys/phoenix/resource.c
+++ b/newlib/libc/sys/phoenix/resource.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -35,16 +36,19 @@ int getpriority(int which, id_t who)
 	struct sched_param param;
 	if (which != PRIO_PROCESS) {
 		errno = ENOSYS;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	int ret = sched_getparam(who, &param);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	errno = EOK;
+	__A_VARIABLE = 1;
 	return param.sched_priority;
 }
 
@@ -53,6 +57,7 @@ int setpriority(int which, id_t who, int prio)
 	struct sched_param param;
 	if (which != PRIO_PROCESS) {
 		errno = ENOSYS;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
@@ -60,9 +65,11 @@ int setpriority(int which, id_t who, int prio)
 	int ret = sched_setparam(who, &param);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -70,6 +77,7 @@ int getrlimit(int resource, struct rlimit *rlim)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -77,6 +85,7 @@ int setrlimit(int resource, const struct rlimit *rlim)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -84,5 +93,6 @@ int getrusage(int who, struct rusage *usage)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/sbrk.c b/newlib/libc/sys/phoenix/sbrk.c
index 64fba4d..e002cca 100644
--- a/newlib/libc/sys/phoenix/sbrk.c
+++ b/newlib/libc/sys/phoenix/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -38,11 +39,13 @@ void *sbrk(intptr_t increment)
 		int ret= syscall2(int, SYS_SBRK, increment, heap_end);
 		if (ret != 0) {
 			errno = -ret;
+			__A_VARIABLE = 1;
 			return (void *) -1;
 		}
 
 		heap_end += increment;
 	}
 
+	__A_VARIABLE = 1;
 	return (void *) prev_heap_end;
 }
diff --git a/newlib/libc/sys/phoenix/sched.c b/newlib/libc/sys/phoenix/sched.c
index 9e92363..edf43a4 100644
--- a/newlib/libc/sys/phoenix/sched.c
+++ b/newlib/libc/sys/phoenix/sched.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -34,9 +35,11 @@ int sched_getparam(pid_t pid, struct sched_param *param)
 	int ret = syscall2(int, SYS_SCHED_GETPARAM, pid, param);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -45,9 +48,11 @@ int sched_setparam(pid_t pid, const struct sched_param *param)
 	int ret = syscall2(int, SYS_SCHED_SETPARAM, pid, param);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -56,9 +61,11 @@ int sched_getscheduler(pid_t pid)
 	int ret = syscall1(int, SYS_SCHED_GETSCHEDULER, pid);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -67,9 +74,11 @@ int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param)
 	int ret = syscall3(int, SYS_SCHED_SETSCHEDULER, pid, policy, param);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -78,9 +87,11 @@ int sched_get_priority_max(int policy)
 	int ret = syscall1(int, SYS_SCHED_GET_PRIORITY_MAX, policy);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 	
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -89,9 +100,11 @@ int sched_get_priority_min(int policy)
 	int ret = syscall1(int, SYS_SCHED_GET_PRIORITY_MIN, policy);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -100,8 +113,10 @@ int sched_yield(void)
 	int ret = syscall0(int, SYS_SCHED_YIELD);
 	if(ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/select.c b/newlib/libc/sys/phoenix/select.c
index 2374163..44967c2 100644
--- a/newlib/libc/sys/phoenix/select.c
+++ b/newlib/libc/sys/phoenix/select.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,8 +34,10 @@ int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struc
 	int ret = syscall5(int, SYS_SELECT, nfds, readfds, writefds, exceptfds, timeout);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/semaphore.c b/newlib/libc/sys/phoenix/semaphore.c
index 617ffc5..92f8510 100644
--- a/newlib/libc/sys/phoenix/semaphore.c
+++ b/newlib/libc/sys/phoenix/semaphore.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -37,12 +38,14 @@
 int sem_init(sem_t *sem, int pshared, unsigned int value)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
 int sem_destroy(sem_t *sem)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -103,17 +106,20 @@ int sem_close(sem_t *sem)
 {
 	if (sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	close(sem->fd);
 	free(sem);
 
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 int sem_unlink(const char *name)
 {
+	__A_VARIABLE = 1;
 	return unlink(name);
 }
 
@@ -121,9 +127,11 @@ int sem_wait(sem_t *sem)
 {
 	if(sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ioctl(sem->fd, IPC_SEM_DOWN, 0);
 }
 
@@ -131,9 +139,11 @@ int sem_timedwait(sem_t * sem, const struct timespec *abs_timeout)
 {
 	if(sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ioctl(sem->fd, IPC_SEM_DOWN_TIMEOUT, 0);
 }
 
@@ -141,9 +151,11 @@ int sem_trywait(sem_t *sem)
 {
 	if(sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ioctl(sem->fd, IPC_SEM_TRYDOWN, 0);
 }
 
@@ -151,9 +163,11 @@ int sem_post(sem_t *sem)
 {
 	if(sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ioctl(sem->fd, IPC_SEM_UP, 0);
 }
 
@@ -161,8 +175,10 @@ int sem_getvalue (sem_t *sem, int *sval)
 {
 	if(sem == NULL || sem->fd < 0) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ioctl(sem->fd, IPC_SEM_GETVAL, (unsigned long) sval);
 }
diff --git a/newlib/libc/sys/phoenix/setmntent.c b/newlib/libc/sys/phoenix/setmntent.c
index 52cd8b3..f685c1b 100644
--- a/newlib/libc/sys/phoenix/setmntent.c
+++ b/newlib/libc/sys/phoenix/setmntent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -26,5 +27,6 @@
 
 FILE *setmntent(const char *filename, const char *type)
 {
+	__A_VARIABLE = 1;
 	return fopen(filename, type);
 }
diff --git a/newlib/libc/sys/phoenix/shm.c b/newlib/libc/sys/phoenix/shm.c
index caccd48..aebd014 100644
--- a/newlib/libc/sys/phoenix/shm.c
+++ b/newlib/libc/sys/phoenix/shm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -48,6 +49,7 @@ int shm_open(const char *name, int oflag, mode_t mode)
 
 		if (flags == -1) {
 			close(fd);
+			__A_VARIABLE = 1;
 			return -1;
 		}
 	}
@@ -55,14 +57,17 @@ int shm_open(const char *name, int oflag, mode_t mode)
 	if (fd != -1 && (oflag | O_CREAT)) {
 		if (ioctl(fd, IPC_SHM_INIT, 0) < 0) {
 			close(fd);
+			__A_VARIABLE = 1;
 			return -1;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 int shm_unlink(const char *name)
 {
+	__A_VARIABLE = 1;
 	return unlink(name);
 }
diff --git a/newlib/libc/sys/phoenix/signal.c b/newlib/libc/sys/phoenix/signal.c
index eca7896..1e3052b 100644
--- a/newlib/libc/sys/phoenix/signal.c
+++ b/newlib/libc/sys/phoenix/signal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,9 +34,11 @@ int kill(pid_t pid, int sig)
 	int ret = syscall2(int, SYS_KILL, pid, sig);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,6 +46,7 @@ sighandler_t signal(int signum, sighandler_t handler)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return SIG_ERR;
 }
 
@@ -50,6 +54,7 @@ int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -57,6 +62,7 @@ int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -64,6 +70,7 @@ int sigsuspend(const sigset_t *mask)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -71,5 +78,6 @@ int raise(int sig)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/socket.c b/newlib/libc/sys/phoenix/socket.c
index 39e4ab2..73f9189 100644
--- a/newlib/libc/sys/phoenix/socket.c
+++ b/newlib/libc/sys/phoenix/socket.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,9 +34,11 @@ int socket(int domain, int type, int protocol)
 	int ret = syscall3(int, SYS_SOCKET, domain, type, protocol);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -44,9 +47,11 @@ int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
 	int ret = syscall3(int, SYS_BIND, sockfd, addr, addrlen);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -55,9 +60,11 @@ int listen(int sockfd, int backlog)
 	int ret = syscall2(int, SYS_LISTEN, sockfd, backlog);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -66,9 +73,11 @@ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
 	int ret = syscall3(int, SYS_ACCEPT, sockfd, addr, addrlen);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -77,9 +86,11 @@ int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
 	int ret = syscall3(int, SYS_CONNECT, sockfd, addr, addrlen);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -90,14 +101,17 @@ int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sock
 	int ret = syscall1(int, SYS_SENDTO, &args);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int send(int sockfd, const void *buf, size_t len, int flags)
 {
+    __A_VARIABLE = 1;
     return sendto(sockfd, buf, len, flags, NULL, 0);
 }
 
@@ -108,14 +122,17 @@ int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_
 	int ret = syscall1(int, SYS_RECVFROM, &args);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int recv(int sockfd, void *buf, size_t len, int flags)
 {
+	__A_VARIABLE = 1;
 	return recvfrom(sockfd, buf, len, flags, NULL, NULL);
 }
 
@@ -123,6 +140,7 @@ int shutdown(int sockfd, int how)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -131,8 +149,10 @@ int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
 	int ret = syscall3(int, SYS_GETPEERNAME, sockfd, addr, addrlen);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/sockopt.c b/newlib/libc/sys/phoenix/sockopt.c
index 6486e7b..148e636 100644
--- a/newlib/libc/sys/phoenix/sockopt.c
+++ b/newlib/libc/sys/phoenix/sockopt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -35,9 +36,11 @@ int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
 	int ret = syscall3(int, SYS_GETSOCKNAME, sockfd, addr, addrlen);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -52,10 +55,12 @@ int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optl
 	int ret = ioctl(sockfd, IOC_GETSOCKOPT, &args);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	*optlen = args.optlen;
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -70,8 +75,10 @@ int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t
 	int ret = ioctl(sockfd, IOC_SETSOCKOPT, &args);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/stat.c b/newlib/libc/sys/phoenix/stat.c
index aec0367..490573e 100644
--- a/newlib/libc/sys/phoenix/stat.c
+++ b/newlib/libc/sys/phoenix/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int stat(const char *pathname, struct stat *buf)
 	int ret = syscall2(int, SYS_STAT, pathname, buf);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,9 +46,11 @@ int fstat(int fd, struct stat *buf)
 	int ret = syscall2(int, SYS_FSTAT, fd, buf);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -54,13 +59,16 @@ int lstat(const char *pathname, struct stat *buf)
 	int ret = syscall2(int, SYS_LSTAT, pathname, buf);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 mode_t umask(mode_t mask)
 {
+	__A_VARIABLE = 1;
 	return syscall1(int, SYS_UMASK, mask);
 }
diff --git a/newlib/libc/sys/phoenix/statfs.c b/newlib/libc/sys/phoenix/statfs.c
index 3b9202a..a20dff3 100644
--- a/newlib/libc/sys/phoenix/statfs.c
+++ b/newlib/libc/sys/phoenix/statfs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,8 +33,10 @@ int statfs(const char *path, struct statfs *buf)
 	int ret = syscall2(int, SYS_STATFS, path, buf);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/symlink.c b/newlib/libc/sys/phoenix/symlink.c
index 90fade0..8176958 100644
--- a/newlib/libc/sys/phoenix/symlink.c
+++ b/newlib/libc/sys/phoenix/symlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -34,6 +35,7 @@ int symlink(const char *target, const char *linkpath)
 		ret = -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -42,9 +44,11 @@ int readlink(const char *pathname, char *buf, size_t bufsize)
 	int ret = syscall3(int, SYS_READLINK, pathname, buf, bufsize);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -53,8 +57,10 @@ int link(const char *oldpath, const char *newpath)
 	int ret = syscall2(int, SYS_LINK, oldpath, newpath);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/sync.c b/newlib/libc/sys/phoenix/sync.c
index 6f72640..258edb9 100644
--- a/newlib/libc/sys/phoenix/sync.c
+++ b/newlib/libc/sys/phoenix/sync.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -31,6 +32,7 @@ void sync()
 	int ret = syscall0(int, SYS_SYNC);
 	if (ret < 0)
 		errno = -ret;
+	__A_VARIABLE = 1;
 }
 
 int fsync(int fd)
@@ -38,13 +40,16 @@ int fsync(int fd)
 	int ret = syscall1(int, SYS_FSYNC, fd);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int fdatasync(int fd)
 {
+	__A_VARIABLE = 1;
 	return fsync(fd);
 }
diff --git a/newlib/libc/sys/phoenix/sysconf.c b/newlib/libc/sys/phoenix/sysconf.c
index 08eb439..b1a1f2c 100644
--- a/newlib/libc/sys/phoenix/sysconf.c
+++ b/newlib/libc/sys/phoenix/sysconf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -28,5 +29,6 @@ long sysconf(int name)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/syslog.c b/newlib/libc/sys/phoenix/syslog.c
index c38800e..743623b 100644
--- a/newlib/libc/sys/phoenix/syslog.c
+++ b/newlib/libc/sys/phoenix/syslog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -51,8 +52,10 @@ struct {
 
 void openlog(const char *ident, int option, int facility)
 {
-	if (client.socket != -1)
+	if (client.socket != -1) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	client.ident = ident;
 	client.option = option;
@@ -63,6 +66,7 @@ void openlog(const char *ident, int option, int facility)
 
 	if ((client.socket = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
 		printf("Socket failed: %s\n", strerror(errno));
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -70,6 +74,7 @@ void openlog(const char *ident, int option, int facility)
 	client.addr.sin_family = AF_INET;
 	client.addr.sin_addr.s_addr = inet_addr("127.0.0.1");
 	client.addr.sin_port = htons(31000);
+	__A_VARIABLE = 1;
 }
 
 void syslog(int priority, const char *format, ...)
@@ -91,16 +96,21 @@ void syslog(int priority, const char *format, ...)
 
 	if (sendto(client.socket, msg, strlen(msg), 0, (struct sockaddr *) &(client.addr), sizeof(client.addr)) == -1) {
 		printf("Send failed: %s\n", strerror(errno));
+		__A_VARIABLE = 1;
 		return;
 	}
+	__A_VARIABLE = 1;
 }
 
 void closelog()
 {
-	if (client.socket == -1)
+	if (client.socket == -1) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	close(client.socket);
 	client.ident = NULL;
 	client.socket = -1;
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/phoenix/time.c b/newlib/libc/sys/phoenix/time.c
index f10de7f..3f521d8 100644
--- a/newlib/libc/sys/phoenix/time.c
+++ b/newlib/libc/sys/phoenix/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -38,12 +39,14 @@ time_t time(time_t *t)
 	int ret = clock_gettime(CLOCK_REALTIME, &tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	if (t != NULL)
 		*t = tp.tv_sec;
 
+	__A_VARIABLE = 1;
 	return tp.tv_sec;
 }
 
@@ -51,6 +54,7 @@ int stime(const time_t *t)
 {
 	if (t == NULL) {
 		errno = EINVAL;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
@@ -60,9 +64,11 @@ int stime(const time_t *t)
 	int ret = clock_settime(CLOCK_REALTIME, &tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -72,12 +78,14 @@ int gettimeofday(struct timeval *tv, void *tz)
 	int ret = clock_gettime(CLOCK_REALTIME, &tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
 	tv->tv_sec = tp.tv_sec;
 	tv->tv_usec = tp.tv_nsec / 1000;
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -90,14 +98,17 @@ int settimeofday(const struct timeval *tv, const struct timezone *tz)
 	int ret = clock_settime(CLOCK_REALTIME, &tp);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 clock_t times(struct tms *buf)
 {
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/truncate.c b/newlib/libc/sys/phoenix/truncate.c
index 0669955..6a31c67 100644
--- a/newlib/libc/sys/phoenix/truncate.c
+++ b/newlib/libc/sys/phoenix/truncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,9 +33,11 @@ int truncate(const char *path, off_t length)
 	int ret = syscall2(int, SYS_TRUNCATE, path, length);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -43,8 +46,10 @@ int ftruncate(int fd, off_t length)
 	int ret = syscall2(int, SYS_FTRUNCATE, fd, length);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/tty.c b/newlib/libc/sys/phoenix/tty.c
index ab944e0..8a966d5 100644
--- a/newlib/libc/sys/phoenix/tty.c
+++ b/newlib/libc/sys/phoenix/tty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,9 +34,11 @@ int _isatty(int fd)
 	int ret = syscall1(int, SYS_ISATTY, fd);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -44,9 +47,11 @@ int tcgetattr(int fd, struct termios *termios_p)
 	int ret = ioctl(fd, TCGETS, termios_p);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1; 
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -65,15 +70,18 @@ int tcsetattr(int fd, int mode, const struct termios *termios_p)
 			break;
 		default:
 			errno = EINVAL;
+			__A_VARIABLE = 1;
 			return -1;
 	}
 
 	int ret = ioctl(fd, cmd, termios_p);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1; 
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -82,9 +90,11 @@ int tcsendbreak(int fd, int duration)
 	int ret = ioctl(fd, TCSBRK, duration);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1; 
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -93,9 +103,11 @@ int tcflush(int fd, int queue_selector)
 	int ret = ioctl(fd, TCFLSH, queue_selector);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1; 
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -104,9 +116,11 @@ int tcdrain(int fd)
 	int ret = ioctl(fd, TCDRAIN, 0);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1; 
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -114,6 +128,7 @@ pid_t tcgetsid(int fd)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
 
@@ -121,5 +136,6 @@ int tcsetpgrp(int fd, pid_t pgrp)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/phoenix/uname.c b/newlib/libc/sys/phoenix/uname.c
index 9f7b071..f6ec7c7 100644
--- a/newlib/libc/sys/phoenix/uname.c
+++ b/newlib/libc/sys/phoenix/uname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -32,8 +33,10 @@ int uname(struct utsname *buf)
 	int ret = syscall1(int, SYS_UNAME, buf);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libc/sys/phoenix/utime.c b/newlib/libc/sys/phoenix/utime.c
index 265363f..76e0d6a 100644
--- a/newlib/libc/sys/phoenix/utime.c
+++ b/newlib/libc/sys/phoenix/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -42,9 +43,11 @@ int utime(const char *filename, const struct utimbuf *times)
 	int ret = syscall2(int, SYS_CHTIMES, filename, times ? &t : NULL);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -61,8 +64,10 @@ int utimes(const char *filename, const struct timeval times[2])
 	int ret = syscall2(int, SYS_CHTIMES, filename, times ? &t : NULL);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
diff --git a/newlib/libc/sys/phoenix/wait.c b/newlib/libc/sys/phoenix/wait.c
index 914e2ab..1733e11 100644
--- a/newlib/libc/sys/phoenix/wait.c
+++ b/newlib/libc/sys/phoenix/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (c) 2016 Phoenix Systems
    All rights reserved.
 
@@ -33,9 +34,11 @@ pid_t wait(int *status)
 	int ret = waitpid(-1, status, 0);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -44,9 +47,11 @@ pid_t waitpid(pid_t pid, int *status, int options)
 	int ret =  syscall3(int, SYS_WAITPID, pid, status, options);
 	if (ret < 0) {
 		errno = -ret;
+		__A_VARIABLE = 1;
 		return -1;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -54,5 +59,6 @@ pid_t wait3(int *status, int options, struct rusage *rusage)
 {
 	/* TODO: implement. */
 	errno = ENOSYS;
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/rdos/chown.c b/newlib/libc/sys/rdos/chown.c
index 9be0ae8..c745bef 100755
--- a/newlib/libc/sys/rdos/chown.c
+++ b/newlib/libc/sys/rdos/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -7,5 +8,6 @@
 int chown(const char *path, uid_t owner, gid_t group)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/close.c b/newlib/libc/sys/rdos/close.c
index 3daf92b..7f6fb46 100644
--- a/newlib/libc/sys/rdos/close.c
+++ b/newlib/libc/sys/rdos/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -32,5 +33,6 @@
 int close(int fildes)
 {
   RdosCloseFile(fildes);
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/rdos/execve.c b/newlib/libc/sys/rdos/execve.c
index 3846532..e55bad7 100644
--- a/newlib/libc/sys/rdos/execve.c
+++ b/newlib/libc/sys/rdos/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int execve( char *name, char **argv, char **env)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/fork.c b/newlib/libc/sys/rdos/fork.c
index 4b3381d..48c470d 100755
--- a/newlib/libc/sys/rdos/fork.c
+++ b/newlib/libc/sys/rdos/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int fork()
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/fstat.c b/newlib/libc/sys/rdos/fstat.c
index 59321c1..3ac656c 100755
--- a/newlib/libc/sys/rdos/fstat.c
+++ b/newlib/libc/sys/rdos/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
diff --git a/newlib/libc/sys/rdos/getenv.c b/newlib/libc/sys/rdos/getenv.c
index 933ea4d..680ee1c 100644
--- a/newlib/libc/sys/rdos/getenv.c
+++ b/newlib/libc/sys/rdos/getenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -79,5 +80,6 @@ char *getenv(const char *name)
             ptr = envbuf;
     }
     RdosCloseEnv(handle);
+    __A_VARIABLE = 1;
     return ptr;
 }
diff --git a/newlib/libc/sys/rdos/getpid.c b/newlib/libc/sys/rdos/getpid.c
index e1ce8c6..6e1aa1a 100644
--- a/newlib/libc/sys/rdos/getpid.c
+++ b/newlib/libc/sys/rdos/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int getpid()
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/gettod.c b/newlib/libc/sys/rdos/gettod.c
index 82a3899..bea3df8 100644
--- a/newlib/libc/sys/rdos/gettod.c
+++ b/newlib/libc/sys/rdos/gettod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -11,5 +12,6 @@ struct timezone;
 int gettimeofday(struct timeval *ptimeval, void *ptimezone)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/isatty.c b/newlib/libc/sys/rdos/isatty.c
index a3fb36c..f69d04b 100644
--- a/newlib/libc/sys/rdos/isatty.c
+++ b/newlib/libc/sys/rdos/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -5,5 +6,6 @@
 
 int isatty(int file)
 {
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/rdos/kill.c b/newlib/libc/sys/rdos/kill.c
index 3833d44..a488f58 100644
--- a/newlib/libc/sys/rdos/kill.c
+++ b/newlib/libc/sys/rdos/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int kill(int pid, int sig)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/link.c b/newlib/libc/sys/rdos/link.c
index 458e549..baeb0e9 100644
--- a/newlib/libc/sys/rdos/link.c
+++ b/newlib/libc/sys/rdos/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int link(char *existing, char *new)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/lseek.c b/newlib/libc/sys/rdos/lseek.c
index 68fb268..99e61f6 100755
--- a/newlib/libc/sys/rdos/lseek.c
+++ b/newlib/libc/sys/rdos/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -40,20 +41,24 @@ off_t lseek(int file, off_t pos, int whence)
 			temp = RdosGetFilePos(file);
 			temp += pos;
 			RdosSetFilePos(file, temp);
+			__A_VARIABLE = 1;
 			return temp;
 
 		case SEEK_SET:
 			RdosSetFilePos(file, pos);
+			__A_VARIABLE = 1;
 			return pos;
 
 		case SEEK_END:
 			temp = RdosGetFilePos(file);
 			temp += pos;
 			RdosSetFilePos(file, temp);
+			__A_VARIABLE = 1;
 			return temp;
 
 		default:
 			errno = EINVAL;
+			__A_VARIABLE = 1;
 			return - 1;
 	}
 }
diff --git a/newlib/libc/sys/rdos/open.c b/newlib/libc/sys/rdos/open.c
index f840988..a723563 100755
--- a/newlib/libc/sys/rdos/open.c
+++ b/newlib/libc/sys/rdos/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
diff --git a/newlib/libc/sys/rdos/rdoshelp.c b/newlib/libc/sys/rdos/rdoshelp.c
index 20d2535..afdf4a0 100644
--- a/newlib/libc/sys/rdos/rdoshelp.c
+++ b/newlib/libc/sys/rdos/rdoshelp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -46,6 +47,7 @@ static int key_section;
 ##########################################################################*/
 int get_impure_data_size()
 {
+	__A_VARIABLE = 1;
 	return sizeof(struct _reent);
 }
 
@@ -63,8 +65,10 @@ int get_impure_data_size()
 ##########################################################################*/
 int __rdos_thread_once (int *handle, void (*func) (void))
 {
-    if (handle == 0 || func == 0)
+    if (handle == 0 || func == 0) {
+        __A_VARIABLE = 1;
         return 0;
+    }
          
     RdosEnterSection(once_section);
     if (*handle == 0)
@@ -72,6 +76,7 @@ int __rdos_thread_once (int *handle, void (*func) (void))
     else
         *handle = 1;
     RdosLeaveSection(once_section);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -88,6 +93,7 @@ int __rdos_thread_once (int *handle, void (*func) (void))
 ##########################################################################*/
 int __rdos_thread_mutex_init (void)
 {
+    __A_VARIABLE = 1;
     return RdosCreateSection();
 }
 
@@ -105,6 +111,7 @@ int __rdos_thread_mutex_init (void)
 int __rdos_thread_mutex_lock (int handle)
 {
     RdosEnterSection(handle);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -123,6 +130,7 @@ int __rdos_thread_mutex_lock (int handle)
 int __rdos_thread_mutex_trylock (int handle)
 {
     RdosEnterSection(handle);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -140,6 +148,7 @@ int __rdos_thread_mutex_trylock (int handle)
 int __rdos_thread_mutex_unlock (int handle)
 {
     RdosLeaveSection(handle);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -159,4 +168,5 @@ void __init_rdos(struct _reent *reent)
 	once_section = RdosCreateSection();
 	_REENT_INIT_PTR(reent);
 	__sinit(reent);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/rdos/read.c b/newlib/libc/sys/rdos/read.c
index 61841ff..006b9b7 100644
--- a/newlib/libc/sys/rdos/read.c
+++ b/newlib/libc/sys/rdos/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -31,5 +32,6 @@
 
 int read(int file, char *ptr, int len)
 {
+    __A_VARIABLE = 1;
     return RdosReadFile(file, ptr, len);
 }
diff --git a/newlib/libc/sys/rdos/readlink.c b/newlib/libc/sys/rdos/readlink.c
index 9922f44..68e4586 100755
--- a/newlib/libc/sys/rdos/readlink.c
+++ b/newlib/libc/sys/rdos/readlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -7,5 +8,6 @@
 int readlink(const char *__restrict path, char *__restrict buf, size_t bufsize)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/sbrk.c b/newlib/libc/sys/rdos/sbrk.c
index 3fd8fcd..a2af8e3 100644
--- a/newlib/libc/sys/rdos/sbrk.c
+++ b/newlib/libc/sys/rdos/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -29,5 +30,6 @@
 
 void *sbrk (int incr)
 { 
+   __A_VARIABLE = 1;
    return RdosAllocateMem(incr);
 } 
diff --git a/newlib/libc/sys/rdos/stat.c b/newlib/libc/sys/rdos/stat.c
index 6483f2a..8c263e4 100755
--- a/newlib/libc/sys/rdos/stat.c
+++ b/newlib/libc/sys/rdos/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -8,5 +9,6 @@
 int stat(const char *__restrict file, struct stat *__restrict st)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/symlink.c b/newlib/libc/sys/rdos/symlink.c
index 60f3719..64475f5 100755
--- a/newlib/libc/sys/rdos/symlink.c
+++ b/newlib/libc/sys/rdos/symlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int symlink(const char *path1, const char *path2)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/times.c b/newlib/libc/sys/rdos/times.c
index b0ba900..0f1cfd9 100644
--- a/newlib/libc/sys/rdos/times.c
+++ b/newlib/libc/sys/rdos/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -7,5 +8,6 @@
 clock_t times(struct tms *buf)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/unlink.c b/newlib/libc/sys/rdos/unlink.c
index 793631b..714e1a8 100644
--- a/newlib/libc/sys/rdos/unlink.c
+++ b/newlib/libc/sys/rdos/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int unlink(char *name)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/wait.c b/newlib/libc/sys/rdos/wait.c
index 80f4088..2d83aef 100644
--- a/newlib/libc/sys/rdos/wait.c
+++ b/newlib/libc/sys/rdos/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "config.h"
 #include <_ansi.h>
 #include <_syslist.h>
@@ -6,5 +7,6 @@
 int wait(int *status)
 {
   errno = ENOSYS;
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/rdos/write.c b/newlib/libc/sys/rdos/write.c
index 3dfe786..988303c 100644
--- a/newlib/libc/sys/rdos/write.c
+++ b/newlib/libc/sys/rdos/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*#######################################################################
 # RDOS operating system
 # Copyright (C) 1988-2006, Leif Ekblad
@@ -31,5 +32,6 @@
 
 int write(int file, char *ptr, int len)
 {
+    __A_VARIABLE = 1;
     return RdosWriteFile(file, ptr, len);
 }
diff --git a/newlib/libc/sys/rtems/cpusetalloc.c b/newlib/libc/sys/rtems/cpusetalloc.c
index e2b1985..a027281 100644
--- a/newlib/libc/sys/rtems/cpusetalloc.c
+++ b/newlib/libc/sys/rtems/cpusetalloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2013 embedded brains GmbH.  All rights reserved.
  *
@@ -34,5 +35,6 @@
 
 cpu_set_t *__cpuset_alloc(int num_cpus)
 {
+  __A_VARIABLE = 1;
   return (cpu_set_t *)malloc(CPU_ALLOC_SIZE(num_cpus));
 }
diff --git a/newlib/libc/sys/rtems/cpusetfree.c b/newlib/libc/sys/rtems/cpusetfree.c
index a94a940..a9cc40e 100644
--- a/newlib/libc/sys/rtems/cpusetfree.c
+++ b/newlib/libc/sys/rtems/cpusetfree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2013 embedded brains GmbH.  All rights reserved.
  *
@@ -35,4 +36,5 @@
 void __cpuset_free(cpu_set_t *set)
 {
   free(set);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/rtems/crt0.c b/newlib/libc/sys/rtems/crt0.c
index 0e9d426..3df12eb 100644
--- a/newlib/libc/sys/rtems/crt0.c
+++ b/newlib/libc/sys/rtems/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *  RTEMS Fake crt0
  *
diff --git a/newlib/libc/sys/rtems/dummysys.c b/newlib/libc/sys/rtems/dummysys.c
index 8109118..167b725 100644
--- a/newlib/libc/sys/rtems/dummysys.c
+++ b/newlib/libc/sys/rtems/dummysys.c
@@ -1 +1,3 @@
-void not_required_by_rtems( void ) {}
+static volatile int __A_VARIABLE;
+void not_required_by_rtems( void ) {__A_VARIABLE = 1;
+}
diff --git a/newlib/libc/sys/sh/creat.c b/newlib/libc/sys/sh/creat.c
index 62ec5ea..e0b064b 100644
--- a/newlib/libc/sys/sh/creat.c
+++ b/newlib/libc/sys/sh/creat.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 int
 creat(path, mode)
      const char *path;
      int mode;
 {
+  __A_VARIABLE = 1;
   return _creat (path, mode);
 }
diff --git a/newlib/libc/sys/sh/ftruncate.c b/newlib/libc/sys/sh/ftruncate.c
index 660377b..bdb7359 100644
--- a/newlib/libc/sys/sh/ftruncate.c
+++ b/newlib/libc/sys/sh/ftruncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include "sys/syscall.h"
@@ -5,5 +6,6 @@
 int
 ftruncate (int file, off_t length)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_ftruncate, file, length, 0);
 }
diff --git a/newlib/libc/sys/sh/syscalls.c b/newlib/libc/sys/sh/syscalls.c
index 614b67e..1981e33 100644
--- a/newlib/libc/sys/sh/syscalls.c
+++ b/newlib/libc/sys/sh/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,6 +14,7 @@ _read (int file,
        char *ptr,
        int len)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_read, file, ptr, len);
 }
 
@@ -21,6 +23,7 @@ _lseek (int file,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_lseek, file, ptr, dir);
 }
 
@@ -29,18 +32,21 @@ _write ( int file,
 	 char *ptr,
 	 int len)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_write, file, ptr, len);
 }
 
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_close, file, 0, 0);
 }
 
 int
 _link (char *old, char *new)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -62,6 +68,7 @@ _sbrk (int incr)
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -70,6 +77,7 @@ _fstat (int file,
 	struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -77,6 +85,7 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_open, path, flags, 0);
 }
 
@@ -84,12 +93,14 @@ int
 _creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_creat, path, mode, 0);
 }
 
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -108,6 +119,7 @@ _isatty (fd)
 
 _exit (n)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_exit, n, 0, 0);
 }
 
@@ -118,29 +130,34 @@ _kill (n, m)
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
 _raise ()
 {
+	__A_VARIABLE = 1;
 }
 
 int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_stat, path, st, 0);
 }
 
 int
 _chmod (const char *path, short mode)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_chmod, path, mode);
 }
 
 int
 _chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_chown, path, owner, group);
 }
 
@@ -149,12 +166,14 @@ _utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_utime, path, times);
 }
 
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_fork);
 }
 
@@ -162,24 +181,28 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_wait);
 }
 
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_execve, path, argv, envp);
 }
 
 int
 _execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_execv, path, argv);
 }
 
 int
 _pipe (int *fd)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_pipe, fd);
 }
 
@@ -188,6 +211,7 @@ _pipe (int *fd)
 clock_t
 _times (struct tms *tp)
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -196,6 +220,7 @@ _gettimeofday (struct timeval *tv, void *tz)
 {
   tv->tv_usec = 0;
   tv->tv_sec = __trap34 (SYS_time);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -213,6 +238,7 @@ __setup_argv_for_main (int argc)
     __trap34 (SYS_argn, i, argv[i]);
   }
 
+  __A_VARIABLE = 1;
   return main (argc, argv);
 }
 
diff --git a/newlib/libc/sys/sh/truncate.c b/newlib/libc/sys/sh/truncate.c
index 5ca48d3..cb81a9a 100644
--- a/newlib/libc/sys/sh/truncate.c
+++ b/newlib/libc/sys/sh/truncate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include "sys/syscall.h"
@@ -5,5 +6,6 @@
 int
 truncate (const char *path, off_t length)
 {
+  __A_VARIABLE = 1;
   return __trap34 (SYS_truncate, path, length, 0);
 }
diff --git a/newlib/libc/sys/sparc64/_main.c b/newlib/libc/sys/sparc64/_main.c
index 6487808..4191ec4 100644
--- a/newlib/libc/sys/sparc64/_main.c
+++ b/newlib/libc/sys/sparc64/_main.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 
 __main()
 {
   
 
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sparc64/closedir.c b/newlib/libc/sys/sparc64/closedir.c
index d87d816..7d6b548 100644
--- a/newlib/libc/sys/sparc64/closedir.c
+++ b/newlib/libc/sys/sparc64/closedir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -54,5 +55,6 @@ closedir(dirp)
 	dirp->dd_loc = 0;
 	(void)free((void *)dirp->dd_buf);
 	(void)free((void *)dirp);
+	__A_VARIABLE = 1;
 	return(close(fd));
 }
diff --git a/newlib/libc/sys/sparc64/creat.c b/newlib/libc/sys/sparc64/creat.c
index 6b11162..79c2a0d 100644
--- a/newlib/libc/sys/sparc64/creat.c
+++ b/newlib/libc/sys/sparc64/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* creat() "system call" */
 
 /* This is needed by f2c and therefore the SPEC benchmarks.  */
@@ -7,5 +8,6 @@
 int
 creat (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
 }
diff --git a/newlib/libc/sys/sparc64/ieee.c b/newlib/libc/sys/sparc64/ieee.c
index 2828976..f0cc15a 100644
--- a/newlib/libc/sys/sparc64/ieee.c
+++ b/newlib/libc/sys/sparc64/ieee.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include <ieeefp.h>
 
@@ -7,12 +8,25 @@ _DEFUN_VOID(fpgetround)
 {
   char *out;
   ieee_flags("get", "direction","", &out);
-  if (strcmp(out,"nearest") == 0) return FP_RN;  
-  if (strcmp(out,"negative") == 0) return FP_RM;  
-  if (strcmp(out,"positive") == 0) return FP_RP;  
-  if (strcmp(out,"tozero") == 0) return FP_RZ;  
+  if (strcmp(out,"nearest") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RN;
+  }  
+  if (strcmp(out,"negative") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RM;
+  }  
+  if (strcmp(out,"positive") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RP;
+  }  
+  if (strcmp(out,"tozero") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RZ;
+  }  
   abort();
   
+  __A_VARIABLE = 1;
 }
 
 fp_rnd
@@ -39,6 +53,7 @@ _DEFUN(fpsetround,(new),
   default:
     break;
   }
+  __A_VARIABLE = 1;
   return old;
 }
 
@@ -55,6 +70,7 @@ _DEFUN_VOID(fpgetmask)
   if (i & 4) r |= FP_X_UFL;
   if (i & 8) r |= FP_X_OFL;
   if (i & 16) r |= FP_X_INV;
+  __A_VARIABLE = 1;
   return r;
 
 }
@@ -80,6 +96,7 @@ _DEFUN(fpsetmask,(mask),
   if (mask & FP_X_INV)
    ieee_flags("set","exception","invalid", &out);
 
+  __A_VARIABLE = 1;
   return old;
 
 }
@@ -88,12 +105,14 @@ fp_except
 _DEFUN(fpsetsticky,(mask),
        fp_except mask)
 {
+  __A_VARIABLE = 1;
   return fpsetmask(mask);
 }
 
 fp_except
 _DEFUN_VOID(fpgetsticky)
 {
+  __A_VARIABLE = 1;
   return fpgetmask();
 }
 
@@ -102,6 +121,7 @@ _DEFUN(fpsetroundtoi,(rdi_mode),
        fp_rdi rdi_mode)
 {
   
+  __A_VARIABLE = 1;
   return 0;
   
 }
@@ -110,6 +130,7 @@ int
 _DEFUN_VOID(fpgetroundtoi)
 {
   
+  __A_VARIABLE = 1;
   return 0;
   
 }
diff --git a/newlib/libc/sys/sparc64/isatty.c b/newlib/libc/sys/sparc64/isatty.c
index 3c64647..404bcab 100644
--- a/newlib/libc/sys/sparc64/isatty.c
+++ b/newlib/libc/sys/sparc64/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isatty.c */
 
 /* Dumb implementation so programs will at least run.  */
@@ -9,9 +10,14 @@ isatty (int fd)
 {
   struct stat buf;
 
-  if (fstat (fd, &buf) < 0)
+  if (fstat (fd, &buf) < 0) {
+    __A_VARIABLE = 1;
     return 0;
-  if (S_ISCHR (buf.st_mode))
+  }
+  if (S_ISCHR (buf.st_mode)) {
+    __A_VARIABLE = 1;
     return 1;
+  }
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/sparc64/opendir.c b/newlib/libc/sys/sparc64/opendir.c
index ce080e3..950cb23 100644
--- a/newlib/libc/sys/sparc64/opendir.c
+++ b/newlib/libc/sys/sparc64/opendir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -50,11 +51,14 @@ opendir(name)
 	register DIR *dirp;
 	register int fd;
 
-	if ((fd = open(name, 0)) == -1)
+	if ((fd = open(name, 0)) == -1) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 	if (fcntl(fd, F_SETFD, 1) == -1 ||
 	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	/*
@@ -68,6 +72,7 @@ opendir(name)
 
 	if (dirp->dd_buf == NULL) {
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	dirp->dd_fd = fd;
@@ -76,5 +81,6 @@ opendir(name)
 	/*
 	 * Set up seek point for rewinddir.
 	 */
+	__A_VARIABLE = 1;
 	return dirp;
 }
diff --git a/newlib/libc/sys/sparc64/readdir.c b/newlib/libc/sys/sparc64/readdir.c
index b383987..86ac366 100644
--- a/newlib/libc/sys/sparc64/readdir.c
+++ b/newlib/libc/sys/sparc64/readdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/sys/sparc64/rewinddir.c b/newlib/libc/sys/sparc64/rewinddir.c
index d52c013..495a39e 100644
--- a/newlib/libc/sys/sparc64/rewinddir.c
+++ b/newlib/libc/sys/sparc64/rewinddir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -46,4 +47,5 @@ rewinddir(dirp)
 
 	_seekdir((dirp), _rewinddir);
 	_rewinddir = telldir(dirp);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sparc64/scandir.c b/newlib/libc/sys/sparc64/scandir.c
index bcfd525..43ed6a2 100644
--- a/newlib/libc/sys/sparc64/scandir.c
+++ b/newlib/libc/sys/sparc64/scandir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -75,10 +76,14 @@ scandir(dirname, namelist, select, dcomp)
 	long arraysz;
 	DIR *dirp;
 
-	if ((dirp = opendir(dirname)) == NULL)
+	if ((dirp = opendir(dirname)) == NULL) {
+		__A_VARIABLE = 1;
 		return(-1);
-	if (fstat(dirp->dd_fd, &stb) < 0)
+	}
+	if (fstat(dirp->dd_fd, &stb) < 0) {
+		__A_VARIABLE = 1;
 		return(-1);
+	}
 
 	/*
 	 * estimate the array size by taking the size of the directory file
@@ -86,8 +91,10 @@ scandir(dirname, namelist, select, dcomp)
 	 */
 	arraysz = (stb.st_size / 24);
 	names = (struct dirent **)malloc(arraysz * sizeof(struct dirent *));
-	if (names == NULL)
+	if (names == NULL) {
+		__A_VARIABLE = 1;
 		return(-1);
+	}
 
 	nitems = 0;
 	while ((d = readdir(dirp)) != NULL) {
@@ -97,8 +104,10 @@ scandir(dirname, namelist, select, dcomp)
 		 * Make a minimum size copy of the data
 		 */
 		p = (struct dirent *)malloc(DIRSIZ(d));
-		if (p == NULL)
+		if (p == NULL) {
+			__A_VARIABLE = 1;
 			return(-1);
+		}
 		p->d_ino = d->d_ino;
 		p->d_reclen = d->d_reclen;
 		p->d_namlen = d->d_namlen;
@@ -108,13 +117,17 @@ scandir(dirname, namelist, select, dcomp)
 		 * realloc the maximum size.
 		 */
 		if (++nitems >= arraysz) {
-			if (fstat(dirp->dd_fd, &stb) < 0)
-				return(-1);	/* just might have grown */
+			if (fstat(dirp->dd_fd, &stb) < 0) {
+				__A_VARIABLE = 1;
+				return(-1);
+			}	/* just might have grown */
 			arraysz = stb.st_size / 12;
 			names = (struct dirent **)realloc((char *)names,
 				arraysz * sizeof(struct dirent *));
-			if (names == NULL)
+			if (names == NULL) {
+				__A_VARIABLE = 1;
 				return(-1);
+			}
 		}
 		names[nitems-1] = p;
 	}
@@ -122,6 +135,7 @@ scandir(dirname, namelist, select, dcomp)
 	if (nitems && dcomp != NULL)
 		qsort(names, nitems, sizeof(struct dirent *), dcomp);
 	*namelist = names;
+	__A_VARIABLE = 1;
 	return(nitems);
 }
 
@@ -133,6 +147,7 @@ alphasort(d1, d2)
 	const void *d1;
 	const void *d2;
 {
+	__A_VARIABLE = 1;
 	return(strcmp((*(struct dirent **)d1)->d_name,
 	    (*(struct dirent **)d2)->d_name));
 }
diff --git a/newlib/libc/sys/sparc64/seekdir.c b/newlib/libc/sys/sparc64/seekdir.c
index 5033140..273ca9c 100644
--- a/newlib/libc/sys/sparc64/seekdir.c
+++ b/newlib/libc/sys/sparc64/seekdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -49,4 +50,5 @@ seekdir(dirp, loc)
 {
 
 	_seekdir(dirp, loc);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sparc64/telldir.c b/newlib/libc/sys/sparc64/telldir.c
index 37d9de6..c93bfbf 100644
--- a/newlib/libc/sys/sparc64/telldir.c
+++ b/newlib/libc/sys/sparc64/telldir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -76,14 +77,17 @@ telldir(dirp)
 	register int index;
 	register struct ddloc *lp;
 
-	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL)
+	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	index = dd_loccnt++;
 	lp->loc_index = index;
 	lp->loc_seek = dirp->dd_seek;
 	lp->loc_loc = dirp->dd_loc;
 	lp->loc_next = dd_hash[LOCHASH(index)];
 	dd_hash[LOCHASH(index)] = lp;
+	__A_VARIABLE = 1;
 	return (index);
 }
 
@@ -109,8 +113,10 @@ _seekdir(dirp, loc)
 		prevlp = &lp->loc_next;
 		lp = lp->loc_next;
 	}
-	if (lp == NULL)
+	if (lp == NULL) {
+		__A_VARIABLE = 1;
 		return;
+	}
 	if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
 		goto found;
 	(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
@@ -126,4 +132,5 @@ found:
 	*prevlp = lp->loc_next;
 	free((caddr_t)lp);
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sparc64/utime2.c b/newlib/libc/sys/sparc64/utime2.c
index 5f01e3b..20391b0 100644
--- a/newlib/libc/sys/sparc64/utime2.c
+++ b/newlib/libc/sys/sparc64/utime2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* utime() system call for sunos4 */
 
 #ifndef __svr4__
@@ -17,9 +18,11 @@ utime (char *path, struct utimbuf *times)
       timevals[0].tv_usec = 0;
       timevals[1].tv_sec = (long int) times->modtime;
       timevals[1].tv_usec = 0;
+      __A_VARIABLE = 1;
       return utimes (path, timevals);
     }
 
+  __A_VARIABLE = 1;
   return utimes (path, (struct timeval *) 0);
 }
 
diff --git a/newlib/libc/sys/sun4/_main.c b/newlib/libc/sys/sun4/_main.c
index 6487808..4191ec4 100644
--- a/newlib/libc/sys/sun4/_main.c
+++ b/newlib/libc/sys/sun4/_main.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 
 __main()
 {
   
 
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sun4/ieee.c b/newlib/libc/sys/sun4/ieee.c
index 2828976..f0cc15a 100644
--- a/newlib/libc/sys/sun4/ieee.c
+++ b/newlib/libc/sys/sun4/ieee.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include <ieeefp.h>
 
@@ -7,12 +8,25 @@ _DEFUN_VOID(fpgetround)
 {
   char *out;
   ieee_flags("get", "direction","", &out);
-  if (strcmp(out,"nearest") == 0) return FP_RN;  
-  if (strcmp(out,"negative") == 0) return FP_RM;  
-  if (strcmp(out,"positive") == 0) return FP_RP;  
-  if (strcmp(out,"tozero") == 0) return FP_RZ;  
+  if (strcmp(out,"nearest") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RN;
+  }  
+  if (strcmp(out,"negative") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RM;
+  }  
+  if (strcmp(out,"positive") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RP;
+  }  
+  if (strcmp(out,"tozero") == 0) {
+    __A_VARIABLE = 1;
+    return FP_RZ;
+  }  
   abort();
   
+  __A_VARIABLE = 1;
 }
 
 fp_rnd
@@ -39,6 +53,7 @@ _DEFUN(fpsetround,(new),
   default:
     break;
   }
+  __A_VARIABLE = 1;
   return old;
 }
 
@@ -55,6 +70,7 @@ _DEFUN_VOID(fpgetmask)
   if (i & 4) r |= FP_X_UFL;
   if (i & 8) r |= FP_X_OFL;
   if (i & 16) r |= FP_X_INV;
+  __A_VARIABLE = 1;
   return r;
 
 }
@@ -80,6 +96,7 @@ _DEFUN(fpsetmask,(mask),
   if (mask & FP_X_INV)
    ieee_flags("set","exception","invalid", &out);
 
+  __A_VARIABLE = 1;
   return old;
 
 }
@@ -88,12 +105,14 @@ fp_except
 _DEFUN(fpsetsticky,(mask),
        fp_except mask)
 {
+  __A_VARIABLE = 1;
   return fpsetmask(mask);
 }
 
 fp_except
 _DEFUN_VOID(fpgetsticky)
 {
+  __A_VARIABLE = 1;
   return fpgetmask();
 }
 
@@ -102,6 +121,7 @@ _DEFUN(fpsetroundtoi,(rdi_mode),
        fp_rdi rdi_mode)
 {
   
+  __A_VARIABLE = 1;
   return 0;
   
 }
@@ -110,6 +130,7 @@ int
 _DEFUN_VOID(fpgetroundtoi)
 {
   
+  __A_VARIABLE = 1;
   return 0;
   
 }
diff --git a/newlib/libc/sys/sysmec/_exit.c b/newlib/libc/sys/sysmec/_exit.c
index bf7e286..994cbf7 100644
--- a/newlib/libc/sys/sysmec/_exit.c
+++ b/newlib/libc/sys/sysmec/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -20,6 +21,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -31,4 +33,5 @@ void _exit (n)
   _do_dtors();
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysmec/access.c b/newlib/libc/sys/sysmec/access.c
index 980682e..b71fa38 100644
--- a/newlib/libc/sys/sysmec/access.c
+++ b/newlib/libc/sys/sysmec/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/newlib/libc/sys/sysmec/chmod.c b/newlib/libc/sys/sysmec/chmod.c
index 1814604..d3f5c72 100644
--- a/newlib/libc/sys/sysmec/chmod.c
+++ b/newlib/libc/sys/sysmec/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/newlib/libc/sys/sysmec/chown.c b/newlib/libc/sys/sysmec/chown.c
index 5b083f1..9613c5c 100644
--- a/newlib/libc/sys/sysmec/chown.c
+++ b/newlib/libc/sys/sysmec/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 ();
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/newlib/libc/sys/sysmec/close.c b/newlib/libc/sys/sysmec/close.c
index 323c74a..554b746 100644
--- a/newlib/libc/sys/sysmec/close.c
+++ b/newlib/libc/sys/sysmec/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/creat.c b/newlib/libc/sys/sysmec/creat.c
index fce9bc3..cb8533c 100644
--- a/newlib/libc/sys/sysmec/creat.c
+++ b/newlib/libc/sys/sysmec/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/newlib/libc/sys/sysmec/crt1.c b/newlib/libc/sys/sysmec/crt1.c
index dd0be31..840f8d2 100644
--- a/newlib/libc/sys/sysmec/crt1.c
+++ b/newlib/libc/sys/sysmec/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
   static int initialized;
@@ -13,4 +14,5 @@ void __main ()
 	(*--p) ();
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysmec/execv.c b/newlib/libc/sys/sysmec/execv.c
index 6665721..3529407 100644
--- a/newlib/libc/sys/sysmec/execv.c
+++ b/newlib/libc/sys/sysmec/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/newlib/libc/sys/sysmec/execve.c b/newlib/libc/sys/sysmec/execve.c
index a0d64c2..f364949 100644
--- a/newlib/libc/sys/sysmec/execve.c
+++ b/newlib/libc/sys/sysmec/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/newlib/libc/sys/sysmec/fork.c b/newlib/libc/sys/sysmec/fork.c
index 1aab324..9ea92c8 100644
--- a/newlib/libc/sys/sysmec/fork.c
+++ b/newlib/libc/sys/sysmec/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/fstat.c b/newlib/libc/sys/sysmec/fstat.c
index 261b144..47a9279 100644
--- a/newlib/libc/sys/sysmec/fstat.c
+++ b/newlib/libc/sys/sysmec/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,5 +16,6 @@ _fstat (int file,
 {
   st->st_mode = S_IFCHR;
   st->st_blksize = 4096;
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libc/sys/sysmec/getpid.c b/newlib/libc/sys/sysmec/getpid.c
index 070382e..8800adf 100644
--- a/newlib/libc/sys/sysmec/getpid.c
+++ b/newlib/libc/sys/sysmec/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -11,5 +12,6 @@ int __trap0 ();
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/sys/sysmec/gettime.c b/newlib/libc/sys/sysmec/gettime.c
index 69250b1..24d0c48 100644
--- a/newlib/libc/sys/sysmec/gettime.c
+++ b/newlib/libc/sys/sysmec/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 ();
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/newlib/libc/sys/sysmec/isatty.c b/newlib/libc/sys/sysmec/isatty.c
index 3ea9986..35a3290 100644
--- a/newlib/libc/sys/sysmec/isatty.c
+++ b/newlib/libc/sys/sysmec/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/newlib/libc/sys/sysmec/kill.c b/newlib/libc/sys/sysmec/kill.c
index 638132f..d792aae 100644
--- a/newlib/libc/sys/sysmec/kill.c
+++ b/newlib/libc/sys/sysmec/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/newlib/libc/sys/sysmec/lseek.c b/newlib/libc/sys/sysmec/lseek.c
index dad6c39..691f9e1 100644
--- a/newlib/libc/sys/sysmec/lseek.c
+++ b/newlib/libc/sys/sysmec/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,5 +16,6 @@ _lseek (int file,
 	off_t ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/newlib/libc/sys/sysmec/open.c b/newlib/libc/sys/sysmec/open.c
index 0a9dbb0..340be01 100644
--- a/newlib/libc/sys/sysmec/open.c
+++ b/newlib/libc/sys/sysmec/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/newlib/libc/sys/sysmec/pipe.c b/newlib/libc/sys/sysmec/pipe.c
index 4c00780..3c88c56 100644
--- a/newlib/libc/sys/sysmec/pipe.c
+++ b/newlib/libc/sys/sysmec/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 pipe (int *fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/read.c b/newlib/libc/sys/sysmec/read.c
index eae084a..954206f 100644
--- a/newlib/libc/sys/sysmec/read.c
+++ b/newlib/libc/sys/sysmec/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ _read (int file,
        char *ptr,
        size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/newlib/libc/sys/sysmec/sbrk.c b/newlib/libc/sys/sysmec/sbrk.c
index 80cb431..7b97409 100644
--- a/newlib/libc/sys/sysmec/sbrk.c
+++ b/newlib/libc/sys/sysmec/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -32,5 +33,6 @@ _sbrk (size_t incr)
       abort ();
     }
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/newlib/libc/sys/sysmec/stat.c b/newlib/libc/sys/sysmec/stat.c
index 11bbe8e..f7a9bf9 100644
--- a/newlib/libc/sys/sysmec/stat.c
+++ b/newlib/libc/sys/sysmec/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/newlib/libc/sys/sysmec/time.c b/newlib/libc/sys/sysmec/time.c
index bde056e..06ffc06 100644
--- a/newlib/libc/sys/sysmec/time.c
+++ b/newlib/libc/sys/sysmec/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/times.c b/newlib/libc/sys/sysmec/times.c
index 3555fd6..ca7b7ea 100644
--- a/newlib/libc/sys/sysmec/times.c
+++ b/newlib/libc/sys/sysmec/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 ();
 clock_t
 times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/unlink.c b/newlib/libc/sys/sysmec/unlink.c
index debd806..081e1cb 100644
--- a/newlib/libc/sys/sysmec/unlink.c
+++ b/newlib/libc/sys/sysmec/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 ();
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/sysmec/utime.c b/newlib/libc/sys/sysmec/utime.c
index 8d3e359..9ad60c6 100644
--- a/newlib/libc/sys/sysmec/utime.c
+++ b/newlib/libc/sys/sysmec/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/newlib/libc/sys/sysmec/wait.c b/newlib/libc/sys/sysmec/wait.c
index 2e5cb6b..f00bc4c 100644
--- a/newlib/libc/sys/sysmec/wait.c
+++ b/newlib/libc/sys/sysmec/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/newlib/libc/sys/sysmec/write.c b/newlib/libc/sys/sysmec/write.c
index 78fd64f..7059def 100644
--- a/newlib/libc/sys/sysmec/write.c
+++ b/newlib/libc/sys/sysmec/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _write ( int file,
 	 char *ptr,
 	 size_t len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/newlib/libc/sys/sysnec810/misc.c b/newlib/libc/sys/sysnec810/misc.c
index f44c03d..8a63358 100644
--- a/newlib/libc/sys/sysnec810/misc.c
+++ b/newlib/libc/sys/sysnec810/misc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -6,26 +7,31 @@ extern int _write (int, void*, unsigned int);
 
 int
 _open() {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 _close() {
+  __A_VARIABLE = 1;
   return -1;
 }
 
 int
 _lseek() {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 _read() {
+  __A_VARIABLE = 1;
   return 0;
 }
 
 int
 isatty() {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -35,6 +41,7 @@ _DEFUN(_fstat,(file, st),
        struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/sys/sysnec810/sbrk.c b/newlib/libc/sys/sysnec810/sbrk.c
index b1cf4a7..e781e8b 100644
--- a/newlib/libc/sys/sysnec810/sbrk.c
+++ b/newlib/libc/sys/sysnec810/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern int _end;
 
 static char *end_of_data = (char *) &_end;
@@ -7,6 +8,7 @@ _sbrk (int delta) {
 	char *ptr = end_of_data;
 
 	end_of_data += delta;
+	__A_VARIABLE = 1;
 	return ptr;
 }
 
diff --git a/newlib/libc/sys/sysnec810/write.c b/newlib/libc/sys/sysnec810/write.c
index 96c1e49..d102a85 100644
--- a/newlib/libc/sys/sysnec810/write.c
+++ b/newlib/libc/sys/sysnec810/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 static volatile char *data = (char *)(0x20);
 static volatile char *control = (char *)(0x24);
 
@@ -8,12 +9,14 @@ static unsigned char
  read_scc_reg (unsigned char n)
 {
   _outb (control, n);
+  __A_VARIABLE = 1;
   return _inb(control);
 }
 
 static void write_scc_data (unsigned char n)
 {
   _outb (data, n);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -31,6 +34,7 @@ _write (int dev, void *buf, unsigned int len)
       write_scc_data (string[i]);
 
     }
+  __A_VARIABLE = 1;
   return len;
 }
 
diff --git a/newlib/libc/sys/sysnecv850/_exit.c b/newlib/libc/sys/sysnecv850/_exit.c
index b45ae96..8ba26c0 100644
--- a/newlib/libc/sys/sysnecv850/_exit.c
+++ b/newlib/libc/sys/sysnecv850/_exit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -20,6 +21,7 @@ static void _do_dtors()
   
   while (p < __dtors_end)
     (*p++) ();
+  __A_VARIABLE = 1;
 }
 
 
@@ -31,4 +33,5 @@ void _exit (n)
   _do_dtors();
 
   TRAP0 (SYS_exit, n, 0, 0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysnecv850/access.c b/newlib/libc/sys/sysnecv850/access.c
index 980682e..b71fa38 100644
--- a/newlib/libc/sys/sysnecv850/access.c
+++ b/newlib/libc/sys/sysnecv850/access.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is file ACCESS.C */
 /*
  * Copyright (C) 1993 DJ Delorie
@@ -18,16 +19,24 @@
 int access(const char *fn, int flags)
 {
   struct stat s;
-  if (stat(fn, &s))
+  if (stat(fn, &s)) {
+    __A_VARIABLE = 1;
     return -1;
-  if (s.st_mode & S_IFDIR)
+  }
+  if (s.st_mode & S_IFDIR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
   if (flags & W_OK)
   {
-    if (s.st_mode & S_IWRITE)
+    if (s.st_mode & S_IWRITE) {
+      __A_VARIABLE = 1;
       return 0;
+    }
+    __A_VARIABLE = 1;
     return -1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 	
diff --git a/newlib/libc/sys/sysnecv850/chmod.c b/newlib/libc/sys/sysnecv850/chmod.c
index c86e5c9..3e015de 100644
--- a/newlib/libc/sys/sysnecv850/chmod.c
+++ b/newlib/libc/sys/sysnecv850/chmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 chmod (const char *path, mode_t mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chmod, path, mode, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/chown.c b/newlib/libc/sys/sysnecv850/chown.c
index 0344d77..a93b1a4 100644
--- a/newlib/libc/sys/sysnecv850/chown.c
+++ b/newlib/libc/sys/sysnecv850/chown.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_chown, path, owner, group);
 }
diff --git a/newlib/libc/sys/sysnecv850/close.c b/newlib/libc/sys/sysnecv850/close.c
index 3c62f68..91a30ea 100644
--- a/newlib/libc/sys/sysnecv850/close.c
+++ b/newlib/libc/sys/sysnecv850/close.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_close, file, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/creat.c b/newlib/libc/sys/sysnecv850/creat.c
index 8d468a6..b04c13d 100644
--- a/newlib/libc/sys/sysnecv850/creat.c
+++ b/newlib/libc/sys/sysnecv850/creat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 creat (const char *path,
 	int mode)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_creat, path, mode, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/crt1.c b/newlib/libc/sys/sysnecv850/crt1.c
index dd0be31..840f8d2 100644
--- a/newlib/libc/sys/sysnecv850/crt1.c
+++ b/newlib/libc/sys/sysnecv850/crt1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 void __main ()
 {
   static int initialized;
@@ -13,4 +14,5 @@ void __main ()
 	(*--p) ();
 
     }
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysnecv850/execv.c b/newlib/libc/sys/sysnecv850/execv.c
index 5286be6..8d9bdcf 100644
--- a/newlib/libc/sys/sysnecv850/execv.c
+++ b/newlib/libc/sys/sysnecv850/execv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execv, path, argv, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/execve.c b/newlib/libc/sys/sysnecv850/execve.c
index b8d97f9..08dd7b5 100644
--- a/newlib/libc/sys/sysnecv850/execve.c
+++ b/newlib/libc/sys/sysnecv850/execve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_execve, path, argv, envp);
 }
diff --git a/newlib/libc/sys/sysnecv850/fork.c b/newlib/libc/sys/sysnecv850/fork.c
index 116116c..48adff1 100644
--- a/newlib/libc/sys/sysnecv850/fork.c
+++ b/newlib/libc/sys/sysnecv850/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fork, 0, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/fstat.c b/newlib/libc/sys/sysnecv850/fstat.c
index b7eed0a..ecada66 100644
--- a/newlib/libc/sys/sysnecv850/fstat.c
+++ b/newlib/libc/sys/sysnecv850/fstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _fstat (int file,
 	struct stat *st)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_fstat, file, st, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/getpid.c b/newlib/libc/sys/sysnecv850/getpid.c
index 18fd149..2d57b2d 100644
--- a/newlib/libc/sys/sysnecv850/getpid.c
+++ b/newlib/libc/sys/sysnecv850/getpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -11,5 +12,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/sys/sysnecv850/gettime.c b/newlib/libc/sys/sysnecv850/gettime.c
index fc47532..dd78c62 100644
--- a/newlib/libc/sys/sysnecv850/gettime.c
+++ b/newlib/libc/sys/sysnecv850/gettime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _gettimeofday (struct timeval *tp, void *tzp)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_gettimeofday, tp, tzp, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/isatty.c b/newlib/libc/sys/sysnecv850/isatty.c
index 95d2c0e..aa041c6 100644
--- a/newlib/libc/sys/sysnecv850/isatty.c
+++ b/newlib/libc/sys/sysnecv850/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/newlib/libc/sys/sysnecv850/kill.c b/newlib/libc/sys/sysnecv850/kill.c
index b8e5395..ba33b46 100644
--- a/newlib/libc/sys/sysnecv850/kill.c
+++ b/newlib/libc/sys/sysnecv850/kill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/newlib/libc/sys/sysnecv850/link.c b/newlib/libc/sys/sysnecv850/link.c
index 9776d79..68f1b75 100644
--- a/newlib/libc/sys/sysnecv850/link.c
+++ b/newlib/libc/sys/sysnecv850/link.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _link ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
diff --git a/newlib/libc/sys/sysnecv850/lseek.c b/newlib/libc/sys/sysnecv850/lseek.c
index b5d3ef0..820b45a 100644
--- a/newlib/libc/sys/sysnecv850/lseek.c
+++ b/newlib/libc/sys/sysnecv850/lseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _lseek (int file,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_lseek, file, ptr, dir);
 }
diff --git a/newlib/libc/sys/sysnecv850/open.c b/newlib/libc/sys/sysnecv850/open.c
index 96616e5..b0ab850 100644
--- a/newlib/libc/sys/sysnecv850/open.c
+++ b/newlib/libc/sys/sysnecv850/open.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _open (const char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_open, path, flags, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/pipe.c b/newlib/libc/sys/sysnecv850/pipe.c
index 494a99e..737349f 100644
--- a/newlib/libc/sys/sysnecv850/pipe.c
+++ b/newlib/libc/sys/sysnecv850/pipe.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 pipe (int *fd)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_pipe, fd, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/read.c b/newlib/libc/sys/sysnecv850/read.c
index ec064cb..bc340ac 100644
--- a/newlib/libc/sys/sysnecv850/read.c
+++ b/newlib/libc/sys/sysnecv850/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ _read (int file,
        char *ptr,
        int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_read, file, ptr, len);
 }
diff --git a/newlib/libc/sys/sysnecv850/rename.c b/newlib/libc/sys/sysnecv850/rename.c
index 9d9f7db..979cacd 100644
--- a/newlib/libc/sys/sysnecv850/rename.c
+++ b/newlib/libc/sys/sysnecv850/rename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 rename (const char *oldpath,
 	 const char *newpath)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_rename, oldpath, newpath, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/sbrk.c b/newlib/libc/sys/sysnecv850/sbrk.c
index 2893c32..bb74177 100644
--- a/newlib/libc/sys/sysnecv850/sbrk.c
+++ b/newlib/libc/sys/sysnecv850/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -25,5 +26,6 @@ _sbrk (int incr)
 
   heap_end += incr;
 
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
diff --git a/newlib/libc/sys/sysnecv850/stat.c b/newlib/libc/sys/sysnecv850/stat.c
index dc8351e..41513d4 100644
--- a/newlib/libc/sys/sysnecv850/stat.c
+++ b/newlib/libc/sys/sysnecv850/stat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_stat, path, st, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/time.c b/newlib/libc/sys/sysnecv850/time.c
index d0dc93f..06340f4 100644
--- a/newlib/libc/sys/sysnecv850/time.c
+++ b/newlib/libc/sys/sysnecv850/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 time_t
 time (time_t *tloc)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_time, tloc, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/times.c b/newlib/libc/sys/sysnecv850/times.c
index a558267..9962c3b 100644
--- a/newlib/libc/sys/sysnecv850/times.c
+++ b/newlib/libc/sys/sysnecv850/times.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 clock_t
 _times (struct tms *buffer)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_times, buffer, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/unlink.c b/newlib/libc/sys/sysnecv850/unlink.c
index 34b712f..46f75b0 100644
--- a/newlib/libc/sys/sysnecv850/unlink.c
+++ b/newlib/libc/sys/sysnecv850/unlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -12,5 +13,6 @@ int __trap0 (int function, int p1, int p2, int p3);
 int
 _unlink (const char *path)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_unlink, path, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/utime.c b/newlib/libc/sys/sysnecv850/utime.c
index ea1f789..df65333 100644
--- a/newlib/libc/sys/sysnecv850/utime.c
+++ b/newlib/libc/sys/sysnecv850/utime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_utime, path, times, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/wait.c b/newlib/libc/sys/sysnecv850/wait.c
index d8c96f0..9cdcdd1 100644
--- a/newlib/libc/sys/sysnecv850/wait.c
+++ b/newlib/libc/sys/sysnecv850/wait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -13,5 +14,6 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_wait, 0, 0, 0);
 }
diff --git a/newlib/libc/sys/sysnecv850/write.c b/newlib/libc/sys/sysnecv850/write.c
index 136ac9e..ce9f2e9 100644
--- a/newlib/libc/sys/sysnecv850/write.c
+++ b/newlib/libc/sys/sysnecv850/write.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -14,5 +15,6 @@ _write ( int file,
 	 char *ptr,
 	 int len)
 {
+  __A_VARIABLE = 1;
   return TRAP0 (SYS_write, file, ptr, len);
 }
diff --git a/newlib/libc/sys/sysvi386/closedir.c b/newlib/libc/sys/sysvi386/closedir.c
index d87d816..7d6b548 100644
--- a/newlib/libc/sys/sysvi386/closedir.c
+++ b/newlib/libc/sys/sysvi386/closedir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -54,5 +55,6 @@ closedir(dirp)
 	dirp->dd_loc = 0;
 	(void)free((void *)dirp->dd_buf);
 	(void)free((void *)dirp);
+	__A_VARIABLE = 1;
 	return(close(fd));
 }
diff --git a/newlib/libc/sys/sysvi386/crt0.c b/newlib/libc/sys/sysvi386/crt0.c
index b41c00a..e7fc66e 100644
--- a/newlib/libc/sys/sysvi386/crt0.c
+++ b/newlib/libc/sys/sysvi386/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/sys/sysvi386/dup.c b/newlib/libc/sys/sysvi386/dup.c
index 95b0a5c..6a9ea23 100644
--- a/newlib/libc/sys/sysvi386/dup.c
+++ b/newlib/libc/sys/sysvi386/dup.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include <fcntl.h>
 
 int
 dup (int fd1) {
+	__A_VARIABLE = 1;
 	return (fcntl (fd1, F_DUPFD, 0));
 }
diff --git a/newlib/libc/sys/sysvi386/dup2.c b/newlib/libc/sys/sysvi386/dup2.c
index 6b72599..f699b90 100644
--- a/newlib/libc/sys/sysvi386/dup2.c
+++ b/newlib/libc/sys/sysvi386/dup2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <fcntl.h>
 
 int
 dup2 (int fd1, int fd2) {
 	close (fd2);	/* ignore errors, if any */
+	__A_VARIABLE = 1;
 	return (fcntl (fd1, F_DUPFD, fd2));
 }
diff --git a/newlib/libc/sys/sysvi386/exec.c b/newlib/libc/sys/sysvi386/exec.c
index 6587d50..5e2eeba 100644
--- a/newlib/libc/sys/sysvi386/exec.c
+++ b/newlib/libc/sys/sysvi386/exec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/unistd.h>
 #include <errno.h>
 
@@ -6,11 +7,13 @@ extern char **environ;
 int
 execv (const char *path, char * const *args) {
 	extern int execve (const char *, char * const *, char * const*);
+	__A_VARIABLE = 1;
 	return execve (path, args, environ);
 }
 
 int
 execl(const char *path, const char *arg1, ...) {
+	__A_VARIABLE = 1;
 	return execv (path, &arg1);
 }
 
@@ -26,6 +29,7 @@ strccpy (char *s1, char *s2, char c) {
 		*s1++ = *s2++;
 	}
 	*s1 = 0;
+	__A_VARIABLE = 1;
 	return dest;
 }
 
@@ -36,6 +40,7 @@ execvp(const char *file, char * const *args) {
 	char buf[MAXNAMLEN];
 
 	if (file[0] == '/') {	/* absolute pathname -- easy out */
+		__A_VARIABLE = 1;
 		return execv (file, args);
 	}
 
@@ -45,10 +50,13 @@ execvp(const char *file, char * const *args) {
 		strcat (buf, "/");
 		strcat (buf, file);
 		execv (buf, args);
-		if (errno != ENOENT)
+		if (errno != ENOENT) {
+			__A_VARIABLE = 1;
 			return -1;
+		}
 		while (*path && *path != ':')
 			path++;
 	}
+	__A_VARIABLE = 1;
 	return -1;
 }
diff --git a/newlib/libc/sys/sysvi386/fpx.c b/newlib/libc/sys/sysvi386/fpx.c
index d55a1e3..360b086 100644
--- a/newlib/libc/sys/sysvi386/fpx.c
+++ b/newlib/libc/sys/sysvi386/fpx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <ieeefp.h>
 #include <machine/registers.h>
 
@@ -13,6 +14,7 @@ fp_except _DEFUN(fpsetmask,(newmask),
   oldmask = tkcw.fp_trap;
   tkcw.fp_trap = newmask;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldmask;
 
 }
@@ -21,6 +23,7 @@ fp_except _DEFUN_VOID(fpgetmask)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.fp_trap;
 }
 
@@ -29,6 +32,7 @@ fp_rnd _DEFUN_VOID(fpgetround)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.fp_rounding;
 }
 
@@ -42,6 +46,7 @@ fp_rnd _DEFUN(fpsetround,(rnd),
   oldrnd = tkcw.fp_rounding;
   tkcw.fp_rounding = rnd;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldrnd;
 }
 
@@ -53,6 +58,7 @@ fp_rdi _DEFUN_VOID(fpgetroundtoi)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.integer_rounding;
 }
 
@@ -66,6 +72,7 @@ fp_rdi _DEFUN(fpsetroundtoi,(rnd),
   oldrnd = tkcw.integer_rounding;
   tkcw.integer_rounding = rnd;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldrnd;
 }
 
diff --git a/newlib/libc/sys/sysvi386/isatty.c b/newlib/libc/sys/sysvi386/isatty.c
index fa1e355..04c1b3c 100644
--- a/newlib/libc/sys/sysvi386/isatty.c
+++ b/newlib/libc/sys/sysvi386/isatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/termio.h>
 
 int
diff --git a/newlib/libc/sys/sysvi386/opendir.c b/newlib/libc/sys/sysvi386/opendir.c
index ce080e3..950cb23 100644
--- a/newlib/libc/sys/sysvi386/opendir.c
+++ b/newlib/libc/sys/sysvi386/opendir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -50,11 +51,14 @@ opendir(name)
 	register DIR *dirp;
 	register int fd;
 
-	if ((fd = open(name, 0)) == -1)
+	if ((fd = open(name, 0)) == -1) {
+		__A_VARIABLE = 1;
 		return NULL;
+	}
 	if (fcntl(fd, F_SETFD, 1) == -1 ||
 	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	/*
@@ -68,6 +72,7 @@ opendir(name)
 
 	if (dirp->dd_buf == NULL) {
 		close (fd);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	dirp->dd_fd = fd;
@@ -76,5 +81,6 @@ opendir(name)
 	/*
 	 * Set up seek point for rewinddir.
 	 */
+	__A_VARIABLE = 1;
 	return dirp;
 }
diff --git a/newlib/libc/sys/sysvi386/readdir.c b/newlib/libc/sys/sysvi386/readdir.c
index 350fa66..e0590b5 100644
--- a/newlib/libc/sys/sysvi386/readdir.c
+++ b/newlib/libc/sys/sysvi386/readdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
diff --git a/newlib/libc/sys/sysvi386/rewinddir.c b/newlib/libc/sys/sysvi386/rewinddir.c
index d52c013..495a39e 100644
--- a/newlib/libc/sys/sysvi386/rewinddir.c
+++ b/newlib/libc/sys/sysvi386/rewinddir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 1990 The Regents of the University of California.
  * All rights reserved.
@@ -46,4 +47,5 @@ rewinddir(dirp)
 
 	_seekdir((dirp), _rewinddir);
 	_rewinddir = telldir(dirp);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysvi386/sbrk.c b/newlib/libc/sys/sysvi386/sbrk.c
index 8ae3ed1..9025d89 100644
--- a/newlib/libc/sys/sysvi386/sbrk.c
+++ b/newlib/libc/sys/sysvi386/sbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern end;
 
 static void *curbrk = (char*)&end;
diff --git a/newlib/libc/sys/sysvi386/scandir.c b/newlib/libc/sys/sysvi386/scandir.c
index 6c4116c..51d474b 100644
--- a/newlib/libc/sys/sysvi386/scandir.c
+++ b/newlib/libc/sys/sysvi386/scandir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -129,6 +130,7 @@ alphasort(d1, d2)
 	const void *d1;
 	const void *d2;
 {
+	__A_VARIABLE = 1;
 	return(strcmp((*(struct dirent **)d1)->d_name,
 	    (*(struct dirent **)d2)->d_name));
 }
diff --git a/newlib/libc/sys/sysvi386/seekdir.c b/newlib/libc/sys/sysvi386/seekdir.c
index 5033140..273ca9c 100644
--- a/newlib/libc/sys/sysvi386/seekdir.c
+++ b/newlib/libc/sys/sysvi386/seekdir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -49,4 +50,5 @@ seekdir(dirp, loc)
 {
 
 	_seekdir(dirp, loc);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysvi386/sleep.c b/newlib/libc/sys/sysvi386/sleep.c
index 723ee3c..cc3aa18 100644
--- a/newlib/libc/sys/sysvi386/sleep.c
+++ b/newlib/libc/sys/sysvi386/sleep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/signal.h>
 
@@ -8,5 +9,6 @@ sleep(unsigned secs) {
 
 	_alarm(secs);
 	_pause();
+	__A_VARIABLE = 1;
 	return (time(0) - t);
 }
diff --git a/newlib/libc/sys/sysvi386/speed.c b/newlib/libc/sys/sysvi386/speed.c
index 1b22c02..b08325c 100644
--- a/newlib/libc/sys/sysvi386/speed.c
+++ b/newlib/libc/sys/sysvi386/speed.c
@@ -1,24 +1,29 @@
+static volatile int __A_VARIABLE;
 #define _NO_MACROS
 #include <sys/termios.h>
 
 speed_t
 cfgetospeed(const struct termios *tp) {
+	__A_VARIABLE = 1;
 	return tp->c_ospeed;
 }
 
 int
 cfsetospeed(struct termios *tp, speed_t speed) {
 	tp->c_ospeed = speed;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 speed_t
 cfgetispeed(const struct termios *tp) {
+	__A_VARIABLE = 1;
 	return tp->c_ispeed;
 }
 
 int
 cfsetispeed(struct termios *tp, speed_t speed) {
 	tp->c_ispeed = speed;
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libc/sys/sysvi386/tcgetattr.c b/newlib/libc/sys/sysvi386/tcgetattr.c
index e368418..e288d49 100644
--- a/newlib/libc/sys/sysvi386/tcgetattr.c
+++ b/newlib/libc/sys/sysvi386/tcgetattr.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include <sys/termios.h>
 
 int
 tcgetattr (int fd, struct termios *tp) {
+	__A_VARIABLE = 1;
 	return _ioctl (fd, _XCGETA, tp);
 }
diff --git a/newlib/libc/sys/sysvi386/tcline.c b/newlib/libc/sys/sysvi386/tcline.c
index 39d4699..5218a65 100644
--- a/newlib/libc/sys/sysvi386/tcline.c
+++ b/newlib/libc/sys/sysvi386/tcline.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define _NO_MACROS
 #include <sys/unistd.h>
 #include <sys/termios.h>
@@ -6,19 +7,24 @@
 int
 tcsendbreak (int fd, int dur) {
 	do {
-		if (_ioctl (fd, _TCSBRK, 0) == -1)
+		if (_ioctl (fd, _TCSBRK, 0) == -1) {
+			__A_VARIABLE = 1;
 			return -1;
+		}
 	} while (dur--);
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 int
 tcdrain (int fd) {
+	__A_VARIABLE = 1;
 	return _ioctl (fd, _TCSBRK, 1);
 }
 
 int
 tcflush(int fd, int what) {
+	__A_VARIABLE = 1;
 	return _ioctl (fd, _TCFLSH, what);
 }
 
diff --git a/newlib/libc/sys/sysvi386/tcsetattr.c b/newlib/libc/sys/sysvi386/tcsetattr.c
index 1df92b2..99875e3 100644
--- a/newlib/libc/sys/sysvi386/tcsetattr.c
+++ b/newlib/libc/sys/sysvi386/tcsetattr.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <sys/termios.h>
 
 int
 tcsetattr (int fd, int opts, const struct termios *tp) {
+	__A_VARIABLE = 1;
 	return _ioctl (fd, opts, tp);
 }
 
diff --git a/newlib/libc/sys/sysvi386/telldir.c b/newlib/libc/sys/sysvi386/telldir.c
index 37d9de6..c93bfbf 100644
--- a/newlib/libc/sys/sysvi386/telldir.c
+++ b/newlib/libc/sys/sysvi386/telldir.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1983 Regents of the University of California.
  * All rights reserved.
@@ -76,14 +77,17 @@ telldir(dirp)
 	register int index;
 	register struct ddloc *lp;
 
-	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL)
+	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL) {
+		__A_VARIABLE = 1;
 		return (-1);
+	}
 	index = dd_loccnt++;
 	lp->loc_index = index;
 	lp->loc_seek = dirp->dd_seek;
 	lp->loc_loc = dirp->dd_loc;
 	lp->loc_next = dd_hash[LOCHASH(index)];
 	dd_hash[LOCHASH(index)] = lp;
+	__A_VARIABLE = 1;
 	return (index);
 }
 
@@ -109,8 +113,10 @@ _seekdir(dirp, loc)
 		prevlp = &lp->loc_next;
 		lp = lp->loc_next;
 	}
-	if (lp == NULL)
+	if (lp == NULL) {
+		__A_VARIABLE = 1;
 		return;
+	}
 	if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
 		goto found;
 	(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
@@ -126,4 +132,5 @@ found:
 	*prevlp = lp->loc_next;
 	free((caddr_t)lp);
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/sysvnecv70/fpx.c b/newlib/libc/sys/sysvnecv70/fpx.c
index d55a1e3..360b086 100644
--- a/newlib/libc/sys/sysvnecv70/fpx.c
+++ b/newlib/libc/sys/sysvnecv70/fpx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <ieeefp.h>
 #include <machine/registers.h>
 
@@ -13,6 +14,7 @@ fp_except _DEFUN(fpsetmask,(newmask),
   oldmask = tkcw.fp_trap;
   tkcw.fp_trap = newmask;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldmask;
 
 }
@@ -21,6 +23,7 @@ fp_except _DEFUN_VOID(fpgetmask)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.fp_trap;
 }
 
@@ -29,6 +32,7 @@ fp_rnd _DEFUN_VOID(fpgetround)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.fp_rounding;
 }
 
@@ -42,6 +46,7 @@ fp_rnd _DEFUN(fpsetround,(rnd),
   oldrnd = tkcw.fp_rounding;
   tkcw.fp_rounding = rnd;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldrnd;
 }
 
@@ -53,6 +58,7 @@ fp_rdi _DEFUN_VOID(fpgetroundtoi)
 {
   v60_tkcw_type tkcw;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return tkcw.integer_rounding;
 }
 
@@ -66,6 +72,7 @@ fp_rdi _DEFUN(fpsetroundtoi,(rnd),
   oldrnd = tkcw.integer_rounding;
   tkcw.integer_rounding = rnd;
   sysv60(0, 8, &tkcw);
+  __A_VARIABLE = 1;
   return oldrnd;
 }
 
diff --git a/newlib/libc/sys/tic80/crt0.c b/newlib/libc/sys/tic80/crt0.c
index ff25e4a..fca9701 100644
--- a/newlib/libc/sys/tic80/crt0.c
+++ b/newlib/libc/sys/tic80/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This is mostly just a placeholder (copied from m88kbug) until we
    figure out what it really should be... -fnf */
 
@@ -19,4 +20,5 @@ _start()
 
   main(0, 0);
   _exit();
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/tirtos/lock.c b/newlib/libc/sys/tirtos/lock.c
index afd4d01..8bff6b7 100644
--- a/newlib/libc/sys/tirtos/lock.c
+++ b/newlib/libc/sys/tirtos/lock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014, Texas Instruments Incorporated
  * All rights reserved.
@@ -43,50 +44,60 @@
 
 void __libc_lock_init(_LOCK_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_close(_LOCK_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_acquire(_LOCK_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_release(_LOCK_T *lock)
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock)\
 {
+    __A_VARIABLE = 1;
     return;
 }
 
 int __libc_lock_try_acquire(_LOCK_T *lock)
 {
+    __A_VARIABLE = 1;
     return -1;
 }
 
 int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock)
 {
+    __A_VARIABLE = 1;
     return -1;
 }
diff --git a/newlib/libc/sys/w65/crt0.c b/newlib/libc/sys/w65/crt0.c
index b759897..2b20b30 100644
--- a/newlib/libc/sys/w65/crt0.c
+++ b/newlib/libc/sys/w65/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 int p;
@@ -13,4 +14,5 @@ int  *s;
 
   main();
   exit(0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/sys/w65/syscalls.c b/newlib/libc/sys/w65/syscalls.c
index 4f5b108..bf7b0c1 100644
--- a/newlib/libc/sys/w65/syscalls.c
+++ b/newlib/libc/sys/w65/syscalls.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -11,6 +12,7 @@ _read (int file,
        char *ptr,
        int len)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_read, file, ptr, len);
 }
 
@@ -20,6 +22,7 @@ _lseek (int file,
 	int ptr,
 	int dir)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_lseek, file, ptr, dir);
 }
 
@@ -28,6 +31,7 @@ writechar (char c)
 {
   asm ("lda %0" : : "r" (c));
   asm ("wdm");
+  __A_VARIABLE = 1;
 }
 
 
@@ -38,6 +42,7 @@ _write (
 	 char *ptr,
 	 int len)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_write, file, ptr, len);
 }
 
@@ -46,6 +51,7 @@ _write (
 int
 _close (int file)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_close, file, 0, 0);
 }
 
@@ -70,6 +76,7 @@ _sbrk (int incr)
     }
 
   heap_end += incr;
+  __A_VARIABLE = 1;
   return (caddr_t) prev_heap_end;
 }
 
@@ -81,6 +88,7 @@ _fstat (int file,
 	struct stat *st)
 {
   st->st_mode = S_IFCHR;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -90,12 +98,14 @@ _open (
 	char *path,
 	int flags)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_open, path, flags, 0);
 }
 
 int
 _unlink ()
 {
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -109,6 +119,7 @@ isatty (fd)
 
 _exit (n)
 {
+  __A_VARIABLE = 1;
   return __trap3 (SYS_exit, n, 0, 0);
 }
 
@@ -121,6 +132,7 @@ _kill (n, m)
 
 _getpid (n)
 {
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -130,24 +142,28 @@ _getpid (n)
 _raise ()
 {
 
+	__A_VARIABLE = 1;
 }
 
 int
 _stat (const char *path, struct stat *st)
 
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_stat, path, st, 0);
 }
 
 int
 _chmod (const char *path, short mode)
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_chmod, path, mode);
 }
 
 int
 _chown (const char *path, short owner, short group)
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_chown, path, owner, group);
 }
 
@@ -156,12 +172,14 @@ _utime (path, times)
      const char *path;
      char *times;
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_utime, path, times);
 }
 
 int
 _fork ()
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_fork);
 }
 
@@ -169,23 +187,27 @@ int
 _wait (statusp)
      int *statusp;
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_wait);
 }
 
 int
 _execve (const char *path, char *const argv[], char *const envp[])
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_execve, path, argv, envp);
 }
 
 int
 _execv (const char *path, char *const argv[])
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_execv, path, argv);
 }
 
 int
 _pipe (int *fd)
 {
+  __A_VARIABLE = 1;
   return _trap3 (SYS_pipe, fd);
 }
diff --git a/newlib/libc/sys/w65/trap.c b/newlib/libc/sys/w65/trap.c
index 1f49999..7e3f7cb 100644
--- a/newlib/libc/sys/w65/trap.c
+++ b/newlib/libc/sys/w65/trap.c
@@ -1,9 +1,11 @@
+static volatile int __A_VARIABLE;
 
 
 
 _trap3()
 {
 
+	__A_VARIABLE = 1;
 }
 
 
diff --git a/newlib/libc/sys/z8ksim/crt0.c b/newlib/libc/sys/z8ksim/crt0.c
index f9aad6d..53ed7f0 100644
--- a/newlib/libc/sys/z8ksim/crt0.c
+++ b/newlib/libc/sys/z8ksim/crt0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 extern char _start_bss;
 extern char _end_bss;
 extern int main(int argc, char **argv, char **environ);
@@ -10,6 +11,7 @@ enter()
   __main();
 #endif
   exit(main(0,0,0));
+  __A_VARIABLE = 1;
 }
 start()
 {
@@ -31,6 +33,7 @@ start()
     *p++ = 0;
   }
   enter();
+  __A_VARIABLE = 1;
 }
 
 #if defined(__Z8002__)
@@ -44,6 +47,7 @@ void __do_global_ctors ()
     {
       (*--p)();
     }
+    __A_VARIABLE = 1;
 }
 
 void __main()
@@ -54,5 +58,6 @@ void __main()
       initialized = 1;
       __do_global_ctors ();
     }
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/newlib/libc/sys/z8ksim/glue.c b/newlib/libc/sys/z8ksim/glue.c
index b3b0bab..2285499 100644
--- a/newlib/libc/sys/z8ksim/glue.c
+++ b/newlib/libc/sys/z8ksim/glue.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "sys/syscall.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -15,6 +16,7 @@ static int argl(long value)
   asm("ld r0,%H0" : : "r" (value));
   asm("ld r1,%I0" : : "r" (value));
   asm("sc %0" : : "i" (SYS_ARG)); 
+  __A_VARIABLE = 1;
 }
 
 
@@ -36,6 +38,7 @@ static int argp(void *value)
 #endif
   asm("sc %0" : : "i" (SYS_ARG)); 
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -52,6 +55,7 @@ int _read (int fd, char *buf,size_t nbytes)
   ARGP(1,buf);
   ARGP(2,(void *)(nbytes));
   MACRO(SYS_read);
+  __A_VARIABLE = 1;
 }
 
 int _write (int fd, char *buf, size_t nbytes)
@@ -60,6 +64,7 @@ int _write (int fd, char *buf, size_t nbytes)
   ARGP(1,buf);
   ARGP(2,(void *)(nbytes));
   MACRO(SYS_write);
+  __A_VARIABLE = 1;
 }
 
 int _open (const char *buf, int flags, int mode)
@@ -68,12 +73,14 @@ int _open (const char *buf, int flags, int mode)
   ARGW(1, flags);
   ARGW(2, mode);
   MACRO(SYS_open);
+  __A_VARIABLE = 1;
 }
 
 int _close (int fd)
 {
   ARGW(0,fd);
   MACRO(SYS_close );
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -104,6 +111,7 @@ int isatty (int fd)
 {
   ARGW(0,fd);
   MACRO(SYS_isatty);
+  __A_VARIABLE = 1;
 }
 
 off_t _lseek (int fd,  off_t offset, int whence)
@@ -112,6 +120,7 @@ off_t _lseek (int fd,  off_t offset, int whence)
   ARGL(1,offset);
   ARGW(2, whence);
   MACRO(SYS_lseek);
+  __A_VARIABLE = 1;
 }
 
 int _fstat (int fd, struct stat *buf)
@@ -119,6 +128,7 @@ int _fstat (int fd, struct stat *buf)
   ARGW(0,fd);
   ARGP(1,buf);
   MACRO(SYS_fstat);
+  __A_VARIABLE = 1;
 }
 
 
@@ -129,12 +139,14 @@ _exit(int val)
 {
   ARGW(0,val);
   MACRO(SYS_exit);
+  __A_VARIABLE = 1;
 }
 
 time_t _time(time_t *timer)
 {
   ARGP(0,timer);
   MACRO(SYS_time);
+  __A_VARIABLE = 1;
 }
 
 int
@@ -143,14 +155,17 @@ _creat (const char *path, int mode)
   ARGP(0, path);
   ARGW(1, mode);
   MACRO(SYS_creat);
+  __A_VARIABLE = 1;
 }
 
 _kill(int pid, int val)
 {
   _exit(val);
+  __A_VARIABLE = 1;
 }
 
 _getpid() 
 {
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/syscalls/sysclose.c b/newlib/libc/syscalls/sysclose.c
index 946544b..c5e401c 100644
--- a/newlib/libc/syscalls/sysclose.c
+++ b/newlib/libc/syscalls/sysclose.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for close */
 
 #include <reent.h>
@@ -7,5 +8,6 @@ int
 _DEFUN (close, (fd),
      int fd)
 {
+  __A_VARIABLE = 1;
   return _close_r (_REENT, fd);
 }
diff --git a/newlib/libc/syscalls/sysexecve.c b/newlib/libc/syscalls/sysexecve.c
index 154c082..e2be1cd 100644
--- a/newlib/libc/syscalls/sysexecve.c
+++ b/newlib/libc/syscalls/sysexecve.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for execve */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (execve, (name, argv, env),
      char *_CONST argv[] _AND
      char *_CONST env[])
 {
+  __A_VARIABLE = 1;
   return _execve_r (_REENT, name, argv, env);
 }
diff --git a/newlib/libc/syscalls/sysfcntl.c b/newlib/libc/syscalls/sysfcntl.c
index 12d09a8..e39908c 100644
--- a/newlib/libc/syscalls/sysfcntl.c
+++ b/newlib/libc/syscalls/sysfcntl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for fcntl */
 /* only called from stdio/fdopen.c, so arg can be int. */
 
@@ -11,6 +12,7 @@ _DEFUN (fcntl, (fd, flag, arg),
      int arg)
 {
 #ifdef HAVE_FCNTL
+  __A_VARIABLE = 1;
   return _fcntl_r (_REENT, fd, flag, arg);
 #else /* !HAVE_FCNTL */
   errno = ENOSYS;
diff --git a/newlib/libc/syscalls/sysfork.c b/newlib/libc/syscalls/sysfork.c
index 21e6be0..3995936 100644
--- a/newlib/libc/syscalls/sysfork.c
+++ b/newlib/libc/syscalls/sysfork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for fork */
 
 /* Don't define this if NO_FORK.  See for example libc/sys/win32/spawn.c.  */
@@ -10,6 +11,7 @@
 int
 _DEFUN_VOID (fork)
 {
+  __A_VARIABLE = 1;
   return _fork_r (_REENT);
 }
 
diff --git a/newlib/libc/syscalls/sysfstat.c b/newlib/libc/syscalls/sysfstat.c
index 7ce2c9d..f9ed5eb 100644
--- a/newlib/libc/syscalls/sysfstat.c
+++ b/newlib/libc/syscalls/sysfstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for fstat */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (fstat, (fd, pstat),
      int fd _AND
      struct stat *pstat)
 {
+  __A_VARIABLE = 1;
   return _fstat_r (_REENT, fd, pstat);
 }
diff --git a/newlib/libc/syscalls/sysgetpid.c b/newlib/libc/syscalls/sysgetpid.c
index f18783c..3b75869 100644
--- a/newlib/libc/syscalls/sysgetpid.c
+++ b/newlib/libc/syscalls/sysgetpid.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for getpid */
 
 #include <reent.h>
@@ -6,5 +7,6 @@
 int
 _DEFUN_VOID (getpid)
 {
+  __A_VARIABLE = 1;
   return _getpid_r (_REENT);
 }
diff --git a/newlib/libc/syscalls/sysgettod.c b/newlib/libc/syscalls/sysgettod.c
index af6d8ab..7f98a6d 100644
--- a/newlib/libc/syscalls/sysgettod.c
+++ b/newlib/libc/syscalls/sysgettod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for gettimeofday */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (gettimeofday, (ptimeval, ptimezone),
      struct timeval *ptimeval _AND
      void *ptimezone)
 {
+  __A_VARIABLE = 1;
   return _gettimeofday_r (_REENT, ptimeval, ptimezone);
 }
diff --git a/newlib/libc/syscalls/sysisatty.c b/newlib/libc/syscalls/sysisatty.c
index 5a6b8d4..a056858 100644
--- a/newlib/libc/syscalls/sysisatty.c
+++ b/newlib/libc/syscalls/sysisatty.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for isatty */
 
 #include <reent.h>
@@ -8,6 +9,7 @@ _DEFUN (isatty, (fd),
      int fd)
 {
 #ifdef REENTRANT_SYSCALLS_PROVIDED
+  __A_VARIABLE = 1;
   return _isatty_r (_REENT, fd);
 #else
   return _isatty (fd);
diff --git a/newlib/libc/syscalls/syskill.c b/newlib/libc/syscalls/syskill.c
index 27f16be..293ad06 100644
--- a/newlib/libc/syscalls/syskill.c
+++ b/newlib/libc/syscalls/syskill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for kill */
 
 #include <reent.h>
@@ -8,5 +9,6 @@ _DEFUN (kill, (pid, sig),
      int pid _AND
      int sig)
 {
+  __A_VARIABLE = 1;
   return _kill_r (_REENT, pid, sig);
 }
diff --git a/newlib/libc/syscalls/syslink.c b/newlib/libc/syscalls/syslink.c
index 3278707..277ec61 100644
--- a/newlib/libc/syscalls/syslink.c
+++ b/newlib/libc/syscalls/syslink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for link */
 
 #include <reent.h>
@@ -8,5 +9,6 @@ _DEFUN (link, (old, new),
      _CONST char *old _AND
      _CONST char *new)
 {
+  __A_VARIABLE = 1;
   return _link_r (_REENT, old, new);
 }
diff --git a/newlib/libc/syscalls/syslseek.c b/newlib/libc/syscalls/syslseek.c
index 275d67c..25852bc 100644
--- a/newlib/libc/syscalls/syslseek.c
+++ b/newlib/libc/syscalls/syslseek.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for lseek */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (lseek, (fd, pos, whence),
      off_t pos _AND
      int whence)
 {
+  __A_VARIABLE = 1;
   return _lseek_r (_REENT, fd, pos, whence);
 }
diff --git a/newlib/libc/syscalls/sysopen.c b/newlib/libc/syscalls/sysopen.c
index ed0cb60..c90fc6f 100644
--- a/newlib/libc/syscalls/sysopen.c
+++ b/newlib/libc/syscalls/sysopen.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for open */
 
 #include <reent.h>
@@ -20,6 +21,7 @@ _DEFUN (open, (file, flags, ...),
   va_start (ap, flags);
   ret = _open_r (_REENT, file, flags, va_arg (ap, int));
   va_end (ap);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -31,6 +33,7 @@ open (file, flags, mode)
      int flags;
      int mode;
 {
+  __A_VARIABLE = 1;
   return _open_r (_REENT, file, flags, mode);
 }
 
diff --git a/newlib/libc/syscalls/sysread.c b/newlib/libc/syscalls/sysread.c
index bcf002d..b6a2136 100644
--- a/newlib/libc/syscalls/sysread.c
+++ b/newlib/libc/syscalls/sysread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for read */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (read, (fd, buf, cnt),
      void *buf _AND
      size_t cnt)
 {
+  __A_VARIABLE = 1;
   return _read_r (_REENT, fd, buf, cnt);
 }
diff --git a/newlib/libc/syscalls/syssbrk.c b/newlib/libc/syscalls/syssbrk.c
index a3e5505..4708733 100644
--- a/newlib/libc/syscalls/syssbrk.c
+++ b/newlib/libc/syscalls/syssbrk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for sbrk */
 
 #include <reent.h>
@@ -10,5 +11,6 @@ void *
 _DEFUN (sbrk, (incr),
      ptrdiff_t incr)
 {
+  __A_VARIABLE = 1;
   return _sbrk_r (_REENT, incr);
 }
diff --git a/newlib/libc/syscalls/sysstat.c b/newlib/libc/syscalls/sysstat.c
index fdf029c..8c7fcbe 100644
--- a/newlib/libc/syscalls/sysstat.c
+++ b/newlib/libc/syscalls/sysstat.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for stat */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (stat, (file, pstat),
      _CONST char *file _AND
      struct stat *pstat)
 {
+  __A_VARIABLE = 1;
   return _stat_r (_REENT, file, pstat);
 }
diff --git a/newlib/libc/syscalls/systimes.c b/newlib/libc/syscalls/systimes.c
index cc30a3e..bcafe1e 100644
--- a/newlib/libc/syscalls/systimes.c
+++ b/newlib/libc/syscalls/systimes.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for times */
 
 #include <reent.h>
@@ -7,5 +8,6 @@ clock_t
 _DEFUN (times, (buf),
      struct tms *buf)
 {
+  __A_VARIABLE = 1;
   return _times_r (_REENT, buf);
 }
diff --git a/newlib/libc/syscalls/sysunlink.c b/newlib/libc/syscalls/sysunlink.c
index 1399a80..305295b 100644
--- a/newlib/libc/syscalls/sysunlink.c
+++ b/newlib/libc/syscalls/sysunlink.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for unlink */
 
 #include <reent.h>
@@ -7,5 +8,6 @@ int
 _DEFUN (unlink, (file),
         _CONST char *file)
 {
+  __A_VARIABLE = 1;
   return _unlink_r (_REENT, file);
 }
diff --git a/newlib/libc/syscalls/syswait.c b/newlib/libc/syscalls/syswait.c
index 0701603..fcf3d96 100644
--- a/newlib/libc/syscalls/syswait.c
+++ b/newlib/libc/syscalls/syswait.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for wait */
 
 #include <reent.h>
@@ -7,5 +8,6 @@ pid_t
 _DEFUN (wait, (status),
         int *status)
 {
+  __A_VARIABLE = 1;
   return _wait_r (_REENT, status);
 }
diff --git a/newlib/libc/syscalls/syswrite.c b/newlib/libc/syscalls/syswrite.c
index 0f080fb..dc471fc 100644
--- a/newlib/libc/syscalls/syswrite.c
+++ b/newlib/libc/syscalls/syswrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* connector for write */
 
 #include <reent.h>
@@ -9,5 +10,6 @@ _DEFUN (write, (fd, buf, cnt),
      const void *buf _AND
      size_t cnt)
 {
+  __A_VARIABLE = 1;
   return _write_r (_REENT, fd, buf, cnt);
 }
diff --git a/newlib/libc/time/asctime.c b/newlib/libc/time/asctime.c
index f56b511..524d850 100644
--- a/newlib/libc/time/asctime.c
+++ b/newlib/libc/time/asctime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * asctime.c
  * Original Author:	G. Haley
@@ -62,6 +63,7 @@ _DEFUN (asctime, (tim_p),
   struct _reent *reent = _REENT;
 
   _REENT_CHECK_ASCTIME_BUF(reent);
+  __A_VARIABLE = 1;
   return asctime_r (tim_p, _REENT_ASCTIME_BUF(reent));
 }
 
diff --git a/newlib/libc/time/asctime_r.c b/newlib/libc/time/asctime_r.c
index 2ec5369..6aa34d6 100644
--- a/newlib/libc/time/asctime_r.c
+++ b/newlib/libc/time/asctime_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * asctime_r.c
  */
@@ -23,5 +24,6 @@ _DEFUN (asctime_r, (tim_p, result),
 	    mon_name[tim_p->tm_mon],
 	    tim_p->tm_mday, tim_p->tm_hour, tim_p->tm_min,
 	    tim_p->tm_sec, 1900 + tim_p->tm_year);
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libc/time/clock.c b/newlib/libc/time/clock.c
index 0bcfbb6..fe8f76f 100644
--- a/newlib/libc/time/clock.c
+++ b/newlib/libc/time/clock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NetWare can not use this implementation of clock, since it does not
    have times or any similar function.  It provides its own version of
    clock in clib.nlm.  If we can not use clib.nlm, then we must write
@@ -63,6 +64,7 @@ clock ()
     res = (clock_t) (tim_s.tms_utime + tim_s.tms_stime +
 		     tim_s.tms_cutime + tim_s.tms_cstime);
 
+  __A_VARIABLE = 1;
   return res;
 }
 
diff --git a/newlib/libc/time/ctime.c b/newlib/libc/time/ctime.c
index df070a8..0863555 100644
--- a/newlib/libc/time/ctime.c
+++ b/newlib/libc/time/ctime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ctime.c
  * Original Author:	G. Haley
@@ -49,6 +50,7 @@ char *
 _DEFUN (ctime, (tim_p),
 	_CONST time_t * tim_p)
 {
+  __A_VARIABLE = 1;
   return asctime (localtime (tim_p));
 }
 
diff --git a/newlib/libc/time/ctime_r.c b/newlib/libc/time/ctime_r.c
index fda8cac..0185588 100644
--- a/newlib/libc/time/ctime_r.c
+++ b/newlib/libc/time/ctime_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ctime_r.c
  */
@@ -11,5 +12,6 @@ _DEFUN (ctime_r, (tim_p, result),
 
 {
   struct tm tm;
+  __A_VARIABLE = 1;
   return asctime_r (localtime_r (tim_p, &tm), result);
 }
diff --git a/newlib/libc/time/difftime.c b/newlib/libc/time/difftime.c
index de6ffdb..f0f0327 100644
--- a/newlib/libc/time/difftime.c
+++ b/newlib/libc/time/difftime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * difftime.c
  * Original Author:	G. Haley
@@ -40,5 +41,6 @@ _DEFUN (difftime, (tim1, tim2),
 	time_t tim1 _AND
 	time_t tim2)
 {
+  __A_VARIABLE = 1;
   return (double)(tim1 - tim2);
 }
diff --git a/newlib/libc/time/gettzinfo.c b/newlib/libc/time/gettzinfo.c
index 54c9bc2..018de15 100644
--- a/newlib/libc/time/gettzinfo.c
+++ b/newlib/libc/time/gettzinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <local.h>
 
@@ -11,5 +12,6 @@ static __tzinfo_type tzinfo = {1, 0,
 __tzinfo_type *
 __gettzinfo (void)
 {
+  __A_VARIABLE = 1;
   return &tzinfo;
 }
diff --git a/newlib/libc/time/gmtime.c b/newlib/libc/time/gmtime.c
index 141d203..02ca4c1 100644
--- a/newlib/libc/time/gmtime.c
+++ b/newlib/libc/time/gmtime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * gmtime.c
  * Original Author:	G. Haley
@@ -64,6 +65,7 @@ _DEFUN (gmtime, (tim_p),
   struct _reent *reent = _REENT;
 
   _REENT_CHECK_TM(reent);
+  __A_VARIABLE = 1;
   return gmtime_r (tim_p, (struct tm *)_REENT_TM(reent));
 }
 
diff --git a/newlib/libc/time/gmtime_r.c b/newlib/libc/time/gmtime_r.c
index 6475df3..a16c776 100644
--- a/newlib/libc/time/gmtime_r.c
+++ b/newlib/libc/time/gmtime_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * gmtime_r.c
  * Original Author: Adapted from tzcode maintained by Arthur David Olson.
@@ -97,5 +98,6 @@ _DEFUN (gmtime_r, (tim_p, res),
 
   res->tm_isdst = 0;
 
+  __A_VARIABLE = 1;
   return (res);
 }
diff --git a/newlib/libc/time/lcltime.c b/newlib/libc/time/lcltime.c
index 2c9a25f..1968645 100644
--- a/newlib/libc/time/lcltime.c
+++ b/newlib/libc/time/lcltime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * localtime.c
  */
@@ -57,6 +58,7 @@ _DEFUN (localtime, (tim_p),
   struct _reent *reent = _REENT;
 
   _REENT_CHECK_TM(reent);
+  __A_VARIABLE = 1;
   return localtime_r (tim_p, (struct tm *)_REENT_TM(reent));
 }
 
diff --git a/newlib/libc/time/lcltime_r.c b/newlib/libc/time/lcltime_r.c
index 3342e99..718ace6 100644
--- a/newlib/libc/time/lcltime_r.c
+++ b/newlib/libc/time/lcltime_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * localtime_r.c
  * Original Author: Adapted from tzcode maintained by Arthur David Olson.
@@ -123,5 +124,6 @@ _DEFUN (localtime_r, (tim_p, res),
     }
   TZ_UNLOCK;
 
+  __A_VARIABLE = 1;
   return (res);
 }
diff --git a/newlib/libc/time/mktime.c b/newlib/libc/time/mktime.c
index 44c0257..fe078f0 100644
--- a/newlib/libc/time/mktime.c
+++ b/newlib/libc/time/mktime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * mktime.c
  * Original Author:	G. Haley
@@ -151,6 +152,7 @@ _DEFUN(validate_structure, (tim_p),
 	    }
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 time_t 
@@ -178,8 +180,10 @@ _DEFUN(mktime, (tim_p),
   /* compute day of the year */
   tim_p->tm_yday = days;
 
-  if (tim_p->tm_year > 10000 || tim_p->tm_year < -10000)
+  if (tim_p->tm_year > 10000 || tim_p->tm_year < -10000) {
+      __A_VARIABLE = 1;
       return (time_t) -1;
+  }
 
   /* compute days in other years */
   if ((year = tim_p->tm_year) > 70)
@@ -285,5 +289,6 @@ _DEFUN(mktime, (tim_p),
   if ((tim_p->tm_wday = (days + 4) % 7) < 0)
     tim_p->tm_wday += 7;
 	
+  __A_VARIABLE = 1;
   return tim;
 }
diff --git a/newlib/libc/time/month_lengths.c b/newlib/libc/time/month_lengths.c
index 2871802..86f497e 100644
--- a/newlib/libc/time/month_lengths.c
+++ b/newlib/libc/time/month_lengths.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * month_lengths.c
  *
diff --git a/newlib/libc/time/strftime.c b/newlib/libc/time/strftime.c
index 3823180..015d803 100644
--- a/newlib/libc/time/strftime.c
+++ b/newlib/libc/time/strftime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* NOTE:  This file defines both strftime() and wcsftime().  Take care when
  * making changes.  See also wcsftime.c, and note the (small) overlap in the
  * manual description, taking care to edit both as needed.  */
@@ -334,6 +335,7 @@ locale, hard-coding the "C" locale settings.
       *len_ret = mbstowcs (buf, elem, CTLOCBUFLEN - 1);
       if (*len_ret == (size_t) -1 )
 	*len_ret = 0;
+      __A_VARIABLE = 1;
       return buf;
     }
 #   define _ctloc(x) (ctloc = __ctloc (ctlocbuf, _CurrentTimeLocale->x, \
@@ -380,7 +382,8 @@ _DEFUN (iso_year_adjust, (tim_p),
     case PACK (1, 0, 1): /* Jan 2 is Sun, leap year.  */
     case PACK (2, 0, 0): /* Jan 3 is Sun, not leap.  */
     case PACK (2, 0, 1): /* Jan 3 is Sun, leap year.  */
-      return -1; /* Belongs to last week of previous year.  */
+      __A_VARIABLE = 1;
+    return -1; /* Belongs to last week of previous year.  */
     case PACK (362, 1, 0): /* Dec 29 is Mon, not leap.  */
     case PACK (363, 1, 1): /* Dec 29 is Mon, leap year.  */
     case PACK (363, 1, 0): /* Dec 30 is Mon, not leap.  */
@@ -393,8 +396,10 @@ _DEFUN (iso_year_adjust, (tim_p),
     case PACK (365, 1, 1): /* Dec 31 is Mon, leap year.  */
     case PACK (365, 2, 1): /* Dec 31 is Tue, leap year.  */
     case PACK (365, 3, 1): /* Dec 31 is Wed, leap year.  */
-      return 1; /* Belongs to first week of next year.  */
+      __A_VARIABLE = 1;
+    return 1; /* Belongs to first week of next year.  */
     }
+  __A_VARIABLE = 1;
   return 0; /* Belongs to specified year.  */
 #undef PACK
 }
@@ -568,6 +573,7 @@ free_era_info (era_info_t *ei)
   free (ei->era_C);
   free (ei->era_Y);
   free (ei);
+  __A_VARIABLE = 1;
 }
 
 typedef struct {
@@ -657,6 +663,7 @@ free_alt_digits (alt_digits_t *adi)
   free (adi->digit);
   free (adi->buffer);
   free (adi);
+  __A_VARIABLE = 1;
 }
 
 /* Return 0 if no alt_digit is available for a number.
@@ -668,11 +675,15 @@ conv_to_alt_digits (CHAR *buf, size_t bufsiz, unsigned num, alt_digits_t *adi)
   if (num < adi->num)
     {
       size_t len = STRLEN (adi->digit[num]);
-      if (bufsiz < len)
+      if (bufsiz < len) {
+      	__A_VARIABLE = 1;
       	return -1;
+      }
       STRCPY (buf, adi->digit[num]);
+      __A_VARIABLE = 1;
       return (int) len;
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1821,7 +1832,8 @@ const struct list  List[] = {
 
 #if defined(STUB_getenv_r)
 char *
-_getenv_r(struct _reent *p, const char *cp) { return getenv(cp); }
+_getenv_r(struct _reent *p, const char *cp) { __A_VARIABLE = 1;
+	return getenv(cp); }
 #endif
 
 int
@@ -1836,10 +1848,12 @@ size_t  ret;
 cp = TZ;
 if((i=putenv(cp)))  {
     printf( "putenv(%s) FAILED, ret %d\n", cp, i);
+    __A_VARIABLE = 1;
     return(-1);
     }
 if(strcmp(getenv("TZ"),strchr(TZ,'=')+1))  {
     printf( "TZ not set properly in environment\n");
+    __A_VARIABLE = 1;
     return(-2);
     }
 tzset();
@@ -1931,6 +1945,7 @@ if(errr || erro)  printf("FAILED %d/%d of", errr, erro);
   else    printf("passed");
 printf(" %d test cases.\n", tot);
 
+__A_VARIABLE = 1;
 return(errr || erro);
 }
 #endif /* defined(_REGRESSION_TEST) ] */
diff --git a/newlib/libc/time/strptime.c b/newlib/libc/time/strptime.c
index 2ec001a..7f003d3 100644
--- a/newlib/libc/time/strptime.c
+++ b/newlib/libc/time/strptime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 1999 Kungliga Tekniska Hgskolan
  * (Royal Institute of Technology, Stockholm, Sweden). 
@@ -67,6 +68,7 @@ const int tm_year_base = 1900;
 static int
 is_leap_year (int year)
 {
+    __A_VARIABLE = 1;
     return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
 }
 
@@ -82,9 +84,11 @@ match_string (const char *__restrict *buf, const char * const*strs,
 
 	if (strncasecmp_l (*buf, strs[i], len, locale) == 0) {
 	    *buf += len;
+	    __A_VARIABLE = 1;
 	    return i;
 	}
     }
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -96,6 +100,7 @@ first_day (int year)
 
     while (--year >= 1970)
 	ret = (ret + 365 + is_leap_year (year)) % 7;
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -114,6 +119,7 @@ set_week_number_sun (struct tm *timeptr, int wnum)
 	timeptr->tm_wday = fday;
 	timeptr->tm_yday = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -131,6 +137,7 @@ set_week_number_mon (struct tm *timeptr, int wnum)
 	timeptr->tm_wday = (fday + 1) % 7;
 	timeptr->tm_yday = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -151,6 +158,7 @@ set_week_number_mon4 (struct tm *timeptr, int wnum)
 	timeptr->tm_wday = fday;
 	timeptr->tm_yday = 0;
     }
+    __A_VARIABLE = 1;
 }
 
 char *
@@ -505,5 +513,6 @@ strptime_l (const char *buf, const char *format, struct tm *timeptr,
 char *
 strptime (const char *buf, const char *format, struct tm *timeptr)
 {
+  __A_VARIABLE = 1;
   return strptime_l (buf, format, timeptr, __get_current_locale ());
 }
diff --git a/newlib/libc/time/time.c b/newlib/libc/time/time.c
index 9de71d4..b48aaea 100644
--- a/newlib/libc/time/time.c
+++ b/newlib/libc/time/time.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<time>>---get current calendar time (as single number)
@@ -48,5 +49,6 @@ _DEFUN (time, (t),
 
   if (t)
     *t = now.tv_sec;
+  __A_VARIABLE = 1;
   return now.tv_sec;
 }
diff --git a/newlib/libc/time/tzcalc_limits.c b/newlib/libc/time/tzcalc_limits.c
index 8a0bda3..383adef 100644
--- a/newlib/libc/time/tzcalc_limits.c
+++ b/newlib/libc/time/tzcalc_limits.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * tzcalc_limits.c
  * Original Author: Adapted from tzcode maintained by Arthur David Olson.
@@ -18,8 +19,10 @@ _DEFUN (__tzcalc_limits, (year),
   int i, j;
   __tzinfo_type *_CONST tz = __gettzinfo ();
 
-  if (year < EPOCH_YEAR)
+  if (year < EPOCH_YEAR) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   tz->__tzyear = year;
 
@@ -73,5 +76,6 @@ _DEFUN (__tzcalc_limits, (year),
 
   tz->__tznorth = (tz->__tzrule[0].change < tz->__tzrule[1].change);
 
+  __A_VARIABLE = 1;
   return 1;
 }
diff --git a/newlib/libc/time/tzlock.c b/newlib/libc/time/tzlock.c
index 5ac42d7..87067d1 100644
--- a/newlib/libc/time/tzlock.c
+++ b/newlib/libc/time/tzlock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<__tz_lock>>, <<__tz_unlock>>---lock time zone global variables
@@ -45,6 +46,7 @@ _DEFUN_VOID (__tz_lock)
 #ifndef __SINGLE_THREAD__
   __lock_acquire(__tz_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
 
 _VOID
@@ -53,4 +55,5 @@ _DEFUN_VOID (__tz_unlock)
 #ifndef __SINGLE_THREAD__
   __lock_release(__tz_mutex);
 #endif
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/time/tzset.c b/newlib/libc/time/tzset.c
index e0750e1..ce30198 100644
--- a/newlib/libc/time/tzset.c
+++ b/newlib/libc/time/tzset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<tzset>>---set timezone characteristics from TZ environment variable
@@ -71,6 +72,7 @@ _VOID
 _DEFUN_VOID (_tzset_unlocked)
 {
   _tzset_unlocked_r (_REENT);
+  __A_VARIABLE = 1;
 }
 
 _VOID
@@ -79,4 +81,5 @@ _DEFUN_VOID (tzset)
   TZ_LOCK;
   _tzset_unlocked_r (_REENT);
   TZ_UNLOCK;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/time/tzset_r.c b/newlib/libc/time/tzset_r.c
index 6c21e82..72b3d8e 100644
--- a/newlib/libc/time/tzset_r.c
+++ b/newlib/libc/time/tzset_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <_ansi.h>
 #include <reent.h>
 #include <stdio.h>
@@ -190,4 +191,5 @@ _DEFUN (_tzset_r, (reent_ptr),
   TZ_LOCK;
   _tzset_unlocked_r (reent_ptr);
   TZ_UNLOCK;
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/time/tzvars.c b/newlib/libc/time/tzvars.c
index d1f1764..8280f3f 100644
--- a/newlib/libc/time/tzvars.c
+++ b/newlib/libc/time/tzvars.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <time.h>
 
 /* Global timezone variables.  */
diff --git a/newlib/libc/time/wcsftime.c b/newlib/libc/time/wcsftime.c
index f77b3d0..d2257f2 100644
--- a/newlib/libc/time/wcsftime.c
+++ b/newlib/libc/time/wcsftime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * wcsftime.c
  * Original Author:	Craig Howland, for Newlib
diff --git a/newlib/libc/unix/basename.c b/newlib/libc/unix/basename.c
index 3a9cc0c..b924644 100644
--- a/newlib/libc/unix/basename.c
+++ b/newlib/libc/unix/basename.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_BASENAME
 /* Copyright 2005 Shaun Jackman
  * Permission to use, copy, modify, and distribute this software
@@ -12,16 +13,21 @@ _DEFUN (basename, (path),
 	char *path)
 {
 	char *p;
-	if( path == NULL || *path == '\0' )
+	if( path == NULL || *path == '\0' ) {
+		__A_VARIABLE = 1;
 		return ".";
+	}
 	p = path + strlen(path) - 1;
 	while( *p == '/' ) {
-		if( p == path )
+		if( p == path ) {
+			__A_VARIABLE = 1;
 			return path;
+		}
 		*p-- = '\0';
 	}
 	while( p >= path && *p != '/' )
 		p--;
+	__A_VARIABLE = 1;
 	return p + 1;
 }
 
diff --git a/newlib/libc/unix/dirname.c b/newlib/libc/unix/dirname.c
index 164da7f..17e6a97 100644
--- a/newlib/libc/unix/dirname.c
+++ b/newlib/libc/unix/dirname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_DIRNAME
 
 /* Copyright 2005 Shaun Jackman
@@ -13,17 +14,22 @@ _DEFUN (dirname, (path),
 	char *path)
 {
 	char *p;
-	if( path == NULL || *path == '\0' )
+	if( path == NULL || *path == '\0' ) {
+		__A_VARIABLE = 1;
 		return ".";
+	}
 	p = path + strlen(path) - 1;
 	while( *p == '/' ) {
-		if( p == path )
+		if( p == path ) {
+			__A_VARIABLE = 1;
 			return path;
+		}
 		*p-- = '\0';
 	}
 	while( p >= path && *p != '/' )
 		p--;
-	return
+	__A_VARIABLE = 1;
+		return
 		p < path ? "." :
 		p == path ? "/" :
 		(*p = '\0', path);
diff --git a/newlib/libc/unix/getcwd.c b/newlib/libc/unix/getcwd.c
index 63f3424..4bc8b23 100644
--- a/newlib/libc/unix/getcwd.c
+++ b/newlib/libc/unix/getcwd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_GETCWD
 /*
  * Copyright (c) 1989, 1991 The Regents of the University of California.
diff --git a/newlib/libc/unix/getlogin.c b/newlib/libc/unix/getlogin.c
index da4f47a..d1f58ea 100644
--- a/newlib/libc/unix/getlogin.c
+++ b/newlib/libc/unix/getlogin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_GETLOGIN
 
 #include <string.h>
@@ -18,11 +19,15 @@ getlogin ()
 
   if (((tty = ttyname (0)) == 0)
       || ((tty = ttyname (1)) == 0)
-      || ((tty = ttyname (2)) == 0))
+      || ((tty = ttyname (2)) == 0)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
-  if ((utmp_fd = open (UTMP_FILE, O_RDONLY)) == -1)
+  if ((utmp_fd = open (UTMP_FILE, O_RDONLY)) == -1) {
+    __A_VARIABLE = 1;
     return 0;
+  }
 
   if (!strncmp (tty, "/dev/", 5))
     tty += 5;
@@ -35,11 +40,13 @@ getlogin ()
 	  close (utmp_fd);
 	  memset (buf, 0, sizeof (buf));
 	  strncpy (buf, utmp_buf.ut_user, sizeof (utmp_buf.ut_user));
+	  __A_VARIABLE = 1;
 	  return buf;
 	}
     }
 
   close (utmp_fd);
+  __A_VARIABLE = 1;
   return 0;
 }
 #endif /* !_NO_GETLOGIN  */
diff --git a/newlib/libc/unix/getpass.c b/newlib/libc/unix/getpass.c
index de23261..d33138e 100644
--- a/newlib/libc/unix/getpass.c
+++ b/newlib/libc/unix/getpass.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_GETPASS
 /*
  * Copyright (c) 1988 The Regents of the University of California.
@@ -96,6 +97,7 @@ getpass (prompt)
   (void) sigsetmask (omask);
   if (fp != stdin)
     (void) fclose (fp);
+  __A_VARIABLE = 1;
   return buf;
 }
 #endif /* !_NO_GETPASS  */
diff --git a/newlib/libc/unix/getpwent.c b/newlib/libc/unix/getpwent.c
index 0f13a20..b78835a 100644
--- a/newlib/libc/unix/getpwent.c
+++ b/newlib/libc/unix/getpwent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_GETPWENT
 
 #include <stdio.h>
@@ -27,6 +28,7 @@ getpwnam (name)
 
   if ((fp = fopen ("/etc/passwd", "r")) == NULL)
     {
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -46,10 +48,12 @@ getpwnam (name)
       if (!strcmp (logname, name))
 	{
 	  fclose (fp);
+	  __A_VARIABLE = 1;
 	  return &pw_passwd;
 	}
     }
   fclose (fp);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -61,6 +65,7 @@ getpwuid (uid_t uid)
 
   if ((fp = fopen ("/etc/passwd", "r")) == NULL)
     {
+      __A_VARIABLE = 1;
       return NULL;
     }
 
@@ -80,10 +85,12 @@ getpwuid (uid_t uid)
       if (uid == pw_passwd.pw_uid)
 	{
 	  fclose (fp);
+	  __A_VARIABLE = 1;
 	  return &pw_passwd;
 	}
     }
   fclose (fp);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -92,11 +99,15 @@ getpwent ()
 {
   char buf[1024];
 
-  if (passwd_fp == NULL)
+  if (passwd_fp == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
-  if (fgets (buf, sizeof (buf), passwd_fp) == NULL)
+  if (fgets (buf, sizeof (buf), passwd_fp) == NULL) {
+    __A_VARIABLE = 1;
     return NULL;
+  }
 
   sscanf (buf, "%[^:]:%[^:]:%d:%d:%[^:]:%[^:]:%s\n",
 	  logname, password, &pw_passwd.pw_uid,
@@ -109,6 +120,7 @@ getpwent ()
   pw_passwd.pw_dir = dir;
   pw_passwd.pw_shell = shell;
 
+  __A_VARIABLE = 1;
   return &pw_passwd;
 }
 
@@ -119,6 +131,7 @@ setpwent ()
     fclose (passwd_fp);
 
   passwd_fp = fopen ("/etc/passwd", "r");
+  __A_VARIABLE = 1;
 }
 
 void
@@ -126,6 +139,7 @@ endpwent ()
 {
   if (passwd_fp != NULL)
     fclose (passwd_fp);
+  __A_VARIABLE = 1;
 }
 
 #endif /* !_NO_GETPWENT  */
diff --git a/newlib/libc/unix/getut.c b/newlib/libc/unix/getut.c
index cf054cb..1083da5 100644
--- a/newlib/libc/unix/getut.c
+++ b/newlib/libc/unix/getut.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_GETUT
 
 #include <stdlib.h>
@@ -21,6 +22,7 @@ setutent ()
       utmp_fd = open (utmp_file, O_RDONLY);
     }
   lseek (utmp_fd, 0, SEEK_SET);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -28,12 +30,14 @@ endutent ()
 {
   close (utmp_fd);
   utmp_fd = -2;
+  __A_VARIABLE = 1;
 }
 
 void
 utmpname (_CONST char *file)
 {
   utmp_file = strdup (file);
+  __A_VARIABLE = 1;
 }
 
 struct utmp *
@@ -41,8 +45,11 @@ getutent ()
 {
   if (utmp_fd == -2)
     setutent ();
-  if (read (utmp_fd, &utmp_data, sizeof (utmp_data)) < sizeof (utmp_data))
+  if (read (utmp_fd, &utmp_data, sizeof (utmp_data)) < sizeof (utmp_data)) {
+    __A_VARIABLE = 1;
     return 0;
+  }
+  __A_VARIABLE = 1;
   return &utmp_data;
 }
 
@@ -57,18 +64,23 @@ getutid (struct utmp *id)
 	case BOOT_TIME:
 	case OLD_TIME:
 	case NEW_TIME:
-	  if (id->ut_type == utmp_data.ut_type)
+	  if (id->ut_type == utmp_data.ut_type) {
+	    __A_VARIABLE = 1;
 	    return &utmp_data;
+	  }
 	case INIT_PROCESS:
 	case LOGIN_PROCESS:
 	case USER_PROCESS:
 	case DEAD_PROCESS:
-	  if (id->ut_id == utmp_data.ut_id)
+	  if (id->ut_id == utmp_data.ut_id) {
+	    __A_VARIABLE = 1;
 	    return &utmp_data;
+	  }
 	default:
 	  abort ();
 	}
     }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -80,10 +92,13 @@ getutline (struct utmp *line)
       if ((utmp_data.ut_type == LOGIN_PROCESS ||
 	   utmp_data.ut_type == USER_PROCESS) &&
 	  !strncmp (utmp_data.ut_line, line->ut_line,
-		    sizeof (utmp_data.ut_line)))
+		    sizeof (utmp_data.ut_line))) {
+	__A_VARIABLE = 1;
 	return &utmp_data;
+      }
     }
 
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/unix/pread.c b/newlib/libc/unix/pread.c
index 770c3fc..6ad5f44 100644
--- a/newlib/libc/unix/pread.c
+++ b/newlib/libc/unix/pread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_PREAD
 /*
 FUNCTION
@@ -63,17 +64,24 @@ _DEFUN (_pread_r, (rptr, fd, buf, n, off),
   off_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_read;
   
-  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1)
+  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_read = _read_r (rptr, fd, buf, n);
 
-  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_read;
 }
 
@@ -86,6 +94,7 @@ _DEFUN (pread, (fd, buf, n, off),
      size_t n _AND
      off_t off)
 {
+  __A_VARIABLE = 1;
   return _pread_r (_REENT, fd, buf, n, off);
 }
 
diff --git a/newlib/libc/unix/pwrite.c b/newlib/libc/unix/pwrite.c
index 9f2a898..95ee626 100644
--- a/newlib/libc/unix/pwrite.c
+++ b/newlib/libc/unix/pwrite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_PWRITE
 /*
 FUNCTION
@@ -64,17 +65,24 @@ _DEFUN (_pwrite_r, (rptr, fd, buf, n, off),
   off_t cur_pos;
   _READ_WRITE_RETURN_TYPE num_written;
   
-  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1)
+  if ((cur_pos = _lseek_r (rptr, fd, 0, SEEK_CUR)) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
-  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, off, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
   num_written = _write_r (rptr, fd, buf, n);
 
-  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1)
+  if (_lseek_r (rptr, fd, cur_pos, SEEK_SET) == (off_t)-1) {
+    __A_VARIABLE = 1;
     return -1;
+  }
 
+  __A_VARIABLE = 1;
   return (ssize_t)num_written;
 }
 
@@ -87,6 +95,7 @@ _DEFUN (pwrite, (fd, buf, n, off),
      size_t n _AND
      off_t off)
 {
+  __A_VARIABLE = 1;
   return _pwrite_r (_REENT, fd, buf, n, off);
 }
 
diff --git a/newlib/libc/unix/sigset.c b/newlib/libc/unix/sigset.c
index 1861349..506df0f 100644
--- a/newlib/libc/unix/sigset.c
+++ b/newlib/libc/unix/sigset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_SIGSET
 
 #include <signal.h>
@@ -10,6 +11,7 @@ int
 sigemptyset (sigset_t * set)
 {
   *set = (sigset_t) 0;
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -18,6 +20,7 @@ int
 sigfillset (sigset_t * set)
 {
   *set = ~((sigset_t) 0);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -28,9 +31,11 @@ sigaddset (sigset_t * set, int signo)
   if (signo >= NSIG || signo <= 0)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
   *set |= 1 << (signo - 1);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -41,9 +46,11 @@ sigdelset (sigset_t * set, int signo)
   if (signo >= NSIG || signo <= 0)
     {
       errno = EINVAL;
+      __A_VARIABLE = 1;
       return -1;
     }
   *set &= ~(1 << (signo - 1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
diff --git a/newlib/libc/unix/ttyname.c b/newlib/libc/unix/ttyname.c
index b36bb74..942e3d5 100644
--- a/newlib/libc/unix/ttyname.c
+++ b/newlib/libc/unix/ttyname.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_TTYNAME
 /*
  * Copyright (c) 1988 The Regents of the University of California.
@@ -49,6 +50,7 @@ _DEFUN( ttyname,(fd),
   fail = ttyname_r( fd, ttyname_buf, sizeof(ttyname_buf) );
   if ( fail )  errno = fail;
    else  ret = ttyname_buf;
+  __A_VARIABLE = 1;
   return ret;
 }
 #endif /* !_NO_TTYNAME  */
diff --git a/newlib/libc/unix/ttyname_r.c b/newlib/libc/unix/ttyname_r.c
index 32bbd67..9bb9a0d 100644
--- a/newlib/libc/unix/ttyname_r.c
+++ b/newlib/libc/unix/ttyname_r.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef _NO_TTYNAME
 /*
  * Copyright (c) 1988 The Regents of the University of California.
diff --git a/newlib/libc/xdr/dummy.c b/newlib/libc/xdr/dummy.c
index 90d0120..9f6eeb3 100644
--- a/newlib/libc/xdr/dummy.c
+++ b/newlib/libc/xdr/dummy.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 /* empty stub so there's at least one file to put in objectlist.awk.in */
diff --git a/newlib/libc/xdr/xdr.c b/newlib/libc/xdr/xdr.c
index 646f9db..6b16744 100644
--- a/newlib/libc/xdr/xdr.c
+++ b/newlib/libc/xdr/xdr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
  * All rights reserved.
@@ -70,6 +71,7 @@ _DEFUN (xdr_free, (proc, objp),
 
   x.x_op = XDR_FREE;
   (*proc) (&x, objp);
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -78,6 +80,7 @@ _DEFUN (xdr_free, (proc, objp),
 bool_t
 _DEFUN_VOID (xdr_void)
 {
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -161,15 +164,22 @@ _DEFUN (xdr_long, (xdrs, lp),
 	long * lp)
 {
   if ((xdrs->x_op == XDR_ENCODE)
-      && ((sizeof (int32_t) == sizeof (long)) || ((int32_t) *lp == *lp)))
+      && ((sizeof (int32_t) == sizeof (long)) || ((int32_t) *lp == *lp))) {
+    __A_VARIABLE = 1;
     return XDR_PUTLONG (xdrs, lp);
+  }
 
-  if (xdrs->x_op == XDR_DECODE)
+  if (xdrs->x_op == XDR_DECODE) {
+    __A_VARIABLE = 1;
     return XDR_GETLONG (xdrs, lp);
+  }
 
-  if (xdrs->x_op == XDR_FREE)
+  if (xdrs->x_op == XDR_FREE) {
+    __A_VARIABLE = 1;
     return TRUE;
+  }
 
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -184,22 +194,30 @@ _DEFUN (xdr_u_long, (xdrs, ulp),
   switch (xdrs->x_op)
     {
     case XDR_ENCODE:
-      if ((sizeof (uint32_t) != sizeof (u_long)) && ((uint32_t) *ulp != *ulp))
+      if ((sizeof (uint32_t) != sizeof (u_long)) && ((uint32_t) *ulp != *ulp)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
+      __A_VARIABLE = 1;
       return (XDR_PUTLONG (xdrs, (long *) ulp));
 
     case XDR_DECODE:
       {
         long int tmp;
-        if (XDR_GETLONG (xdrs, &tmp) == FALSE)
+        if (XDR_GETLONG (xdrs, &tmp) == FALSE) {
+          __A_VARIABLE = 1;
           return FALSE;
+        }
         *ulp = (u_long) (uint32_t) tmp;
+        __A_VARIABLE = 1;
         return TRUE;
       }
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -215,14 +233,18 @@ _DEFUN (xdr_int32_t, (xdrs, int32_p),
   switch (xdrs->x_op)
     {
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, int32_p);
 
     case XDR_DECODE:
+      __A_VARIABLE = 1;
       return XDR_GETINT32(xdrs, int32_p);
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -237,14 +259,18 @@ _DEFUN (xdr_u_int32_t, (xdrs, u_int32_p),
   switch (xdrs->x_op)
     {
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)u_int32_p);
 
     case XDR_DECODE:
+      __A_VARIABLE = 1;
       return XDR_GETINT32 (xdrs, (int32_t *)u_int32_p);
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -259,14 +285,18 @@ _DEFUN (xdr_uint32_t, (xdrs, uint32_p),
   switch (xdrs->x_op)
     {
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)uint32_p);
 
     case XDR_DECODE:
+      __A_VARIABLE = 1;
       return XDR_GETINT32 (xdrs, (int32_t *)uint32_p);
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -284,17 +314,23 @@ _DEFUN (xdr_short, (xdrs, sp),
     {
     case XDR_ENCODE:
       l = (long) *sp;
+      __A_VARIABLE = 1;
       return (XDR_PUTLONG (xdrs, &l));
 
     case XDR_DECODE:
-      if (!XDR_GETLONG (xdrs, &l))
+      if (!XDR_GETLONG (xdrs, &l)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *sp = (short) l;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -312,17 +348,23 @@ _DEFUN (xdr_u_short, (xdrs, usp),
     {
     case XDR_ENCODE:
       l = (u_long) * usp;
+      __A_VARIABLE = 1;
       return XDR_PUTLONG (xdrs, &l);
 
     case XDR_DECODE:
-      if (!XDR_GETLONG (xdrs, &l))
+      if (!XDR_GETLONG (xdrs, &l)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *usp = (u_short) (u_long) l;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -341,17 +383,23 @@ _DEFUN (xdr_int16_t, (xdrs, int16_p),
     {
     case XDR_ENCODE:
       t = (int32_t) *int16_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, &t);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, &t))
+      if (!XDR_GETINT32 (xdrs, &t)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *int16_p = (int16_t) t;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -369,17 +417,23 @@ _DEFUN (xdr_u_int16_t, (xdrs, u_int16_p),
     {
     case XDR_ENCODE:
       ut = (uint32_t) *u_int16_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)&ut);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut))
+      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *u_int16_p = (u_int16_t) ut;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -397,17 +451,23 @@ _DEFUN (xdr_uint16_t, (xdrs, uint16_p),
     {
     case XDR_ENCODE:
       ut = (uint32_t) *uint16_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)&ut);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut))
+      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *uint16_p = (uint16_t) ut;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -425,17 +485,23 @@ _DEFUN (xdr_int8_t, (xdrs, int8_p),
     {
     case XDR_ENCODE:
       t = (int32_t) *int8_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, &t);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, &t))
+      if (!XDR_GETINT32 (xdrs, &t)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *int8_p = (int8_t) t;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -453,17 +519,23 @@ _DEFUN (xdr_u_int8_t, (xdrs, u_int8_p),
     {
     case XDR_ENCODE:
       ut = (uint32_t) *u_int8_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)&ut);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut))
+      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *u_int8_p = (u_int8_t) ut;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -481,17 +553,23 @@ _DEFUN (xdr_uint8_t, (xdrs, uint8_p),
     {
     case XDR_ENCODE:
       ut = (uint32_t) *uint8_p;
+      __A_VARIABLE = 1;
       return XDR_PUTINT32 (xdrs, (int32_t *)&ut);
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut))
+      if (!XDR_GETINT32 (xdrs, (int32_t *)&ut)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *uint8_p = (uint8_t) ut;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 
 }
@@ -508,9 +586,12 @@ _DEFUN (xdr_char, (xdrs, cp),
   int i;
 
   i = (*cp);
-  if (!xdr_int (xdrs, &i))
+  if (!xdr_int (xdrs, &i)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   *cp = (char) i;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -525,9 +606,12 @@ _DEFUN (xdr_u_char, (xdrs, ucp),
   u_int u;
 
   u = (*ucp);
-  if (!xdr_u_int (xdrs, &u))
+  if (!xdr_u_int (xdrs, &u)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   *ucp = (u_char) u;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -545,17 +629,23 @@ _DEFUN (xdr_bool, (xdrs, bp),
     {
     case XDR_ENCODE:
       lb = *bp ? XDR_TRUE : XDR_FALSE;
+      __A_VARIABLE = 1;
       return XDR_PUTLONG (xdrs, &lb);
 
     case XDR_DECODE:
-      if (!XDR_GETLONG (xdrs, &lb))
+      if (!XDR_GETLONG (xdrs, &lb)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *bp = (lb == XDR_FALSE) ? FALSE : TRUE;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -618,8 +708,10 @@ _DEFUN (xdr_opaque, (xdrs, cp, cnt),
   /*
    * if no data we are done
    */
-  if (cnt == 0)
+  if (cnt == 0) {
+    __A_VARIABLE = 1;
     return TRUE;
+  }
 
   /*
    * round byte count to full xdr units
@@ -631,22 +723,34 @@ _DEFUN (xdr_opaque, (xdrs, cp, cnt),
   switch (xdrs->x_op)
     {
     case XDR_DECODE:
-      if (!XDR_GETBYTES (xdrs, cp, cnt))
+      if (!XDR_GETBYTES (xdrs, cp, cnt)) {
+        __A_VARIABLE = 1;
         return FALSE;
-      if (rndup == 0)
+      }
+      if (rndup == 0) {
+        __A_VARIABLE = 1;
         return TRUE;
+      }
+      __A_VARIABLE = 1;
       return XDR_GETBYTES (xdrs, (caddr_t) crud, rndup);
 
     case XDR_ENCODE:
-      if (!XDR_PUTBYTES (xdrs, cp, cnt))
+      if (!XDR_PUTBYTES (xdrs, cp, cnt)) {
+        __A_VARIABLE = 1;
         return FALSE;
-      if (rndup == 0)
+      }
+      if (rndup == 0) {
+        __A_VARIABLE = 1;
         return TRUE;
+      }
+      __A_VARIABLE = 1;
       return (XDR_PUTBYTES (xdrs, xdr_zero, rndup));
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -668,12 +772,16 @@ _DEFUN (xdr_bytes, (xdrs, cpp, sizep, maxsize),
   /*
    * first deal with the length since xdr bytes are counted
    */
-  if (!xdr_u_int (xdrs, sizep))
+  if (!xdr_u_int (xdrs, sizep)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   nodesize = *sizep;
-  if ((nodesize > maxsize) && (xdrs->x_op != XDR_FREE))
+  if ((nodesize > maxsize) && (xdrs->x_op != XDR_FREE)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   /*
    * now deal with the actual bytes
@@ -681,19 +789,23 @@ _DEFUN (xdr_bytes, (xdrs, cpp, sizep, maxsize),
   switch (xdrs->x_op)
     {
     case XDR_DECODE:
-      if (nodesize == 0)
+      if (nodesize == 0) {
+        __A_VARIABLE = 1;
         return TRUE;
+      }
       if (sp == NULL)
         *cpp = sp = mem_alloc (nodesize);
       if (sp == NULL)
         {
           xdr_warnx ("xdr_bytes: out of memory");
           errno = ENOMEM;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       /* FALLTHROUGH */
 
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return xdr_opaque (xdrs, sp, nodesize);
 
     case XDR_FREE:
@@ -702,8 +814,10 @@ _DEFUN (xdr_bytes, (xdrs, cpp, sizep, maxsize),
           mem_free (sp, nodesize);
           *cpp = NULL;
         }
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -715,6 +829,7 @@ _DEFUN (xdr_netobj, (xdrs, np),
         XDR * xdrs _AND
 	struct netobj * np)
 {
+  __A_VARIABLE = 1;
   return (xdr_bytes (xdrs, &np->n_bytes, &np->n_len, MAX_NETOBJ_SZ));
 }
 
@@ -746,8 +861,10 @@ _DEFUN (xdr_union, (xdrs, dscmp, unp, choices, dfault),
   /*
    * we deal with the discriminator;  it's an enum
    */
-  if (!xdr_enum (xdrs, dscmp))
+  if (!xdr_enum (xdrs, dscmp)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   dscm = *dscmp;
 
@@ -757,13 +874,16 @@ _DEFUN (xdr_union, (xdrs, dscmp, unp, choices, dfault),
    */
   for (; choices->proc != NULL_xdrproc_t; choices++)
     {
-      if (choices->value == dscm)
+      if (choices->value == dscm) {
+        __A_VARIABLE = 1;
         return ((*(choices->proc)) (xdrs, unp, LASTUNSIGNED));
+      }
     }
 
   /*
    * no match - execute the default xdr routine if there is one
    */
+  __A_VARIABLE = 1;
   return ((dfault == NULL_xdrproc_t) ? FALSE : (*dfault) (xdrs, unp, LASTUNSIGNED));
 }
 
@@ -798,24 +918,32 @@ _DEFUN (xdr_string, (xdrs, cpp, maxsize),
   switch (xdrs->x_op)
     {
     case XDR_FREE:
-      if (sp == NULL)
-        return TRUE;        /* already free */
+      if (sp == NULL) {
+        __A_VARIABLE = 1;
+        return TRUE;
+      }        /* already free */
 
       /* FALLTHROUGH */
     case XDR_ENCODE:
-      if (sp == NULL)
+      if (sp == NULL) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
 
       size = strlen (sp);
       break;
     case XDR_DECODE:
       break;
     }
-  if (!xdr_u_int (xdrs, &size))
+  if (!xdr_u_int (xdrs, &size)) {
+      __A_VARIABLE = 1;
       return FALSE;
+  }
 
-  if (size > maxsize)
+  if (size > maxsize) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   nodesize = size + 1;
   if (nodesize == 0)
@@ -824,6 +952,7 @@ _DEFUN (xdr_string, (xdrs, cpp, maxsize),
        * provided a too large maxsize but nevertheless catch it
        * here.
        */
+      __A_VARIABLE = 1;
       return FALSE;
     }
 
@@ -840,19 +969,23 @@ _DEFUN (xdr_string, (xdrs, cpp, maxsize),
         {
           xdr_warnx ("xdr_string: out of memory");
           errno = ENOMEM;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       sp[size] = 0;
       /* FALLTHROUGH */
 
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return xdr_opaque (xdrs, sp, size);
 
     case XDR_FREE:
       mem_free (sp, nodesize);
       *cpp = NULL;
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -865,6 +998,7 @@ _DEFUN (xdr_wrapstring, (xdrs, cpp),
         XDR * xdrs _AND
         char ** cpp)
 {
+  __A_VARIABLE = 1;
   return xdr_string (xdrs, cpp, LASTUNSIGNED);
 }
 
@@ -893,18 +1027,24 @@ _DEFUN (xdr_int64_t, (xdrs, llp),
     case XDR_ENCODE:
       t1 = (int32_t) ((*llp) >> 32);
       t2 = (int32_t) (*llp);
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, &t1) && XDR_PUTINT32 (xdrs, &t2));
 
     case XDR_DECODE:
-      if (!XDR_GETINT32 (xdrs, &t1) || !XDR_GETINT32 (xdrs, &t2))
+      if (!XDR_GETINT32 (xdrs, &t1) || !XDR_GETINT32 (xdrs, &t2)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *llp = ((int64_t) t1) << 32;
       *llp |= (uint32_t) t2;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -924,20 +1064,26 @@ _DEFUN (xdr_u_int64_t, (xdrs, ullp),
     case XDR_ENCODE:
       t1 = (uint32_t) ((*ullp) >> 32);
       t2 = (uint32_t) (*ullp);
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, (int32_t *)&t1) &&
               XDR_PUTINT32 (xdrs, (int32_t *)&t2));
 
     case XDR_DECODE:
       if (!XDR_GETINT32 (xdrs, (int32_t *)&t1) ||
-          !XDR_GETINT32 (xdrs, (int32_t *)&t2))
+          !XDR_GETINT32 (xdrs, (int32_t *)&t2)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *ullp = ((u_int64_t) t1) << 32;
       *ullp |= t2;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -956,20 +1102,26 @@ _DEFUN (xdr_uint64_t, (xdrs, ullp),
     case XDR_ENCODE:
       t1 = (uint32_t) ((*ullp) >> 32);
       t2 = (uint32_t) (*ullp);
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, (int32_t *)&t1) &&
               XDR_PUTINT32 (xdrs, (int32_t *)&t2));
 
     case XDR_DECODE:
       if (!XDR_GETINT32 (xdrs, (int32_t *)&t1) ||
-          !XDR_GETINT32 (xdrs, (int32_t *)&t2))
+          !XDR_GETINT32 (xdrs, (int32_t *)&t2)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       *ullp = ((uint64_t) t1) << 32;
       *ullp |= t2;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -986,6 +1138,7 @@ _DEFUN (xdr_hyper, (xdrs, llp),
    * Don't bother open-coding this; it's a fair amount of code.  Just
    * call xdr_int64_t().
    */
+  __A_VARIABLE = 1;
   return (xdr_int64_t (xdrs, (int64_t *) llp));
 }
 
@@ -1002,6 +1155,7 @@ _DEFUN (xdr_u_hyper, (xdrs, ullp),
    * Don't bother open-coding this; it's a fair amount of code.  Just
    * call xdr_uint64_t().
    */
+  __A_VARIABLE = 1;
   return (xdr_uint64_t (xdrs, (uint64_t *) ullp));
 }
 
@@ -1018,6 +1172,7 @@ _DEFUN (xdr_longlong_t, (xdrs, llp),
    * Don't bother open-coding this; it's a fair amount of code.  Just
    * call xdr_int64_t().
    */
+  __A_VARIABLE = 1;
   return (xdr_int64_t (xdrs, (int64_t *) llp));
 }
 
@@ -1034,6 +1189,7 @@ _DEFUN (xdr_u_longlong_t, (xdrs, ullp),
    * Don't bother open-coding this; it's a fair amount of code.  Just
    * call xdr_u_int64_t().
    */
+  __A_VARIABLE = 1;
   return (xdr_uint64_t (xdrs, (uint64_t *) ullp));
 }
 
diff --git a/newlib/libc/xdr/xdr_array.c b/newlib/libc/xdr/xdr_array.c
index 98549ac..89d8f16 100644
--- a/newlib/libc/xdr/xdr_array.c
+++ b/newlib/libc/xdr/xdr_array.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
@@ -71,11 +72,13 @@ _DEFUN (xdr_array, (xdrs, addrp, sizep, maxsize, elsize, elproc),
   /* like strings, arrays are really counted arrays */
   if (!xdr_u_int (xdrs, sizep))
     {
+      __A_VARIABLE = 1;
       return FALSE;
     }
   c = *sizep;
   if ((c > maxsize || UINT_MAX / elsize < c) && (xdrs->x_op != XDR_FREE))
     {
+      __A_VARIABLE = 1;
       return FALSE;
     }
   nodesize = c * elsize;
@@ -88,19 +91,23 @@ _DEFUN (xdr_array, (xdrs, addrp, sizep, maxsize, elsize, elproc),
     switch (xdrs->x_op)
       {
       case XDR_DECODE:
-        if (c == 0)
+        if (c == 0) {
+          __A_VARIABLE = 1;
           return TRUE;
+        }
         *addrp = target = mem_alloc (nodesize);
         if (target == NULL)
           {
             xdr_warnx ("xdr_array: out of memory");
             errno = ENOMEM;
+            __A_VARIABLE = 1;
             return FALSE;
           }
         memset (target, 0, nodesize);
         break;
 
       case XDR_FREE:
+        __A_VARIABLE = 1;
         return TRUE;
 
       case XDR_ENCODE:
@@ -124,6 +131,7 @@ _DEFUN (xdr_array, (xdrs, addrp, sizep, maxsize, elsize, elproc),
       mem_free (*addrp, nodesize);
       *addrp = NULL;
     }
+  __A_VARIABLE = 1;
   return (stat);
 }
 
@@ -153,9 +161,11 @@ _DEFUN (xdr_vector, (xdrs, basep, nelem, elemsize, xdr_elem),
     {
       if (!(*xdr_elem) (xdrs, elptr))
         {
+          __A_VARIABLE = 1;
           return FALSE;
         }
       elptr += elemsize;
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
diff --git a/newlib/libc/xdr/xdr_float.c b/newlib/libc/xdr/xdr_float.c
index 00726bb..f704760 100644
--- a/newlib/libc/xdr/xdr_float.c
+++ b/newlib/libc/xdr/xdr_float.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
@@ -67,14 +68,18 @@ _DEFUN (xdr_float, (xdrs, fp),
     {
 
     case XDR_ENCODE:
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, (int32_t *) fp));
 
     case XDR_DECODE:
+      __A_VARIABLE = 1;
       return (XDR_GETINT32 (xdrs, (int32_t *) fp));
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
diff --git a/newlib/libc/xdr/xdr_float_vax.c b/newlib/libc/xdr/xdr_float_vax.c
index 323e43e..724c575 100644
--- a/newlib/libc/xdr/xdr_float_vax.c
+++ b/newlib/libc/xdr/xdr_float_vax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
@@ -108,12 +109,15 @@ _DEFUN (xdr_float, (xdrs, fp),
       is.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;
     shipit:
       is.sign = vs.sign;
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, (int32_t *) & is));
 
     case XDR_DECODE:
       vsp = (struct vax_single *) fp;
-      if (!XDR_GETINT32 (xdrs, (int32_t *) & is))
+      if (!XDR_GETINT32 (xdrs, (int32_t *) & is)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       for (i = 0, lim = sgl_limits;
            i < sizeof (sgl_limits) / sizeof (struct sgl_limits); i++, lim++)
         {
@@ -129,11 +133,14 @@ _DEFUN (xdr_float, (xdrs, fp),
       vsp->mantissa1 = (is.mantissa >> 16);
     doneit:
       vsp->sign = is.sign;
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -218,12 +225,15 @@ _DEFUN (xdr_double, (xdrs, dp),
     shipit:
       id.sign = vd.sign;
       lp = (int32_t *) & id;
+      __A_VARIABLE = 1;
       return (XDR_PUTINT32 (xdrs, lp++) && XDR_PUTINT32 (xdrs, lp));
 
     case XDR_DECODE:
       lp = (int32_t *) & id;
-      if (!XDR_GETINT32 (xdrs, lp++) || !XDR_GETINT32 (xdrs, lp))
+      if (!XDR_GETINT32 (xdrs, lp++) || !XDR_GETINT32 (xdrs, lp)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       for (i = 0, lim = dbl_limits;
            i < sizeof (dbl_limits) / sizeof (struct dbl_limits); i++, lim++)
         {
@@ -243,11 +253,14 @@ _DEFUN (xdr_double, (xdrs, dp),
     doneit:
       vd.sign = id.sign;
       *dp = *((double *) &vd);
+      __A_VARIABLE = 1;
       return TRUE;
 
     case XDR_FREE:
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 #endif /* !_DOUBLE_IS_32BITS */
diff --git a/newlib/libc/xdr/xdr_mem.c b/newlib/libc/xdr/xdr_mem.c
index 497342d..3a06599 100644
--- a/newlib/libc/xdr/xdr_mem.c
+++ b/newlib/libc/xdr/xdr_mem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
  * All rights reserved.
@@ -113,12 +114,14 @@ _DEFUN (xdrmem_create, (xdrs, addr, size, op),
     : (struct xdr_ops *)&xdrmem_ops_aligned;
   xdrs->x_private = xdrs->x_base = addr;
   xdrs->x_handy = size;
+  __A_VARIABLE = 1;
 }
 
 static void
 _DEFUN (xdrmem_destroy, (xdrs),
        XDR * xdrs)
 {
+	__A_VARIABLE = 1;
 }
 
 static bool_t
@@ -126,11 +129,14 @@ _DEFUN (xdrmem_getlong_aligned, (xdrs, lp),
         XDR * xdrs _AND
 	long *lp)
 {
-  if (xdrs->x_handy < sizeof (int32_t))
+  if (xdrs->x_handy < sizeof (int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof (int32_t);
   *lp = (int32_t) ntohl (*(u_int32_t *) xdrs->x_private);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -139,11 +145,14 @@ _DEFUN (xdrmem_putlong_aligned, (xdrs, lp),
         XDR * xdrs _AND
 	_CONST long *lp)
 {
-  if (xdrs->x_handy < sizeof (int32_t))
+  if (xdrs->x_handy < sizeof (int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof (int32_t);
   *(u_int32_t *) xdrs->x_private = htonl ((u_int32_t) * lp);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -154,12 +163,15 @@ _DEFUN (xdrmem_getlong_unaligned, (xdrs, lp),
 {
   u_int32_t l;
 
-  if (xdrs->x_handy < sizeof (int32_t))
+  if (xdrs->x_handy < sizeof (int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof (int32_t);
   memmove (&l, xdrs->x_private, sizeof (int32_t));
   *lp = ntohl (l);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -170,12 +182,15 @@ _DEFUN (xdrmem_putlong_unaligned, (xdrs, lp),
 {
   u_int32_t l;
 
-  if (xdrs->x_handy < sizeof (int32_t))
+  if (xdrs->x_handy < sizeof (int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof (int32_t);
   l = htonl ((u_int32_t) * lp);
   memmove (xdrs->x_private, &l, sizeof (int32_t));
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -185,11 +200,14 @@ _DEFUN (xdrmem_getbytes, (xdrs, addr, len),
 	char *addr _AND
 	u_int len)
 {
-  if (xdrs->x_handy < len)
+  if (xdrs->x_handy < len) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= len;
   memmove (addr, xdrs->x_private, len);
   xdrs->x_private = (char *) xdrs->x_private + len;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -199,11 +217,14 @@ _DEFUN (xdrmem_putbytes, (xdrs, addr, len),
 	_CONST char *addr _AND
 	u_int len)
 {
-  if (xdrs->x_handy < len)
+  if (xdrs->x_handy < len) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= len;
   memmove (xdrs->x_private, addr, len);
   xdrs->x_private = (char *) xdrs->x_private + len;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -212,6 +233,7 @@ _DEFUN (xdrmem_getpos, (xdrs),
         XDR * xdrs)
 {
   /* XXX w/64-bit pointers, u_int not enough! */
+  __A_VARIABLE = 1;
   return (u_int) ((u_long) xdrs->x_private - (u_long) xdrs->x_base);
 }
 
@@ -226,12 +248,15 @@ _DEFUN (xdrmem_setpos, (xdrs, pos),
 
   if (newaddr > lastaddr
       || newaddr < xdrs->x_base
-      || handy != (u_int) handy)
+      || handy != (u_int) handy) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   xdrs->x_private = newaddr;
   xdrs->x_handy = (u_int) handy;
   /* XXX sizeof(u_int) <? sizeof(ptrdiff_t) */
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -248,6 +273,7 @@ _DEFUN (xdrmem_inline_aligned, (xdrs, len),
       buf = (int32_t *) xdrs->x_private;
       xdrs->x_private = (char *) xdrs->x_private + len;
     }
+  __A_VARIABLE = 1;
   return (buf);
 }
 
@@ -256,6 +282,7 @@ _DEFUN (xdrmem_inline_unaligned, (xdrs, len),
         XDR * xdrs _AND
 	u_int len)
 {
+  __A_VARIABLE = 1;
   return (0);
 }
 
@@ -264,11 +291,14 @@ _DEFUN (xdrmem_getint32_aligned, (xdrs, ip),
 	XDR *xdrs _AND
 	int32_t *ip)
 {
-  if (xdrs->x_handy < sizeof(int32_t))
+  if (xdrs->x_handy < sizeof(int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof(int32_t);
   *ip = (int32_t) ntohl (*(u_int32_t *) xdrs->x_private);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -277,11 +307,14 @@ _DEFUN (xdrmem_putint32_aligned, (xdrs, ip),
         XDR *xdrs _AND
 	_CONST int32_t *ip)
 {
-  if (xdrs->x_handy < sizeof(int32_t))
+  if (xdrs->x_handy < sizeof(int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof(int32_t);
   *(u_int32_t *) xdrs->x_private = htonl ((u_int32_t) * ip);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -292,12 +325,15 @@ _DEFUN (xdrmem_getint32_unaligned, (xdrs, ip),
 {
   u_int32_t l;
 
-  if (xdrs->x_handy < sizeof(int32_t))
+  if (xdrs->x_handy < sizeof(int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof(int32_t);
   memmove (&l, xdrs->x_private, sizeof (int32_t));
   *ip = (int32_t) ntohl (l);
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -308,12 +344,15 @@ _DEFUN (xdrmem_putint32_unaligned, (xdrs, ip),
 {
   u_int32_t l;
 
-  if (xdrs->x_handy < sizeof(int32_t))
+  if (xdrs->x_handy < sizeof(int32_t)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   xdrs->x_handy -= sizeof(int32_t);
   l = htonl ((u_int32_t) * ip);
   memmove (xdrs->x_private, &l, sizeof (int32_t));
   xdrs->x_private = (char *) xdrs->x_private + sizeof (int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
diff --git a/newlib/libc/xdr/xdr_private.c b/newlib/libc/xdr/xdr_private.c
index 16b37a2..919cc3d 100644
--- a/newlib/libc/xdr/xdr_private.c
+++ b/newlib/libc/xdr/xdr_private.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* xdr_private.c - utility functions for porting xdr
  *
  * Copyright (c) 2009 Charles S. Wilson
@@ -31,6 +32,7 @@ _DEFUN (xdr_set_vprintf, (fnptr),
 {
   xdr_vprintf_t tmp = xdr_vprintf;
   xdr_vprintf = fnptr;
+  __A_VARIABLE = 1;
   return tmp;
 }
 
@@ -42,9 +44,11 @@ _DEFUN (xdr_vwarnx, (format, ap),
   if (xdr_vprintf)
     {
       (*xdr_vprintf)(format, ap);
+      __A_VARIABLE = 1;
       return;
     }
   /* otherwise, do nothing */
+    __A_VARIABLE = 1;
 }
 
 void
@@ -55,4 +59,5 @@ _DEFUN (xdr_warnx, (fmt),
   va_start (ap, fmt);
   xdr_vwarnx (fmt, ap);
   va_end (ap);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libc/xdr/xdr_rec.c b/newlib/libc/xdr/xdr_rec.c
index eef4c48..e9b2c6a 100644
--- a/newlib/libc/xdr/xdr_rec.c
+++ b/newlib/libc/xdr/xdr_rec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
@@ -195,6 +196,7 @@ _DEFUN (xdrrec_create, (xdrs, sendsize, recvsize, tcp_handle, readit, writeit),
        *  return a handle, and in this case return NULL
        */
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return;
     }
 
@@ -207,6 +209,7 @@ _DEFUN (xdrrec_create, (xdrs, sendsize, recvsize, tcp_handle, readit, writeit),
       xdr_warnx ("xdrrec_create: out of memory");
       mem_free (rstrm, sizeof (RECSTREAM));
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return;
     }
   for (rstrm->out_base = rstrm->out_buffer;
@@ -222,6 +225,7 @@ _DEFUN (xdrrec_create, (xdrs, sendsize, recvsize, tcp_handle, readit, writeit),
       mem_free (rstrm->out_buffer, sendsize + BYTES_PER_XDR_UNIT);
       mem_free (rstrm, sizeof (RECSTREAM));
       errno = ENOMEM;
+      __A_VARIABLE = 1;
       return;
     }
   for (rstrm->in_base = rstrm->in_buffer;
@@ -252,6 +256,7 @@ _DEFUN (xdrrec_create, (xdrs, sendsize, recvsize, tcp_handle, readit, writeit),
   rstrm->nonblock = FALSE;
   rstrm->in_reclen = 0;
   rstrm->in_received = 0;
+  __A_VARIABLE = 1;
 }
 
 
@@ -303,12 +308,15 @@ _DEFUN (xdrrec_putlong, (xdrs, lp),
        */
       rstrm->out_finger -= sizeof (int32_t);
       rstrm->frag_sent = TRUE;
-      if (!flush_out (rstrm, FALSE))
+      if (!flush_out (rstrm, FALSE)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       dest_lp = ((int32_t *) (void *) (rstrm->out_finger));
       rstrm->out_finger += sizeof (int32_t);
     }
   *dest_lp = (int32_t) htonl ((u_int32_t) (*lp));
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -326,19 +334,26 @@ _DEFUN (xdrrec_getbytes, (xdrs, addr, len),
       current = (int) rstrm->fbtbc;
       if (current == 0)
         {
-          if (rstrm->last_frag)
+          if (rstrm->last_frag) {
+            __A_VARIABLE = 1;
             return FALSE;
-          if (!set_input_fragment (rstrm))
+          }
+          if (!set_input_fragment (rstrm)) {
+            __A_VARIABLE = 1;
             return FALSE;
+          }
           continue;
         }
       current = (len < current) ? len : current;
-      if (!get_input_bytes (rstrm, addr, current))
+      if (!get_input_bytes (rstrm, addr, current)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       addr += current;
       rstrm->fbtbc -= current;
       len -= current;
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -363,10 +378,13 @@ _DEFUN (xdrrec_putbytes, (xdrs, addr, len),
       if (rstrm->out_finger == rstrm->out_boundry)
         {
           rstrm->frag_sent = TRUE;
-          if (!flush_out (rstrm, FALSE))
+          if (!flush_out (rstrm, FALSE)) {
+            __A_VARIABLE = 1;
             return FALSE;
+          }
         }
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -394,6 +412,7 @@ _DEFUN (xdrrec_getpos, (xdrs),
         pos = (off_t) - 1;
         break;
       }
+  __A_VARIABLE = 1;
   return ((u_int) pos);
 }
 
@@ -417,6 +436,7 @@ _DEFUN (xdrrec_setpos, (xdrs, pos),
             (newpos < rstrm->out_boundry))
           {
             rstrm->out_finger = newpos;
+            __A_VARIABLE = 1;
             return TRUE;
           }
         break;
@@ -428,6 +448,7 @@ _DEFUN (xdrrec_setpos, (xdrs, pos),
           {
             rstrm->in_finger = newpos;
             rstrm->fbtbc -= delta;
+            __A_VARIABLE = 1;
             return TRUE;
           }
         break;
@@ -435,6 +456,7 @@ _DEFUN (xdrrec_setpos, (xdrs, pos),
       case XDR_FREE:
         break;
       }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -478,6 +500,7 @@ _DEFUN (xdrrec_inline, (xdrs, len),
     case XDR_FREE:
       break;
     }
+  __A_VARIABLE = 1;
   return (buf);
 }
 
@@ -490,6 +513,7 @@ _DEFUN (xdrrec_destroy, (xdrs),
   mem_free (rstrm->out_buffer, rstrm->sendsize + BYTES_PER_XDR_UNIT);
   mem_free (rstrm->in_buffer, rstrm->recvsize + BYTES_PER_XDR_UNIT);
   mem_free (rstrm, sizeof (RECSTREAM));
+  __A_VARIABLE = 1;
 }
 
 static bool_t
@@ -535,12 +559,15 @@ _DEFUN (xdrrec_putint32, (xdrs, ip),
        */
       rstrm->out_finger -= sizeof (int32_t);
       rstrm->frag_sent = TRUE;
-      if (!flush_out (rstrm, FALSE))
+      if (!flush_out (rstrm, FALSE)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       dest_ip = ((int32_t *) (void *) (rstrm->out_finger));
       rstrm->out_finger += sizeof (int32_t);
     }
   *dest_ip = (int32_t) htonl (*ip);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -564,25 +591,33 @@ _DEFUN (xdrrec_skiprecord, (xdrs),
       if (__xdrrec_getrec (xdrs, &xstat, FALSE))
         {
           rstrm->fbtbc = 0;
+          __A_VARIABLE = 1;
           return TRUE;
         }
       if (rstrm->in_finger == rstrm->in_boundry && xstat == XPRT_MOREREQS)
         {
           rstrm->fbtbc = 0;
+          __A_VARIABLE = 1;
           return TRUE;
         }
+      __A_VARIABLE = 1;
       return FALSE;
     }
 
   while (rstrm->fbtbc > 0 || (!rstrm->last_frag))
     {
-      if (!skip_input_bytes (rstrm, rstrm->fbtbc))
+      if (!skip_input_bytes (rstrm, rstrm->fbtbc)) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       rstrm->fbtbc = 0;
-      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm)))
+      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm))) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
     }
   rstrm->last_frag = FALSE;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -599,14 +634,21 @@ _DEFUN (xdrrec_eof, (xdrs),
 
   while (rstrm->fbtbc > 0 || (!rstrm->last_frag))
     {
-      if (!skip_input_bytes (rstrm, rstrm->fbtbc))
+      if (!skip_input_bytes (rstrm, rstrm->fbtbc)) {
+        __A_VARIABLE = 1;
         return TRUE;
+      }
       rstrm->fbtbc = 0;
-      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm)))
+      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm))) {
+        __A_VARIABLE = 1;
         return TRUE;
     }
-  if (rstrm->in_finger == rstrm->in_boundry)
+    }
+  if (rstrm->in_finger == rstrm->in_boundry) {
+    __A_VARIABLE = 1;
     return TRUE;
+  }
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -629,6 +671,7 @@ _DEFUN (xdrrec_endofrecord, (xdrs, sendnow),
        (u_long) rstrm->out_boundry))
     {
       rstrm->frag_sent = FALSE;
+      __A_VARIABLE = 1;
       return (flush_out (rstrm, TRUE));
     }
   len = (u_long) (rstrm->out_finger) - (u_long) (rstrm->frag_header) -
@@ -636,6 +679,7 @@ _DEFUN (xdrrec_endofrecord, (xdrs, sendnow),
   *(rstrm->frag_header) = htonl ((u_int32_t) len | LAST_FRAG);
   rstrm->frag_header = (u_int32_t *) (void *) rstrm->out_finger;
   rstrm->out_finger += sizeof (u_int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -660,11 +704,13 @@ _DEFUN (__xdrrec_getrec, (xdrs, statp, expectdata),
       if (n == 0)
         {
           *statp = expectdata ? XPRT_DIED : XPRT_IDLE;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       if (n < 0)
         {
           *statp = XPRT_DIED;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       rstrm->in_hdrp += n;
@@ -672,6 +718,7 @@ _DEFUN (__xdrrec_getrec, (xdrs, statp, expectdata),
       if (rstrm->in_hdrlen < sizeof (rstrm->in_header))
         {
           *statp = XPRT_MOREREQS;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       rstrm->in_header = ntohl (rstrm->in_header);
@@ -680,6 +727,7 @@ _DEFUN (__xdrrec_getrec, (xdrs, statp, expectdata),
           (rstrm->in_reclen + fraglen) > rstrm->in_maxrec)
         {
           *statp = XPRT_DIED;
+          __A_VARIABLE = 1;
           return FALSE;
         }
       rstrm->in_reclen += fraglen;
@@ -705,12 +753,14 @@ _DEFUN (__xdrrec_getrec, (xdrs, statp, expectdata),
   if (n < 0)
     {
       *statp = XPRT_DIED;
+      __A_VARIABLE = 1;
       return FALSE;
     }
 
   if (n == 0)
     {
       *statp = expectdata ? XPRT_DIED : XPRT_IDLE;
+      __A_VARIABLE = 1;
       return FALSE;
     }
 
@@ -728,11 +778,13 @@ _DEFUN (__xdrrec_getrec, (xdrs, statp, expectdata),
           rstrm->in_finger = rstrm->in_base;
           rstrm->in_reclen = rstrm->in_received = 0;
           *statp = XPRT_MOREREQS;
+          __A_VARIABLE = 1;
           return TRUE;
         }
     }
 
   *statp = XPRT_MOREREQS;
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -747,6 +799,7 @@ _DEFUN (__xdrrec_setnonblock, (xdrs, maxrec),
   if (maxrec == 0)
     maxrec = rstrm->recvsize;
   rstrm->in_maxrec = maxrec;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -767,10 +820,13 @@ _DEFUN (flush_out, (rstrm, eor),
   len = (u_int32_t) ((u_long) (rstrm->out_finger) -
                      (u_long) (rstrm->out_base));
   if ((*(rstrm->writeit)) (rstrm->tcp_handle, rstrm->out_base, (int) len)
-      != (int) len)
+      != (int) len) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   rstrm->frag_header = (u_int32_t *) (void *) rstrm->out_base;
   rstrm->out_finger = (char *) rstrm->out_base + sizeof (u_int32_t);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -782,18 +838,23 @@ _DEFUN (fill_input_buf, (rstrm),
   u_int32_t i;
   int len;
 
-  if (rstrm->nonblock)
+  if (rstrm->nonblock) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
 
   where = rstrm->in_base;
   i = (u_int32_t) ((u_long) rstrm->in_boundry % BYTES_PER_XDR_UNIT);
   where += i;
   len = (u_int32_t) (rstrm->in_size - i);
-  if ((len = (*(rstrm->readit)) (rstrm->tcp_handle, where, len)) == -1)
+  if ((len = (*(rstrm->readit)) (rstrm->tcp_handle, where, len)) == -1) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   rstrm->in_finger = where;
   where += len;
   rstrm->in_boundry = where;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -808,10 +869,13 @@ _DEFUN (get_input_bytes, (rstrm, addr, len),
   if (rstrm->nonblock)
     {
       if ((rstrm->in_boundry < rstrm->in_finger) ||               /* <-- should never happen, but avoids... */
-         (len > (size_t) (rstrm->in_boundry - rstrm->in_finger))) /* <-- signed/unsigned comparison */
+         (len > (size_t) (rstrm->in_boundry - rstrm->in_finger))) /* <-- signed/unsigned comparison */ {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       memcpy (addr, rstrm->in_finger, (size_t) len);
       rstrm->in_finger += len;
+      __A_VARIABLE = 1;
       return TRUE;
     }
 
@@ -820,8 +884,10 @@ _DEFUN (get_input_bytes, (rstrm, addr, len),
       current = (size_t) ((long) rstrm->in_boundry - (long) rstrm->in_finger);
       if (current == 0)
         {
-          if (!fill_input_buf (rstrm))
+          if (!fill_input_buf (rstrm)) {
+            __A_VARIABLE = 1;
             return FALSE;
+          }
           continue;
         }
       current = (len < current) ? len : current;
@@ -830,6 +896,7 @@ _DEFUN (get_input_bytes, (rstrm, addr, len),
       addr += current;
       len -= current;
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -839,10 +906,14 @@ _DEFUN (set_input_fragment, (rstrm),
 {
   u_int32_t header;
 
-  if (rstrm->nonblock)
+  if (rstrm->nonblock) {
+    __A_VARIABLE = 1;
     return FALSE;
-  if (!get_input_bytes (rstrm, (char *) (void *) &header, sizeof (header)))
+  }
+  if (!get_input_bytes (rstrm, (char *) (void *) &header, sizeof (header))) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   header = ntohl (header);
   rstrm->last_frag = ((header & LAST_FRAG) == 0) ? FALSE : TRUE;
   /*
@@ -853,9 +924,12 @@ _DEFUN (set_input_fragment, (rstrm),
    * but we don't have any way to be certain that they aren't
    * what the client actually intended to send us.
    */
-  if (header == 0)
+  if (header == 0) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   rstrm->fbtbc = header & (~LAST_FRAG);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -871,8 +945,10 @@ _DEFUN (skip_input_bytes, (rstrm, cnt),
       current = (size_t) ((long) rstrm->in_boundry - (long) rstrm->in_finger);
       if (current == 0)
         {
-          if (!fill_input_buf (rstrm))
+          if (!fill_input_buf (rstrm)) {
+            __A_VARIABLE = 1;
             return FALSE;
+          }
           continue;
         }
       /* in this loop (prior to last line), cnt > 0 so size_t cast is safe*/
@@ -880,6 +956,7 @@ _DEFUN (skip_input_bytes, (rstrm, cnt),
       rstrm->in_finger += current;
       cnt -= current;
     }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -890,6 +967,7 @@ _DEFUN (fix_buf_size, (s),
 
   if (s < 100)
     s = 4000;
+  __A_VARIABLE = 1;
   return (RNDUP (s));
 }
 
@@ -908,8 +986,10 @@ _DEFUN (realloc_stream, (rstrm, size),
   if (size > (int)rstrm->recvsize) /* recvsize guaranteed < INT_MAX */
     {
       buf = realloc (rstrm->in_buffer, (size_t) (size + BYTES_PER_XDR_UNIT));
-      if (buf == NULL)
+      if (buf == NULL) {
+        __A_VARIABLE = 1;
         return FALSE;
+      }
       for (buf_algn = buf;
            (long) buf_algn % BYTES_PER_XDR_UNIT != 0; buf_algn++)
         ;
@@ -922,6 +1002,7 @@ _DEFUN (realloc_stream, (rstrm, size),
       rstrm->in_size = size;
     }
 
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
diff --git a/newlib/libc/xdr/xdr_reference.c b/newlib/libc/xdr/xdr_reference.c
index 010a7e7..a18e123 100644
--- a/newlib/libc/xdr/xdr_reference.c
+++ b/newlib/libc/xdr/xdr_reference.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
  * All rights reserved.
@@ -69,6 +70,7 @@ _DEFUN (xdr_reference, (xdrs, pp, size, proc),
     switch (xdrs->x_op)
       {
       case XDR_FREE:
+        __A_VARIABLE = 1;
         return TRUE;
 
       case XDR_DECODE:
@@ -77,6 +79,7 @@ _DEFUN (xdr_reference, (xdrs, pp, size, proc),
           {
             xdr_warnx ("xdr_reference: out of memory");
             errno = ENOMEM;
+            __A_VARIABLE = 1;
             return FALSE;
           }
         memset (loc, 0, size);
@@ -93,6 +96,7 @@ _DEFUN (xdr_reference, (xdrs, pp, size, proc),
       mem_free (loc, size);
       *pp = NULL;
     }
+  __A_VARIABLE = 1;
   return stat;
 }
 
@@ -128,12 +132,15 @@ _DEFUN (xdr_pointer, (xdrs, objpp, obj_size, xdr_obj),
   more_data = (*objpp != NULL);
   if (!xdr_bool (xdrs, &more_data))
     {
+      __A_VARIABLE = 1;
       return FALSE;
     }
   if (!more_data)
     {
       *objpp = NULL;
+      __A_VARIABLE = 1;
       return TRUE;
     }
+  __A_VARIABLE = 1;
   return (xdr_reference (xdrs, objpp, obj_size, xdr_obj));
 }
diff --git a/newlib/libc/xdr/xdr_sizeof.c b/newlib/libc/xdr/xdr_sizeof.c
index 156a2e1..fecd299 100644
--- a/newlib/libc/xdr/xdr_sizeof.c
+++ b/newlib/libc/xdr/xdr_sizeof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
  * All rights reserved.
@@ -48,6 +49,7 @@ _DEFUN (x_putlong, (xdrs, longp),
 	_CONST long *longp)
 {
   xdrs->x_handy += BYTES_PER_XDR_UNIT;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -59,6 +61,7 @@ _DEFUN (x_putbytes, (xdrs, bp, len),
 	u_int len)
 {
   xdrs->x_handy += len;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -66,6 +69,7 @@ static u_int
 _DEFUN (x_getpostn, (xdrs),
         XDR * xdrs)
 {
+  __A_VARIABLE = 1;
   return xdrs->x_handy;
 }
 
@@ -76,6 +80,7 @@ _DEFUN (x_setpostn, (xdrs, pos),
 	u_int pos)
 {
   /* This is not allowed */
+  __A_VARIABLE = 1;
   return FALSE;
 }
 
@@ -114,6 +119,7 @@ static int
 _DEFUN_VOID (harmless)
 {
   /* Always return FALSE/NULL, as the case may be */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -128,6 +134,7 @@ _DEFUN (x_destroy, (xdrs),
       mem_free (xdrs->x_private, sizeof (xdrs->x_private));
       xdrs->x_private = NULL;
     }
+  __A_VARIABLE = 1;
   return;
 }
 
@@ -137,6 +144,7 @@ _DEFUN (x_putint32, (xdrs, int32p),
 	_CONST int32_t *int32p)
 {
   xdrs->x_handy += BYTES_PER_XDR_UNIT;
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -176,6 +184,7 @@ _DEFUN (xdr_sizeof, (func, data),
   stat = func (&x, data);
   if (x.x_private)
     mem_free (x.x_private, sizeof (x.x_private));
+  __A_VARIABLE = 1;
   return (stat == TRUE ? x.x_handy : 0);
 }
 
diff --git a/newlib/libc/xdr/xdr_stdio.c b/newlib/libc/xdr/xdr_stdio.c
index c933c68..52d7775 100644
--- a/newlib/libc/xdr/xdr_stdio.c
+++ b/newlib/libc/xdr/xdr_stdio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009, Sun Microsystems, Inc.
  * All rights reserved.
@@ -93,6 +94,7 @@ _DEFUN (xdrstdio_create, (xdrs, file, op),
   xdrs->x_private = (void *) file;
   xdrs->x_handy = 0;
   xdrs->x_base = 0;
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -105,6 +107,7 @@ _DEFUN (xdrstdio_destroy, (xdrs),
 {
   (void) fflush ((FILE *) xdrs->x_private);
   /* XXX: should we close the file ?? */
+  __A_VARIABLE = 1;
 }
 
 static bool_t
@@ -114,9 +117,12 @@ _DEFUN (xdrstdio_getlong, (xdrs, lp),
 {
   u_int32_t temp;
 
-  if (fread (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1)
+  if (fread (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   *lp = (long) (int32_t) ntohl (temp);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -127,8 +133,11 @@ _DEFUN (xdrstdio_putlong, (xdrs, lp),
 {
   u_int32_t temp = htonl ((u_int32_t) * lp);
 
-  if (fwrite (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1)
+  if (fwrite (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -139,8 +148,11 @@ _DEFUN (xdrstdio_getbytes, (xdrs, addr, len),
 	u_int len)
 {
   if ((len != 0) && (fread (addr, (size_t) len, 1,
-                            (FILE *) xdrs->x_private) != 1))
+                            (FILE *) xdrs->x_private) != 1)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -151,8 +163,11 @@ _DEFUN (xdrstdio_putbytes, (xdrs, addr, len),
 	u_int len)
 {
   if ((len != 0) && (fwrite (addr, (size_t) len, 1,
-                             (FILE *) xdrs->x_private) != 1))
+                             (FILE *) xdrs->x_private) != 1)) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -160,6 +175,7 @@ static u_int
 _DEFUN (xdrstdio_getpos, (xdrs),
         XDR * xdrs)
 {
+  __A_VARIABLE = 1;
   return ((u_int) ftell ((FILE *) xdrs->x_private));
 }
 
@@ -168,6 +184,7 @@ _DEFUN (xdrstdio_setpos, (xdrs, pos),
         XDR * xdrs _AND
         u_int pos)
 {
+  __A_VARIABLE = 1;
   return ((fseek ((FILE *) xdrs->x_private, (long) pos, 0) < 0) ?
           FALSE : TRUE);
 }
@@ -187,6 +204,7 @@ _DEFUN (xdrstdio_inline, (xdrs, len),
    * most of the gains to be had here and require storage
    * management on this buffer, so we don't do this.
    */
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -197,9 +215,12 @@ _DEFUN (xdrstdio_getint32, (xdrs, ip),
 {
   int32_t temp;
 
-  if (fread (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1)
+  if (fread (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
   *ip = ntohl (temp);
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
@@ -210,8 +231,11 @@ _DEFUN (xdrstdio_putint32, (xdrs, ip),
 {
   int32_t temp = htonl (*ip);
 
-  if (fwrite (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1)
+  if (fwrite (&temp, sizeof (int32_t), 1, (FILE *) xdrs->x_private) != 1) {
+    __A_VARIABLE = 1;
     return FALSE;
+  }
+  __A_VARIABLE = 1;
   return TRUE;
 }
 
diff --git a/newlib/libm/common/acoshl.c b/newlib/libm/common/acoshl.c
index 8e587ec..1ebbb4c 100644
--- a/newlib/libm/common/acoshl.c
+++ b/newlib/libm/common/acoshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 acoshl (long double x)
 {
+  __A_VARIABLE = 1;
   return acosh(x);
 }
 #endif
diff --git a/newlib/libm/common/acosl.c b/newlib/libm/common/acosl.c
index 498041c..c718180 100644
--- a/newlib/libm/common/acosl.c
+++ b/newlib/libm/common/acosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 acosl (long double x)
 {
+  __A_VARIABLE = 1;
   return acos(x);
 }
 #endif
diff --git a/newlib/libm/common/asinhl.c b/newlib/libm/common/asinhl.c
index 2437018..d82ecc3 100644
--- a/newlib/libm/common/asinhl.c
+++ b/newlib/libm/common/asinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 asinhl (long double x)
 {
+  __A_VARIABLE = 1;
   return asinh(x);
 }
 #endif
diff --git a/newlib/libm/common/asinl.c b/newlib/libm/common/asinl.c
index 4aa24cd..d5cdd4f 100644
--- a/newlib/libm/common/asinl.c
+++ b/newlib/libm/common/asinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 asinl (long double x)
 {
+  __A_VARIABLE = 1;
   return asin(x);
 }
 #endif
diff --git a/newlib/libm/common/atan2l.c b/newlib/libm/common/atan2l.c
index a3aaf6d..bb315b4 100644
--- a/newlib/libm/common/atan2l.c
+++ b/newlib/libm/common/atan2l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 atan2l (long double v, long double u)
 {
+  __A_VARIABLE = 1;
   return atan2(v, u);
 }
 #endif
diff --git a/newlib/libm/common/atanhl.c b/newlib/libm/common/atanhl.c
index 03c26d4..6583911 100644
--- a/newlib/libm/common/atanhl.c
+++ b/newlib/libm/common/atanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 atanhl (long double x)
 {
+  __A_VARIABLE = 1;
   return atanh(x);
 }
 #endif
diff --git a/newlib/libm/common/atanl.c b/newlib/libm/common/atanl.c
index d459160..bc195c2 100644
--- a/newlib/libm/common/atanl.c
+++ b/newlib/libm/common/atanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 atanl (long double x)
 {
+  __A_VARIABLE = 1;
   return atan(x);
 }
 #endif
diff --git a/newlib/libm/common/cbrtl.c b/newlib/libm/common/cbrtl.c
index 272b097..b09dca1 100644
--- a/newlib/libm/common/cbrtl.c
+++ b/newlib/libm/common/cbrtl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 cbrtl (long double x)
 {
+  __A_VARIABLE = 1;
   return cbrt(x);
 }
 #endif
diff --git a/newlib/libm/common/ceill.c b/newlib/libm/common/ceill.c
index 0614d50..e7e9213 100644
--- a/newlib/libm/common/ceill.c
+++ b/newlib/libm/common/ceill.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 ceill (long double x)
 {
+  __A_VARIABLE = 1;
   return ceil(x);
 }
 #endif
diff --git a/newlib/libm/common/copysignl.c b/newlib/libm/common/copysignl.c
index c5de287..61211f1 100644
--- a/newlib/libm/common/copysignl.c
+++ b/newlib/libm/common/copysignl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 copysignl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return copysign(x, y);
 }
 #endif
diff --git a/newlib/libm/common/coshl.c b/newlib/libm/common/coshl.c
index 296feb2..b2c0e55 100644
--- a/newlib/libm/common/coshl.c
+++ b/newlib/libm/common/coshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 coshl (long double x)
 {
+  __A_VARIABLE = 1;
   return cosh(x);
 }
 #endif
diff --git a/newlib/libm/common/cosl.c b/newlib/libm/common/cosl.c
index abe9c5d..852460d 100644
--- a/newlib/libm/common/cosl.c
+++ b/newlib/libm/common/cosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 cosl (long double x)
 {
+  __A_VARIABLE = 1;
   return cos(x);
 }
 #endif
diff --git a/newlib/libm/common/erfcl.c b/newlib/libm/common/erfcl.c
index eb9bc46..8ed275e 100644
--- a/newlib/libm/common/erfcl.c
+++ b/newlib/libm/common/erfcl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 erfcl (long double x)
 {
+  __A_VARIABLE = 1;
   return erfc(x);
 }
 #endif
diff --git a/newlib/libm/common/erfl.c b/newlib/libm/common/erfl.c
index 1b0be48..73c6c5a 100644
--- a/newlib/libm/common/erfl.c
+++ b/newlib/libm/common/erfl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 erfl (long double x)
 {
+  __A_VARIABLE = 1;
   return erf(x);
 }
 #endif
diff --git a/newlib/libm/common/exp2l.c b/newlib/libm/common/exp2l.c
index 29127bb..a2e086d 100644
--- a/newlib/libm/common/exp2l.c
+++ b/newlib/libm/common/exp2l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 exp2l (long double x)
 {
+  __A_VARIABLE = 1;
   return exp2(x);
 }
 #endif
diff --git a/newlib/libm/common/expl.c b/newlib/libm/common/expl.c
index 37083b0..b034214 100644
--- a/newlib/libm/common/expl.c
+++ b/newlib/libm/common/expl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 expl (long double x)
 {
+  __A_VARIABLE = 1;
   return exp(x);
 }
 #endif
diff --git a/newlib/libm/common/expm1l.c b/newlib/libm/common/expm1l.c
index 8018f9f..32fa105 100644
--- a/newlib/libm/common/expm1l.c
+++ b/newlib/libm/common/expm1l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 expm1l (long double x)
 {
+  __A_VARIABLE = 1;
   return expm1(x);
 }
 #endif
diff --git a/newlib/libm/common/fabsl.c b/newlib/libm/common/fabsl.c
index 83be0ae..c449d0b 100644
--- a/newlib/libm/common/fabsl.c
+++ b/newlib/libm/common/fabsl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fabsl (long double x)
 {
+  __A_VARIABLE = 1;
   return fabs(x);
 }
 #endif
diff --git a/newlib/libm/common/fdiml.c b/newlib/libm/common/fdiml.c
index fe58531..5c5a55f 100644
--- a/newlib/libm/common/fdiml.c
+++ b/newlib/libm/common/fdiml.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fdiml (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return fdim(x, y);
 }
 #endif
diff --git a/newlib/libm/common/floorl.c b/newlib/libm/common/floorl.c
index 045f280..d183bae 100644
--- a/newlib/libm/common/floorl.c
+++ b/newlib/libm/common/floorl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 floorl (long double x)
 {
+  __A_VARIABLE = 1;
   return floor(x);
 }
 #endif
diff --git a/newlib/libm/common/fmal.c b/newlib/libm/common/fmal.c
index c287d9b..5ddbd6b 100644
--- a/newlib/libm/common/fmal.c
+++ b/newlib/libm/common/fmal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fmal (long double x, long double y, long double z)
 {
+  __A_VARIABLE = 1;
   return fma(x, y, z);
 }
 #endif
diff --git a/newlib/libm/common/fmaxl.c b/newlib/libm/common/fmaxl.c
index f983ed9..d67eaf8 100644
--- a/newlib/libm/common/fmaxl.c
+++ b/newlib/libm/common/fmaxl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fmaxl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return fmax(x, y);
 }
 #endif
diff --git a/newlib/libm/common/fminl.c b/newlib/libm/common/fminl.c
index 246c426..e0e38ea 100644
--- a/newlib/libm/common/fminl.c
+++ b/newlib/libm/common/fminl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fminl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return fmin(x, y);
 }
 #endif
diff --git a/newlib/libm/common/fmodl.c b/newlib/libm/common/fmodl.c
index 3b48943..8407444 100644
--- a/newlib/libm/common/fmodl.c
+++ b/newlib/libm/common/fmodl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 fmodl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return fmod(x, y);
 }
 #endif
diff --git a/newlib/libm/common/frexpl.c b/newlib/libm/common/frexpl.c
index 79e41fd..0afa946 100644
--- a/newlib/libm/common/frexpl.c
+++ b/newlib/libm/common/frexpl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 frexpl (long double x, int *eptr)
 {
+  __A_VARIABLE = 1;
   return frexp(x, eptr);
 }
 #endif
diff --git a/newlib/libm/common/hypotl.c b/newlib/libm/common/hypotl.c
index cf67ccf..daa6e70 100644
--- a/newlib/libm/common/hypotl.c
+++ b/newlib/libm/common/hypotl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
diff --git a/newlib/libm/common/ilogbl.c b/newlib/libm/common/ilogbl.c
index 03db4de..348ae08 100644
--- a/newlib/libm/common/ilogbl.c
+++ b/newlib/libm/common/ilogbl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 int
 ilogbl (long double x)
 {
+  __A_VARIABLE = 1;
   return ilogb(x);
 }
 #endif
diff --git a/newlib/libm/common/isgreater.c b/newlib/libm/common/isgreater.c
index 54a8e6d..2b59ec8 100644
--- a/newlib/libm/common/isgreater.c
+++ b/newlib/libm/common/isgreater.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* isgreater.c:  This file contains no source code, but rather only the
  * man-page comments.  All of the documented "functions" are actually macros
  * defined in math.h (q.v.).  */
diff --git a/newlib/libm/common/ldexpl.c b/newlib/libm/common/ldexpl.c
index 5f6627a..5e6cd63 100644
--- a/newlib/libm/common/ldexpl.c
+++ b/newlib/libm/common/ldexpl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 ldexpl (long double value, int exp)
 {
+  __A_VARIABLE = 1;
   return ldexp(value, exp);
 }
 #endif
diff --git a/newlib/libm/common/lgammal.c b/newlib/libm/common/lgammal.c
index 1b42eaf..4f4cf24 100644
--- a/newlib/libm/common/lgammal.c
+++ b/newlib/libm/common/lgammal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 lgammal (long double x)
 {
+  __A_VARIABLE = 1;
   return lgamma(x);
 }
 #endif
diff --git a/newlib/libm/common/llrintl.c b/newlib/libm/common/llrintl.c
index e5faaa0..9083f04 100644
--- a/newlib/libm/common/llrintl.c
+++ b/newlib/libm/common/llrintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long long int
 llrintl (long double x)
 {
+  __A_VARIABLE = 1;
   return llrint(x);
 }
 #endif
diff --git a/newlib/libm/common/llroundl.c b/newlib/libm/common/llroundl.c
index d663226..9c03a83 100644
--- a/newlib/libm/common/llroundl.c
+++ b/newlib/libm/common/llroundl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long long int
 llroundl (long double x)
 {
+  __A_VARIABLE = 1;
   return llround(x);
 }
 #endif
diff --git a/newlib/libm/common/log10l.c b/newlib/libm/common/log10l.c
index e63152b..9f675d9 100644
--- a/newlib/libm/common/log10l.c
+++ b/newlib/libm/common/log10l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 log10l (long double x)
 {
+  __A_VARIABLE = 1;
   return log10(x);
 }
 #endif
diff --git a/newlib/libm/common/log1pl.c b/newlib/libm/common/log1pl.c
index f524624..4781c9a 100644
--- a/newlib/libm/common/log1pl.c
+++ b/newlib/libm/common/log1pl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 log1pl (long double x)
 {
+  __A_VARIABLE = 1;
   return log1p(x);
 }
 #endif
diff --git a/newlib/libm/common/log2l.c b/newlib/libm/common/log2l.c
index e92e9eb..212e37c 100644
--- a/newlib/libm/common/log2l.c
+++ b/newlib/libm/common/log2l.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 Copyright (c) 2014 Mentor Graphics, Inc.
 All rights reserved.
@@ -32,6 +33,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 long double
 log2l (long double x)
 {
+  __A_VARIABLE = 1;
   return log2(x);
 }
 #endif
diff --git a/newlib/libm/common/logbl.c b/newlib/libm/common/logbl.c
index 59d24a2..708c33d 100644
--- a/newlib/libm/common/logbl.c
+++ b/newlib/libm/common/logbl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 Copyright (c) 2014 Mentor Graphics, Inc.
 All rights reserved.
@@ -32,6 +33,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 long double
 logbl (long double x)
 {
+  __A_VARIABLE = 1;
   return logb(x);
 }
 #endif
diff --git a/newlib/libm/common/logl.c b/newlib/libm/common/logl.c
index aaba076..1e1002b 100644
--- a/newlib/libm/common/logl.c
+++ b/newlib/libm/common/logl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 logl (long double x)
 {
+  __A_VARIABLE = 1;
   return log(x);
 }
 #endif
diff --git a/newlib/libm/common/lrintl.c b/newlib/libm/common/lrintl.c
index 67c4638..a2a491a 100644
--- a/newlib/libm/common/lrintl.c
+++ b/newlib/libm/common/lrintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long int
 lrintl (long double x)
 {
+  __A_VARIABLE = 1;
   return lrint(x);
 }
 #endif
diff --git a/newlib/libm/common/lroundl.c b/newlib/libm/common/lroundl.c
index 8687522..a6e0089 100644
--- a/newlib/libm/common/lroundl.c
+++ b/newlib/libm/common/lroundl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long
 lroundl (long double x)
 {
+  __A_VARIABLE = 1;
   return lround(x);
 }
 #endif
diff --git a/newlib/libm/common/modfl.c b/newlib/libm/common/modfl.c
index 3b31c6a..5e8bb60 100644
--- a/newlib/libm/common/modfl.c
+++ b/newlib/libm/common/modfl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 modfl (long double x, long double *iptr)
 {
+  __A_VARIABLE = 1;
   return modf(x, (double *)iptr);
 }
 #endif
diff --git a/newlib/libm/common/nanl.c b/newlib/libm/common/nanl.c
index 40f8981..b899d99 100644
--- a/newlib/libm/common/nanl.c
+++ b/newlib/libm/common/nanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 nanl (const char *tagp)
 {
+  __A_VARIABLE = 1;
   return nan(tagp);
 }
 #endif
diff --git a/newlib/libm/common/nearbyintl.c b/newlib/libm/common/nearbyintl.c
index 84c0f78..92f01f3 100644
--- a/newlib/libm/common/nearbyintl.c
+++ b/newlib/libm/common/nearbyintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 nearbyintl (long double x)
 {
+  __A_VARIABLE = 1;
   return nearbyint(x);
 }
 #endif
diff --git a/newlib/libm/common/nextafterl.c b/newlib/libm/common/nextafterl.c
index 7e4e2b9..a69968f 100644
--- a/newlib/libm/common/nextafterl.c
+++ b/newlib/libm/common/nextafterl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 nextafterl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return nextafter(x, y);
 }
 #endif
diff --git a/newlib/libm/common/nexttoward.c b/newlib/libm/common/nexttoward.c
index 71dd71d..5e7bf85 100644
--- a/newlib/libm/common/nexttoward.c
+++ b/newlib/libm/common/nexttoward.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 Copyright (c) 2014 Mentor Graphics, Inc.
 All rights reserved.
@@ -32,6 +33,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 double
 nexttoward (double x, long double y)
 {
+  __A_VARIABLE = 1;
   return nextafter(x, y);
 }
 #endif
diff --git a/newlib/libm/common/nexttowardf.c b/newlib/libm/common/nexttowardf.c
index 6f47319..ec241be 100644
--- a/newlib/libm/common/nexttowardf.c
+++ b/newlib/libm/common/nexttowardf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright  2005-2014 Rich Felker, et al.
  *
@@ -41,10 +42,14 @@ nexttowardf (float x, long double y)
   union fshape ux;
   uint32_t e;
 
-  if (isnan(x) || isnan(y))
+  if (isnan(x) || isnan(y)) {
+    __A_VARIABLE = 1;
     return x + y;
-  if (x == y)
+  }
+  if (x == y) {
+    __A_VARIABLE = 1;
     return y;
+  }
   ux.value = x;
   if (x == 0) {
     ux.bits = 1;
@@ -72,6 +77,7 @@ nexttowardf (float x, long double y)
     volatile float force_eval;
     force_eval = x*x + ux.value*ux.value;
   }
+  __A_VARIABLE = 1;
   return ux.value;
 }
 
diff --git a/newlib/libm/common/nexttowardl.c b/newlib/libm/common/nexttowardl.c
index 59af4ce..bbbaff2 100644
--- a/newlib/libm/common/nexttowardl.c
+++ b/newlib/libm/common/nexttowardl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 Copyright (c) 2014 Mentor Graphics, Inc.
 All rights reserved.
@@ -32,6 +33,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 long double
 nexttowardl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return nextafter(x, y);
 }
 #endif
diff --git a/newlib/libm/common/powl.c b/newlib/libm/common/powl.c
index d956d52..b2331ef 100644
--- a/newlib/libm/common/powl.c
+++ b/newlib/libm/common/powl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 powl (long double x, long double y)
 {
+  __A_VARIABLE = 1;
   return pow(x, y);
 }
 #endif
diff --git a/newlib/libm/common/remainderl.c b/newlib/libm/common/remainderl.c
index f2a9e99..449ffe5 100644
--- a/newlib/libm/common/remainderl.c
+++ b/newlib/libm/common/remainderl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 remainderl (long double x, long double p)
 {
+  __A_VARIABLE = 1;
   return remainder(x, p);
 }
 #endif
diff --git a/newlib/libm/common/remquol.c b/newlib/libm/common/remquol.c
index aff9e72..60b600b 100644
--- a/newlib/libm/common/remquol.c
+++ b/newlib/libm/common/remquol.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 remquol (long double x, long double y, int *quo)
 {
+  __A_VARIABLE = 1;
   return remquo(x, y, quo);
 }
 #endif
diff --git a/newlib/libm/common/rintl.c b/newlib/libm/common/rintl.c
index 30a9abd..1370689 100644
--- a/newlib/libm/common/rintl.c
+++ b/newlib/libm/common/rintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 rintl (long double x)
 {
+  __A_VARIABLE = 1;
   return rint(x);
 }
 #endif
diff --git a/newlib/libm/common/roundl.c b/newlib/libm/common/roundl.c
index 8b67837..2aa8aad 100644
--- a/newlib/libm/common/roundl.c
+++ b/newlib/libm/common/roundl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 roundl (long double x)
 {
+  __A_VARIABLE = 1;
   return round(x);
 }
 #endif
diff --git a/newlib/libm/common/s_cbrt.c b/newlib/libm/common/s_cbrt.c
index 95185d0..5ec979a 100644
--- a/newlib/libm/common/s_cbrt.c
+++ b/newlib/libm/common/s_cbrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_cbrt.c 5.1 93/09/24 */
 /*
@@ -82,10 +83,15 @@ G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */
 	GET_HIGH_WORD(hx,x);
 	sign=hx&0x80000000; 		/* sign= sign(x) */
 	hx  ^=sign;
-	if(hx>=0x7ff00000) return(x+x); /* cbrt(NaN,INF) is itself */
+	if(hx>=0x7ff00000) {
+	    __A_VARIABLE = 1;
+	    return(x+x);
+	} /* cbrt(NaN,INF) is itself */
 	GET_LOW_WORD(low,x);
-	if((hx|low)==0) 
-	    return(x);		/* cbrt(0) is itself */
+	if((hx|low)==0) {
+	    __A_VARIABLE = 1;
+	    return(x);
+	}		/* cbrt(0) is itself */
 
 	SET_HIGH_WORD(x,hx);	/* x <- |x| */
     /* rough cbrt to 5 bits */
@@ -117,6 +123,7 @@ G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */
     /* retore the sign bit */
 	GET_HIGH_WORD(high,t);
 	SET_HIGH_WORD(t,high|sign);
+	__A_VARIABLE = 1;
 	return(t);
 }
 
diff --git a/newlib/libm/common/s_copysign.c b/newlib/libm/common/s_copysign.c
index bfc546d..77abd36 100644
--- a/newlib/libm/common/s_copysign.c
+++ b/newlib/libm/common/s_copysign.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_copysign.c 5.1 93/09/24 */
 /*
@@ -76,6 +77,7 @@ Definition (Issue 2).
 	GET_HIGH_WORD(hx,x);
 	GET_HIGH_WORD(hy,y);
 	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
+        __A_VARIABLE = 1;
         return x;
 }
 
diff --git a/newlib/libm/common/s_exp10.c b/newlib/libm/common/s_exp10.c
index 23cedfb..c755cca 100644
--- a/newlib/libm/common/s_exp10.c
+++ b/newlib/libm/common/s_exp10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)s_exp10.c 5.1 93/09/24 */
 /* Modified from s_exp2.c by Yaakov Selkowitz 2007.  */
 
@@ -74,6 +75,7 @@ PORTABILITY
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return pow(10.0, x);
 }
 
diff --git a/newlib/libm/common/s_expm1.c b/newlib/libm/common/s_expm1.c
index 12c88f1..8c6a608 100644
--- a/newlib/libm/common/s_expm1.c
+++ b/newlib/libm/common/s_expm1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_expm1.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_fdim.c b/newlib/libm/common/s_fdim.c
index a6c465c..ea25b0b 100644
--- a/newlib/libm/common/s_fdim.c
+++ b/newlib/libm/common/s_fdim.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -50,11 +51,20 @@ ANSI C, POSIX.
 #endif
 {
   int c = __fpclassifyd(x);
-  if (c == FP_NAN)  return(x);
-  if (__fpclassifyd(y) == FP_NAN)  return(y);
-  if (c == FP_INFINITE)
+  if (c == FP_NAN)  {
+    __A_VARIABLE = 1;
+    return(x);
+  }
+  if (__fpclassifyd(y) == FP_NAN)  {
+    __A_VARIABLE = 1;
+    return(y);
+  }
+  if (c == FP_INFINITE) {
+    __A_VARIABLE = 1;
     return HUGE_VAL;
+  }
 
+  __A_VARIABLE = 1;
   return x > y ? x - y : 0.0;
 }
 
diff --git a/newlib/libm/common/s_finite.c b/newlib/libm/common/s_finite.c
index 17f4e84..9dd7e02 100644
--- a/newlib/libm/common/s_finite.c
+++ b/newlib/libm/common/s_finite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_finite.c 5.1 93/09/24 */
 /*
@@ -29,6 +30,7 @@
 {
 	__int32_t hx;
 	GET_HIGH_WORD(hx,x);
+	__A_VARIABLE = 1;
 	return  (int)((__uint32_t)((hx&0x7fffffff)-0x7ff00000)>>31);
 }
 
diff --git a/newlib/libm/common/s_fma.c b/newlib/libm/common/s_fma.c
index bbb3eb0..fd96eb8 100644
--- a/newlib/libm/common/s_fma.c
+++ b/newlib/libm/common/s_fma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
 <<fma>>, <<fmaf>>---floating multiply add
@@ -50,6 +51,7 @@ ANSI C, POSIX.
 #endif
 {
   /* Implementation defined. */
+  __A_VARIABLE = 1;
   return (x * y) + z;
 }
 
diff --git a/newlib/libm/common/s_fmax.c b/newlib/libm/common/s_fmax.c
index 8f446e2..713e556 100644
--- a/newlib/libm/common/s_fmax.c
+++ b/newlib/libm/common/s_fmax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -41,11 +42,16 @@ ANSI C, POSIX.
 	double y;
 #endif
 {
-  if (__fpclassifyd(x) == FP_NAN)
+  if (__fpclassifyd(x) == FP_NAN) {
+    __A_VARIABLE = 1;
     return y;
-  if (__fpclassifyd(y) == FP_NAN)
+  }
+  if (__fpclassifyd(y) == FP_NAN) {
+    __A_VARIABLE = 1;
     return x;
+  }
   
+  __A_VARIABLE = 1;
   return x > y ? x : y;
 }
 
diff --git a/newlib/libm/common/s_fmin.c b/newlib/libm/common/s_fmin.c
index 2d0cd80..62ef6b8 100644
--- a/newlib/libm/common/s_fmin.c
+++ b/newlib/libm/common/s_fmin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -41,11 +42,16 @@ ANSI C, POSIX.
 	double y;
 #endif
 {
-  if (__fpclassifyd(x) == FP_NAN)
+  if (__fpclassifyd(x) == FP_NAN) {
+    __A_VARIABLE = 1;
     return y;
-  if (__fpclassifyd(y) == FP_NAN)
+  }
+  if (__fpclassifyd(y) == FP_NAN) {
+    __A_VARIABLE = 1;
     return x;
+  }
   
+  __A_VARIABLE = 1;
   return x < y ? x : y;
 }
 
diff --git a/newlib/libm/common/s_fpclassify.c b/newlib/libm/common/s_fpclassify.c
index 3ebba70..1ed9a8a 100644
--- a/newlib/libm/common/s_fpclassify.c
+++ b/newlib/libm/common/s_fpclassify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002, 2007 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libm/common/s_ilogb.c b/newlib/libm/common/s_ilogb.c
index 477ec2e..ae6f31c 100644
--- a/newlib/libm/common/s_ilogb.c
+++ b/newlib/libm/common/s_ilogb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_ilogb.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_infinity.c b/newlib/libm/common/s_infinity.c
index 9285a76..7478923 100644
--- a/newlib/libm/common/s_infinity.c
+++ b/newlib/libm/common/s_infinity.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * infinity () returns the representation of infinity.
  * Added by Cygnus Support.
@@ -43,6 +44,7 @@ QUICKREF
 	double x;
 
 	INSERT_WORDS(x,0x7ff00000,0);
+	__A_VARIABLE = 1;
 	return x;
 }
 
diff --git a/newlib/libm/common/s_isinf.c b/newlib/libm/common/s_isinf.c
index fe18e2a..68b30ac 100644
--- a/newlib/libm/common/s_isinf.c
+++ b/newlib/libm/common/s_isinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * isinf(x) returns 1 if x is infinity, else 0;
  * no branching!
@@ -24,6 +25,7 @@ _DEFUN (isinf, (x),
 	hx &= 0x7fffffff;
 	hx |= (__uint32_t)(lx|(-lx))>>31;	
 	hx = 0x7ff00000 - hx;
+	__A_VARIABLE = 1;
 	return 1 - (int)((__uint32_t)(hx|(-hx))>>31);
 }
 
diff --git a/newlib/libm/common/s_isinfd.c b/newlib/libm/common/s_isinfd.c
index 5a2b04d..1c36af1 100644
--- a/newlib/libm/common/s_isinfd.c
+++ b/newlib/libm/common/s_isinfd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * __isinfd(x) returns 1 if x is infinity, else 0;
  * no branching!
@@ -17,6 +18,7 @@ _DEFUN (__isinfd, (x),
 	hx &= 0x7fffffff;
 	hx |= (__uint32_t)(lx|(-lx))>>31;	
 	hx = 0x7ff00000 - hx;
+	__A_VARIABLE = 1;
 	return 1 - (int)((__uint32_t)(hx|(-hx))>>31);
 }
 
diff --git a/newlib/libm/common/s_isnan.c b/newlib/libm/common/s_isnan.c
index bc0a916..5fcdcdc 100644
--- a/newlib/libm/common/s_isnan.c
+++ b/newlib/libm/common/s_isnan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_isnan.c 5.1 93/09/24 */
 /*
@@ -204,6 +205,7 @@ QUICKREF
 	hx &= 0x7fffffff;
 	hx |= (__uint32_t)(lx|(-lx))>>31;	
 	hx = 0x7ff00000 - hx;
+	__A_VARIABLE = 1;
 	return (int)(((__uint32_t)(hx))>>31);
 }
 
diff --git a/newlib/libm/common/s_isnand.c b/newlib/libm/common/s_isnand.c
index 0ac8c59..267b57a 100644
--- a/newlib/libm/common/s_isnand.c
+++ b/newlib/libm/common/s_isnand.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -116,6 +117,7 @@ _DEFUN (__isnand, (x),
 	hx &= 0x7fffffff;
 	hx |= (__uint32_t)(lx|(-lx))>>31;	
 	hx = 0x7ff00000 - hx;
+	__A_VARIABLE = 1;
 	return (int)(((__uint32_t)(hx))>>31);
 }
 
diff --git a/newlib/libm/common/s_lib_ver.c b/newlib/libm/common/s_lib_ver.c
index 15c8b41..2cd6096 100644
--- a/newlib/libm/common/s_lib_ver.c
+++ b/newlib/libm/common/s_lib_ver.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_lib_ver.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_llrint.c b/newlib/libm/common/s_llrint.c
index 8b8a846..9b43736 100644
--- a/newlib/libm/common/s_llrint.c
+++ b/newlib/libm/common/s_llrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lrint adapted to be llrint for Newlib, 2009 by Craig Howland.  */
 /* @(#)s_lrint.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_llround.c b/newlib/libm/common/s_llround.c
index 0bc35ac..a908c35 100644
--- a/newlib/libm/common/s_llround.c
+++ b/newlib/libm/common/s_llround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lround adapted to be llround for Newlib, 2009 by Craig Howland.  */
 /*
  * ====================================================
diff --git a/newlib/libm/common/s_log1p.c b/newlib/libm/common/s_log1p.c
index 351c887..2fb72e4 100644
--- a/newlib/libm/common/s_log1p.c
+++ b/newlib/libm/common/s_log1p.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_log1p.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_log2.c b/newlib/libm/common/s_log2.c
index 3b05066..c3b2f4a 100644
--- a/newlib/libm/common/s_log2.c
+++ b/newlib/libm/common/s_log2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)s_log2.c 5.1 93/09/24 */
 /* Modification from s_exp10.c Yaakov Selkowitz 2009.  */
 
@@ -79,6 +80,7 @@ C99, POSIX, System V Interface Definition (Issue 6).
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return (log(x) / M_LN2);
 }
 
diff --git a/newlib/libm/common/s_logb.c b/newlib/libm/common/s_logb.c
index 7e71457..379735e 100644
--- a/newlib/libm/common/s_logb.c
+++ b/newlib/libm/common/s_logb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 2009 for Newlib:  Sun's s_ilogb.c converted to be s_logb.c.  */
 /* @(#)s_ilogb.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_lrint.c b/newlib/libm/common/s_lrint.c
index 52bb522..8291651 100644
--- a/newlib/libm/common/s_lrint.c
+++ b/newlib/libm/common/s_lrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_lrint.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_lround.c b/newlib/libm/common/s_lround.c
index 52cd74f..8b88613 100644
--- a/newlib/libm/common/s_lround.c
+++ b/newlib/libm/common/s_lround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
diff --git a/newlib/libm/common/s_matherr.c b/newlib/libm/common/s_matherr.c
index 58e2428..2ce7dbf 100644
--- a/newlib/libm/common/s_matherr.c
+++ b/newlib/libm/common/s_matherr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_matherr.c 5.1 93/09/24 */
 /*
@@ -118,6 +119,10 @@ PORTABILITY
 #endif
 {
 	int n=0;
-	if(x->arg1!=x->arg1) return 0;
+	if(x->arg1!=x->arg1) {
+		__A_VARIABLE = 1;
+		return 0;
+	}
+	__A_VARIABLE = 1;
 	return n;
 }
diff --git a/newlib/libm/common/s_modf.c b/newlib/libm/common/s_modf.c
index 2e9bfb1..f10e134 100644
--- a/newlib/libm/common/s_modf.c
+++ b/newlib/libm/common/s_modf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_modf.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_nan.c b/newlib/libm/common/s_nan.c
index a98650d..b1a26d5 100644
--- a/newlib/libm/common/s_nan.c
+++ b/newlib/libm/common/s_nan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * nan () returns a nan.
  * Added by Cygnus Support.
@@ -46,6 +47,7 @@ QUICKREF
 #else
 	INSERT_WORDS(x,0x7ff80000,0);
 #endif
+	__A_VARIABLE = 1;
 	return x;
 }
 
diff --git a/newlib/libm/common/s_nearbyint.c b/newlib/libm/common/s_nearbyint.c
index 714b66a..c8b96b7 100644
--- a/newlib/libm/common/s_nearbyint.c
+++ b/newlib/libm/common/s_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -58,6 +59,7 @@ SEEALSO
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return rint(x);
 }
 
diff --git a/newlib/libm/common/s_nextafter.c b/newlib/libm/common/s_nextafter.c
index 3a7fa3f..6d422da 100644
--- a/newlib/libm/common/s_nextafter.c
+++ b/newlib/libm/common/s_nextafter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_nextafter.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_pow10.c b/newlib/libm/common/s_pow10.c
index 052e26d..534d2d7 100644
--- a/newlib/libm/common/s_pow10.c
+++ b/newlib/libm/common/s_pow10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)s_pow10.c 5.1 93/09/24 */
 /* Modification from s_exp10.c Yaakov Selkowitz 2007.  */
 
@@ -73,6 +74,7 @@ PORTABILITY
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return pow(10.0, x);
 }
 
diff --git a/newlib/libm/common/s_remquo.c b/newlib/libm/common/s_remquo.c
index 30bf15f..fcad5c5 100644
--- a/newlib/libm/common/s_remquo.c
+++ b/newlib/libm/common/s_remquo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Adapted for Newlib, 2009.  (Allow for int < 32 bits; return *quo=0 during
  * errors to make test scripts easier.)  */
 /* @(#)e_fmod.c 1.3 95/01/18 */
diff --git a/newlib/libm/common/s_rint.c b/newlib/libm/common/s_rint.c
index f06325a..6c4d5e4 100644
--- a/newlib/libm/common/s_rint.c
+++ b/newlib/libm/common/s_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_rint.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_round.c b/newlib/libm/common/s_round.c
index 07aac9e..1f54fac 100644
--- a/newlib/libm/common/s_round.c
+++ b/newlib/libm/common/s_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
diff --git a/newlib/libm/common/s_scalbln.c b/newlib/libm/common/s_scalbln.c
index 5af9d89..2959841 100644
--- a/newlib/libm/common/s_scalbln.c
+++ b/newlib/libm/common/s_scalbln.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)s_scalbn.c 5.1 93/09/24 */
 /*
  * ====================================================
@@ -42,22 +43,37 @@ tiny   = 1.0e-300;
 	EXTRACT_WORDS(hx,lx,x);
         k = (hx&0x7ff00000)>>20;		/* extract exponent */
         if (k==0) {				/* 0 or subnormal x */
-            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
+            if ((lx|(hx&0x7fffffff))==0) {
+	        __A_VARIABLE = 1;
+	        return x;
+	    } /* +-0 */
 	    x *= two54;
 	    GET_HIGH_WORD(hx,x);
 	    k = ((hx&0x7ff00000)>>20) - 54;
 	    }
-        if (k==0x7ff) return x+x;		/* NaN or Inf */
+        if (k==0x7ff) {
+	    __A_VARIABLE = 1;
+	  return x+x;
+        }		/* NaN or Inf */
         k = k+n;
-        if (n> 50000 || k >  0x7fe)
-	  return huge*copysign(huge,x); /* overflow  */
-	if (n< -50000) return tiny*copysign(tiny,x); /*underflow*/
+        if (n> 50000 || k >  0x7fe) {
+	  __A_VARIABLE = 1;
+	  return huge*copysign(huge,x);
+	} /* overflow  */
+	if (n< -50000) {
+	  __A_VARIABLE = 1;
+	  return tiny*copysign(tiny,x);
+        } /*underflow*/
         if (k > 0) 				/* normal result */
-	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
-        if (k <= -54)
-	  return tiny*copysign(tiny,x); 	/*underflow*/
+	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); __A_VARIABLE = 1;
+	  return x;}
+        if (k <= -54) {
+	  __A_VARIABLE = 1;
+	  return tiny*copysign(tiny,x);
+        } 	/*underflow*/
         k += 54;				/* subnormal result */
 	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
+        __A_VARIABLE = 1;
         return x*twom54;
 }
 
diff --git a/newlib/libm/common/s_scalbn.c b/newlib/libm/common/s_scalbn.c
index 7fab586..ea71a56 100644
--- a/newlib/libm/common/s_scalbn.c
+++ b/newlib/libm/common/s_scalbn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_scalbn.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/common/s_signbit.c b/newlib/libm/common/s_signbit.c
index d2ba1fc..670d450 100644
--- a/newlib/libm/common/s_signbit.c
+++ b/newlib/libm/common/s_signbit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -45,6 +46,7 @@ __signbitf (float x)
 
   GET_FLOAT_WORD(w,x);
 
+  __A_VARIABLE = 1;
   return (w & 0x80000000) != 0;
 }
 
@@ -55,5 +57,6 @@ __signbitd (double x)
 
   GET_HIGH_WORD(msw, x);
 
+  __A_VARIABLE = 1;
   return (msw & 0x80000000) != 0;
 }
diff --git a/newlib/libm/common/s_trunc.c b/newlib/libm/common/s_trunc.c
index 31a1f92..8f2a9a6 100644
--- a/newlib/libm/common/s_trunc.c
+++ b/newlib/libm/common/s_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
diff --git a/newlib/libm/common/scalblnl.c b/newlib/libm/common/scalblnl.c
index 2a2106a..33d58e8 100644
--- a/newlib/libm/common/scalblnl.c
+++ b/newlib/libm/common/scalblnl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 scalblnl (long double x, long n)
 {
+  __A_VARIABLE = 1;
   return scalbln(x, n);
 }
 #endif
diff --git a/newlib/libm/common/scalbnl.c b/newlib/libm/common/scalbnl.c
index 7af4f5b..e1732c8 100644
--- a/newlib/libm/common/scalbnl.c
+++ b/newlib/libm/common/scalbnl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 scalbnl (long double x, int n)
 {
+  __A_VARIABLE = 1;
   return scalbn(x, n);
 }
 #endif
diff --git a/newlib/libm/common/sf_cbrt.c b/newlib/libm/common/sf_cbrt.c
index fe632f0..e64d206 100644
--- a/newlib/libm/common/sf_cbrt.c
+++ b/newlib/libm/common/sf_cbrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_cbrt.c -- float version of s_cbrt.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -53,10 +54,14 @@ G =  3.5714286566e-01; /* 5/14      = 0x3eb6db6e */
 	GET_FLOAT_WORD(hx,x);
 	sign=hx&0x80000000; 		/* sign= sign(x) */
 	hx  ^=sign;
-	if(!FLT_UWORD_IS_FINITE(hx))
-	    return(x+x);		/* cbrt(NaN,INF) is itself */
-	if(FLT_UWORD_IS_ZERO(hx))
-	    return(x);			/* cbrt(0) is itself */
+	if(!FLT_UWORD_IS_FINITE(hx)) {
+	    __A_VARIABLE = 1;
+	    return(x+x);
+	}		/* cbrt(NaN,INF) is itself */
+	if(FLT_UWORD_IS_ZERO(hx)) {
+	    __A_VARIABLE = 1;
+	    return(x);
+	}			/* cbrt(0) is itself */
 
 	SET_FLOAT_WORD(x,hx);	/* x <- |x| */
     /* rough cbrt to 5 bits */
@@ -76,6 +81,7 @@ G =  3.5714286566e-01; /* 5/14      = 0x3eb6db6e */
     /* retore the sign bit */
 	GET_FLOAT_WORD(high,t);
 	SET_FLOAT_WORD(t,high|sign);
+	__A_VARIABLE = 1;
 	return(t);
 }
 
@@ -88,6 +94,7 @@ G =  3.5714286566e-01; /* 5/14      = 0x3eb6db6e */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) cbrtf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_copysign.c b/newlib/libm/common/sf_copysign.c
index f547c82..1b01912 100644
--- a/newlib/libm/common/sf_copysign.c
+++ b/newlib/libm/common/sf_copysign.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_copysign.c -- float version of s_copysign.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -32,6 +33,7 @@
 	GET_FLOAT_WORD(ix,x);
 	GET_FLOAT_WORD(iy,y);
 	SET_FLOAT_WORD(x,(ix&0x7fffffff)|(iy&0x80000000));
+        __A_VARIABLE = 1;
         return x;
 }
 
@@ -44,6 +46,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) copysignf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/common/sf_exp10.c b/newlib/libm/common/sf_exp10.c
index eb70a9c..caba5e7 100644
--- a/newlib/libm/common/sf_exp10.c
+++ b/newlib/libm/common/sf_exp10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_exp10.c -- float version of s_exp10.c.
  * Modification of sf_exp2.c by Yaakov Selkowitz 2007.
  */
@@ -29,6 +30,7 @@
 	float x;
 #endif
 {
+  __A_VARIABLE = 1;
   return powf(10.0, x);
 }
 
@@ -41,6 +43,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) exp10f((float) x);
 }
 
diff --git a/newlib/libm/common/sf_expm1.c b/newlib/libm/common/sf_expm1.c
index 4ba3b81..a0ed62a 100644
--- a/newlib/libm/common/sf_expm1.c
+++ b/newlib/libm/common/sf_expm1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_expm1.c -- float version of s_expm1.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -139,6 +140,7 @@ Q5  =  -2.0109921195e-07; /* 0xb457edbb */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) expm1f((float) x);
 }
 
diff --git a/newlib/libm/common/sf_fdim.c b/newlib/libm/common/sf_fdim.c
index fe34909..f078485 100644
--- a/newlib/libm/common/sf_fdim.c
+++ b/newlib/libm/common/sf_fdim.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -15,11 +16,20 @@
 #endif
 {
   int c = __fpclassifyf(x);
-  if (c == FP_NAN)  return(x);
-  if (__fpclassifyf(y) == FP_NAN)  return(y);
-  if (c == FP_INFINITE)
+  if (c == FP_NAN)  {
+    __A_VARIABLE = 1;
+    return(x);
+  }
+  if (__fpclassifyf(y) == FP_NAN)  {
+    __A_VARIABLE = 1;
+    return(y);
+  }
+  if (c == FP_INFINITE) {
+    __A_VARIABLE = 1;
     return HUGE_VALF;
+  }
 
+  __A_VARIABLE = 1;
   return x > y ? x - y : 0.0;
 }
 
@@ -33,6 +43,7 @@
 	double y;
 #endif
 {
+  __A_VARIABLE = 1;
   return (double) fdimf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/common/sf_finite.c b/newlib/libm/common/sf_finite.c
index cb7026f..12b34c6 100644
--- a/newlib/libm/common/sf_finite.c
+++ b/newlib/libm/common/sf_finite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_finite.c -- float version of s_finite.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -30,6 +31,7 @@
 	__int32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
+	__A_VARIABLE = 1;
 	return (FLT_UWORD_IS_FINITE(ix));
 }
 
@@ -42,6 +44,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return finitef((float) x);
 }
 
diff --git a/newlib/libm/common/sf_fma.c b/newlib/libm/common/sf_fma.c
index 4360f40..d942149 100644
--- a/newlib/libm/common/sf_fma.c
+++ b/newlib/libm/common/sf_fma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -22,6 +23,7 @@
   /* In floating-point implementations in which double is larger than float,
    * computing as double should provide the desired function.  Otherwise,
    * the behavior will not be as specified in the standards.  */
+  __A_VARIABLE = 1;
   return (float) (((double) x * (double) y) + (double) z);
 }
 
@@ -36,6 +38,7 @@
         double z;
 #endif
 {
+  __A_VARIABLE = 1;
   return (double) fmaf((float) x, (float) y, (float) z);
 }
 
diff --git a/newlib/libm/common/sf_fmax.c b/newlib/libm/common/sf_fmax.c
index ac1bf46..14d2646 100644
--- a/newlib/libm/common/sf_fmax.c
+++ b/newlib/libm/common/sf_fmax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -14,11 +15,16 @@
 	float y;
 #endif
 {
-  if (__fpclassifyf(x) == FP_NAN)
+  if (__fpclassifyf(x) == FP_NAN) {
+    __A_VARIABLE = 1;
     return y;
-  if (__fpclassifyf(y) == FP_NAN)
+  }
+  if (__fpclassifyf(y) == FP_NAN) {
+    __A_VARIABLE = 1;
     return x;
+  }
   
+  __A_VARIABLE = 1;
   return x > y ? x : y;
 }
 
@@ -32,6 +38,7 @@
 	double y;
 #endif
 {
+  __A_VARIABLE = 1;
   return (double) fmaxf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/common/sf_fmin.c b/newlib/libm/common/sf_fmin.c
index f0e3444..30156f1 100644
--- a/newlib/libm/common/sf_fmin.c
+++ b/newlib/libm/common/sf_fmin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -14,11 +15,16 @@
 	float y;
 #endif
 {
-  if (__fpclassifyf(x) == FP_NAN)
+  if (__fpclassifyf(x) == FP_NAN) {
+    __A_VARIABLE = 1;
     return y;
-  if (__fpclassifyf(y) == FP_NAN)
+  }
+  if (__fpclassifyf(y) == FP_NAN) {
+    __A_VARIABLE = 1;
     return x;
+  }
   
+  __A_VARIABLE = 1;
   return x < y ? x : y;
 }
 
@@ -32,6 +38,7 @@
 	double y;
 #endif
 {
+  __A_VARIABLE = 1;
   return (double) fminf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/common/sf_fpclassify.c b/newlib/libm/common/sf_fpclassify.c
index 878457f..9313128 100644
--- a/newlib/libm/common/sf_fpclassify.c
+++ b/newlib/libm/common/sf_fpclassify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002,2007 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libm/common/sf_ilogb.c b/newlib/libm/common/sf_ilogb.c
index 28191c2..e0c8d1f 100644
--- a/newlib/libm/common/sf_ilogb.c
+++ b/newlib/libm/common/sf_ilogb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_ilogb.c -- float version of s_ilogb.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -49,6 +50,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return ilogbf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_infinity.c b/newlib/libm/common/sf_infinity.c
index 8722596..cb1a9bd 100644
--- a/newlib/libm/common/sf_infinity.c
+++ b/newlib/libm/common/sf_infinity.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * infinityf () returns the representation of infinity.
  * Added by Cygnus Support.
@@ -10,6 +11,7 @@
 	float x;
 
 	SET_FLOAT_WORD(x,0x7f800000);
+	__A_VARIABLE = 1;
 	return x;
 }
 
@@ -17,6 +19,7 @@
 
 	double infinity()
 {
+	__A_VARIABLE = 1;
 	return (double) infinityf();
 }
 
diff --git a/newlib/libm/common/sf_isinf.c b/newlib/libm/common/sf_isinf.c
index 5b57a34..ffee7d1 100644
--- a/newlib/libm/common/sf_isinf.c
+++ b/newlib/libm/common/sf_isinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * isinff(x) returns 1 if x is +-infinity, else 0;
  *
@@ -19,6 +20,7 @@ _DEFUN (isinff, (x),
 	__int32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
+	__A_VARIABLE = 1;
 	return FLT_UWORD_IS_INFINITE(ix);
 }
 
@@ -30,6 +32,7 @@ int
 _DEFUN (isinf, (x),
 	double x)
 {
+	__A_VARIABLE = 1;
 	return isinff((float) x);
 }
 
diff --git a/newlib/libm/common/sf_isinff.c b/newlib/libm/common/sf_isinff.c
index 9d0e742..b95cb66 100644
--- a/newlib/libm/common/sf_isinff.c
+++ b/newlib/libm/common/sf_isinff.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * __isinff(x) returns 1 if x is +-infinity, else 0;
  * Added by Cygnus Support.
@@ -12,6 +13,7 @@ _DEFUN (__isinff, (x),
 	__int32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
+	__A_VARIABLE = 1;
 	return FLT_UWORD_IS_INFINITE(ix);
 }
 
@@ -21,6 +23,7 @@ int
 _DEFUN (__isinfd, (x),
 	double x)
 {
+	__A_VARIABLE = 1;
 	return __isinff((float) x);
 }
 
diff --git a/newlib/libm/common/sf_isnan.c b/newlib/libm/common/sf_isnan.c
index 9c813fc..1bae77c 100644
--- a/newlib/libm/common/sf_isnan.c
+++ b/newlib/libm/common/sf_isnan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_c_isnan.c -- float version of s_c_isnan.c.
  */
 
@@ -30,6 +31,7 @@ _DEFUN (isnanf, (x),
 	__int32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
+	__A_VARIABLE = 1;
 	return FLT_UWORD_IS_NAN(ix);
 }
 
@@ -41,6 +43,7 @@ int
 _DEFUN (isnan, (x),
 	double x)
 {
+	__A_VARIABLE = 1;
 	return isnanf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_isnanf.c b/newlib/libm/common/sf_isnanf.c
index 0b0d9bb..011f802 100644
--- a/newlib/libm/common/sf_isnanf.c
+++ b/newlib/libm/common/sf_isnanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -22,6 +23,7 @@ _DEFUN (__isnanf, (x),
 	__int32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
+	__A_VARIABLE = 1;
 	return FLT_UWORD_IS_NAN(ix);
 }
 
@@ -31,6 +33,7 @@ int
 _DEFUN (__isnand, (x),
 	double x)
 {
+	__A_VARIABLE = 1;
 	return __isnanf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_llrint.c b/newlib/libm/common/sf_llrint.c
index 7558e89..c155214 100644
--- a/newlib/libm/common/sf_llrint.c
+++ b/newlib/libm/common/sf_llrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lrintf adapted to be llrintf for Newlib, 2009 by Craig Howland.  */
 /* @(#)sf_lrint.c 5.1 93/09/24 */
 /*
@@ -95,6 +96,7 @@ TWO23[2]={
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return llrintf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_llround.c b/newlib/libm/common/sf_llround.c
index fe2b4bd..504bb95 100644
--- a/newlib/libm/common/sf_llround.c
+++ b/newlib/libm/common/sf_llround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* lroundf adapted to be llroundf for Newlib, 2009 by Craig Howland.  */
 /*
  * ====================================================
@@ -49,6 +50,7 @@ llroundf(float x)
 long long int
 llround(double x)
 {
+	__A_VARIABLE = 1;
 	return llroundf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_log1p.c b/newlib/libm/common/sf_log1p.c
index e09170f..598c9a3 100644
--- a/newlib/libm/common/sf_log1p.c
+++ b/newlib/libm/common/sf_log1p.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_log1p.c -- float version of s_log1p.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -115,6 +116,7 @@ static float zero = 0.0;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) log1pf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_log2.c b/newlib/libm/common/sf_log2.c
index 9fbaaca..f5aa948 100644
--- a/newlib/libm/common/sf_log2.c
+++ b/newlib/libm/common/sf_log2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_log2.c -- float version of s_log2.c.
  * Modification of sf_exp10.c by Yaakov Selkowitz 2009.
  */
@@ -30,6 +31,7 @@
 	float x;
 #endif
 {
+  __A_VARIABLE = 1;
   return (logf(x) / (float_t) M_LN2);
 }
 
@@ -42,6 +44,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) log2f((float) x);
 }
 
diff --git a/newlib/libm/common/sf_logb.c b/newlib/libm/common/sf_logb.c
index 75336a1..a288458 100644
--- a/newlib/libm/common/sf_logb.c
+++ b/newlib/libm/common/sf_logb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 2009 for Newlib:  Sun's sf_ilogb.c converted to be sf_logb.c.  */
 /*
  * ====================================================
@@ -56,6 +57,7 @@ float x;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) logbf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_lrint.c b/newlib/libm/common/sf_lrint.c
index 3c58c5d..5890e5b 100644
--- a/newlib/libm/common/sf_lrint.c
+++ b/newlib/libm/common/sf_lrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)sf_lrint.c 5.1 93/09/24 */
 /*
@@ -95,6 +96,7 @@ TWO23[2]={
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return lrintf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_lround.c b/newlib/libm/common/sf_lround.c
index e1f2fa1..3dea23d 100644
--- a/newlib/libm/common/sf_lround.c
+++ b/newlib/libm/common/sf_lround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -56,6 +57,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return lroundf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_modf.c b/newlib/libm/common/sf_modf.c
index 6c64e3f..8a48f51 100644
--- a/newlib/libm/common/sf_modf.c
+++ b/newlib/libm/common/sf_modf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_modf.c -- float version of s_modf.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -67,6 +68,7 @@ static float one = 1.0;
 	double x,*iptr;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) modff((float) x, (float *) iptr);
 }
 
diff --git a/newlib/libm/common/sf_nan.c b/newlib/libm/common/sf_nan.c
index 8f0e1a8..601ffe2 100644
--- a/newlib/libm/common/sf_nan.c
+++ b/newlib/libm/common/sf_nan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * nanf () returns a nan.
  * Added by Cygnus Support.
@@ -14,6 +15,7 @@
 #else
 	SET_FLOAT_WORD(x,0x7fc00000);
 #endif
+	__A_VARIABLE = 1;
 	return x;
 }
 
@@ -21,6 +23,7 @@
 
 	double nan(const char *arg)
 {
+	__A_VARIABLE = 1;
 	return (double) nanf(arg);
 }
 
diff --git a/newlib/libm/common/sf_nearbyint.c b/newlib/libm/common/sf_nearbyint.c
index 0073b6d..acd2665 100644
--- a/newlib/libm/common/sf_nearbyint.c
+++ b/newlib/libm/common/sf_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -20,6 +21,7 @@
 	float x;
 #endif
 {
+  __A_VARIABLE = 1;
   return rintf(x);
 }
 
@@ -32,6 +34,7 @@
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return (double) nearbyintf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_nextafter.c b/newlib/libm/common/sf_nextafter.c
index cea4da5..1f43494 100644
--- a/newlib/libm/common/sf_nextafter.c
+++ b/newlib/libm/common/sf_nextafter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_nextafter.c -- float version of s_nextafter.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -73,6 +74,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) nextafterf((float) x, (float) x);
 }
 
diff --git a/newlib/libm/common/sf_pow10.c b/newlib/libm/common/sf_pow10.c
index 116afac..41b28df 100644
--- a/newlib/libm/common/sf_pow10.c
+++ b/newlib/libm/common/sf_pow10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_pow10.c -- float version of s_pow10.c.
  * Modification of sf_pow10.c by Yaakov Selkowitz 2007.
  */
@@ -29,6 +30,7 @@
 	float x;
 #endif
 {
+  __A_VARIABLE = 1;
   return powf(10.0, x);
 }
 
@@ -41,6 +43,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) pow10f((float) x);
 }
 
diff --git a/newlib/libm/common/sf_remquo.c b/newlib/libm/common/sf_remquo.c
index 7a756af..bb703fe 100644
--- a/newlib/libm/common/sf_remquo.c
+++ b/newlib/libm/common/sf_remquo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Adapted for Newlib, 2009.  (Allow for int < 32 bits; return *quo=0 during
  * errors to make test scripts easier.)  */
 /* @(#)e_fmod.c 1.3 95/01/18 */
diff --git a/newlib/libm/common/sf_rint.c b/newlib/libm/common/sf_rint.c
index bc0b466..73853e2 100644
--- a/newlib/libm/common/sf_rint.c
+++ b/newlib/libm/common/sf_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_rint.c -- float version of s_rint.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -78,6 +79,7 @@ TWO23[2]={
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) rintf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_round.c b/newlib/libm/common/sf_round.c
index c8f1d77..8170c94 100644
--- a/newlib/libm/common/sf_round.c
+++ b/newlib/libm/common/sf_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -68,6 +69,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) roundf((float) x);
 }
 
diff --git a/newlib/libm/common/sf_scalbln.c b/newlib/libm/common/sf_scalbln.c
index dd4baf5..a8efba5 100644
--- a/newlib/libm/common/sf_scalbln.c
+++ b/newlib/libm/common/sf_scalbln.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_scalbnf.c -- float version of s_scalbn.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -36,23 +37,37 @@ tiny   = 1.0e-30;
 	GET_FLOAT_WORD(ix,x);
         k = (ix&0x7f800000)>>23;		/* extract exponent */
         if (k==0) {				/* 0 or subnormal x */
-            if ((ix&0x7fffffff)==0) return x; /* +-0 */
+            if ((ix&0x7fffffff)==0) {
+                __A_VARIABLE = 1;
+	        return x;
+	    } /* +-0 */
 	    x *= two25;
 	    GET_FLOAT_WORD(ix,x);
 	    k = ((ix&0x7f800000)>>23) - 25;
 	    }
-        if (k==0xff) return x+x;		/* NaN or Inf */
+        if (k==0xff) {
+	    __A_VARIABLE = 1;
+	  return x+x;
+        }		/* NaN or Inf */
         k = k+n;
-        if (n> 50000 || k >  0xfe)
-	  return huge*copysignf(huge,x); /* overflow  */
-	if (n< -50000)
-	  return tiny*copysignf(tiny,x);	/*underflow*/
+        if (n> 50000 || k >  0xfe) {
+	  __A_VARIABLE = 1;
+	  return huge*copysignf(huge,x);
+	} /* overflow  */
+	if (n< -50000) {
+	  __A_VARIABLE = 1;
+	  return tiny*copysignf(tiny,x);
+        }	/*underflow*/
         if (k > 0) 				/* normal result */
-	    {SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23)); return x;}
-        if (k <= -25)
-	    return tiny*copysignf(tiny,x);	/*underflow*/
+	    {SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23)); __A_VARIABLE = 1;
+	    return x;}
+        if (k <= -25) {
+	    __A_VARIABLE = 1;
+	    return tiny*copysignf(tiny,x);
+        }	/*underflow*/
         k += 25;				/* subnormal result */
 	SET_FLOAT_WORD(x,(ix&0x807fffff)|(k<<23));
+        __A_VARIABLE = 1;
         return x*twom25;
 }
 
@@ -65,6 +80,7 @@ tiny   = 1.0e-30;
 	double x; long int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) scalblnf((float) x, n);
 }
 
diff --git a/newlib/libm/common/sf_scalbn.c b/newlib/libm/common/sf_scalbn.c
index 7000600..32f92fd 100644
--- a/newlib/libm/common/sf_scalbn.c
+++ b/newlib/libm/common/sf_scalbn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_scalbn.c -- float version of s_scalbn.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -80,6 +81,7 @@ tiny   = 1.0e-30;
 	int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) scalbnf((float) x, n);
 }
 
diff --git a/newlib/libm/common/sf_trunc.c b/newlib/libm/common/sf_trunc.c
index 74ea933..fe0e8fc 100644
--- a/newlib/libm/common/sf_trunc.c
+++ b/newlib/libm/common/sf_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
@@ -60,6 +61,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) truncf((float) x);
 }
 
diff --git a/newlib/libm/common/sinhl.c b/newlib/libm/common/sinhl.c
index b57905a..3a1b36f 100644
--- a/newlib/libm/common/sinhl.c
+++ b/newlib/libm/common/sinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 sinhl (long double x)
 {
+  __A_VARIABLE = 1;
   return sinh(x);
 }
 #endif
diff --git a/newlib/libm/common/sinl.c b/newlib/libm/common/sinl.c
index c6fe1e8..d62ee31 100644
--- a/newlib/libm/common/sinl.c
+++ b/newlib/libm/common/sinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 sinl (long double x)
 {
+  __A_VARIABLE = 1;
   return sin(x);
 }
 #endif
diff --git a/newlib/libm/common/sl_finite.c b/newlib/libm/common/sl_finite.c
index 9ec6290..10f7eb4 100644
--- a/newlib/libm/common/sl_finite.c
+++ b/newlib/libm/common/sl_finite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2015 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libm/common/sqrtl.c b/newlib/libm/common/sqrtl.c
index 8cd717e..00dde21 100644
--- a/newlib/libm/common/sqrtl.c
+++ b/newlib/libm/common/sqrtl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 sqrtl (long double x)
 {
+  __A_VARIABLE = 1;
   return sqrt(x);
 }
 
@@ -95,6 +97,7 @@ inc (long double x)
 	}
     }
 
+  __A_VARIABLE = 1;
   return ux.extu_ld;
 }
 
@@ -114,6 +117,7 @@ dec (long double x)
 	}
     }
 
+  __A_VARIABLE = 1;
   return ux.extu_ld;
 }
 
diff --git a/newlib/libm/common/tanhl.c b/newlib/libm/common/tanhl.c
index 3e66b59..74295a7 100644
--- a/newlib/libm/common/tanhl.c
+++ b/newlib/libm/common/tanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 tanhl (long double x)
 {
+  __A_VARIABLE = 1;
   return tanh(x);
 }
 #endif
diff --git a/newlib/libm/common/tanl.c b/newlib/libm/common/tanl.c
index e444efe..01f70bb 100644
--- a/newlib/libm/common/tanl.c
+++ b/newlib/libm/common/tanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 tanl (long double x)
 {
+  __A_VARIABLE = 1;
   return tan(x);
 }
 #endif
diff --git a/newlib/libm/common/tgammal.c b/newlib/libm/common/tgammal.c
index 540316e..15e4e16 100644
--- a/newlib/libm/common/tgammal.c
+++ b/newlib/libm/common/tgammal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 tgammal (long double x)
 {
+  __A_VARIABLE = 1;
   return tgamma(x);
 }
 #endif
diff --git a/newlib/libm/common/truncl.c b/newlib/libm/common/truncl.c
index ba7a92d..4ed11af 100644
--- a/newlib/libm/common/truncl.c
+++ b/newlib/libm/common/truncl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 (C) Copyright IBM Corp. 2009
 
@@ -36,6 +37,7 @@ POSSIBILITY OF SUCH DAMAGE.
 long double
 truncl (long double x)
 {
+  __A_VARIABLE = 1;
   return trunc(x);
 }
 #endif
diff --git a/newlib/libm/complex/cabs.c b/newlib/libm/complex/cabs.c
index 69091d7..8cc92a7 100644
--- a/newlib/libm/complex/cabs.c
+++ b/newlib/libm/complex/cabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cabs.c,v 1.1 2007/08/20 16:01:30 drochner Exp $ */
 
 /*
@@ -55,5 +56,6 @@ double
 cabs(double complex z)
 {
 
+	__A_VARIABLE = 1;
 	return hypot( creal(z), cimag(z) );
 }
diff --git a/newlib/libm/complex/cabsf.c b/newlib/libm/complex/cabsf.c
index 635e23e..299934c 100644
--- a/newlib/libm/complex/cabsf.c
+++ b/newlib/libm/complex/cabsf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cabsf.c,v 1.1 2007/08/20 16:01:30 drochner Exp $ */
 
 /*
@@ -15,5 +16,6 @@ float
 cabsf(float complex z)
 {
 
+	__A_VARIABLE = 1;
 	return hypotf( crealf(z), cimagf(z) );
 }
diff --git a/newlib/libm/complex/cabsl.c b/newlib/libm/complex/cabsl.c
index 091f2cd..d28ceda 100644
--- a/newlib/libm/complex/cabsl.c
+++ b/newlib/libm/complex/cabsl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2015 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libm/complex/cacos.c b/newlib/libm/complex/cacos.c
index 86e1198..9c38dc7 100644
--- a/newlib/libm/complex/cacos.c
+++ b/newlib/libm/complex/cacos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacos.c,v 1.1 2007/08/20 16:01:30 drochner Exp $ */
 
 /*-
@@ -95,5 +96,6 @@ cacos(double complex z)
 	tmp1 = M_PI_2 - creal(tmp0);
 	w = tmp1 - (cimag(tmp0) * I);
 #endif
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cacosf.c b/newlib/libm/complex/cacosf.c
index 3874dd5..02bed0e 100644
--- a/newlib/libm/complex/cacosf.c
+++ b/newlib/libm/complex/cacosf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacosf.c,v 1.1 2007/08/20 16:01:30 drochner Exp $ */
 
 /*-
@@ -42,5 +43,6 @@ cacosf(float complex z)
 
 	w = casinf(z);
 	w = ((float)M_PI_2 - crealf(w)) - cimagf(w) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cacosh.c b/newlib/libm/complex/cacosh.c
index 3d42c40..eebe678 100644
--- a/newlib/libm/complex/cacosh.c
+++ b/newlib/libm/complex/cacosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacosh.c,v 1.2 2009/08/03 19:41:32 drochner Exp $ */
 
 /*-
@@ -89,5 +90,6 @@ cacosh(double complex z)
 #else
 	w = clog(z + csqrt(z + 1) * csqrt(z - 1));
 #endif
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cacoshf.c b/newlib/libm/complex/cacoshf.c
index 41a557a..5b9a1de 100644
--- a/newlib/libm/complex/cacoshf.c
+++ b/newlib/libm/complex/cacoshf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacoshf.c,v 1.2 2009/08/03 19:41:32 drochner Exp $ */
 
 /*-
@@ -44,5 +45,6 @@ cacoshf(float complex z)
 #else
 	w = clogf(z + csqrtf(z + 1) * csqrtf(z - 1));
 #endif
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cacoshl.c b/newlib/libm/complex/cacoshl.c
index 4e4e006..7d08e37 100644
--- a/newlib/libm/complex/cacoshl.c
+++ b/newlib/libm/complex/cacoshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacoshl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -41,5 +42,6 @@ cacoshl(long double complex z)
 #else
 	w = clogl(z + csqrtl(z + 1) * csqrtl(z - 1));
 #endif
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cacosl.c b/newlib/libm/complex/cacosl.c
index 6a05c8c..395a456 100644
--- a/newlib/libm/complex/cacosl.c
+++ b/newlib/libm/complex/cacosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cacosl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -40,6 +41,7 @@ cacosl(long double complex z)
 
 	w = casinl(z);
 	w = (M_PI_2L - creall(w)) - cimagl(w) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
 
diff --git a/newlib/libm/complex/carg.c b/newlib/libm/complex/carg.c
index 0447420..0c2129a 100644
--- a/newlib/libm/complex/carg.c
+++ b/newlib/libm/complex/carg.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: carg.c,v 1.1 2007/08/20 16:01:31 drochner Exp $ */
 
 /*
@@ -55,5 +56,6 @@ double
 carg(double complex z)
 {
 
+	__A_VARIABLE = 1;
 	return atan2( cimag(z) , creal(z) );
 }
diff --git a/newlib/libm/complex/cargf.c b/newlib/libm/complex/cargf.c
index 1683d21..b7abfc3 100644
--- a/newlib/libm/complex/cargf.c
+++ b/newlib/libm/complex/cargf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cargf.c,v 1.1 2007/08/20 16:01:31 drochner Exp $ */
 
 /*
@@ -15,5 +16,6 @@ float
 cargf(float complex z)
 {
 
+	__A_VARIABLE = 1;
 	return atan2f( cimagf(z), crealf(z) );
 }
diff --git a/newlib/libm/complex/cargl.c b/newlib/libm/complex/cargl.c
index 790cffe..bee69e2 100644
--- a/newlib/libm/complex/cargl.c
+++ b/newlib/libm/complex/cargl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cargl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*
diff --git a/newlib/libm/complex/casin.c b/newlib/libm/complex/casin.c
index 5019fd8..1a554ff 100644
--- a/newlib/libm/complex/casin.c
+++ b/newlib/libm/complex/casin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casin.c,v 1.1 2007/08/20 16:01:31 drochner Exp $ */
 
 /*-
@@ -161,5 +162,6 @@ return;
 	zz = clog(zz);
 	/* multiply by 1/i = -i */
 	w = zz * (-1.0 * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/casinf.c b/newlib/libm/complex/casinf.c
index 9a9f759..1a9c486 100644
--- a/newlib/libm/complex/casinf.c
+++ b/newlib/libm/complex/casinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casinf.c,v 1.1 2007/08/20 16:01:31 drochner Exp $ */
 
 /*-
@@ -118,5 +119,6 @@ return;
 	zz = clogf(zz);
 	/* multiply by 1/i = -i */
 	w = zz * (-1.0f * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/casinh.c b/newlib/libm/complex/casinh.c
index 16238a6..e3cc137 100644
--- a/newlib/libm/complex/casinh.c
+++ b/newlib/libm/complex/casinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casinh.c,v 1.1 2007/08/20 16:01:31 drochner Exp $ */
 
 /*-
@@ -93,5 +94,6 @@ casinh(double complex z)
 	double complex w;
 
 	w = -1.0 * I * casin(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/casinhf.c b/newlib/libm/complex/casinhf.c
index 0db55a0..dd2f1ed 100644
--- a/newlib/libm/complex/casinhf.c
+++ b/newlib/libm/complex/casinhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casinhf.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -40,5 +41,6 @@ casinhf(float complex z)
 	float complex w;
 
 	w = -1.0f * I * casinf(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/casinhl.c b/newlib/libm/complex/casinhl.c
index 2864791..6ee0ef4 100644
--- a/newlib/libm/complex/casinhl.c
+++ b/newlib/libm/complex/casinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casinhl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -37,5 +38,6 @@ casinhl(long double complex z)
 	long double complex w;
 
 	w = -1.0L * I * casinl(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/casinl.c b/newlib/libm/complex/casinl.c
index 4884889..8319d22 100644
--- a/newlib/libm/complex/casinl.c
+++ b/newlib/libm/complex/casinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: casinl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -115,6 +116,7 @@ return;
 	zz = clogl(zz);
 	/* multiply by 1/i = -i */
 	w = zz * (-1.0L * I);
+	__A_VARIABLE = 1;
 	return w;
 }
 
diff --git a/newlib/libm/complex/catan.c b/newlib/libm/complex/catan.c
index bf9ea01..24eefea 100644
--- a/newlib/libm/complex/catan.c
+++ b/newlib/libm/complex/catan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catan.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -119,6 +120,7 @@ catan(double complex z)
 	t = y + 1.0;
 	a = (x2 + (t * t))/a;
 	w = w + (0.25 * log(a)) * I;
+	__A_VARIABLE = 1;
 	return w;
 
 ovrf:
@@ -126,5 +128,6 @@ ovrf:
 	mtherr ("catan", OVERFLOW);
 #endif
 	w = HUGE_VAL + HUGE_VAL * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/catanf.c b/newlib/libm/complex/catanf.c
index ac1a65c..1d88d9c 100644
--- a/newlib/libm/complex/catanf.c
+++ b/newlib/libm/complex/catanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catanf.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -68,6 +69,7 @@ catanf(float complex z)
 	t = y + 1.0f;
 	a = (x2 + (t * t))/a;
 	w = w + (0.25f * logf(a)) * I;
+	__A_VARIABLE = 1;
 	return w;
 
 ovrf:
@@ -75,5 +77,6 @@ ovrf:
 	mtherr ("catan", OVERFLOW);
 #endif
 	w = HUGE_VALF + HUGE_VALF * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/catanh.c b/newlib/libm/complex/catanh.c
index 2b9ef9e..80ab0f6 100644
--- a/newlib/libm/complex/catanh.c
+++ b/newlib/libm/complex/catanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catanh.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -86,5 +87,6 @@ catanh(double complex z)
 	double complex w;
 
 	w = -1.0 * I * catan(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/catanhf.c b/newlib/libm/complex/catanhf.c
index fe6127a..66e696b 100644
--- a/newlib/libm/complex/catanhf.c
+++ b/newlib/libm/complex/catanhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catanhf.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -40,5 +41,6 @@ catanhf(float complex z)
 	float complex w;
 
 	w = -1.0f * I * catanf(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/catanhl.c b/newlib/libm/complex/catanhl.c
index 8975fe8..5acf202 100644
--- a/newlib/libm/complex/catanhl.c
+++ b/newlib/libm/complex/catanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catanhl.c,v 1.3 2014/10/10 12:43:15 christos Exp $ */
 
 /*-
@@ -37,5 +38,6 @@ catanhl(long double complex z)
 	long double complex w;
 
 	w = -1.0L * I * catanl(z * I);
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/catanl.c b/newlib/libm/complex/catanl.c
index ee2a259..39485d4 100644
--- a/newlib/libm/complex/catanl.c
+++ b/newlib/libm/complex/catanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: catanl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -65,6 +66,7 @@ catanl(long double complex z)
 	t = y + 1.0L;
 	a = (x2 + (t * t))/a;
 	w = w + (0.25L * logl(a)) * I;
+	__A_VARIABLE = 1;
 	return w;
 
 ovrf:
@@ -72,6 +74,7 @@ ovrf:
 	mtherr ("catanl", OVERFLOW);
 #endif
 	w = HUGE_VALL + HUGE_VALL * I;
+	__A_VARIABLE = 1;
 	return w;
 }
 
diff --git a/newlib/libm/complex/ccos.c b/newlib/libm/complex/ccos.c
index 1062c07..075cffa 100644
--- a/newlib/libm/complex/ccos.c
+++ b/newlib/libm/complex/ccos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccos.c,v 1.1 2007/08/20 16:01:32 drochner Exp $ */
 
 /*-
@@ -77,5 +78,6 @@ ccos(double complex z)
 
 	_cchsh(cimag(z), &ch, &sh);
 	w = cos(creal(z)) * ch - (sin(creal(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ccosf.c b/newlib/libm/complex/ccosf.c
index 805e24f..5d679e9 100644
--- a/newlib/libm/complex/ccosf.c
+++ b/newlib/libm/complex/ccosf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccosf.c,v 1.1 2007/08/20 16:01:33 drochner Exp $ */
 
 /*-
@@ -44,5 +45,6 @@ ccosf(float complex z)
 
 	_cchshf(cimagf(z), &ch, &sh);
 	w = cosf(crealf(z)) * ch - (sinf(crealf(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ccosh.c b/newlib/libm/complex/ccosh.c
index 223a5ed..f9e5730 100644
--- a/newlib/libm/complex/ccosh.c
+++ b/newlib/libm/complex/ccosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccosh.c,v 1.1 2007/08/20 16:01:33 drochner Exp $ */
 
 /*-
@@ -77,5 +78,6 @@ ccosh(double complex z)
 	x = creal(z);
 	y = cimag(z);
 	w = cosh(x) * cos(y) + (sinh(x) * sin(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ccoshf.c b/newlib/libm/complex/ccoshf.c
index af11353..e159fd9 100644
--- a/newlib/libm/complex/ccoshf.c
+++ b/newlib/libm/complex/ccoshf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccoshf.c,v 1.1 2007/08/20 16:01:33 drochner Exp $ */
 
 /*-
@@ -44,5 +45,6 @@ ccoshf(float complex z)
 	x = crealf(z);
 	y = cimagf(z);
 	w = coshf(x) * cosf(y) + (sinhf(x) * sinf(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ccoshl.c b/newlib/libm/complex/ccoshl.c
index f59fadf..0b533a1 100644
--- a/newlib/libm/complex/ccoshl.c
+++ b/newlib/libm/complex/ccoshl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccoshl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -41,5 +42,6 @@ ccoshl(long double complex z)
 	x = creall(z);
 	y = cimagl(z);
 	w = coshl(x) * cosl(y) + (sinhl(x) * sinl(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ccosl.c b/newlib/libm/complex/ccosl.c
index c310f40..9073f30 100644
--- a/newlib/libm/complex/ccosl.c
+++ b/newlib/libm/complex/ccosl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ccosl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -41,5 +42,6 @@ ccosl(long double complex z)
 
 	_cchshl(cimagl(z), &ch, &sh);
 	w = cosl(creall(z)) * ch - (sinl(creall(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cephes_subr.c b/newlib/libm/complex/cephes_subr.c
index 5eacff6..09cb743 100644
--- a/newlib/libm/complex/cephes_subr.c
+++ b/newlib/libm/complex/cephes_subr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cephes_subr.c,v 1.1 2007/08/20 16:01:33 drochner Exp $ */
 
 /*-
@@ -53,6 +54,7 @@ _cchsh(double x, double *c, double *s)
 		*s = e - ei;
 		*c = e + ei;
 	}
+	__A_VARIABLE = 1;
 }
 
 /* Program to subtract nearest integer multiple of PI */
@@ -78,6 +80,7 @@ _redupi(double x)
 	i = t;	/* the multiple */
 	t = i;
 	t = ((x - t * DP1) - t * DP2) - t * DP3;
+	__A_VARIABLE = 1;
 	return t;
 }
 
@@ -122,5 +125,6 @@ _ctans(double complex z)
 		t /= f;
 		d += t;
 	} while (fabs(t/d) > MACHEP);
+	__A_VARIABLE = 1;
 	return d;
 }
diff --git a/newlib/libm/complex/cephes_subrf.c b/newlib/libm/complex/cephes_subrf.c
index 4a32581..bba2a9f 100644
--- a/newlib/libm/complex/cephes_subrf.c
+++ b/newlib/libm/complex/cephes_subrf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cephes_subrf.c,v 1.1 2007/08/20 16:01:34 drochner Exp $ */
 
 /*-
@@ -53,6 +54,7 @@ _cchshf(float x, float *c, float *s)
 		*s = e - ei;
 		*c = e + ei;
 	}
+	__A_VARIABLE = 1;
 }
 
 /* Program to subtract nearest integer multiple of PI */
@@ -78,6 +80,7 @@ _redupif(float x)
 	i = t;	/* the multiple */
 	t = i;
 	t = ((x - t * DP1) - t * DP2) - t * DP3;
+	__A_VARIABLE = 1;
 	return t;
 }
 
@@ -121,5 +124,6 @@ _ctansf(float complex z)
 		t /= f;
 		d += t;
 	} while (fabsf(t/d) > MACHEPF);
+	__A_VARIABLE = 1;
 	return d;
 }
diff --git a/newlib/libm/complex/cephes_subrl.c b/newlib/libm/complex/cephes_subrl.c
index 8af11df..59774eb 100644
--- a/newlib/libm/complex/cephes_subrl.c
+++ b/newlib/libm/complex/cephes_subrl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cephes_subrl.c,v 1.2 2014/10/10 14:06:40 christos Exp $ */
 
 /*-
@@ -50,6 +51,7 @@ _cchshl(long double x, long double *c, long double *s)
 		*s = e - ei;
 		*c = e + ei;
 	}
+	__A_VARIABLE = 1;
 }
 
 /* Program to subtract nearest integer multiple of PI */
@@ -80,6 +82,7 @@ _redupil(long double x)
 	i = t;	/* the multiple */
 	t = i;
 	t = ((x - t * DP1) - t * DP2) - t * DP3;
+	__A_VARIABLE = 1;
 	return t;
 }
 
@@ -124,5 +127,6 @@ _ctansl(long double complex z)
 		t /= f;
 		d += t;
 	} while (fabsl(t/d) > MACHEPL);
+	__A_VARIABLE = 1;
 	return d;
 }
diff --git a/newlib/libm/complex/cexp.c b/newlib/libm/complex/cexp.c
index b9a3fd0..445ac1b 100644
--- a/newlib/libm/complex/cexp.c
+++ b/newlib/libm/complex/cexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cexp.c,v 1.1 2007/08/20 16:01:34 drochner Exp $ */
 
 /*-
@@ -78,5 +79,6 @@ cexp(double complex z)
 	y = cimag(z);
 	r = exp(x);
 	w = r * cos(y) + r * sin(y) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cexpf.c b/newlib/libm/complex/cexpf.c
index 07fab1f..46e357f 100644
--- a/newlib/libm/complex/cexpf.c
+++ b/newlib/libm/complex/cexpf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cexpf.c,v 1.1 2007/08/20 16:01:34 drochner Exp $ */
 
 /*-
@@ -45,5 +46,6 @@ cexpf(float complex z)
 	y = cimagf(z);
 	r = expf(x);
 	w = r * cosf(y) + r * sinf(y) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cexpl.c b/newlib/libm/complex/cexpl.c
index 8b56634..20d4a57 100644
--- a/newlib/libm/complex/cexpl.c
+++ b/newlib/libm/complex/cexpl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cexpl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -42,5 +43,6 @@ cexpl(long double complex z)
 	y = cimagl(z);
 	r = expl(x);
 	w = r * cosl(y) + r * sinl(y) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cimag.c b/newlib/libm/complex/cimag.c
index 959dbc9..d082de8 100644
--- a/newlib/libm/complex/cimag.c
+++ b/newlib/libm/complex/cimag.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cimag.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -55,5 +56,6 @@ cimag(double complex z)
 {
 	double_complex w = { .z = z };
 
+	__A_VARIABLE = 1;
 	return (IMAG_PART(w));
 }
diff --git a/newlib/libm/complex/cimagf.c b/newlib/libm/complex/cimagf.c
index 20077ee..6509a86 100644
--- a/newlib/libm/complex/cimagf.c
+++ b/newlib/libm/complex/cimagf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cimagf.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -16,5 +17,6 @@ cimagf(float complex z)
 {
 	float_complex w = { .z = z };
 
+	__A_VARIABLE = 1;
 	return (IMAG_PART(w));
 }
diff --git a/newlib/libm/complex/cimagl.c b/newlib/libm/complex/cimagl.c
index a5afdc4..678e779 100644
--- a/newlib/libm/complex/cimagl.c
+++ b/newlib/libm/complex/cimagl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2015 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -12,5 +13,6 @@ cimagl (long double complex z)
 {
   long_double_complex w = { .z = z };
 
+  __A_VARIABLE = 1;
   return IMAG_PART (w);
 }
diff --git a/newlib/libm/complex/clog.c b/newlib/libm/complex/clog.c
index f7ad3d2..ebd1300 100644
--- a/newlib/libm/complex/clog.c
+++ b/newlib/libm/complex/clog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: clog.c,v 1.1 2007/08/20 16:01:35 drochner Exp $ */
 
 /*-
@@ -87,5 +88,6 @@ clog(double complex z)
 	p = log(rr);
 	rr = atan2(cimag(z), creal(z));
 	w = p + rr * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/clog10.c b/newlib/libm/complex/clog10.c
index c857a65..c5c9580 100644
--- a/newlib/libm/complex/clog10.c
+++ b/newlib/libm/complex/clog10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 FUNCTION
         <<clog10>>, <<clog10f>>---complex base-10 logarithm
@@ -42,5 +43,6 @@ clog10(double complex z)
 	p = log10(rr);
 	rr = atan2(cimag(z), creal(z)) * M_IVLN10;
 	w = p + rr * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/clog10f.c b/newlib/libm/complex/clog10f.c
index 1242732..8488e33 100644
--- a/newlib/libm/complex/clog10f.c
+++ b/newlib/libm/complex/clog10f.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <complex.h>
 #include <math.h>
 
@@ -11,5 +12,6 @@ clog10f(float complex z)
 	p = log10f(rr);
 	rr = atan2f(cimagf(z), crealf(z)) * (float) M_IVLN10;
 	w = p + rr * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/clogf.c b/newlib/libm/complex/clogf.c
index 078cea5..928b92b 100644
--- a/newlib/libm/complex/clogf.c
+++ b/newlib/libm/complex/clogf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: clogf.c,v 1.1 2007/08/20 16:01:35 drochner Exp $ */
 
 /*-
@@ -45,5 +46,6 @@ clogf(float complex z)
 	p = logf(rr);
 	rr = atan2f(cimagf(z), crealf(z));
 	w = p + rr * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/clogl.c b/newlib/libm/complex/clogl.c
index 3644a44..96986db 100644
--- a/newlib/libm/complex/clogl.c
+++ b/newlib/libm/complex/clogl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: clogl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -42,5 +43,6 @@ clogl(long double complex z)
 	p = logl(rr);
 	rr = atan2l(cimagl(z), creall(z));
 	w = p + rr * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/conj.c b/newlib/libm/complex/conj.c
index dc50f08..322342d 100644
--- a/newlib/libm/complex/conj.c
+++ b/newlib/libm/complex/conj.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: conj.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -51,5 +52,6 @@ conj(double complex z)
 
 	IMAG_PART(w) = -IMAG_PART(w);
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/conjf.c b/newlib/libm/complex/conjf.c
index f6a9522..631c3db 100644
--- a/newlib/libm/complex/conjf.c
+++ b/newlib/libm/complex/conjf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: conjf.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -18,5 +19,6 @@ conjf(float complex z)
 
 	IMAG_PART(w) = -IMAG_PART(w);
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/conjl.c b/newlib/libm/complex/conjl.c
index 35094ce..cf17ba7 100644
--- a/newlib/libm/complex/conjl.c
+++ b/newlib/libm/complex/conjl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: conjl.c,v 1.4 2010/09/20 16:55:20 christos Exp $	*/
 
 /*-
@@ -42,5 +43,6 @@ conjl(long double complex z)
 
 	IMAG_PART(w) = -IMAG_PART(w);
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/cpow.c b/newlib/libm/complex/cpow.c
index b60f7be..42c4b61 100644
--- a/newlib/libm/complex/cpow.c
+++ b/newlib/libm/complex/cpow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cpow.c,v 1.1 2007/08/20 16:01:35 drochner Exp $ */
 
 /*-
@@ -87,6 +88,7 @@ cpow(double complex a, double complex z)
 	y = cimag(z);
 	absa = cabs(a);
 	if (absa == 0.0) {
+		__A_VARIABLE = 1;
 		return (0.0 + 0.0 * I);
 	}
 	arga = carg(a);
@@ -97,5 +99,6 @@ cpow(double complex a, double complex z)
 		theta = theta + y * log(absa);
 	}
 	w = r * cos(theta) + (r * sin(theta)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cpowf.c b/newlib/libm/complex/cpowf.c
index 1e736af..f562426 100644
--- a/newlib/libm/complex/cpowf.c
+++ b/newlib/libm/complex/cpowf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cpowf.c,v 1.1 2007/08/20 16:01:36 drochner Exp $ */
 
 /*-
@@ -45,6 +46,7 @@ cpowf(float complex a, float complex z)
 	y = cimagf(z);
 	absa = cabsf(a);
 	if (absa == 0.0f) {
+		__A_VARIABLE = 1;
 		return (0.0f + 0.0f * I);
 	}
 	arga = cargf(a);
@@ -55,5 +57,6 @@ cpowf(float complex a, float complex z)
 		theta = theta + y * logf(absa);
 	}
 	w = r * cosf(theta) + (r * sinf(theta)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cpowl.c b/newlib/libm/complex/cpowl.c
index 85c2c20..e5db3ad 100644
--- a/newlib/libm/complex/cpowl.c
+++ b/newlib/libm/complex/cpowl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: cpowl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -42,6 +43,7 @@ cpowl(long double complex a, long double complex z)
 	y = cimagl(z);
 	absa = cabsl(a);
 	if (absa == 0.0L) {
+		__A_VARIABLE = 1;
 		return (0.0L + 0.0L * I);
 	}
 	arga = cargl(a);
@@ -52,5 +54,6 @@ cpowl(long double complex a, long double complex z)
 		theta = theta + y * logl(absa);
 	}
 	w = r * cosl(theta) + (r * sinl(theta)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/cproj.c b/newlib/libm/complex/cproj.c
index 32a757f..290c179 100644
--- a/newlib/libm/complex/cproj.c
+++ b/newlib/libm/complex/cproj.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: cproj.c,v 1.3 2010/09/20 17:51:38 christos Exp $	*/
 
 /*-
@@ -102,5 +103,6 @@ cproj(double complex z)
 		IMAG_PART(w) = copysign(0.0, cimag(z));
 	}
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/cprojf.c b/newlib/libm/complex/cprojf.c
index 1310170..e239835 100644
--- a/newlib/libm/complex/cprojf.c
+++ b/newlib/libm/complex/cprojf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: cprojf.c,v 1.3 2010/09/20 17:51:38 christos Exp $	*/
 
 /*-
@@ -64,5 +65,6 @@ cprojf(float complex z)
 		IMAG_PART(w) = copysignf(0.0, cimagf(z));
 	}
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/cprojl.c b/newlib/libm/complex/cprojl.c
index e71c773..542c376 100644
--- a/newlib/libm/complex/cprojl.c
+++ b/newlib/libm/complex/cprojl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: cprojl.c,v 1.7 2014/10/10 00:48:18 christos Exp $	*/
 
 /*-
@@ -60,5 +61,6 @@ cprojl(long double complex z)
 		IMAG_PART(w) = copysignl(0.0L, cimagl(z));
 	}
 
+	__A_VARIABLE = 1;
 	return (w.z);
 }
diff --git a/newlib/libm/complex/creal.c b/newlib/libm/complex/creal.c
index 1652a5f..b63420b 100644
--- a/newlib/libm/complex/creal.c
+++ b/newlib/libm/complex/creal.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: creal.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -55,5 +56,6 @@ creal(double complex z)
 {
 	double_complex w = { .z = z };
 
+	__A_VARIABLE = 1;
 	return (REAL_PART(w));
 }
diff --git a/newlib/libm/complex/crealf.c b/newlib/libm/complex/crealf.c
index b5bf31c..2dada37 100644
--- a/newlib/libm/complex/crealf.c
+++ b/newlib/libm/complex/crealf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: crealf.c,v 1.2 2010/09/15 16:11:29 christos Exp $ */
 
 /*
@@ -16,5 +17,6 @@ crealf(float complex z)
 {
 	float_complex w = { .z = z };
 
+	__A_VARIABLE = 1;
 	return (REAL_PART(w));
 }
diff --git a/newlib/libm/complex/creall.c b/newlib/libm/complex/creall.c
index 7aa88c2..efc1797 100644
--- a/newlib/libm/complex/creall.c
+++ b/newlib/libm/complex/creall.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2015 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -12,5 +13,6 @@ creall (long double complex z)
 {
   long_double_complex w = { .z = z };
 
+  __A_VARIABLE = 1;
   return (REAL_PART(w));
 }
diff --git a/newlib/libm/complex/csin.c b/newlib/libm/complex/csin.c
index cf6dae0..1e1696f 100644
--- a/newlib/libm/complex/csin.c
+++ b/newlib/libm/complex/csin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csin.c,v 1.1 2007/08/20 16:01:36 drochner Exp $ */
 
 /*-
@@ -77,5 +78,6 @@ csin(double complex z)
 
 	_cchsh(cimag(z), &ch, &sh);
 	w = sin(creal(z)) * ch + (cos(creal(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csinf.c b/newlib/libm/complex/csinf.c
index 68cefe4..861f0b3 100644
--- a/newlib/libm/complex/csinf.c
+++ b/newlib/libm/complex/csinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csinf.c,v 1.1 2007/08/20 16:01:36 drochner Exp $ */
 
 /*-
@@ -44,5 +45,6 @@ csinf(float complex z)
 
 	_cchshf(cimagf(z), &ch, &sh);
 	w = sinf(crealf(z)) * ch + (cosf(crealf(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csinh.c b/newlib/libm/complex/csinh.c
index f117162..83f7e96 100644
--- a/newlib/libm/complex/csinh.c
+++ b/newlib/libm/complex/csinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csinh.c,v 1.1 2007/08/20 16:01:36 drochner Exp $ */
 
 /*-
@@ -76,5 +77,6 @@ csinh(double complex z)
 	x = creal(z);
 	y = cimag(z);
 	w = sinh(x) * cos(y) + (cosh(x) * sin(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csinhf.c b/newlib/libm/complex/csinhf.c
index 3cd6ba7..4fd6a84 100644
--- a/newlib/libm/complex/csinhf.c
+++ b/newlib/libm/complex/csinhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csinhf.c,v 1.1 2007/08/20 16:01:37 drochner Exp $ */
 
 /*-
@@ -44,5 +45,6 @@ csinhf(float complex z)
 	x = crealf(z);
 	y = cimagf(z);
 	w = sinhf(x) * cosf(y) + (coshf(x) * sinf(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csinhl.c b/newlib/libm/complex/csinhl.c
index 44ed050..59ab196 100644
--- a/newlib/libm/complex/csinhl.c
+++ b/newlib/libm/complex/csinhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csinhl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -41,5 +42,6 @@ csinhl(long double complex z)
 	x = creall(z);
 	y = cimagl(z);
 	w = sinhl(x) * cosl(y) + (coshl(x) * sinl(y)) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csinl.c b/newlib/libm/complex/csinl.c
index 2b96c72..15c99c9 100644
--- a/newlib/libm/complex/csinl.c
+++ b/newlib/libm/complex/csinl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csinl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -41,5 +42,6 @@ csinl(long double complex z)
 
 	_cchshl(cimagl(z), &ch, &sh);
 	w = sinl(creall(z)) * ch + (cosl(creall(z)) * sh) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csqrt.c b/newlib/libm/complex/csqrt.c
index b144b7c..a23eba9 100644
--- a/newlib/libm/complex/csqrt.c
+++ b/newlib/libm/complex/csqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csqrt.c,v 1.1 2007/08/20 16:01:37 drochner Exp $ */
 
 /*-
@@ -91,6 +92,7 @@ csqrt(double complex z)
 				w = r + y * I;
 			}
 		}
+		__A_VARIABLE = 1;
 		return w;
 	}
 	if (x == 0.0) {
@@ -100,6 +102,7 @@ csqrt(double complex z)
 			w = r + r * I;
 		else
 			w = r - r * I;
+		__A_VARIABLE = 1;
 		return w;
 	}
 	/* Rescale to avoid internal overflow or underflow.  */
@@ -133,5 +136,6 @@ csqrt(double complex z)
 		w = t - r * I;
 	else
 		w = t + r * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/csqrtf.c b/newlib/libm/complex/csqrtf.c
index 13451fa..561af36 100644
--- a/newlib/libm/complex/csqrtf.c
+++ b/newlib/libm/complex/csqrtf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: csqrtf.c,v 1.1 2007/08/20 16:01:37 drochner Exp $ */
 
 /*-
diff --git a/newlib/libm/complex/csqrtl.c b/newlib/libm/complex/csqrtl.c
index c10a126..b835b3d 100644
--- a/newlib/libm/complex/csqrtl.c
+++ b/newlib/libm/complex/csqrtl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2007-2008 David Schultz <das@FreeBSD.ORG>
  * All rights reserved.
diff --git a/newlib/libm/complex/ctan.c b/newlib/libm/complex/ctan.c
index fb0db34..e26db21 100644
--- a/newlib/libm/complex/ctan.c
+++ b/newlib/libm/complex/ctan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctan.c,v 1.1 2007/08/20 16:01:37 drochner Exp $ */
 
 /*-
@@ -83,9 +84,11 @@ ctan(double complex z)
 	if (d == 0.0) {
 		/* mtherr ("ctan", OVERFLOW); */
 		w = HUGE_VAL + HUGE_VAL * I;
+		__A_VARIABLE = 1;
 		return w;
 	}
 
 	w = sin(2.0 * creal(z)) / d + (sinh(2.0 * cimag(z)) / d) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ctanf.c b/newlib/libm/complex/ctanf.c
index a75ff1c..08e3442 100644
--- a/newlib/libm/complex/ctanf.c
+++ b/newlib/libm/complex/ctanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctanf.c,v 1.1 2007/08/20 16:01:38 drochner Exp $ */
 
 /*-
@@ -50,9 +51,11 @@ ctanf(float complex z)
 	if (d == 0.0f) {
 		/* mtherr ("ctan", OVERFLOW); */
 		w = HUGE_VALF + HUGE_VALF * I;
+		__A_VARIABLE = 1;
 		return w;
 	}
 
 	w = sinf(2.0f * crealf(z)) / d + (sinhf(2.0f * cimagf(z)) / d) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ctanh.c b/newlib/libm/complex/ctanh.c
index db27e5b..4fb8768 100644
--- a/newlib/libm/complex/ctanh.c
+++ b/newlib/libm/complex/ctanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctanh.c,v 1.1 2007/08/20 16:01:38 drochner Exp $ */
 
 /*-
@@ -79,5 +80,6 @@ ctanh(double complex z)
 	d = cosh(2.0 * x) + cos(2.0 * y);
 	w = sinh(2.0 * x) / d  +  (sin(2.0 * y) / d) * I;
 
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ctanhf.c b/newlib/libm/complex/ctanhf.c
index 6aaf20f..5dd6dfd 100644
--- a/newlib/libm/complex/ctanhf.c
+++ b/newlib/libm/complex/ctanhf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctanhf.c,v 1.1 2007/08/20 16:01:38 drochner Exp $ */
 
 /*-
@@ -46,5 +47,6 @@ ctanhf(float complex z)
 	d = coshf(2.0f * x) + cosf(2.0f * y);
 	w = sinhf(2.0f * x) / d  +  (sinf(2.0f * y) / d) * I;
 
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ctanhl.c b/newlib/libm/complex/ctanhl.c
index 1db886f..58f37f7 100644
--- a/newlib/libm/complex/ctanhl.c
+++ b/newlib/libm/complex/ctanhl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctanhl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -43,5 +44,6 @@ ctanhl(long double complex z)
 	d = coshl(2.0L * x) + cosl(2.0L * y);
 	w = sinhl(2.0L * x) / d  +  (sinl(2.0L * y) / d) * I;
 
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/complex/ctanl.c b/newlib/libm/complex/ctanl.c
index c5c887c..d41e266 100644
--- a/newlib/libm/complex/ctanl.c
+++ b/newlib/libm/complex/ctanl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* $NetBSD: ctanl.c,v 1.1 2014/10/10 00:48:18 christos Exp $ */
 
 /*-
@@ -48,9 +49,11 @@ ctanl(long double complex z)
 	if (d == 0.0L) {
 		/* mtherr ("ctan", OVERFLOW); */
 		w = HUGE_VALL + HUGE_VALL * I;
+		__A_VARIABLE = 1;
 		return w;
 	}
 
 	w = sinl(2.0L * creall(z)) / d + (sinhl(2.0L * cimagl(z)) / d) * I;
+	__A_VARIABLE = 1;
 	return w;
 }
diff --git a/newlib/libm/machine/aarch64/e_sqrt.c b/newlib/libm/machine/aarch64/e_sqrt.c
index e4b7554..b5f72de 100644
--- a/newlib/libm/machine/aarch64/e_sqrt.c
+++ b/newlib/libm/machine/aarch64/e_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* e_sqrt.c -- define __ieee754_sqrt
    Copyright (c) 2015 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ __ieee754_sqrt (double x)
 {
   double result;
   asm ("fsqrt\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/ef_sqrt.c b/newlib/libm/machine/aarch64/ef_sqrt.c
index 19fec95..2cb6e49 100644
--- a/newlib/libm/machine/aarch64/ef_sqrt.c
+++ b/newlib/libm/machine/aarch64/ef_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_sqrt.c -- define __ieee754_sqrtf
    Copyright (c) 2015 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ __ieee754_sqrtf (float x)
 {
   float result;
   asm ("fsqrt\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_ceil.c b/newlib/libm/machine/aarch64/s_ceil.c
index 747c6be..07f70a9 100644
--- a/newlib/libm/machine/aarch64/s_ceil.c
+++ b/newlib/libm/machine/aarch64/s_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_ceil.c -- define ceil
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ ceil (double x)
 {
   double result;
   asm ( "frintp\t%d0, %d1" : "=w" (result) : "w" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_fabs.c b/newlib/libm/machine/aarch64/s_fabs.c
index 60e95ce..3d14a7e 100644
--- a/newlib/libm/machine/aarch64/s_fabs.c
+++ b/newlib/libm/machine/aarch64/s_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_fabs.c -- define fabs
    Copyright (c) 2015 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fabs (double x)
 {
   double result;
   asm ("fabs\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_floor.c b/newlib/libm/machine/aarch64/s_floor.c
index 0663406..9f159f3 100644
--- a/newlib/libm/machine/aarch64/s_floor.c
+++ b/newlib/libm/machine/aarch64/s_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_floor.c -- define floor
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ floor (double x)
 {
   double result;
   asm ("frintm\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_fma.c b/newlib/libm/machine/aarch64/s_fma.c
index d457ad2..352ce11 100644
--- a/newlib/libm/machine/aarch64/s_fma.c
+++ b/newlib/libm/machine/aarch64/s_fma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_fma.c -- define fma
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fma (double x, double y, double z)
 {
   double result;
   asm ("fmadd\t%d0, %d1, %d2, %d3" : "=w" (result) : "w" (x), "w" (y), "w" (z));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_fmax.c b/newlib/libm/machine/aarch64/s_fmax.c
index 8616a4e..04c4bd7 100644
--- a/newlib/libm/machine/aarch64/s_fmax.c
+++ b/newlib/libm/machine/aarch64/s_fmax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_fmax.c -- define fmax
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fmax (double x, double y)
 {
   double result;
   asm ("fmaxnm\t%d0, %d1, %d2" : "=w" (result) : "w" (x), "w" (y));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_fmin.c b/newlib/libm/machine/aarch64/s_fmin.c
index 367a1e1..4d8ca21 100644
--- a/newlib/libm/machine/aarch64/s_fmin.c
+++ b/newlib/libm/machine/aarch64/s_fmin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_fmin.c -- define fmin
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fmin (double x, double y)
 {
   double result;
   asm ("fminnm\t%d0, %d1, %d2" : "=w" (result) : "w" (x), "w" (y));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_llrint.c b/newlib/libm/machine/aarch64/s_llrint.c
index fd28b0e..08f82b3 100644
--- a/newlib/libm/machine/aarch64/s_llrint.c
+++ b/newlib/libm/machine/aarch64/s_llrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_llrint.c -- define llrint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -34,5 +35,6 @@ llrint (double x)
   asm ("frintx\t%d1, %d2\n\t"
        "fcvtzs\t%x0, %d1"
        : "=r" (result), "=w" (temp) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_llround.c b/newlib/libm/machine/aarch64/s_llround.c
index 231c7e7..498e660 100644
--- a/newlib/libm/machine/aarch64/s_llround.c
+++ b/newlib/libm/machine/aarch64/s_llround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_llround.c -- define llround
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ llround (double x)
 {
   long long int result;
   asm ("fcvtas\t%x0, %d1" : "=r" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_lrint.c b/newlib/libm/machine/aarch64/s_lrint.c
index fda83b1..932980b 100644
--- a/newlib/libm/machine/aarch64/s_lrint.c
+++ b/newlib/libm/machine/aarch64/s_lrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_lrint.c -- define lrint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -34,5 +35,6 @@ lrint (double x)
   asm ("frintx\t%d1, %d2\n\t"
        "fcvtzs\t%x0, %d1"
        : "=r" (result), "=w" (temp) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_lround.c b/newlib/libm/machine/aarch64/s_lround.c
index 72a8f02..01a7b42 100644
--- a/newlib/libm/machine/aarch64/s_lround.c
+++ b/newlib/libm/machine/aarch64/s_lround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_lround.c -- define lround
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ lround (double x)
 {
   long int result;
   asm ("fcvtas\t%x0, %d1" : "=r" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_nearbyint.c b/newlib/libm/machine/aarch64/s_nearbyint.c
index b097554..6276faa 100644
--- a/newlib/libm/machine/aarch64/s_nearbyint.c
+++ b/newlib/libm/machine/aarch64/s_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_nearbyint.c -- define nearbyint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ nearbyint (double x)
 {
   double result;
   asm ("frinti\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_rint.c b/newlib/libm/machine/aarch64/s_rint.c
index 1e96afa..12d65b7 100644
--- a/newlib/libm/machine/aarch64/s_rint.c
+++ b/newlib/libm/machine/aarch64/s_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_rint.c -- define rint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ rint (double x)
 {
   double result;
   asm ("frintx\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_round.c b/newlib/libm/machine/aarch64/s_round.c
index f363a6f..133c6a4 100644
--- a/newlib/libm/machine/aarch64/s_round.c
+++ b/newlib/libm/machine/aarch64/s_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_round.c -- define round
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ round (double x)
 {
   double result;
   asm ("frinta\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/s_trunc.c b/newlib/libm/machine/aarch64/s_trunc.c
index 98dca6a..63814ab 100644
--- a/newlib/libm/machine/aarch64/s_trunc.c
+++ b/newlib/libm/machine/aarch64/s_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_trunc.c -- define trunc
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ trunc (double x)
 {
   double result;
   asm ("frintz\t%d0, %d1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_ceil.c b/newlib/libm/machine/aarch64/sf_ceil.c
index b9171ab..8f27b43 100644
--- a/newlib/libm/machine/aarch64/sf_ceil.c
+++ b/newlib/libm/machine/aarch64/sf_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_ceil.c -- define ceilf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ ceilf (float x)
 {
   float result;
   asm ( "frintp\t%s0, %s1" : "=w" (result) : "w" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_fabs.c b/newlib/libm/machine/aarch64/sf_fabs.c
index 2b92546..dc05e75 100644
--- a/newlib/libm/machine/aarch64/sf_fabs.c
+++ b/newlib/libm/machine/aarch64/sf_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_fabs.c -- define fabsf
    Copyright (c) 2015 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fabsf (float x)
 {
   float result;
   asm ("fabs\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_floor.c b/newlib/libm/machine/aarch64/sf_floor.c
index a63377d..813eacd 100644
--- a/newlib/libm/machine/aarch64/sf_floor.c
+++ b/newlib/libm/machine/aarch64/sf_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_floor.c -- define floorf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ floorf (float x)
 {
   float result;
   asm ( "frintm\t%s0, %s1" : "=w" (result) : "w" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_fma.c b/newlib/libm/machine/aarch64/sf_fma.c
index 9d4f79f..0287dc9 100644
--- a/newlib/libm/machine/aarch64/sf_fma.c
+++ b/newlib/libm/machine/aarch64/sf_fma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_fma.c -- define fmaf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fmaf (float x, float y, float z)
 {
   float result;
   asm ("fmadd\t%s0, %s1, %s2, %s3" : "=w" (result) : "w" (x), "w" (y), "w" (z));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_fmax.c b/newlib/libm/machine/aarch64/sf_fmax.c
index 3800d2b..fbba69b 100644
--- a/newlib/libm/machine/aarch64/sf_fmax.c
+++ b/newlib/libm/machine/aarch64/sf_fmax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_fmax.c -- define fmaxf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fmaxf (float x, float y)
 {
   float result;
   asm ("fmaxnm\t%s0, %s1, %s2" : "=w" (result) : "w" (x), "w" (y));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_fmin.c b/newlib/libm/machine/aarch64/sf_fmin.c
index aa4ca28..be89ee2 100644
--- a/newlib/libm/machine/aarch64/sf_fmin.c
+++ b/newlib/libm/machine/aarch64/sf_fmin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_fmin.c -- define fminf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ fminf (float x, float y)
 {
   float result;
   asm ("fminnm\t%s0, %s1, %s2" : "=w" (result) : "w" (x), "w" (y));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_llrint.c b/newlib/libm/machine/aarch64/sf_llrint.c
index 2262088..08a748f 100644
--- a/newlib/libm/machine/aarch64/sf_llrint.c
+++ b/newlib/libm/machine/aarch64/sf_llrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_llrint.c -- define llrintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -34,5 +35,6 @@ llrintf (float x)
   asm ("frintx\t%s1, %s2\n\t"
        "fcvtzs\t%x0, %s1"
        : "=r" (result), "=w" (temp) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_llround.c b/newlib/libm/machine/aarch64/sf_llround.c
index 6d2c93a..80bbd87 100644
--- a/newlib/libm/machine/aarch64/sf_llround.c
+++ b/newlib/libm/machine/aarch64/sf_llround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_llround.c -- define llroundf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ llroundf (float x)
 {
   long long int result;
   asm ("fcvtas\t%x0, %s1" : "=r" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_lrint.c b/newlib/libm/machine/aarch64/sf_lrint.c
index d1f327a..7943747 100644
--- a/newlib/libm/machine/aarch64/sf_lrint.c
+++ b/newlib/libm/machine/aarch64/sf_lrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_lrint.c -- define lrintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -34,5 +35,6 @@ lrintf (float x)
   asm ("frintx\t%s1, %s2\n\t"
        "fcvtzs\t%x0, %s1"
        : "=r" (result), "=w" (temp) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_lround.c b/newlib/libm/machine/aarch64/sf_lround.c
index 858b2f0..4f0e606 100644
--- a/newlib/libm/machine/aarch64/sf_lround.c
+++ b/newlib/libm/machine/aarch64/sf_lround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_lround.c -- define lroundf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ lroundf (float x)
 {
   long int result;
   asm ("fcvtas\t%x0, %s1" : "=r" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_nearbyint.c b/newlib/libm/machine/aarch64/sf_nearbyint.c
index b7c8a67..4d814c5 100644
--- a/newlib/libm/machine/aarch64/sf_nearbyint.c
+++ b/newlib/libm/machine/aarch64/sf_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_nearbyint.c -- define nearbyintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ nearbyintf (float x)
 {
   float result;
   asm ("frinti\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_rint.c b/newlib/libm/machine/aarch64/sf_rint.c
index adcb35c..4667ad5 100644
--- a/newlib/libm/machine/aarch64/sf_rint.c
+++ b/newlib/libm/machine/aarch64/sf_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_rint.c -- define rintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ rintf (float x)
 {
   float result;
   asm ("frintx\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_round.c b/newlib/libm/machine/aarch64/sf_round.c
index 788bbfd..de96e27 100644
--- a/newlib/libm/machine/aarch64/sf_round.c
+++ b/newlib/libm/machine/aarch64/sf_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_round.c -- define roundf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ roundf (float x)
 {
   float result;
   asm ("frinta\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/aarch64/sf_trunc.c b/newlib/libm/machine/aarch64/sf_trunc.c
index 3df7db8..3b85a9c 100644
--- a/newlib/libm/machine/aarch64/sf_trunc.c
+++ b/newlib/libm/machine/aarch64/sf_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_trunc.c -- define truncf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -31,5 +32,6 @@ truncf (float x)
 {
   float result;
   asm ("frintz\t%s0, %s1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
diff --git a/newlib/libm/machine/arm/e_sqrt.c b/newlib/libm/machine/arm/e_sqrt.c
index 6f3eb83..df81df9 100644
--- a/newlib/libm/machine/arm/e_sqrt.c
+++ b/newlib/libm/machine/arm/e_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -37,6 +38,7 @@ __ieee754_sqrt(double x)
 	/* VFP9 Erratum 760019, see GCC sources "gcc/config/arm/vfp.md" */
 	asm ("vsqrt.f64 %P0, %P1" : "=&w" (result) : "w" (x));
 #endif
+	__A_VARIABLE = 1;
 	return result;
 }
 
diff --git a/newlib/libm/machine/arm/ef_sqrt.c b/newlib/libm/machine/arm/ef_sqrt.c
index 3a1ba6c..676b74b 100644
--- a/newlib/libm/machine/arm/ef_sqrt.c
+++ b/newlib/libm/machine/arm/ef_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*-
  * Copyright (c) 2017 embedded brains GmbH
  * All rights reserved.
@@ -37,6 +38,7 @@ __ieee754_sqrtf(float x)
 	/* VFP9 Erratum 760019, see GCC sources "gcc/config/arm/vfp.md" */
 	asm ("vsqrt.f32 %0, %1" : "=&w" (result) : "w" (x));
 #endif
+	__A_VARIABLE = 1;
 	return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_ceil.c b/newlib/libm/machine/arm/s_ceil.c
index ed1e85a..7d224f0 100644
--- a/newlib/libm/machine/arm/s_ceil.c
+++ b/newlib/libm/machine/arm/s_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_ceil.c -- define ceil
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ ceil (double x)
 {
   double result;
   asm volatile ( "vrintp.f64\t%P0, %P1" : "=w" (result) : "w" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_floor.c b/newlib/libm/machine/arm/s_floor.c
index d25132f..a9e405f 100644
--- a/newlib/libm/machine/arm/s_floor.c
+++ b/newlib/libm/machine/arm/s_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_floor.c -- define floor
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ floor (double x)
 {
   double result;
   asm volatile ("vrintm.f64\t%P0, %P1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_nearbyint.c b/newlib/libm/machine/arm/s_nearbyint.c
index 7ead69b..db9fbb0 100644
--- a/newlib/libm/machine/arm/s_nearbyint.c
+++ b/newlib/libm/machine/arm/s_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_nearbyint.c -- define nearbyint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ nearbyint (double x)
 {
   double result;
   asm volatile ("vrintr.f64\t%P0, %P1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_rint.c b/newlib/libm/machine/arm/s_rint.c
index 02c1022..24a85f5 100644
--- a/newlib/libm/machine/arm/s_rint.c
+++ b/newlib/libm/machine/arm/s_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_rint.c -- define rint
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ rint (double x)
 {
   double result;
   asm volatile ("vrintx.f64\t%P0, %P1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_round.c b/newlib/libm/machine/arm/s_round.c
index a8f2466..bf5c34f 100644
--- a/newlib/libm/machine/arm/s_round.c
+++ b/newlib/libm/machine/arm/s_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_round.c -- define round
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ round (double x)
 {
   double result;
   asm volatile ("vrinta.f64\t%P0, %P1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/s_trunc.c b/newlib/libm/machine/arm/s_trunc.c
index 6fb6968..ab1fa37 100644
--- a/newlib/libm/machine/arm/s_trunc.c
+++ b/newlib/libm/machine/arm/s_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* s_trunc.c -- define trunc
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ trunc (double x)
 {
   double result;
   asm volatile ("vrintz.f64\t%P0, %P1" : "=w" (result) : "w" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_ceil.c b/newlib/libm/machine/arm/sf_ceil.c
index b6efbff..0b16285 100644
--- a/newlib/libm/machine/arm/sf_ceil.c
+++ b/newlib/libm/machine/arm/sf_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_ceil.c -- define ceilf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ ceilf (float x)
 {
   float result;
   asm volatile ( "vrintp.f32\t%0, %1" : "=t" (result) : "t" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_floor.c b/newlib/libm/machine/arm/sf_floor.c
index 7bc9580..bc0ab0f 100644
--- a/newlib/libm/machine/arm/sf_floor.c
+++ b/newlib/libm/machine/arm/sf_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_floor.c -- define floorf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ floorf (float x)
 {
   float result;
   asm volatile ( "vrintm.f32\t%0, %1" : "=t" (result) : "t" (x) );
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_nearbyint.c b/newlib/libm/machine/arm/sf_nearbyint.c
index c70d844..b466d24 100644
--- a/newlib/libm/machine/arm/sf_nearbyint.c
+++ b/newlib/libm/machine/arm/sf_nearbyint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_nearbyint.c -- define nearbyintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ nearbyintf (float x)
 {
   float result;
   asm volatile ("vrintr.f32\t%0, %1" : "=t" (result) : "t" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_rint.c b/newlib/libm/machine/arm/sf_rint.c
index d9c383a..34ed8c1 100644
--- a/newlib/libm/machine/arm/sf_rint.c
+++ b/newlib/libm/machine/arm/sf_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_rint.c -- define rintf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ rintf (float x)
 {
   float result;
   asm volatile ("vrintx.f32\t%0, %1" : "=t" (result) : "t" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_round.c b/newlib/libm/machine/arm/sf_round.c
index 232fc08..ef0236d 100644
--- a/newlib/libm/machine/arm/sf_round.c
+++ b/newlib/libm/machine/arm/sf_round.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_round.c -- define roundf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ roundf (float x)
 {
   float result;
   asm volatile ("vrinta.f32\t%0, %1" : "=t" (result) : "t" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/arm/sf_trunc.c b/newlib/libm/machine/arm/sf_trunc.c
index 64e4aeb..f7cdfe6 100644
--- a/newlib/libm/machine/arm/sf_trunc.c
+++ b/newlib/libm/machine/arm/sf_trunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_trunc.c -- define truncf
    Copyright (c) 2011, 2012 ARM Ltd.  All rights reserved.
 
@@ -32,6 +33,7 @@ truncf (float x)
 {
   float result;
   asm volatile ("vrintz.f32\t%0, %1" : "=t" (result) : "t" (x));
+  __A_VARIABLE = 1;
   return result;
 }
 
diff --git a/newlib/libm/machine/i386/f_exp.c b/newlib/libm/machine/i386/f_exp.c
index 0ec721b..06241b4 100644
--- a/newlib/libm/machine/i386/f_exp.c
+++ b/newlib/libm/machine/i386/f_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1998,2002 by Red Hat Inc. All rights reserved.
diff --git a/newlib/libm/machine/i386/f_expf.c b/newlib/libm/machine/i386/f_expf.c
index b32d1f2..bc3fe4b 100644
--- a/newlib/libm/machine/i386/f_expf.c
+++ b/newlib/libm/machine/i386/f_expf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1998, 2002 by Red Hat Inc. All rights reserved.
diff --git a/newlib/libm/machine/i386/f_llrint.c b/newlib/libm/machine/i386/f_llrint.c
index 10285eb..ac8d04c 100644
--- a/newlib/libm/machine/i386/f_llrint.c
+++ b/newlib/libm/machine/i386/f_llrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -63,6 +64,7 @@ long long int _f_llrint (double x)
 {
   long long int _result;
   asm ("fistpll %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_llrintf.c b/newlib/libm/machine/i386/f_llrintf.c
index 427ad20..7077c16 100644
--- a/newlib/libm/machine/i386/f_llrintf.c
+++ b/newlib/libm/machine/i386/f_llrintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -26,6 +27,7 @@ long long int _f_llrintf (float x)
 {
   long long int _result;
   asm ("fistpll %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_llrintl.c b/newlib/libm/machine/i386/f_llrintl.c
index 610270c..cc1c383 100644
--- a/newlib/libm/machine/i386/f_llrintl.c
+++ b/newlib/libm/machine/i386/f_llrintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -26,11 +27,13 @@ long long int _f_llrintl (long double x)
 {
   long long int _result;
   asm ("fistpll %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
 /* For now, we only have the fast math version.  */
 long long int llrintl (long double x) {
+  __A_VARIABLE = 1;
   return _f_llrintl(x);
 }
 
diff --git a/newlib/libm/machine/i386/f_lrint.c b/newlib/libm/machine/i386/f_lrint.c
index b8cdabb..652e775 100644
--- a/newlib/libm/machine/i386/f_lrint.c
+++ b/newlib/libm/machine/i386/f_lrint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -62,6 +63,7 @@ long int _f_lrint (double x)
 {
   long int _result;
   asm ("fistpl %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_lrintf.c b/newlib/libm/machine/i386/f_lrintf.c
index da8ffa6..e93e08f 100644
--- a/newlib/libm/machine/i386/f_lrintf.c
+++ b/newlib/libm/machine/i386/f_lrintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -25,6 +26,7 @@ long int _f_lrintf (float x)
 {
   long int _result;
   asm ("fistpl %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_lrintl.c b/newlib/libm/machine/i386/f_lrintl.c
index eae2bca..bdca577 100644
--- a/newlib/libm/machine/i386/f_lrintl.c
+++ b/newlib/libm/machine/i386/f_lrintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -26,11 +27,13 @@ long int _f_lrintl (long double x)
 {
   long int _result;
   asm ("fistpl %0" : "=m" (_result) : "t" (x) : "st");
+  __A_VARIABLE = 1;
   return _result;
 }
 
 /* For now, there is only the fast math version so we use it.  */
 long int lrintl (long double x) {
+  __A_VARIABLE = 1;
   return _f_lrintl(x);
 }
 
diff --git a/newlib/libm/machine/i386/f_pow.c b/newlib/libm/machine/i386/f_pow.c
index d1ef421..3aa4ae1 100644
--- a/newlib/libm/machine/i386/f_pow.c
+++ b/newlib/libm/machine/i386/f_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1998, 2002 by Red Hat Inc. All rights reserved.
diff --git a/newlib/libm/machine/i386/f_powf.c b/newlib/libm/machine/i386/f_powf.c
index a778f46..a3263b5 100644
--- a/newlib/libm/machine/i386/f_powf.c
+++ b/newlib/libm/machine/i386/f_powf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * Copyright (C) 1998, 2002 by Red Hat Inc. All rights reserved.
diff --git a/newlib/libm/machine/i386/f_rint.c b/newlib/libm/machine/i386/f_rint.c
index e335d46..2b7f6f5 100644
--- a/newlib/libm/machine/i386/f_rint.c
+++ b/newlib/libm/machine/i386/f_rint.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -60,6 +61,7 @@ double _f_rint (double x)
 {
   double _result;
   asm ("frndint" : "=t" (_result) : "0" (x));
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_rintf.c b/newlib/libm/machine/i386/f_rintf.c
index a7dabb7..692dc6b 100644
--- a/newlib/libm/machine/i386/f_rintf.c
+++ b/newlib/libm/machine/i386/f_rintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -25,6 +26,7 @@ float _f_rintf (float x)
 {
   float _result;
   asm ("frndint" : "=t" (_result) : "0" (x));
+  __A_VARIABLE = 1;
   return _result;
 }
 
diff --git a/newlib/libm/machine/i386/f_rintl.c b/newlib/libm/machine/i386/f_rintl.c
index 0e67739..2b2b2bb 100644
--- a/newlib/libm/machine/i386/f_rintl.c
+++ b/newlib/libm/machine/i386/f_rintl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * ====================================================
  * x87 FP implementation contributed to Newlib by
@@ -26,11 +27,13 @@ long double _f_rintl (long double x)
 {
   long double _result;
   asm ("frndint" : "=t" (_result) : "0" (x));
+  __A_VARIABLE = 1;
   return _result;
 }
 
 /* For now, we only have the fast math version.  */
 long double rintl (long double x) {
+  __A_VARIABLE = 1;
   return _f_rintl(x);
 } 
 
diff --git a/newlib/libm/machine/riscv/fe_dfl_env.c b/newlib/libm/machine/riscv/fe_dfl_env.c
index 883c6f9..a4d2885 100644
--- a/newlib/libm/machine/riscv/fe_dfl_env.c
+++ b/newlib/libm/machine/riscv/fe_dfl_env.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
diff --git a/newlib/libm/machine/riscv/feclearexcept.c b/newlib/libm/machine/riscv/feclearexcept.c
index 90c7775..f8a2d8c 100644
--- a/newlib/libm/machine/riscv/feclearexcept.c
+++ b/newlib/libm/machine/riscv/feclearexcept.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -77,5 +78,6 @@ int feclearexcept(int excepts)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fegetenv.c b/newlib/libm/machine/riscv/fegetenv.c
index c1488c7..0c8e6f7 100644
--- a/newlib/libm/machine/riscv/fegetenv.c
+++ b/newlib/libm/machine/riscv/fegetenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -66,5 +67,6 @@ int fegetenv(fenv_t *envp)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fegetexceptflag.c b/newlib/libm/machine/riscv/fegetexceptflag.c
index ab1b8a6..72816ad 100644
--- a/newlib/libm/machine/riscv/fegetexceptflag.c
+++ b/newlib/libm/machine/riscv/fegetexceptflag.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -72,5 +73,6 @@ int fegetexceptflag(fexcept_t *flagp, int excepts)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fegetround.c b/newlib/libm/machine/riscv/fegetround.c
index b4c0f2b..197d98b 100644
--- a/newlib/libm/machine/riscv/fegetround.c
+++ b/newlib/libm/machine/riscv/fegetround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
diff --git a/newlib/libm/machine/riscv/feholdexcept.c b/newlib/libm/machine/riscv/feholdexcept.c
index 9d726da..e92dfef 100644
--- a/newlib/libm/machine/riscv/feholdexcept.c
+++ b/newlib/libm/machine/riscv/feholdexcept.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -72,5 +73,6 @@ int feholdexcept(fenv_t *envp)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/feraiseexcept.c b/newlib/libm/machine/riscv/feraiseexcept.c
index 6f28632..ab5a1ca 100644
--- a/newlib/libm/machine/riscv/feraiseexcept.c
+++ b/newlib/libm/machine/riscv/feraiseexcept.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -81,5 +82,6 @@ int feraiseexcept(int excepts)
 
 #endif
 
+  __A_VARIABLE = 1;
   return (excepts != 0);
 }
diff --git a/newlib/libm/machine/riscv/fesetenv.c b/newlib/libm/machine/riscv/fesetenv.c
index 943b272..64aa72e 100644
--- a/newlib/libm/machine/riscv/fesetenv.c
+++ b/newlib/libm/machine/riscv/fesetenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -69,5 +70,6 @@ int fesetenv(const fenv_t *envp)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fesetexceptflag.c b/newlib/libm/machine/riscv/fesetexceptflag.c
index 04400f4..4753ab1 100644
--- a/newlib/libm/machine/riscv/fesetexceptflag.c
+++ b/newlib/libm/machine/riscv/fesetexceptflag.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -76,5 +77,6 @@ int fesetexceptflag(const fexcept_t *flagp, int excepts)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fesetround.c b/newlib/libm/machine/riscv/fesetround.c
index b2451c7..000237e 100644
--- a/newlib/libm/machine/riscv/fesetround.c
+++ b/newlib/libm/machine/riscv/fesetround.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
@@ -66,5 +67,6 @@ int fesetround(int round)
 
 #endif
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/libm/machine/riscv/fetestexcept.c b/newlib/libm/machine/riscv/fetestexcept.c
index 55d880c..15f6eeb 100644
--- a/newlib/libm/machine/riscv/fetestexcept.c
+++ b/newlib/libm/machine/riscv/fetestexcept.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
diff --git a/newlib/libm/machine/riscv/feupdateenv.c b/newlib/libm/machine/riscv/feupdateenv.c
index 737095c..e98beb9 100644
--- a/newlib/libm/machine/riscv/feupdateenv.c
+++ b/newlib/libm/machine/riscv/feupdateenv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (c) Copyright 2017 Michael R. Neilly
   All rights reserved.
diff --git a/newlib/libm/machine/spu/fe_dfl_env.c b/newlib/libm/machine/spu/fe_dfl_env.c
index 25b8a00..8bf5d5d 100644
--- a/newlib/libm/machine/spu/fe_dfl_env.c
+++ b/newlib/libm/machine/spu/fe_dfl_env.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <fenv.h>
 /*
  * Define for FE_DFL_ENV macro, all bits zero.
diff --git a/newlib/libm/machine/spu/feclearexcept.c b/newlib/libm/machine/spu/feclearexcept.c
index fbec7ad..373eaba 100644
--- a/newlib/libm/machine/spu/feclearexcept.c
+++ b/newlib/libm/machine/spu/feclearexcept.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/feclearexcept.h"
 
 void feclearexcept(int excepts)
 {
     _feclearexcept(excepts);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fegetenv.c b/newlib/libm/machine/spu/fegetenv.c
index 544877b..298f0b7 100644
--- a/newlib/libm/machine/spu/fegetenv.c
+++ b/newlib/libm/machine/spu/fegetenv.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fegetenv.h"
 
 void fegetenv(fenv_t *envp)
 {
     _fegetenv(envp);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fegetexceptflag.c b/newlib/libm/machine/spu/fegetexceptflag.c
index 0c98199..75cd6a1 100644
--- a/newlib/libm/machine/spu/fegetexceptflag.c
+++ b/newlib/libm/machine/spu/fegetexceptflag.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fegetexceptflag.h"
 
 void fegetexceptflag(fexcept_t *flagp, int excepts)
 {
     _fegetexceptflag(flagp, excepts);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fegetround.c b/newlib/libm/machine/spu/fegetround.c
index a810aed..f732b8b 100644
--- a/newlib/libm/machine/spu/fegetround.c
+++ b/newlib/libm/machine/spu/fegetround.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fegetround.h"
 
 int fegetround()
 {
+    __A_VARIABLE = 1;
     return _fegetround();
 }
diff --git a/newlib/libm/machine/spu/feholdexcept.c b/newlib/libm/machine/spu/feholdexcept.c
index 57b57b1..71f0ef8 100644
--- a/newlib/libm/machine/spu/feholdexcept.c
+++ b/newlib/libm/machine/spu/feholdexcept.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/feholdexcept.h"
 
 int feholdexcept(fenv_t *envp)
 {
+    __A_VARIABLE = 1;
     return _feholdexcept(envp);
 }
diff --git a/newlib/libm/machine/spu/feraiseexcept.c b/newlib/libm/machine/spu/feraiseexcept.c
index 0a6946e..8ffe46b 100644
--- a/newlib/libm/machine/spu/feraiseexcept.c
+++ b/newlib/libm/machine/spu/feraiseexcept.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/feraiseexcept.h"
 
 void feraiseexcept(int excepts)
 {
     _feraiseexcept(excepts);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fesetenv.c b/newlib/libm/machine/spu/fesetenv.c
index 1875113..c5f62ba 100644
--- a/newlib/libm/machine/spu/fesetenv.c
+++ b/newlib/libm/machine/spu/fesetenv.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fesetenv.h"
 
 void fesetenv(const fenv_t *envp)
 {
     _fesetenv(envp);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fesetexceptflag.c b/newlib/libm/machine/spu/fesetexceptflag.c
index 0312aed..1d51fd9 100644
--- a/newlib/libm/machine/spu/fesetexceptflag.c
+++ b/newlib/libm/machine/spu/fesetexceptflag.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fesetexceptflag.h"
 
 void fesetexceptflag(const fexcept_t *flagp, int excepts)
 {
     _fesetexceptflag(flagp, excepts);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/fesetround.c b/newlib/libm/machine/spu/fesetround.c
index 8ad9822..86564dc 100644
--- a/newlib/libm/machine/spu/fesetround.c
+++ b/newlib/libm/machine/spu/fesetround.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fesetround.h"
 
 int fesetround(int rounding_mode)
 {
+    __A_VARIABLE = 1;
     return _fesetround(rounding_mode);
 }
diff --git a/newlib/libm/machine/spu/fetestexcept.c b/newlib/libm/machine/spu/fetestexcept.c
index 7e88f78..1b6c2cf 100644
--- a/newlib/libm/machine/spu/fetestexcept.c
+++ b/newlib/libm/machine/spu/fetestexcept.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/fetestexcept.h"
 
 int fetestexcept(int excepts)
 {
+    __A_VARIABLE = 1;
     return _fetestexcept(excepts);
 }
diff --git a/newlib/libm/machine/spu/feupdateenv.c b/newlib/libm/machine/spu/feupdateenv.c
index 9198158..164af30 100644
--- a/newlib/libm/machine/spu/feupdateenv.c
+++ b/newlib/libm/machine/spu/feupdateenv.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "headers/feupdateenv.h"
 
 void feupdateenv(const fenv_t *envp)
 {
     _feupdateenv(envp);
+    __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/machine/spu/llrint.c b/newlib/libm/machine/spu/llrint.c
index e0aa0e8..6c7805f 100644
--- a/newlib/libm/machine/spu/llrint.c
+++ b/newlib/libm/machine/spu/llrint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/llrint.h"
 
 long long int llrint(double x)
 {
+    __A_VARIABLE = 1;
     return _llrint(x);
 }
diff --git a/newlib/libm/machine/spu/llrintf.c b/newlib/libm/machine/spu/llrintf.c
index a27c773..f41c4e2 100644
--- a/newlib/libm/machine/spu/llrintf.c
+++ b/newlib/libm/machine/spu/llrintf.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/llrintf.h"
 
 long long int llrintf(float x)
 {
+    __A_VARIABLE = 1;
     return _llrintf(x);
 }
diff --git a/newlib/libm/machine/spu/llround.c b/newlib/libm/machine/spu/llround.c
index a24450e..1d78f71 100644
--- a/newlib/libm/machine/spu/llround.c
+++ b/newlib/libm/machine/spu/llround.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/llround.h"
 
 long long int llround(double x)
 {
+    __A_VARIABLE = 1;
     return _llround(x);
 }
diff --git a/newlib/libm/machine/spu/llroundf.c b/newlib/libm/machine/spu/llroundf.c
index 8adfd43..62f0a8c 100644
--- a/newlib/libm/machine/spu/llroundf.c
+++ b/newlib/libm/machine/spu/llroundf.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/llroundf.h"
 
 long long int llroundf(float x)
 {
+    __A_VARIABLE = 1;
     return _llroundf(x);
 }
diff --git a/newlib/libm/machine/spu/log2.c b/newlib/libm/machine/spu/log2.c
index 9bbb31d..cb8617d 100644
--- a/newlib/libm/machine/spu/log2.c
+++ b/newlib/libm/machine/spu/log2.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log2.h"
 
 #undef log2
 double log2(double vx)
 {
+  __A_VARIABLE = 1;
   return _log2(vx);
 }
diff --git a/newlib/libm/machine/spu/log2f.c b/newlib/libm/machine/spu/log2f.c
index 42b2c02..a94c92b 100644
--- a/newlib/libm/machine/spu/log2f.c
+++ b/newlib/libm/machine/spu/log2f.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log2f.h"
 
 #undef log2f
 float log2f(float x)
 {
+    __A_VARIABLE = 1;
     return _log2f(x);
 }
diff --git a/newlib/libm/machine/spu/s_asinh.c b/newlib/libm/machine/spu/s_asinh.c
index f78d5ff..f1ea395 100644
--- a/newlib/libm/machine/spu/s_asinh.c
+++ b/newlib/libm/machine/spu/s_asinh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/asinh.h"
 
 double asinh(double x)
 {
+  __A_VARIABLE = 1;
   return _asinh(x);
 }
diff --git a/newlib/libm/machine/spu/s_atan.c b/newlib/libm/machine/spu/s_atan.c
index f9b605f..77bf33e 100644
--- a/newlib/libm/machine/spu/s_atan.c
+++ b/newlib/libm/machine/spu/s_atan.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atan.h"
 
 double atan(double x)
 {
+  __A_VARIABLE = 1;
   return _atan(x);
 }
diff --git a/newlib/libm/machine/spu/s_cbrt.c b/newlib/libm/machine/spu/s_cbrt.c
index 56be72f..db61d5c 100644
--- a/newlib/libm/machine/spu/s_cbrt.c
+++ b/newlib/libm/machine/spu/s_cbrt.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/cbrt.h"
 
 double cbrt(double x)
 {
+    __A_VARIABLE = 1;
     return _cbrt(x);
 }
diff --git a/newlib/libm/machine/spu/s_ceil.c b/newlib/libm/machine/spu/s_ceil.c
index c96d976..985323d 100644
--- a/newlib/libm/machine/spu/s_ceil.c
+++ b/newlib/libm/machine/spu/s_ceil.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ceil.h"
 
 double ceil(double x)
 {
+    __A_VARIABLE = 1;
     return _ceil(x);
 }
diff --git a/newlib/libm/machine/spu/s_copysign.c b/newlib/libm/machine/spu/s_copysign.c
index b4b2390..56b5aae 100644
--- a/newlib/libm/machine/spu/s_copysign.c
+++ b/newlib/libm/machine/spu/s_copysign.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/copysign.h"
 
 double copysign(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _copysign(x, y);
 }
diff --git a/newlib/libm/machine/spu/s_cos.c b/newlib/libm/machine/spu/s_cos.c
index 5873262..1501fa1 100644
--- a/newlib/libm/machine/spu/s_cos.c
+++ b/newlib/libm/machine/spu/s_cos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/cos.h"
 
 double cos(double angle)
 {
+  __A_VARIABLE = 1;
   return _cos(angle);
 }
diff --git a/newlib/libm/machine/spu/s_erf.c b/newlib/libm/machine/spu/s_erf.c
index 89ef0cf..4074e88 100644
--- a/newlib/libm/machine/spu/s_erf.c
+++ b/newlib/libm/machine/spu/s_erf.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/erf.h"
 
 double erf(double x)
 {
+  __A_VARIABLE = 1;
   return _erf(x);
 }
 
@@ -14,5 +16,6 @@ double erf(double x)
 
 double erfc(double x)
 {
+  __A_VARIABLE = 1;
   return _erfc(x);
 }
diff --git a/newlib/libm/machine/spu/s_expm1.c b/newlib/libm/machine/spu/s_expm1.c
index 616d3d5..45f8ad9 100644
--- a/newlib/libm/machine/spu/s_expm1.c
+++ b/newlib/libm/machine/spu/s_expm1.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/expm1.h"
 
 double expm1(double x)
 {
+  __A_VARIABLE = 1;
   return _expm1(x);
 }
diff --git a/newlib/libm/machine/spu/s_fabs.c b/newlib/libm/machine/spu/s_fabs.c
index 810f320..c7961d8 100644
--- a/newlib/libm/machine/spu/s_fabs.c
+++ b/newlib/libm/machine/spu/s_fabs.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fabs.h"
 
 double fabs(double x)
 {
+    __A_VARIABLE = 1;
     return _fabs(x);
 }
diff --git a/newlib/libm/machine/spu/s_fdim.c b/newlib/libm/machine/spu/s_fdim.c
index fd2b5ac..1125fbf 100644
--- a/newlib/libm/machine/spu/s_fdim.c
+++ b/newlib/libm/machine/spu/s_fdim.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fdim.h"
 
 double fdim(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _fdim(x, y);
 }
diff --git a/newlib/libm/machine/spu/s_floor.c b/newlib/libm/machine/spu/s_floor.c
index 5f0d238..41da9c4 100644
--- a/newlib/libm/machine/spu/s_floor.c
+++ b/newlib/libm/machine/spu/s_floor.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/floor.h"
 
 double floor(double x)
 {
+    __A_VARIABLE = 1;
     return _floor(x);
 }
diff --git a/newlib/libm/machine/spu/s_fma.c b/newlib/libm/machine/spu/s_fma.c
index 0dad63e..1ac7280 100644
--- a/newlib/libm/machine/spu/s_fma.c
+++ b/newlib/libm/machine/spu/s_fma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fma.h"
 
 double fma(double x, double y, double z)
 {
+    __A_VARIABLE = 1;
     return _fma(x, y, z);
 }
diff --git a/newlib/libm/machine/spu/s_fmax.c b/newlib/libm/machine/spu/s_fmax.c
index b17c327..6bd262c 100644
--- a/newlib/libm/machine/spu/s_fmax.c
+++ b/newlib/libm/machine/spu/s_fmax.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmax.h"
 
 double fmax(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _fmax(x, y);
 }
diff --git a/newlib/libm/machine/spu/s_fmin.c b/newlib/libm/machine/spu/s_fmin.c
index 3daa05b..be8b1fe 100644
--- a/newlib/libm/machine/spu/s_fmin.c
+++ b/newlib/libm/machine/spu/s_fmin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmin.h"
 
 double fmin(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _fmin(x, y);
 }
diff --git a/newlib/libm/machine/spu/s_frexp.c b/newlib/libm/machine/spu/s_frexp.c
index 3f1e096..2e8e13b 100644
--- a/newlib/libm/machine/spu/s_frexp.c
+++ b/newlib/libm/machine/spu/s_frexp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/frexp.h"
 
 double frexp(double x, int *pexp)
 {
+    __A_VARIABLE = 1;
     return _frexp(x, pexp);
 }
diff --git a/newlib/libm/machine/spu/s_ilogb.c b/newlib/libm/machine/spu/s_ilogb.c
index 9a3730f..8f00891 100644
--- a/newlib/libm/machine/spu/s_ilogb.c
+++ b/newlib/libm/machine/spu/s_ilogb.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ilogb.h"
 
 int ilogb(double x)
 {
+    __A_VARIABLE = 1;
     return _ilogb(x);
 }
diff --git a/newlib/libm/machine/spu/s_isnan.c b/newlib/libm/machine/spu/s_isnan.c
index c93ff19..e7dd6e2 100644
--- a/newlib/libm/machine/spu/s_isnan.c
+++ b/newlib/libm/machine/spu/s_isnan.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/isnan.h"
 
 #undef isnan
 int isnan(double x)
 {
+  __A_VARIABLE = 1;
   return _isnan(x);
 }
diff --git a/newlib/libm/machine/spu/s_ldexp.c b/newlib/libm/machine/spu/s_ldexp.c
index 268eb67..2ef3b01 100644
--- a/newlib/libm/machine/spu/s_ldexp.c
+++ b/newlib/libm/machine/spu/s_ldexp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ldexp.h"
 
 double ldexp(double x, int exp)
 {
+    __A_VARIABLE = 1;
     return _ldexp(x, exp);
 }
diff --git a/newlib/libm/machine/spu/s_log1p.c b/newlib/libm/machine/spu/s_log1p.c
index 70ca375..9999c32 100644
--- a/newlib/libm/machine/spu/s_log1p.c
+++ b/newlib/libm/machine/spu/s_log1p.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log1p.h"
 
 double log1p(double x)
 {
+  __A_VARIABLE = 1;
   return _log1p(x);
 }
diff --git a/newlib/libm/machine/spu/s_lrint.c b/newlib/libm/machine/spu/s_lrint.c
index e9a3f74..8bdd831 100644
--- a/newlib/libm/machine/spu/s_lrint.c
+++ b/newlib/libm/machine/spu/s_lrint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lrint.h"
 
 long int lrint(double x)
 {
+    __A_VARIABLE = 1;
     return _lrint(x);
 }
diff --git a/newlib/libm/machine/spu/s_lround.c b/newlib/libm/machine/spu/s_lround.c
index cc012d7..0d2b4ac 100644
--- a/newlib/libm/machine/spu/s_lround.c
+++ b/newlib/libm/machine/spu/s_lround.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lround.h"
 
 long int lround(double x)
 {
+    __A_VARIABLE = 1;
     return _lround(x);
 }
diff --git a/newlib/libm/machine/spu/s_nearbyint.c b/newlib/libm/machine/spu/s_nearbyint.c
index 5887f27..ead397a 100644
--- a/newlib/libm/machine/spu/s_nearbyint.c
+++ b/newlib/libm/machine/spu/s_nearbyint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/nearbyint.h"
 
 double nearbyint(double x)
 {
+    __A_VARIABLE = 1;
     return _nearbyint(x);
 }
diff --git a/newlib/libm/machine/spu/s_nextafter.c b/newlib/libm/machine/spu/s_nextafter.c
index 60a741f..10803b1 100644
--- a/newlib/libm/machine/spu/s_nextafter.c
+++ b/newlib/libm/machine/spu/s_nextafter.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/nextafter.h"
 
 double nextafter(double x, double y)
 {
+  __A_VARIABLE = 1;
   return _nextafter(x, y);
 }
diff --git a/newlib/libm/machine/spu/s_remquo.c b/newlib/libm/machine/spu/s_remquo.c
index 9ba6a12..d7ed6fb 100644
--- a/newlib/libm/machine/spu/s_remquo.c
+++ b/newlib/libm/machine/spu/s_remquo.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/remquo.h"
 
 double remquo(double x, double y, int *quo)
 {
+    __A_VARIABLE = 1;
     return _remquo(x, y, quo);
 }
diff --git a/newlib/libm/machine/spu/s_rint.c b/newlib/libm/machine/spu/s_rint.c
index 482c626..41ef3a3 100644
--- a/newlib/libm/machine/spu/s_rint.c
+++ b/newlib/libm/machine/spu/s_rint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/rint.h"
 
 double rint(double x)
 {
+    __A_VARIABLE = 1;
     return _rint(x);
 }
diff --git a/newlib/libm/machine/spu/s_round.c b/newlib/libm/machine/spu/s_round.c
index 7138c84..a19dfc4 100644
--- a/newlib/libm/machine/spu/s_round.c
+++ b/newlib/libm/machine/spu/s_round.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/round.h"
 
 double round(double x)
 {
+    __A_VARIABLE = 1;
     return _round(x);
 }
diff --git a/newlib/libm/machine/spu/s_scalbn.c b/newlib/libm/machine/spu/s_scalbn.c
index 58e161d..ec08430 100644
--- a/newlib/libm/machine/spu/s_scalbn.c
+++ b/newlib/libm/machine/spu/s_scalbn.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/scalbn.h"
 
 double scalbn(double x, int exp)
 {
+    __A_VARIABLE = 1;
     return _scalbn(x, exp);
 }
diff --git a/newlib/libm/machine/spu/s_sin.c b/newlib/libm/machine/spu/s_sin.c
index ec079c9..0dbdaf1 100644
--- a/newlib/libm/machine/spu/s_sin.c
+++ b/newlib/libm/machine/spu/s_sin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sin.h"
 
 double sin(double angle)
 {
+  __A_VARIABLE = 1;
   return _sin(angle);
 }
diff --git a/newlib/libm/machine/spu/s_tan.c b/newlib/libm/machine/spu/s_tan.c
index 8b0b22c..6f83785 100644
--- a/newlib/libm/machine/spu/s_tan.c
+++ b/newlib/libm/machine/spu/s_tan.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tan.h"
 
 double tan(double angle)
 {
+  __A_VARIABLE = 1;
   return _tan(angle);
 }
diff --git a/newlib/libm/machine/spu/s_tanh.c b/newlib/libm/machine/spu/s_tanh.c
index 5443d57..3e51924 100644
--- a/newlib/libm/machine/spu/s_tanh.c
+++ b/newlib/libm/machine/spu/s_tanh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tanh.h"
 
 double tanh(double x)
 {
+  __A_VARIABLE = 1;
   return _tanh(x);
 }
diff --git a/newlib/libm/machine/spu/s_trunc.c b/newlib/libm/machine/spu/s_trunc.c
index 043df44..c94640a 100644
--- a/newlib/libm/machine/spu/s_trunc.c
+++ b/newlib/libm/machine/spu/s_trunc.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/trunc.h"
 
 double trunc(double x)
 {
+    __A_VARIABLE = 1;
     return _trunc(x);
 }
diff --git a/newlib/libm/machine/spu/sf_asinh.c b/newlib/libm/machine/spu/sf_asinh.c
index fcfb959..db7354e 100644
--- a/newlib/libm/machine/spu/sf_asinh.c
+++ b/newlib/libm/machine/spu/sf_asinh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/asinhf.h"
 
 float asinhf(float x)
 {
+  __A_VARIABLE = 1;
   return _asinhf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_atan.c b/newlib/libm/machine/spu/sf_atan.c
index 90ef514..f65d16e 100644
--- a/newlib/libm/machine/spu/sf_atan.c
+++ b/newlib/libm/machine/spu/sf_atan.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atanf.h"
 
 float atanf(float x)
 {
+    __A_VARIABLE = 1;
     return _atanf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_cbrt.c b/newlib/libm/machine/spu/sf_cbrt.c
index 86a0865..dc316cb 100644
--- a/newlib/libm/machine/spu/sf_cbrt.c
+++ b/newlib/libm/machine/spu/sf_cbrt.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/cbrtf.h"
 
 float cbrtf(float x)
 {
+    __A_VARIABLE = 1;
     return _cbrtf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_ceil.c b/newlib/libm/machine/spu/sf_ceil.c
index cfd611c..287f2af 100644
--- a/newlib/libm/machine/spu/sf_ceil.c
+++ b/newlib/libm/machine/spu/sf_ceil.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ceilf.h"
 
 float ceilf(float value)
 {
+    __A_VARIABLE = 1;
     return _ceilf(value);
 }
diff --git a/newlib/libm/machine/spu/sf_copysign.c b/newlib/libm/machine/spu/sf_copysign.c
index 4647c45..4f58911 100644
--- a/newlib/libm/machine/spu/sf_copysign.c
+++ b/newlib/libm/machine/spu/sf_copysign.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/copysignf.h"
 
 float copysignf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _copysignf(x, y);
 }
diff --git a/newlib/libm/machine/spu/sf_cos.c b/newlib/libm/machine/spu/sf_cos.c
index da498d1..3664599 100644
--- a/newlib/libm/machine/spu/sf_cos.c
+++ b/newlib/libm/machine/spu/sf_cos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/cosf.h"
 
 float cosf(float angle)
 {
+  __A_VARIABLE = 1;
   return _cosf(angle);
 }
diff --git a/newlib/libm/machine/spu/sf_erf.c b/newlib/libm/machine/spu/sf_erf.c
index 14e0dcd..8d1d65c 100644
--- a/newlib/libm/machine/spu/sf_erf.c
+++ b/newlib/libm/machine/spu/sf_erf.c
@@ -1,8 +1,10 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/erff.h"
 
 float erff(float x)
 {
+  __A_VARIABLE = 1;
   return _erff(x);
 }
 
@@ -14,5 +16,6 @@ float erff(float x)
 
 float erfcf(float x)
 {
+  __A_VARIABLE = 1;
   return _erfcf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_expm1.c b/newlib/libm/machine/spu/sf_expm1.c
index 9851de5..35abe86 100644
--- a/newlib/libm/machine/spu/sf_expm1.c
+++ b/newlib/libm/machine/spu/sf_expm1.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/expm1f.h"
 
 float expm1f(float vx)
 {
+  __A_VARIABLE = 1;
   return _expm1f(vx);
 }
diff --git a/newlib/libm/machine/spu/sf_fabs.c b/newlib/libm/machine/spu/sf_fabs.c
index bffc44b..0dc3450 100644
--- a/newlib/libm/machine/spu/sf_fabs.c
+++ b/newlib/libm/machine/spu/sf_fabs.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fabsf.h"
 
 float fabsf(float value)
 {
+    __A_VARIABLE = 1;
     return _fabsf(value);
 }
diff --git a/newlib/libm/machine/spu/sf_fdim.c b/newlib/libm/machine/spu/sf_fdim.c
index b489c27..cf79648 100644
--- a/newlib/libm/machine/spu/sf_fdim.c
+++ b/newlib/libm/machine/spu/sf_fdim.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fdimf.h"
 
 float fdimf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _fdimf(x, y);
 }
diff --git a/newlib/libm/machine/spu/sf_finite.c b/newlib/libm/machine/spu/sf_finite.c
index 88d635f..d1b4335 100644
--- a/newlib/libm/machine/spu/sf_finite.c
+++ b/newlib/libm/machine/spu/sf_finite.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 finitef(float x)
 {
+	__A_VARIABLE = 1;
 	return 1;
 }
diff --git a/newlib/libm/machine/spu/sf_floor.c b/newlib/libm/machine/spu/sf_floor.c
index c5de7ca..8e73872 100644
--- a/newlib/libm/machine/spu/sf_floor.c
+++ b/newlib/libm/machine/spu/sf_floor.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/floorf.h"
 
 float floorf(float value)
 {
+    __A_VARIABLE = 1;
     return _floorf(value);
 }
diff --git a/newlib/libm/machine/spu/sf_fma.c b/newlib/libm/machine/spu/sf_fma.c
index 45dbcba..81874ba 100644
--- a/newlib/libm/machine/spu/sf_fma.c
+++ b/newlib/libm/machine/spu/sf_fma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmaf.h"
 
 float fmaf(float x, float y, float z)
 {
+    __A_VARIABLE = 1;
     return _fmaf(x, y, z);
 }
diff --git a/newlib/libm/machine/spu/sf_fmax.c b/newlib/libm/machine/spu/sf_fmax.c
index 5d5ca53..ea519e0 100644
--- a/newlib/libm/machine/spu/sf_fmax.c
+++ b/newlib/libm/machine/spu/sf_fmax.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmaxf.h"
 
 float fmaxf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _fmaxf(x, y);
 }
diff --git a/newlib/libm/machine/spu/sf_fmin.c b/newlib/libm/machine/spu/sf_fmin.c
index a08dca8..da50440 100644
--- a/newlib/libm/machine/spu/sf_fmin.c
+++ b/newlib/libm/machine/spu/sf_fmin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fminf.h"
 
 float fminf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _fminf(x, y);
 }
diff --git a/newlib/libm/machine/spu/sf_fpclassify.c b/newlib/libm/machine/spu/sf_fpclassify.c
index 36cf8ba..3605e0d 100644
--- a/newlib/libm/machine/spu/sf_fpclassify.c
+++ b/newlib/libm/machine/spu/sf_fpclassify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -18,7 +19,10 @@ __fpclassifyf (float x)
 
   GET_FLOAT_WORD(w,x);
 
-  if (w == 0x00000000 || w == 0x80000000)
+  if (w == 0x00000000 || w == 0x80000000) {
+    __A_VARIABLE = 1;
     return FP_ZERO;
+  }
+  __A_VARIABLE = 1;
   return FP_NORMAL;
 }
diff --git a/newlib/libm/machine/spu/sf_frexp.c b/newlib/libm/machine/spu/sf_frexp.c
index 8ea04d5..588624d 100644
--- a/newlib/libm/machine/spu/sf_frexp.c
+++ b/newlib/libm/machine/spu/sf_frexp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/frexpf.h"
 
 float frexpf(float x, int *pexp)
 {
+    __A_VARIABLE = 1;
     return _frexpf(x, pexp);
 }
diff --git a/newlib/libm/machine/spu/sf_ilogb.c b/newlib/libm/machine/spu/sf_ilogb.c
index ea2146c..c61217f 100644
--- a/newlib/libm/machine/spu/sf_ilogb.c
+++ b/newlib/libm/machine/spu/sf_ilogb.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ilogbf.h"
 
 int ilogbf(float x)
 {
+    __A_VARIABLE = 1;
     return _ilogbf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_isinf.c b/newlib/libm/machine/spu/sf_isinf.c
index 6460ec1..48ade2a 100644
--- a/newlib/libm/machine/spu/sf_isinf.c
+++ b/newlib/libm/machine/spu/sf_isinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -39,5 +40,6 @@
 int
 isinff (float x)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libm/machine/spu/sf_isinff.c b/newlib/libm/machine/spu/sf_isinff.c
index 3ce424a..d519607 100644
--- a/newlib/libm/machine/spu/sf_isinff.c
+++ b/newlib/libm/machine/spu/sf_isinff.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 __isinff (float x)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libm/machine/spu/sf_isnan.c b/newlib/libm/machine/spu/sf_isnan.c
index 448bfc4..765ef94 100644
--- a/newlib/libm/machine/spu/sf_isnan.c
+++ b/newlib/libm/machine/spu/sf_isnan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 isnanf(float x)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libm/machine/spu/sf_isnanf.c b/newlib/libm/machine/spu/sf_isnanf.c
index 1dab50c..42948d8 100644
--- a/newlib/libm/machine/spu/sf_isnanf.c
+++ b/newlib/libm/machine/spu/sf_isnanf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -37,5 +38,6 @@
 int
 __isnanf(float x)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libm/machine/spu/sf_ldexp.c b/newlib/libm/machine/spu/sf_ldexp.c
index 7d19a5d..9cee758 100644
--- a/newlib/libm/machine/spu/sf_ldexp.c
+++ b/newlib/libm/machine/spu/sf_ldexp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/ldexpf.h"
 
 float ldexpf(float x, int exp)
 {
+    __A_VARIABLE = 1;
     return _ldexpf(x, exp);
 }
diff --git a/newlib/libm/machine/spu/sf_log1p.c b/newlib/libm/machine/spu/sf_log1p.c
index 8ea8a37..18982dd 100644
--- a/newlib/libm/machine/spu/sf_log1p.c
+++ b/newlib/libm/machine/spu/sf_log1p.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log1pf.h"
 
 float log1pf(float x)
 {
+  __A_VARIABLE = 1;
   return _log1pf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_logb.c b/newlib/libm/machine/spu/sf_logb.c
index 2aca486..e54d5d6 100644
--- a/newlib/libm/machine/spu/sf_logb.c
+++ b/newlib/libm/machine/spu/sf_logb.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/logbf.h"
 
 float logbf(float x)
 {
+  __A_VARIABLE = 1;
   return _logbf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_lrint.c b/newlib/libm/machine/spu/sf_lrint.c
index dd96610..83e378b 100644
--- a/newlib/libm/machine/spu/sf_lrint.c
+++ b/newlib/libm/machine/spu/sf_lrint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lrintf.h"
 
 long int lrintf(float x)
 {
+    __A_VARIABLE = 1;
     return _lrintf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_lround.c b/newlib/libm/machine/spu/sf_lround.c
index 250467b..7bd9fb3 100644
--- a/newlib/libm/machine/spu/sf_lround.c
+++ b/newlib/libm/machine/spu/sf_lround.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lroundf.h"
 
 long int lroundf(float x)
 {
+    __A_VARIABLE = 1;
     return _lroundf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_nan.c b/newlib/libm/machine/spu/sf_nan.c
index ef994c7..50a70a2 100644
--- a/newlib/libm/machine/spu/sf_nan.c
+++ b/newlib/libm/machine/spu/sf_nan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
   (C) Copyright 2007
   International Business Machines Corporation,
@@ -38,5 +39,6 @@
 float
 nanf(const char *unused)
 {
+	__A_VARIABLE = 1;
 	return 0;
 }
diff --git a/newlib/libm/machine/spu/sf_nearbyint.c b/newlib/libm/machine/spu/sf_nearbyint.c
index d55329b..30dca06 100644
--- a/newlib/libm/machine/spu/sf_nearbyint.c
+++ b/newlib/libm/machine/spu/sf_nearbyint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/nearbyintf.h"
 
 float nearbyintf(float x)
 {
+  __A_VARIABLE = 1;
   return _nearbyintf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_nextafter.c b/newlib/libm/machine/spu/sf_nextafter.c
index 408ed41..bd62105 100644
--- a/newlib/libm/machine/spu/sf_nextafter.c
+++ b/newlib/libm/machine/spu/sf_nextafter.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/nextafterf.h"
 
 float nextafterf(float x, float y)
 {
+  __A_VARIABLE = 1;
   return _nextafterf(x, y);
 }
diff --git a/newlib/libm/machine/spu/sf_remquo.c b/newlib/libm/machine/spu/sf_remquo.c
index 3494398..5daba3b 100644
--- a/newlib/libm/machine/spu/sf_remquo.c
+++ b/newlib/libm/machine/spu/sf_remquo.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/remquof.h"
 
 float remquof(float x, float y, int *quo)
 {
+    __A_VARIABLE = 1;
     return _remquof(x, y, quo);
 }
diff --git a/newlib/libm/machine/spu/sf_rint.c b/newlib/libm/machine/spu/sf_rint.c
index 777dfd6..104500b 100644
--- a/newlib/libm/machine/spu/sf_rint.c
+++ b/newlib/libm/machine/spu/sf_rint.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/rintf.h"
 
 float rintf(float x)
 {
+  __A_VARIABLE = 1;
   return _rintf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_round.c b/newlib/libm/machine/spu/sf_round.c
index 62a68f6..a177ac0 100644
--- a/newlib/libm/machine/spu/sf_round.c
+++ b/newlib/libm/machine/spu/sf_round.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/roundf.h"
 
 float roundf(float x)
 {
+    __A_VARIABLE = 1;
     return _roundf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_scalbn.c b/newlib/libm/machine/spu/sf_scalbn.c
index 67824df..42b1276 100644
--- a/newlib/libm/machine/spu/sf_scalbn.c
+++ b/newlib/libm/machine/spu/sf_scalbn.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/scalbnf.h"
 
 float scalbnf(float x, int exp)
 {
+    __A_VARIABLE = 1;
     return _scalbnf(x, exp);
 }
diff --git a/newlib/libm/machine/spu/sf_sin.c b/newlib/libm/machine/spu/sf_sin.c
index ac8d2a3..eb81efd 100644
--- a/newlib/libm/machine/spu/sf_sin.c
+++ b/newlib/libm/machine/spu/sf_sin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sinf.h"
 
 float sinf(float angle)
 {
+  __A_VARIABLE = 1;
   return _sinf(angle);
 }
diff --git a/newlib/libm/machine/spu/sf_tan.c b/newlib/libm/machine/spu/sf_tan.c
index 511106b..2483d79 100644
--- a/newlib/libm/machine/spu/sf_tan.c
+++ b/newlib/libm/machine/spu/sf_tan.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tanf.h"
 
 float tanf(float angle)
 {
+  __A_VARIABLE = 1;
   return _tanf(angle);
 }
diff --git a/newlib/libm/machine/spu/sf_tanh.c b/newlib/libm/machine/spu/sf_tanh.c
index 65c3f9b..fc9daaf 100644
--- a/newlib/libm/machine/spu/sf_tanh.c
+++ b/newlib/libm/machine/spu/sf_tanh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tanhf.h"
 
 float tanhf(float x)
 {
+  __A_VARIABLE = 1;
   return _tanhf(x);
 }
diff --git a/newlib/libm/machine/spu/sf_trunc.c b/newlib/libm/machine/spu/sf_trunc.c
index 4a7ab88..d71267d 100644
--- a/newlib/libm/machine/spu/sf_trunc.c
+++ b/newlib/libm/machine/spu/sf_trunc.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/truncf.h"
 
 float truncf(float x)
 {
+    __A_VARIABLE = 1;
     return _truncf(x);
 }
diff --git a/newlib/libm/machine/spu/w_acos.c b/newlib/libm/machine/spu/w_acos.c
index 412198c..304dabb 100644
--- a/newlib/libm/machine/spu/w_acos.c
+++ b/newlib/libm/machine/spu/w_acos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/acos.h"
 
 double acos(double x)
 {
+  __A_VARIABLE = 1;
   return _acos(x);
 }
diff --git a/newlib/libm/machine/spu/w_acosh.c b/newlib/libm/machine/spu/w_acosh.c
index b05f4a4..ba32515 100644
--- a/newlib/libm/machine/spu/w_acosh.c
+++ b/newlib/libm/machine/spu/w_acosh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/acosh.h"
 
 double acosh(double x)
 {
+  __A_VARIABLE = 1;
   return _acosh(x);
 }
diff --git a/newlib/libm/machine/spu/w_asin.c b/newlib/libm/machine/spu/w_asin.c
index 142ed2b..e43cf1d 100644
--- a/newlib/libm/machine/spu/w_asin.c
+++ b/newlib/libm/machine/spu/w_asin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/asin.h"
 
 double asin(double x)
 {
+  __A_VARIABLE = 1;
   return _asin(x);
 }
diff --git a/newlib/libm/machine/spu/w_atan2.c b/newlib/libm/machine/spu/w_atan2.c
index fb690c4..71817db 100644
--- a/newlib/libm/machine/spu/w_atan2.c
+++ b/newlib/libm/machine/spu/w_atan2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atan2.h"
 
 double atan2(double y, double x)
 {
+  __A_VARIABLE = 1;
   return _atan2(y, x);
 }
diff --git a/newlib/libm/machine/spu/w_atanh.c b/newlib/libm/machine/spu/w_atanh.c
index 8d4c2ce..16faf60 100644
--- a/newlib/libm/machine/spu/w_atanh.c
+++ b/newlib/libm/machine/spu/w_atanh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atanh.h"
 
 double atanh(double x)
 {
+  __A_VARIABLE = 1;
   return _atanh(x);
 }
diff --git a/newlib/libm/machine/spu/w_cosh.c b/newlib/libm/machine/spu/w_cosh.c
index 5fb77eb..8ee71b7 100644
--- a/newlib/libm/machine/spu/w_cosh.c
+++ b/newlib/libm/machine/spu/w_cosh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/cosh.h"
 
 double cosh(double x)
 {
+  __A_VARIABLE = 1;
   return _cosh(x);
 }
diff --git a/newlib/libm/machine/spu/w_exp.c b/newlib/libm/machine/spu/w_exp.c
index 3f00afa..da95db0 100644
--- a/newlib/libm/machine/spu/w_exp.c
+++ b/newlib/libm/machine/spu/w_exp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/exp.h"
 
 double exp(double x)
 {
+  __A_VARIABLE = 1;
   return _exp(x);
 }
diff --git a/newlib/libm/machine/spu/w_exp2.c b/newlib/libm/machine/spu/w_exp2.c
index c8933bc..9675a6b 100644
--- a/newlib/libm/machine/spu/w_exp2.c
+++ b/newlib/libm/machine/spu/w_exp2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/exp2.h"
 
 double exp2(double vx)
 {
+  __A_VARIABLE = 1;
   return _exp2(vx);
 }
diff --git a/newlib/libm/machine/spu/w_fmod.c b/newlib/libm/machine/spu/w_fmod.c
index 29704bc..49a3b50 100644
--- a/newlib/libm/machine/spu/w_fmod.c
+++ b/newlib/libm/machine/spu/w_fmod.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmod.h"
 
 double fmod(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _fmod(x, y);
 }
diff --git a/newlib/libm/machine/spu/w_hypot.c b/newlib/libm/machine/spu/w_hypot.c
index 93db031..7470f7f 100644
--- a/newlib/libm/machine/spu/w_hypot.c
+++ b/newlib/libm/machine/spu/w_hypot.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/hypot.h"
 
 double hypot(double x, double y)
 {
+  __A_VARIABLE = 1;
   return _hypot(x, y);
 }
diff --git a/newlib/libm/machine/spu/w_lgamma.c b/newlib/libm/machine/spu/w_lgamma.c
index f092adb..f55e7a3 100644
--- a/newlib/libm/machine/spu/w_lgamma.c
+++ b/newlib/libm/machine/spu/w_lgamma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lgamma.h"
 
 double lgamma(double x)
 {
+  __A_VARIABLE = 1;
   return _lgamma(x);
 }
diff --git a/newlib/libm/machine/spu/w_log.c b/newlib/libm/machine/spu/w_log.c
index b224dbc..597b144 100644
--- a/newlib/libm/machine/spu/w_log.c
+++ b/newlib/libm/machine/spu/w_log.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log.h"
 
 double log(double x)
 {
+  __A_VARIABLE = 1;
   return _log(x);
 }
diff --git a/newlib/libm/machine/spu/w_log10.c b/newlib/libm/machine/spu/w_log10.c
index b761875..2c57a5f 100644
--- a/newlib/libm/machine/spu/w_log10.c
+++ b/newlib/libm/machine/spu/w_log10.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log10.h"
 
 double log10(double x)
 {
+  __A_VARIABLE = 1;
   return _log10(x);
 }
diff --git a/newlib/libm/machine/spu/w_pow.c b/newlib/libm/machine/spu/w_pow.c
index a1afe43..1a4f2ad 100644
--- a/newlib/libm/machine/spu/w_pow.c
+++ b/newlib/libm/machine/spu/w_pow.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/pow.h"
 
 double pow(double x, double y)
 {
+  __A_VARIABLE = 1;
   return _pow(x, y);
 }
diff --git a/newlib/libm/machine/spu/w_remainder.c b/newlib/libm/machine/spu/w_remainder.c
index c87627b..fd56365 100644
--- a/newlib/libm/machine/spu/w_remainder.c
+++ b/newlib/libm/machine/spu/w_remainder.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/remainder.h"
 
 double remainder(double x, double y)
 {
+    __A_VARIABLE = 1;
     return _remainder(x, y);
 }
diff --git a/newlib/libm/machine/spu/w_sincos.c b/newlib/libm/machine/spu/w_sincos.c
index 0ea1244..98a6ebe 100644
--- a/newlib/libm/machine/spu/w_sincos.c
+++ b/newlib/libm/machine/spu/w_sincos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sincos.h"
 
 void sincos(double angle, double* sinx, double* cosx)
 {
+  __A_VARIABLE = 1;
   return _sincos(angle, sinx, cosx);
 }
diff --git a/newlib/libm/machine/spu/w_sinh.c b/newlib/libm/machine/spu/w_sinh.c
index 0077296..3d38cc1 100644
--- a/newlib/libm/machine/spu/w_sinh.c
+++ b/newlib/libm/machine/spu/w_sinh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sinh.h"
 
 double sinh(double x)
 {
+  __A_VARIABLE = 1;
   return _sinh(x);
 }
diff --git a/newlib/libm/machine/spu/w_sqrt.c b/newlib/libm/machine/spu/w_sqrt.c
index 359ffcc..7053b52 100644
--- a/newlib/libm/machine/spu/w_sqrt.c
+++ b/newlib/libm/machine/spu/w_sqrt.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sqrt.h"
 
 double sqrt(double in)
 {
+    __A_VARIABLE = 1;
     return _sqrt(in);
 }
diff --git a/newlib/libm/machine/spu/w_tgamma.c b/newlib/libm/machine/spu/w_tgamma.c
index 98dd52d..00bc2dd 100644
--- a/newlib/libm/machine/spu/w_tgamma.c
+++ b/newlib/libm/machine/spu/w_tgamma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tgamma.h"
 
 double tgamma(double x)
 {
+  __A_VARIABLE = 1;
   return _tgamma(x);
 }
diff --git a/newlib/libm/machine/spu/wf_acos.c b/newlib/libm/machine/spu/wf_acos.c
index 8658556..bca4d75 100644
--- a/newlib/libm/machine/spu/wf_acos.c
+++ b/newlib/libm/machine/spu/wf_acos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/acosf.h"
 
 float acosf(float x)
 {
+  __A_VARIABLE = 1;
   return _acosf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_acosh.c b/newlib/libm/machine/spu/wf_acosh.c
index 1e729ae..af963d9 100644
--- a/newlib/libm/machine/spu/wf_acosh.c
+++ b/newlib/libm/machine/spu/wf_acosh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/acoshf.h"
 
 float acoshf(float x)
 {
+  __A_VARIABLE = 1;
   return _acoshf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_asin.c b/newlib/libm/machine/spu/wf_asin.c
index c3fab30..a48ee9d 100644
--- a/newlib/libm/machine/spu/wf_asin.c
+++ b/newlib/libm/machine/spu/wf_asin.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/asinf.h"
 
 float asinf(float x)
 {
+  __A_VARIABLE = 1;
   return _asinf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_atan2.c b/newlib/libm/machine/spu/wf_atan2.c
index 2a22f53..b251632 100644
--- a/newlib/libm/machine/spu/wf_atan2.c
+++ b/newlib/libm/machine/spu/wf_atan2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atan2f.h"
 
 float atan2f(float y, float x)
 {
+  __A_VARIABLE = 1;
   return _atan2f(y, x);
 }
diff --git a/newlib/libm/machine/spu/wf_atanh.c b/newlib/libm/machine/spu/wf_atanh.c
index 8a80174..914cf55 100644
--- a/newlib/libm/machine/spu/wf_atanh.c
+++ b/newlib/libm/machine/spu/wf_atanh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/atanhf.h"
 
 float atanhf(float x)
 {
+  __A_VARIABLE = 1;
   return _atanhf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_cosh.c b/newlib/libm/machine/spu/wf_cosh.c
index 6a0f15c..78401fd 100644
--- a/newlib/libm/machine/spu/wf_cosh.c
+++ b/newlib/libm/machine/spu/wf_cosh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/coshf.h"
 
 float coshf(float x)
 {
+  __A_VARIABLE = 1;
   return _coshf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_exp.c b/newlib/libm/machine/spu/wf_exp.c
index 9a0f905..53785d6 100644
--- a/newlib/libm/machine/spu/wf_exp.c
+++ b/newlib/libm/machine/spu/wf_exp.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/expf.h"
 
 float expf(float x)
 {
+    __A_VARIABLE = 1;
     return _expf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_exp2.c b/newlib/libm/machine/spu/wf_exp2.c
index c815cee..cd9e0c2 100644
--- a/newlib/libm/machine/spu/wf_exp2.c
+++ b/newlib/libm/machine/spu/wf_exp2.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/exp2f.h"
 
 float exp2f(float x)
 {
+    __A_VARIABLE = 1;
     return _exp2f(x);
 }
diff --git a/newlib/libm/machine/spu/wf_fmod.c b/newlib/libm/machine/spu/wf_fmod.c
index b7b8c27..b37fc93 100644
--- a/newlib/libm/machine/spu/wf_fmod.c
+++ b/newlib/libm/machine/spu/wf_fmod.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/fmodf.h"
 
 float fmodf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _fmodf(x, y);
 }
diff --git a/newlib/libm/machine/spu/wf_hypot.c b/newlib/libm/machine/spu/wf_hypot.c
index f9d8850..9f0a469 100644
--- a/newlib/libm/machine/spu/wf_hypot.c
+++ b/newlib/libm/machine/spu/wf_hypot.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/hypotf.h"
 
 float hypotf(float x, float y)
 {
+  __A_VARIABLE = 1;
   return _hypotf(x, y);
 }
diff --git a/newlib/libm/machine/spu/wf_lgamma.c b/newlib/libm/machine/spu/wf_lgamma.c
index 6b0824a..e607ff1 100644
--- a/newlib/libm/machine/spu/wf_lgamma.c
+++ b/newlib/libm/machine/spu/wf_lgamma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/lgammaf.h"
 
 float lgammaf(float x)
 {
+  __A_VARIABLE = 1;
   return _lgammaf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_log.c b/newlib/libm/machine/spu/wf_log.c
index e788dea..1871e19 100644
--- a/newlib/libm/machine/spu/wf_log.c
+++ b/newlib/libm/machine/spu/wf_log.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/logf.h"
 
 float logf(float x)
 {
+    __A_VARIABLE = 1;
     return _logf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_log10.c b/newlib/libm/machine/spu/wf_log10.c
index f3d2c9f..0480d24 100644
--- a/newlib/libm/machine/spu/wf_log10.c
+++ b/newlib/libm/machine/spu/wf_log10.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/log10f.h"
 
 float log10f(float x)
 {
+    __A_VARIABLE = 1;
     return _log10f(x);
 }
diff --git a/newlib/libm/machine/spu/wf_pow.c b/newlib/libm/machine/spu/wf_pow.c
index 7996656..3d91a06 100644
--- a/newlib/libm/machine/spu/wf_pow.c
+++ b/newlib/libm/machine/spu/wf_pow.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/powf.h"
 
 float powf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _powf(x, y);
 }
diff --git a/newlib/libm/machine/spu/wf_remainder.c b/newlib/libm/machine/spu/wf_remainder.c
index 84508ce..5d2919e 100644
--- a/newlib/libm/machine/spu/wf_remainder.c
+++ b/newlib/libm/machine/spu/wf_remainder.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/remainderf.h"
 
 float remainderf(float x, float y)
 {
+    __A_VARIABLE = 1;
     return _remainderf(x, y);
 }
diff --git a/newlib/libm/machine/spu/wf_sincos.c b/newlib/libm/machine/spu/wf_sincos.c
index 6dc4d0c..2d18a65 100644
--- a/newlib/libm/machine/spu/wf_sincos.c
+++ b/newlib/libm/machine/spu/wf_sincos.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sincosf.h"
 
 void sincosf(float angle, float* sinx, float* cosx)
 {
+  __A_VARIABLE = 1;
   return _sincosf(angle, sinx, cosx);
 }
diff --git a/newlib/libm/machine/spu/wf_sinh.c b/newlib/libm/machine/spu/wf_sinh.c
index 413e7b5..94d9a15 100644
--- a/newlib/libm/machine/spu/wf_sinh.c
+++ b/newlib/libm/machine/spu/wf_sinh.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sinhf.h"
 
 float sinhf(float x)
 {
+  __A_VARIABLE = 1;
   return _sinhf(x);
 }
diff --git a/newlib/libm/machine/spu/wf_sqrt.c b/newlib/libm/machine/spu/wf_sqrt.c
index 78eccb4..15fd7d3 100644
--- a/newlib/libm/machine/spu/wf_sqrt.c
+++ b/newlib/libm/machine/spu/wf_sqrt.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/sqrtf.h"
 
 float sqrtf(float in)
 {
+  __A_VARIABLE = 1;
   return _sqrtf(in);
 }
diff --git a/newlib/libm/machine/spu/wf_tgamma.c b/newlib/libm/machine/spu/wf_tgamma.c
index 161f505..38110f3 100644
--- a/newlib/libm/machine/spu/wf_tgamma.c
+++ b/newlib/libm/machine/spu/wf_tgamma.c
@@ -1,7 +1,9 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include "headers/tgammaf.h"
 
 float tgammaf(float x)
 {
+  __A_VARIABLE = 1;
   return _tgammaf(x);
 }
diff --git a/newlib/libm/math/e_acos.c b/newlib/libm/math/e_acos.c
index 319b1d5..292753a 100644
--- a/newlib/libm/math/e_acos.c
+++ b/newlib/libm/math/e_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_acos.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_acosh.c b/newlib/libm/math/e_acosh.c
index 27984eb..3a81436 100644
--- a/newlib/libm/math/e_acosh.c
+++ b/newlib/libm/math/e_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_acosh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_asin.c b/newlib/libm/math/e_asin.c
index 4b6f45e..4e3732e 100644
--- a/newlib/libm/math/e_asin.c
+++ b/newlib/libm/math/e_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_asin.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_atan2.c b/newlib/libm/math/e_atan2.c
index 8e9650f..92d6ac0 100644
--- a/newlib/libm/math/e_atan2.c
+++ b/newlib/libm/math/e_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_atan2.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_atanh.c b/newlib/libm/math/e_atanh.c
index 58ad325..9a775e8 100644
--- a/newlib/libm/math/e_atanh.c
+++ b/newlib/libm/math/e_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_atanh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_cosh.c b/newlib/libm/math/e_cosh.c
index a6310bd..b5ec389 100644
--- a/newlib/libm/math/e_cosh.c
+++ b/newlib/libm/math/e_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_cosh.c 5.1 93/09/24 */
 /*
@@ -58,24 +59,35 @@ static double one = 1.0, half=0.5, huge = 1.0e300;
 	ix &= 0x7fffffff;
 
     /* x is INF or NaN */
-	if(ix>=0x7ff00000) return x*x;	
+	if(ix>=0x7ff00000) {
+	    __A_VARIABLE = 1;
+	    return x*x;
+	}	
 
     /* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
 	if(ix<0x3fd62e43) {
 	    t = expm1(fabs(x));
 	    w = one+t;
-	    if (ix<0x3c800000) return w;	/* cosh(tiny) = 1 */
+	    if (ix<0x3c800000) {
+	        __A_VARIABLE = 1;
+	        return w;
+	    }	/* cosh(tiny) = 1 */
+	    __A_VARIABLE = 1;
 	    return one+(t*t)/(w+w);
 	}
 
     /* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
 	if (ix < 0x40360000) {
 		t = __ieee754_exp(fabs(x));
+		__A_VARIABLE = 1;
 		return half*t+half/t;
 	}
 
     /* |x| in [22, log(maxdouble)] return half*exp(|x|) */
-	if (ix < 0x40862E42)  return half*__ieee754_exp(fabs(x));
+	if (ix < 0x40862E42)  {
+		__A_VARIABLE = 1;
+		return half*__ieee754_exp(fabs(x));
+	}
 
     /* |x| in [log(maxdouble), overflowthresold] */
 	GET_LOW_WORD(lx,x);
@@ -83,10 +95,12 @@ static double one = 1.0, half=0.5, huge = 1.0e300;
              (ix==0x408633ce && lx<=(__uint32_t)0x8fb9f87d)) {
 	    w = __ieee754_exp(half*fabs(x));
 	    t = half*w;
+	    __A_VARIABLE = 1;
 	    return t*w;
 	}
 
     /* |x| > overflowthresold, cosh(x) overflow */
+	__A_VARIABLE = 1;
 	return huge*huge;
 }
 
diff --git a/newlib/libm/math/e_exp.c b/newlib/libm/math/e_exp.c
index e7455ee..f6cd66e 100644
--- a/newlib/libm/math/e_exp.c
+++ b/newlib/libm/math/e_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_exp.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_fmod.c b/newlib/libm/math/e_fmod.c
index f9739ee..4471a48 100644
--- a/newlib/libm/math/e_fmod.c
+++ b/newlib/libm/math/e_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_fmod.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_hypot.c b/newlib/libm/math/e_hypot.c
index 03f7f51..bfe6436 100644
--- a/newlib/libm/math/e_hypot.c
+++ b/newlib/libm/math/e_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_hypot.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_j0.c b/newlib/libm/math/e_j0.c
index 13773cb..aba8989 100644
--- a/newlib/libm/math/e_j0.c
+++ b/newlib/libm/math/e_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_j0.c 5.1 93/09/24 */
 /*
@@ -173,9 +174,18 @@ v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */
 	EXTRACT_WORDS(hx,lx,x);
         ix = 0x7fffffff&hx;
     /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
-	if(ix>=0x7ff00000) return  one/(x+x*x); 
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7ff00000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if((ix|lx)==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
@@ -206,14 +216,17 @@ v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */
                     u = pzero(x); v = qzero(x);
                     z = invsqrtpi*(u*ss+v*cc)/__ieee754_sqrt(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
 	}
 	if(ix<=0x3e400000) {	/* x < 2**-27 */
+	    __A_VARIABLE = 1;
 	    return(u00 + tpi*__ieee754_log(x));
 	}
 	z = x*x;
 	u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
 	v = one+z*(v01+z*(v02+z*(v03+z*v04)));
+	__A_VARIABLE = 1;
 	return(u/v + tpi*(__ieee754_j0(x)*__ieee754_log(x)));
 }
 
@@ -345,6 +358,7 @@ static double pS2[5] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+	__A_VARIABLE = 1;
 	return one+ r/s;
 }
 		
@@ -481,6 +495,7 @@ static double qS2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (-.125 + r/s)/x;
 }
 
diff --git a/newlib/libm/math/e_j1.c b/newlib/libm/math/e_j1.c
index 098eb56..f72d731 100644
--- a/newlib/libm/math/e_j1.c
+++ b/newlib/libm/math/e_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_j1.c 5.1 93/09/24 */
 /*
@@ -174,9 +175,18 @@ static double V0[5] = {
 	EXTRACT_WORDS(hx,lx,x);
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
-	if(ix>=0x7ff00000) return  one/(x+x*x); 
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7ff00000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if((ix|lx)==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
                 s = sin(x);
                 c = cos(x);
@@ -203,14 +213,17 @@ static double V0[5] = {
                     u = pone(x); v = qone(x);
                     z = invsqrtpi*(u*ss+v*cc)/__ieee754_sqrt(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
         } 
         if(ix<=0x3c900000) {    /* x < 2**-54 */
+            __A_VARIABLE = 1;
             return(-tpi/x);
         } 
         z = x*x;
         u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
         v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
+        __A_VARIABLE = 1;
         return(x*(u/v) + tpi*(__ieee754_j1(x)*__ieee754_log(x)-one/x));
 }
 
@@ -343,6 +356,7 @@ static double ps2[5] = {
         z = one/(x*x);
         r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
         s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+        __A_VARIABLE = 1;
         return one+ r/s;
 }
 		
@@ -480,6 +494,7 @@ static double qs2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (.375 + r/s)/x;
 }
 
diff --git a/newlib/libm/math/e_jn.c b/newlib/libm/math/e_jn.c
index 1eea27b..003abf6 100644
--- a/newlib/libm/math/e_jn.c
+++ b/newlib/libm/math/e_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_jn.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_log.c b/newlib/libm/math/e_log.c
index 72cddb2..13d49a6 100644
--- a/newlib/libm/math/e_log.c
+++ b/newlib/libm/math/e_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_log.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_log10.c b/newlib/libm/math/e_log10.c
index f7daaa1..53f1f3c 100644
--- a/newlib/libm/math/e_log10.c
+++ b/newlib/libm/math/e_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_log10.c 5.1 93/09/24 */
 /*
@@ -79,19 +80,28 @@ static double zero   =  0.0;
 
         k=0;
         if (hx < 0x00100000) {                  /* x < 2**-1022  */
-            if (((hx&0x7fffffff)|lx)==0)
-                return -two54/zero;             /* log(+-0)=-inf */
-            if (hx<0) return (x-x)/zero;        /* log(-#) = NaN */
+            if (((hx&0x7fffffff)|lx)==0) {
+                __A_VARIABLE = 1;
+                return -two54/zero;
+            }             /* log(+-0)=-inf */
+            if (hx<0) {
+                __A_VARIABLE = 1;
+                return (x-x)/zero;
+            }        /* log(-#) = NaN */
             k -= 54; x *= two54; /* subnormal number, scale up x */
 	    GET_HIGH_WORD(hx,x);
         }
-	if (hx >= 0x7ff00000) return x+x;
+	if (hx >= 0x7ff00000) {
+	    __A_VARIABLE = 1;
+	    return x+x;
+	}
 	k += (hx>>20)-1023;
 	i  = ((__uint32_t)k&0x80000000)>>31;
         hx = (hx&0x000fffff)|((0x3ff-i)<<20);
         y  = (double)(k+i);
 	SET_HIGH_WORD(x,hx);
 	z  = y*log10_2lo + ivln10*__ieee754_log(x);
+	__A_VARIABLE = 1;
 	return  z+y*log10_2hi;
 }
 
diff --git a/newlib/libm/math/e_pow.c b/newlib/libm/math/e_pow.c
index cad6737..d8ff0c7 100644
--- a/newlib/libm/math/e_pow.c
+++ b/newlib/libm/math/e_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_pow.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_rem_pio2.c b/newlib/libm/math/e_rem_pio2.c
index ddfecba..d1b2586 100644
--- a/newlib/libm/math/e_rem_pio2.c
+++ b/newlib/libm/math/e_rem_pio2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_rem_pio2.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_remainder.c b/newlib/libm/math/e_remainder.c
index ae7ce64..98c752a 100644
--- a/newlib/libm/math/e_remainder.c
+++ b/newlib/libm/math/e_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_remainder.c 5.1 93/09/24 */
 /*
@@ -49,15 +50,23 @@ static double zero = 0.0;
 	hx &= 0x7fffffff;
 
     /* purge off exception values */
-	if((hp|lp)==0) return (x*p)/(x*p); 	/* p = 0 */
+	if((hp|lp)==0) {
+	    __A_VARIABLE = 1;
+	    return (x*p)/(x*p);
+	} 	/* p = 0 */
 	if((hx>=0x7ff00000)||			/* x not finite */
 	  ((hp>=0x7ff00000)&&			/* p is NaN */
-	  (((hp-0x7ff00000)|lp)!=0)))
+	  (((hp-0x7ff00000)|lp)!=0))) {
+	    __A_VARIABLE = 1;
 	    return (x*p)/(x*p);
+	}
 
 
 	if (hp<=0x7fdfffff) x = __ieee754_fmod(x,p+p);	/* now x < 2p */
-	if (((hx-hp)|(lx-lp))==0) return zero*x;
+	if (((hx-hp)|(lx-lp))==0) {
+	    __A_VARIABLE = 1;
+	    return zero*x;
+	}
 	x  = fabs(x);
 	p  = fabs(p);
 	if (hp<0x00200000) {
@@ -74,6 +83,7 @@ static double zero = 0.0;
 	}
 	GET_HIGH_WORD(hx,x);
 	SET_HIGH_WORD(x,hx^sx);
+	__A_VARIABLE = 1;
 	return x;
 }
 
diff --git a/newlib/libm/math/e_scalb.c b/newlib/libm/math/e_scalb.c
index 0bb924b..2d9b42b 100644
--- a/newlib/libm/math/e_scalb.c
+++ b/newlib/libm/math/e_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_scalb.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/e_sinh.c b/newlib/libm/math/e_sinh.c
index cf7ebfb..f665db7 100644
--- a/newlib/libm/math/e_sinh.c
+++ b/newlib/libm/math/e_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_sinh.c 5.1 93/09/24 */
 /*
@@ -55,31 +56,46 @@ static double one = 1.0, shuge = 1.0e307;
 	ix = jx&0x7fffffff;
 
     /* x is INF or NaN */
-	if(ix>=0x7ff00000) return x+x;	
+	if(ix>=0x7ff00000) {
+	    __A_VARIABLE = 1;
+	    return x+x;
+	}	
 
 	h = 0.5;
 	if (jx<0) h = -h;
     /* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
 	if (ix < 0x40360000) {		/* |x|<22 */
 	    if (ix<0x3e300000) 		/* |x|<2**-28 */
-		if(shuge+x>one) return x;/* sinh(tiny) = tiny with inexact */
+		if(shuge+x>one) {
+			__A_VARIABLE = 1;
+			return x;
+		}/* sinh(tiny) = tiny with inexact */
 	    t = expm1(fabs(x));
-	    if(ix<0x3ff00000) return h*(2.0*t-t*t/(t+one));
+	    if(ix<0x3ff00000) {
+		__A_VARIABLE = 1;
+		return h*(2.0*t-t*t/(t+one));
+	    }
+	    __A_VARIABLE = 1;
 	    return h*(t+t/(t+one));
 	}
 
     /* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
-	if (ix < 0x40862E42)  return h*__ieee754_exp(fabs(x));
+	if (ix < 0x40862E42)  {
+	    __A_VARIABLE = 1;
+	    return h*__ieee754_exp(fabs(x));
+	}
 
     /* |x| in [log(maxdouble), overflowthresold] */
 	GET_LOW_WORD(lx,x);
        if (ix<0x408633CE || (ix==0x408633ce && lx<=(__uint32_t)0x8fb9f87d)) {
 	    w = __ieee754_exp(0.5*fabs(x));
 	    t = h*w;
+	    __A_VARIABLE = 1;
 	    return t*w;
 	}
 
     /* |x| > overflowthresold, sinh(x) overflow */
+	__A_VARIABLE = 1;
 	return x*shuge;
 }
 
diff --git a/newlib/libm/math/e_sqrt.c b/newlib/libm/math/e_sqrt.c
index 78fc524..e616628 100644
--- a/newlib/libm/math/e_sqrt.c
+++ b/newlib/libm/math/e_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_sqrt.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/ef_acos.c b/newlib/libm/math/ef_acos.c
index f73f97d..e4ff0f5 100644
--- a/newlib/libm/math/ef_acos.c
+++ b/newlib/libm/math/ef_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_acos.c -- float version of e_acos.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_acosh.c b/newlib/libm/math/ef_acosh.c
index 1119c2c..0809934 100644
--- a/newlib/libm/math/ef_acosh.c
+++ b/newlib/libm/math/ef_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_acosh.c -- float version of e_acosh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_asin.c b/newlib/libm/math/ef_asin.c
index c49dcbb..60f00f6 100644
--- a/newlib/libm/math/ef_asin.c
+++ b/newlib/libm/math/ef_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_asin.c -- float version of e_asin.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_atan2.c b/newlib/libm/math/ef_atan2.c
index d57480b..a967052 100644
--- a/newlib/libm/math/ef_atan2.c
+++ b/newlib/libm/math/ef_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_atan2.c -- float version of e_atan2.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_atanh.c b/newlib/libm/math/ef_atanh.c
index 74b3d3d..9622cdc 100644
--- a/newlib/libm/math/ef_atanh.c
+++ b/newlib/libm/math/ef_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_atanh.c -- float version of e_atanh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_cosh.c b/newlib/libm/math/ef_cosh.c
index bdce61a..de68d4d 100644
--- a/newlib/libm/math/ef_cosh.c
+++ b/newlib/libm/math/ef_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_cosh.c -- float version of e_cosh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -39,33 +40,45 @@ static float one = 1.0, half=0.5, huge = 1.0e30;
 	ix &= 0x7fffffff;
 
     /* x is INF or NaN */
-	if(!FLT_UWORD_IS_FINITE(ix)) return x*x;	
+	if(!FLT_UWORD_IS_FINITE(ix)) {
+	    __A_VARIABLE = 1;
+	    return x*x;
+	}	
 
     /* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
 	if(ix<0x3eb17218) {
 	    t = expm1f(fabsf(x));
 	    w = one+t;
-	    if (ix<0x24000000) return w;	/* cosh(tiny) = 1 */
+	    if (ix<0x24000000) {
+	        __A_VARIABLE = 1;
+	        return w;
+	    }	/* cosh(tiny) = 1 */
+	    __A_VARIABLE = 1;
 	    return one+(t*t)/(w+w);
 	}
 
     /* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
 	if (ix < 0x41b00000) {
 		t = __ieee754_expf(fabsf(x));
+		__A_VARIABLE = 1;
 		return half*t+half/t;
 	}
 
     /* |x| in [22, log(maxdouble)] return half*exp(|x|) */
-	if (ix <= FLT_UWORD_LOG_MAX)
+	if (ix <= FLT_UWORD_LOG_MAX) {
+	  __A_VARIABLE = 1;
 	  return half*__ieee754_expf(fabsf(x));
+	}
 
     /* |x| in [log(maxdouble), overflowthresold] */
 	if (ix <= FLT_UWORD_LOG_2MAX) {
 	    w = __ieee754_expf(half*fabsf(x));
 	    t = half*w;
+	    __A_VARIABLE = 1;
 	    return t*w;
 	}
 
     /* |x| > overflowthresold, cosh(x) overflow */
+	__A_VARIABLE = 1;
 	return huge*huge;
 }
diff --git a/newlib/libm/math/ef_exp.c b/newlib/libm/math/ef_exp.c
index 6824f99..fdd0f1c 100644
--- a/newlib/libm/math/ef_exp.c
+++ b/newlib/libm/math/ef_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_exp.c -- float version of e_exp.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_fmod.c b/newlib/libm/math/ef_fmod.c
index 53c1ba2..e8ef020 100644
--- a/newlib/libm/math/ef_fmod.c
+++ b/newlib/libm/math/ef_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_fmod.c -- float version of e_fmod.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_hypot.c b/newlib/libm/math/ef_hypot.c
index 9368eb4..c52e48b 100644
--- a/newlib/libm/math/ef_hypot.c
+++ b/newlib/libm/math/ef_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_hypot.c -- float version of e_hypot.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_j0.c b/newlib/libm/math/ef_j0.c
index 866cfcf..e40ac23 100644
--- a/newlib/libm/math/ef_j0.c
+++ b/newlib/libm/math/ef_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_j0.c -- float version of e_j0.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -128,9 +129,18 @@ v04  =  4.4111031494e-10; /* 0x2ff280c2 */
 	GET_FLOAT_WORD(hx,x);
         ix = 0x7fffffff&hx;
     /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
-	if(!FLT_UWORD_IS_FINITE(ix)) return  one/(x+x*x); 
-        if(FLT_UWORD_IS_ZERO(ix)) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(!FLT_UWORD_IS_FINITE(ix)) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if(FLT_UWORD_IS_ZERO(ix)) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
@@ -161,14 +171,17 @@ v04  =  4.4111031494e-10; /* 0x2ff280c2 */
                     u = pzerof(x); v = qzerof(x);
                     z = invsqrtpi*(u*ss+v*cc)/__ieee754_sqrtf(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
 	}
 	if(ix<=0x32000000) {	/* x < 2**-27 */
+	    __A_VARIABLE = 1;
 	    return(u00 + tpi*__ieee754_logf(x));
 	}
 	z = x*x;
 	u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
 	v = one+z*(v01+z*(v02+z*(v03+z*v04)));
+	__A_VARIABLE = 1;
 	return(u/v + tpi*(__ieee754_j0f(x)*__ieee754_logf(x)));
 }
 
@@ -299,6 +312,7 @@ static float pS2[5] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+	__A_VARIABLE = 1;
 	return one+ r/s;
 }
 		
@@ -435,5 +449,6 @@ static float qS2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (-(float).125 + r/s)/x;
 }
diff --git a/newlib/libm/math/ef_j1.c b/newlib/libm/math/ef_j1.c
index 01bd24c..9c76d5c 100644
--- a/newlib/libm/math/ef_j1.c
+++ b/newlib/libm/math/ef_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_j1.c -- float version of e_j1.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -129,9 +130,18 @@ static float V0[5] = {
 	GET_FLOAT_WORD(hx,x);
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
-	if(!FLT_UWORD_IS_FINITE(ix)) return one/(x+x*x); 
-        if(FLT_UWORD_IS_ZERO(ix)) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(!FLT_UWORD_IS_FINITE(ix)) {
+                __A_VARIABLE = 1;
+                return one/(x+x*x);
+        } 
+        if(FLT_UWORD_IS_ZERO(ix)) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
                 s = sinf(x);
                 c = cosf(x);
@@ -158,14 +168,17 @@ static float V0[5] = {
                     u = ponef(x); v = qonef(x);
                     z = invsqrtpi*(u*ss+v*cc)/__ieee754_sqrtf(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
         } 
         if(ix<=0x24800000) {    /* x < 2**-54 */
+            __A_VARIABLE = 1;
             return(-tpi/x);
         } 
         z = x*x;
         u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
         v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
+        __A_VARIABLE = 1;
         return(x*(u/v) + tpi*(__ieee754_j1f(x)*__ieee754_logf(x)-one/x));
 }
 
@@ -298,6 +311,7 @@ static float ps2[5] = {
         z = one/(x*x);
         r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
         s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+        __A_VARIABLE = 1;
         return one+ r/s;
 }
 		
@@ -435,5 +449,6 @@ static float qs2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return ((float).375 + r/s)/x;
 }
diff --git a/newlib/libm/math/ef_jn.c b/newlib/libm/math/ef_jn.c
index bedfb3e..063a08f 100644
--- a/newlib/libm/math/ef_jn.c
+++ b/newlib/libm/math/ef_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_jn.c -- float version of e_jn.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_log.c b/newlib/libm/math/ef_log.c
index 619fe90..bc24aea 100644
--- a/newlib/libm/math/ef_log.c
+++ b/newlib/libm/math/ef_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_log.c -- float version of e_log.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_log10.c b/newlib/libm/math/ef_log10.c
index 5ab23c4..c713704 100644
--- a/newlib/libm/math/ef_log10.c
+++ b/newlib/libm/math/ef_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_log10.c -- float version of e_log10.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -44,10 +45,18 @@ static float zero   =  0.0;
 	GET_FLOAT_WORD(hx,x);
 
         k=0;
-        if (FLT_UWORD_IS_ZERO(hx&0x7fffffff))
-            return -two25/zero;             /* log(+-0)=-inf */
-        if (hx<0) return (x-x)/zero;        /* log(-#) = NaN */
-	if (!FLT_UWORD_IS_FINITE(hx)) return x+x;
+        if (FLT_UWORD_IS_ZERO(hx&0x7fffffff)) {
+            __A_VARIABLE = 1;
+            return -two25/zero;
+        }             /* log(+-0)=-inf */
+        if (hx<0) {
+            __A_VARIABLE = 1;
+            return (x-x)/zero;
+	}        /* log(-#) = NaN */
+	if (!FLT_UWORD_IS_FINITE(hx)) {
+            __A_VARIABLE = 1;
+            return x+x;
+        }
         if (FLT_UWORD_IS_SUBNORMAL(hx)) {
             k -= 25; x *= two25; /* subnormal number, scale up x */
 	    GET_FLOAT_WORD(hx,x);
@@ -58,5 +67,6 @@ static float zero   =  0.0;
         y  = (float)(k+i);
 	SET_FLOAT_WORD(x,hx);
 	z  = y*log10_2lo + ivln10*__ieee754_logf(x);
+	__A_VARIABLE = 1;
 	return  z+y*log10_2hi;
 }
diff --git a/newlib/libm/math/ef_pow.c b/newlib/libm/math/ef_pow.c
index b3041db..4a5e8db 100644
--- a/newlib/libm/math/ef_pow.c
+++ b/newlib/libm/math/ef_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_pow.c -- float version of e_pow.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_rem_pio2.c b/newlib/libm/math/ef_rem_pio2.c
index f1191d0..11978fb 100644
--- a/newlib/libm/math/ef_rem_pio2.c
+++ b/newlib/libm/math/ef_rem_pio2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_rem_pio2.c -- float version of e_rem_pio2.c
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_remainder.c b/newlib/libm/math/ef_remainder.c
index 23d29d0..6bbab52 100644
--- a/newlib/libm/math/ef_remainder.c
+++ b/newlib/libm/math/ef_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_remainder.c -- float version of e_remainder.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -42,12 +43,17 @@ static float zero = 0.0;
     /* purge off exception values */
 	if(FLT_UWORD_IS_ZERO(hp)||
 	   !FLT_UWORD_IS_FINITE(hx)||
-	   FLT_UWORD_IS_NAN(hp))
+	   FLT_UWORD_IS_NAN(hp)) {
+	    __A_VARIABLE = 1;
 	    return (x*p)/(x*p);
+	}
 
 
 	if (hp<=FLT_UWORD_HALF_MAX) x = __ieee754_fmodf(x,p+p); /* now x < 2p */
-	if ((hx-hp)==0) return zero*x;
+	if ((hx-hp)==0) {
+	    __A_VARIABLE = 1;
+	    return zero*x;
+	}
 	x  = fabsf(x);
 	p  = fabsf(p);
 	if (hp<0x01000000) {
@@ -64,5 +70,6 @@ static float zero = 0.0;
 	}
 	GET_FLOAT_WORD(hx,x);
 	SET_FLOAT_WORD(x,hx^sx);
+	__A_VARIABLE = 1;
 	return x;
 }
diff --git a/newlib/libm/math/ef_scalb.c b/newlib/libm/math/ef_scalb.c
index 8d973b1..ad55c5f 100644
--- a/newlib/libm/math/ef_scalb.c
+++ b/newlib/libm/math/ef_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_scalb.c -- float version of e_scalb.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/ef_sinh.c b/newlib/libm/math/ef_sinh.c
index a61b172..10a2fa6 100644
--- a/newlib/libm/math/ef_sinh.c
+++ b/newlib/libm/math/ef_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_sinh.c -- float version of e_sinh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -35,29 +36,44 @@ static float one = 1.0, shuge = 1.0e37;
 	ix = jx&0x7fffffff;
 
     /* x is INF or NaN */
-	if(!FLT_UWORD_IS_FINITE(ix)) return x+x;	
+	if(!FLT_UWORD_IS_FINITE(ix)) {
+	    __A_VARIABLE = 1;
+	    return x+x;
+	}	
 
 	h = 0.5;
 	if (jx<0) h = -h;
     /* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
 	if (ix < 0x41b00000) {		/* |x|<22 */
 	    if (ix<0x31800000) 		/* |x|<2**-28 */
-		if(shuge+x>one) return x;/* sinh(tiny) = tiny with inexact */
+		if(shuge+x>one) {
+			__A_VARIABLE = 1;
+			return x;
+		}/* sinh(tiny) = tiny with inexact */
 	    t = expm1f(fabsf(x));
-	    if(ix<0x3f800000) return h*((float)2.0*t-t*t/(t+one));
+	    if(ix<0x3f800000) {
+		__A_VARIABLE = 1;
+		return h*((float)2.0*t-t*t/(t+one));
+	    }
+	    __A_VARIABLE = 1;
 	    return h*(t+t/(t+one));
 	}
 
     /* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
-	if (ix<=FLT_UWORD_LOG_MAX)  return h*__ieee754_expf(fabsf(x));
+	if (ix<=FLT_UWORD_LOG_MAX)  {
+	    __A_VARIABLE = 1;
+	    return h*__ieee754_expf(fabsf(x));
+	}
 
     /* |x| in [log(maxdouble), overflowthresold] */
 	if (ix<=FLT_UWORD_LOG_2MAX) {
 	    w = __ieee754_expf((float)0.5*fabsf(x));
 	    t = h*w;
+	    __A_VARIABLE = 1;
 	    return t*w;
 	}
 
     /* |x| > overflowthresold, sinh(x) overflow */
+	__A_VARIABLE = 1;
 	return x*shuge;
 }
diff --git a/newlib/libm/math/ef_sqrt.c b/newlib/libm/math/ef_sqrt.c
index 80e7f36..ac62777 100644
--- a/newlib/libm/math/ef_sqrt.c
+++ b/newlib/libm/math/ef_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_sqrtf.c -- float version of e_sqrt.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -36,12 +37,20 @@ static	float	one	= 1.0, tiny=1.0e-30;
 	hx = ix&0x7fffffff;
 
     /* take care of Inf and NaN */
-	if(!FLT_UWORD_IS_FINITE(hx))
-	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
+	if(!FLT_UWORD_IS_FINITE(hx)) {
+	    __A_VARIABLE = 1;
+	    return x*x+x;
+	}		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
 					   sqrt(-inf)=sNaN */
     /* take care of zero and -ves */
-	if(FLT_UWORD_IS_ZERO(hx)) return x;/* sqrt(+-0) = +-0 */
-	if(ix<0) return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
+	if(FLT_UWORD_IS_ZERO(hx)) {
+	    __A_VARIABLE = 1;
+	    return x;
+	}/* sqrt(+-0) = +-0 */
+	if(ix<0) {
+	    __A_VARIABLE = 1;
+	    return (x-x)/(x-x);
+	}		/* sqrt(-ve) = sNaN */
 
     /* normalize x */
 	m = (ix>>23);
@@ -85,5 +94,6 @@ static	float	one	= 1.0, tiny=1.0e-30;
 	ix = (q>>1)+0x3f000000L;
 	ix += (m <<23);
 	SET_FLOAT_WORD(z,ix);
+	__A_VARIABLE = 1;
 	return z;
 }
diff --git a/newlib/libm/math/el_hypot.c b/newlib/libm/math/el_hypot.c
index 737cde3..e653ef8 100644
--- a/newlib/libm/math/el_hypot.c
+++ b/newlib/libm/math/el_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2015 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
diff --git a/newlib/libm/math/er_gamma.c b/newlib/libm/math/er_gamma.c
index 3c0e241..39ca402 100644
--- a/newlib/libm/math/er_gamma.c
+++ b/newlib/libm/math/er_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)er_gamma.c 5.1 93/09/24 */
 /*
@@ -28,5 +29,6 @@
 	double x; int *signgamp;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_exp (__ieee754_lgamma_r(x,signgamp));
 }
diff --git a/newlib/libm/math/er_lgamma.c b/newlib/libm/math/er_lgamma.c
index 386a8a7..3a92d07 100644
--- a/newlib/libm/math/er_lgamma.c
+++ b/newlib/libm/math/er_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)er_lgamma.c 5.1 93/09/24 */
 /*
@@ -172,7 +173,10 @@ static double zero=  0.00000000000000000000e+00;
 	GET_HIGH_WORD(ix,x);
 	ix &= 0x7fffffff;
 
-	if(ix<0x3fd00000) return __kernel_sin(pi*x,zero,0);
+	if(ix<0x3fd00000) {
+	    __A_VARIABLE = 1;
+	    return __kernel_sin(pi*x,zero,0);
+	}
 	y = -x;		/* x is assume negative */
 
     /*
@@ -205,6 +209,7 @@ static double zero=  0.00000000000000000000e+00;
 	    case 6:   y = -__kernel_cos(pi*(y-1.5),zero); break;
 	    default:  y =  __kernel_sin(pi*(y-2.0),zero,0); break;
 	    }
+	__A_VARIABLE = 1;
 	return -y;
 }
 
diff --git a/newlib/libm/math/erf_gamma.c b/newlib/libm/math/erf_gamma.c
index 9e529dc..811fba4 100644
--- a/newlib/libm/math/erf_gamma.c
+++ b/newlib/libm/math/erf_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* erf_gamma.c -- float version of er_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -30,5 +31,6 @@
 	float x; int *signgamp;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_expf (__ieee754_lgammaf_r(x,signgamp));
 }
diff --git a/newlib/libm/math/erf_lgamma.c b/newlib/libm/math/erf_lgamma.c
index 3c6ba02..76a9ddd 100644
--- a/newlib/libm/math/erf_lgamma.c
+++ b/newlib/libm/math/erf_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* erf_lgamma.c -- float version of er_lgamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -107,7 +108,10 @@ static float zero=  0.0000000000e+00;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
 
-	if(ix<0x3e800000) return __kernel_sinf(pi*x,zero,0);
+	if(ix<0x3e800000) {
+	    __A_VARIABLE = 1;
+	    return __kernel_sinf(pi*x,zero,0);
+	}
 	y = -x;		/* x is assume negative */
 
     /*
@@ -140,6 +144,7 @@ static float zero=  0.0000000000e+00;
 	    case 6:   y = -__kernel_cosf(pi*(y-(float)1.5),zero); break;
 	    default:  y =  __kernel_sinf(pi*(y-(float)2.0),zero,0); break;
 	    }
+	__A_VARIABLE = 1;
 	return -y;
 }
 
diff --git a/newlib/libm/math/k_cos.c b/newlib/libm/math/k_cos.c
index 6c60c24..1db46ad 100644
--- a/newlib/libm/math/k_cos.c
+++ b/newlib/libm/math/k_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)k_cos.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/k_rem_pio2.c b/newlib/libm/math/k_rem_pio2.c
index 8569256..7915f5e 100644
--- a/newlib/libm/math/k_rem_pio2.c
+++ b/newlib/libm/math/k_rem_pio2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)k_rem_pio2.c 5.1 93/09/24 */
 /*
@@ -314,6 +315,7 @@ recompute:
 		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
 		}
 	}
+	__A_VARIABLE = 1;
 	return n&7;
 }
 
diff --git a/newlib/libm/math/k_sin.c b/newlib/libm/math/k_sin.c
index f119916..f629876 100644
--- a/newlib/libm/math/k_sin.c
+++ b/newlib/libm/math/k_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)k_sin.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/k_standard.c b/newlib/libm/math/k_standard.c
index 0d72f1a..d256c9a 100644
--- a/newlib/libm/math/k_standard.c
+++ b/newlib/libm/math/k_standard.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)k_standard.c 5.1 93/09/24 */
 /*
@@ -778,6 +779,7 @@ static double zero = 0.0;	/* used as const */
 	}
 	if (exc.err != 0)
 	    errno = exc.err;
+	__A_VARIABLE = 1;
 	return exc.retval; 
 }
 
diff --git a/newlib/libm/math/k_tan.c b/newlib/libm/math/k_tan.c
index 9f5b307..b426290 100644
--- a/newlib/libm/math/k_tan.c
+++ b/newlib/libm/math/k_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)k_tan.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/kf_cos.c b/newlib/libm/math/kf_cos.c
index 4f71af2..fd9b0b1 100644
--- a/newlib/libm/math/kf_cos.c
+++ b/newlib/libm/math/kf_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kf_cos.c -- float version of k_cos.c
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/kf_rem_pio2.c b/newlib/libm/math/kf_rem_pio2.c
index 261c481..246cc96 100644
--- a/newlib/libm/math/kf_rem_pio2.c
+++ b/newlib/libm/math/kf_rem_pio2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kf_rem_pio2.c -- float version of k_rem_pio2.c
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -204,5 +205,6 @@ recompute:
 		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
 		}
 	}
+	__A_VARIABLE = 1;
 	return n&7;
 }
diff --git a/newlib/libm/math/kf_sin.c b/newlib/libm/math/kf_sin.c
index e81fa0b..0df2a5f 100644
--- a/newlib/libm/math/kf_sin.c
+++ b/newlib/libm/math/kf_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kf_sin.c -- float version of k_sin.c
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/kf_tan.c b/newlib/libm/math/kf_tan.c
index 285d7f6..d7d644a 100644
--- a/newlib/libm/math/kf_tan.c
+++ b/newlib/libm/math/kf_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* kf_tan.c -- float version of k_tan.c
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/s_asinh.c b/newlib/libm/math/s_asinh.c
index b7e173c..2c6da9b 100644
--- a/newlib/libm/math/s_asinh.c
+++ b/newlib/libm/math/s_asinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_asinh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_atan.c b/newlib/libm/math/s_atan.c
index c52a09d..4c5f83b 100644
--- a/newlib/libm/math/s_atan.c
+++ b/newlib/libm/math/s_atan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_atan.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_ceil.c b/newlib/libm/math/s_ceil.c
index 24d6916..c34cf32 100644
--- a/newlib/libm/math/s_ceil.c
+++ b/newlib/libm/math/s_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_ceil.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_cos.c b/newlib/libm/math/s_cos.c
index c471233..309ada3 100644
--- a/newlib/libm/math/s_cos.c
+++ b/newlib/libm/math/s_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_cos.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_erf.c b/newlib/libm/math/s_erf.c
index 825309d..bb21fa6 100644
--- a/newlib/libm/math/s_erf.c
+++ b/newlib/libm/math/s_erf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_erf.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_fabs.c b/newlib/libm/math/s_fabs.c
index 95b871c..3e45fa4 100644
--- a/newlib/libm/math/s_fabs.c
+++ b/newlib/libm/math/s_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_fabs.c 5.1 93/09/24 */
 /*
@@ -67,6 +68,7 @@ PORTABILITY
 	__uint32_t high;
 	GET_HIGH_WORD(high,x);
 	SET_HIGH_WORD(x,high&0x7fffffff);
+        __A_VARIABLE = 1;
         return x;
 }
 
diff --git a/newlib/libm/math/s_floor.c b/newlib/libm/math/s_floor.c
index 65e234e..8011d24 100644
--- a/newlib/libm/math/s_floor.c
+++ b/newlib/libm/math/s_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_floor.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_frexp.c b/newlib/libm/math/s_frexp.c
index 5a396c7..293423e 100644
--- a/newlib/libm/math/s_frexp.c
+++ b/newlib/libm/math/s_frexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_frexp.c 5.1 93/09/24 */
 /*
@@ -98,7 +99,10 @@ two54 =  1.80143985094819840000e+16; /* 0x43500000, 0x00000000 */
 	EXTRACT_WORDS(hx,lx,x);
 	ix = 0x7fffffff&hx;
 	*eptr = 0;
-	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
+	if(ix>=0x7ff00000||((ix|lx)==0)) {
+	    __A_VARIABLE = 1;
+	    return x;
+	}	/* 0,inf,nan */
 	if (ix<0x00100000) {		/* subnormal */
 	    x *= two54;
 	    GET_HIGH_WORD(hx,x);
@@ -108,6 +112,7 @@ two54 =  1.80143985094819840000e+16; /* 0x43500000, 0x00000000 */
 	*eptr += (ix>>20)-1022;
 	hx = (hx&0x800fffff)|0x3fe00000;
 	SET_HIGH_WORD(x,hx);
+	__A_VARIABLE = 1;
 	return x;
 }
 
diff --git a/newlib/libm/math/s_ldexp.c b/newlib/libm/math/s_ldexp.c
index adc7d5d..03cfc5d 100644
--- a/newlib/libm/math/s_ldexp.c
+++ b/newlib/libm/math/s_ldexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_ldexp.c 5.1 93/09/24 */
 /*
@@ -72,9 +73,13 @@ PORTABILITY
 	double value; int exp;
 #endif
 {
-	if(!finite(value)||value==0.0) return value;
+	if(!finite(value)||value==0.0) {
+		__A_VARIABLE = 1;
+		return value;
+	}
 	value = scalbn(value,exp);
 	if(!finite(value)||value==0.0) errno = ERANGE;
+	__A_VARIABLE = 1;
 	return value;
 }
 
diff --git a/newlib/libm/math/s_signif.c b/newlib/libm/math/s_signif.c
index f68046b..7212ed4 100644
--- a/newlib/libm/math/s_signif.c
+++ b/newlib/libm/math/s_signif.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_signif.c 5.1 93/09/24 */
 /*
@@ -28,6 +29,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_scalb(x,(double) -ilogb(x));
 }
 
diff --git a/newlib/libm/math/s_sin.c b/newlib/libm/math/s_sin.c
index 28259f3..15842dd 100644
--- a/newlib/libm/math/s_sin.c
+++ b/newlib/libm/math/s_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_sin.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_tan.c b/newlib/libm/math/s_tan.c
index 2959f41..a2d11c7 100644
--- a/newlib/libm/math/s_tan.c
+++ b/newlib/libm/math/s_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_tan.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/s_tanh.c b/newlib/libm/math/s_tanh.c
index b5541d0..5240b29 100644
--- a/newlib/libm/math/s_tanh.c
+++ b/newlib/libm/math/s_tanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_tanh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/sf_asinh.c b/newlib/libm/math/sf_asinh.c
index 4688ea8..4d566ea 100644
--- a/newlib/libm/math/sf_asinh.c
+++ b/newlib/libm/math/sf_asinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_asinh.c -- float version of s_asinh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -60,6 +61,7 @@ huge=  1.0000000000e+30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) asinhf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_atan.c b/newlib/libm/math/sf_atan.c
index 6edf05f..795c70f 100644
--- a/newlib/libm/math/sf_atan.c
+++ b/newlib/libm/math/sf_atan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_atan.c -- float version of s_atan.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -123,6 +124,7 @@ huge   = 1.0e30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) atanf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_ceil.c b/newlib/libm/math/sf_ceil.c
index 8a8edac..6afed73 100644
--- a/newlib/libm/math/sf_ceil.c
+++ b/newlib/libm/math/sf_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_ceil.c -- float version of s_ceil.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -64,6 +65,7 @@ static float huge = 1.0e30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) ceilf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_cos.c b/newlib/libm/math/sf_cos.c
index 4c0a9a5..80ee00a 100644
--- a/newlib/libm/math/sf_cos.c
+++ b/newlib/libm/math/sf_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_cos.c -- float version of s_cos.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -62,6 +63,7 @@ static float one=1.0;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) cosf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_erf.c b/newlib/libm/math/sf_erf.c
index 0329c60..897beab 100644
--- a/newlib/libm/math/sf_erf.c
+++ b/newlib/libm/math/sf_erf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_erf.c -- float version of s_erf.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -230,6 +231,7 @@ sb7  = -2.2440952301e+01; /* 0xc1b38712 */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) erff((float) x);
 }
 
@@ -240,6 +242,7 @@ sb7  = -2.2440952301e+01; /* 0xc1b38712 */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) erfcf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_fabs.c b/newlib/libm/math/sf_fabs.c
index 2aaed32..5d201cb 100644
--- a/newlib/libm/math/sf_fabs.c
+++ b/newlib/libm/math/sf_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_fabs.c -- float version of s_fabs.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -29,6 +30,7 @@
 	__uint32_t ix;
 	GET_FLOAT_WORD(ix,x);
 	SET_FLOAT_WORD(x,ix&0x7fffffff);
+        __A_VARIABLE = 1;
         return x;
 }
 
@@ -41,6 +43,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) fabsf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_floor.c b/newlib/libm/math/sf_floor.c
index 9264d81..c040ce5 100644
--- a/newlib/libm/math/sf_floor.c
+++ b/newlib/libm/math/sf_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_floor.c -- float version of s_floor.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -74,6 +75,7 @@ static float huge = 1.0e30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) floorf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_frexp.c b/newlib/libm/math/sf_frexp.c
index 8dd8a97..65525f4 100644
--- a/newlib/libm/math/sf_frexp.c
+++ b/newlib/libm/math/sf_frexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_frexp.c -- float version of s_frexp.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -33,7 +34,10 @@ two25 =  3.3554432000e+07; /* 0x4c000000 */
 	GET_FLOAT_WORD(hx,x);
 	ix = 0x7fffffff&hx;
 	*eptr = 0;
-	if(!FLT_UWORD_IS_FINITE(ix)||FLT_UWORD_IS_ZERO(ix)) return x;	/* 0,inf,nan */
+	if(!FLT_UWORD_IS_FINITE(ix)||FLT_UWORD_IS_ZERO(ix)) {
+	    __A_VARIABLE = 1;
+	    return x;
+	}	/* 0,inf,nan */
 	if (FLT_UWORD_IS_SUBNORMAL(ix)) {		/* subnormal */
 	    x *= two25;
 	    GET_FLOAT_WORD(hx,x);
@@ -43,6 +47,7 @@ two25 =  3.3554432000e+07; /* 0x4c000000 */
 	*eptr += (ix>>23)-126;
 	hx = (hx&0x807fffff)|0x3f000000;
 	SET_FLOAT_WORD(x,hx);
+	__A_VARIABLE = 1;
 	return x;
 }
 
@@ -55,6 +60,7 @@ two25 =  3.3554432000e+07; /* 0x4c000000 */
 	double x; int *eptr;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) frexpf((float) x, eptr);
 }
 
diff --git a/newlib/libm/math/sf_ldexp.c b/newlib/libm/math/sf_ldexp.c
index 2781304..6518ec8 100644
--- a/newlib/libm/math/sf_ldexp.c
+++ b/newlib/libm/math/sf_ldexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_ldexp.c -- float version of s_ldexp.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -23,9 +24,13 @@
 	float value; int exp;
 #endif
 {
-	if(!finitef(value)||value==(float)0.0) return value;
+	if(!finitef(value)||value==(float)0.0) {
+		__A_VARIABLE = 1;
+		return value;
+	}
 	value = scalbnf(value,exp);
 	if(!finitef(value)||value==(float)0.0) errno = ERANGE;
+	__A_VARIABLE = 1;
 	return value;
 }
 
@@ -38,6 +43,7 @@
 	double value; int exp;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) ldexpf((float) value, exp);
 }
 
diff --git a/newlib/libm/math/sf_signif.c b/newlib/libm/math/sf_signif.c
index fd4a072..93b3d42 100644
--- a/newlib/libm/math/sf_signif.c
+++ b/newlib/libm/math/sf_signif.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_signif.c -- float version of s_signif.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -22,6 +23,7 @@
 	float x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_scalbf(x,(float) -ilogbf(x));
 }
 
@@ -34,6 +36,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) significandf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_sin.c b/newlib/libm/math/sf_sin.c
index da81845..5804703 100644
--- a/newlib/libm/math/sf_sin.c
+++ b/newlib/libm/math/sf_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_sin.c -- float version of s_sin.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -56,6 +57,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) sinf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_tan.c b/newlib/libm/math/sf_tan.c
index 18c47a4..6f615c4 100644
--- a/newlib/libm/math/sf_tan.c
+++ b/newlib/libm/math/sf_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_tan.c -- float version of s_tan.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -51,6 +52,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) tanf((float) x);
 }
 
diff --git a/newlib/libm/math/sf_tanh.c b/newlib/libm/math/sf_tanh.c
index 1eb44a2..1c36305 100644
--- a/newlib/libm/math/sf_tanh.c
+++ b/newlib/libm/math/sf_tanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_tanh.c -- float version of s_tanh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -67,6 +68,7 @@ static float one=1.0, two=2.0, tiny = 1.0e-30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) tanhf((float) x);
 }
 
diff --git a/newlib/libm/math/w_acos.c b/newlib/libm/math/w_acos.c
index 8ce7887..b5b7c00 100644
--- a/newlib/libm/math/w_acos.c
+++ b/newlib/libm/math/w_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_acos.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_acosh.c b/newlib/libm/math/w_acosh.c
index 9303260..07a135c 100644
--- a/newlib/libm/math/w_acosh.c
+++ b/newlib/libm/math/w_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_acosh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_asin.c b/newlib/libm/math/w_asin.c
index c49111d..a6b3edb 100644
--- a/newlib/libm/math/w_asin.c
+++ b/newlib/libm/math/w_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_asin.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_atan2.c b/newlib/libm/math/w_atan2.c
index f3e344e..31a074c 100644
--- a/newlib/libm/math/w_atan2.c
+++ b/newlib/libm/math/w_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_atan2.c 5.1 93/09/24 */
 /*
@@ -84,6 +85,7 @@ PORTABILITY
 	double y,x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_atan2(y,x);
 }
 
diff --git a/newlib/libm/math/w_atanh.c b/newlib/libm/math/w_atanh.c
index 07fd459..7b6df04 100644
--- a/newlib/libm/math/w_atanh.c
+++ b/newlib/libm/math/w_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_atanh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_cosh.c b/newlib/libm/math/w_cosh.c
index 54bfec3..beeb75b 100644
--- a/newlib/libm/math/w_cosh.c
+++ b/newlib/libm/math/w_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_cosh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_drem.c b/newlib/libm/math/w_drem.c
index d289bda..d29e10c 100644
--- a/newlib/libm/math/w_drem.c
+++ b/newlib/libm/math/w_drem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * drem() wrapper for remainder().
  * 
@@ -11,5 +12,6 @@ double
 drem(x, y)
 	double x, y;
 {
+	__A_VARIABLE = 1;
 	return remainder(x, y);
 }
diff --git a/newlib/libm/math/w_exp.c b/newlib/libm/math/w_exp.c
index eb36390..a669cdc 100644
--- a/newlib/libm/math/w_exp.c
+++ b/newlib/libm/math/w_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_exp.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_exp2.c b/newlib/libm/math/w_exp2.c
index 857cb0c..401d157 100644
--- a/newlib/libm/math/w_exp2.c
+++ b/newlib/libm/math/w_exp2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_exp2.c 5.1 93/09/24 */
 /*
@@ -64,6 +65,7 @@ PORTABILITY
 	double x;
 #endif
 {
+  __A_VARIABLE = 1;
   return pow(2.0, x);
 }
 
diff --git a/newlib/libm/math/w_fmod.c b/newlib/libm/math/w_fmod.c
index f9f72c7..65b941c 100644
--- a/newlib/libm/math/w_fmod.c
+++ b/newlib/libm/math/w_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_fmod.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_gamma.c b/newlib/libm/math/w_gamma.c
index d1a70df..355b5fd 100644
--- a/newlib/libm/math/w_gamma.c
+++ b/newlib/libm/math/w_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_gamma.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_hypot.c b/newlib/libm/math/w_hypot.c
index 203bf09..6521c12 100644
--- a/newlib/libm/math/w_hypot.c
+++ b/newlib/libm/math/w_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_hypot.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_j0.c b/newlib/libm/math/w_j0.c
index e4dde5c..3512bdf 100644
--- a/newlib/libm/math/w_j0.c
+++ b/newlib/libm/math/w_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_j0.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_j1.c b/newlib/libm/math/w_j1.c
index ba7df15..f98d643 100644
--- a/newlib/libm/math/w_j1.c
+++ b/newlib/libm/math/w_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_j1.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_jn.c b/newlib/libm/math/w_jn.c
index 6cadc9a..32cd41b 100644
--- a/newlib/libm/math/w_jn.c
+++ b/newlib/libm/math/w_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_jn.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_lgamma.c b/newlib/libm/math/w_lgamma.c
index e56e477..233fc7d 100644
--- a/newlib/libm/math/w_lgamma.c
+++ b/newlib/libm/math/w_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_lgamma.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_log.c b/newlib/libm/math/w_log.c
index 38896cd..4b055df 100644
--- a/newlib/libm/math/w_log.c
+++ b/newlib/libm/math/w_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_log.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_log10.c b/newlib/libm/math/w_log10.c
index 66f0e78..39d8a9f 100644
--- a/newlib/libm/math/w_log10.c
+++ b/newlib/libm/math/w_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_log10.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_pow.c b/newlib/libm/math/w_pow.c
index ebf7be3..4b80599 100644
--- a/newlib/libm/math/w_pow.c
+++ b/newlib/libm/math/w_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 /* @(#)w_pow.c 5.2 93/10/01 */
diff --git a/newlib/libm/math/w_remainder.c b/newlib/libm/math/w_remainder.c
index e4c1967..145a45d 100644
--- a/newlib/libm/math/w_remainder.c
+++ b/newlib/libm/math/w_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_remainder.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_scalb.c b/newlib/libm/math/w_scalb.c
index c324968..b643cb4 100644
--- a/newlib/libm/math/w_scalb.c
+++ b/newlib/libm/math/w_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_scalb.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_sincos.c b/newlib/libm/math/w_sincos.c
index 491efa4..28c2de3 100644
--- a/newlib/libm/math/w_sincos.c
+++ b/newlib/libm/math/w_sincos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sincos -- currently no more efficient than two separate calls to
    sin and cos. */
 
@@ -17,6 +18,7 @@
 {
   *sinx = sin (x);
   *cosx = cos (x);
+  __A_VARIABLE = 1;
 }
 
 #endif /* defined(_DOUBLE_IS_32BITS) */
diff --git a/newlib/libm/math/w_sinh.c b/newlib/libm/math/w_sinh.c
index 72e0ef5..8794484 100644
--- a/newlib/libm/math/w_sinh.c
+++ b/newlib/libm/math/w_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_sinh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_sqrt.c b/newlib/libm/math/w_sqrt.c
index 23a793c..b9f5e2e 100644
--- a/newlib/libm/math/w_sqrt.c
+++ b/newlib/libm/math/w_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_sqrt.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/w_tgamma.c b/newlib/libm/math/w_tgamma.c
index c0c011d..b99ace3 100644
--- a/newlib/libm/math/w_tgamma.c
+++ b/newlib/libm/math/w_tgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)w_gamma.c 5.1 93/09/24 */
 /*
  * ====================================================
diff --git a/newlib/libm/math/wf_acos.c b/newlib/libm/math/wf_acos.c
index ff9f80b..3ce6855 100644
--- a/newlib/libm/math/wf_acos.c
+++ b/newlib/libm/math/wf_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_acos.c -- float version of w_acos.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -63,6 +64,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) acosf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_acosh.c b/newlib/libm/math/wf_acosh.c
index fc8ec3a..1dfa49d 100644
--- a/newlib/libm/math/wf_acosh.c
+++ b/newlib/libm/math/wf_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_acosh.c -- float version of w_acosh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -64,6 +65,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) acoshf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_asin.c b/newlib/libm/math/wf_asin.c
index 385de54..f30dd62 100644
--- a/newlib/libm/math/wf_asin.c
+++ b/newlib/libm/math/wf_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_asin.c -- float version of w_asin.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -65,6 +66,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) asinf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_atan2.c b/newlib/libm/math/wf_atan2.c
index eb2a76b..38ea741 100644
--- a/newlib/libm/math/wf_atan2.c
+++ b/newlib/libm/math/wf_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_atan2.c -- float version of w_atan2.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -28,6 +29,7 @@
 	float y,x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return __ieee754_atan2f(y,x);
 }
 
@@ -40,6 +42,7 @@
 	double y,x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) atan2f((float) y, (float) x);
 }
 
diff --git a/newlib/libm/math/wf_atanh.c b/newlib/libm/math/wf_atanh.c
index 5656304..544189d 100644
--- a/newlib/libm/math/wf_atanh.c
+++ b/newlib/libm/math/wf_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_atanh.c -- float version of w_atanh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -77,6 +78,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) atanhf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_cosh.c b/newlib/libm/math/wf_cosh.c
index 02eb124..617bfa7 100644
--- a/newlib/libm/math/wf_cosh.c
+++ b/newlib/libm/math/wf_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_cosh.c -- float version of w_cosh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -72,6 +73,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) coshf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_drem.c b/newlib/libm/math/wf_drem.c
index 7c3f7c5..d05447f 100644
--- a/newlib/libm/math/wf_drem.c
+++ b/newlib/libm/math/wf_drem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * dremf() wrapper for remainderf().
  * 
@@ -15,5 +16,6 @@ dremf(x, y)
 	float x, y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return remainderf(x, y);
 }
diff --git a/newlib/libm/math/wf_exp.c b/newlib/libm/math/wf_exp.c
index 70f4459..f80b7bb 100644
--- a/newlib/libm/math/wf_exp.c
+++ b/newlib/libm/math/wf_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_exp.c -- float version of w_exp.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -97,6 +98,7 @@ u_threshold= -1.0397208405e+02;  /* 0xc2cff1b5 */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) expf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_exp2.c b/newlib/libm/math/wf_exp2.c
index 9440314..08687bf 100644
--- a/newlib/libm/math/wf_exp2.c
+++ b/newlib/libm/math/wf_exp2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_exp2.c -- float version of w_exp2.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -28,6 +29,7 @@
 	float x;
 #endif
 {
+  __A_VARIABLE = 1;
   return powf(2.0, x);
 }
 
@@ -40,6 +42,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) exp2f((float) x);
 }
 
diff --git a/newlib/libm/math/wf_fmod.c b/newlib/libm/math/wf_fmod.c
index 030ca3e..a51468e 100644
--- a/newlib/libm/math/wf_fmod.c
+++ b/newlib/libm/math/wf_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_fmod.c -- float version of w_fmod.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -67,6 +68,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) fmodf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/math/wf_gamma.c b/newlib/libm/math/wf_gamma.c
index 1204f39..57a7cb4 100644
--- a/newlib/libm/math/wf_gamma.c
+++ b/newlib/libm/math/wf_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_gamma.c -- float version of w_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -87,6 +88,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) gammaf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_hypot.c b/newlib/libm/math/wf_hypot.c
index c04ace1..ff6fc2d 100644
--- a/newlib/libm/math/wf_hypot.c
+++ b/newlib/libm/math/wf_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_hypot.c -- float version of w_hypot.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -73,6 +74,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) hypotf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/math/wf_j0.c b/newlib/libm/math/wf_j0.c
index 1f7f5ed..7081b90 100644
--- a/newlib/libm/math/wf_j0.c
+++ b/newlib/libm/math/wf_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_j0.c -- float version of w_j0.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -121,6 +122,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) j0f((float) x);
 }
 
@@ -131,6 +133,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) y0f((float) x);
 }
 
diff --git a/newlib/libm/math/wf_j1.c b/newlib/libm/math/wf_j1.c
index b919628..d2b1e5c 100644
--- a/newlib/libm/math/wf_j1.c
+++ b/newlib/libm/math/wf_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_j1.c -- float version of w_j1.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -123,6 +124,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) j1f((float) x);
 }
 
@@ -133,6 +135,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) y1f((float) x);
 }
 
diff --git a/newlib/libm/math/wf_jn.c b/newlib/libm/math/wf_jn.c
index 837b6b7..180d4b9 100644
--- a/newlib/libm/math/wf_jn.c
+++ b/newlib/libm/math/wf_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_jn.c -- float version of w_jn.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -122,6 +123,7 @@
 	double x; int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) jnf(n, (float) x);
 }
 
@@ -132,6 +134,7 @@
 	double x; int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) ynf(n, (float) x);
 }
 
diff --git a/newlib/libm/math/wf_lgamma.c b/newlib/libm/math/wf_lgamma.c
index f1bf0c0..3a11975 100644
--- a/newlib/libm/math/wf_lgamma.c
+++ b/newlib/libm/math/wf_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_lgamma.c -- float version of w_lgamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -81,6 +82,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) lgammaf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_log.c b/newlib/libm/math/wf_log.c
index 4518b86..28e48b5 100644
--- a/newlib/libm/math/wf_log.c
+++ b/newlib/libm/math/wf_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_log.c -- float version of w_log.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -80,6 +81,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) logf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_log10.c b/newlib/libm/math/wf_log10.c
index 11c5956..5fbe865 100644
--- a/newlib/libm/math/wf_log10.c
+++ b/newlib/libm/math/wf_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_log10.c -- float version of w_log10.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -83,6 +84,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) log10f((float) x);
 }
 
diff --git a/newlib/libm/math/wf_pow.c b/newlib/libm/math/wf_pow.c
index a30f880..92a67f2 100644
--- a/newlib/libm/math/wf_pow.c
+++ b/newlib/libm/math/wf_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_pow.c -- float version of w_pow.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -173,6 +174,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) powf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/math/wf_remainder.c b/newlib/libm/math/wf_remainder.c
index f38c237..af0da78 100644
--- a/newlib/libm/math/wf_remainder.c
+++ b/newlib/libm/math/wf_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_remainder.c -- float version of w_remainder.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -64,6 +65,7 @@
 	double x,y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) remainderf((float) x, (float) y);
 }
 
diff --git a/newlib/libm/math/wf_scalb.c b/newlib/libm/math/wf_scalb.c
index d2c3cd2..6b5eb80 100644
--- a/newlib/libm/math/wf_scalb.c
+++ b/newlib/libm/math/wf_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_scalb.c -- float version of w_scalb.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/wf_sincos.c b/newlib/libm/math/wf_sincos.c
index 477c604..676a7e5 100644
--- a/newlib/libm/math/wf_sincos.c
+++ b/newlib/libm/math/wf_sincos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sincos -- currently no more efficient than two separate calls to
    sin and cos. */
 #include "fdlibm.h"
@@ -14,6 +15,7 @@
 {
   *sinx = sinf (x);
   *cosx = cosf (x);
+  __A_VARIABLE = 1;
 }
 
 #ifdef _DOUBLE_IS_32BITS
@@ -29,5 +31,6 @@
 {
   *sinx = sinf((float) x);
   *cosx = cosf((float) x);
+  __A_VARIABLE = 1;
 }
 #endif /* defined(_DOUBLE_IS_32BITS) */
diff --git a/newlib/libm/math/wf_sinh.c b/newlib/libm/math/wf_sinh.c
index 80c7a8e..af49b5a 100644
--- a/newlib/libm/math/wf_sinh.c
+++ b/newlib/libm/math/wf_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_sinh.c -- float version of w_sinh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -72,6 +73,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) sinhf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_sqrt.c b/newlib/libm/math/wf_sqrt.c
index 4536ba0..e8b685e 100644
--- a/newlib/libm/math/wf_sqrt.c
+++ b/newlib/libm/math/wf_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_sqrt.c -- float version of w_sqrt.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -66,6 +67,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) sqrtf((float) x);
 }
 
diff --git a/newlib/libm/math/wf_tgamma.c b/newlib/libm/math/wf_tgamma.c
index 92df396..600c9fd 100644
--- a/newlib/libm/math/wf_tgamma.c
+++ b/newlib/libm/math/wf_tgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* w_gammaf.c -- float version of w_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -53,6 +54,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) tgammaf((float) x);
 }
 
diff --git a/newlib/libm/math/wr_gamma.c b/newlib/libm/math/wr_gamma.c
index 0092ed0..1c167e8 100644
--- a/newlib/libm/math/wr_gamma.c
+++ b/newlib/libm/math/wr_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)wr_gamma.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/wr_lgamma.c b/newlib/libm/math/wr_lgamma.c
index c59c1cc..80c2680 100644
--- a/newlib/libm/math/wr_lgamma.c
+++ b/newlib/libm/math/wr_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)wr_lgamma.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/math/wrf_gamma.c b/newlib/libm/math/wrf_gamma.c
index ae285f5..3ddcaf0 100644
--- a/newlib/libm/math/wrf_gamma.c
+++ b/newlib/libm/math/wrf_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wrf_gamma.c -- float version of wr_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/math/wrf_lgamma.c b/newlib/libm/math/wrf_lgamma.c
index 73985e2..6b71bc5 100644
--- a/newlib/libm/math/wrf_lgamma.c
+++ b/newlib/libm/math/wrf_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wrf_lgamma.c -- float version of wr_lgamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/e_acosh.c b/newlib/libm/mathfp/e_acosh.c
index 7b199c5..3f26189 100644
--- a/newlib/libm/mathfp/e_acosh.c
+++ b/newlib/libm/mathfp/e_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_acosh.c 5.1 93/09/24 */
 
diff --git a/newlib/libm/mathfp/e_atanh.c b/newlib/libm/mathfp/e_atanh.c
index fb233e5..a0abcc7 100644
--- a/newlib/libm/mathfp/e_atanh.c
+++ b/newlib/libm/mathfp/e_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_atanh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/e_hypot.c b/newlib/libm/mathfp/e_hypot.c
index 713aa77..b78d5ef 100644
--- a/newlib/libm/mathfp/e_hypot.c
+++ b/newlib/libm/mathfp/e_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_hypot.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/e_j0.c b/newlib/libm/mathfp/e_j0.c
index c58c08e..7e1d292 100644
--- a/newlib/libm/mathfp/e_j0.c
+++ b/newlib/libm/mathfp/e_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_j0.c 5.1 93/09/24 */
 /*
@@ -173,9 +174,18 @@ v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */
 	EXTRACT_WORDS(hx,lx,x);
         ix = 0x7fffffff&hx;
     /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
-	if(ix>=0x7ff00000) return  one/(x+x*x); 
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7ff00000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if((ix|lx)==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
@@ -206,14 +216,17 @@ v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */
                     u = pzero(x); v = qzero(x);
                     z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
 	}
 	if(ix<=0x3e400000) {	/* x < 2**-27 */
+	    __A_VARIABLE = 1;
 	    return(u00 + tpi*log(x));
 	}
 	z = x*x;
 	u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
 	v = one+z*(v01+z*(v02+z*(v03+z*v04)));
+	__A_VARIABLE = 1;
 	return(u/v + tpi*(j0(x)*log(x)));
 }
 
@@ -345,6 +358,7 @@ static double pS2[5] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+	__A_VARIABLE = 1;
 	return one+ r/s;
 }
 		
@@ -481,6 +495,7 @@ static double qS2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (-.125 + r/s)/x;
 }
 
diff --git a/newlib/libm/mathfp/e_j1.c b/newlib/libm/mathfp/e_j1.c
index 274adfd..210470a 100644
--- a/newlib/libm/mathfp/e_j1.c
+++ b/newlib/libm/mathfp/e_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_j1.c 5.1 93/09/24 */
 /*
@@ -174,9 +175,18 @@ static double V0[5] = {
 	EXTRACT_WORDS(hx,lx,x);
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
-	if(ix>=0x7ff00000) return  one/(x+x*x); 
-        if((ix|lx)==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7ff00000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if((ix|lx)==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
                 s = sin(x);
                 c = cos(x);
@@ -203,14 +213,17 @@ static double V0[5] = {
                     u = pone(x); v = qone(x);
                     z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
         } 
         if(ix<=0x3c900000) {    /* x < 2**-54 */
+            __A_VARIABLE = 1;
             return(-tpi/x);
         } 
         z = x*x;
         u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
         v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
+        __A_VARIABLE = 1;
         return(x*(u/v) + tpi*(j1(x)*log(x)-one/x));
 }
 
@@ -343,6 +356,7 @@ static double ps2[5] = {
         z = one/(x*x);
         r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
         s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+        __A_VARIABLE = 1;
         return one+ r/s;
 }
 		
@@ -480,6 +494,7 @@ static double qs2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (.375 + r/s)/x;
 }
 
diff --git a/newlib/libm/mathfp/e_remainder.c b/newlib/libm/mathfp/e_remainder.c
index 02a714d..8bedee4 100644
--- a/newlib/libm/mathfp/e_remainder.c
+++ b/newlib/libm/mathfp/e_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_remainder.c 5.1 93/09/24 */
 /*
@@ -82,15 +83,23 @@ static double zero = 0.0;
 	hx &= 0x7fffffff;
 
     /* purge off exception values */
-	if((hp|lp)==0) return (x*p)/(x*p); 	/* p = 0 */
+	if((hp|lp)==0) {
+	    __A_VARIABLE = 1;
+	    return (x*p)/(x*p);
+	} 	/* p = 0 */
 	if((hx>=0x7ff00000)||			/* x not finite */
 	  ((hp>=0x7ff00000)&&			/* p is NaN */
-	  (((hp-0x7ff00000)|lp)!=0)))
+	  (((hp-0x7ff00000)|lp)!=0))) {
+	    __A_VARIABLE = 1;
 	    return (x*p)/(x*p);
+	}
 
 
 	if (hp<=0x7fdfffff) x = fmod(x,p+p);	/* now x < 2p */
-	if (((hx-hp)|(lx-lp))==0) return zero*x;
+	if (((hx-hp)|(lx-lp))==0) {
+	    __A_VARIABLE = 1;
+	    return zero*x;
+	}
 	x  = fabs(x);
 	p  = fabs(p);
 	if (hp<0x00200000) {
@@ -107,6 +116,7 @@ static double zero = 0.0;
 	}
 	GET_HIGH_WORD(hx,x);
 	SET_HIGH_WORD(x,hx^sx);
+	__A_VARIABLE = 1;
 	return x;
 }
 
diff --git a/newlib/libm/mathfp/e_scalb.c b/newlib/libm/mathfp/e_scalb.c
index c4056e0..aebe391 100644
--- a/newlib/libm/mathfp/e_scalb.c
+++ b/newlib/libm/mathfp/e_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)e_scalb.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/ef_acosh.c b/newlib/libm/mathfp/ef_acosh.c
index 705be49..98a1b57 100644
--- a/newlib/libm/mathfp/ef_acosh.c
+++ b/newlib/libm/mathfp/ef_acosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_acosh.c -- float version of e_acosh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/ef_atanh.c b/newlib/libm/mathfp/ef_atanh.c
index bfc40de..74024cb 100644
--- a/newlib/libm/mathfp/ef_atanh.c
+++ b/newlib/libm/mathfp/ef_atanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_atanh.c -- float version of e_atanh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/ef_hypot.c b/newlib/libm/mathfp/ef_hypot.c
index 8e5f4cc..0a09d33 100644
--- a/newlib/libm/mathfp/ef_hypot.c
+++ b/newlib/libm/mathfp/ef_hypot.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_hypot.c -- float version of e_hypot.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/ef_j0.c b/newlib/libm/mathfp/ef_j0.c
index e4cc108..7c8ff14 100644
--- a/newlib/libm/mathfp/ef_j0.c
+++ b/newlib/libm/mathfp/ef_j0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_j0.c -- float version of e_j0.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -128,9 +129,18 @@ v04  =  4.4111031494e-10; /* 0x2ff280c2 */
 	GET_FLOAT_WORD(hx,x);
         ix = 0x7fffffff&hx;
     /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
-	if(ix>=0x7f800000) return  one/(x+x*x); 
-        if(ix==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7f800000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if(ix==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
         /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
          * where x0 = x-pi/4
@@ -161,14 +171,17 @@ v04  =  4.4111031494e-10; /* 0x2ff280c2 */
                     u = pzerof(x); v = qzerof(x);
                     z = invsqrtpi*(u*ss+v*cc)/sqrtf(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
 	}
 	if(ix<=0x32000000) {	/* x < 2**-27 */
+	    __A_VARIABLE = 1;
 	    return(u00 + tpi*logf(x));
 	}
 	z = x*x;
 	u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
 	v = one+z*(v01+z*(v02+z*(v03+z*v04)));
+	__A_VARIABLE = 1;
 	return(u/v + tpi*(j0f(x)*logf(x)));
 }
 
@@ -299,6 +312,7 @@ static float pS2[5] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+	__A_VARIABLE = 1;
 	return one+ r/s;
 }
 		
@@ -435,5 +449,6 @@ static float qS2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return (-(float).125 + r/s)/x;
 }
diff --git a/newlib/libm/mathfp/ef_j1.c b/newlib/libm/mathfp/ef_j1.c
index 636a4c9..81de85b 100644
--- a/newlib/libm/mathfp/ef_j1.c
+++ b/newlib/libm/mathfp/ef_j1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_j1.c -- float version of e_j1.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -129,9 +130,18 @@ static float V0[5] = {
 	GET_FLOAT_WORD(hx,x);
         ix = 0x7fffffff&hx;
     /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
-	if(ix>=0x7f800000) return  one/(x+x*x); 
-        if(ix==0) return -one/zero;
-        if(hx<0) return zero/zero;
+	if(ix>=0x7f800000) {
+                __A_VARIABLE = 1;
+                return  one/(x+x*x);
+        } 
+        if(ix==0) {
+                __A_VARIABLE = 1;
+                return -one/zero;
+        }
+        if(hx<0) {
+                __A_VARIABLE = 1;
+                return zero/zero;
+        }
         if(ix >= 0x40000000) {  /* |x| >= 2.0 */
                 s = sinf(x);
                 c = cosf(x);
@@ -158,14 +168,17 @@ static float V0[5] = {
                     u = ponef(x); v = qonef(x);
                     z = invsqrtpi*(u*ss+v*cc)/sqrtf(x);
                 }
+                __A_VARIABLE = 1;
                 return z;
         } 
         if(ix<=0x24800000) {    /* x < 2**-54 */
+            __A_VARIABLE = 1;
             return(-tpi/x);
         } 
         z = x*x;
         u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
         v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
+        __A_VARIABLE = 1;
         return(x*(u/v) + tpi*(j1f(x)*logf(x)-one/x));
 }
 
@@ -298,6 +311,7 @@ static float ps2[5] = {
         z = one/(x*x);
         r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
         s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+        __A_VARIABLE = 1;
         return one+ r/s;
 }
 		
@@ -435,5 +449,6 @@ static float qs2[6] = {
 	z = one/(x*x);
 	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
 	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	__A_VARIABLE = 1;
 	return ((float).375 + r/s)/x;
 }
diff --git a/newlib/libm/mathfp/ef_remainder.c b/newlib/libm/mathfp/ef_remainder.c
index 92958ef..a2a607f 100644
--- a/newlib/libm/mathfp/ef_remainder.c
+++ b/newlib/libm/mathfp/ef_remainder.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_remainder.c -- float version of e_remainder.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -40,14 +41,22 @@ static float zero = 0.0;
 	hx &= 0x7fffffff;
 
     /* purge off exception values */
-	if(hp==0) return (x*p)/(x*p);	 	/* p = 0 */
+	if(hp==0) {
+	    __A_VARIABLE = 1;
+	    return (x*p)/(x*p);
+	}	 	/* p = 0 */
 	if((hx>=0x7f800000)||			/* x not finite */
-	  ((hp>0x7f800000)))			/* p is NaN */
+	  ((hp>0x7f800000)))			/* p is NaN */ {
+	    __A_VARIABLE = 1;
 	    return (x*p)/(x*p);
+	}
 
 
 	if (hp<=0x7effffff) x = fmodf(x,p+p);	/* now x < 2p */
-	if ((hx-hp)==0) return zero*x;
+	if ((hx-hp)==0) {
+	    __A_VARIABLE = 1;
+	    return zero*x;
+	}
 	x  = fabsf(x);
 	p  = fabsf(p);
 	if (hp<0x01000000) {
@@ -64,5 +73,6 @@ static float zero = 0.0;
 	}
 	GET_FLOAT_WORD(hx,x);
 	SET_FLOAT_WORD(x,hx^sx);
+	__A_VARIABLE = 1;
 	return x;
 }
diff --git a/newlib/libm/mathfp/ef_scalb.c b/newlib/libm/mathfp/ef_scalb.c
index 901f177..cfce0ab 100644
--- a/newlib/libm/mathfp/ef_scalb.c
+++ b/newlib/libm/mathfp/ef_scalb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_scalb.c -- float version of e_scalb.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/er_gamma.c b/newlib/libm/mathfp/er_gamma.c
index 0060ed0..7d58e22 100644
--- a/newlib/libm/mathfp/er_gamma.c
+++ b/newlib/libm/mathfp/er_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)er_gamma.c 5.1 93/09/24 */
 /*
@@ -28,10 +29,12 @@
 	double x; int *signgamp;
 #endif
 {
+	__A_VARIABLE = 1;
 	return exp (lgamma_r(x,signgamp));
 }
 
 double gamma(double x)
 {
+  __A_VARIABLE = 1;
   return gamma_r(x, &(_REENT_SIGNGAM(_REENT)));
 }
diff --git a/newlib/libm/mathfp/er_lgamma.c b/newlib/libm/mathfp/er_lgamma.c
index fd49c25..68a3feb 100644
--- a/newlib/libm/mathfp/er_lgamma.c
+++ b/newlib/libm/mathfp/er_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)er_lgamma.c 5.1 93/09/24 */
 /*
@@ -285,7 +286,10 @@ static double zero=  0.00000000000000000000e+00;
 	GET_HIGH_WORD(ix,x);
 	ix &= 0x7fffffff;
 
-	if(ix<0x3fd00000) return sin(pi*x);
+	if(ix<0x3fd00000) {
+	    __A_VARIABLE = 1;
+	    return sin(pi*x);
+	}
 	y = -x;		/* x is assume negative */
 
     /*
@@ -318,6 +322,7 @@ static double zero=  0.00000000000000000000e+00;
 	    case 6:   y = -cos(pi*(y-1.5)); break;
 	    default:  y =  sin(pi*(y-2.0)); break;
 	    }
+	__A_VARIABLE = 1;
 	return -y;
 }
 
@@ -426,5 +431,6 @@ static double zero=  0.00000000000000000000e+00;
 double
 lgamma(double x)
 {
+  __A_VARIABLE = 1;
   return lgamma_r(x, &(_REENT_SIGNGAM(_REENT)));
 }
diff --git a/newlib/libm/mathfp/erf_gamma.c b/newlib/libm/mathfp/erf_gamma.c
index 246645d..0d86ab2 100644
--- a/newlib/libm/mathfp/erf_gamma.c
+++ b/newlib/libm/mathfp/erf_gamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* erf_gamma.c -- float version of er_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -30,10 +31,12 @@
 	float x; int *signgamp;
 #endif
 {
+	__A_VARIABLE = 1;
 	return expf (lgammaf_r(x,signgamp));
 }
 
 float gammaf(float x)
 {
+  __A_VARIABLE = 1;
   return gammaf_r(x, &(_REENT_SIGNGAM(_REENT)));
 }
diff --git a/newlib/libm/mathfp/erf_lgamma.c b/newlib/libm/mathfp/erf_lgamma.c
index 4f09214..8f313b0 100644
--- a/newlib/libm/mathfp/erf_lgamma.c
+++ b/newlib/libm/mathfp/erf_lgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* erf_lgamma.c -- float version of er_lgamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -107,7 +108,10 @@ static float zero=  0.0000000000e+00;
 	GET_FLOAT_WORD(ix,x);
 	ix &= 0x7fffffff;
 
-	if(ix<0x3e800000) return sinf(pi*x);
+	if(ix<0x3e800000) {
+	    __A_VARIABLE = 1;
+	    return sinf(pi*x);
+	}
 	y = -x;		/* x is assume negative */
 
     /*
@@ -140,6 +144,7 @@ static float zero=  0.0000000000e+00;
 	    case 6:   y = -cosf(pi*(y-(float)1.5)); break;
 	    default:  y =  sinf(pi*(y-(float)2.0)); break;
 	    }
+	__A_VARIABLE = 1;
 	return -y;
 }
 
@@ -247,5 +252,6 @@ static float zero=  0.0000000000e+00;
 
 float lgammaf(float x)
 {
+  __A_VARIABLE = 1;
   return lgammaf_r(x, &(_REENT_SIGNGAM(_REENT)));
 }
diff --git a/newlib/libm/mathfp/s_acos.c b/newlib/libm/mathfp/s_acos.c
index 051afea..e8831ee 100644
--- a/newlib/libm/mathfp/s_acos.c
+++ b/newlib/libm/mathfp/s_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_acos.c 1.0 98/08/13 */
 
@@ -88,6 +89,7 @@ double
 _DEFUN (acos, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (asine (x, 1));
 }
 
diff --git a/newlib/libm/mathfp/s_asin.c b/newlib/libm/mathfp/s_asin.c
index 477bbf5..e3cb4bf 100644
--- a/newlib/libm/mathfp/s_asin.c
+++ b/newlib/libm/mathfp/s_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_asin.c 1.0 98/08/13 */
 /******************************************************************
@@ -23,6 +24,7 @@ double
 _DEFUN (asin, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (asine (x, 0));
 }
 
diff --git a/newlib/libm/mathfp/s_asine.c b/newlib/libm/mathfp/s_asine.c
index 89a2bed..72547b9 100644
--- a/newlib/libm/mathfp/s_asine.c
+++ b/newlib/libm/mathfp/s_asine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_asine.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_asinh.c b/newlib/libm/mathfp/s_asinh.c
index d70cc61..233c8ec 100644
--- a/newlib/libm/mathfp/s_asinh.c
+++ b/newlib/libm/mathfp/s_asinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_asinh.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/s_atan.c b/newlib/libm/mathfp/s_atan.c
index a5a8189..25037f7 100644
--- a/newlib/libm/mathfp/s_atan.c
+++ b/newlib/libm/mathfp/s_atan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atan.c 1.0 98/08/13 */
 
@@ -69,13 +70,17 @@ _DEFUN (atan, (double),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         /* this should check to see if neg NaN or pos NaN... */
+        __A_VARIABLE = 1;
         return (__PI_OVER_TWO);
       case 0:
+        __A_VARIABLE = 1;
         return (0.0);
       default:
+        __A_VARIABLE = 1;
         return (atangent (x, 0, 0, 0));
     }
 }
diff --git a/newlib/libm/mathfp/s_atan2.c b/newlib/libm/mathfp/s_atan2.c
index 60034b3..6602c25 100644
--- a/newlib/libm/mathfp/s_atan2.c
+++ b/newlib/libm/mathfp/s_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atan2.c 1.0 98/08/13 */
 
@@ -83,6 +84,7 @@ _DEFUN (atan2, (double, double),
         double v _AND
         double u)
 {
+  __A_VARIABLE = 1;
   return (atangent (0.0, v, u, 1));
 }
 
diff --git a/newlib/libm/mathfp/s_atangent.c b/newlib/libm/mathfp/s_atangent.c
index 0a7c4d2..9f37ed6 100644
--- a/newlib/libm/mathfp/s_atangent.c
+++ b/newlib/libm/mathfp/s_atangent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atangent.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_ceil.c b/newlib/libm/mathfp/s_ceil.c
index c6ecbe3..9012b84 100644
--- a/newlib/libm/mathfp/s_ceil.c
+++ b/newlib/libm/mathfp/s_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_ceil.c 1.0 98/08/13 */
 /*****************************************************************
diff --git a/newlib/libm/mathfp/s_cos.c b/newlib/libm/mathfp/s_cos.c
index 6f63a40..7548635 100644
--- a/newlib/libm/mathfp/s_cos.c
+++ b/newlib/libm/mathfp/s_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_cos.c 1.0 98/08/13 */
 /******************************************************************
@@ -23,6 +24,7 @@ double
 _DEFUN (cos, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (sine (x, 1));
 }
 
diff --git a/newlib/libm/mathfp/s_cosh.c b/newlib/libm/mathfp/s_cosh.c
index f914110..a943073 100644
--- a/newlib/libm/mathfp/s_cosh.c
+++ b/newlib/libm/mathfp/s_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_cosh.c 1.0 98/08/13 */
 
@@ -74,6 +75,7 @@ double
 _DEFUN (cosh, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (sineh (x, 1));
 }
 
diff --git a/newlib/libm/mathfp/s_erf.c b/newlib/libm/mathfp/s_erf.c
index 2d8faa3..9baadf4 100644
--- a/newlib/libm/mathfp/s_erf.c
+++ b/newlib/libm/mathfp/s_erf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_erf.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/s_exp.c b/newlib/libm/mathfp/s_exp.c
index e70699b..1e6dc4e 100644
--- a/newlib/libm/mathfp/s_exp.c
+++ b/newlib/libm/mathfp/s_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_exp.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_exp2.c b/newlib/libm/mathfp/s_exp2.c
index 3bcf7ca..e1baba7 100644
--- a/newlib/libm/mathfp/s_exp2.c
+++ b/newlib/libm/mathfp/s_exp2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -12,6 +13,7 @@ double
 _DEFUN (exp2, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return pow(2.0, x);
 }
 
diff --git a/newlib/libm/mathfp/s_fabs.c b/newlib/libm/mathfp/s_fabs.c
index 9e1d75e..13fae62 100644
--- a/newlib/libm/mathfp/s_fabs.c
+++ b/newlib/libm/mathfp/s_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_fabs.c 1.0 98/08/13 */
 
@@ -66,13 +67,17 @@ _DEFUN (fabs, (double),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = ERANGE;
+        __A_VARIABLE = 1;
         return (x);
       case 0:
+        __A_VARIABLE = 1;
         return (0.0);
       default:
+        __A_VARIABLE = 1;
         return (x < 0.0 ? -x : x);
     }
 }
diff --git a/newlib/libm/mathfp/s_floor.c b/newlib/libm/mathfp/s_floor.c
index 0dbc207..cfa2db6 100644
--- a/newlib/libm/mathfp/s_floor.c
+++ b/newlib/libm/mathfp/s_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_floor.c 1.0 98/08/13 */
 
@@ -78,14 +79,19 @@ _DEFUN (floor, (double),
 {
   double f, y;
 
-  if (x > -1.0 && x < 1.0)
+  if (x > -1.0 && x < 1.0) {
+    __A_VARIABLE = 1;
     return (x >= 0 ? 0 : -1.0);
+  }
 
   y = modf (x, &f);
 
-  if (y == 0.0)
+  if (y == 0.0) {
+    __A_VARIABLE = 1;
     return (x);
+  }
 
+  __A_VARIABLE = 1;
   return (x >= 0 ? f : f - 1.0);
 }
 
diff --git a/newlib/libm/mathfp/s_fmod.c b/newlib/libm/mathfp/s_fmod.c
index 19bba9c..bf1b1be 100644
--- a/newlib/libm/mathfp/s_fmod.c
+++ b/newlib/libm/mathfp/s_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_fmod.c 1.0 98/08/13 */
 /*
diff --git a/newlib/libm/mathfp/s_frexp.c b/newlib/libm/mathfp/s_frexp.c
index 54fa336..7b13069 100644
--- a/newlib/libm/mathfp/s_frexp.c
+++ b/newlib/libm/mathfp/s_frexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_frexp.c 1.0 98/08/13 */
 
@@ -90,6 +91,7 @@ double frexp (double d, int *exp)
         errno = EDOM;
       case 0:
         *exp = 0;
+        __A_VARIABLE = 1;
         return (d);
     }
 
@@ -105,6 +107,7 @@ double frexp (double d, int *exp)
 
   INSERT_WORDS (f, hf, lf);
 
+  __A_VARIABLE = 1;
   return (f);
 }
 
diff --git a/newlib/libm/mathfp/s_ispos.c b/newlib/libm/mathfp/s_ispos.c
index 2077999..cddcf68 100644
--- a/newlib/libm/mathfp/s_ispos.c
+++ b/newlib/libm/mathfp/s_ispos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_ispos.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_ldexp.c b/newlib/libm/mathfp/s_ldexp.c
index 6da4128..3a676d1 100644
--- a/newlib/libm/mathfp/s_ldexp.c
+++ b/newlib/libm/mathfp/s_ldexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_ldexp.c 1.0 98/08/13 */
 
@@ -119,6 +120,7 @@ _DEFUN (ldexp, (double, int),
          }
     }
 
+    __A_VARIABLE = 1;
     return (d);
 }
 
diff --git a/newlib/libm/mathfp/s_log.c b/newlib/libm/mathfp/s_log.c
index 27b9598..b29c171 100644
--- a/newlib/libm/mathfp/s_log.c
+++ b/newlib/libm/mathfp/s_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_log.c 1.0 98/08/13 */
 /******************************************************************
@@ -23,6 +24,7 @@ double
 _DEFUN (log, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (logarithm (x, 0));
 }
 
diff --git a/newlib/libm/mathfp/s_log10.c b/newlib/libm/mathfp/s_log10.c
index 080cecd..d4071ca 100644
--- a/newlib/libm/mathfp/s_log10.c
+++ b/newlib/libm/mathfp/s_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_log10.c 1.0 98/08/13 */
 /******************************************************************
@@ -62,6 +63,7 @@ double
 _DEFUN (log10, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (logarithm (x, 1));
 }
 
diff --git a/newlib/libm/mathfp/s_logarithm.c b/newlib/libm/mathfp/s_logarithm.c
index 51e7f30..95e451b 100644
--- a/newlib/libm/mathfp/s_logarithm.c
+++ b/newlib/libm/mathfp/s_logarithm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_logarithm.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_mathcnst.c b/newlib/libm/mathfp/s_mathcnst.c
index a847ee4..31c7c47 100644
--- a/newlib/libm/mathfp/s_mathcnst.c
+++ b/newlib/libm/mathfp/s_mathcnst.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)z_mathcnst.c 1.0 98/08/13 */
 
 #include "zmath.h"
diff --git a/newlib/libm/mathfp/s_numtest.c b/newlib/libm/mathfp/s_numtest.c
index b41bb87..c29f748 100644
--- a/newlib/libm/mathfp/s_numtest.c
+++ b/newlib/libm/mathfp/s_numtest.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_numtest.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_pow.c b/newlib/libm/mathfp/s_pow.c
index 90d9d0b..d42968f 100644
--- a/newlib/libm/mathfp/s_pow.c
+++ b/newlib/libm/mathfp/s_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_pow.c 1.0 98/08/13 */
 
diff --git a/newlib/libm/mathfp/s_signif.c b/newlib/libm/mathfp/s_signif.c
index 76b5f7c..b5519ec 100644
--- a/newlib/libm/mathfp/s_signif.c
+++ b/newlib/libm/mathfp/s_signif.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)s_signif.c 5.1 93/09/24 */
 /*
@@ -28,6 +29,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return scalb(x,(double) -ilogb(x));
 }
 
diff --git a/newlib/libm/mathfp/s_sin.c b/newlib/libm/mathfp/s_sin.c
index 2051304..2a260c6 100644
--- a/newlib/libm/mathfp/s_sin.c
+++ b/newlib/libm/mathfp/s_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sin.c 1.0 98/08/13 */
 /******************************************************************
@@ -23,6 +24,7 @@ double
 _DEFUN (sin, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (sine (x, 0));
 }
 
diff --git a/newlib/libm/mathfp/s_sincos.c b/newlib/libm/mathfp/s_sincos.c
index e313e6f..835b775 100644
--- a/newlib/libm/mathfp/s_sincos.c
+++ b/newlib/libm/mathfp/s_sincos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sin.c 1.0 98/08/13 */
 /******************************************************************
@@ -27,6 +28,7 @@ _DEFUN (sincos, (x, sinx, cosx),
 {
   *sinx = sin (x);
   *cosx = cos (x);
+  __A_VARIABLE = 1;
 }
 
 #endif /* _DOUBLE_IS_32BITS */
diff --git a/newlib/libm/mathfp/s_sine.c b/newlib/libm/mathfp/s_sine.c
index 9642f4a..9e1abf4 100644
--- a/newlib/libm/mathfp/s_sine.c
+++ b/newlib/libm/mathfp/s_sine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sine.c 1.0 98/08/13 */
 /******************************************************************
@@ -96,9 +97,11 @@ _DEFUN (sine, (double, int),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (z_notanum.d); 
     }
 
@@ -126,6 +129,7 @@ _DEFUN (sine, (double, int),
   if (y > YMAX)
     {
       errno = ERANGE;
+      __A_VARIABLE = 1;
       return (x);
     }
 
@@ -160,6 +164,7 @@ _DEFUN (sine, (double, int),
  
   res *= sgn;
 
+  __A_VARIABLE = 1;
   return (res);
 }
 
diff --git a/newlib/libm/mathfp/s_sineh.c b/newlib/libm/mathfp/s_sineh.c
index 6f5e208..6fc0f3e 100644
--- a/newlib/libm/mathfp/s_sineh.c
+++ b/newlib/libm/mathfp/s_sineh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sineh.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/s_sinf.c b/newlib/libm/mathfp/s_sinf.c
index b738a49..bdb0c94 100644
--- a/newlib/libm/mathfp/s_sinf.c
+++ b/newlib/libm/mathfp/s_sinf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (sinf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (sinef (x, 0));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (sinf, (float),
 
 double sin (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sinf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/s_sinh.c b/newlib/libm/mathfp/s_sinh.c
index c600ee0..bcc6c91 100644
--- a/newlib/libm/mathfp/s_sinh.c
+++ b/newlib/libm/mathfp/s_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinh.c 1.0 98/08/13 */
 /******************************************************************
@@ -23,6 +24,7 @@ double
 _DEFUN (sinh, (double),
         double x)
 {
+  __A_VARIABLE = 1;
   return (sineh (x, 0));
 }
 
diff --git a/newlib/libm/mathfp/s_sqrt.c b/newlib/libm/mathfp/s_sqrt.c
index bafbb38..0081cff 100644
--- a/newlib/libm/mathfp/s_sqrt.c
+++ b/newlib/libm/mathfp/s_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sqrt.c 1.0 98/08/13 */
 /*****************************************************************
diff --git a/newlib/libm/mathfp/s_tan.c b/newlib/libm/mathfp/s_tan.c
index 725aeec..8be3219 100644
--- a/newlib/libm/mathfp/s_tan.c
+++ b/newlib/libm/mathfp/s_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_tan.c 1.0 98/08/13 */
 /******************************************************************
@@ -83,9 +84,11 @@ _DEFUN (tan, (double),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (z_notanum.d);
     }
 
@@ -95,6 +98,7 @@ _DEFUN (tan, (double),
   if (y > 105414357.0)
     {
       errno = ERANGE;
+      __A_VARIABLE = 1;
       return (y);
     }
 
@@ -133,6 +137,7 @@ _DEFUN (tan, (double),
       res = xnum / xden;
     }
 
+  __A_VARIABLE = 1;
   return (res);
 }
 
diff --git a/newlib/libm/mathfp/s_tanh.c b/newlib/libm/mathfp/s_tanh.c
index a19855e..56492b0 100644
--- a/newlib/libm/mathfp/s_tanh.c
+++ b/newlib/libm/mathfp/s_tanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_tanh.c 1.0 98/08/13 */
 /*****************************************************************
@@ -111,6 +112,7 @@ _DEFUN (tanh, (double),
   if (x < 0.0)
     res = -res;
 
+  __A_VARIABLE = 1;
   return (res);
 }
 
diff --git a/newlib/libm/mathfp/s_tgamma.c b/newlib/libm/mathfp/s_tgamma.c
index 4caf270..48e9922 100644
--- a/newlib/libm/mathfp/s_tgamma.c
+++ b/newlib/libm/mathfp/s_tgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* @(#)w_gamma.c 5.1 93/09/24 */
 /*
  * ====================================================
diff --git a/newlib/libm/mathfp/sf_acos.c b/newlib/libm/mathfp/sf_acos.c
index 6bef980..758c277 100644
--- a/newlib/libm/mathfp/sf_acos.c
+++ b/newlib/libm/mathfp/sf_acos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_acosf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,12 +22,14 @@ float
 _DEFUN (acosf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (asinef (x, 1));
 }
 
 #ifdef _DOUBLE_IS_32BITS
 double acos (double x)
 {
+  __A_VARIABLE = 1;
   return (double) asinef ((float) x, 1);
 }
 
diff --git a/newlib/libm/mathfp/sf_asin.c b/newlib/libm/mathfp/sf_asin.c
index 92c33fd..98a6a8f 100644
--- a/newlib/libm/mathfp/sf_asin.c
+++ b/newlib/libm/mathfp/sf_asin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_asinf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (asinf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (asinef (x, 0));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (asinf, (float),
 
 double asin (double x)
 {
+  __A_VARIABLE = 1;
   return (double) asinef ((float) x, 0);
 }
 
diff --git a/newlib/libm/mathfp/sf_asine.c b/newlib/libm/mathfp/sf_asine.c
index 12ba289..12fec20 100644
--- a/newlib/libm/mathfp/sf_asine.c
+++ b/newlib/libm/mathfp/sf_asine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_asinef.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/sf_asinh.c b/newlib/libm/mathfp/sf_asinh.c
index ee07e39..d1f161d 100644
--- a/newlib/libm/mathfp/sf_asinh.c
+++ b/newlib/libm/mathfp/sf_asinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_asinh.c -- float version of s_asinh.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -60,6 +61,7 @@ huge=  1.0000000000e+30;
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) asinhf((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_atan.c b/newlib/libm/mathfp/sf_atan.c
index f0f5220..93699cf 100644
--- a/newlib/libm/mathfp/sf_atan.c
+++ b/newlib/libm/mathfp/sf_atan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atanf.c 1.0 98/08/13 */
 /******************************************************************
@@ -25,13 +26,17 @@ _DEFUN (atanf, (float),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         /* this should check to see if neg NaN or pos NaN... */
+        __A_VARIABLE = 1;
         return (__PI_OVER_TWO);
       case 0:
+        __A_VARIABLE = 1;
         return (0.0);
       default:
+        __A_VARIABLE = 1;
         return (atangentf (x, 0, 0, 0));
     }
 }
@@ -39,6 +44,7 @@ _DEFUN (atanf, (float),
 #ifdef _DOUBLE_IS_32BITS
 double atan (double x)
 {
+  __A_VARIABLE = 1;
   return (double) atangentf ((float) x, 0, 0, 0);
 }
 
diff --git a/newlib/libm/mathfp/sf_atan2.c b/newlib/libm/mathfp/sf_atan2.c
index 69c6123..da9b8a8 100644
--- a/newlib/libm/mathfp/sf_atan2.c
+++ b/newlib/libm/mathfp/sf_atan2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atan2f.c 1.0 98/08/13 */
 /******************************************************************
@@ -22,12 +23,14 @@ _DEFUN (atan2f, (float, float),
         float v _AND
         float u)
 {
+  __A_VARIABLE = 1;
   return (atangentf (0.0, v, u, 1));
 }
 
 #ifdef _DOUBLE_IS_32BITS
 double atan2 (double v, double u)
 {
+  __A_VARIABLE = 1;
   return (double) atangentf (0.0, (float) v, (float) u, 1);
 }
 
diff --git a/newlib/libm/mathfp/sf_atangent.c b/newlib/libm/mathfp/sf_atangent.c
index 7a8f0ce..99a81b9 100644
--- a/newlib/libm/mathfp/sf_atangent.c
+++ b/newlib/libm/mathfp/sf_atangent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_atangentf.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/sf_ceil.c b/newlib/libm/mathfp/sf_ceil.c
index bc8e140..026fbfe 100644
--- a/newlib/libm/mathfp/sf_ceil.c
+++ b/newlib/libm/mathfp/sf_ceil.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_ceilf.c 1.0 98/08/13 */
 /*****************************************************************
@@ -36,6 +37,7 @@ _DEFUN (ceilf, (float),
 #ifdef _DOUBLE_IS_32BITS
 double ceil (double x)
 {
+  __A_VARIABLE = 1;
   return (double) ceilf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_cos.c b/newlib/libm/mathfp/sf_cos.c
index 057663e..0061d02 100644
--- a/newlib/libm/mathfp/sf_cos.c
+++ b/newlib/libm/mathfp/sf_cos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_cosf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (cosf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (sinef (x, 1));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (cosf, (float),
 
 double cos (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sinef ((float) x, 1);
 }
 
diff --git a/newlib/libm/mathfp/sf_cosh.c b/newlib/libm/mathfp/sf_cosh.c
index 4635b71..7c4e08e 100644
--- a/newlib/libm/mathfp/sf_cosh.c
+++ b/newlib/libm/mathfp/sf_cosh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_coshf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,12 +22,14 @@ float
 _DEFUN (coshf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (sinehf (x, 1));
 }
 
 #ifdef _DOUBLE_IS_32BITS
 double cosh (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sinehf ((float) x, 1);
 }
 
diff --git a/newlib/libm/mathfp/sf_erf.c b/newlib/libm/mathfp/sf_erf.c
index aa209f6..a3e7c28 100644
--- a/newlib/libm/mathfp/sf_erf.c
+++ b/newlib/libm/mathfp/sf_erf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_erf.c -- float version of s_erf.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -230,6 +231,7 @@ sb7  = -2.2440952301e+01; /* 0xc1b38712 */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) erff((float) x);
 }
 
@@ -240,6 +242,7 @@ sb7  = -2.2440952301e+01; /* 0xc1b38712 */
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) erfcf((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_exp.c b/newlib/libm/mathfp/sf_exp.c
index e37fac5..bebbe2d 100644
--- a/newlib/libm/mathfp/sf_exp.c
+++ b/newlib/libm/mathfp/sf_exp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_expf.c 1.0 98/08/13 */
 /******************************************************************
@@ -86,6 +87,7 @@ _DEFUN (expf, (float),
 
 double exp (double x)
 {
+  __A_VARIABLE = 1;
   return (double) expf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_exp2.c b/newlib/libm/mathfp/sf_exp2.c
index 7e147c5..0447a4e 100644
--- a/newlib/libm/mathfp/sf_exp2.c
+++ b/newlib/libm/mathfp/sf_exp2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Copyright (C) 2002 by  Red Hat, Incorporated. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software
@@ -10,6 +11,7 @@ float
 _DEFUN (exp2f, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return powf(2.0, x);
 }
 
@@ -17,6 +19,7 @@ _DEFUN (exp2f, (float),
 
 double exp2 (double x)
 {
+  __A_VARIABLE = 1;
   return (double) exp2f ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_fabs.c b/newlib/libm/mathfp/sf_fabs.c
index 2661eab..ac4551a 100644
--- a/newlib/libm/mathfp/sf_fabs.c
+++ b/newlib/libm/mathfp/sf_fabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_fabsf.c 1.0 98/08/13 */
 /******************************************************************
@@ -25,13 +26,17 @@ _DEFUN (fabsf, (float),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = ERANGE;
+        __A_VARIABLE = 1;
         return (x);
       case 0:
+        __A_VARIABLE = 1;
         return (0.0);
       default:
+        __A_VARIABLE = 1;
         return (x < 0.0 ? -x : x);
     }
 }
@@ -39,6 +44,7 @@ _DEFUN (fabsf, (float),
 #ifdef _DOUBLE_IS_32BITS
 double fabs (double x)
 {
+  __A_VARIABLE = 1;
   return (double) fabsf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_floor.c b/newlib/libm/mathfp/sf_floor.c
index 1e0fb9e..689e525 100644
--- a/newlib/libm/mathfp/sf_floor.c
+++ b/newlib/libm/mathfp/sf_floor.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_floorf.c 1.0 98/08/13 */
 /*****************************************************************
@@ -23,20 +24,26 @@ _DEFUN (floorf, (float),
 {
   float f, y;
 
-  if (x > -1.0 && x < 1.0)
+  if (x > -1.0 && x < 1.0) {
+    __A_VARIABLE = 1;
     return (x >= 0 ? 0 : -1.0);
+  }
 
   y = modff (x, &f);
 
-  if (y == 0.0)
+  if (y == 0.0) {
+    __A_VARIABLE = 1;
     return (x);
+  }
 
+  __A_VARIABLE = 1;
   return (x >= 0 ? f : f - 1.0);
 }
 
 #ifdef _DOUBLE_IS_32BITS
 double floor (double x)
 {
+  __A_VARIABLE = 1;
   return (double) floorf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_fmod.c b/newlib/libm/mathfp/sf_fmod.c
index 0ac86bb..ddb7d5a 100644
--- a/newlib/libm/mathfp/sf_fmod.c
+++ b/newlib/libm/mathfp/sf_fmod.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ef_fmod.c -- float version of e_fmod.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/sf_frexp.c b/newlib/libm/mathfp/sf_frexp.c
index 7f25195..fa0f138 100644
--- a/newlib/libm/mathfp/sf_frexp.c
+++ b/newlib/libm/mathfp/sf_frexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_frexpf.c 1.0 98/08/13 */
 /******************************************************************
@@ -32,6 +33,7 @@ float frexpf (float d, int *exp)
         errno = EDOM;
       case 0:
         *exp = 0;
+        __A_VARIABLE = 1;
         return (d);
     }
 
@@ -46,6 +48,7 @@ float frexpf (float d, int *exp)
 
   SET_FLOAT_WORD (f, wf);
 
+  __A_VARIABLE = 1;
   return (f);
 }
 
@@ -53,6 +56,7 @@ float frexpf (float d, int *exp)
 
 double frexp (double x, int *exp)
 {
+  __A_VARIABLE = 1;
   return (double) frexpf ((float) x, exp);
 }
 
diff --git a/newlib/libm/mathfp/sf_ispos.c b/newlib/libm/mathfp/sf_ispos.c
index 1b91f39..bf3f0e0 100644
--- a/newlib/libm/mathfp/sf_ispos.c
+++ b/newlib/libm/mathfp/sf_ispos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_isposf.c 1.0 98/08/13 */
 /******************************************************************
@@ -34,6 +35,7 @@ int isposf (float x)
 
 int ispos (double x)
 {
+  __A_VARIABLE = 1;
   return isposf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_ldexp.c b/newlib/libm/mathfp/sf_ldexp.c
index 6b6c2c0..cad1804 100644
--- a/newlib/libm/mathfp/sf_ldexp.c
+++ b/newlib/libm/mathfp/sf_ldexp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_ldexpf.c 1.0 98/08/13 */
 /******************************************************************
@@ -68,6 +69,7 @@ _DEFUN (ldexpf, (float, int),
          }
     }
 
+    __A_VARIABLE = 1;
     return (d);
 }
 
@@ -75,6 +77,7 @@ _DEFUN (ldexpf, (float, int),
 
 double ldexp (double x, int e)
 {
+  __A_VARIABLE = 1;
   return (double) ldexpf ((float) x, e);
 }
 
diff --git a/newlib/libm/mathfp/sf_log.c b/newlib/libm/mathfp/sf_log.c
index b746d44..d2732b7 100644
--- a/newlib/libm/mathfp/sf_log.c
+++ b/newlib/libm/mathfp/sf_log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_logf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (logf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (logarithmf (x, 0));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (logf, (float),
 
 double log (double x)
 {
+  __A_VARIABLE = 1;
   return (double) logf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_log10.c b/newlib/libm/mathfp/sf_log10.c
index 444e535..c19954b 100644
--- a/newlib/libm/mathfp/sf_log10.c
+++ b/newlib/libm/mathfp/sf_log10.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_log10f.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (log10f, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (logarithmf (x, 1));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (log10f, (float),
 
 double log10 (double x)
 {
+  __A_VARIABLE = 1;
   return (double) log10f ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_logarithm.c b/newlib/libm/mathfp/sf_logarithm.c
index c22ba86..1b054ac 100644
--- a/newlib/libm/mathfp/sf_logarithm.c
+++ b/newlib/libm/mathfp/sf_logarithm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_logarithmf.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/sf_numtest.c b/newlib/libm/mathfp/sf_numtest.c
index 00bab3a..990f7fc 100644
--- a/newlib/libm/mathfp/sf_numtest.c
+++ b/newlib/libm/mathfp/sf_numtest.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_numtestf.c 1.0 98/08/13 */
 /******************************************************************
@@ -57,6 +58,7 @@ _DEFUN (numtestf, (float),
 
 int numtest (double x)
 {
+  __A_VARIABLE = 1;
   return numtestf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_pow.c b/newlib/libm/mathfp/sf_pow.c
index 489a71d..0e2188f 100644
--- a/newlib/libm/mathfp/sf_pow.c
+++ b/newlib/libm/mathfp/sf_pow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_powf.c 1.0 98/08/13 */
 #include <float.h>
@@ -119,6 +120,7 @@ float powf (float x, float y)
 
 double pow (double x, double y)
 {
+  __A_VARIABLE = 1;
   return (double) powf ((float) x, (float) y);
 }
 
diff --git a/newlib/libm/mathfp/sf_signif.c b/newlib/libm/mathfp/sf_signif.c
index 35427f9..6d6c15b 100644
--- a/newlib/libm/mathfp/sf_signif.c
+++ b/newlib/libm/mathfp/sf_signif.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sf_signif.c -- float version of s_signif.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -22,6 +23,7 @@
 	float x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return scalbf(x,(float) -ilogbf(x));
 }
 
@@ -34,6 +36,7 @@
 	double x;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) significandf((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_sin.c b/newlib/libm/mathfp/sf_sin.c
index c68e18e..5b162e1 100644
--- a/newlib/libm/mathfp/sf_sin.c
+++ b/newlib/libm/mathfp/sf_sin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (sinf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (sinef (x, 0));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (sinf, (float),
 
 double sin (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sinef ((float) x, 0);
 }
 
diff --git a/newlib/libm/mathfp/sf_sincos.c b/newlib/libm/mathfp/sf_sincos.c
index e192b4b..7fa64e9 100644
--- a/newlib/libm/mathfp/sf_sincos.c
+++ b/newlib/libm/mathfp/sf_sincos.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinf.c 1.0 98/08/13 */
 /******************************************************************
@@ -25,6 +26,7 @@ _DEFUN (sincosf, (x, sinx, cosx),
 {
   *sinx = sin (x);
   *cosx = cos (x);
+  __A_VARIABLE = 1;
 }
 
 #ifdef _DOUBLE_IS_32BITS
@@ -34,6 +36,7 @@ sincos (double x, double *sinx, double *cosx)
 {
   *sinx = (double) sinf ((float) x);
   *cosx = (double) cosf ((float) x);
+  __A_VARIABLE = 1;
 }
 
 #endif /* defined(_DOUBLE_IS_32BITS) */
diff --git a/newlib/libm/mathfp/sf_sine.c b/newlib/libm/mathfp/sf_sine.c
index 6932de2..f519c5f 100644
--- a/newlib/libm/mathfp/sf_sine.c
+++ b/newlib/libm/mathfp/sf_sine.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinef.c 1.0 98/08/13 */
 /******************************************************************
@@ -44,9 +45,11 @@ _DEFUN (sinef, (float, int),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (z_notanum_f.f); 
     }
 
@@ -74,6 +77,7 @@ _DEFUN (sinef, (float, int),
   if (y > YMAX)
     {
       errno = ERANGE;
+      __A_VARIABLE = 1;
       return (x);
     }
 
@@ -108,5 +112,6 @@ _DEFUN (sinef, (float, int),
  
   res *= sgn;
 
+  __A_VARIABLE = 1;
   return (res);
 }
diff --git a/newlib/libm/mathfp/sf_sineh.c b/newlib/libm/mathfp/sf_sineh.c
index 4eee2c9..2c8322e 100644
--- a/newlib/libm/mathfp/sf_sineh.c
+++ b/newlib/libm/mathfp/sf_sineh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinehf.c 1.0 98/08/13 */
 /******************************************************************
diff --git a/newlib/libm/mathfp/sf_sinh.c b/newlib/libm/mathfp/sf_sinh.c
index a50e566..5b80ff6 100644
--- a/newlib/libm/mathfp/sf_sinh.c
+++ b/newlib/libm/mathfp/sf_sinh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sinhf.c 1.0 98/08/13 */
 /******************************************************************
@@ -21,6 +22,7 @@ float
 _DEFUN (sinhf, (float),
         float x)
 {
+  __A_VARIABLE = 1;
   return (sinehf (x, 0));
 }
 
@@ -28,6 +30,7 @@ _DEFUN (sinhf, (float),
 
 double sinh (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sinhf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_sqrt.c b/newlib/libm/mathfp/sf_sqrt.c
index 5d5410d..2579677 100644
--- a/newlib/libm/mathfp/sf_sqrt.c
+++ b/newlib/libm/mathfp/sf_sqrt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_sqrtf.c 1.0 98/08/13 */
 /*****************************************************************
@@ -94,6 +95,7 @@ _DEFUN (sqrtf, (float),
 
 double sqrt (double x)
 {
+  __A_VARIABLE = 1;
   return (double) sqrtf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_tan.c b/newlib/libm/mathfp/sf_tan.c
index fcde19a..fa0990e 100644
--- a/newlib/libm/mathfp/sf_tan.c
+++ b/newlib/libm/mathfp/sf_tan.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_tanf.c 1.0 98/08/13 */
 /******************************************************************
@@ -40,9 +41,11 @@ _DEFUN (tanf, (float),
     {
       case NAN:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (x);
       case INF:
         errno = EDOM;
+        __A_VARIABLE = 1;
         return (z_notanum_f.f);
     }
 
@@ -52,6 +55,7 @@ _DEFUN (tanf, (float),
   if (y > 105414357.0)
     {
       errno = ERANGE;
+      __A_VARIABLE = 1;
       return (y);
     }
 
@@ -91,6 +95,7 @@ _DEFUN (tanf, (float),
       res = xnum / xden;
     }
 
+  __A_VARIABLE = 1;
   return (res);
 }
 
@@ -98,6 +103,7 @@ _DEFUN (tanf, (float),
 
 double tan (double x)
 {
+  __A_VARIABLE = 1;
   return (double) tanf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_tanh.c b/newlib/libm/mathfp/sf_tanh.c
index 51806af..9f73bb7 100644
--- a/newlib/libm/mathfp/sf_tanh.c
+++ b/newlib/libm/mathfp/sf_tanh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)z_tanhf.c 1.0 98/08/13 */
 /*****************************************************************
@@ -64,6 +65,7 @@ _DEFUN (tanhf, (float),
   if (x < 0.0)
     res = -res;
 
+  __A_VARIABLE = 1;
   return (res);
 }
 
@@ -71,6 +73,7 @@ _DEFUN (tanhf, (float),
 
 double tanh (double x)
 {
+  __A_VARIABLE = 1;
   return (double) tanhf ((float) x);
 }
 
diff --git a/newlib/libm/mathfp/sf_tgamma.c b/newlib/libm/mathfp/sf_tgamma.c
index f4d1456..8bf5f0b 100644
--- a/newlib/libm/mathfp/sf_tgamma.c
+++ b/newlib/libm/mathfp/sf_tgamma.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* w_gammaf.c -- float version of w_gamma.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
diff --git a/newlib/libm/mathfp/w_cabs.c b/newlib/libm/mathfp/w_cabs.c
index bef7668..d3f2d9e 100644
--- a/newlib/libm/mathfp/w_cabs.c
+++ b/newlib/libm/mathfp/w_cabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cabs() wrapper for hypot().
  * 
@@ -16,5 +17,6 @@ double
 cabs(z)
 	struct complex z;
 {
+	__A_VARIABLE = 1;
 	return hypot(z.x, z.y);
 }
diff --git a/newlib/libm/mathfp/w_drem.c b/newlib/libm/mathfp/w_drem.c
index d289bda..d29e10c 100644
--- a/newlib/libm/mathfp/w_drem.c
+++ b/newlib/libm/mathfp/w_drem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * drem() wrapper for remainder().
  * 
@@ -11,5 +12,6 @@ double
 drem(x, y)
 	double x, y;
 {
+	__A_VARIABLE = 1;
 	return remainder(x, y);
 }
diff --git a/newlib/libm/mathfp/w_jn.c b/newlib/libm/mathfp/w_jn.c
index 14c2225..9158685 100644
--- a/newlib/libm/mathfp/w_jn.c
+++ b/newlib/libm/mathfp/w_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* @(#)w_jn.c 5.1 93/09/24 */
 /*
diff --git a/newlib/libm/mathfp/wf_cabs.c b/newlib/libm/mathfp/wf_cabs.c
index c3ed0ca..cce947c 100644
--- a/newlib/libm/mathfp/wf_cabs.c
+++ b/newlib/libm/mathfp/wf_cabs.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * cabsf() wrapper for hypotf().
  * 
@@ -16,5 +17,6 @@ float
 cabsf(z)
 	struct complex z;
 {
+	__A_VARIABLE = 1;
 	return hypotf(z.x, z.y);
 }
diff --git a/newlib/libm/mathfp/wf_drem.c b/newlib/libm/mathfp/wf_drem.c
index 7c3f7c5..d05447f 100644
--- a/newlib/libm/mathfp/wf_drem.c
+++ b/newlib/libm/mathfp/wf_drem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * dremf() wrapper for remainderf().
  * 
@@ -15,5 +16,6 @@ dremf(x, y)
 	float x, y;
 #endif
 {
+	__A_VARIABLE = 1;
 	return remainderf(x, y);
 }
diff --git a/newlib/libm/mathfp/wf_jn.c b/newlib/libm/mathfp/wf_jn.c
index ebc886d..d0fcf51 100644
--- a/newlib/libm/mathfp/wf_jn.c
+++ b/newlib/libm/mathfp/wf_jn.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* wf_jn.c -- float version of w_jn.c.
  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
  */
@@ -122,6 +123,7 @@
 	double x; int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) jnf(n, (float) x);
 }
 
@@ -132,6 +134,7 @@
 	double x; int n;
 #endif
 {
+	__A_VARIABLE = 1;
 	return (double) ynf(n, (float) x);
 }
 
diff --git a/newlib/libm/test/acos_vec.c b/newlib/libm/test/acos_vec.c
index 4288b7b..a1dbe15 100644
--- a/newlib/libm/test/acos_vec.c
+++ b/newlib/libm/test/acos_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type acos_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_acos(m)   {run_vector_1(m,acos_vec,(char *)(acos),"acos","dd");   }	
+test_acos(m)   {run_vector_1(m,acos_vec,(char *)(acos),"acos","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/acosf_vec.c b/newlib/libm/test/acosf_vec.c
index f7ed3db..128820c 100644
--- a/newlib/libm/test/acosf_vec.c
+++ b/newlib/libm/test/acosf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type acosf_vec[] = {
 { 1,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_acosf(m)   {run_vector_1(m,acosf_vec,(char *)(acosf),"acosf","ff");   }	
+test_acosf(m)   {run_vector_1(m,acosf_vec,(char *)(acosf),"acosf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/acosh_vec.c b/newlib/libm/test/acosh_vec.c
index 48f169c..f7d4a40 100644
--- a/newlib/libm/test/acosh_vec.c
+++ b/newlib/libm/test/acosh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type acosh_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x40101249, 0xc6ea2cbb, 0x403bcccc, 0xccccccc9},			/* 4.01786=f(27.8000)*/
 {64, 0,123,__LINE__, 0x40104f1a, 0xa2d94c29, 0x403d7fff, 0xfffffffc},			/* 4.07725=f(29.5000)*/
 0,};
-test_acosh(m)   {run_vector_1(m,acosh_vec,(char *)(acosh),"acosh","dd");   }	
+test_acosh(m)   {run_vector_1(m,acosh_vec,(char *)(acosh),"acosh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/acoshf_vec.c b/newlib/libm/test/acoshf_vec.c
index ba40d29..d29ffe7 100644
--- a/newlib/libm/test/acoshf_vec.c
+++ b/newlib/libm/test/acoshf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type acoshf_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {11, 0,123,__LINE__, 0x40101249, 0xc6280000, 0x403bcccc, 0xccccccc9},			/* 4.01785=f(27.8000)*/
 {11, 0,123,__LINE__, 0x40104f1a, 0xa0280000, 0x403d7fff, 0xfffffffc},			/* 4.07725=f(29.5000)*/
 0,};
-test_acoshf(m)   {run_vector_1(m,acoshf_vec,(char *)(acoshf),"acoshf","ff");   }	
+test_acoshf(m)   {run_vector_1(m,acoshf_vec,(char *)(acoshf),"acoshf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/asin_vec.c b/newlib/libm/test/asin_vec.c
index 4215cc7..b5304b8 100644
--- a/newlib/libm/test/asin_vec.c
+++ b/newlib/libm/test/asin_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type asin_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_asin(m)   {run_vector_1(m,asin_vec,(char *)(asin),"asin","dd");   }	
+test_asin(m)   {run_vector_1(m,asin_vec,(char *)(asin),"asin","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/asinf_vec.c b/newlib/libm/test/asinf_vec.c
index 7e1b271..0027de0 100644
--- a/newlib/libm/test/asinf_vec.c
+++ b/newlib/libm/test/asinf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type asinf_vec[] = {
 { 0,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_asinf(m)   {run_vector_1(m,asinf_vec,(char *)(asinf),"asinf","ff");   }	
+test_asinf(m)   {run_vector_1(m,asinf_vec,(char *)(asinf),"asinf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/asinh_vec.c b/newlib/libm/test/asinh_vec.c
index 67926d9..70851ea 100644
--- a/newlib/libm/test/asinh_vec.c
+++ b/newlib/libm/test/asinh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type asinh_vec[] = {
 {64, 0,123,__LINE__, 0xbff0416d, 0x0b8ea990, 0xbff33333, 0x33333333},			/* -1.01597=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x401012f3, 0x5ffa8bd3, 0x403bcccc, 0xccccccc9},			/* 4.01850=f(27.8000)*/
 {64, 0,123,__LINE__, 0x40104fb1, 0x4017a7cb, 0x403d7fff, 0xfffffffc},			/* 4.07782=f(29.5000)*/
 0,};
-test_asinh(m)   {run_vector_1(m,asinh_vec,(char *)(asinh),"asinh","dd");   }	
+test_asinh(m)   {run_vector_1(m,asinh_vec,(char *)(asinh),"asinh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/asinhf_vec.c b/newlib/libm/test/asinhf_vec.c
index d4b85eb..13a0eab 100644
--- a/newlib/libm/test/asinhf_vec.c
+++ b/newlib/libm/test/asinhf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type asinhf_vec[] = {
 {14, 0,123,__LINE__, 0xbff0416d, 0x20000000, 0xbff33333, 0x33333333},			/* -1.01597=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {11, 0,123,__LINE__, 0x401012f3, 0x60000000, 0x403bcccc, 0xccccccc9},			/* 4.01850=f(27.8000)*/
 {11, 0,123,__LINE__, 0x40104fb1, 0x40000000, 0x403d7fff, 0xfffffffc},			/* 4.07782=f(29.5000)*/
 0,};
-test_asinhf(m)   {run_vector_1(m,asinhf_vec,(char *)(asinhf),"asinhf","ff");   }	
+test_asinhf(m)   {run_vector_1(m,asinhf_vec,(char *)(asinhf),"asinhf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atan2_vec.c b/newlib/libm/test/atan2_vec.c
index 8021084..a849184 100644
--- a/newlib/libm/test/atan2_vec.c
+++ b/newlib/libm/test/atan2_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atan2_vec[] = {
 {62,0,123,__LINE__, 0xc002d97c, 0x7f3321d2, 0xbff00000, 0x00000000, 0xbff00000, 0x00000000},
@@ -1601,4 +1602,5 @@
 {62,0,123,__LINE__, 0x3fe9ff55, 0x5176d133, 0x3fee6666, 0x6666666d, 0x3feccccc, 0xccccccd3},
 {62,0,123,__LINE__, 0x3fe921fb, 0x54442d18, 0x3fee6666, 0x6666666d, 0x3fee6666, 0x6666666d},
 0,};
-test_atan2(m)   {run_vector_1(m,atan2_vec,(char *)(atan2),"atan2","ddd");   }	
+test_atan2(m)   {run_vector_1(m,atan2_vec,(char *)(atan2),"atan2","ddd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atan2f_vec.c b/newlib/libm/test/atan2f_vec.c
index f07ac8d..d4fcc42 100644
--- a/newlib/libm/test/atan2f_vec.c
+++ b/newlib/libm/test/atan2f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atan2f_vec[] = {
 {32,0,123,__LINE__, 0xc002d97c, 0x7f3321d2, 0xbff00000, 0x00000000, 0xbff00000, 0x00000000},
@@ -1601,4 +1602,5 @@
 {32,0,123,__LINE__, 0x3fe9ff55, 0x5176d133, 0x3fee6666, 0x6666666d, 0x3feccccc, 0xccccccd3},
 {32,0,123,__LINE__, 0x3fe921fb, 0x54442d18, 0x3fee6666, 0x6666666d, 0x3fee6666, 0x6666666d},
 0,};
-test_atan2f(m)   {run_vector_1(m,atan2f_vec,(char *)(atan2f),"atan2f","fff");   }	
+test_atan2f(m)   {run_vector_1(m,atan2f_vec,(char *)(atan2f),"atan2f","fff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atan_vec.c b/newlib/libm/test/atan_vec.c
index 12b44be..5cde8d0 100644
--- a/newlib/libm/test/atan_vec.c
+++ b/newlib/libm/test/atan_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atan_vec[] = {
 {64, 0,123,__LINE__, 0xbfec08aa, 0xe496efa6, 0xbff33333, 0x33333333},			/* -0.87605=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3ff88eb5, 0x0616141e, 0x403bcccc, 0xccccccc9},			/* 1.53484=f(27.8000)*/
 {64, 0,123,__LINE__, 0x3ff8972f, 0xfc482372, 0x403d7fff, 0xfffffffc},			/* 1.53691=f(29.5000)*/
 0,};
-test_atan(m)   {run_vector_1(m,atan_vec,(char *)(atan),"atan","dd");   }	
+test_atan(m)   {run_vector_1(m,atan_vec,(char *)(atan),"atan","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atanf_vec.c b/newlib/libm/test/atanf_vec.c
index c907fe5..2eea673 100644
--- a/newlib/libm/test/atanf_vec.c
+++ b/newlib/libm/test/atanf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atanf_vec[] = {
 {11, 0,123,__LINE__, 0xbfec08aa, 0xed5c7cec, 0xbff33333, 0x33333333},			/* -0.87605=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {13, 0,123,__LINE__, 0x3ff88eb5, 0x0612c894, 0x403bcccc, 0xccccccc9},			/* 1.53484=f(27.8000)*/
 {13, 0,123,__LINE__, 0x3ff8972f, 0xfbdc0a62, 0x403d7fff, 0xfffffffc},			/* 1.53691=f(29.5000)*/
 0,};
-test_atanf(m)   {run_vector_1(m,atanf_vec,(char *)(atanf),"atanf","ff");   }	
+test_atanf(m)   {run_vector_1(m,atanf_vec,(char *)(atanf),"atanf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atanh_vec.c b/newlib/libm/test/atanh_vec.c
index 3b53849..deead92 100644
--- a/newlib/libm/test/atanh_vec.c
+++ b/newlib/libm/test/atanh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atanh_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_atanh(m)   {run_vector_1(m,atanh_vec,(char *)(atanh),"atanh","dd");   }	
+test_atanh(m)   {run_vector_1(m,atanh_vec,(char *)(atanh),"atanh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/atanhf_vec.c b/newlib/libm/test/atanhf_vec.c
index 16a1144..cc7d1ed 100644
--- a/newlib/libm/test/atanhf_vec.c
+++ b/newlib/libm/test/atanhf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type atanhf_vec[] = {
 { 0,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 64.0000=f(27.8000)*/
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 64.0000=f(29.5000)*/
 0,};
-test_atanhf(m)   {run_vector_1(m,atanhf_vec,(char *)(atanhf),"atanhf","ff");   }	
+test_atanhf(m)   {run_vector_1(m,atanhf_vec,(char *)(atanhf),"atanhf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/ceil_vec.c b/newlib/libm/test/ceil_vec.c
index 9422299..6f18eb8 100644
--- a/newlib/libm/test/ceil_vec.c
+++ b/newlib/libm/test/ceil_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type ceil_vec[] = {
 {64, 0,123,__LINE__, 0xbff00000, 0x00000000, 0xbff33333, 0x33333333},			/* -1.00000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x403c0000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 28.0000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x403e0000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 30.0000=f(29.5000)*/
 0,};
-test_ceil(m)   {run_vector_1(m,ceil_vec,(char *)(ceil),"ceil","dd");   }	
+test_ceil(m)   {run_vector_1(m,ceil_vec,(char *)(ceil),"ceil","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/ceilf_vec.c b/newlib/libm/test/ceilf_vec.c
index 2c86955..0420339 100644
--- a/newlib/libm/test/ceilf_vec.c
+++ b/newlib/libm/test/ceilf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type ceilf_vec[] = {
 { 0, 0,123,__LINE__, 0xbff00000, 0x00000000, 0xbff33333, 0x33333333},			/* -1.00000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {13, 0,123,__LINE__, 0x403c0000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 28.0000=f(27.8000)*/
 {14, 0,123,__LINE__, 0x403e0000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 30.0000=f(29.5000)*/
 0,};
-test_ceilf(m)   {run_vector_1(m,ceilf_vec,(char *)(ceilf),"ceilf","ff");   }	
+test_ceilf(m)   {run_vector_1(m,ceilf_vec,(char *)(ceilf),"ceilf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/conv_vec.c b/newlib/libm/test/conv_vec.c
index 1190e1b..e7fbe13 100644
--- a/newlib/libm/test/conv_vec.c
+++ b/newlib/libm/test/conv_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 
 double_type doubles[] =
diff --git a/newlib/libm/test/convert.c b/newlib/libm/test/convert.c
index a748280..ddf22aa 100644
--- a/newlib/libm/test/convert.c
+++ b/newlib/libm/test/convert.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Test conversions */
 
 #include "test.h"
@@ -21,6 +22,7 @@ _DEFUN_VOID(test_strtod)
   v = strtod(pd->string, &tail);
   test_mok(v, pd->value, 64);
   test_iok(tail - pd->string, pd->endscan);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -32,18 +34,21 @@ _DEFUN_VOID(test_strtof)
   v = strtof(pd->string, &tail);
   test_mok(v, pd->value, 32);
   test_iok(tail - pd->string, pd->endscan);
+  __A_VARIABLE = 1;
 }
 
 void
 _DEFUN_VOID(test_atof)
 {
   test_mok(atof(pd->string), pd->value, 64);
+  __A_VARIABLE = 1;
 }
 
 void
 _DEFUN_VOID(test_atoff)
 {
   test_mok(atoff(pd->string), pd->value, 32);
+  __A_VARIABLE = 1;
 }
 
 
@@ -61,6 +66,7 @@ _DEFUN(iterate,(func, name),
     func();
     pd++;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -83,6 +89,7 @@ _DEFUN(int_iterate,(func, name),
     func();
     p++;
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -98,6 +105,7 @@ _DEFUN(test_strtol_base,(base, pi, string),
   test_iok(r, pi->value);
   test_eok(errno, pi->errno_val);
   test_iok(ptr - string, pi->end);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -108,6 +116,7 @@ _DEFUN_VOID(test_strtol)
   test_strtol_base(16, &(p->hex), p->string);
   test_strtol_base(0, &(p->normal), p->string);
   test_strtol_base(26, &(p->alphabetical), p->string);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -115,6 +124,7 @@ _DEFUN_VOID(test_atoi)
 {
   test_iok(atoi(p->string), p->decimal.value);
   test_eok(errno, p->decimal.errno_val);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -122,6 +132,7 @@ _DEFUN_VOID(test_atol)
 {
   test_iok(atol(p->string), p->decimal.value);
   test_eok(errno, p->decimal.errno_val);
+  __A_VARIABLE = 1;
 }
 
 /* test ECVT and friends */
@@ -137,6 +148,7 @@ _DEFUN_VOID(test_ecvtbuf)
   test_sok(s,pdd->estring);
   test_iok(pdd->e2,a2);
   test_iok(pdd->e3,a3);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -155,6 +167,7 @@ _DEFUN_VOID(test_ecvt)
   test_sok(s,pdd->estring);
   test_iok(pdd->e2,a2);
   test_iok(pdd->e3,a3);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -167,6 +180,7 @@ _DEFUN_VOID(test_fcvtbuf)
   test_scok(s,pdd->fstring,10);
   test_iok(pdd->f2,a2);
   test_iok(pdd->f3,a3);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -178,6 +192,7 @@ _DEFUN_VOID(test_gcvt)
   s = gcvtf(pdd->value, pdd->g1, buffer);  
   test_scok(s, pdd->gstring, 9);
 
+  __A_VARIABLE = 1;
 }
 
 void
@@ -202,6 +217,7 @@ _DEFUN_VOID(test_fcvt)
   test_mok(v1, v2,32);
   test_iok(pdd->f2,a2);
   test_iok(pdd->f3,a3);
+  __A_VARIABLE = 1;
 }
 
 static void
@@ -219,6 +235,7 @@ _DEFUN(diterate,(func, name),
     func();
     pdd++;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -250,6 +267,7 @@ _DEFUN_VOID(deltest)
   line(8);  
   sprintf(buffer,"%.0f", 12.3456789);
   test_sok(buffer,"12");
+  __A_VARIABLE = 1;
 }
 
 /* Most of what sprint does is tested with the tests of
@@ -282,6 +300,7 @@ _DEFUN_VOID(test_sprint)
     test_sok(buffer, si->result);
     si++;
   }  
+  __A_VARIABLE = 1;
 }
 
 /* Scanf calls strtod etc tested elsewhere, but also has some pattern matching skills */
@@ -337,6 +356,7 @@ _DEFUN_VOID(test_scan)
   test_sok("XYZZY", buffer);
   sscanf("magicXYZZYfoobar","%[^XYZ]", buffer);
   test_sok("magic", buffer);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -363,4 +383,5 @@ _DEFUN_VOID(test_cvt)
   int_iterate(test_atoi,"atoi");
   int_iterate(test_atol,"atol");
   int_iterate(test_strtol, "strtol");
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/test/cos_vec.c b/newlib/libm/test/cos_vec.c
index 37d669e..b1c974f 100644
--- a/newlib/libm/test/cos_vec.c
+++ b/newlib/libm/test/cos_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type cos_vec[] = {
 {64, 0,123,__LINE__, 0x3fd730de, 0x943b79d3, 0xbff33333, 0x33333333},			/* 0.36235=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0xbfec7794, 0x7992f3fe, 0x403bcccc, 0xccccccc9},			/* -0.88959=f(27.8000)*/
 {64, 0,123,__LINE__, 0xbfd5a705, 0x9eaeac12, 0x403d7fff, 0xfffffffc},			/* -0.33831=f(29.5000)*/
 0,};
-test_cos(m)   {run_vector_1(m,cos_vec,(char *)(cos),"cos","dd");   }	
+test_cos(m)   {run_vector_1(m,cos_vec,(char *)(cos),"cos","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/cosf_vec.c b/newlib/libm/test/cosf_vec.c
index 7e7d720..3b97144 100644
--- a/newlib/libm/test/cosf_vec.c
+++ b/newlib/libm/test/cosf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type cosf_vec[] = {
 {10, 0,123,__LINE__, 0x3fd730de, 0x6472104d, 0xbff33333, 0x33333333},			/* 0.36235=f(-1.20000)*/
@@ -284,4 +285,5 @@
 {11, 0,123,__LINE__, 0xbfec7793, 0xaf30f05a, 0x403bcccc, 0xccccccc9},			/* -0.88959=f(27.8000)*/
 { 0, 0,123,__LINE__, 0xbfd5a705, 0xdb0448d3, 0x403d7fff, 0xfffffffc},			/* -0.33831=f(29.5000)*/
 0,};
-test_cosf(m)   {run_vector_1(m,cosf_vec,(char *)(cosf),"cosf","ff");   }	
+test_cosf(m)   {run_vector_1(m,cosf_vec,(char *)(cosf),"cosf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/cosh_vec.c b/newlib/libm/test/cosh_vec.c
index c8d47e3..9e94c8a 100644
--- a/newlib/libm/test/cosh_vec.c
+++ b/newlib/libm/test/cosh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type cosh_vec[] = {
 {63, 0,123,__LINE__, 0x3ffcf871, 0xf8dfa802, 0xbff33333, 0x33333333},			/* 1.81065=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {63, 0,123,__LINE__, 0x42613b19, 0x1e69fb25, 0x403bcccc, 0xccccccc9},			/* 5.92048e+11=f(27.8000)*/
 {61, 0,123,__LINE__, 0x42879487, 0x9e85b8dc, 0x403d7fff, 0xfffffffc},			/* 3.24084e+12=f(29.5000)*/
 0,};
-test_cosh(m)   {run_vector_1(m,cosh_vec,(char *)(cosh),"cosh","dd");   }	
+test_cosh(m)   {run_vector_1(m,cosh_vec,(char *)(cosh),"cosh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/coshf_vec.c b/newlib/libm/test/coshf_vec.c
index d8f96bb..4c01f8a 100644
--- a/newlib/libm/test/coshf_vec.c
+++ b/newlib/libm/test/coshf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type coshf_vec[] = {
 {14, 0,123,__LINE__, 0x3ffcf872, 0x20000000, 0xbff33333, 0x33333333},			/* 1.81065=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 6, 0,123,__LINE__, 0x42613b16, 0xc0000000, 0x403bcccc, 0xccccccc9},			/* 5.92046e+11=f(27.8000)*/
 { 6, 0,123,__LINE__, 0x42879486, 0x60000000, 0x403d7fff, 0xfffffffc},			/* 3.24083e+12=f(29.5000)*/
 0,};
-test_coshf(m)   {run_vector_1(m,coshf_vec,(char *)(coshf),"coshf","ff");   }	
+test_coshf(m)   {run_vector_1(m,coshf_vec,(char *)(coshf),"coshf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/dcvt.c b/newlib/libm/test/dcvt.c
index 2aaa1af..1d6f40a 100644
--- a/newlib/libm/test/dcvt.c
+++ b/newlib/libm/test/dcvt.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 
 #include <limits.h>
@@ -34,6 +35,7 @@ double *value)
   double tmp;
   
   *value = modf (*value * 10, &tmp) ;
+  __A_VARIABLE = 1;
   return  lcset[(int)tmp];
 }
 
@@ -63,6 +65,7 @@ _DEFUN(print_nan,(buffer, value, precision),
       buffer[i++] = ' ';
     }
   buffer[i++] = 0;
+  __A_VARIABLE = 1;
   return buffer;
   
 }
@@ -126,6 +129,7 @@ _DEFUN(renormalize,(in),
     in->abs_exp = -in->exp;
   }
 
+  __A_VARIABLE = 1;
 }
 
 /* This routine looks at original_value, and makes it between 0 and 1,
@@ -193,6 +197,7 @@ _DEFUN(normalize,(value, in),
   in->original_value = value;  
   renormalize(in);
   
+  __A_VARIABLE = 1;
 }
 int
 _DEFUN(round,(in, start, now, ch),
@@ -334,6 +339,7 @@ _DEFUN(_cvte,(in),
   }
   
   in->buffer[buffer_idx++] = 0;
+  __A_VARIABLE = 1;
 }
 
 
@@ -429,6 +435,7 @@ _DEFUN(_cvtf,(in),
 
 
   
+  __A_VARIABLE = 1;
 }
 
 
@@ -451,6 +458,7 @@ _DEFUN(_dcvt,(buffer, invalue, precision, width, type, dot),
 
   if (!finite(invalue))
   {
+    __A_VARIABLE = 1;
     return print_nan(buffer, invalue, precision);
   }    
 
@@ -526,6 +534,7 @@ _DEFUN(_dcvt,(buffer, invalue, precision, width, type, dot),
   }
 
 
+  __A_VARIABLE = 1;
   return buffer;
 }
 
@@ -546,6 +555,7 @@ _DEFUN(fcvtbuf,(invalue,ndigit,decpt,sign, fcvt_buf),
     
   if (!finite(invalue))
     {
+      __A_VARIABLE = 1;
       return print_nan(fcvt_buf, invalue, ndigit);
     }    
 
@@ -558,6 +568,7 @@ _DEFUN(fcvtbuf,(invalue,ndigit,decpt,sign, fcvt_buf),
   _cvtf(&in);
   *decpt = in.dot_idx;
   *sign = in.value_neg;
+  __A_VARIABLE = 1;
   return in.buffer;
 }
 
@@ -575,6 +586,7 @@ _DEFUN(ecvtbuf,(invalue,ndigit,decpt,sign, fcvt_buf),
     
   if (!finite(invalue))
     {
+      __A_VARIABLE = 1;
       return print_nan(fcvt_buf, invalue, ndigit);
     }    
 
@@ -590,6 +602,7 @@ _DEFUN(ecvtbuf,(invalue,ndigit,decpt,sign, fcvt_buf),
   _cvtf(&in);
   *decpt = in.dot_idx;
   *sign = in.value_neg;
+  __A_VARIABLE = 1;
   return in.buffer;
 }
 
@@ -601,5 +614,6 @@ _DEFUN(gcvt,(d,ndigit,buf),
    int ndigit _AND
    char *buf)
 {
+  __A_VARIABLE = 1;
   return _dcvt(buf, d, ndigit, 0, 'g', 1);
 }
diff --git a/newlib/libm/test/dvec.c b/newlib/libm/test/dvec.c
index 198faa1..31fbf0c 100644
--- a/newlib/libm/test/dvec.c
+++ b/newlib/libm/test/dvec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 
 ddouble_type ddoubles[] = {
diff --git a/newlib/libm/test/erf_vec.c b/newlib/libm/test/erf_vec.c
index 893f9cc..8eddd03 100644
--- a/newlib/libm/test/erf_vec.c
+++ b/newlib/libm/test/erf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type erf_vec[] = {
 {64, 0,123,__LINE__, 0xbfed214a, 0xc7b2d068, 0xbff33333, 0x33333333},			/* -0.91031=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 1.00000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 1.00000=f(29.5000)*/
 0,};
-test_erf(m)   {run_vector_1(m,erf_vec,(char *)(erf),"erf","dd");   }	
+test_erf(m)   {run_vector_1(m,erf_vec,(char *)(erf),"erf","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/erfc_vec.c b/newlib/libm/test/erfc_vec.c
index 4579d31..fae8d38 100644
--- a/newlib/libm/test/erfc_vec.c
+++ b/newlib/libm/test/erfc_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type erfc_vec[] = {
 {64, 0,123,__LINE__, 0x3ffe90a5, 0x63d96834, 0xbff33333, 0x33333333},			/* 1.91031=f(-1.20000)*/
@@ -283,4 +284,5 @@
 {64, 0,123,__LINE__, 0x00000000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 0.00000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x00000000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 0.00000=f(29.5000)*/
 0,};
-test_erfc(m)   {run_vector_1(m,erfc_vec,(char *)(erfc),"erfc","dd");   }	
+test_erfc(m)   {run_vector_1(m,erfc_vec,(char *)(erfc),"erfc","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/erfcf_vec.c b/newlib/libm/test/erfcf_vec.c
index 338321a..83f67cf 100644
--- a/newlib/libm/test/erfcf_vec.c
+++ b/newlib/libm/test/erfcf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type erfcf_vec[] = {
 {16, 0,123,__LINE__, 0x3ffe90a5, 0x60000000, 0xbff33333, 0x33333333},			/* 1.91031=f(-1.20000)*/
@@ -283,4 +284,5 @@
 {64, 0,123,__LINE__, 0x00000000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 0.00000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x00000000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 0.00000=f(29.5000)*/
 0,};
-test_erfcf(m)   {run_vector_1(m,erfcf_vec,(char *)(erfcf),"erfcf","ff");   }	
+test_erfcf(m)   {run_vector_1(m,erfcf_vec,(char *)(erfcf),"erfcf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/erff_vec.c b/newlib/libm/test/erff_vec.c
index f522333..6a4c2f9 100644
--- a/newlib/libm/test/erff_vec.c
+++ b/newlib/libm/test/erff_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type erff_vec[] = {
 {11, 0,123,__LINE__, 0xbfed214a, 0xc0000000, 0xbff33333, 0x33333333},			/* -0.91031=f(-1.20000)*/
@@ -283,4 +284,5 @@
 {12, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 1.00000=f(27.8000)*/
 {12, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 1.00000=f(29.5000)*/
 0,};
-test_erff(m)   {run_vector_1(m,erff_vec,(char *)(erff),"erff","ff");   }	
+test_erff(m)   {run_vector_1(m,erff_vec,(char *)(erff),"erff","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/exp_vec.c b/newlib/libm/test/exp_vec.c
index 75adb91..fcb2536 100644
--- a/newlib/libm/test/exp_vec.c
+++ b/newlib/libm/test/exp_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type exp_vec[] = {
 {63, 0,123,__LINE__, 0x3fd346c4, 0x167a12df, 0xbff33333, 0x33333333},			/* 0.30119=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {60, 0,123,__LINE__, 0x42713b19, 0x1e69fb28, 0x403bcccc, 0xccccccc9},			/* 1.18410e+12=f(27.8000)*/
 {62, 0,123,__LINE__, 0x42979487, 0x9e85b8de, 0x403d7fff, 0xfffffffc},			/* 6.48167e+12=f(29.5000)*/
 0,};
-test_exp(m)   {run_vector_1(m,exp_vec,(char *)(exp),"exp","dd");   }	
+test_exp(m)   {run_vector_1(m,exp_vec,(char *)(exp),"exp","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/expf_vec.c b/newlib/libm/test/expf_vec.c
index 256310b..9ce6af8 100644
--- a/newlib/libm/test/expf_vec.c
+++ b/newlib/libm/test/expf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type expf_vec[] = {
 {32, 0,123,__LINE__, 0x3fd346c4, 0x20000000, 0xbff33333, 0x33333333},			/* 0.30119=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {32, 0,123,__LINE__, 0x42713b19, 0x20000000, 0x403bcccc, 0xccccccc9},			/* 1.18410e+12=f(27.8000)*/
 {32, 0,123,__LINE__, 0x42979489, 0x80000000, 0x403d7fff, 0xfffffffc},			/* 6.48168e+12=f(29.5000)*/
 0,};
-void test_expf(m)   { run_vector_1(m,expf_vec,(char *)(expf),"expf","ff");   }	
+void test_expf(m)   { run_vector_1(m,expf_vec,(char *)(expf),"expf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/fabs_vec.c b/newlib/libm/test/fabs_vec.c
index 3c7fce7..abc6ae4 100644
--- a/newlib/libm/test/fabs_vec.c
+++ b/newlib/libm/test/fabs_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type fabs_vec[] = {
 {64, 0,123,__LINE__, 0x3ff33333, 0x33333333, 0xbff33333, 0x33333333},			/* 1.20000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x403bcccc, 0xccccccc9, 0x403bcccc, 0xccccccc9},			/* 27.8000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x403d7fff, 0xfffffffc, 0x403d7fff, 0xfffffffc},			/* 29.5000=f(29.5000)*/
 0,};
-test_fabs(m)   {run_vector_1(m,fabs_vec,(char *)(fabs),"fabs","dd");   }	
+test_fabs(m)   {run_vector_1(m,fabs_vec,(char *)(fabs),"fabs","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/fabsf_vec.c b/newlib/libm/test/fabsf_vec.c
index 9c8e122..41cfeff 100644
--- a/newlib/libm/test/fabsf_vec.c
+++ b/newlib/libm/test/fabsf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type fabsf_vec[] = {
 {64, 0,123,__LINE__, 0x3ff33333, 0x40000000, 0xbff33333, 0x33333333},			/* 1.20000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x403bcccc, 0xc0000000, 0x403bcccc, 0xccccccc9},			/* 27.7999=f(27.8000)*/
 {64, 0,123,__LINE__, 0x403d8000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 29.5000=f(29.5000)*/
 0,};
-test_fabsf(m)   {run_vector_1(m,fabsf_vec,(char *)(fabsf),"fabsf","ff");   }	
+test_fabsf(m)   {run_vector_1(m,fabsf_vec,(char *)(fabsf),"fabsf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/floor_vec.c b/newlib/libm/test/floor_vec.c
index 2272a7d..17ffd58 100644
--- a/newlib/libm/test/floor_vec.c
+++ b/newlib/libm/test/floor_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type floor_vec[] = {
 {64, 0,123,__LINE__, 0xc0000000, 0x00000000, 0xbff33333, 0x33333333},			/* -2.00000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x403b0000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 27.0000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x403d0000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 29.0000=f(29.5000)*/
 0,};
-test_floor(m)   {run_vector_1(m,floor_vec,(char *)(floor),"floor","dd");   }	
+test_floor(m)   {run_vector_1(m,floor_vec,(char *)(floor),"floor","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/floorf_vec.c b/newlib/libm/test/floorf_vec.c
index f01e1e6..9ef08f8 100644
--- a/newlib/libm/test/floorf_vec.c
+++ b/newlib/libm/test/floorf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type floorf_vec[] = {
 { 1, 0,123,__LINE__, 0xc0000000, 0x00000000, 0xbff33333, 0x33333333},			/* -2.00000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {16, 0,123,__LINE__, 0x403b0000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 27.0000=f(27.8000)*/
 {16, 0,123,__LINE__, 0x403d0000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 29.0000=f(29.5000)*/
 0,};
-test_floorf(m)   {run_vector_1(m,floorf_vec,(char *)(floorf),"floorf","ff");   }	
+test_floorf(m)   {run_vector_1(m,floorf_vec,(char *)(floorf),"floorf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/fmod_vec.c b/newlib/libm/test/fmod_vec.c
index 4357c84..dabcea3 100644
--- a/newlib/libm/test/fmod_vec.c
+++ b/newlib/libm/test/fmod_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type fmod_vec[] = {
 {64, 0,123,__LINE__, 0xbff33333, 0x33333333, 0xbff33333, 0x33333333, 0x40066666, 0x66666666},			/* -1.20000=f(-1.20000, v2.80000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x403bcccc, 0xccccccc9, 0x403bcccc, 0xccccccc9, 0x403fcccc, 0xccccccc9},			/* 27.8000=f(27.8000, v31.8000)*/
 {64, 0,123,__LINE__, 0x403d7fff, 0xfffffffc, 0x403d7fff, 0xfffffffc, 0x4040bfff, 0xfffffffe},			/* 29.5000=f(29.5000, v33.5000)*/
 0,};
-test_fmod(m)   {run_vector_1(m,fmod_vec,(char *)(fmod),"fmod","ddd");   }	
+test_fmod(m)   {run_vector_1(m,fmod_vec,(char *)(fmod),"fmod","ddd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/fmodf_vec.c b/newlib/libm/test/fmodf_vec.c
index f50eeda..6051d46 100644
--- a/newlib/libm/test/fmodf_vec.c
+++ b/newlib/libm/test/fmodf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type fmodf_vec[] = {
 { 0, 0,123,__LINE__, 0xbff33333, 0x40000000, 0xbff33333, 0x33333333, 0x40066666, 0x66666666},			/* -1.20000=f(-1.20000, v2.80000)*/
@@ -285,4 +286,5 @@
 {10, 0,123,__LINE__, 0x403bcccc, 0xc0000000, 0x403bcccc, 0xccccccc9, 0x403fcccc, 0xccccccc9},			/* 27.7999=f(27.8000, v31.8000)*/
 {10, 0,123,__LINE__, 0x403d8000, 0x00000000, 0x403d7fff, 0xfffffffc, 0x4040bfff, 0xfffffffe},			/* 29.5000=f(29.5000, v33.5000)*/
 0,};
-test_fmodf(m)   {run_vector_1(m,fmodf_vec,(char *)(fmodf),"fmodf","fff");   }	
+test_fmodf(m)   {run_vector_1(m,fmodf_vec,(char *)(fmodf),"fmodf","fff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/gamma_vec.c b/newlib/libm/test/gamma_vec.c
index 119efe6..6fd9ecc 100644
--- a/newlib/libm/test/gamma_vec.c
+++ b/newlib/libm/test/gamma_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type gamma_vec[] = {
 {60, 0,123,__LINE__, 0xbfb5db13, 0x8c7d70c7, 0xbff33333, 0x33333333},			/* -0.08537=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x404ff29d, 0x1a191b4b, 0x403bcccc, 0xccccccc9},			/* 63.8954=f(27.8000)*/
 {64, 0,123,__LINE__, 0x4051646b, 0xd261edc0, 0x403d7fff, 0xfffffffc},			/* 69.5690=f(29.5000)*/
 0,};
-test_gamma(m)   {run_vector_1(m,gamma_vec,(char *)(gamma),"gamma","dd");   }	
+test_gamma(m)   {run_vector_1(m,gamma_vec,(char *)(gamma),"gamma","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/gammaf_vec.c b/newlib/libm/test/gammaf_vec.c
index 3210f14..9816fca 100644
--- a/newlib/libm/test/gammaf_vec.c
+++ b/newlib/libm/test/gammaf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type gammaf_vec[] = {
 { 0, 0,123,__LINE__, 0xbfb5db13, 0xc0000000, 0xbff33333, 0x33333333},			/* -0.08537=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {12, 0,123,__LINE__, 0x404ff29d, 0x20000000, 0x403bcccc, 0xccccccc9},			/* 63.8954=f(27.8000)*/
 {11, 0,123,__LINE__, 0x4051646b, 0xe0000000, 0x403d7fff, 0xfffffffc},			/* 69.5690=f(29.5000)*/
 0,};
-test_gammaf(m)   {run_vector_1(m,gammaf_vec,(char *)(gammaf),"gammaf","ff");   }	
+test_gammaf(m)   {run_vector_1(m,gammaf_vec,(char *)(gammaf),"gammaf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/hypot_vec.c b/newlib/libm/test/hypot_vec.c
index ca8e7ff..39ac807 100644
--- a/newlib/libm/test/hypot_vec.c
+++ b/newlib/libm/test/hypot_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type hypot_vec[] = {
 {64, 0,123,__LINE__, 0x40085ed7, 0x614b038c, 0xbff33333, 0x33333333, 0x40066666, 0x66666666},			/* 3.04630=f(-1.20000, v2.80000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x40451e82, 0xf264be59, 0x403bcccc, 0xccccccc9, 0x403fcccc, 0xccccccc9},			/* 42.2383=f(27.8000, v31.8000)*/
 {64, 0,123,__LINE__, 0x40465197, 0x3fa50845, 0x403d7fff, 0xfffffffc, 0x4040bfff, 0xfffffffe},			/* 44.6374=f(29.5000, v33.5000)*/
 0,};
-test_hypot(m)   {run_vector_1(m,hypot_vec,(char *)(hypot),"hypot","ddd");   }	
+test_hypot(m)   {run_vector_1(m,hypot_vec,(char *)(hypot),"hypot","ddd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/hypotf_vec.c b/newlib/libm/test/hypotf_vec.c
index 833f05e..825f596 100644
--- a/newlib/libm/test/hypotf_vec.c
+++ b/newlib/libm/test/hypotf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type hypotf_vec[] = {
 { 1, 0,123,__LINE__, 0x40085ed7, 0x6c3cac80, 0xbff33333, 0x33333333, 0x40066666, 0x66666666},			/* 3.04630=f(-1.20000, v2.80000)*/
@@ -285,4 +286,5 @@
 { 9, 0,123,__LINE__, 0x40451e82, 0xe4b2fe80, 0x403bcccc, 0xccccccc9, 0x403fcccc, 0xccccccc9},			/* 42.2383=f(27.8000, v31.8000)*/
 { 9, 0,123,__LINE__, 0x40465197, 0x39800000, 0x403d7fff, 0xfffffffc, 0x4040bfff, 0xfffffffe},			/* 44.6374=f(29.5000, v33.5000)*/
 0,};
-test_hypotf(m)   {run_vector_1(m,hypotf_vec,(char *)(hypotf),"hypotf","fff");   }	
+test_hypotf(m)   {run_vector_1(m,hypotf_vec,(char *)(hypotf),"hypotf","fff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/iconv_vec.c b/newlib/libm/test/iconv_vec.c
index 15bf388..a709a3b 100644
--- a/newlib/libm/test/iconv_vec.c
+++ b/newlib/libm/test/iconv_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include "test.h"
 
diff --git a/newlib/libm/test/j0_vec.c b/newlib/libm/test/j0_vec.c
index 834f883..46815aa 100644
--- a/newlib/libm/test/j0_vec.c
+++ b/newlib/libm/test/j0_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type j0_vec[] = {
 {63, 0,123,__LINE__, 0x3fe579eb, 0x607c7c44, 0xbff33333, 0x33333333},			/* 0.67113=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0xbfa7617b, 0x541dda80, 0x403bcccc, 0xccccccc9},			/* -0.04566=f(27.8000)*/
 {64, 0,123,__LINE__, 0xbfc10afd, 0x307647d2, 0x403d7fff, 0xfffffffc},			/* -0.13314=f(29.5000)*/
 0,};
-test_j0(m)   {run_vector_1(m,j0_vec,(char *)(j0),"j0","dd");   }	
+test_j0(m)   {run_vector_1(m,j0_vec,(char *)(j0),"j0","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/j0f_vec.c b/newlib/libm/test/j0f_vec.c
index 2f7a531..ca962c1 100644
--- a/newlib/libm/test/j0f_vec.c
+++ b/newlib/libm/test/j0f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type j0f_vec[] = {
 {11, 0,123,__LINE__, 0x3fe579eb, 0x54c385c0, 0xbff33333, 0x33333333},			/* 0.67113=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 9, 0,123,__LINE__, 0xbfa76175, 0xe5ae6e65, 0x403bcccc, 0xccccccc9},			/* -0.04566=f(27.8000)*/
 { 0, 0,123,__LINE__, 0xbfc10afd, 0x7ae2e789, 0x403d7fff, 0xfffffffc},			/* -0.13314=f(29.5000)*/
 0,};
-test_j0f(m)   {run_vector_1(m,j0f_vec,(char *)(j0f),"j0f","ff");   }	
+test_j0f(m)   {run_vector_1(m,j0f_vec,(char *)(j0f),"j0f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/j1_vec.c b/newlib/libm/test/j1_vec.c
index 27bbce6..bafb663 100644
--- a/newlib/libm/test/j1_vec.c
+++ b/newlib/libm/test/j1_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type j1_vec[] = {
 {64, 0,123,__LINE__, 0xbfdfe3f7, 0xc98d2cad, 0xbff33333, 0x33333333},			/* -0.49828=f(-1.20000)*/
@@ -282,4 +283,5 @@
 {62, 0,123,__LINE__, 0x3fc25cf8, 0x6ae10498, 0x403bcccc, 0xccccccc9},			/* 0.14346=f(27.8000)*/
 {64, 0,123,__LINE__, 0xbfb07640, 0x70ecf703, 0x403d7fff, 0xfffffffc},			/* -0.06430=f(29.5000)*/
 0,};
-test_j1(m)   {run_vector_1(m,j1_vec,(char *)(j1),"j1","dd");   }	
+test_j1(m)   {run_vector_1(m,j1_vec,(char *)(j1),"j1","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/j1f_vec.c b/newlib/libm/test/j1f_vec.c
index b09c892..c0887dc 100644
--- a/newlib/libm/test/j1f_vec.c
+++ b/newlib/libm/test/j1f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type j1f_vec[] = {
 {10, 0,123,__LINE__, 0xbfdfe3f7, 0xe296ed50, 0xbff33333, 0x33333333},			/* -0.49828=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 0, 0,123,__LINE__, 0x3fc25cf8, 0x80000000, 0x403bcccc, 0xccccccc9},			/* 0.14346=f(27.8000)*/
 { 0, 0,123,__LINE__, 0xbfb07642, 0x60000000, 0x403d7fff, 0xfffffffc},			/* -0.06430=f(29.5000)*/
 0,};
-test_j1f(m)   {run_vector_1(m,j1f_vec,(char *)(j1f),"j1f","ff");   }	
+test_j1f(m)   {run_vector_1(m,j1f_vec,(char *)(j1f),"j1f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/jn_vec.c b/newlib/libm/test/jn_vec.c
index a2929bf..58af500 100644
--- a/newlib/libm/test/jn_vec.c
+++ b/newlib/libm/test/jn_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type jn_vec[] = {
 {61,0,123,__LINE__, 0x3ff00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -201,4 +202,5 @@
 {61,0,123,__LINE__, 0x3fbefed6, 0x4831e4df, 0x40080000, 0x00000000, 0x3fff3333, 0x33333338},
 {61,0,123,__LINE__, 0x3f9fc826, 0xafa66438, 0x40100000, 0x00000000, 0x3fff3333, 0x33333338},
 0,};
-test_jn(m)   {run_vector_1(m,jn_vec,(char *)(jn),"jn","did");   }	
+test_jn(m)   {run_vector_1(m,jn_vec,(char *)(jn),"jn","did");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/jnf_vec.c b/newlib/libm/test/jnf_vec.c
index 1c9a4db..b6e3ab9 100644
--- a/newlib/libm/test/jnf_vec.c
+++ b/newlib/libm/test/jnf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type jnf_vec[] = {
 {32,0,123,__LINE__, 0x3ff00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -201,4 +202,5 @@
 {32,0,123,__LINE__, 0x3fbefed6, 0x4831e4df, 0x40080000, 0x00000000, 0x3fff3333, 0x33333338},
 {32,0,123,__LINE__, 0x3f9fc826, 0xafa66438, 0x40100000, 0x00000000, 0x3fff3333, 0x33333338},
 0,};
-test_jnf(m)   {run_vector_1(m,jnf_vec,(char *)(jnf),"jnf","fif");   }	
+test_jnf(m)   {run_vector_1(m,jnf_vec,(char *)(jnf),"jnf","fif");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log10_vec.c b/newlib/libm/test/log10_vec.c
index 48975a7..4db03f1 100644
--- a/newlib/libm/test/log10_vec.c
+++ b/newlib/libm/test/log10_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log10_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3ff71ace, 0xb746d587, 0x403bcccc, 0xccccccc9},			/* 1.44404=f(27.8000)*/
 {64, 0,123,__LINE__, 0x3ff78464, 0x1719126d, 0x403d7fff, 0xfffffffc},			/* 1.46982=f(29.5000)*/
 0,};
-test_log10(m)   {run_vector_1(m,log10_vec,(char *)(log10),"log10","dd");   }	
+test_log10(m)   {run_vector_1(m,log10_vec,(char *)(log10),"log10","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log10f_vec.c b/newlib/libm/test/log10f_vec.c
index 034117c..1438e7d 100644
--- a/newlib/libm/test/log10f_vec.c
+++ b/newlib/libm/test/log10f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log10f_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 1, 0,123,__LINE__, 0x3ff71ace, 0xb43ddb6b, 0x403bcccc, 0xccccccc9},			/* 1.44404=f(27.8000)*/
 { 1, 0,123,__LINE__, 0x3ff78464, 0x17051b9e, 0x403d7fff, 0xfffffffc},			/* 1.46982=f(29.5000)*/
 0,};
-test_log10f(m)   {run_vector_1(m,log10f_vec,(char *)(log10f),"log10f","ff");   }	
+test_log10f(m)   {run_vector_1(m,log10f_vec,(char *)(log10f),"log10f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log1p_vec.c b/newlib/libm/test/log1p_vec.c
index 9966b86..4fd2438 100644
--- a/newlib/libm/test/log1p_vec.c
+++ b/newlib/libm/test/log1p_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log1p_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x400ae20c, 0x7db0765f, 0x403bcccc, 0xccccccc9},			/* 3.36037=f(27.8000)*/
 {64, 0,123,__LINE__, 0x400b5781, 0x1666499d, 0x403d7fff, 0xfffffffc},			/* 3.41772=f(29.5000)*/
 0,};
-test_log1p(m)   {run_vector_1(m,log1p_vec,(char *)(log1p),"log1p","dd");   }	
+test_log1p(m)   {run_vector_1(m,log1p_vec,(char *)(log1p),"log1p","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log1pf_vec.c b/newlib/libm/test/log1pf_vec.c
index 7169e0a..25d8f36 100644
--- a/newlib/libm/test/log1pf_vec.c
+++ b/newlib/libm/test/log1pf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log1pf_vec[] = {
 { 0,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {12, 0,123,__LINE__, 0x400ae20c, 0x7a980000, 0x403bcccc, 0xccccccc9},			/* 3.36037=f(27.8000)*/
 {12, 0,123,__LINE__, 0x400b5781, 0x16980000, 0x403d7fff, 0xfffffffc},			/* 3.41772=f(29.5000)*/
 0,};
-test_log1pf(m)   {run_vector_1(m,log1pf_vec,(char *)(log1pf),"log1pf","ff");   }	
+test_log1pf(m)   {run_vector_1(m,log1pf_vec,(char *)(log1pf),"log1pf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log2_vec.c b/newlib/libm/test/log2_vec.c
index 6a76e26..2009e8f 100644
--- a/newlib/libm/test/log2_vec.c
+++ b/newlib/libm/test/log2_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log2_vec[] = {
 {62,0,123,__LINE__, 0xc01149a7, 0x84bcd1b9, 0x3fa99999, 0x9999999a},
@@ -397,4 +398,5 @@
 {62,0,123,__LINE__, 0x4011423f, 0xce576f3a, 0x4033e666, 0x66666690},
 {62,0,123,__LINE__, 0x401145f4, 0xd99d3304, 0x4033f333, 0x3333335d},
 0,};
-test_log2(m)   {run_vector_1(m,log2_vec,(char *)(log2),"log2","dd");   }	
+test_log2(m)   {run_vector_1(m,log2_vec,(char *)(log2),"log2","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log2f_vec.c b/newlib/libm/test/log2f_vec.c
index a31ca2f..c45f60f 100644
--- a/newlib/libm/test/log2f_vec.c
+++ b/newlib/libm/test/log2f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log2f_vec[] = {
 {31,0,123,__LINE__, 0xc01149a7, 0x84bcd1b9, 0x3fa99999, 0x9999999a},
@@ -399,4 +400,5 @@
 {31,0,123,__LINE__, 0x4011423f, 0xce576f3a, 0x4033e666, 0x66666690},
 {31,0,123,__LINE__, 0x401145f4, 0xd99d3304, 0x4033f333, 0x3333335d},
 0,};
-test_log2f(m)   {run_vector_1(m,log2f_vec,(char *)(log2f),"log2f","ff");   }	
+test_log2f(m)   {run_vector_1(m,log2f_vec,(char *)(log2f),"log2f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/log_vec.c b/newlib/libm/test/log_vec.c
index 894b754..137b8a7 100644
--- a/newlib/libm/test/log_vec.c
+++ b/newlib/libm/test/log_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type log_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x400a99ac, 0x7c374f8a, 0x403bcccc, 0xccccccc9},			/* 3.32503=f(27.8000)*/
 {64, 0,123,__LINE__, 0x400b133b, 0x33cfc475, 0x403d7fff, 0xfffffffc},			/* 3.38439=f(29.5000)*/
 0,};
-test_log(m)   {run_vector_1(m,log_vec,(char *)(log),"log","dd");   }	
+test_log(m)   {run_vector_1(m,log_vec,(char *)(log),"log","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/logf_vec.c b/newlib/libm/test/logf_vec.c
index f7b541f..5ac986e 100644
--- a/newlib/libm/test/logf_vec.c
+++ b/newlib/libm/test/logf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type logf_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {12, 0,123,__LINE__, 0x400a99ac, 0x78b8c86b, 0x403bcccc, 0xccccccc9},			/* 3.32503=f(27.8000)*/
 {12, 0,123,__LINE__, 0x400b133b, 0x33b8c86b, 0x403d7fff, 0xfffffffc},			/* 3.38439=f(29.5000)*/
 0,};
-test_logf(m)   {run_vector_1(m,logf_vec,(char *)(logf),"logf","ff");   }	
+test_logf(m)   {run_vector_1(m,logf_vec,(char *)(logf),"logf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/math.c b/newlib/libm/test/math.c
index df63c2d..c6b2aa1 100644
--- a/newlib/libm/test/math.c
+++ b/newlib/libm/test/math.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 
   Test the library maths functions using trusted precomputed test
   vectors.
@@ -44,8 +45,10 @@ _DEFUN(matherr,(e),
     mname = e->name;
     e->retval = mretval;
     errno = merror + 24;
+    __A_VARIABLE = 1;
     return 1;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -57,6 +60,7 @@ void _DEFUN(translate_to,(file,r),
   __ieee_double_shape_type bits;
   bits.value = r;
   fprintf(file, "0x%08x, 0x%08x", bits.parts.msw, bits.parts.lsw);
+  __A_VARIABLE = 1;
 }
 
 int 
@@ -104,6 +108,7 @@ _DEFUN(ffcheck,( is, p, name, serrno, merror),
     
   }
 #endif
+  __A_VARIABLE = 1;
   return mag;
 }
 
@@ -116,6 +121,7 @@ _DEFUN(thedouble, (msw, lsw),
   
   x.parts.msw = msw;
   x.parts.lsw = lsw;
+  __A_VARIABLE = 1;
   return x.value;
 }
 
@@ -174,6 +180,7 @@ _DEFUN(frontline,(f, mag, p, result, merror, errno, args, name),
     fprintf(f,", %g", thedouble(p->qs[2].msw,p->qs[2].lsw));
   }
   fprintf(f, ")*/\n");      
+  __A_VARIABLE = 1;
 }
 
 _DEFUN(finish,(f, vector,  result , p, args, name),
@@ -191,6 +198,7 @@ _DEFUN(finish,(f, vector,  result , p, args, name),
   {    
     frontline(f, mag, p, result, merror, errno, args , name);
   }
+  __A_VARIABLE = 1;
 } 
 int redo;  
 
@@ -245,6 +253,7 @@ _DEFUN(run_vector_1,(vector, p, func, name, args),
 
       }
       VECCLOSE(f, name, args);
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -351,6 +360,7 @@ _DEFUN(run_vector_1,(vector, p, func, name, args),
   {
     VECCLOSE(f, name, args);
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -422,6 +432,7 @@ _DEFUN_VOID(test_math)
   test_y1f(0);
   test_y1f(0);
   test_ynf(0);
+  __A_VARIABLE = 1;
 }
 
 /* These have to be played with to get to compile on machines which
diff --git a/newlib/libm/test/math2.c b/newlib/libm/test/math2.c
index 50b5376..ce38d37 100644
--- a/newlib/libm/test/math2.c
+++ b/newlib/libm/test/math2.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include "test.h"
 #include <errno.h>
@@ -8,6 +9,7 @@ _DEFUN_VOID(randi)
 {
   static int next;
   next = (next * 1103515245) + 12345;
+  __A_VARIABLE = 1;
   return ((next >> 16) & 0xffff);
 }
 
@@ -30,6 +32,7 @@ double _DEFUN_VOID(randx)
     
   } while (!finite(res));
   
+  __A_VARIABLE = 1;
   return res ;
 }
 
@@ -39,6 +42,7 @@ double _DEFUN_VOID(randy)
   int pow;
   double r= randx();
   r = frexp(r, &pow);
+  __A_VARIABLE = 1;
   return ldexp(r, randi() & 0x1f);
 }
 
@@ -116,6 +120,7 @@ _DEFUN_VOID(test_frexp)
   test_mok(r, 0.75, 64);
   test_iok(i, 7);
   
+  __A_VARIABLE = 1;
 }
 
 /* Test mod - this is given a real hammering by the strtod type
@@ -170,6 +175,7 @@ _DEFUN_VOID(test_mod)
   }
 
 
+  __A_VARIABLE = 1;
 }
 
 /*
@@ -219,6 +225,7 @@ _DEFUN_VOID(test_pow)
 
 
 
+  __A_VARIABLE = 1;
 }
 
 
@@ -229,4 +236,5 @@ _DEFUN_VOID(test_math2)
   test_mod();  
   test_frexp();
   test_pow();
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/test/sin_vec.c b/newlib/libm/test/sin_vec.c
index 5e95f28..ffe31d3 100644
--- a/newlib/libm/test/sin_vec.c
+++ b/newlib/libm/test/sin_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sin_vec[] = {
 {62, 0,123,__LINE__, 0xbfedd343, 0xa21a55c6, 0xbff33333, 0x33333333},			/* -0.93203=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3fdd3b53, 0x753c19f9, 0x403bcccc, 0xccccccc9},			/* 0.45674=f(27.8000)*/
 {64, 0,123,__LINE__, 0xbfee1ced, 0xe66aefee, 0x403d7fff, 0xfffffffc},			/* -0.94103=f(29.5000)*/
 0,};
-test_sin(m)   {run_vector_1(m,sin_vec,(char *)(sin),"sin","dd");   }	
+test_sin(m)   {run_vector_1(m,sin_vec,(char *)(sin),"sin","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/sinf_vec.c b/newlib/libm/test/sinf_vec.c
index 32eb8b1..b3bf644 100644
--- a/newlib/libm/test/sinf_vec.c
+++ b/newlib/libm/test/sinf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sinf_vec[] = {
 {31, 0,123,__LINE__, 0xbfedd343, 0xb0aef9e0, 0xbff33333, 0x33333333},			/* -0.93203=f(-1.20000)*/
@@ -283,4 +284,5 @@
 { 0, 0,123,__LINE__, 0x3fdd3b58, 0xe939af6e, 0x403bcccc, 0xccccccc9},			/* 0.45674=f(27.8000)*/
 { 0, 0,123,__LINE__, 0xbfee1ced, 0x68d0d25a, 0x403d7fff, 0xfffffffc},			/* -0.94103=f(29.5000)*/
 0,};
-test_sinf(m)   {run_vector_1(m,sinf_vec,(char *)(sinf),"sinf","ff");   }	
+test_sinf(m)   {run_vector_1(m,sinf_vec,(char *)(sinf),"sinf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/sinh_vec.c b/newlib/libm/test/sinh_vec.c
index cdcea79..c092204 100644
--- a/newlib/libm/test/sinh_vec.c
+++ b/newlib/libm/test/sinh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sinh_vec[] = {
 {61, 0,123,__LINE__, 0xbff826c0, 0xf3412349, 0xbff33333, 0x33333333},			/* -1.50946=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {63, 0,123,__LINE__, 0x42613b19, 0x1e69fb25, 0x403bcccc, 0xccccccc9},			/* 5.92048e+11=f(27.8000)*/
 {61, 0,123,__LINE__, 0x42879487, 0x9e85b8dc, 0x403d7fff, 0xfffffffc},			/* 3.24084e+12=f(29.5000)*/
 0,};
-test_sinh(m)   {run_vector_1(m,sinh_vec,(char *)(sinh),"sinh","dd");   }	
+test_sinh(m)   {run_vector_1(m,sinh_vec,(char *)(sinh),"sinh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/sinhf_vec.c b/newlib/libm/test/sinhf_vec.c
index f15709c..08ae000 100644
--- a/newlib/libm/test/sinhf_vec.c
+++ b/newlib/libm/test/sinhf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sinhf_vec[] = {
 {12, 0,123,__LINE__, 0xbff826c1, 0x00000000, 0xbff33333, 0x33333333},			/* -1.50946=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 6, 0,123,__LINE__, 0x42613b16, 0xc0000000, 0x403bcccc, 0xccccccc9},			/* 5.92046e+11=f(27.8000)*/
 { 6, 0,123,__LINE__, 0x42879486, 0x60000000, 0x403d7fff, 0xfffffffc},			/* 3.24083e+12=f(29.5000)*/
 0,};
-test_sinhf(m)   {run_vector_1(m,sinhf_vec,(char *)(sinhf),"sinhf","ff");   }	
+test_sinhf(m)   {run_vector_1(m,sinhf_vec,(char *)(sinhf),"sinhf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/sprint_ivec.c b/newlib/libm/test/sprint_ivec.c
index 24762c6..c98d822 100644
--- a/newlib/libm/test/sprint_ivec.c
+++ b/newlib/libm/test/sprint_ivec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 
 sprint_int_type sprint_ints[] = 
diff --git a/newlib/libm/test/sprint_vec.c b/newlib/libm/test/sprint_vec.c
index 5ac7251..4861148 100644
--- a/newlib/libm/test/sprint_vec.c
+++ b/newlib/libm/test/sprint_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 
 sprint_double_type sprint_doubles[] = 
diff --git a/newlib/libm/test/sqrt_vec.c b/newlib/libm/test/sqrt_vec.c
index 49bef14..bb4166c 100644
--- a/newlib/libm/test/sqrt_vec.c
+++ b/newlib/libm/test/sqrt_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sqrt_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x4015171c, 0xbaaadfe0, 0x403bcccc, 0xccccccc9},			/* 5.27257=f(27.8000)*/
 {64, 0,123,__LINE__, 0x4015b9be, 0x5d52a9d8, 0x403d7fff, 0xfffffffc},			/* 5.43139=f(29.5000)*/
 0,};
-test_sqrt(m)   {run_vector_1(m,sqrt_vec,(char *)(sqrt),"sqrt","dd");   }	
+test_sqrt(m)   {run_vector_1(m,sqrt_vec,(char *)(sqrt),"sqrt","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/sqrtf_vec.c b/newlib/libm/test/sqrtf_vec.c
index 0e52fac..4fef9bc 100644
--- a/newlib/libm/test/sqrtf_vec.c
+++ b/newlib/libm/test/sqrtf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type sqrtf_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {12, 0,123,__LINE__, 0x4015171c, 0xc0000000, 0x403bcccc, 0xccccccc9},			/* 5.27257=f(27.8000)*/
 {12, 0,123,__LINE__, 0x4015b9be, 0x60000000, 0x403d7fff, 0xfffffffc},			/* 5.43139=f(29.5000)*/
 0,};
-test_sqrtf(m)   {run_vector_1(m,sqrtf_vec,(char *)(sqrtf),"sqrtf","ff");   }	
+test_sqrtf(m)   {run_vector_1(m,sqrtf_vec,(char *)(sqrtf),"sqrtf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/string.c b/newlib/libm/test/string.c
index c470472..ff92d9f 100644
--- a/newlib/libm/test/string.c
+++ b/newlib/libm/test/string.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 #include <string.h>
 #include <errno.h>
@@ -23,6 +24,7 @@ _DEFUN(checkit,(ok,l),
     printf("string.c:%d %s\n", l, it);
     ++errors;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -39,10 +41,14 @@ _DEFUN(funcqual,(a,b,l),
   newfunc(it);
   
   line(l);
-  if (a == NULL && b == NULL) return;
+  if (a == NULL && b == NULL) {
+      __A_VARIABLE = 1;
+      return;
+  }
   if (strcmp(a,b)) {
       printf("string.c:%d (%s)\n", l, it);  
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -552,5 +558,6 @@ void test_string()
   equal(strerror(errno), _sys_errlist[errno]);
 }
 #endif
+__A_VARIABLE = 1;
 }
 
diff --git a/newlib/libm/test/tan_vec.c b/newlib/libm/test/tan_vec.c
index eb76cb5..204bced 100644
--- a/newlib/libm/test/tan_vec.c
+++ b/newlib/libm/test/tan_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type tan_vec[] = {
 {64, 0,123,__LINE__, 0xc00493c4, 0x3acb164c, 0xbff33333, 0x33333333},			/* -2.57215=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0xbfe06e04, 0xfc5ca3b7, 0x403bcccc, 0xccccccc9},			/* -0.51343=f(27.8000)*/
 {63, 0,123,__LINE__, 0x4006407d, 0xaf0ccd5f, 0x403d7fff, 0xfffffffc},			/* 2.78149=f(29.5000)*/
 0,};
-test_tan(m)   {run_vector_1(m,tan_vec,(char *)(tan),"tan","dd");   }	
+test_tan(m)   {run_vector_1(m,tan_vec,(char *)(tan),"tan","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/tanf_vec.c b/newlib/libm/test/tanf_vec.c
index e6106e7..d2f41e2 100644
--- a/newlib/libm/test/tanf_vec.c
+++ b/newlib/libm/test/tanf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type tanf_vec[] = {
 { 1, 0,123,__LINE__, 0xc00493c4, 0x60a46c17, 0xbff33333, 0x33333333},			/* -2.57215=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 0, 0,123,__LINE__, 0xbfe06e07, 0x062e771c, 0x403bcccc, 0xccccccc9},			/* -0.51343=f(27.8000)*/
 { 0, 0,123,__LINE__, 0x4006407d, 0xa6634ee2, 0x403d7fff, 0xfffffffc},			/* 2.78149=f(29.5000)*/
 0,};
-test_tanf(m)   {run_vector_1(m,tanf_vec,(char *)(tanf),"tanf","ff");   }	
+test_tanf(m)   {run_vector_1(m,tanf_vec,(char *)(tanf),"tanf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/tanh_vec.c b/newlib/libm/test/tanh_vec.c
index 01ad1c2..f97cb4f 100644
--- a/newlib/libm/test/tanh_vec.c
+++ b/newlib/libm/test/tanh_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type tanh_vec[] = {
 {64, 0,123,__LINE__, 0xbfeaad4c, 0x6d28dcaf, 0xbff33333, 0x33333333},			/* -0.83365=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 1.00000=f(27.8000)*/
 {64, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 1.00000=f(29.5000)*/
 0,};
-test_tanh(m)   {run_vector_1(m,tanh_vec,(char *)(tanh),"tanh","dd");   }	
+test_tanh(m)   {run_vector_1(m,tanh_vec,(char *)(tanh),"tanh","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/tanhf_vec.c b/newlib/libm/test/tanhf_vec.c
index c8612c0..d14584e 100644
--- a/newlib/libm/test/tanhf_vec.c
+++ b/newlib/libm/test/tanhf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type tanhf_vec[] = {
 {11, 0,123,__LINE__, 0xbfeaad4c, 0x80000000, 0xbff33333, 0x33333333},			/* -0.83365=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {12, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403bcccc, 0xccccccc9},			/* 1.00000=f(27.8000)*/
 {12, 0,123,__LINE__, 0x3ff00000, 0x00000000, 0x403d7fff, 0xfffffffc},			/* 1.00000=f(29.5000)*/
 0,};
-test_tanhf(m)   {run_vector_1(m,tanhf_vec,(char *)(tanhf),"tanhf","ff");   }	
+test_tanhf(m)   {run_vector_1(m,tanhf_vec,(char *)(tanhf),"tanhf","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/test.c b/newlib/libm/test/test.c
index 615c54a..9cdd03e 100644
--- a/newlib/libm/test/test.c
+++ b/newlib/libm/test/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <signal.h>
 #include  "test.h"
 #include <math.h>
@@ -51,6 +52,7 @@ bt();
    test_is();
   if (ieee)  test_ieee();
   printf("Tested %d functions, %d errors detected\n", count, inacc);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -67,6 +69,7 @@ _DEFUN(newfunc,(string),
     iname = string;
   }
   
+  __A_VARIABLE = 1;
 }
 
 
@@ -82,6 +85,7 @@ int li;
   theline = li;
   
   count++;
+  __A_VARIABLE = 1;
 }
 
 
@@ -131,7 +135,10 @@ _DEFUN(mag_of_error,(is, shouldbe),
   b.value = shouldbe;
   
   if (a.parts.msw == b.parts.msw 
-      && a.parts.lsw== b.parts.lsw) return 64;
+      && a.parts.lsw== b.parts.lsw) {
+    __A_VARIABLE = 1;
+    return 64;
+  }
 
 
   /* Subtract the larger from the smaller number */
@@ -162,7 +169,10 @@ _DEFUN(mag_of_error,(is, shouldbe),
   mask = 0x80000000;
   for (i = 0; i < 32; i++)
   {
-    if (((msw) & mask)!=0) return i;
+    if (((msw) & mask)!=0) {
+      __A_VARIABLE = 1;
+      return i;
+    }
     mask >>=1;
   }
   
@@ -170,10 +180,14 @@ _DEFUN(mag_of_error,(is, shouldbe),
   for (i = 0; i < 32; i++)
   {
     
-    if (((lsw) & mask)!=0) return i+32;
+    if (((lsw) & mask)!=0) {
+      __A_VARIABLE = 1;
+      return i+32;
+    }
     mask >>=1;
   }
   
+  __A_VARIABLE = 1;
   return 64;
   
 }
@@ -195,6 +209,7 @@ _DEFUN(test_sok,(is, shouldbe),
 	   is, shouldbe);
     inacc++;
   }
+  __A_VARIABLE = 1;
 }
 void
 _DEFUN(test_iok,(is, shouldbe),
@@ -208,6 +223,7 @@ _DEFUN(test_iok,(is, shouldbe),
 	   is, shouldbe);
     inacc++;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -228,6 +244,7 @@ _DEFUN(test_scok,(is, shouldbe, count),
 	   is, shouldbe);
     inacc++;
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -242,6 +259,7 @@ _DEFUN(test_eok,(is, shouldbe),
 	   is, shouldbe);
     inacc++;
   }
+  __A_VARIABLE = 1;
 }
 
 void
@@ -255,8 +273,10 @@ _DEFUN(test_mok,(value, shouldbe, okmag),
   if (mag == 0) 
   {
     /* error in the first bit is ok if the numbers are both 0 */
-    if (value == 0.0 && shouldbe == 0.0)
+    if (value == 0.0 && shouldbe == 0.0) {
+     __A_VARIABLE = 1;
      return;
+    }
     
   }
   a.value = shouldbe;
@@ -274,11 +294,14 @@ _DEFUN(test_mok,(value, shouldbe, okmag),
     printf("(%g %g)\n",   a.value, b.value);
     inacc++;
   }
+  __A_VARIABLE = 1;
 }
 
 #ifdef __PCCNECV70__
-kill() {}
-getpid() {}
+kill() {__A_VARIABLE = 1;
+}
+getpid() {__A_VARIABLE = 1;
+}
 #endif
 
 bt(){
@@ -288,4 +311,5 @@ bt(){
   f2 = 0.0/f1;
   printf("(%g)\n", f2);
 
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/test/test_ieee.c b/newlib/libm/test/test_ieee.c
index a126d01..b589263 100644
--- a/newlib/libm/test/test_ieee.c
+++ b/newlib/libm/test/test_ieee.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 #include "test.h"
 #include <ieeefp.h>
@@ -22,6 +23,7 @@ _DEFUN_VOID(test_getround)
   line(4);  
   fpsetround(FP_RZ);
   test_iok(fpgetround(), FP_RZ);
+  __A_VARIABLE = 1;
 }
 
 /* And fpset/fpgetmask */
@@ -44,6 +46,7 @@ _DEFUN_VOID(test_getmask)
   line(5);  
   fpsetmask(FP_X_IMP);
   test_iok(fpgetmask(),FP_X_IMP);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -65,6 +68,7 @@ _DEFUN_VOID(test_getsticky)
   line(5);  
   fpsetsticky(FP_X_IMP);
   test_iok(fpgetsticky(),FP_X_IMP);
+  __A_VARIABLE = 1;
 }
 
 void
@@ -79,6 +83,7 @@ _DEFUN_VOID(test_getroundtoi)
   fpsetroundtoi(FP_RDI_RD);
   test_iok(fpgetroundtoi(),FP_RDI_RD);
 
+  __A_VARIABLE = 1;
 }
 
 double
@@ -90,6 +95,7 @@ double
   __ieee_double_shape_type v;
   v.parts.lsw = lsw;
   v.parts.msw = msw;
+  __A_VARIABLE = 1;
   return v.value;
 }
 
@@ -159,6 +165,7 @@ _DEFUN_VOID(test_round)
   r4 = - n - m;
   line(8);
   test_mok(r4,sub_rounded_up,64);
+  __A_VARIABLE = 1;
 }
 
 
@@ -175,6 +182,7 @@ _DEFUN_VOID(test_ieee)
   fpsetround(old);
 
   
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/newlib/libm/test/test_is.c b/newlib/libm/test/test_is.c
index 2e99bec..4307f91 100644
--- a/newlib/libm/test/test_is.c
+++ b/newlib/libm/test/test_is.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
 #include <ctype.h>
 
@@ -1910,26 +1911,44 @@ _DEFUN(test_is_single,(i),
       
     }
 
+    __A_VARIABLE = 1;
 }
 
 
-int _DEFUN(def_isascii,(i), int i) { return isascii(i); }
-int _DEFUN(def_iscntrl,(i), int i) { return iscntrl(i); }
-int _DEFUN(def_isspace,(i), int i) { return isspace(i); }
-int _DEFUN(def_isprint,(i), int i) { return isprint(i); }
-int _DEFUN(def_isalnum,(i), int i) { return isalnum(i); }
-int _DEFUN(def_isdigit,(i), int i) { return isdigit(i); }
-int _DEFUN(def_isxdigit,(i), int i) { return isxdigit(i); }
-int _DEFUN(def_isalpha,(i), int i) { return isalpha(i); }
-int _DEFUN(def_isupper,(i), int i) { return isupper(i); }
-int _DEFUN(def_islower,(i), int i) { return islower(i); }
-int _DEFUN(def_isgraph,(i), int i) { return isgraph(i); }
-int _DEFUN(def_ispunct,(i), int i) { return ispunct(i); }
-int _DEFUN(def_tolower,(i), int i) { return tolower(i); }
-int _DEFUN(def_toupper,(i), int i) { return toupper(i); }
-int _DEFUN(def_toascii,(i), int i) { return toascii(i); }
-int _DEFUN(def__tolower,(i), int i) { return _tolower(i); }
-int _DEFUN(def__toupper,(i), int i) { return _toupper(i); }
+int _DEFUN(def_isascii,(i), int i) { __A_VARIABLE = 1;
+	return isascii(i); }
+int _DEFUN(def_iscntrl,(i), int i) { __A_VARIABLE = 1;
+	return iscntrl(i); }
+int _DEFUN(def_isspace,(i), int i) { __A_VARIABLE = 1;
+	return isspace(i); }
+int _DEFUN(def_isprint,(i), int i) { __A_VARIABLE = 1;
+	return isprint(i); }
+int _DEFUN(def_isalnum,(i), int i) { __A_VARIABLE = 1;
+	return isalnum(i); }
+int _DEFUN(def_isdigit,(i), int i) { __A_VARIABLE = 1;
+	return isdigit(i); }
+int _DEFUN(def_isxdigit,(i), int i) { __A_VARIABLE = 1;
+	return isxdigit(i); }
+int _DEFUN(def_isalpha,(i), int i) { __A_VARIABLE = 1;
+	return isalpha(i); }
+int _DEFUN(def_isupper,(i), int i) { __A_VARIABLE = 1;
+	return isupper(i); }
+int _DEFUN(def_islower,(i), int i) { __A_VARIABLE = 1;
+	return islower(i); }
+int _DEFUN(def_isgraph,(i), int i) { __A_VARIABLE = 1;
+	return isgraph(i); }
+int _DEFUN(def_ispunct,(i), int i) { __A_VARIABLE = 1;
+	return ispunct(i); }
+int _DEFUN(def_tolower,(i), int i) { __A_VARIABLE = 1;
+	return tolower(i); }
+int _DEFUN(def_toupper,(i), int i) { __A_VARIABLE = 1;
+	return toupper(i); }
+int _DEFUN(def_toascii,(i), int i) { __A_VARIABLE = 1;
+	return toascii(i); }
+int _DEFUN(def__tolower,(i), int i) { __A_VARIABLE = 1;
+	return _tolower(i); }
+int _DEFUN(def__toupper,(i), int i) { __A_VARIABLE = 1;
+	return _toupper(i); }
 
 extern int inacc;
 void
@@ -1950,6 +1969,7 @@ _DEFUN(test_is_set,(func, name, p),
 	inacc++;
       }
   }
+  __A_VARIABLE = 1;
 }
 void
 _DEFUN(test_to_set,(func, name, p, low, high),
@@ -1971,6 +1991,7 @@ _DEFUN(test_to_set,(func, name, p, low, high),
 	inacc++;
       }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -2028,4 +2049,5 @@ _DEFUN_VOID(test_is)
   test_to_set(toascii, "toascii function", &setascii, 0,255);
   test_to_set(tolower, "tolower function", &setlower, 0,255);
   test_to_set(toupper, "toupper function", &setupper, 0,255);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/libm/test/y0_vec.c b/newlib/libm/test/y0_vec.c
index 9fae154..e701044 100644
--- a/newlib/libm/test/y0_vec.c
+++ b/newlib/libm/test/y0_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type y0_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3fc2771c, 0x9fef6e9f, 0x403bcccc, 0xccccccc9},			/* 0.14426=f(27.8000)*/
 {64, 0,123,__LINE__, 0xbfafc3a0, 0x56b6c32f, 0x403d7fff, 0xfffffffc},			/* -0.06203=f(29.5000)*/
 0,};
-test_y0(m)   {run_vector_1(m,y0_vec,(char *)(y0),"y0","dd");   }	
+test_y0(m)   {run_vector_1(m,y0_vec,(char *)(y0),"y0","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/y0f_vec.c b/newlib/libm/test/y0f_vec.c
index 5567a9f..1ff0ec3 100644
--- a/newlib/libm/test/y0f_vec.c
+++ b/newlib/libm/test/y0f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type y0f_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 0, 0,123,__LINE__, 0x3fc2771d, 0x63e62eec, 0x403bcccc, 0xccccccc9},			/* 0.14426=f(27.8000)*/
 { 0, 0,123,__LINE__, 0xbfafc39b, 0xf28f96ed, 0x403d7fff, 0xfffffffc},			/* -0.06203=f(29.5000)*/
 0,};
-test_y0f(m)   {run_vector_1(m,y0f_vec,(char *)(y0f),"y0f","ff");   }	
+test_y0f(m)   {run_vector_1(m,y0f_vec,(char *)(y0f),"y0f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/y1_vec.c b/newlib/libm/test/y1_vec.c
index 3cb5497..902a126 100644
--- a/newlib/libm/test/y1_vec.c
+++ b/newlib/libm/test/y1_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type y1_vec[] = {
 {64,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 {64, 0,123,__LINE__, 0x3fa8b66b, 0x18717143, 0x403bcccc, 0xccccccc9},			/* 0.04826=f(27.8000)*/
 {64, 0,123,__LINE__, 0x3fc0e92b, 0x1cafe2d0, 0x403d7fff, 0xfffffffc},			/* 0.13211=f(29.5000)*/
 0,};
-test_y1(m)   {run_vector_1(m,y1_vec,(char *)(y1),"y1","dd");   }	
+test_y1(m)   {run_vector_1(m,y1_vec,(char *)(y1),"y1","dd");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/y1f_vec.c b/newlib/libm/test/y1f_vec.c
index 419afb1..08eab60 100644
--- a/newlib/libm/test/y1f_vec.c
+++ b/newlib/libm/test/y1f_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type y1f_vec[] = {
 { 9,13, 37,__LINE__, 0x40500000, 0x00000000, 0xbff33333, 0x33333333},			/* 64.0000=f(-1.20000)*/
@@ -285,4 +286,5 @@
 { 0, 0,123,__LINE__, 0x3fa8b668, 0xc801a7a1, 0x403bcccc, 0xccccccc9},			/* 0.04826=f(27.8000)*/
 {11, 0,123,__LINE__, 0x3fc0e92a, 0xfe6b2ee0, 0x403d7fff, 0xfffffffc},			/* 0.13211=f(29.5000)*/
 0,};
-test_y1f(m)   {run_vector_1(m,y1f_vec,(char *)(y1f),"y1f","ff");   }	
+test_y1f(m)   {run_vector_1(m,y1f_vec,(char *)(y1f),"y1f","ff");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/yn_vec.c b/newlib/libm/test/yn_vec.c
index 6902853..20e4321 100644
--- a/newlib/libm/test/yn_vec.c
+++ b/newlib/libm/test/yn_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type yn_vec[] = {
 {64,0,123,__LINE__, 0x3ff00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
@@ -201,4 +202,5 @@
 {64,0,123,__LINE__, 0x3fbefed6, 0x4831e4df, 0x40080000, 0x00000000, 0x3fff3333, 0x33333338},
 {64,0,123,__LINE__, 0x3f9fc826, 0xafa66438, 0x40100000, 0x00000000, 0x3fff3333, 0x33333338},
 0,};
-test_yn(m)   {run_vector_1(m,yn_vec,(char *)(yn),"yn","did");   }	
+test_yn(m)   {run_vector_1(m,yn_vec,(char *)(yn),"yn","did");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/libm/test/ynf_vec.c b/newlib/libm/test/ynf_vec.c
index edd0d17..2602b7e 100644
--- a/newlib/libm/test/ynf_vec.c
+++ b/newlib/libm/test/ynf_vec.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test.h"
  one_line_type ynf_vec[] = {
 
@@ -196,4 +197,5 @@
 {32,0,123,__LINE__, 0xbff2f1d5, 0x75c2f518, 0x40080000, 0x00000000, 0x3fff3333, 0x33333338},
 {32,0,123,__LINE__, 0xc007ffe0, 0x680bca3f, 0x40100000, 0x00000000, 0x3fff3333, 0x33333338},
 0,};
-test_ynf(m)   {run_vector_1(m,ynf_vec,(char *)(ynf),"ynf","fif");   }	
+test_ynf(m)   {run_vector_1(m,ynf_vec,(char *)(ynf),"ynf","fif");   __A_VARIABLE = 1;
+}	
diff --git a/newlib/testsuite/newlib.elix/tmmap.c b/newlib/testsuite/newlib.elix/tmmap.c
index d930c96..113148b 100644
--- a/newlib/testsuite/newlib.elix/tmmap.c
+++ b/newlib/testsuite/newlib.elix/tmmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <stdio.h>
@@ -38,5 +39,6 @@ int main()
   CHECK (strncmp (buf, "abcjefgh", 8) == 0);
 
   exit (0);
+  __A_VARIABLE = 1;
 }
 
diff --git a/newlib/testsuite/newlib.iconv/iconvjp.c b/newlib/testsuite/newlib.iconv/iconvjp.c
index 2022851..1485885 100644
--- a/newlib/testsuite/newlib.iconv/iconvjp.c
+++ b/newlib/testsuite/newlib.iconv/iconvjp.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003, Artem B. Bityuckiy, SoftMine Corporation.
  * Rights transferred to Franklin Electronic Publishers.
@@ -958,6 +959,7 @@ int main(int argc, char **argv)
             CHECK(iconv_close(descs[d++]) != -1);
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 #else /* #if defined(_ICONV_CONVERTER_UTF_8) || ... */
@@ -966,6 +968,7 @@ int main(int argc, char **argv)
     puts("None of UTF-8, EUC-JP, SHIFT-JIS and UCS-2_INTERNAL converters "
          "linked, SKIP test");
     exit(0);
+    __A_VARIABLE = 1;
 }
 #endif /* #if defined(_ICONV_CONVERTER_UTF_8) || ... */
 
@@ -974,6 +977,7 @@ int main(int argc, char **argv)
 {
     puts("iconv library is disabled, SKIP test");
     exit(0);
+    __A_VARIABLE = 1;
 }
 #endif /* #ifdef _ICONV_ENABLED */
 
diff --git a/newlib/testsuite/newlib.iconv/iconvnm.c b/newlib/testsuite/newlib.iconv/iconvnm.c
index d7ef216..3b53476 100644
--- a/newlib/testsuite/newlib.iconv/iconvnm.c
+++ b/newlib/testsuite/newlib.iconv/iconvnm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003, Artem B. Bityuckiy, SoftMine Corporation.
  * Rights transferred to Franklin Electronic Publishers.
@@ -102,12 +103,14 @@ int main(int argc, char **argv)
     }
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 #else
 int main(int argc, char **argv)
 {
     puts("iconv library is disabled, skip name test");
     exit(0);
+    __A_VARIABLE = 1;
 }
 #endif /* #ifdef _ICONV_ENABLED */
 
diff --git a/newlib/testsuite/newlib.iconv/iconvru.c b/newlib/testsuite/newlib.iconv/iconvru.c
index 7f02ebc..c65a721 100644
--- a/newlib/testsuite/newlib.iconv/iconvru.c
+++ b/newlib/testsuite/newlib.iconv/iconvru.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2003, Artem B. Bityuckiy, SoftMine Corporation.
  * Rights transferred to Franklin Electronic Publishers.
@@ -469,6 +470,7 @@ int main(int argc, char **argv)
             CHECK(iconv_close(descs[d++]) != -1);
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 #else /* #if defined(_ICONV_CONVERTER_UTF_8) || ... */
@@ -476,6 +478,7 @@ int main(int argc, char **argv)
 {
     puts("None of ISO-8859-5, KOI8-R and UTF-8 converters linked, SKIP test");
     exit(0);
+    __A_VARIABLE = 1;
 }
 #endif /* #if defined(_ICONV_CONVERTER_UTF_8) || ... */
 
@@ -484,6 +487,7 @@ int main(int argc, char **argv)
 {
     puts("iconv library is disabled, SKIP test");
     exit(0);
+    __A_VARIABLE = 1;
 }
 #endif /* #ifdef _ICONV_ENABLED */
 
diff --git a/newlib/testsuite/newlib.locale/UTF-8.c b/newlib/testsuite/newlib.locale/UTF-8.c
index 3e56267..d0de5a9 100644
--- a/newlib/testsuite/newlib.locale/UTF-8.c
+++ b/newlib/testsuite/newlib.locale/UTF-8.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *  Copyright (C) 2002 by Red Hat, Incorporated. All rights reserved.
  *
diff --git a/newlib/testsuite/newlib.search/hsearchtest.c b/newlib/testsuite/newlib.search/hsearchtest.c
index 5154403..826d325 100644
--- a/newlib/testsuite/newlib.search/hsearchtest.c
+++ b/newlib/testsuite/newlib.search/hsearchtest.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*	$NetBSD: hsearchtest.c,v 1.4 2002/02/21 07:38:15 itojun Exp $	*/
 
 /*
@@ -56,6 +57,7 @@ testfail(const char *file, unsigned long line, const char *expression)
 	fprintf(stderr, "TEST FAILED: %s: file %s, line %ld\n",
 	    expression, file, line);
 	exit(1);
+	__A_VARIABLE = 1;
 }
 
 int
@@ -122,4 +124,5 @@ main(int argc, char *argv[])
 	hdestroy();
 
 	exit(0);
+	__A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.stdio/nulprintf.c b/newlib/testsuite/newlib.stdio/nulprintf.c
index 5e4131b..298eba2 100644
--- a/newlib/testsuite/newlib.stdio/nulprintf.c
+++ b/newlib/testsuite/newlib.stdio/nulprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2014 by ARM Ltd. All rights reserved.
  *
@@ -14,4 +15,5 @@ int main()
 {
   printf ("%.*s\n", 8, m);
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.stdio/swprintf.c b/newlib/testsuite/newlib.stdio/swprintf.c
index c20bf89..9b87154 100644
--- a/newlib/testsuite/newlib.stdio/swprintf.c
+++ b/newlib/testsuite/newlib.stdio/swprintf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2011 by ARM Ltd. All rights reserved.
  *
@@ -27,4 +28,5 @@ int main()
 #endif
 
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.stdlib/atexit.c b/newlib/testsuite/newlib.stdlib/atexit.c
index 48fdb67..0b92f14 100644
--- a/newlib/testsuite/newlib.stdlib/atexit.c
+++ b/newlib/testsuite/newlib.stdlib/atexit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -9,22 +10,26 @@ static void newline(void);
 void a (void)
 {
   printf("a");
+  __A_VARIABLE = 1;
 }
 
 void b (void)
 {
   printf("b");
+  __A_VARIABLE = 1;
 }
 
 void c (int code, void *k)
 {
   char *x = (char *)k;
   printf("%d%c",code,x[0]);
+  __A_VARIABLE = 1;
 }
 
 static void newline (void)
 {
   printf("\n");
+  __A_VARIABLE = 1;
 }
 
 int main()
@@ -45,4 +50,5 @@ int main()
     abort();
 
   exit(0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.stdlib/size_max.c b/newlib/testsuite/newlib.stdlib/size_max.c
index d163e27..befef16 100644
--- a/newlib/testsuite/newlib.stdlib/size_max.c
+++ b/newlib/testsuite/newlib.stdlib/size_max.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stddef.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -14,5 +15,6 @@ int main () {
   if (++s != 0)
     abort ();
 
+  __A_VARIABLE = 1;
   return 0;
 }
diff --git a/newlib/testsuite/newlib.string/memcpy-1.c b/newlib/testsuite/newlib.string/memcpy-1.c
index 145db1a..feca10d 100644
--- a/newlib/testsuite/newlib.string/memcpy-1.c
+++ b/newlib/testsuite/newlib.string/memcpy-1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 ARM Ltd
  * All rights reserved.
@@ -73,6 +74,7 @@ print_error (char const* msg, ...)
     {
       /* Further errors omitted.  */
     }
+    __A_VARIABLE = 1;
 }
 
 int
@@ -157,4 +159,5 @@ main (void)
     abort ();
 
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.string/memmove1.c b/newlib/testsuite/newlib.string/memmove1.c
index d3f1d66..0d24b3c 100644
--- a/newlib/testsuite/newlib.string/memmove1.c
+++ b/newlib/testsuite/newlib.string/memmove1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A minor test-program for memmove.
    Copyright (C) 2005 Axis Communications.
    All rights reserved.
@@ -66,6 +67,7 @@ mymemmove (unsigned char *dest, unsigned char *src, size_t n)
       while (n-- > 0)
 	*--dest = *--src;
     }
+  __A_VARIABLE = 1;
 }
 
 /* It's either the noinline attribute or forcing the test framework to
@@ -86,6 +88,7 @@ xmemmove (unsigned char *dest, unsigned char *src, size_t n)
       DEBUGP ("memmove of n bytes returned %p instead of dest=%p\n",
 	      retp, dest);
     }
+    __A_VARIABLE = 1;
 }
 
 
@@ -98,6 +101,7 @@ fill (unsigned char dest[MAX*3])
   size_t i;
   for (i = 0; i < MAX*3; i++)
     dest[i] = (10 + i) % MAX;
+  __A_VARIABLE = 1;
 }
 
 int
@@ -181,4 +185,5 @@ main (void)
   if (errors != 0)
     abort ();
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.string/strcmp-1.c b/newlib/testsuite/newlib.string/strcmp-1.c
index 71a17d6..4ddf1b9 100644
--- a/newlib/testsuite/newlib.string/strcmp-1.c
+++ b/newlib/testsuite/newlib.string/strcmp-1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2011 ARM Ltd
  * All rights reserved.
@@ -115,6 +116,7 @@ print_error (char const* msg, ...)
     {
       /* Further errors omitted.  */
     }
+    __A_VARIABLE = 1;
 }
 
 void
@@ -128,6 +130,7 @@ printbuf (char *buf, char *name)
     else
       printf ("(%d,%s)", i, "\\0");
   printf ("\n");
+  __A_VARIABLE = 1;
 }
 
 int
@@ -282,4 +285,5 @@ main (void)
       abort ();
     }
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.string/tstring.c b/newlib/testsuite/newlib.string/tstring.c
index 9c5acb6..c9cd16f 100644
--- a/newlib/testsuite/newlib.string/tstring.c
+++ b/newlib/testsuite/newlib.string/tstring.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (C) 2002 by Red Hat, Incorporated. All rights reserved.
  *
@@ -27,6 +28,7 @@ void eprintf (int line, char *result, char *expected, int size)
   else
     printf ("Failure at line %d, result is <%s>, should be <%s>\n",
              line, result, expected);
+  __A_VARIABLE = 1;
 }
 
 void mycopy (char *target, char *source, int size)
@@ -37,6 +39,7 @@ void mycopy (char *target, char *source, int size)
     {
       target[i] = source[i];
     }
+    __A_VARIABLE = 1;
 }
 
 void myset (char *target, char ch, int size)
@@ -47,6 +50,7 @@ void myset (char *target, char ch, int size)
     {
       target[i] = ch;
     }
+    __A_VARIABLE = 1;
 }
 
 int main()
@@ -350,4 +354,5 @@ int main()
     abort();
   else
     exit(0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.wctype/tiswctype.c b/newlib/testsuite/newlib.wctype/tiswctype.c
index 441cddb..181be9f 100644
--- a/newlib/testsuite/newlib.wctype/tiswctype.c
+++ b/newlib/testsuite/newlib.wctype/tiswctype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <wctype.h>
 #include <newlib.h>
 #include "check.h"
@@ -58,4 +59,5 @@ int main()
   CHECK (x == 0);
 
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.wctype/twctrans.c b/newlib/testsuite/newlib.wctype/twctrans.c
index f8b7b50..786a676 100644
--- a/newlib/testsuite/newlib.wctype/twctrans.c
+++ b/newlib/testsuite/newlib.wctype/twctrans.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <wctype.h>
 #include <newlib.h>
 #include "check.h"
@@ -20,4 +21,5 @@ int main()
   CHECK (x == 0);
 
   exit (0);
+  __A_VARIABLE = 1;
 }
diff --git a/newlib/testsuite/newlib.wctype/twctype.c b/newlib/testsuite/newlib.wctype/twctype.c
index 95be74d..df26f4b 100644
--- a/newlib/testsuite/newlib.wctype/twctype.c
+++ b/newlib/testsuite/newlib.wctype/twctype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <wctype.h>
 #include <ctype.h>
 #include <stdio.h>
@@ -61,4 +62,5 @@ int main()
 #endif
 
   exit (0);
+  __A_VARIABLE = 1;
 }
-- 
2.34.1

