From 36823c28b32ddd4ef2963721b0521e44f37db3ec Mon Sep 17 00:00:00 2001
From: Mateusz Krajewski <mkrajewski413@gmail.com>
Date: Fri, 30 Dec 2022 16:29:22 +0100
Subject: [PATCH 1/1] Touch memory at every exit point

Signed-off-by: Mateusz Krajewski <mkrajewski413@gmail.com>
---
 deps/hiredis/async.c                          |  118 +-
 deps/hiredis/dict.c                           |   86 +-
 deps/hiredis/examples/example-ae.c            |   16 +-
 deps/hiredis/examples/example-glib.c          |    8 +
 deps/hiredis/examples/example-ivykis.c        |   16 +-
 deps/hiredis/examples/example-libev.c         |   16 +-
 deps/hiredis/examples/example-libevent.c      |   16 +-
 deps/hiredis/examples/example-libuv.c         |   16 +-
 deps/hiredis/examples/example-macosx.c        |   17 +-
 deps/hiredis/examples/example.c               |    2 +
 deps/hiredis/hiredis.c                        |  234 +++-
 deps/hiredis/net.c                            |   36 +
 deps/hiredis/read.c                           |   52 +-
 deps/hiredis/sds.c                            |  214 +++-
 deps/hiredis/test.c                           |   35 +-
 deps/jemalloc/src/arena.c                     |  221 ++++
 deps/jemalloc/src/background_thread.c         |   69 ++
 deps/jemalloc/src/base.c                      |   55 +
 deps/jemalloc/src/bin.c                       |    9 +
 deps/jemalloc/src/bitmap.c                    |   16 +
 deps/jemalloc/src/ckh.c                       |   52 +
 deps/jemalloc/src/div.c                       |    2 +
 deps/jemalloc/src/extent.c                    |  213 ++++
 deps/jemalloc/src/extent_dss.c                |   28 +
 deps/jemalloc/src/extent_mmap.c               |    5 +
 deps/jemalloc/src/jemalloc.c                  |  168 +++
 deps/jemalloc/src/large.c                     |   35 +
 deps/jemalloc/src/log.c                       |    7 +
 deps/jemalloc/src/malloc_io.c                 |   22 +
 deps/jemalloc/src/mutex.c                     |   17 +
 deps/jemalloc/src/mutex_pool.c                |    3 +
 deps/jemalloc/src/nstime.c                    |   45 +
 deps/jemalloc/src/pages.c                     |   40 +
 deps/jemalloc/src/prof.c                      |  243 ++++
 deps/jemalloc/src/stats.c                     |   27 +
 deps/jemalloc/src/tcache.c                    |   58 +
 deps/jemalloc/src/tsd.c                       |   32 +
 deps/jemalloc/src/witness.c                   |   21 +
 deps/jemalloc/src/zone.c                      |   57 +
 .../jemalloc/test/integration/MALLOCX_ARENA.c |    6 +
 .../jemalloc/test/integration/aligned_alloc.c |   10 +
 deps/jemalloc/test/integration/allocated.c    |    9 +
 deps/jemalloc/test/integration/extent.c       |   16 +
 deps/jemalloc/test/integration/mallocx.c      |   20 +
 deps/jemalloc/test/integration/overflow.c     |    4 +
 .../test/integration/posix_memalign.c         |   10 +
 deps/jemalloc/test/integration/rallocx.c      |   20 +
 deps/jemalloc/test/integration/sdallocx.c     |    6 +
 deps/jemalloc/test/integration/thread_arena.c |    8 +
 .../test/integration/thread_tcache_enabled.c  |    8 +
 deps/jemalloc/test/integration/xallocx.c      |   36 +
 deps/jemalloc/test/src/SFMT.c                 |   54 +
 deps/jemalloc/test/src/btalloc.c              |    2 +
 deps/jemalloc/test/src/mq.c                   |    2 +
 deps/jemalloc/test/src/mtx.c                  |    6 +
 deps/jemalloc/test/src/test.c                 |   43 +-
 deps/jemalloc/test/src/thd.c                  |    8 +
 deps/jemalloc/test/src/timer.c                |    9 +
 deps/jemalloc/test/stress/microbench.c        |   35 +
 deps/jemalloc/test/unit/SFMT.c                |    2 +
 deps/jemalloc/test/unit/a0.c                  |    4 +
 deps/jemalloc/test/unit/arena_reset.c         |   43 +
 deps/jemalloc/test/unit/atomic.c              |   14 +
 deps/jemalloc/test/unit/background_thread.c   |   10 +
 .../test/unit/background_thread_enable.c      |    6 +
 deps/jemalloc/test/unit/base.c                |    8 +
 deps/jemalloc/test/unit/bit_util.c            |    8 +
 deps/jemalloc/test/unit/ckh.c                 |    8 +
 deps/jemalloc/test/unit/decay.c               |   45 +
 deps/jemalloc/test/unit/div.c                 |    4 +
 deps/jemalloc/test/unit/emitter.c             |   22 +
 deps/jemalloc/test/unit/extent_quantize.c     |    8 +
 deps/jemalloc/test/unit/fork.c                |   10 +
 deps/jemalloc/test/unit/hooks.c               |   10 +
 deps/jemalloc/test/unit/junk.c                |   16 +
 deps/jemalloc/test/unit/log.c                 |    6 +
 deps/jemalloc/test/unit/mallctl.c             |   54 +
 deps/jemalloc/test/unit/malloc_io.c           |   10 +
 deps/jemalloc/test/unit/math.c                |   19 +
 deps/jemalloc/test/unit/mq.c                  |    8 +
 deps/jemalloc/test/unit/mtx.c                 |    8 +
 deps/jemalloc/test/unit/nstime.c              |   28 +
 deps/jemalloc/test/unit/pack.c                |   13 +
 deps/jemalloc/test/unit/pages.c               |    4 +
 deps/jemalloc/test/unit/ph.c                  |   24 +
 deps/jemalloc/test/unit/prng.c                |   34 +
 deps/jemalloc/test/unit/prof_accum.c          |   10 +
 deps/jemalloc/test/unit/prof_active.c         |   18 +
 deps/jemalloc/test/unit/prof_gdump.c          |    6 +
 deps/jemalloc/test/unit/prof_idump.c          |    6 +
 deps/jemalloc/test/unit/prof_reset.c          |   20 +
 deps/jemalloc/test/unit/prof_tctx.c           |    4 +
 deps/jemalloc/test/unit/prof_thread_name.c    |   10 +
 deps/jemalloc/test/unit/ql.c                  |   18 +
 deps/jemalloc/test/unit/qr.c                  |   18 +
 deps/jemalloc/test/unit/rb.c                  |   20 +
 deps/jemalloc/test/unit/retained.c            |   18 +
 deps/jemalloc/test/unit/rtree.c               |   20 +
 deps/jemalloc/test/unit/size_classes.c        |   10 +
 deps/jemalloc/test/unit/slab.c                |    4 +
 deps/jemalloc/test/unit/smoothstep.c          |    8 +
 deps/jemalloc/test/unit/spin.c                |    4 +
 deps/jemalloc/test/unit/stats.c               |   22 +
 deps/jemalloc/test/unit/ticker.c              |    8 +
 deps/jemalloc/test/unit/tsd.c                 |   16 +
 deps/jemalloc/test/unit/witness.c             |   26 +
 deps/jemalloc/test/unit/zero.c                |    8 +
 deps/linenoise/example.c                      |    7 +
 deps/linenoise/linenoise.c                    |  158 ++-
 deps/lua/etc/min.c                            |    4 +
 deps/lua/etc/noparser.c                       |    6 +
 deps/lua/src/fpconv.c                         |   35 +-
 deps/lua/src/lapi.c                           |  176 ++-
 deps/lua/src/lauxlib.c                        |  124 +-
 deps/lua/src/lbaselib.c                       |   92 +-
 deps/lua/src/lcode.c                          |  141 ++-
 deps/lua/src/ldblib.c                         |   58 +-
 deps/lua/src/ldebug.c                         |   84 +-
 deps/lua/src/ldo.c                            |   52 +-
 deps/lua/src/ldump.c                          |   22 +
 deps/lua/src/lfunc.c                          |   27 +-
 deps/lua/src/lgc.c                            |   84 +-
 deps/lua/src/linit.c                          |    2 +
 deps/lua/src/liolib.c                         |   68 ++
 deps/lua/src/lmathlib.c                       |   61 +-
 deps/lua/src/lmem.c                           |    6 +
 deps/lua/src/loadlib.c                        |  119 +-
 deps/lua/src/lobject.c                        |   27 +-
 deps/lua/src/loslib.c                         |   40 +-
 deps/lua/src/lparser.c                        |  226 +++-
 deps/lua/src/lstate.c                         |   25 +-
 deps/lua/src/lstring.c                        |   15 +-
 deps/lua/src/lstrlib.c                        |  105 +-
 deps/lua/src/ltable.c                         |   60 +-
 deps/lua/src/ltablib.c                        |   41 +-
 deps/lua/src/ltm.c                            |    4 +
 deps/lua/src/lua.c                            |  110 +-
 deps/lua/src/lua_struct.c                     |   60 +-
 deps/lua/src/luac.c                           |   14 +
 deps/lua/src/lundump.c                        |   24 +
 deps/lua/src/lvm.c                            |   81 +-
 deps/lua/src/lzio.c                           |   19 +-
 deps/lua/src/print.c                          |   21 +-
 deps/lua/src/strbuf.c                         |   28 +-
 src/adlist.c                                  |   14 +-
 src/ae.c                                      |   87 +-
 src/ae_epoll.c                                |   26 +-
 src/ae_evport.c                               |   34 +-
 src/ae_kqueue.c                               |   31 +-
 src/ae_select.c                               |   24 +-
 src/anet.c                                    |  141 ++-
 src/aof.c                                     |  177 ++-
 src/bio.c                                     |   13 +
 src/bitops.c                                  |   57 +-
 src/blocked.c                                 |   37 +-
 src/childinfo.c                               |   18 +-
 src/cluster.c                                 |  439 ++++++-
 src/config.c                                  |  103 +-
 src/crc16.c                                   |    2 +
 src/crc64.c                                   |    4 +
 src/db.c                                      |  203 +++-
 src/debug.c                                   |   84 +-
 src/defrag.c                                  |  113 +-
 src/dict.c                                    |  211 +++-
 src/endianconv.c                              |   14 +
 src/evict.c                                   |   69 +-
 src/expire.c                                  |   59 +-
 src/geo.c                                     |   73 +-
 src/geohash.c                                 |   59 +-
 src/geohash_helper.c                          |   39 +-
 src/hyperloglog.c                             |   88 +-
 src/intset.c                                  |   39 +
 src/latency.c                                 |   40 +-
 src/lazyfree.c                                |   14 +
 src/listpack.c                                |  125 +-
 src/localtime.c                               |    4 +
 src/lolwut.c                                  |    4 +
 src/lolwut5.c                                 |   42 +-
 src/memtest.c                                 |   36 +-
 src/module.c                                  | 1056 +++++++++++++++--
 src/modules/helloblock.c                      |   45 +-
 src/modules/hellocluster.c                    |   24 +-
 src/modules/hellodict.c                       |   34 +-
 src/modules/hellotimer.c                      |   15 +-
 src/modules/hellotype.c                       |   69 +-
 src/modules/testmodule.c                      |   87 +-
 src/multi.c                                   |   55 +-
 src/networking.c                              |  291 ++++-
 src/notify.c                                  |   14 +-
 src/object.c                                  |  138 ++-
 src/pqsort.c                                  |    9 +
 src/pubsub.c                                  |   32 +
 src/quicklist.c                               |   78 +-
 src/rand.c                                    |    6 +
 src/rax.c                                     |  112 +-
 src/rdb.c                                     |  369 +++++-
 src/redis-benchmark.c                         |   49 +-
 src/redis-check-aof.c                         |   21 +
 src/redis-check-rdb.c                         |   27 +-
 src/redis-cli.c                               |  612 +++++++++-
 src/release.c                                 |    4 +
 src/replication.c                             |  158 ++-
 src/rio.c                                     |   75 +-
 src/scripting.c                               |  183 ++-
 src/sds.c                                     |  196 ++-
 src/sentinel.c                                |  387 +++++-
 src/server.c                                  |  249 +++-
 src/setproctitle.c                            |   29 +-
 src/sha1.c                                    |   10 +
 src/siphash.c                                 |    7 +-
 src/slowlog.c                                 |   15 +-
 src/sort.c                                    |   13 +
 src/sparkline.c                               |   10 +
 src/t_hash.c                                  |  127 +-
 src/t_list.c                                  |  125 +-
 src/t_set.c                                   |  122 +-
 src/t_stream.c                                |  164 ++-
 src/t_string.c                                |  102 +-
 src/t_zset.c                                  |  427 ++++++-
 src/util.c                                    |   84 +-
 src/zipmap.c                                  |   49 +-
 src/zmalloc.c                                 |   73 +-
 tests/modules/commandfilter.c                 |   38 +-
 tests/modules/testrdb.c                       |   28 +
 utils/corrupt_rdb.c                           |    2 +
 utils/hashtable/rehashing.c                   |   16 +
 utils/lru/lfu-simulation.c                    |   22 +-
 227 files changed, 12809 insertions(+), 1137 deletions(-)

diff --git a/deps/hiredis/async.c b/deps/hiredis/async.c
index d955203..83f10fa 100644
--- a/deps/hiredis/async.c
+++ b/deps/hiredis/async.c
@@ -62,35 +62,48 @@ int __redisAppendCommand(redisContext *c, const char *cmd, size_t len);
 
 /* Functions managing dictionary of callbacks for pub/sub. */
 static unsigned int callbackHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction((const unsigned char *)key,
                                sdslen((const sds)key));
 }
 
 static void *callbackValDup(void *privdata, const void *src) {
+    volatile int __A_VARIABLE;
     ((void) privdata);
     redisCallback *dup = malloc(sizeof(*dup));
     memcpy(dup,src,sizeof(*dup));
+    __A_VARIABLE = 1;
     return dup;
 }
 
 static int callbackKeyCompare(void *privdata, const void *key1, const void *key2) {
+    volatile int __A_VARIABLE;
     int l1, l2;
     ((void) privdata);
 
     l1 = sdslen((const sds)key1);
     l2 = sdslen((const sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1,key2,l1) == 0;
 }
 
 static void callbackKeyDestructor(void *privdata, void *key) {
+    volatile int __A_VARIABLE;
     ((void) privdata);
     sdsfree((sds)key);
+    __A_VARIABLE = 1;
 }
 
 static void callbackValDestructor(void *privdata, void *val) {
+    volatile int __A_VARIABLE;
     ((void) privdata);
     free(val);
+    __A_VARIABLE = 1;
 }
 
 static dictType callbackDict = {
@@ -103,11 +116,14 @@ static dictType callbackDict = {
 };
 
 static redisAsyncContext *redisAsyncInitialize(redisContext *c) {
+    volatile int __A_VARIABLE;
     redisAsyncContext *ac;
 
     ac = realloc(c,sizeof(redisAsyncContext));
-    if (ac == NULL)
+    if (ac == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c = &(ac->c);
 
@@ -136,73 +152,93 @@ static redisAsyncContext *redisAsyncInitialize(redisContext *c) {
     ac->sub.invalid.tail = NULL;
     ac->sub.channels = dictCreate(&callbackDict,NULL);
     ac->sub.patterns = dictCreate(&callbackDict,NULL);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 /* We want the error field to be accessible directly instead of requiring
  * an indirection to the redisContext struct. */
 static void __redisAsyncCopyError(redisAsyncContext *ac) {
-    if (!ac)
+    volatile int __A_VARIABLE;
+    if (!ac) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     redisContext *c = &(ac->c);
     ac->err = c->err;
     ac->errstr = c->errstr;
+    __A_VARIABLE = 1;
 }
 
 redisAsyncContext *redisAsyncConnect(const char *ip, int port) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisAsyncContext *ac;
 
     c = redisConnectNonBlock(ip,port);
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     ac = redisAsyncInitialize(c);
     if (ac == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 redisAsyncContext *redisAsyncConnectBind(const char *ip, int port,
                                          const char *source_addr) {
+    volatile int __A_VARIABLE;
     redisContext *c = redisConnectBindNonBlock(ip,port,source_addr);
     redisAsyncContext *ac = redisAsyncInitialize(c);
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
                                                   const char *source_addr) {
+    volatile int __A_VARIABLE;
     redisContext *c = redisConnectBindNonBlockWithReuse(ip,port,source_addr);
     redisAsyncContext *ac = redisAsyncInitialize(c);
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 redisAsyncContext *redisAsyncConnectUnix(const char *path) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisAsyncContext *ac;
 
     c = redisConnectUnixNonBlock(path);
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     ac = redisAsyncInitialize(c);
     if (ac == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn) {
+    volatile int __A_VARIABLE;
     if (ac->onConnect == NULL) {
         ac->onConnect = fn;
 
@@ -210,27 +246,35 @@ int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn
          * the first write event to be fired. This assumes the related event
          * library functions are already set. */
         _EL_ADD_WRITE(ac);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn) {
+    volatile int __A_VARIABLE;
     if (ac->onDisconnect == NULL) {
         ac->onDisconnect = fn;
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 /* Helper functions to push/shift callbacks */
 static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {
+    volatile int __A_VARIABLE;
     redisCallback *cb;
 
     /* Copy callback from stack to heap */
     cb = malloc(sizeof(*cb));
-    if (cb == NULL)
+    if (cb == NULL) {
+        __A_VARIABLE = 1;
         return REDIS_ERR_OOM;
+    }
 
     if (source != NULL) {
         memcpy(cb,source,sizeof(*cb));
@@ -243,10 +287,12 @@ static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {
     if (list->tail != NULL)
         list->tail->next = cb;
     list->tail = cb;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int __redisShiftCallback(redisCallbackList *list, redisCallback *target) {
+    volatile int __A_VARIABLE;
     redisCallback *cb = list->head;
     if (cb != NULL) {
         list->head = cb->next;
@@ -257,22 +303,27 @@ static int __redisShiftCallback(redisCallbackList *list, redisCallback *target)
         if (target != NULL)
             memcpy(target,cb,sizeof(*cb));
         free(cb);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisReply *reply) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     if (cb->fn != NULL) {
         c->flags |= REDIS_IN_CALLBACK;
         cb->fn(ac,reply,cb->privdata);
         c->flags &= ~REDIS_IN_CALLBACK;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to free the context. */
 static void __redisAsyncFree(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     redisCallback cb;
     dictIterator *it;
@@ -314,6 +365,7 @@ static void __redisAsyncFree(redisAsyncContext *ac) {
 
     /* Cleanup self */
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Free the async context. When this function is called from a callback,
@@ -321,14 +373,17 @@ static void __redisAsyncFree(redisAsyncContext *ac) {
  * free'ing. To do so, a flag is set on the context which is picked up by
  * redisProcessCallbacks(). Otherwise, the context is immediately free'd. */
 void redisAsyncFree(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     c->flags |= REDIS_FREEING;
     if (!(c->flags & REDIS_IN_CALLBACK))
         __redisAsyncFree(ac);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to make the disconnect happen and clean up. */
 static void __redisAsyncDisconnect(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
 
     /* Make sure error is accessible if there is any */
@@ -346,6 +401,7 @@ static void __redisAsyncDisconnect(redisAsyncContext *ac) {
     /* For non-clean disconnects, __redisAsyncFree() will execute pending
      * callbacks with a NULL-reply. */
     __redisAsyncFree(ac);
+    __A_VARIABLE = 1;
 }
 
 /* Tries to do a clean disconnect from Redis, meaning it stops new commands
@@ -355,13 +411,16 @@ static void __redisAsyncDisconnect(redisAsyncContext *ac) {
  * to redisProcessCallbacks(). Otherwise, we can only disconnect immediately
  * when there are no pending callbacks. */
 void redisAsyncDisconnect(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     c->flags |= REDIS_DISCONNECTING;
     if (!(c->flags & REDIS_IN_CALLBACK) && ac->replies.head == NULL)
         __redisAsyncDisconnect(ac);
+    __A_VARIABLE = 1;
 }
 
 static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply, redisCallback *dstcb) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     dict *callbacks;
     dictEntry *de;
@@ -405,6 +464,7 @@ static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply,
         /* Shift callback for invalid commands. */
         __redisShiftCallback(&ac->sub.invalid,dstcb);
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -492,21 +552,26 @@ void redisProcessCallbacks(redisAsyncContext *ac) {
  * write event fires. When connecting was not successful, the connect callback
  * is called with a REDIS_ERR status and the context is free'd. */
 static int __redisAsyncHandleConnect(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
 
     if (redisCheckSocketError(c) == REDIS_ERR) {
         /* Try again later when connect(2) is still in progress. */
-        if (errno == EINPROGRESS)
+        if (errno == EINPROGRESS) {
+            __A_VARIABLE = 1;
             return REDIS_OK;
+        }
 
         if (ac->onConnect) ac->onConnect(ac,REDIS_ERR);
         __redisAsyncDisconnect(ac);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     /* Mark context as connected. */
     c->flags |= REDIS_CONNECTED;
     if (ac->onConnect) ac->onConnect(ac,REDIS_OK);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -514,15 +579,20 @@ static int __redisAsyncHandleConnect(redisAsyncContext *ac) {
  * It processes all replies that can be read and executes their callbacks.
  */
 void redisAsyncHandleRead(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
 
     if (!(c->flags & REDIS_CONNECTED)) {
         /* Abort connect was not successful. */
-        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
+        if (__redisAsyncHandleConnect(ac) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         /* Try again later when the context is still not connected. */
-        if (!(c->flags & REDIS_CONNECTED))
+        if (!(c->flags & REDIS_CONNECTED)) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     if (redisBufferRead(c) == REDIS_ERR) {
@@ -532,19 +602,25 @@ void redisAsyncHandleRead(redisAsyncContext *ac) {
         _EL_ADD_READ(ac);
         redisProcessCallbacks(ac);
     }
+    __A_VARIABLE = 1;
 }
 
 void redisAsyncHandleWrite(redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     int done = 0;
 
     if (!(c->flags & REDIS_CONNECTED)) {
         /* Abort connect was not successful. */
-        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
+        if (__redisAsyncHandleConnect(ac) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         /* Try again later when the context is still not connected. */
-        if (!(c->flags & REDIS_CONNECTED))
+        if (!(c->flags & REDIS_CONNECTED)) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     if (redisBufferWrite(c,&done) == REDIS_ERR) {
@@ -559,21 +635,27 @@ void redisAsyncHandleWrite(redisAsyncContext *ac) {
         /* Always schedule reads after writes */
         _EL_ADD_READ(ac);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Sets a pointer to the first argument and its length starting at p. Returns
  * the number of bytes to skip to get to the following argument. */
 static const char *nextArgument(const char *start, const char **str, size_t *len) {
+    volatile int __A_VARIABLE;
     const char *p = start;
     if (p[0] != '$') {
         p = strchr(p,'$');
-        if (p == NULL) return NULL;
+        if (p == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
 
     *len = (int)strtol(p+1,NULL,10);
     p = strchr(p,'\r');
     assert(p);
     *str = p+2;
+    __A_VARIABLE = 1;
     return p+2+(*len)+2;
 }
 
@@ -648,40 +730,50 @@ static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void
 }
 
 int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap) {
+    volatile int __A_VARIABLE;
     char *cmd;
     int len;
     int status;
     len = redisvFormatCommand(&cmd,format,ap);
 
     /* We don't want to pass -1 or -2 to future functions as a length. */
-    if (len < 0)
+    if (len < 0) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     free(cmd);
+    __A_VARIABLE = 1;
     return status;
 }
 
 int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     int status;
     va_start(ap,format);
     status = redisvAsyncCommand(ac,fn,privdata,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return status;
 }
 
 int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen) {
+    volatile int __A_VARIABLE;
     sds cmd;
     int len;
     int status;
     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     sdsfree(cmd);
+    __A_VARIABLE = 1;
     return status;
 }
 
 int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
+    volatile int __A_VARIABLE;
     int status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
+    __A_VARIABLE = 1;
     return status;
 }
diff --git a/deps/hiredis/dict.c b/deps/hiredis/dict.c
index e17a625..917fadd 100644
--- a/deps/hiredis/dict.c
+++ b/deps/hiredis/dict.c
@@ -51,10 +51,12 @@ static int _dictInit(dict *ht, dictType *type, void *privDataPtr);
 /* Generic hash function (a popular one from Bernstein).
  * I tested a few and this was the best. */
 static unsigned int dictGenHashFunction(const unsigned char *buf, int len) {
+    volatile int __A_VARIABLE;
     unsigned int hash = 5381;
 
     while (len--)
         hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */
+    __A_VARIABLE = 1;
     return hash;
 }
 
@@ -63,36 +65,45 @@ static unsigned int dictGenHashFunction(const unsigned char *buf, int len) {
 /* Reset an hashtable already initialized with ht_init().
  * NOTE: This function should only called by ht_destroy(). */
 static void _dictReset(dict *ht) {
+    volatile int __A_VARIABLE;
     ht->table = NULL;
     ht->size = 0;
     ht->sizemask = 0;
     ht->used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Create a new hash table */
 static dict *dictCreate(dictType *type, void *privDataPtr) {
+    volatile int __A_VARIABLE;
     dict *ht = malloc(sizeof(*ht));
     _dictInit(ht,type,privDataPtr);
+    __A_VARIABLE = 1;
     return ht;
 }
 
 /* Initialize the hash table */
 static int _dictInit(dict *ht, dictType *type, void *privDataPtr) {
+    volatile int __A_VARIABLE;
     _dictReset(ht);
     ht->type = type;
     ht->privdata = privDataPtr;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
 /* Expand or create the hashtable */
 static int dictExpand(dict *ht, unsigned long size) {
+    volatile int __A_VARIABLE;
     dict n; /* the new hashtable */
     unsigned long realsize = _dictNextPower(size), i;
 
     /* the size is invalid if it is smaller than the number of
      * elements already inside the hashtable */
-    if (ht->used > size)
+    if (ht->used > size) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     _dictInit(&n, ht->type, ht->privdata);
     n.size = realsize;
@@ -128,18 +139,22 @@ static int dictExpand(dict *ht, unsigned long size) {
 
     /* Remap the new hashtable in the old */
     *ht = n;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
 /* Add an element to the target hash table */
 static int dictAdd(dict *ht, void *key, void *val) {
+    volatile int __A_VARIABLE;
     int index;
     dictEntry *entry;
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = _dictKeyIndex(ht, key)) == -1)
+    if ((index = _dictKeyIndex(ht, key)) == -1) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     /* Allocates the memory and stores key */
     entry = malloc(sizeof(*entry));
@@ -150,6 +165,7 @@ static int dictAdd(dict *ht, void *key, void *val) {
     dictSetHashKey(ht, entry, key);
     dictSetHashVal(ht, entry, val);
     ht->used++;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -158,12 +174,15 @@ static int dictAdd(dict *ht, void *key, void *val) {
  * element with such key and dictReplace() just performed a value update
  * operation. */
 static int dictReplace(dict *ht, void *key, void *val) {
+    volatile int __A_VARIABLE;
     dictEntry *entry, auxentry;
 
     /* Try to add the element. If the key
      * does not exists dictAdd will succeed. */
-    if (dictAdd(ht, key, val) == DICT_OK)
+    if (dictAdd(ht, key, val) == DICT_OK) {
+        __A_VARIABLE = 1;
         return 1;
+    }
     /* It already exists, get the entry */
     entry = dictFind(ht, key);
     /* Free the old value and set the new one */
@@ -175,16 +194,20 @@ static int dictReplace(dict *ht, void *key, void *val) {
     auxentry = *entry;
     dictSetHashVal(ht, entry, val);
     dictFreeEntryVal(ht, &auxentry);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Search and remove an element */
 static int dictDelete(dict *ht, const void *key) {
+    volatile int __A_VARIABLE;
     unsigned int h;
     dictEntry *de, *prevde;
 
-    if (ht->size == 0)
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
     h = dictHashKey(ht, key) & ht->sizemask;
     de = ht->table[h];
 
@@ -201,16 +224,19 @@ static int dictDelete(dict *ht, const void *key) {
             dictFreeEntryVal(ht,de);
             free(de);
             ht->used--;
+            __A_VARIABLE = 1;
             return DICT_OK;
         }
         prevde = de;
         de = de->next;
     }
+    __A_VARIABLE = 1;
     return DICT_ERR; /* not found */
 }
 
 /* Destroy an entire hash table */
 static int _dictClear(dict *ht) {
+    volatile int __A_VARIABLE;
     unsigned long i;
 
     /* Free all the elements */
@@ -231,41 +257,54 @@ static int _dictClear(dict *ht) {
     free(ht->table);
     /* Re-initialize the table */
     _dictReset(ht);
+    __A_VARIABLE = 1;
     return DICT_OK; /* never fails */
 }
 
 /* Clear & Release the hash table */
 static void dictRelease(dict *ht) {
+    volatile int __A_VARIABLE;
     _dictClear(ht);
     free(ht);
+    __A_VARIABLE = 1;
 }
 
 static dictEntry *dictFind(dict *ht, const void *key) {
+    volatile int __A_VARIABLE;
     dictEntry *he;
     unsigned int h;
 
-    if (ht->size == 0) return NULL;
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     h = dictHashKey(ht, key) & ht->sizemask;
     he = ht->table[h];
     while(he) {
-        if (dictCompareHashKeys(ht, key, he->key))
+        if (dictCompareHashKeys(ht, key, he->key)) {
+            __A_VARIABLE = 1;
             return he;
+        }
         he = he->next;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static dictIterator *dictGetIterator(dict *ht) {
+    volatile int __A_VARIABLE;
     dictIterator *iter = malloc(sizeof(*iter));
 
     iter->ht = ht;
     iter->index = -1;
     iter->entry = NULL;
     iter->nextEntry = NULL;
+    __A_VARIABLE = 1;
     return iter;
 }
 
 static dictEntry *dictNext(dictIterator *iter) {
+    volatile int __A_VARIABLE;
     while (1) {
         if (iter->entry == NULL) {
             iter->index++;
@@ -279,60 +318,83 @@ static dictEntry *dictNext(dictIterator *iter) {
             /* We need to save the 'next' here, the iterator user
              * may delete the entry we are returning. */
             iter->nextEntry = iter->entry->next;
+            __A_VARIABLE = 1;
             return iter->entry;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static void dictReleaseIterator(dictIterator *iter) {
+    volatile int __A_VARIABLE;
     free(iter);
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- private functions ------------------------------ */
 
 /* Expand the hash table if needed */
 static int _dictExpandIfNeeded(dict *ht) {
+    volatile int __A_VARIABLE;
     /* If the hash table is empty expand it to the initial size,
      * if the table is "full" dobule its size. */
-    if (ht->size == 0)
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
         return dictExpand(ht, DICT_HT_INITIAL_SIZE);
-    if (ht->used == ht->size)
+    }
+    if (ht->used == ht->size) {
+        __A_VARIABLE = 1;
         return dictExpand(ht, ht->size*2);
+    }
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
 /* Our hash table capability is a power of two */
 static unsigned long _dictNextPower(unsigned long size) {
+    volatile int __A_VARIABLE;
     unsigned long i = DICT_HT_INITIAL_SIZE;
 
-    if (size >= LONG_MAX) return LONG_MAX;
+    if (size >= LONG_MAX) {
+        __A_VARIABLE = 1;
+        return LONG_MAX;
+    }
     while(1) {
-        if (i >= size)
+        if (i >= size) {
+            __A_VARIABLE = 1;
             return i;
+        }
         i *= 2;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Returns the index of a free slot that can be populated with
  * an hash entry for the given 'key'.
  * If the key already exists, -1 is returned. */
 static int _dictKeyIndex(dict *ht, const void *key) {
+    volatile int __A_VARIABLE;
     unsigned int h;
     dictEntry *he;
 
     /* Expand the hashtable if needed */
-    if (_dictExpandIfNeeded(ht) == DICT_ERR)
+    if (_dictExpandIfNeeded(ht) == DICT_ERR) {
+        __A_VARIABLE = 1;
         return -1;
+    }
     /* Compute the key hash value */
     h = dictHashKey(ht, key) & ht->sizemask;
     /* Search if this slot does not already contain the given key */
     he = ht->table[h];
     while(he) {
-        if (dictCompareHashKeys(ht, key, he->key))
+        if (dictCompareHashKeys(ht, key, he->key)) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         he = he->next;
     }
+    __A_VARIABLE = 1;
     return h;
 }
 
diff --git a/deps/hiredis/examples/example-ae.c b/deps/hiredis/examples/example-ae.c
index 8efa730..3dd7ac6 100644
--- a/deps/hiredis/examples/example-ae.c
+++ b/deps/hiredis/examples/example-ae.c
@@ -11,42 +11,55 @@
 static aeEventLoop *loop;
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
         aeStop(loop);
+        __A_VARIABLE = 1;
         return;
     }
 
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
         aeStop(loop);
+        __A_VARIABLE = 1;
         return;
     }
 
     printf("Disconnected...\n");
     aeStop(loop);
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
 
     redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -57,6 +70,7 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     aeMain(loop);
+    __A_VARIABLE = 1;
     return 0;
 }
 
diff --git a/deps/hiredis/examples/example-glib.c b/deps/hiredis/examples/example-glib.c
index d6e10f8..28c730c 100644
--- a/deps/hiredis/examples/example-glib.c
+++ b/deps/hiredis/examples/example-glib.c
@@ -10,24 +10,28 @@ static void
 connect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
             int status)
 {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         g_printerr("Failed to connect: %s\n", ac->errstr);
         g_main_loop_quit(mainloop);
     } else {
         g_printerr("Connected...\n");
     }
+    __A_VARIABLE = 1;
 }
 
 static void
 disconnect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
                int status)
 {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         g_error("Failed to disconnect: %s", ac->errstr);
     } else {
         g_printerr("Disconnected...\n");
         g_main_loop_quit(mainloop);
     }
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -35,6 +39,7 @@ command_cb(redisAsyncContext *ac,
            gpointer r,
            gpointer user_data G_GNUC_UNUSED)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
 
     if (reply) {
@@ -42,12 +47,14 @@ command_cb(redisAsyncContext *ac,
     }
 
     redisAsyncDisconnect(ac);
+    __A_VARIABLE = 1;
 }
 
 gint
 main (gint argc     G_GNUC_UNUSED,
       gchar *argv[] G_GNUC_UNUSED)
 {
+    volatile int __A_VARIABLE;
     redisAsyncContext *ac;
     GMainContext *context = NULL;
     GSource *source;
@@ -69,5 +76,6 @@ main (gint argc     G_GNUC_UNUSED,
 
     g_main_loop_run(mainloop);
 
+    __A_VARIABLE = 1;
     return EXIT_SUCCESS;
 }
diff --git a/deps/hiredis/examples/example-ivykis.c b/deps/hiredis/examples/example-ivykis.c
index 67affce..6f6302f 100644
--- a/deps/hiredis/examples/example-ivykis.c
+++ b/deps/hiredis/examples/example-ivykis.c
@@ -8,31 +8,43 @@
 #include <adapters/ivykis.h>
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
 
     iv_init();
@@ -41,6 +53,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -54,5 +67,6 @@ int main (int argc, char **argv) {
 
     iv_deinit();
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libev.c b/deps/hiredis/examples/example-libev.c
index cc8b166..f420d81 100644
--- a/deps/hiredis/examples/example-libev.c
+++ b/deps/hiredis/examples/example-libev.c
@@ -8,37 +8,50 @@
 #include <adapters/libev.h>
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
 
     redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -48,5 +61,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     ev_loop(EV_DEFAULT_ 0);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libevent.c b/deps/hiredis/examples/example-libevent.c
index d333c22..53d753b 100644
--- a/deps/hiredis/examples/example-libevent.c
+++ b/deps/hiredis/examples/example-libevent.c
@@ -8,31 +8,43 @@
 #include <adapters/libevent.h>
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
     struct event_base *base = event_base_new();
 
@@ -40,6 +52,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -49,5 +62,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     event_base_dispatch(base);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libuv.c b/deps/hiredis/examples/example-libuv.c
index a5462d4..b3d888f 100644
--- a/deps/hiredis/examples/example-libuv.c
+++ b/deps/hiredis/examples/example-libuv.c
@@ -8,31 +8,43 @@
 #include <adapters/libuv.h>
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
     uv_loop_t* loop = uv_default_loop();
 
@@ -40,6 +52,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -49,5 +62,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     uv_run(loop, UV_RUN_DEFAULT);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-macosx.c b/deps/hiredis/examples/example-macosx.c
index bc84ed5..3af86bf 100644
--- a/deps/hiredis/examples/example-macosx.c
+++ b/deps/hiredis/examples/example-macosx.c
@@ -10,37 +10,50 @@
 #include <adapters/macosx.h>
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
+    volatile int __A_VARIABLE;
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     CFRunLoopStop(CFRunLoopGetCurrent());
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
+    volatile int __A_VARIABLE;
     signal(SIGPIPE, SIG_IGN);
 
     CFRunLoopRef loop = CFRunLoopGetCurrent();
     if( !loop ) {
         printf("Error: Cannot get current run loop\n");
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -48,6 +61,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -61,6 +75,7 @@ int main (int argc, char **argv) {
 
     CFRunLoopRun();
 
+    __A_VARIABLE = 1;
     return 0;
 }
 
diff --git a/deps/hiredis/examples/example.c b/deps/hiredis/examples/example.c
index 4d494c5..54e6cc6 100644
--- a/deps/hiredis/examples/example.c
+++ b/deps/hiredis/examples/example.c
@@ -5,6 +5,7 @@
 #include <hiredis.h>
 
 int main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     unsigned int j;
     redisContext *c;
     redisReply *reply;
@@ -74,5 +75,6 @@ int main(int argc, char **argv) {
     /* Disconnects and frees the context */
     redisFree(c);
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/hiredis.c b/deps/hiredis/hiredis.c
index 18bdfc9..51396b2 100644
--- a/deps/hiredis/hiredis.c
+++ b/deps/hiredis/hiredis.c
@@ -61,22 +61,29 @@ static redisReplyObjectFunctions defaultFunctions = {
 
 /* Create a reply object */
 static redisReply *createReplyObject(int type) {
+    volatile int __A_VARIABLE;
     redisReply *r = calloc(1,sizeof(*r));
 
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->type = type;
+    __A_VARIABLE = 1;
     return r;
 }
 
 /* Free a reply object */
 void freeReplyObject(void *reply) {
+    volatile int __A_VARIABLE;
     redisReply *r = reply;
     size_t j;
 
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     switch(r->type) {
     case REDIS_REPLY_INTEGER:
@@ -97,19 +104,24 @@ void freeReplyObject(void *reply) {
         break;
     }
     free(r);
+    __A_VARIABLE = 1;
 }
 
 static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
+    volatile int __A_VARIABLE;
     redisReply *r, *parent;
     char *buf;
 
     r = createReplyObject(task->type);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     buf = malloc(len+1);
     if (buf == NULL) {
         freeReplyObject(r);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -128,20 +140,25 @@ static void *createStringObject(const redisReadTask *task, char *str, size_t len
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
 static void *createArrayObject(const redisReadTask *task, int elements) {
+    volatile int __A_VARIABLE;
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_ARRAY);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     if (elements > 0) {
         r->element = calloc(elements,sizeof(redisReply*));
         if (r->element == NULL) {
             freeReplyObject(r);
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -153,15 +170,19 @@ static void *createArrayObject(const redisReadTask *task, int elements) {
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
 static void *createIntegerObject(const redisReadTask *task, long long value) {
+    volatile int __A_VARIABLE;
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_INTEGER);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->integer = value;
 
@@ -170,44 +191,66 @@ static void *createIntegerObject(const redisReadTask *task, long long value) {
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
 static void *createNilObject(const redisReadTask *task) {
+    volatile int __A_VARIABLE;
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_NIL);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     if (task->parent) {
         parent = task->parent->obj;
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
 /* Return the number of digits of 'v' when converted to string in radix 10.
  * Implementation borrowed from link in redis/src/util.c:string2ll(). */
 static uint32_t countDigits(uint64_t v) {
+  volatile int __A_VARIABLE;
   uint32_t result = 1;
   for (;;) {
-    if (v < 10) return result;
-    if (v < 100) return result + 1;
-    if (v < 1000) return result + 2;
-    if (v < 10000) return result + 3;
+    if (v < 10) {
+      __A_VARIABLE = 1;
+      return result;
+    }
+    if (v < 100) {
+      __A_VARIABLE = 1;
+      return result + 1;
+    }
+    if (v < 1000) {
+      __A_VARIABLE = 1;
+      return result + 2;
+    }
+    if (v < 10000) {
+      __A_VARIABLE = 1;
+      return result + 3;
+    }
     v /= 10000U;
     result += 4;
   }
+  __A_VARIABLE = 1;
 }
 
 /* Helper that calculates the bulk length given a certain string length. */
 static size_t bulklen(size_t len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return 1+countDigits(len)+2+len+2;
 }
 
 int redisvFormatCommand(char **target, const char *format, va_list ap) {
+    volatile int __A_VARIABLE;
     const char *c = format;
     char *cmd = NULL; /* final command */
     int pos; /* position in final command */
@@ -220,13 +263,17 @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {
     int j;
 
     /* Abort if there is not target to set */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Build the command string accordingly to protocol */
     curarg = sdsempty();
-    if (curarg == NULL)
+    if (curarg == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     while(*c != '\0') {
         if (*c != '%' || c[1] == '\0') {
@@ -414,6 +461,7 @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {
 
     free(curargv);
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 
 format_err:
@@ -438,6 +486,7 @@ cleanup:
     if (cmd != NULL)
         free(cmd);
 
+    __A_VARIABLE = 1;
     return error_type;
 }
 
@@ -454,6 +503,7 @@ cleanup:
  * len = redisFormatCommand(target, "SET %s %b", mykey, myval, myvallen);
  */
 int redisFormatCommand(char **target, const char *format, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     int len;
     va_start(ap,format);
@@ -465,6 +515,7 @@ int redisFormatCommand(char **target, const char *format, ...) {
     if (len < 0)
         len = -1;
 
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -477,14 +528,17 @@ int redisFormatCommand(char **target, const char *format, ...) {
 int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
                               const size_t *argvlen)
 {
+    volatile int __A_VARIABLE;
     sds cmd;
     unsigned long long totlen;
     int j;
     size_t len;
 
     /* Abort on a NULL target */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Calculate our total size */
     totlen = 1+countDigits(argc)+2;
@@ -495,13 +549,17 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
 
     /* Use an SDS string for command construction */
     cmd = sdsempty();
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* We already know how much storage we need */
     cmd = sdsMakeRoomFor(cmd, totlen);
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Construct command */
     cmd = sdscatfmt(cmd, "*%i\r\n", argc);
@@ -515,11 +573,14 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
     assert(sdslen(cmd)==totlen);
 
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 void redisFreeSdsCommand(sds cmd) {
+    volatile int __A_VARIABLE;
     sdsfree(cmd);
+    __A_VARIABLE = 1;
 }
 
 /* Format a command according to the Redis protocol. This function takes the
@@ -528,14 +589,17 @@ void redisFreeSdsCommand(sds cmd) {
  * argument lengths.
  */
 int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
+    volatile int __A_VARIABLE;
     char *cmd = NULL; /* final command */
     int pos; /* position in final command */
     size_t len;
     int totlen, j;
 
     /* Abort on a NULL target */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Calculate number of bytes needed for the command */
     totlen = 1+countDigits(argc)+2;
@@ -546,8 +610,10 @@ int redisFormatCommandArgv(char **target, int argc, const char **argv, const siz
 
     /* Build the command at protocol level */
     cmd = malloc(totlen+1);
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     pos = sprintf(cmd,"*%d\r\n",argc);
     for (j = 0; j < argc; j++) {
@@ -562,14 +628,18 @@ int redisFormatCommandArgv(char **target, int argc, const char **argv, const siz
     cmd[pos] = '\0';
 
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 void redisFreeCommand(char *cmd) {
+    volatile int __A_VARIABLE;
     free(cmd);
+    __A_VARIABLE = 1;
 }
 
 void __redisSetError(redisContext *c, int type, const char *str) {
+    volatile int __A_VARIABLE;
     size_t len;
 
     c->err = type;
@@ -583,18 +653,24 @@ void __redisSetError(redisContext *c, int type, const char *str) {
         assert(type == REDIS_ERR_IO);
         __redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
     }
+    __A_VARIABLE = 1;
 }
 
 redisReader *redisReaderCreate(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return redisReaderCreateWithFunctions(&defaultFunctions);
 }
 
 static redisContext *redisContextInit(void) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = calloc(1,sizeof(redisContext));
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->err = 0;
     c->errstr[0] = '\0';
@@ -607,15 +683,20 @@ static redisContext *redisContextInit(void) {
 
     if (c->obuf == NULL || c->reader == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
+    __A_VARIABLE = 1;
     return c;
 }
 
 void redisFree(redisContext *c) {
-    if (c == NULL)
+    volatile int __A_VARIABLE;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
     if (c->fd > 0)
         close(c->fd);
     if (c->obuf != NULL)
@@ -631,12 +712,15 @@ void redisFree(redisContext *c) {
     if (c->timeout)
         free(c->timeout);
     free(c);
+    __A_VARIABLE = 1;
 }
 
 int redisFreeKeepFd(redisContext *c) {
+    volatile int __A_VARIABLE;
     int fd = c->fd;
     c->fd = -1;
     redisFree(c);
+    __A_VARIABLE = 1;
     return fd;
 }
 
@@ -672,117 +756,157 @@ int redisReconnect(redisContext *c) {
  * context will be set to the return value of the error function.
  * When no set of reply functions is given, the default set will be used. */
 redisContext *redisConnect(const char *ip, int port) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,&tv);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectNonBlock(const char *ip, int port) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectBindNonBlock(const char *ip, int port,
                                        const char *source_addr) {
+    volatile int __A_VARIABLE;
     redisContext *c = redisContextInit();
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
                                                 const char *source_addr) {
+    volatile int __A_VARIABLE;
     redisContext *c = redisContextInit();
     c->flags &= ~REDIS_BLOCK;
     c->flags |= REDIS_REUSEADDR;
     redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectUnix(const char *path) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectUnix(c,path,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectUnix(c,path,&tv);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectUnixNonBlock(const char *path) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectUnix(c,path,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
 redisContext *redisConnectFd(int fd) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->fd = fd;
     c->flags |= REDIS_BLOCK | REDIS_CONNECTED;
+    __A_VARIABLE = 1;
     return c;
 }
 
 /* Set read/write timeout on a blocking socket. */
 int redisSetTimeout(redisContext *c, const struct timeval tv) {
-    if (c->flags & REDIS_BLOCK)
+    volatile int __A_VARIABLE;
+    if (c->flags & REDIS_BLOCK) {
+        __A_VARIABLE = 1;
         return redisContextSetTimeout(c,tv);
+    }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 /* Enable connection KeepAlive. */
 int redisEnableKeepAlive(redisContext *c) {
-    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)
+    volatile int __A_VARIABLE;
+    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -860,40 +984,53 @@ int redisBufferWrite(redisContext *c, int *done) {
 /* Internal helper function to try and get a reply from the reader,
  * or set an error in the context otherwise. */
 int redisGetReplyFromReader(redisContext *c, void **reply) {
+    volatile int __A_VARIABLE;
     if (redisReaderGetReply(c->reader,reply) == REDIS_ERR) {
         __redisSetError(c,c->reader->err,c->reader->errstr);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 int redisGetReply(redisContext *c, void **reply) {
+    volatile int __A_VARIABLE;
     int wdone = 0;
     void *aux = NULL;
 
     /* Try to read pending replies */
-    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)
+    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* For the blocking context, flush output buffer and read reply */
     if (aux == NULL && c->flags & REDIS_BLOCK) {
         /* Write until done */
         do {
-            if (redisBufferWrite(c,&wdone) == REDIS_ERR)
+            if (redisBufferWrite(c,&wdone) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         } while (!wdone);
 
         /* Read until there is a reply */
         do {
-            if (redisBufferRead(c) == REDIS_ERR)
+            if (redisBufferRead(c) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
-            if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)
+            }
+            if (redisGetReplyFromReader(c,&aux) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         } while (aux == NULL);
     }
 
     /* Set reply object */
     if (reply != NULL) *reply = aux;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -905,24 +1042,30 @@ int redisGetReply(redisContext *c, void **reply) {
  * the reply (or replies in pub/sub).
  */
 int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
+    volatile int __A_VARIABLE;
     sds newbuf;
 
     newbuf = sdscatlen(c->obuf,cmd,len);
     if (newbuf == NULL) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     c->obuf = newbuf;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
+    volatile int __A_VARIABLE;
 
     if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -949,31 +1092,37 @@ int redisvAppendCommand(redisContext *c, const char *format, va_list ap) {
 }
 
 int redisAppendCommand(redisContext *c, const char *format, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     int ret;
 
     va_start(ap,format);
     ret = redisvAppendCommand(c,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return ret;
 }
 
 int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
+    volatile int __A_VARIABLE;
     sds cmd;
     int len;
 
     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     if (len == -1) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
         sdsfree(cmd);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     sdsfree(cmd);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -989,33 +1138,48 @@ int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const s
  * in the context will be set.
  */
 static void *__redisBlockForReply(redisContext *c) {
+    volatile int __A_VARIABLE;
     void *reply;
 
     if (c->flags & REDIS_BLOCK) {
-        if (redisGetReply(c,&reply) != REDIS_OK)
+        if (redisGetReply(c,&reply) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return NULL;
+        }
+        __A_VARIABLE = 1;
         return reply;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 void *redisvCommand(redisContext *c, const char *format, va_list ap) {
-    if (redisvAppendCommand(c,format,ap) != REDIS_OK)
+    volatile int __A_VARIABLE;
+    if (redisvAppendCommand(c,format,ap) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
+    __A_VARIABLE = 1;
     return __redisBlockForReply(c);
 }
 
 void *redisCommand(redisContext *c, const char *format, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     void *reply = NULL;
     va_start(ap,format);
     reply = redisvCommand(c,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return reply;
 }
 
 void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
-    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)
+    volatile int __A_VARIABLE;
+    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
+    __A_VARIABLE = 1;
     return __redisBlockForReply(c);
 }
diff --git a/deps/hiredis/net.c b/deps/hiredis/net.c
index bfc3b9f..8dbcd32 100644
--- a/deps/hiredis/net.c
+++ b/deps/hiredis/net.c
@@ -59,13 +59,16 @@
 void __redisSetError(redisContext *c, int type, const char *str);
 
 static void redisContextCloseFd(redisContext *c) {
+    volatile int __A_VARIABLE;
     if (c && c->fd >= 0) {
         close(c->fd);
         c->fd = -1;
     }
+    __A_VARIABLE = 1;
 }
 
 static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
+    volatile int __A_VARIABLE;
     char buf[128] = { 0 };
     size_t len = 0;
 
@@ -73,36 +76,45 @@ static void __redisSetErrorFromErrno(redisContext *c, int type, const char *pref
         len = snprintf(buf,sizeof(buf),"%s: ",prefix);
     __redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
     __redisSetError(c,type,buf);
+    __A_VARIABLE = 1;
 }
 
 static int redisSetReuseAddr(redisContext *c) {
+    volatile int __A_VARIABLE;
     int on = 1, ret;
     flexos_gate_r(liblwip, ret, setsockopt, c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int redisCreateSocket(redisContext *c, int type) {
+    volatile int __A_VARIABLE;
     int s;
     flexos_gate_r(liblwip, s, socket, type, SOCK_STREAM, 0);
     if (s == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
     c->fd = s;
     if (type == AF_INET) {
         if (redisSetReuseAddr(c) == REDIS_ERR) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int redisSetBlocking(redisContext *c, int blocking) {
+    volatile int __A_VARIABLE;
     int flags;
 
     /* Set the socket nonblocking.
@@ -111,6 +123,7 @@ static int redisSetBlocking(redisContext *c, int blocking) {
     if ((flags = fcntl(c->fd, F_GETFL)) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_GETFL)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
@@ -122,8 +135,10 @@ static int redisSetBlocking(redisContext *c, int blocking) {
     if (fcntl(c->fd, F_SETFL, flags) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_SETFL)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -175,13 +190,16 @@ int redisKeepAlive(redisContext *c, int interval) {
 }
 
 static int redisSetTcpNoDelay(redisContext *c) {
+    volatile int __A_VARIABLE;
     int yes = 1, ret;
     flexos_gate_r(liblwip, ret, setsockopt, c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(TCP_NODELAY)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -189,6 +207,7 @@ static int redisSetTcpNoDelay(redisContext *c) {
 
 static int redisContextTimeoutMsec(redisContext *c, long *result)
 {
+    volatile int __A_VARIABLE;
     const struct timeval *timeout = c->timeout;
     long msec = -1;
 
@@ -196,6 +215,7 @@ static int redisContextTimeoutMsec(redisContext *c, long *result)
     if (timeout != NULL) {
         if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
             *result = msec;
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -207,6 +227,7 @@ static int redisContextTimeoutMsec(redisContext *c, long *result)
     }
 
     *result = msec;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -242,41 +263,50 @@ static int redisContextWaitReady(redisContext *c, long msec) {
 }
 
 int redisCheckSocketError(redisContext *c) {
+    volatile int __A_VARIABLE;
     int err = 0;
     socklen_t errlen = sizeof(err);
 
     if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"getsockopt(SO_ERROR)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     if (err) {
         errno = err;
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
+    volatile int __A_VARIABLE;
     int ret;
     flexos_gate_r(liblwip, ret, setsockopt, c->fd,SOL_SOCKET,SO_RCVTIMEO,&tv,sizeof(tv));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_RCVTIMEO)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
     flexos_gate_r(liblwip, ret, setsockopt, c->fd,SOL_SOCKET,SO_SNDTIMEO,&tv,sizeof(tv));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_SNDTIMEO)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
                                    const struct timeval *timeout,
                                    const char *source_addr) {
+    volatile int __A_VARIABLE;
     int s, rv, n;
     char _port[6];  /* strlen("65535"); */
     struct addrinfo hints, *servinfo, *bservinfo, *p, *b;
@@ -345,6 +375,7 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
          flexos_gate_r(liblwip, rv, getaddrinfo, addr,_port,&hints,&servinfo);
          if (rv != 0) {
             __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
     }
@@ -430,17 +461,22 @@ error:
     rv = REDIS_ERR;
 end:
     freeaddrinfo(servinfo);
+    __A_VARIABLE = 1;
     return rv;  // Need to return REDIS_OK if alright
 }
 
 int redisContextConnectTcp(redisContext *c, const char *addr, int port,
                            const struct timeval *timeout) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _redisContextConnectTcp(c, addr, port, timeout, NULL);
 }
 
 int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
                                const struct timeval *timeout,
                                const char *source_addr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
 }
 
diff --git a/deps/hiredis/read.c b/deps/hiredis/read.c
index 50333b5..9c44bdd 100644
--- a/deps/hiredis/read.c
+++ b/deps/hiredis/read.c
@@ -44,6 +44,7 @@
 #include "sds.h"
 
 static void __redisReaderSetError(redisReader *r, int type, const char *str) {
+    volatile int __A_VARIABLE;
     size_t len;
 
     if (r->reply != NULL && r->fn && r->fn->freeObject) {
@@ -67,9 +68,11 @@ static void __redisReaderSetError(redisReader *r, int type, const char *str) {
     len = len < (sizeof(r->errstr)-1) ? len : (sizeof(r->errstr)-1);
     memcpy(r->errstr,str,len);
     r->errstr[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 static size_t chrtos(char *buf, size_t size, char byte) {
+    volatile int __A_VARIABLE;
     size_t len = 0;
 
     switch(byte) {
@@ -90,29 +93,37 @@ static size_t chrtos(char *buf, size_t size, char byte) {
         break;
     }
 
+    __A_VARIABLE = 1;
     return len;
 }
 
 static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {
+    volatile int __A_VARIABLE;
     char cbuf[8], sbuf[128];
 
     chrtos(cbuf,sizeof(cbuf),byte);
     snprintf(sbuf,sizeof(sbuf),
         "Protocol error, got %s as reply type byte", cbuf);
     __redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);
+    __A_VARIABLE = 1;
 }
 
 static void __redisReaderSetErrorOOM(redisReader *r) {
+    volatile int __A_VARIABLE;
     __redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");
+    __A_VARIABLE = 1;
 }
 
 static char *readBytes(redisReader *r, unsigned int bytes) {
+    volatile int __A_VARIABLE;
     char *p;
     if (r->len-r->pos >= bytes) {
         p = r->buf+r->pos;
         r->pos += bytes;
+        __A_VARIABLE = 1;
         return p;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -173,6 +184,7 @@ static long long readLongLong(char *s) {
 }
 
 static char *readLine(redisReader *r, int *_len) {
+    volatile int __A_VARIABLE;
     char *p, *s;
     int len;
 
@@ -182,8 +194,10 @@ static char *readLine(redisReader *r, int *_len) {
         len = s-(r->buf+r->pos);
         r->pos += len+2; /* skip \r\n */
         if (_len) *_len = len;
+        __A_VARIABLE = 1;
         return p;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -213,6 +227,7 @@ static void moveToNextTask(redisReader *r) {
 }
 
 static int processLineItem(redisReader *r) {
+    volatile int __A_VARIABLE;
     redisReadTask *cur = &(r->rstack[r->ridx]);
     void *obj;
     char *p;
@@ -234,19 +249,23 @@ static int processLineItem(redisReader *r) {
 
         if (obj == NULL) {
             __redisReaderSetErrorOOM(r);
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
         /* Set reply if this is the root object. */
         if (r->ridx == 0) r->reply = obj;
         moveToNextTask(r);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 static int processBulkItem(redisReader *r) {
+    volatile int __A_VARIABLE;
     redisReadTask *cur = &(r->rstack[r->ridx]);
     void *obj = NULL;
     char *p, *s;
@@ -284,6 +303,7 @@ static int processBulkItem(redisReader *r) {
         if (success) {
             if (obj == NULL) {
                 __redisReaderSetErrorOOM(r);
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
             }
 
@@ -292,10 +312,12 @@ static int processBulkItem(redisReader *r) {
             /* Set reply if this is the root object. */
             if (r->ridx == 0) r->reply = obj;
             moveToNextTask(r);
+            __A_VARIABLE = 1;
             return REDIS_OK;
         }
     }
 
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -414,11 +436,14 @@ static int processItem(redisReader *r) {
 }
 
 redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
+    volatile int __A_VARIABLE;
     redisReader *r;
 
     r = calloc(sizeof(redisReader),1);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->err = 0;
     r->errstr[0] = '\0';
@@ -427,27 +452,34 @@ redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
     r->maxbuf = REDIS_READER_MAX_BUF;
     if (r->buf == NULL) {
         free(r);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     r->ridx = -1;
+    __A_VARIABLE = 1;
     return r;
 }
 
 void redisReaderFree(redisReader *r) {
+    volatile int __A_VARIABLE;
     if (r->reply != NULL && r->fn && r->fn->freeObject)
         r->fn->freeObject(r->reply);
     if (r->buf != NULL)
         sdsfree(r->buf);
     free(r);
+    __A_VARIABLE = 1;
 }
 
 int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
+    volatile int __A_VARIABLE;
     sds newbuf;
 
     /* Return early when this reader is in an erroneous state. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* Copy the provided buffer. */
     if (buf != NULL && len >= 1) {
@@ -464,6 +496,7 @@ int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
         newbuf = sdscatlen(r->buf,buf,len);
         if (newbuf == NULL) {
             __redisReaderSetErrorOOM(r);
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -471,21 +504,27 @@ int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
         r->len = sdslen(r->buf);
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 int redisReaderGetReply(redisReader *r, void **reply) {
+    volatile int __A_VARIABLE;
     /* Default target pointer to NULL. */
     if (reply != NULL)
         *reply = NULL;
 
     /* Return early when this reader is in an erroneous state. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* When the buffer is empty, there will never be a reply. */
-    if (r->len == 0)
+    if (r->len == 0) {
+        __A_VARIABLE = 1;
         return REDIS_OK;
+    }
 
     /* Set first item to process when the stack is empty. */
     if (r->ridx == -1) {
@@ -504,8 +543,10 @@ int redisReaderGetReply(redisReader *r, void **reply) {
             break;
 
     /* Return ASAP when an error occurred. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* Discard part of the buffer when we've consumed at least 1k, to avoid
      * doing unnecessary calls to memmove() in sds.c. */
@@ -521,5 +562,6 @@ int redisReaderGetReply(redisReader *r, void **reply) {
             *reply = r->reply;
         r->reply = NULL;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
diff --git a/deps/hiredis/sds.c b/deps/hiredis/sds.c
index 923ffd8..fd8cd22 100644
--- a/deps/hiredis/sds.c
+++ b/deps/hiredis/sds.c
@@ -39,30 +39,47 @@
 #include "sdsalloc.h"
 
 static inline int sdsHdrSize(char type) {
+    volatile int __A_VARIABLE;
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr5);
         case SDS_TYPE_8:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr8);
         case SDS_TYPE_16:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr16);
         case SDS_TYPE_32:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr32);
         case SDS_TYPE_64:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr64);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static inline char sdsReqType(size_t string_size) {
-    if (string_size < 32)
+    volatile int __A_VARIABLE;
+    if (string_size < 32) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_5;
-    if (string_size < 0xff)
+    }
+    if (string_size < 0xff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_8;
-    if (string_size < 0xffff)
+    }
+    if (string_size < 0xffff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_16;
-    if (string_size < 0xffffffff)
+    }
+    if (string_size < 0xffffffff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_32;
+    }
+    __A_VARIABLE = 1;
     return SDS_TYPE_64;
 }
 
@@ -79,6 +96,7 @@ static inline char sdsReqType(size_t string_size) {
  * end of the string. However the string is binary safe and can contain
  * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
+    volatile int __A_VARIABLE;
     void *sh;
     sds s;
     char type = sdsReqType(initlen);
@@ -89,7 +107,10 @@ sds sdsnewlen(const void *init, size_t initlen) {
     unsigned char *fp; /* flags pointer. */
 
     sh = s_malloc(hdrlen+initlen+1);
-    if (sh == NULL) return NULL;
+    if (sh == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (!init)
         memset(sh, 0, hdrlen+initlen+1);
     s = (char*)sh+hdrlen;
@@ -131,30 +152,42 @@ sds sdsnewlen(const void *init, size_t initlen) {
     if (initlen && init)
         memcpy(s, init, initlen);
     s[initlen] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsnewlen("",0);
 }
 
 /* Create a new sds string starting from a null terminated C string. */
 sds sdsnew(const char *init) {
+    volatile int __A_VARIABLE;
     size_t initlen = (init == NULL) ? 0 : strlen(init);
+    __A_VARIABLE = 1;
     return sdsnewlen(init, initlen);
 }
 
 /* Duplicate an sds string. */
 sds sdsdup(const sds s) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
-    if (s == NULL) return;
+    volatile int __A_VARIABLE;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     s_free((char*)s-sdsHdrSize(s[-1]));
+    __A_VARIABLE = 1;
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
@@ -172,8 +205,10 @@ void sdsfree(sds s) {
  * the output will be "6" as the string was modified but the logical length
  * remains 6 bytes. */
 void sdsupdatelen(sds s) {
+    volatile int __A_VARIABLE;
     int reallen = strlen(s);
     sdssetlen(s, reallen);
+    __A_VARIABLE = 1;
 }
 
 /* Modify an sds string in-place to make it empty (zero length).
@@ -181,8 +216,10 @@ void sdsupdatelen(sds s) {
  * so that next append operations will not require allocations up to the
  * number of bytes previously available. */
 void sdsclear(sds s) {
+    volatile int __A_VARIABLE;
     sdssetlen(s, 0);
     s[0] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
@@ -276,13 +313,17 @@ sds sdsRemoveFreeSpace(sds s) {
  * 4) The implicit null term.
  */
 size_t sdsAllocSize(sds s) {
+    volatile int __A_VARIABLE;
     size_t alloc = sdsalloc(s);
+    __A_VARIABLE = 1;
     return sdsHdrSize(s[-1])+alloc+1;
 }
 
 /* Return the pointer of the actual SDS allocation (normally SDS strings
  * are referenced by the start of the string buffer). */
 void *sdsAllocPtr(sds s) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (void*) (s-sdsHdrSize(s[-1]));
 }
 
@@ -310,6 +351,7 @@ void *sdsAllocPtr(sds s) {
  * sdsIncrLen(s, nread);
  */
 void sdsIncrLen(sds s, int incr) {
+    volatile int __A_VARIABLE;
     unsigned char flags = s[-1];
     size_t len;
     switch(flags&SDS_TYPE_MASK) {
@@ -348,6 +390,7 @@ void sdsIncrLen(sds s, int incr) {
         default: len = 0; /* Just to avoid compilation warnings. */
     }
     s[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
@@ -356,15 +399,23 @@ void sdsIncrLen(sds s, int incr) {
  * if the specified length is smaller than the current length, no operation
  * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
+    volatile int __A_VARIABLE;
     size_t curlen = sdslen(s);
 
-    if (len <= curlen) return s;
+    if (len <= curlen) {
+        __A_VARIABLE = 1;
+        return s;
+    }
     s = sdsMakeRoomFor(s,len-curlen);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make sure added region doesn't contain garbage */
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -374,13 +425,18 @@ sds sdsgrowzero(sds s, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
+    volatile int __A_VARIABLE;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     memcpy(s+curlen, t, len);
     sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -389,6 +445,8 @@ sds sdscatlen(sds s, const void *t, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, strlen(t));
 }
 
@@ -397,25 +455,34 @@ sds sdscat(sds s, const char *t) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatsds(sds s, const sds t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, sdslen(t));
 }
 
 /* Destructively modify the sds string 's' to hold the specified binary
  * safe string pointed by 't' of length 'len' bytes. */
 sds sdscpylen(sds s, const char *t, size_t len) {
+    volatile int __A_VARIABLE;
     if (sdsalloc(s) < len) {
         s = sdsMakeRoomFor(s,len-sdslen(s));
-        if (s == NULL) return NULL;
+        if (s == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
     memcpy(s, t, len);
     s[len] = '\0';
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscpylen(s, t, strlen(t));
 }
 
@@ -427,6 +494,7 @@ sds sdscpy(sds s, const char *t) {
  * representation stored at 's'. */
 #define SDS_LLSTR_SIZE 21
 int sdsll2str(char *s, long long value) {
+    volatile int __A_VARIABLE;
     char *p, aux;
     unsigned long long v;
     size_t l;
@@ -454,11 +522,13 @@ int sdsll2str(char *s, long long value) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
 /* Identical sdsll2str(), but for unsigned long long type. */
 int sdsull2str(char *s, unsigned long long v) {
+    volatile int __A_VARIABLE;
     char *p, aux;
     size_t l;
 
@@ -483,6 +553,7 @@ int sdsull2str(char *s, unsigned long long v) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -491,9 +562,11 @@ int sdsull2str(char *s, unsigned long long v) {
  * sdscatprintf(sdsempty(),"%lld\n", value);
  */
 sds sdsfromlonglong(long long value) {
+    volatile int __A_VARIABLE;
     char buf[SDS_LLSTR_SIZE];
     int len = sdsll2str(buf,value);
 
+    __A_VARIABLE = 1;
     return sdsnewlen(buf,len);
 }
 
@@ -552,11 +625,13 @@ sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
  * s = sdscatprintf(sdsempty(), "... your format ...", args);
  */
 sds sdscatprintf(sds s, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char *t;
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return t;
 }
 
@@ -577,6 +652,7 @@ sds sdscatprintf(sds s, const char *fmt, ...) {
  * %% - Verbatim "%" character.
  */
 sds sdscatfmt(sds s, char const *fmt, ...) {
+    volatile int __A_VARIABLE;
     const char *f = fmt;
     int i;
     va_list ap;
@@ -661,6 +737,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
 
     /* Add null-term */
     s[i] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -679,6 +756,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
  * Output will be just "Hello World".
  */
 sds sdstrim(sds s, const char *cset) {
+    volatile int __A_VARIABLE;
     char *start, *end, *sp, *ep;
     size_t len;
 
@@ -690,6 +768,7 @@ sds sdstrim(sds s, const char *cset) {
     if (s != sp) memmove(s, sp, len);
     s[len] = '\0';
     sdssetlen(s,len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -710,9 +789,13 @@ sds sdstrim(sds s, const char *cset) {
  * sdsrange(s,1,-1); => "ello World"
  */
 void sdsrange(sds s, int start, int end) {
+    volatile int __A_VARIABLE;
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return;
+    if (len == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -735,20 +818,25 @@ void sdsrange(sds s, int start, int end) {
     if (start && newlen) memmove(s, s+start, newlen);
     s[newlen] = 0;
     sdssetlen(s,newlen);
+    __A_VARIABLE = 1;
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
+    volatile int __A_VARIABLE;
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Apply toupper() to every character of the sds string 's'. */
 void sdstoupper(sds s) {
+    volatile int __A_VARIABLE;
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two sds strings s1 and s2 with memcmp().
@@ -763,6 +851,7 @@ void sdstoupper(sds s) {
  * additional characters, the longer string is considered to be greater than
  * the smaller one. */
 int sdscmp(const sds s1, const sds s2) {
+    volatile int __A_VARIABLE;
     size_t l1, l2, minlen;
     int cmp;
 
@@ -770,7 +859,11 @@ int sdscmp(const sds s1, const sds s2) {
     l2 = sdslen(s2);
     minlen = (l1 < l2) ? l1 : l2;
     cmp = memcmp(s1,s2,minlen);
-    if (cmp == 0) return l1-l2;
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return l1-l2;
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -791,16 +884,24 @@ int sdscmp(const sds s1, const sds s2) {
  * same function but for zero-terminated strings.
  */
 sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
+    volatile int __A_VARIABLE;
     int elements = 0, slots = 5, start = 0, j;
     sds *tokens;
 
-    if (seplen < 1 || len < 0) return NULL;
+    if (seplen < 1 || len < 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     tokens = s_malloc(sizeof(sds)*slots);
-    if (tokens == NULL) return NULL;
+    if (tokens == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (len == 0) {
         *count = 0;
+        __A_VARIABLE = 1;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
@@ -827,6 +928,7 @@ sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count
     if (tokens[elements] == NULL) goto cleanup;
     elements++;
     *count = elements;
+    __A_VARIABLE = 1;
     return tokens;
 
 cleanup:
@@ -835,16 +937,22 @@ cleanup:
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
         s_free(tokens);
         *count = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
-    if (!tokens) return;
+    volatile int __A_VARIABLE;
+    if (!tokens) {
+        __A_VARIABLE = 1;
+        return;
+    }
     while(count--)
         sdsfree(tokens[count]);
     s_free(tokens);
+    __A_VARIABLE = 1;
 }
 
 /* Append to the sds string "s" an escaped string representation where
@@ -854,6 +962,7 @@ void sdsfreesplitres(sds *tokens, int count) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatrepr(sds s, const char *p, size_t len) {
+    volatile int __A_VARIABLE;
     s = sdscatlen(s,"\"",1);
     while(len--) {
         switch(*p) {
@@ -875,12 +984,15 @@ sds sdscatrepr(sds s, const char *p, size_t len) {
         }
         p++;
     }
+    __A_VARIABLE = 1;
     return sdscatlen(s,"\"",1);
 }
 
 /* Helper function for sdssplitargs() that returns non zero if 'c'
  * is a valid hex digit. */
 int is_hex_digit(char c) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
            (c >= 'A' && c <= 'F');
 }
@@ -888,24 +1000,42 @@ int is_hex_digit(char c) {
 /* Helper function for sdssplitargs() that converts a hex digit into an
  * integer from 0 to 15 */
 int hex_digit_to_int(char c) {
+    volatile int __A_VARIABLE;
     switch(c) {
-    case '0': return 0;
-    case '1': return 1;
-    case '2': return 2;
-    case '3': return 3;
-    case '4': return 4;
-    case '5': return 5;
-    case '6': return 6;
-    case '7': return 7;
-    case '8': return 8;
-    case '9': return 9;
-    case 'a': case 'A': return 10;
-    case 'b': case 'B': return 11;
-    case 'c': case 'C': return 12;
-    case 'd': case 'D': return 13;
-    case 'e': case 'E': return 14;
-    case 'f': case 'F': return 15;
-    default: return 0;
+    case '0': __A_VARIABLE = 1;
+        return 0;
+    case '1': __A_VARIABLE = 1;
+        return 1;
+    case '2': __A_VARIABLE = 1;
+        return 2;
+    case '3': __A_VARIABLE = 1;
+        return 3;
+    case '4': __A_VARIABLE = 1;
+        return 4;
+    case '5': __A_VARIABLE = 1;
+        return 5;
+    case '6': __A_VARIABLE = 1;
+        return 6;
+    case '7': __A_VARIABLE = 1;
+        return 7;
+    case '8': __A_VARIABLE = 1;
+        return 8;
+    case '9': __A_VARIABLE = 1;
+        return 9;
+    case 'a': case 'A': __A_VARIABLE = 1;
+        return 10;
+    case 'b': case 'B': __A_VARIABLE = 1;
+        return 11;
+    case 'c': case 'C': __A_VARIABLE = 1;
+        return 12;
+    case 'd': case 'D': __A_VARIABLE = 1;
+        return 13;
+    case 'e': case 'E': __A_VARIABLE = 1;
+        return 14;
+    case 'f': case 'F': __A_VARIABLE = 1;
+        return 15;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1048,6 +1178,7 @@ err:
  * The function returns the sds string pointer, that is always the same
  * as the input pointer since no resize is needed. */
 sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
+    volatile int __A_VARIABLE;
     size_t j, i, l = sdslen(s);
 
     for (j = 0; j < l; j++) {
@@ -1058,12 +1189,14 @@ sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Join an array of C strings using the specified separator (also a C string).
  * Returns the result as an sds string. */
 sds sdsjoin(char **argv, int argc, char *sep) {
+    volatile int __A_VARIABLE;
     sds join = sdsempty();
     int j;
 
@@ -1071,11 +1204,13 @@ sds sdsjoin(char **argv, int argc, char *sep) {
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
 /* Like sdsjoin, but joins an array of SDS strings. */
 sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
+    volatile int __A_VARIABLE;
     sds join = sdsempty();
     int j;
 
@@ -1083,6 +1218,7 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
         join = sdscatsds(join, argv[j]);
         if (j != argc-1) join = sdscatlen(join,sep,seplen);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1091,9 +1227,15 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
  * the overhead of function calls. Here we define these wrappers only for
  * the programs SDS is linked to, if they want to touch the SDS internals
  * even if they use a different allocator. */
-void *sds_malloc(size_t size) { return s_malloc(size); }
-void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
-void sds_free(void *ptr) { s_free(ptr); }
+void *sds_malloc(size_t size) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return s_realloc(ptr,size); }
+void sds_free(void *ptr) {
+	volatile int __A_VARIABLE; s_free(ptr); __A_VARIABLE = 1;
+}
 
 #if defined(SDS_TEST_MAIN)
 #include <stdio.h>
@@ -1267,6 +1409,8 @@ int sdsTest(void) {
 
 #ifdef SDS_TEST_MAIN
 int main(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsTest();
 }
 #endif
diff --git a/deps/hiredis/test.c b/deps/hiredis/test.c
index a23d606..59851ed 100644
--- a/deps/hiredis/test.c
+++ b/deps/hiredis/test.c
@@ -39,8 +39,10 @@ static int tests = 0, fails = 0;
 #define test_cond(_c) if(_c) printf("\033[0;32mPASSED\033[0;0m\n"); else {printf("\033[0;31mFAILED\033[0;0m\n"); fails++;}
 
 static long long usec(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
@@ -52,6 +54,7 @@ static long long usec(void) {
 #endif
 
 static redisContext *select_database(redisContext *c) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
 
     /* Switch to DB 9 for testing, now that we know we can chat. */
@@ -70,10 +73,12 @@ static redisContext *select_database(redisContext *c) {
         exit(1);
     }
 
+    __A_VARIABLE = 1;
     return c;
 }
 
 static int disconnect(redisContext *c, int keep_fd) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
 
     /* Make sure we're on DB 9. */
@@ -85,13 +90,17 @@ static int disconnect(redisContext *c, int keep_fd) {
     freeReplyObject(reply);
 
     /* Free the context as well, but keep the fd if requested. */
-    if (keep_fd)
+    if (keep_fd) {
+        __A_VARIABLE = 1;
         return redisFreeKeepFd(c);
+    }
     redisFree(c);
+    __A_VARIABLE = 1;
     return -1;
 }
 
 static redisContext *connect(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c = NULL;
 
     if (config.type == CONN_TCP) {
@@ -119,10 +128,12 @@ static redisContext *connect(struct config config) {
         exit(1);
     }
 
+    __A_VARIABLE = 1;
     return select_database(c);
 }
 
 static void test_format_commands(void) {
+    volatile int __A_VARIABLE;
     char *cmd;
     int len;
 
@@ -240,9 +251,11 @@ static void test_format_commands(void) {
     test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
         len == 4+4+(3+2)+4+(7+2)+4+(3+2));
     sdsfree(sds_cmd);
+    __A_VARIABLE = 1;
 }
 
 static void test_append_formatted_commands(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisReply *reply;
     char *cmd;
@@ -262,9 +275,11 @@ static void test_append_formatted_commands(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_reply_reader(void) {
+    volatile int __A_VARIABLE;
     redisReader *reader;
     void *reply;
     int ret;
@@ -341,9 +356,11 @@ static void test_reply_reader(void) {
         ((redisReply*)reply)->elements == 0);
     freeReplyObject(reply);
     redisReaderFree(reader);
+    __A_VARIABLE = 1;
 }
 
 static void test_free_null(void) {
+    volatile int __A_VARIABLE;
     void *redisCtx = NULL;
     void *reply = NULL;
 
@@ -354,9 +371,11 @@ static void test_free_null(void) {
     test("Don't fail when freeReplyObject is passed a NULL value: ");
     freeReplyObject(reply);
     test_cond(reply == NULL);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection_errors(void) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     test("Returns error when host cannot be resolved: ");
@@ -381,9 +400,11 @@ static void test_blocking_connection_errors(void) {
     c = redisConnectUnix((char*)"/tmp/idontexist.sock");
     test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisReply *reply;
 
@@ -459,9 +480,11 @@ static void test_blocking_connection(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection_timeouts(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisReply *reply;
     ssize_t s;
@@ -505,9 +528,11 @@ static void test_blocking_connection_timeouts(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_io_errors(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c;
     redisReply *reply;
     void *_reply;
@@ -556,9 +581,11 @@ static void test_blocking_io_errors(struct config config) {
     test_cond(redisGetReply(c,&_reply) == REDIS_ERR &&
         c->err == REDIS_ERR_IO && errno == EAGAIN);
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_invalid_timeout_errors(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c;
 
     test("Set error when an invalid timeout usec value is given to redisConnectWithTimeout: ");
@@ -580,9 +607,11 @@ static void test_invalid_timeout_errors(struct config config) {
 
     test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_throughput(struct config config) {
+    volatile int __A_VARIABLE;
     redisContext *c = connect(config);
     redisReply **replies;
     int i, num;
@@ -645,6 +674,7 @@ static void test_throughput(struct config config) {
     printf("\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\n", num, (t2-t1)/1000000.0);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 // static long __test_callback_flags = 0;
@@ -747,6 +777,7 @@ static void test_throughput(struct config config) {
 // }
 
 int main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     struct config cfg = {
         .tcp = {
             .host = "127.0.0.1",
@@ -815,9 +846,11 @@ int main(int argc, char **argv) {
 
     if (fails) {
         printf("*** %d TESTS FAILED ***\n", fails);
+        __A_VARIABLE = 1;
         return 1;
     }
 
     printf("ALL TESTS PASSED\n");
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/jemalloc/src/arena.c b/deps/jemalloc/src/arena.c
index 5d55bf1..64b574a 100644
--- a/deps/jemalloc/src/arena.c
+++ b/deps/jemalloc/src/arena.c
@@ -64,6 +64,7 @@ void
 arena_basic_stats_merge(UNUSED tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
     const char **dss, ssize_t *dirty_decay_ms, ssize_t *muzzy_decay_ms,
     size_t *nactive, size_t *ndirty, size_t *nmuzzy) {
+	volatile int __A_VARIABLE;
 	*nthreads += arena_nthreads_get(arena, false);
 	*dss = dss_prec_names[arena_dss_prec_get(arena)];
 	*dirty_decay_ms = arena_dirty_decay_ms_get(arena);
@@ -71,6 +72,7 @@ arena_basic_stats_merge(UNUSED tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
 	*nactive += atomic_load_zu(&arena->nactive, ATOMIC_RELAXED);
 	*ndirty += extents_npages_get(&arena->extents_dirty);
 	*nmuzzy += extents_npages_get(&arena->extents_muzzy);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -78,6 +80,7 @@ arena_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
     const char **dss, ssize_t *dirty_decay_ms, ssize_t *muzzy_decay_ms,
     size_t *nactive, size_t *ndirty, size_t *nmuzzy, arena_stats_t *astats,
     bin_stats_t *bstats, arena_stats_large_t *lstats) {
+	volatile int __A_VARIABLE;
 	cassert(config_stats);
 
 	arena_basic_stats_merge(tsdn, arena, nthreads, dss, dirty_decay_ms,
@@ -203,11 +206,13 @@ arena_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
 	for (szind_t i = 0; i < NBINS; i++) {
 		bin_stats_merge(tsdn, &bstats[i], &arena->bins[i]);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_extents_dirty_dalloc(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
 
@@ -218,10 +223,12 @@ arena_extents_dirty_dalloc(tsdn_t *tsdn, arena_t *arena,
 	} else {
 		arena_background_thread_inactivity_check(tsdn, arena, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
 arena_slab_reg_alloc(extent_t *slab, const bin_info_t *bin_info) {
+	volatile int __A_VARIABLE;
 	void *ret;
 	arena_slab_data_t *slab_data = extent_slab_data_get(slab);
 	size_t regind;
@@ -233,6 +240,7 @@ arena_slab_reg_alloc(extent_t *slab, const bin_info_t *bin_info) {
 	ret = (void *)((uintptr_t)extent_addr_get(slab) +
 	    (uintptr_t)(bin_info->reg_size * regind));
 	extent_nfree_dec(slab);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -241,6 +249,7 @@ static
 #endif
 size_t
 arena_slab_regind(extent_t *slab, szind_t binind, const void *ptr) {
+	volatile int __A_VARIABLE;
 	size_t diff, regind;
 
 	/* Freeing a pointer outside the slab can cause assertion failure. */
@@ -257,11 +266,13 @@ arena_slab_regind(extent_t *slab, szind_t binind, const void *ptr) {
 
 	assert(regind < bin_infos[binind].nregs);
 
+	__A_VARIABLE = 1;
 	return regind;
 }
 
 static void
 arena_slab_reg_dalloc(extent_t *slab, arena_slab_data_t *slab_data, void *ptr) {
+	volatile int __A_VARIABLE;
 	szind_t binind = extent_szind_get(slab);
 	const bin_info_t *bin_info = &bin_infos[binind];
 	size_t regind = arena_slab_regind(slab, binind, ptr);
@@ -272,21 +283,27 @@ arena_slab_reg_dalloc(extent_t *slab, arena_slab_data_t *slab_data, void *ptr) {
 
 	bitmap_unset(slab_data->bitmap, &bin_info->bitmap_info, regind);
 	extent_nfree_inc(slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_nactive_add(arena_t *arena, size_t add_pages) {
+	volatile int __A_VARIABLE;
 	atomic_fetch_add_zu(&arena->nactive, add_pages, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_nactive_sub(arena_t *arena, size_t sub_pages) {
+	volatile int __A_VARIABLE;
 	assert(atomic_load_zu(&arena->nactive, ATOMIC_RELAXED) >= sub_pages);
 	atomic_fetch_sub_zu(&arena->nactive, sub_pages, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_large_malloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
+	volatile int __A_VARIABLE;
 	szind_t index, hindex;
 
 	cassert(config_stats);
@@ -299,10 +316,12 @@ arena_large_malloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
 
 	arena_stats_add_u64(tsdn, &arena->stats,
 	    &arena->stats.lstats[hindex].nmalloc, 1);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_large_dalloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
+	volatile int __A_VARIABLE;
 	szind_t index, hindex;
 
 	cassert(config_stats);
@@ -315,18 +334,22 @@ arena_large_dalloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
 
 	arena_stats_add_u64(tsdn, &arena->stats,
 	    &arena->stats.lstats[hindex].ndalloc, 1);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_large_ralloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t oldusize,
     size_t usize) {
+	volatile int __A_VARIABLE;
 	arena_large_dalloc_stats_update(tsdn, arena, oldusize);
 	arena_large_malloc_stats_update(tsdn, arena, usize);
+	__A_VARIABLE = 1;
 }
 
 extent_t *
 arena_extent_alloc_large(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool *zero) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
@@ -373,11 +396,13 @@ arena_extent_alloc_large(tsdn_t *tsdn, arena_t *arena, size_t usize,
 		arena_nactive_add(arena, size >> LG_PAGE);
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 void
 arena_extent_dalloc_large_prep(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	if (config_stats) {
 		arena_stats_lock(tsdn, &arena->stats);
 		arena_large_dalloc_stats_update(tsdn, arena,
@@ -385,11 +410,13 @@ arena_extent_dalloc_large_prep(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_sub(arena, extent_size_get(extent) >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_extent_ralloc_large_shrink(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
     size_t oldusize) {
+	volatile int __A_VARIABLE;
 	size_t usize = extent_usize_get(extent);
 	size_t udiff = oldusize - usize;
 
@@ -399,11 +426,13 @@ arena_extent_ralloc_large_shrink(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_sub(arena, udiff >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_extent_ralloc_large_expand(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
     size_t oldusize) {
+	volatile int __A_VARIABLE;
 	size_t usize = extent_usize_get(extent);
 	size_t udiff = usize - oldusize;
 
@@ -413,20 +442,26 @@ arena_extent_ralloc_large_expand(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_add(arena, udiff >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 static ssize_t
 arena_decay_ms_read(arena_decay_t *decay) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);
 }
 
 static void
 arena_decay_ms_write(arena_decay_t *decay, ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	atomic_store_zd(&decay->time_ms, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_deadline_init(arena_decay_t *decay) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Generate a new deadline that is uniformly random within the next
 	 * epoch after the current one.
@@ -440,15 +475,19 @@ arena_decay_deadline_init(arena_decay_t *decay) {
 		    nstime_ns(&decay->interval)));
 		nstime_add(&decay->deadline, &jitter);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 arena_decay_deadline_reached(const arena_decay_t *decay, const nstime_t *time) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (nstime_compare(&decay->deadline, time) <= 0);
 }
 
 static size_t
 arena_decay_backlog_npages_limit(const arena_decay_t *decay) {
+	volatile int __A_VARIABLE;
 	uint64_t sum;
 	size_t npages_limit_backlog;
 	unsigned i;
@@ -464,11 +503,13 @@ arena_decay_backlog_npages_limit(const arena_decay_t *decay) {
 	}
 	npages_limit_backlog = (size_t)(sum >> SMOOTHSTEP_BFP);
 
+	__A_VARIABLE = 1;
 	return npages_limit_backlog;
 }
 
 static void
 arena_decay_backlog_update_last(arena_decay_t *decay, size_t current_npages) {
+	volatile int __A_VARIABLE;
 	size_t npages_delta = (current_npages > decay->nunpurged) ?
 	    current_npages - decay->nunpurged : 0;
 	decay->backlog[SMOOTHSTEP_NSTEPS-1] = npages_delta;
@@ -483,11 +524,13 @@ arena_decay_backlog_update_last(arena_decay_t *decay, size_t current_npages) {
 			decay->ceil_npages = npages_limit;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_backlog_update(arena_decay_t *decay, uint64_t nadvance_u64,
     size_t current_npages) {
+	volatile int __A_VARIABLE;
 	if (nadvance_u64 >= SMOOTHSTEP_NSTEPS) {
 		memset(decay->backlog, 0, (SMOOTHSTEP_NSTEPS-1) *
 		    sizeof(size_t));
@@ -505,22 +548,26 @@ arena_decay_backlog_update(arena_decay_t *decay, uint64_t nadvance_u64,
 	}
 
 	arena_decay_backlog_update_last(decay, current_npages);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_try_purge(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, size_t current_npages, size_t npages_limit,
     bool is_background_thread) {
+	volatile int __A_VARIABLE;
 	if (current_npages > npages_limit) {
 		arena_decay_to_limit(tsdn, arena, decay, extents, false,
 		    npages_limit, current_npages - npages_limit,
 		    is_background_thread);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_epoch_advance_helper(arena_decay_t *decay, const nstime_t *time,
     size_t current_npages) {
+	volatile int __A_VARIABLE;
 	assert(arena_decay_deadline_reached(decay, time));
 
 	nstime_t delta;
@@ -540,11 +587,13 @@ arena_decay_epoch_advance_helper(arena_decay_t *decay, const nstime_t *time,
 
 	/* Update the backlog. */
 	arena_decay_backlog_update(decay, nadvance_u64, current_npages);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_epoch_advance(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, const nstime_t *time, bool is_background_thread) {
+	volatile int __A_VARIABLE;
 	size_t current_npages = extents_npages_get(extents);
 	arena_decay_epoch_advance_helper(decay, time, current_npages);
 
@@ -557,10 +606,12 @@ arena_decay_epoch_advance(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		arena_decay_try_purge(tsdn, arena, decay, extents,
 		    current_npages, npages_limit, is_background_thread);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_decay_reinit(arena_decay_t *decay, ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	arena_decay_ms_write(decay, decay_ms);
 	if (decay_ms > 0) {
 		nstime_init(&decay->interval, (uint64_t)decay_ms *
@@ -574,11 +625,13 @@ arena_decay_reinit(arena_decay_t *decay, ssize_t decay_ms) {
 	arena_decay_deadline_init(decay);
 	decay->nunpurged = 0;
 	memset(decay->backlog, 0, SMOOTHSTEP_NSTEPS * sizeof(size_t));
+	__A_VARIABLE = 1;
 }
 
 static bool
 arena_decay_init(arena_decay_t *decay, ssize_t decay_ms,
     arena_stats_decay_t *stats) {
+	volatile int __A_VARIABLE;
 	if (config_debug) {
 		for (size_t i = 0; i < sizeof(arena_decay_t); i++) {
 			assert(((char *)decay)[i] == 0);
@@ -587,6 +640,7 @@ arena_decay_init(arena_decay_t *decay, ssize_t decay_ms,
 	}
 	if (malloc_mutex_init(&decay->mtx, "decay", WITNESS_RANK_DECAY,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	decay->purging = false;
@@ -595,24 +649,30 @@ arena_decay_init(arena_decay_t *decay, ssize_t decay_ms,
 	if (config_stats) {
 		decay->stats = stats;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 arena_decay_ms_valid(ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	if (decay_ms < -1) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (decay_ms == -1 || (uint64_t)decay_ms <= NSTIME_SEC_MAX *
 	    KQU(1000)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 arena_maybe_decay(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, bool is_background_thread) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &decay->mtx);
 
 	/* Purge all or nothing if the option is disabled. */
@@ -623,6 +683,7 @@ arena_maybe_decay(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 			    0, extents_npages_get(extents),
 			    is_background_thread);
 		}
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -665,28 +726,37 @@ arena_maybe_decay(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    is_background_thread);
 	}
 
+	__A_VARIABLE = 1;
 	return advance_epoch;
 }
 
 static ssize_t
 arena_decay_ms_get(arena_decay_t *decay) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_ms_read(decay);
 }
 
 ssize_t
 arena_dirty_decay_ms_get(arena_t *arena) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_ms_get(&arena->decay_dirty);
 }
 
 ssize_t
 arena_muzzy_decay_ms_get(arena_t *arena) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_ms_get(&arena->decay_muzzy);
 }
 
 static bool
 arena_decay_ms_set(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -703,12 +773,15 @@ arena_decay_ms_set(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 	arena_maybe_decay(tsdn, arena, decay, extents, false);
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 arena_dirty_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
     ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_ms_set(tsdn, arena, &arena->decay_dirty,
 	    &arena->extents_dirty, decay_ms);
 }
@@ -716,6 +789,8 @@ arena_dirty_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
 bool
 arena_muzzy_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
     ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_ms_set(tsdn, arena, &arena->decay_muzzy,
 	    &arena->extents_muzzy, decay_ms);
 }
@@ -724,6 +799,7 @@ static size_t
 arena_stash_decayed(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extents_t *extents, size_t npages_limit,
 	size_t npages_decay_max, extent_list_t *decay_extents) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
 
@@ -736,6 +812,7 @@ arena_stash_decayed(tsdn_t *tsdn, arena_t *arena,
 		extent_list_append(decay_extents, extent);
 		nstashed += extent_size_get(extent) >> LG_PAGE;
 	}
+	__A_VARIABLE = 1;
 	return nstashed;
 }
 
@@ -743,6 +820,7 @@ static size_t
 arena_decay_stashed(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, arena_decay_t *decay, extents_t *extents,
     bool all, extent_list_t *decay_extents, bool is_background_thread) {
+	volatile int __A_VARIABLE;
 	UNUSED size_t nmadvise, nunmapped;
 	size_t npurged;
 
@@ -802,6 +880,7 @@ arena_decay_stashed(tsdn_t *tsdn, arena_t *arena,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 
+	__A_VARIABLE = 1;
 	return npurged;
 }
 
@@ -816,11 +895,13 @@ static void
 arena_decay_to_limit(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, bool all, size_t npages_limit, size_t npages_decay_max,
     bool is_background_thread) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 1);
 	malloc_mutex_assert_owner(tsdn, &decay->mtx);
 
 	if (decay->purging) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	decay->purging = true;
@@ -842,22 +923,26 @@ arena_decay_to_limit(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 
 	malloc_mutex_lock(tsdn, &decay->mtx);
 	decay->purging = false;
+	__A_VARIABLE = 1;
 }
 
 static bool
 arena_decay_impl(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, bool is_background_thread, bool all) {
+	volatile int __A_VARIABLE;
 	if (all) {
 		malloc_mutex_lock(tsdn, &decay->mtx);
 		arena_decay_to_limit(tsdn, arena, decay, extents, all, 0,
 		    extents_npages_get(extents), is_background_thread);
 		malloc_mutex_unlock(tsdn, &decay->mtx);
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	if (malloc_mutex_trylock(tsdn, &decay->mtx)) {
 		/* No need to wait if another thread is in progress. */
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -876,12 +961,15 @@ arena_decay_impl(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    npages_new);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 arena_decay_dirty(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
     bool all) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_impl(tsdn, arena, &arena->decay_dirty,
 	    &arena->extents_dirty, is_background_thread, all);
 }
@@ -889,51 +977,66 @@ arena_decay_dirty(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
 static bool
 arena_decay_muzzy(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
     bool all) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_decay_impl(tsdn, arena, &arena->decay_muzzy,
 	    &arena->extents_muzzy, is_background_thread, all);
 }
 
 void
 arena_decay(tsdn_t *tsdn, arena_t *arena, bool is_background_thread, bool all) {
+	volatile int __A_VARIABLE;
 	if (arena_decay_dirty(tsdn, arena, is_background_thread, all)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	arena_decay_muzzy(tsdn, arena, is_background_thread, all);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_slab_dalloc(tsdn_t *tsdn, arena_t *arena, extent_t *slab) {
+	volatile int __A_VARIABLE;
 	arena_nactive_sub(arena, extent_size_get(slab) >> LG_PAGE);
 
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_nonfull_insert(bin_t *bin, extent_t *slab) {
+	volatile int __A_VARIABLE;
 	assert(extent_nfree_get(slab) > 0);
 	extent_heap_insert(&bin->slabs_nonfull, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_nonfull_remove(bin_t *bin, extent_t *slab) {
+	volatile int __A_VARIABLE;
 	extent_heap_remove(&bin->slabs_nonfull, slab);
+	__A_VARIABLE = 1;
 }
 
 static extent_t *
 arena_bin_slabs_nonfull_tryget(bin_t *bin) {
+	volatile int __A_VARIABLE;
 	extent_t *slab = extent_heap_remove_first(&bin->slabs_nonfull);
 	if (slab == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	if (config_stats) {
 		bin->stats.reslabs++;
 	}
+	__A_VARIABLE = 1;
 	return slab;
 }
 
 static void
 arena_bin_slabs_full_insert(arena_t *arena, bin_t *bin, extent_t *slab) {
+	volatile int __A_VARIABLE;
 	assert(extent_nfree_get(slab) == 0);
 	/*
 	 *  Tracking extents is required by arena_reset, which is not allowed
@@ -941,21 +1044,27 @@ arena_bin_slabs_full_insert(arena_t *arena, bin_t *bin, extent_t *slab) {
 	 *  linkage (often results in cache misses) for auto arenas.
 	 */
 	if (arena_is_auto(arena)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_list_append(&bin->slabs_full, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_full_remove(arena_t *arena, bin_t *bin, extent_t *slab) {
+	volatile int __A_VARIABLE;
 	if (arena_is_auto(arena)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_list_remove(&bin->slabs_full, slab);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_reset(tsd_t *tsd, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Locking in this function is unintuitive.  The caller guarantees that
 	 * no concurrent operations are happening in this arena, but there are
@@ -1031,10 +1140,12 @@ arena_reset(tsd_t *tsd, arena_t *arena) {
 	}
 
 	atomic_store_zu(&arena->nactive, 0, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_destroy_retained(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Iterate over the retained extents and destroy them.  This gives the
 	 * extent allocator underlying the extent hooks an opportunity to unmap
@@ -1050,10 +1161,12 @@ arena_destroy_retained(tsdn_t *tsdn, arena_t *arena) {
 	    &arena->extents_retained, 0)) != NULL) {
 		extent_destroy_wrapper(tsdn, arena, &extent_hooks, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_destroy(tsd_t *tsd, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	assert(base_ind_get(arena->base) >= narenas_auto);
 	assert(arena_nthreads_get(arena, false) == 0);
 	assert(arena_nthreads_get(arena, true) == 0);
@@ -1086,12 +1199,14 @@ arena_destroy(tsd_t *tsd, arena_t *arena) {
 	 * this arena.
 	 */
 	base_delete(tsd_tsdn(tsd), arena->base);
+	__A_VARIABLE = 1;
 }
 
 static extent_t *
 arena_slab_alloc_hard(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, const bin_info_t *bin_info,
     szind_t szind) {
+	volatile int __A_VARIABLE;
 	extent_t *slab;
 	bool zero, commit;
 
@@ -1108,12 +1223,14 @@ arena_slab_alloc_hard(tsdn_t *tsdn, arena_t *arena,
 		    bin_info->slab_size);
 	}
 
+	__A_VARIABLE = 1;
 	return slab;
 }
 
 static extent_t *
 arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind,
     const bin_info_t *bin_info) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
 
@@ -1133,6 +1250,7 @@ arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind,
 		slab = arena_slab_alloc_hard(tsdn, arena, &extent_hooks,
 		    bin_info, szind);
 		if (slab == NULL) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 	}
@@ -1145,18 +1263,21 @@ arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind,
 
 	arena_nactive_add(arena, extent_size_get(slab) >> LG_PAGE);
 
+	__A_VARIABLE = 1;
 	return slab;
 }
 
 static extent_t *
 arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
     szind_t binind) {
+	volatile int __A_VARIABLE;
 	extent_t *slab;
 	const bin_info_t *bin_info;
 
 	/* Look for a usable slab. */
 	slab = arena_bin_slabs_nonfull_tryget(bin);
 	if (slab != NULL) {
+		__A_VARIABLE = 1;
 		return slab;
 	}
 	/* No existing slabs have any space available. */
@@ -1174,6 +1295,7 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 			bin->stats.nslabs++;
 			bin->stats.curslabs++;
 		}
+		__A_VARIABLE = 1;
 		return slab;
 	}
 
@@ -1184,9 +1306,11 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 	 */
 	slab = arena_bin_slabs_nonfull_tryget(bin);
 	if (slab != NULL) {
+		__A_VARIABLE = 1;
 		return slab;
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1194,6 +1318,7 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 static void *
 arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
     szind_t binind) {
+	volatile int __A_VARIABLE;
 	const bin_info_t *bin_info;
 	extent_t *slab;
 
@@ -1229,6 +1354,7 @@ arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 					    bin);
 				}
 			}
+			__A_VARIABLE = 1;
 			return ret;
 		}
 
@@ -1237,18 +1363,21 @@ arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 	}
 
 	if (slab == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	bin->slabcur = slab;
 
 	assert(extent_nfree_get(bin->slabcur) > 0);
 
+	__A_VARIABLE = 1;
 	return arena_slab_reg_alloc(slab, bin_info);
 }
 
 void
 arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
     cache_bin_t *tbin, szind_t binind, uint64_t prof_accumbytes) {
+	volatile int __A_VARIABLE;
 	unsigned i, nfill;
 	bin_t *bin;
 
@@ -1297,24 +1426,30 @@ arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
 	malloc_mutex_unlock(tsdn, &bin->lock);
 	tbin->ncached = i;
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_alloc_junk_small(void *ptr, const bin_info_t *bin_info, bool zero) {
+	volatile int __A_VARIABLE;
 	if (!zero) {
 		memset(ptr, JEMALLOC_ALLOC_JUNK, bin_info->reg_size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_junk_small_impl(void *ptr, const bin_info_t *bin_info) {
+	volatile int __A_VARIABLE;
 	memset(ptr, JEMALLOC_FREE_JUNK, bin_info->reg_size);
+	__A_VARIABLE = 1;
 }
 arena_dalloc_junk_small_t *JET_MUTABLE arena_dalloc_junk_small =
     arena_dalloc_junk_small_impl;
 
 static void *
 arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero) {
+	volatile int __A_VARIABLE;
 	void *ret;
 	bin_t *bin;
 	size_t usize;
@@ -1333,6 +1468,7 @@ arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero) {
 
 	if (ret == NULL) {
 		malloc_mutex_unlock(tsdn, &bin->lock);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1364,30 +1500,36 @@ arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero) {
 	}
 
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void *
 arena_malloc_hard(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind,
     bool zero) {
+	volatile int __A_VARIABLE;
 	assert(!tsdn_null(tsdn) || arena != NULL);
 
 	if (likely(!tsdn_null(tsdn))) {
 		arena = arena_choose(tsdn_tsd(tsdn), arena);
 	}
 	if (unlikely(arena == NULL)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	if (likely(size <= SMALL_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return arena_malloc_small(tsdn, arena, ind, zero);
 	}
+	__A_VARIABLE = 1;
 	return large_malloc(tsdn, arena, sz_index2size(ind), zero);
 }
 
 void *
 arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
     bool zero, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	void *ret;
 
 	if (usize <= SMALL_MAXCLASS && (alignment < PAGE || (alignment == PAGE
@@ -1402,11 +1544,13 @@ arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 			ret = large_palloc(tsdn, arena, usize, alignment, zero);
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 arena_prof_promote(tsdn_t *tsdn, const void *ptr, size_t usize) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(ptr != NULL);
 	assert(isalloc(tsdn, ptr) == LARGE_MINCLASS);
@@ -1427,10 +1571,12 @@ arena_prof_promote(tsdn_t *tsdn, const void *ptr, size_t usize) {
 	prof_accum_cancel(tsdn, &arena->prof_accum, usize);
 
 	assert(isalloc(tsdn, ptr) == usize);
+	__A_VARIABLE = 1;
 }
 
 static size_t
 arena_prof_demote(tsdn_t *tsdn, extent_t *extent, const void *ptr) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(ptr != NULL);
 
@@ -1442,12 +1588,14 @@ arena_prof_demote(tsdn_t *tsdn, extent_t *extent, const void *ptr) {
 
 	assert(isalloc(tsdn, ptr) == LARGE_MINCLASS);
 
+	__A_VARIABLE = 1;
 	return LARGE_MINCLASS;
 }
 
 void
 arena_dalloc_promoted(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
     bool slow_path) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(opt_prof);
 
@@ -1459,10 +1607,12 @@ arena_dalloc_promoted(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
 	} else {
 		large_dalloc(tsdn, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dissociate_bin_slab(arena_t *arena, extent_t *slab, bin_t *bin) {
+	volatile int __A_VARIABLE;
 	/* Dissociate slab from bin. */
 	if (slab == bin->slabcur) {
 		bin->slabcur = NULL;
@@ -1481,11 +1631,13 @@ arena_dissociate_bin_slab(arena_t *arena, extent_t *slab, bin_t *bin) {
 			arena_bin_slabs_nonfull_remove(bin, slab);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_bin_slab(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
     bin_t *bin) {
+	volatile int __A_VARIABLE;
 	assert(slab != bin->slabcur);
 
 	malloc_mutex_unlock(tsdn, &bin->lock);
@@ -1496,11 +1648,13 @@ arena_dalloc_bin_slab(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 	if (config_stats) {
 		bin->stats.curslabs--;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_lower_slab(UNUSED tsdn_t *tsdn, arena_t *arena, extent_t *slab,
     bin_t *bin) {
+	volatile int __A_VARIABLE;
 	assert(extent_nfree_get(slab) > 0);
 
 	/*
@@ -1523,11 +1677,13 @@ arena_bin_lower_slab(UNUSED tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 	} else {
 		arena_bin_slabs_nonfull_insert(bin, slab);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_bin_locked_impl(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
     void *ptr, bool junked) {
+	volatile int __A_VARIABLE;
 	arena_slab_data_t *slab_data = extent_slab_data_get(slab);
 	szind_t binind = extent_szind_get(slab);
 	bin_t *bin = &arena->bins[binind];
@@ -1551,31 +1707,38 @@ arena_dalloc_bin_locked_impl(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 		bin->stats.ndalloc++;
 		bin->stats.curregs--;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_dalloc_bin_junked_locked(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
     void *ptr) {
+	volatile int __A_VARIABLE;
 	arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, true);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_bin(tsdn_t *tsdn, arena_t *arena, extent_t *extent, void *ptr) {
+	volatile int __A_VARIABLE;
 	szind_t binind = extent_szind_get(extent);
 	bin_t *bin = &arena->bins[binind];
 
 	malloc_mutex_lock(tsdn, &bin->lock);
 	arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, false);
 	malloc_mutex_unlock(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_dalloc_small(tsdn_t *tsdn, void *ptr) {
+	volatile int __A_VARIABLE;
 	extent_t *extent = iealloc(tsdn, ptr);
 	arena_t *arena = extent_arena_get(extent);
 
 	arena_dalloc_bin(tsdn, arena, extent, ptr);
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -1617,33 +1780,41 @@ arena_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
 static void *
 arena_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	if (alignment == 0) {
+		__A_VARIABLE = 1;
 		return arena_malloc(tsdn, arena, usize, sz_size2index(usize),
 		    zero, tcache, true);
 	}
 	usize = sz_sa2u(usize, alignment);
 	if (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
+	__A_VARIABLE = 1;
 	return ipalloct(tsdn, usize, alignment, zero, tcache, arena);
 }
 
 void *
 arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
     size_t size, size_t alignment, bool zero, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	size_t usize = sz_s2u(size);
 	if (unlikely(usize == 0 || size > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	if (likely(usize <= SMALL_MAXCLASS)) {
 		/* Try to avoid moving the allocation. */
 		if (!arena_ralloc_no_move(tsdn, ptr, oldsize, usize, 0, zero)) {
+			__A_VARIABLE = 1;
 			return ptr;
 		}
 	}
 
 	if (oldsize >= LARGE_MINCLASS && usize >= LARGE_MINCLASS) {
+		__A_VARIABLE = 1;
 		return large_ralloc(tsdn, arena, iealloc(tsdn, ptr), usize,
 		    alignment, zero, tcache);
 	}
@@ -1655,6 +1826,7 @@ arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
 	void *ret = arena_ralloc_move_helper(tsdn, arena, usize, alignment,
 	    zero, tcache);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1666,54 +1838,71 @@ arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
 	size_t copysize = (usize < oldsize) ? usize : oldsize;
 	memcpy(ret, ptr, copysize);
 	isdalloct(tsdn, ptr, oldsize, tcache, NULL, true);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 dss_prec_t
 arena_dss_prec_get(arena_t *arena) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (dss_prec_t)atomic_load_u(&arena->dss_prec, ATOMIC_ACQUIRE);
 }
 
 bool
 arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec) {
+	volatile int __A_VARIABLE;
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return (dss_prec != dss_prec_disabled);
 	}
 	atomic_store_u(&arena->dss_prec, (unsigned)dss_prec, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 ssize_t
 arena_dirty_decay_ms_default_get(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&dirty_decay_ms_default, ATOMIC_RELAXED);
 }
 
 bool
 arena_dirty_decay_ms_default_set(ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	atomic_store_zd(&dirty_decay_ms_default, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 ssize_t
 arena_muzzy_decay_ms_default_get(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&muzzy_decay_ms_default, ATOMIC_RELAXED);
 }
 
 bool
 arena_muzzy_decay_ms_default_set(ssize_t decay_ms) {
+	volatile int __A_VARIABLE;
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	atomic_store_zd(&muzzy_decay_ms_default, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
     size_t *new_limit) {
+	volatile int __A_VARIABLE;
 	assert(opt_retain);
 
 	pszind_t new_ind JEMALLOC_CC_SILENCE_INIT(0);
@@ -1722,6 +1911,7 @@ arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
 		/* Grow no more than the new limit. */
 		if ((new_ind = sz_psz2ind(limit + 1) - 1) >
 		     EXTENT_GROW_MAX_PIND) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
@@ -1735,26 +1925,35 @@ arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
 	}
 	malloc_mutex_unlock(tsd_tsdn(tsd), &arena->extent_grow_mtx);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 unsigned
 arena_nthreads_get(arena_t *arena, bool internal) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_u(&arena->nthreads[internal], ATOMIC_RELAXED);
 }
 
 void
 arena_nthreads_inc(arena_t *arena, bool internal) {
+	volatile int __A_VARIABLE;
 	atomic_fetch_add_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_nthreads_dec(arena_t *arena, bool internal) {
+	volatile int __A_VARIABLE;
 	atomic_fetch_sub_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 size_t
 arena_extent_sn_next(arena_t *arena) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_fetch_add_zu(&arena->extent_sn_next, 1, ATOMIC_RELAXED);
 }
 
@@ -1916,6 +2115,7 @@ label_error:
 
 void
 arena_boot(void) {
+	volatile int __A_VARIABLE;
 	arena_dirty_decay_ms_default_set(opt_dirty_decay_ms);
 	arena_muzzy_decay_ms_default_set(opt_muzzy_decay_ms);
 #define REGIND_bin_yes(index, reg_size) 				\
@@ -1928,57 +2128,75 @@ arena_boot(void) {
 #undef REGIND_bin_yes
 #undef REGIND_bin_no
 #undef SC
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork0(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &arena->decay_dirty.mtx);
 	malloc_mutex_prefork(tsdn, &arena->decay_muzzy.mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork1(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	if (config_stats) {
 		malloc_mutex_prefork(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork2(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &arena->extent_grow_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork3(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	extents_prefork(tsdn, &arena->extents_dirty);
 	extents_prefork(tsdn, &arena->extents_muzzy);
 	extents_prefork(tsdn, &arena->extents_retained);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork4(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork5(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	base_prefork(tsdn, arena->base);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork6(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &arena->large_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork7(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	for (unsigned i = 0; i < NBINS; i++) {
 		bin_prefork(tsdn, &arena->bins[i]);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_postfork_parent(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 0; i < NBINS; i++) {
@@ -1996,10 +2214,12 @@ arena_postfork_parent(tsdn_t *tsdn, arena_t *arena) {
 	if (config_stats) {
 		malloc_mutex_postfork_parent(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_postfork_child(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	atomic_store_u(&arena->nthreads[0], 0, ATOMIC_RELAXED);
@@ -2040,4 +2260,5 @@ arena_postfork_child(tsdn_t *tsdn, arena_t *arena) {
 	if (config_stats) {
 		malloc_mutex_postfork_child(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/background_thread.c b/deps/jemalloc/src/background_thread.c
index 3517a3b..d6a9d00 100644
--- a/deps/jemalloc/src/background_thread.c
+++ b/deps/jemalloc/src/background_thread.c
@@ -35,18 +35,22 @@ static int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,
 
 static void
 pthread_create_wrapper_init(void) {
+	volatile int __A_VARIABLE;
 #ifdef JEMALLOC_LAZY_LOCK
 	if (!isthreaded) {
 		isthreaded = true;
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 int
 pthread_create_wrapper(pthread_t *__restrict thread, const pthread_attr_t *attr,
     void *(*start_routine)(void *), void *__restrict arg) {
+	volatile int __A_VARIABLE;
 	pthread_create_wrapper_init();
 
+	__A_VARIABLE = 1;
 	return pthread_create_fptr(thread, attr, start_routine, arg);
 }
 #endif /* JEMALLOC_PTHREAD_CREATE_WRAPPER */
@@ -72,12 +76,14 @@ static bool background_thread_enabled_at_fork;
 
 static void
 background_thread_info_init(tsdn_t *tsdn, background_thread_info_t *info) {
+	volatile int __A_VARIABLE;
 	background_thread_wakeup_time_set(tsdn, info, 0);
 	info->npages_to_purge_new = 0;
 	if (config_stats) {
 		info->tot_n_runs = 0;
 		nstime_init(&info->tot_sleep_time, 0);
 	}
+	__A_VARIABLE = 1;
 }
 
 static inline bool
@@ -102,6 +108,7 @@ set_current_thread_affinity(UNUSED int cpu) {
 
 static inline size_t
 decay_npurge_after_interval(arena_decay_t *decay, size_t interval) {
+	volatile int __A_VARIABLE;
 	size_t i;
 	uint64_t sum = 0;
 	for (i = 0; i < interval; i++) {
@@ -111,14 +118,17 @@ decay_npurge_after_interval(arena_decay_t *decay, size_t interval) {
 		sum += decay->backlog[i] * (h_steps[i] - h_steps[i - interval]);
 	}
 
+	__A_VARIABLE = 1;
 	return (size_t)(sum >> SMOOTHSTEP_BFP);
 }
 
 static uint64_t
 arena_decay_compute_purge_interval_impl(tsdn_t *tsdn, arena_decay_t *decay,
     extents_t *extents) {
+	volatile int __A_VARIABLE;
 	if (malloc_mutex_trylock(tsdn, &decay->mtx)) {
 		/* Use minimal interval if decay is contended. */
+		__A_VARIABLE = 1;
 		return BACKGROUND_THREAD_MIN_INTERVAL_NS;
 	}
 
@@ -196,27 +206,32 @@ label_done:
 	    BACKGROUND_THREAD_MIN_INTERVAL_NS : interval;
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 
+	__A_VARIABLE = 1;
 	return interval;
 }
 
 /* Compute purge interval for background threads. */
 static uint64_t
 arena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	uint64_t i1, i2;
 	i1 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_dirty,
 	    &arena->extents_dirty);
 	if (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {
+		__A_VARIABLE = 1;
 		return i1;
 	}
 	i2 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_muzzy,
 	    &arena->extents_muzzy);
 
+	__A_VARIABLE = 1;
 	return i1 < i2 ? i1 : i2;
 }
 
 static void
 background_thread_sleep(tsdn_t *tsdn, background_thread_info_t *info,
     uint64_t interval) {
+	volatile int __A_VARIABLE;
 	if (config_stats) {
 		info->tot_n_runs++;
 	}
@@ -268,24 +283,29 @@ background_thread_sleep(tsdn_t *tsdn, background_thread_info_t *info,
 			nstime_add(&info->tot_sleep_time, &after_sleep);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 background_thread_pause_check(tsdn_t *tsdn, background_thread_info_t *info) {
+	volatile int __A_VARIABLE;
 	if (unlikely(info->state == background_thread_paused)) {
 		malloc_mutex_unlock(tsdn, &info->mtx);
 		/* Wait on global lock to update status. */
 		malloc_mutex_lock(tsdn, &background_thread_lock);
 		malloc_mutex_unlock(tsdn, &background_thread_lock);
 		malloc_mutex_lock(tsdn, &info->mtx);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static inline void
 background_work_sleep_once(tsdn_t *tsdn, background_thread_info_t *info, unsigned ind) {
+	volatile int __A_VARIABLE;
 	uint64_t min_interval = BACKGROUND_THREAD_INDEFINITE_SLEEP;
 	unsigned narenas = narenas_total_get();
 
@@ -307,10 +327,12 @@ background_work_sleep_once(tsdn_t *tsdn, background_thread_info_t *info, unsigne
 		}
 	}
 	background_thread_sleep(tsdn, info, min_interval);
+	__A_VARIABLE = 1;
 }
 
 static bool
 background_threads_disable_single(tsd_t *tsd, background_thread_info_t *info) {
+	volatile int __A_VARIABLE;
 	if (info == &background_thread_info[0]) {
 		malloc_mutex_assert_owner(tsd_tsdn(tsd),
 		    &background_thread_lock);
@@ -334,17 +356,20 @@ background_threads_disable_single(tsd_t *tsd, background_thread_info_t *info) {
 
 	if (!has_thread) {
 		post_reentrancy(tsd);
+		__A_VARIABLE = 1;
 		return false;
 	}
 	void *ret;
 	if (pthread_join(info->thread, &ret)) {
 		post_reentrancy(tsd);
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(ret == NULL);
 	n_background_threads--;
 	post_reentrancy(tsd);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -353,6 +378,7 @@ static void *background_thread_entry(void *ind_arg);
 static int
 background_thread_create_signals_masked(pthread_t *thread,
     const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Mask signals during thread creation so that the thread inherits
 	 * an empty signal set.
@@ -362,6 +388,7 @@ background_thread_create_signals_masked(pthread_t *thread,
 	sigset_t oldset;
 	int mask_err = pthread_sigmask(SIG_SETMASK, &set, &oldset);
 	if (mask_err != 0) {
+		__A_VARIABLE = 1;
 		return mask_err;
 	}
 	int create_err = pthread_create_wrapper(thread, attr, start_routine,
@@ -379,14 +406,17 @@ background_thread_create_signals_masked(pthread_t *thread,
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 	return create_err;
 }
 
 static bool
 check_background_thread_creation(tsd_t *tsd, unsigned *n_created,
     bool *created_threads) {
+	volatile int __A_VARIABLE;
 	bool ret = false;
 	if (likely(*n_created == n_background_threads)) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 
@@ -429,11 +459,13 @@ check_background_thread_creation(tsd_t *tsd, unsigned *n_created,
 	}
 	malloc_mutex_lock(tsdn, &background_thread_info[0].mtx);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 background_thread0_work(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	/* Thread0 is also responsible for launching / terminating threads. */
 	VARIABLE_ARRAY(bool, created_threads, max_background_threads);
 	unsigned i;
@@ -479,10 +511,12 @@ background_thread0_work(tsd_t *tsd) {
 	}
 	background_thread_info[0].state = background_thread_stopped;
 	assert(n_background_threads == 1);
+	__A_VARIABLE = 1;
 }
 
 static void
 background_work(tsd_t *tsd, unsigned ind) {
+	volatile int __A_VARIABLE;
 	background_thread_info_t *info = &background_thread_info[ind];
 
 	malloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);
@@ -502,10 +536,12 @@ background_work(tsd_t *tsd, unsigned ind) {
 	assert(info->state == background_thread_stopped);
 	background_thread_wakeup_time_set(tsd_tsdn(tsd), info, 0);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void *
 background_thread_entry(void *ind_arg) {
+	volatile int __A_VARIABLE;
 	unsigned thread_ind = (unsigned)(uintptr_t)ind_arg;
 	assert(thread_ind < max_background_threads);
 #ifdef JEMALLOC_HAVE_PTHREAD_SETNAME_NP
@@ -523,20 +559,24 @@ background_thread_entry(void *ind_arg) {
 	assert(pthread_equal(pthread_self(),
 	    background_thread_info[thread_ind].thread));
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static void
 background_thread_init(tsd_t *tsd, background_thread_info_t *info) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);
 	info->state = background_thread_started;
 	background_thread_info_init(tsd_tsdn(tsd), info);
 	n_background_threads++;
+	__A_VARIABLE = 1;
 }
 
 /* Create a new background thread if needed. */
 bool
 background_thread_create(tsd_t *tsd, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	assert(have_background_thread);
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);
 
@@ -553,6 +593,7 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 	}
 	malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 	if (!need_new_thread) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (arena_ind != 0) {
@@ -563,6 +604,7 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 		pthread_cond_signal(&t0->cond);
 		malloc_mutex_unlock(tsd_tsdn(tsd), &t0->mtx);
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -583,14 +625,17 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 		n_background_threads--;
 		malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 background_threads_enable(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	assert(n_background_threads == 0);
 	assert(background_thread_enabled());
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);
@@ -622,21 +667,25 @@ background_threads_enable(tsd_t *tsd) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return background_thread_create(tsd, 0);
 }
 
 bool
 background_threads_disable(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	assert(!background_thread_enabled());
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);
 
 	/* Thread 0 will be responsible for terminating other threads. */
 	if (background_threads_disable_single(tsd,
 	    &background_thread_info[0])) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(n_background_threads == 0);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -644,6 +693,7 @@ background_threads_disable(tsd_t *tsd) {
 void
 background_thread_interval_check(tsdn_t *tsdn, arena_t *arena,
     arena_decay_t *decay, size_t npages_new) {
+	volatile int __A_VARIABLE;
 	background_thread_info_t *info = arena_background_thread_info_get(
 	    arena);
 	if (malloc_mutex_trylock(tsdn, &info->mtx)) {
@@ -653,6 +703,7 @@ background_thread_interval_check(tsdn_t *tsdn, arena_t *arena,
 		 * threads.  So keep this non-blocking, and leave the work to a
 		 * future epoch.
 		 */
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -722,38 +773,47 @@ label_done_unlock2:
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 label_done:
 	malloc_mutex_unlock(tsdn, &info->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 background_thread_prefork0(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &background_thread_lock);
 	background_thread_enabled_at_fork = background_thread_enabled();
+	__A_VARIABLE = 1;
 }
 
 void
 background_thread_prefork1(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	for (unsigned i = 0; i < max_background_threads; i++) {
 		malloc_mutex_prefork(tsdn, &background_thread_info[i].mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 background_thread_postfork_parent(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	for (unsigned i = 0; i < max_background_threads; i++) {
 		malloc_mutex_postfork_parent(tsdn,
 		    &background_thread_info[i].mtx);
 	}
 	malloc_mutex_postfork_parent(tsdn, &background_thread_lock);
+	__A_VARIABLE = 1;
 }
 
 void
 background_thread_postfork_child(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	for (unsigned i = 0; i < max_background_threads; i++) {
 		malloc_mutex_postfork_child(tsdn,
 		    &background_thread_info[i].mtx);
 	}
 	malloc_mutex_postfork_child(tsdn, &background_thread_lock);
 	if (!background_thread_enabled_at_fork) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -771,14 +831,17 @@ background_thread_postfork_child(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsdn, &info->mtx);
 	}
 	malloc_mutex_unlock(tsdn, &background_thread_lock);
+	__A_VARIABLE = 1;
 }
 
 bool
 background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
+	volatile int __A_VARIABLE;
 	assert(config_stats);
 	malloc_mutex_lock(tsdn, &background_thread_lock);
 	if (!background_thread_enabled()) {
 		malloc_mutex_unlock(tsdn, &background_thread_lock);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -800,6 +863,7 @@ background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
 	}
 	malloc_mutex_unlock(tsdn, &background_thread_lock);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -809,7 +873,9 @@ background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
 
 static bool
 pthread_create_fptr_init(void) {
+	volatile int __A_VARIABLE;
 	if (pthread_create_fptr != NULL) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	pthread_create_fptr = dlsym(RTLD_NEXT, "pthread_create");
@@ -824,6 +890,7 @@ pthread_create_fptr_init(void) {
 		can_enable_background_thread = true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -835,11 +902,13 @@ pthread_create_fptr_init(void) {
  */
 void
 background_thread_ctl_init(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_not_owner(tsdn, &background_thread_lock);
 #ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER
 	pthread_create_fptr_init();
 	pthread_create_wrapper_init();
 #endif
+	__A_VARIABLE = 1;
 }
 
 #endif /* defined(JEMALLOC_BACKGROUND_THREAD) */
diff --git a/deps/jemalloc/src/base.c b/deps/jemalloc/src/base.c
index b0324b5..949c4b8 100644
--- a/deps/jemalloc/src/base.c
+++ b/deps/jemalloc/src/base.c
@@ -24,12 +24,15 @@ const char *metadata_thp_mode_names[] = {
 
 static inline bool
 metadata_thp_madvise(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (metadata_thp_enabled() &&
 	    (init_system_thp_mode == thp_mode_default));
 }
 
 static void *
 base_map(tsdn_t *tsdn, extent_hooks_t *extent_hooks, unsigned ind, size_t size) {
+	volatile int __A_VARIABLE;
 	void *addr;
 	bool zero = true;
 	bool commit = true;
@@ -48,12 +51,14 @@ base_map(tsdn_t *tsdn, extent_hooks_t *extent_hooks, unsigned ind, size_t size)
 		post_reentrancy(tsd);
 	}
 
+	__A_VARIABLE = 1;
 	return addr;
 }
 
 static void
 base_unmap(tsdn_t *tsdn, extent_hooks_t *extent_hooks, unsigned ind, void *addr,
     size_t size) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Cascade through dalloc, decommit, purge_forced, and purge_lazy,
 	 * stopping at first success.  This cascade is performed for consistency
@@ -113,21 +118,25 @@ label_done:
 		    (size & HUGEPAGE_MASK) == 0);
 		pages_nohuge(addr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 base_extent_init(size_t *extent_sn_next, extent_t *extent, void *addr,
     size_t size) {
+	volatile int __A_VARIABLE;
 	size_t sn;
 
 	sn = *extent_sn_next;
 	(*extent_sn_next)++;
 
 	extent_binit(extent, addr, size, sn);
+	__A_VARIABLE = 1;
 }
 
 static size_t
 base_get_num_blocks(base_t *base, bool with_new_block) {
+	volatile int __A_VARIABLE;
 	base_block_t *b = base->blocks;
 	assert(b != NULL);
 
@@ -137,14 +146,17 @@ base_get_num_blocks(base_t *base, bool with_new_block) {
 		b = b->next;
 	}
 
+	__A_VARIABLE = 1;
 	return n_blocks;
 }
 
 static void
 base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	assert(opt_metadata_thp == metadata_thp_auto);
 	malloc_mutex_assert_owner(tsdn, &base->mtx);
 	if (base->auto_thp_switched) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	/* Called when adding a new block. */
@@ -157,6 +169,7 @@ base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
 		    BASE_AUTO_THP_THRESHOLD_A0);
 	}
 	if (!should_switch) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -174,11 +187,13 @@ base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
 		block = block->next;
 		assert(block == NULL || (base_ind_get(base) == 0));
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
 base_extent_bump_alloc_helper(extent_t *extent, size_t *gap_size, size_t size,
     size_t alignment) {
+	volatile int __A_VARIABLE;
 	void *ret;
 
 	assert(alignment == ALIGNMENT_CEILING(alignment, QUANTUM));
@@ -191,12 +206,14 @@ base_extent_bump_alloc_helper(extent_t *extent, size_t *gap_size, size_t size,
 	extent_binit(extent, (void *)((uintptr_t)extent_addr_get(extent) +
 	    *gap_size + size), extent_bsize_get(extent) - *gap_size - size,
 	    extent_sn_get(extent));
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 base_extent_bump_alloc_post(base_t *base, extent_t *extent, size_t gap_size,
     void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (extent_bsize_get(extent) > 0) {
 		/*
 		 * Compute the index for the largest size class that does not
@@ -226,16 +243,19 @@ base_extent_bump_alloc_post(base_t *base, extent_t *extent, size_t gap_size,
 			assert(base->mapped >= base->n_thp << LG_HUGEPAGE);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
 base_extent_bump_alloc(base_t *base, extent_t *extent, size_t size,
     size_t alignment) {
+	volatile int __A_VARIABLE;
 	void *ret;
 	size_t gap_size;
 
 	ret = base_extent_bump_alloc_helper(extent, &gap_size, size, alignment);
 	base_extent_bump_alloc_post(base, extent, gap_size, ret, size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -248,6 +268,7 @@ static base_block_t *
 base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
     unsigned ind, pszind_t *pind_last, size_t *extent_sn_next, size_t size,
     size_t alignment) {
+	volatile int __A_VARIABLE;
 	alignment = ALIGNMENT_CEILING(alignment, QUANTUM);
 	size_t usize = ALIGNMENT_CEILING(size, alignment);
 	size_t header_size = sizeof(base_block_t);
@@ -270,6 +291,7 @@ base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
 	base_block_t *block = (base_block_t *)base_map(tsdn, extent_hooks, ind,
 	    block_size);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -297,6 +319,7 @@ base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
 	assert(block_size >= header_size);
 	base_extent_init(extent_sn_next, &block->extent,
 	    (void *)((uintptr_t)block + header_size), block_size - header_size);
+	__A_VARIABLE = 1;
 	return block;
 }
 
@@ -306,6 +329,7 @@ base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
  */
 static extent_t *
 base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &base->mtx);
 
 	extent_hooks_t *extent_hooks = base_extent_hooks_get(base);
@@ -319,6 +343,7 @@ base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
 	    alignment);
 	malloc_mutex_lock(tsdn, &base->mtx);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	block->next = base->blocks;
@@ -338,21 +363,26 @@ base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
 		assert(base->resident <= base->mapped);
 		assert(base->n_thp << LG_HUGEPAGE <= base->mapped);
 	}
+	__A_VARIABLE = 1;
 	return &block->extent;
 }
 
 base_t *
 b0get(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return b0;
 }
 
 base_t *
 base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
+	volatile int __A_VARIABLE;
 	pszind_t pind_last = 0;
 	size_t extent_sn_next = 0;
 	base_block_t *block = base_block_alloc(tsdn, NULL, extent_hooks, ind,
 	    &pind_last, &extent_sn_next, sizeof(base_t), QUANTUM);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -366,6 +396,7 @@ base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	if (malloc_mutex_init(&base->mtx, "base", WITNESS_RANK_BASE,
 	    malloc_mutex_rank_exclusive)) {
 		base_unmap(tsdn, extent_hooks, ind, block, block->size);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	base->pind_last = pind_last;
@@ -389,11 +420,13 @@ base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	base_extent_bump_alloc_post(base, &block->extent, gap_size, base,
 	    base_size);
 
+	__A_VARIABLE = 1;
 	return base;
 }
 
 void
 base_delete(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t *extent_hooks = base_extent_hooks_get(base);
 	base_block_t *next = base->blocks;
 	do {
@@ -402,24 +435,30 @@ base_delete(tsdn_t *tsdn, base_t *base) {
 		base_unmap(tsdn, extent_hooks, base_ind_get(base), block,
 		    block->size);
 	} while (next != NULL);
+	__A_VARIABLE = 1;
 }
 
 extent_hooks_t *
 base_extent_hooks_get(base_t *base) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (extent_hooks_t *)atomic_load_p(&base->extent_hooks,
 	    ATOMIC_ACQUIRE);
 }
 
 extent_hooks_t *
 base_extent_hooks_set(base_t *base, extent_hooks_t *extent_hooks) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t *old_extent_hooks = base_extent_hooks_get(base);
 	atomic_store_p(&base->extent_hooks, extent_hooks, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return old_extent_hooks;
 }
 
 static void *
 base_alloc_impl(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment,
     size_t *esn) {
+	volatile int __A_VARIABLE;
 	alignment = QUANTUM_CEILING(alignment);
 	size_t usize = ALIGNMENT_CEILING(size, alignment);
 	size_t asize = usize + alignment - QUANTUM;
@@ -449,6 +488,7 @@ base_alloc_impl(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment,
 	}
 label_return:
 	malloc_mutex_unlock(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -462,24 +502,30 @@ label_return:
  */
 void *
 base_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return base_alloc_impl(tsdn, base, size, alignment, NULL);
 }
 
 extent_t *
 base_alloc_extent(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	size_t esn;
 	extent_t *extent = base_alloc_impl(tsdn, base, sizeof(extent_t),
 	    CACHELINE, &esn);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	extent_esn_set(extent, esn);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 void
 base_stats_get(tsdn_t *tsdn, base_t *base, size_t *allocated, size_t *resident,
     size_t *mapped, size_t *n_thp) {
+	volatile int __A_VARIABLE;
 	cassert(config_stats);
 
 	malloc_mutex_lock(tsdn, &base->mtx);
@@ -490,25 +536,34 @@ base_stats_get(tsdn_t *tsdn, base_t *base, size_t *allocated, size_t *resident,
 	*mapped = base->mapped;
 	*n_thp = base->n_thp;
 	malloc_mutex_unlock(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_prefork(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_postfork_parent(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_parent(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_postfork_child(tsdn_t *tsdn, base_t *base) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_child(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 bool
 base_boot(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	b0 = base_new(tsdn, 0, (extent_hooks_t *)&extent_hooks_default);
+	__A_VARIABLE = 1;
 	return (b0 == NULL);
 }
diff --git a/deps/jemalloc/src/bin.c b/deps/jemalloc/src/bin.c
index 0886bc4..b7de48b 100644
--- a/deps/jemalloc/src/bin.c
+++ b/deps/jemalloc/src/bin.c
@@ -21,8 +21,10 @@ const bin_info_t bin_infos[NBINS] = {
 
 bool
 bin_init(bin_t *bin) {
+	volatile int __A_VARIABLE;
 	if (malloc_mutex_init(&bin->lock, "bin", WITNESS_RANK_BIN,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	bin->slabcur = NULL;
@@ -31,20 +33,27 @@ bin_init(bin_t *bin) {
 	if (config_stats) {
 		memset(&bin->stats, 0, sizeof(bin_stats_t));
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 void
 bin_prefork(tsdn_t *tsdn, bin_t *bin) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 bin_postfork_parent(tsdn_t *tsdn, bin_t *bin) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_parent(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 bin_postfork_child(tsdn_t *tsdn, bin_t *bin) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_child(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/bitmap.c b/deps/jemalloc/src/bitmap.c
index 468b317..131fab5 100644
--- a/deps/jemalloc/src/bitmap.c
+++ b/deps/jemalloc/src/bitmap.c
@@ -10,6 +10,7 @@
 
 void
 bitmap_info_init(bitmap_info_t *binfo, size_t nbits) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 	size_t group_count;
 
@@ -34,15 +35,19 @@ bitmap_info_init(bitmap_info_t *binfo, size_t nbits) {
 	assert(binfo->levels[i].group_offset <= BITMAP_GROUPS_MAX);
 	binfo->nlevels = i;
 	binfo->nbits = nbits;
+	__A_VARIABLE = 1;
 }
 
 static size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return binfo->levels[binfo->nlevels].group_offset;
 }
 
 void
 bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
+	volatile int __A_VARIABLE;
 	size_t extra;
 	unsigned i;
 
@@ -54,6 +59,7 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 	if (fill) {
 		/* The "filled" bitmap starts out with all 0 bits. */
 		memset(bitmap, 0, bitmap_size(binfo));
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -78,30 +84,37 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 			bitmap[binfo->levels[i+1].group_offset - 1] >>= extra;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 #else /* BITMAP_USE_TREE */
 
 void
 bitmap_info_init(bitmap_info_t *binfo, size_t nbits) {
+	volatile int __A_VARIABLE;
 	assert(nbits > 0);
 	assert(nbits <= (ZU(1) << LG_BITMAP_MAXBITS));
 
 	binfo->ngroups = BITMAP_BITS2GROUPS(nbits);
 	binfo->nbits = nbits;
+	__A_VARIABLE = 1;
 }
 
 static size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return binfo->ngroups;
 }
 
 void
 bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
+	volatile int __A_VARIABLE;
 	size_t extra;
 
 	if (fill) {
 		memset(bitmap, 0, bitmap_size(binfo));
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -111,11 +124,14 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 	if (extra != 0) {
 		bitmap[binfo->ngroups - 1] >>= extra;
 	}
+	__A_VARIABLE = 1;
 }
 
 #endif /* BITMAP_USE_TREE */
 
 size_t
 bitmap_size(const bitmap_info_t *binfo) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (bitmap_info_ngroups(binfo) << LG_SIZEOF_BITMAP);
 }
diff --git a/deps/jemalloc/src/ckh.c b/deps/jemalloc/src/ckh.c
index e95e0a3..9cb5799 100644
--- a/deps/jemalloc/src/ckh.c
+++ b/deps/jemalloc/src/ckh.c
@@ -61,16 +61,19 @@ static void	ckh_shrink(tsd_t *tsd, ckh_t *ckh);
  */
 static size_t
 ckh_bucket_search(ckh_t *ckh, size_t bucket, const void *key) {
+	volatile int __A_VARIABLE;
 	ckhc_t *cell;
 	unsigned i;
 
 	for (i = 0; i < (ZU(1) << LG_CKH_BUCKET_CELLS); i++) {
 		cell = &ckh->tab[(bucket << LG_CKH_BUCKET_CELLS) + i];
 		if (cell->key != NULL && ckh->keycomp(key, cell->key)) {
+			__A_VARIABLE = 1;
 			return (bucket << LG_CKH_BUCKET_CELLS) + i;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return SIZE_T_MAX;
 }
 
@@ -79,6 +82,7 @@ ckh_bucket_search(ckh_t *ckh, size_t bucket, const void *key) {
  */
 static size_t
 ckh_isearch(ckh_t *ckh, const void *key) {
+	volatile int __A_VARIABLE;
 	size_t hashes[2], bucket, cell;
 
 	assert(ckh != NULL);
@@ -89,18 +93,21 @@ ckh_isearch(ckh_t *ckh, const void *key) {
 	bucket = hashes[0] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	cell = ckh_bucket_search(ckh, bucket, key);
 	if (cell != SIZE_T_MAX) {
+		__A_VARIABLE = 1;
 		return cell;
 	}
 
 	/* Search secondary bucket. */
 	bucket = hashes[1] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	cell = ckh_bucket_search(ckh, bucket, key);
+	__A_VARIABLE = 1;
 	return cell;
 }
 
 static bool
 ckh_try_bucket_insert(ckh_t *ckh, size_t bucket, const void *key,
     const void *data) {
+	volatile int __A_VARIABLE;
 	ckhc_t *cell;
 	unsigned offset, i;
 
@@ -117,10 +124,12 @@ ckh_try_bucket_insert(ckh_t *ckh, size_t bucket, const void *key,
 			cell->key = key;
 			cell->data = data;
 			ckh->count++;
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -133,6 +142,7 @@ ckh_try_bucket_insert(ckh_t *ckh, size_t bucket, const void *key,
 static bool
 ckh_evict_reloc_insert(ckh_t *ckh, size_t argbucket, void const **argkey,
     void const **argdata) {
+	volatile int __A_VARIABLE;
 	const void *key, *data, *tkey, *tdata;
 	ckhc_t *cell;
 	size_t hashes[2], bucket, tbucket;
@@ -191,18 +201,22 @@ ckh_evict_reloc_insert(ckh_t *ckh, size_t argbucket, void const **argkey,
 		if (tbucket == argbucket) {
 			*argkey = key;
 			*argdata = data;
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		bucket = tbucket;
 		if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 ckh_try_insert(ckh_t *ckh, void const**argkey, void const**argdata) {
+	volatile int __A_VARIABLE;
 	size_t hashes[2], bucket;
 	const void *key = *argkey;
 	const void *data = *argdata;
@@ -212,18 +226,21 @@ ckh_try_insert(ckh_t *ckh, void const**argkey, void const**argdata) {
 	/* Try to insert in primary bucket. */
 	bucket = hashes[0] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	/* Try to insert in secondary bucket. */
 	bucket = hashes[1] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	/*
 	 * Try to find a place for this item via iterative eviction/relocation.
 	 */
+	__A_VARIABLE = 1;
 	return ckh_evict_reloc_insert(ckh, bucket, argkey, argdata);
 }
 
@@ -233,6 +250,7 @@ ckh_try_insert(ckh_t *ckh, void const**argkey, void const**argdata) {
  */
 static bool
 ckh_rebuild(ckh_t *ckh, ckhc_t *aTab) {
+	volatile int __A_VARIABLE;
 	size_t count, i, nins;
 	const void *key, *data;
 
@@ -244,17 +262,20 @@ ckh_rebuild(ckh_t *ckh, ckhc_t *aTab) {
 			data = aTab[i].data;
 			if (ckh_try_insert(ckh, &key, &data)) {
 				ckh->count = count;
+				__A_VARIABLE = 1;
 				return true;
 			}
 			nins++;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 ckh_grow(tsd_t *tsd, ckh_t *ckh) {
+	volatile int __A_VARIABLE;
 	bool ret;
 	ckhc_t *tab, *ttab;
 	unsigned lg_prevbuckets, lg_curcells;
@@ -304,11 +325,13 @@ ckh_grow(tsd_t *tsd, ckh_t *ckh) {
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
+	volatile int __A_VARIABLE;
 	ckhc_t *tab, *ttab;
 	size_t usize;
 	unsigned lg_prevbuckets, lg_curcells;
@@ -321,6 +344,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 	lg_curcells = ckh->lg_curbuckets + LG_CKH_BUCKET_CELLS - 1;
 	usize = sz_sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
 	if (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tab = (ckhc_t *)ipallocztm(tsd_tsdn(tsd), usize, CACHELINE, true, NULL,
@@ -330,6 +354,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 		 * An OOM error isn't worth propagating, since it doesn't
 		 * prevent this or future operations from proceeding.
 		 */
+		__A_VARIABLE = 1;
 		return;
 	}
 	/* Swap in new table. */
@@ -343,6 +368,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 #ifdef CKH_COUNT
 		ckh->nshrinks++;
 #endif
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -353,11 +379,13 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 #ifdef CKH_COUNT
 	ckh->nshrinkfails++;
 #endif
+	__A_VARIABLE = 1;
 }
 
 bool
 ckh_new(tsd_t *tsd, ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
     ckh_keycomp_t *keycomp) {
+	volatile int __A_VARIABLE;
 	bool ret;
 	size_t mincells, usize;
 	unsigned lg_mincells;
@@ -409,11 +437,13 @@ ckh_new(tsd_t *tsd, ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 ckh_delete(tsd_t *tsd, ckh_t *ckh) {
+	volatile int __A_VARIABLE;
 	assert(ckh != NULL);
 
 #ifdef CKH_VERBOSE
@@ -432,17 +462,21 @@ ckh_delete(tsd_t *tsd, ckh_t *ckh) {
 	if (config_debug) {
 		memset(ckh, JEMALLOC_FREE_JUNK, sizeof(ckh_t));
 	}
+	__A_VARIABLE = 1;
 }
 
 size_t
 ckh_count(ckh_t *ckh) {
+	volatile int __A_VARIABLE;
 	assert(ckh != NULL);
 
+	__A_VARIABLE = 1;
 	return ckh->count;
 }
 
 bool
 ckh_iter(ckh_t *ckh, size_t *tabind, void **key, void **data) {
+	volatile int __A_VARIABLE;
 	size_t i, ncells;
 
 	for (i = *tabind, ncells = (ZU(1) << (ckh->lg_curbuckets +
@@ -455,15 +489,18 @@ ckh_iter(ckh_t *ckh, size_t *tabind, void **key, void **data) {
 				*data = (void *)ckh->tab[i].data;
 			}
 			*tabind = i + 1;
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
 bool
 ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data) {
+	volatile int __A_VARIABLE;
 	bool ret;
 
 	assert(ckh != NULL);
@@ -482,12 +519,14 @@ ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data) {
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 bool
 ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
     void **data) {
+	volatile int __A_VARIABLE;
 	size_t cell;
 
 	assert(ckh != NULL);
@@ -512,14 +551,17 @@ ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
 			ckh_shrink(tsd, ckh);
 		}
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
 bool
 ckh_search(ckh_t *ckh, const void *searchkey, void **key, void **data) {
+	volatile int __A_VARIABLE;
 	size_t cell;
 
 	assert(ckh != NULL);
@@ -532,27 +574,34 @@ ckh_search(ckh_t *ckh, const void *searchkey, void **key, void **data) {
 		if (data != NULL) {
 			*data = (void *)ckh->tab[cell].data;
 		}
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
 void
 ckh_string_hash(const void *key, size_t r_hash[2]) {
+	volatile int __A_VARIABLE;
 	hash(key, strlen((const char *)key), 0x94122f33U, r_hash);
+	__A_VARIABLE = 1;
 }
 
 bool
 ckh_string_keycomp(const void *k1, const void *k2) {
+	volatile int __A_VARIABLE;
 	assert(k1 != NULL);
 	assert(k2 != NULL);
 
+	__A_VARIABLE = 1;
 	return !strcmp((char *)k1, (char *)k2);
 }
 
 void
 ckh_pointer_hash(const void *key, size_t r_hash[2]) {
+	volatile int __A_VARIABLE;
 	union {
 		const void	*v;
 		size_t		i;
@@ -561,9 +610,12 @@ ckh_pointer_hash(const void *key, size_t r_hash[2]) {
 	assert(sizeof(u.v) == sizeof(u.i));
 	u.v = key;
 	hash(&u.i, sizeof(u.i), 0xd983396eU, r_hash);
+	__A_VARIABLE = 1;
 }
 
 bool
 ckh_pointer_keycomp(const void *k1, const void *k2) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (k1 == k2);
 }
diff --git a/deps/jemalloc/src/div.c b/deps/jemalloc/src/div.c
index 808892a..4d1fc1d 100644
--- a/deps/jemalloc/src/div.c
+++ b/deps/jemalloc/src/div.c
@@ -28,6 +28,7 @@
 
 void
 div_init(div_info_t *div_info, size_t d) {
+	volatile int __A_VARIABLE;
 	/* Nonsensical. */
 	assert(d != 0);
 	/*
@@ -52,4 +53,5 @@ div_init(div_info_t *div_info, size_t d) {
 #ifdef JEMALLOC_DEBUG
 	div_info->d = d;
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/extent.c b/deps/jemalloc/src/extent.c
index 09d6d77..ba21b10 100644
--- a/deps/jemalloc/src/extent.c
+++ b/deps/jemalloc/src/extent.c
@@ -160,46 +160,57 @@ extent_rtree_leaf_elm_try_lock(tsdn_t *tsdn, rtree_leaf_elm_t *elm,
  */
 static extent_t *
 extent_lock_from_addr(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, void *addr) {
+	volatile int __A_VARIABLE;
 	extent_t *ret = NULL;
 	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, &extents_rtree,
 	    rtree_ctx, (uintptr_t)addr, false, false);
 	if (elm == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	lock_result_t lock_result;
 	do {
 		lock_result = extent_rtree_leaf_elm_try_lock(tsdn, elm, &ret);
 	} while (lock_result == lock_result_failure);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 extent_t *
 extent_alloc(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsdn, &arena->extent_avail_mtx);
 	extent_t *extent = extent_avail_first(&arena->extent_avail);
 	if (extent == NULL) {
 		malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+		__A_VARIABLE = 1;
 		return base_alloc_extent(tsdn, arena->base);
 	}
 	extent_avail_remove(&arena->extent_avail, extent);
 	malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 void
 extent_dalloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsdn, &arena->extent_avail_mtx);
 	extent_avail_insert(&arena->extent_avail, extent);
 	malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 }
 
 extent_hooks_t *
 extent_hooks_get(arena_t *arena) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return base_extent_hooks_get(arena->base);
 }
 
 extent_hooks_t *
 extent_hooks_set(tsd_t *tsd, arena_t *arena, extent_hooks_t *extent_hooks) {
+	volatile int __A_VARIABLE;
 	background_thread_info_t *info;
 	if (have_background_thread) {
 		info = arena_background_thread_info_get(arena);
@@ -210,15 +221,18 @@ extent_hooks_set(tsd_t *tsd, arena_t *arena, extent_hooks_t *extent_hooks) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 extent_hooks_assure_initialized(arena_t *arena,
     extent_hooks_t **r_extent_hooks) {
+	volatile int __A_VARIABLE;
 	if (*r_extent_hooks == EXTENT_HOOKS_INITIALIZER) {
 		*r_extent_hooks = extent_hooks_get(arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 #ifndef JEMALLOC_JET
@@ -226,6 +240,7 @@ static
 #endif
 size_t
 extent_size_quantize_floor(size_t size) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	pszind_t pind;
 
@@ -240,10 +255,12 @@ extent_size_quantize_floor(size_t size) {
 		 * PAGE-spaced size classes, but it's simplest to just handle
 		 * the one case that would cause erroneous results.
 		 */
+		__A_VARIABLE = 1;
 		return size;
 	}
 	ret = sz_pind2sz(pind - 1) + sz_large_pad;
 	assert(ret <= size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -252,6 +269,7 @@ static
 #endif
 size_t
 extent_size_quantize_ceil(size_t size) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 
 	assert(size > 0);
@@ -271,6 +289,7 @@ extent_size_quantize_ceil(size_t size) {
 		ret = sz_pind2sz(sz_psz2ind(ret - sz_large_pad + 1)) +
 		    sz_large_pad;
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -280,8 +299,10 @@ ph_gen(, extent_heap_, extent_heap_t, extent_t, ph_link, extent_snad_comp)
 bool
 extents_init(tsdn_t *tsdn, extents_t *extents, extent_state_t state,
     bool delay_coalesce) {
+	volatile int __A_VARIABLE;
 	if (malloc_mutex_init(&extents->mtx, "extents", WITNESS_RANK_EXTENTS,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	for (unsigned i = 0; i < NPSIZES+1; i++) {
@@ -292,21 +313,27 @@ extents_init(tsdn_t *tsdn, extents_t *extents, extent_state_t state,
 	atomic_store_zu(&extents->npages, 0, ATOMIC_RELAXED);
 	extents->state = state;
 	extents->delay_coalesce = delay_coalesce;
+	__A_VARIABLE = 1;
 	return false;
 }
 
 extent_state_t
 extents_state_get(const extents_t *extents) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extents->state;
 }
 
 size_t
 extents_npages_get(extents_t *extents) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_zu(&extents->npages, ATOMIC_RELAXED);
 }
 
 static void
 extents_insert_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &extents->mtx);
 	assert(extent_state_get(extent) == extents->state);
 
@@ -329,10 +356,12 @@ extents_insert_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
 	    atomic_load_zu(&extents->npages, ATOMIC_RELAXED);
 	atomic_store_zu(&extents->npages, cur_extents_npages + npages,
 	    ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 extents_remove_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &extents->mtx);
 	assert(extent_state_get(extent) == extents->state);
 
@@ -355,6 +384,7 @@ extents_remove_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
 	assert(cur_extents_npages >= npages);
 	atomic_store_zu(&extents->npages,
 	    cur_extents_npages - (size >> LG_PAGE), ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -364,6 +394,7 @@ extents_remove_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
 static extent_t *
 extents_fit_alignment(extents_t *extents, size_t min_size, size_t max_size,
     size_t alignment) {
+        volatile int __A_VARIABLE;
         pszind_t pind = sz_psz2ind(extent_size_quantize_ceil(min_size));
         pszind_t pind_max = sz_psz2ind(extent_size_quantize_ceil(max_size));
 
@@ -387,10 +418,12 @@ extents_fit_alignment(extents_t *extents, size_t min_size, size_t max_size,
 
 		size_t leadsize = next_align - base;
 		if (candidate_size - leadsize >= min_size) {
+			__A_VARIABLE = 1;
 			return extent;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -398,6 +431,7 @@ extents_fit_alignment(extents_t *extents, size_t min_size, size_t max_size,
 static extent_t *
 extents_best_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     size_t size) {
+	volatile int __A_VARIABLE;
 	pszind_t pind = sz_psz2ind(extent_size_quantize_ceil(size));
 	pszind_t i = (pszind_t)bitmap_ffu(extents->bitmap, &extents_bitmap_info,
 	    (size_t)pind);
@@ -407,14 +441,17 @@ extents_best_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		 * large extents for much smaller sizes.
 		 */
 		if ((sz_pind2sz(i) >> opt_lg_extent_max_active_fit) > size) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		assert(!extent_heap_empty(&extents->heaps[i]));
 		extent_t *extent = extent_heap_first(&extents->heaps[i]);
 		assert(extent_size_get(extent) >= size);
+		__A_VARIABLE = 1;
 		return extent;
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -425,6 +462,7 @@ extents_best_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 static extent_t *
 extents_first_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     size_t size) {
+	volatile int __A_VARIABLE;
 	extent_t *ret = NULL;
 
 	pszind_t pind = sz_psz2ind(extent_size_quantize_ceil(size));
@@ -444,6 +482,7 @@ extents_first_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		assert(i < NPSIZES);
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -456,11 +495,13 @@ extents_first_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 static extent_t *
 extents_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     size_t esize, size_t alignment) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &extents->mtx);
 
 	size_t max_size = esize + PAGE_CEILING(alignment) - PAGE;
 	/* Beware size_t wrap-around. */
 	if (max_size < esize) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -478,6 +519,7 @@ extents_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		    alignment);
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -485,6 +527,7 @@ static bool
 extent_try_delayed_coalesce(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,
     extent_t *extent) {
+	volatile int __A_VARIABLE;
 	extent_state_set(extent, extent_state_active);
 	bool coalesced;
 	extent = extent_try_coalesce(tsdn, arena, r_extent_hooks, rtree_ctx,
@@ -492,9 +535,11 @@ extent_try_delayed_coalesce(tsdn_t *tsdn, arena_t *arena,
 	extent_state_set(extent, extents_state_get(extents));
 
 	if (!coalesced) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	extents_insert_locked(tsdn, extents, extent);
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -502,6 +547,7 @@ extent_t *
 extents_alloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, void *new_addr, size_t size, size_t pad,
     size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	assert(size + pad != 0);
 	assert(alignment != 0);
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
@@ -510,12 +556,14 @@ extents_alloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_t *extent = extent_recycle(tsdn, arena, r_extent_hooks, extents,
 	    new_addr, size, pad, alignment, slab, szind, zero, commit, false);
 	assert(extent == NULL || extent_dumpable_get(extent));
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 void
 extents_dalloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	assert(extent_base_get(extent) != NULL);
 	assert(extent_size_get(extent) != 0);
 	assert(extent_dumpable_get(extent));
@@ -526,11 +574,13 @@ extents_dalloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_zeroed_set(extent, false);
 
 	extent_record(tsdn, arena, r_extent_hooks, extents, extent, false);
+	__A_VARIABLE = 1;
 }
 
 extent_t *
 extents_evict(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, size_t npages_min) {
+	volatile int __A_VARIABLE;
 	rtree_ctx_t rtree_ctx_fallback;
 	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
 
@@ -589,12 +639,14 @@ extents_evict(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 
 label_return:
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 static void
 extents_leak(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, extent_t *extent, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Leak extent after making sure its pages have already been purged, so
 	 * that this is only a virtual memory leak.
@@ -608,58 +660,73 @@ extents_leak(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		}
 	}
 	extent_dalloc(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_prefork(tsdn_t *tsdn, extents_t *extents) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_prefork(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_postfork_parent(tsdn_t *tsdn, extents_t *extents) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_parent(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_postfork_child(tsdn_t *tsdn, extents_t *extents) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_postfork_child(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deactivate_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     extent_t *extent) {
+	volatile int __A_VARIABLE;
 	assert(extent_arena_get(extent) == arena);
 	assert(extent_state_get(extent) == extent_state_active);
 
 	extent_state_set(extent, extents_state_get(extents));
 	extents_insert_locked(tsdn, extents, extent);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deactivate(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     extent_t *extent) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsdn, &extents->mtx);
 	extent_deactivate_locked(tsdn, arena, extents, extent);
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_activate_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
     extent_t *extent) {
+	volatile int __A_VARIABLE;
 	assert(extent_arena_get(extent) == arena);
 	assert(extent_state_get(extent) == extents_state_get(extents));
 
 	extents_remove_locked(tsdn, extents, extent);
 	extent_state_set(extent, extent_state_active);
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_rtree_leaf_elms_lookup(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
     const extent_t *extent, bool dependent, bool init_missing,
     rtree_leaf_elm_t **r_elm_a, rtree_leaf_elm_t **r_elm_b) {
+	volatile int __A_VARIABLE;
 	*r_elm_a = rtree_leaf_elm_lookup(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)extent_base_get(extent), dependent, init_missing);
 	if (!dependent && *r_elm_a == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(*r_elm_a != NULL);
@@ -667,26 +734,31 @@ extent_rtree_leaf_elms_lookup(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
 	*r_elm_b = rtree_leaf_elm_lookup(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)extent_last_get(extent), dependent, init_missing);
 	if (!dependent && *r_elm_b == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(*r_elm_b != NULL);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static void
 extent_rtree_write_acquired(tsdn_t *tsdn, rtree_leaf_elm_t *elm_a,
     rtree_leaf_elm_t *elm_b, extent_t *extent, szind_t szind, bool slab) {
+	volatile int __A_VARIABLE;
 	rtree_leaf_elm_write(tsdn, &extents_rtree, elm_a, extent, szind, slab);
 	if (elm_b != NULL) {
 		rtree_leaf_elm_write(tsdn, &extents_rtree, elm_b, extent, szind,
 		    slab);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_interior_register(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, extent_t *extent,
     szind_t szind) {
+	volatile int __A_VARIABLE;
 	assert(extent_slab_get(extent));
 
 	/* Register interior. */
@@ -695,10 +767,12 @@ extent_interior_register(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, extent_t *extent,
 		    (uintptr_t)extent_base_get(extent) + (uintptr_t)(i <<
 		    LG_PAGE), extent, szind, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_gdump_add(tsdn_t *tsdn, const extent_t *extent) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	/* prof_gdump() requirement. */
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
@@ -721,10 +795,12 @@ extent_gdump_add(tsdn_t *tsdn, const extent_t *extent) {
 			prof_gdump(tsdn);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_gdump_sub(tsdn_t *tsdn, const extent_t *extent) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	if (opt_prof && extent_state_get(extent) == extent_state_active) {
@@ -732,10 +808,12 @@ extent_gdump_sub(tsdn_t *tsdn, const extent_t *extent) {
 		assert(atomic_load_zu(&curpages, ATOMIC_RELAXED) >= nsub);
 		atomic_fetch_sub_zu(&curpages, nsub, ATOMIC_RELAXED);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_register_impl(tsdn_t *tsdn, extent_t *extent, bool gdump_add) {
+	volatile int __A_VARIABLE;
 	rtree_ctx_t rtree_ctx_fallback;
 	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
 	rtree_leaf_elm_t *elm_a, *elm_b;
@@ -748,6 +826,7 @@ extent_register_impl(tsdn_t *tsdn, extent_t *extent, bool gdump_add) {
 
 	if (extent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, extent, false, true,
 	    &elm_a, &elm_b)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -764,23 +843,30 @@ extent_register_impl(tsdn_t *tsdn, extent_t *extent, bool gdump_add) {
 		extent_gdump_add(tsdn, extent);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 extent_register(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_register_impl(tsdn, extent, true);
 }
 
 static bool
 extent_register_no_gdump_add(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_register_impl(tsdn, extent, false);
 }
 
 static void
 extent_reregister(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	bool err = extent_register(tsdn, extent);
 	assert(!err);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -793,6 +879,7 @@ extent_reregister(tsdn_t *tsdn, extent_t *extent) {
 static void
 extent_interior_deregister(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
     extent_t *extent) {
+	volatile int __A_VARIABLE;
 	size_t i;
 
 	assert(extent_slab_get(extent));
@@ -802,6 +889,7 @@ extent_interior_deregister(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
 		    (uintptr_t)extent_base_get(extent) + (uintptr_t)(i <<
 		    LG_PAGE));
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -809,6 +897,7 @@ extent_interior_deregister(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
  */
 static void
 extent_deregister_impl(tsdn_t *tsdn, extent_t *extent, bool gdump) {
+	volatile int __A_VARIABLE;
 	rtree_ctx_t rtree_ctx_fallback;
 	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
 	rtree_leaf_elm_t *elm_a, *elm_b;
@@ -828,16 +917,21 @@ extent_deregister_impl(tsdn_t *tsdn, extent_t *extent, bool gdump) {
 	if (config_prof && gdump) {
 		extent_gdump_sub(tsdn, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deregister(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	extent_deregister_impl(tsdn, extent, true);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deregister_no_gdump_sub(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	extent_deregister_impl(tsdn, extent, false);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -849,6 +943,7 @@ extent_recycle_extract(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,
     void *new_addr, size_t size, size_t pad, size_t alignment, bool slab,
     bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 	assert(alignment > 0);
@@ -896,12 +991,14 @@ extent_recycle_extract(tsdn_t *tsdn, arena_t *arena,
 	}
 	if (extent == NULL) {
 		malloc_mutex_unlock(tsdn, &extents->mtx);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	extent_activate_locked(tsdn, arena, extents, extent);
 	malloc_mutex_unlock(tsdn, &extents->mtx);
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -940,11 +1037,13 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
     extent_t **to_leak, extent_t **to_salvage,
     void *new_addr, size_t size, size_t pad, size_t alignment, bool slab,
     szind_t szind, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	size_t esize = size + pad;
 	size_t leadsize = ALIGNMENT_CEILING((uintptr_t)extent_base_get(*extent),
 	    PAGE_CEILING(alignment)) - (uintptr_t)extent_base_get(*extent);
 	assert(new_addr == NULL || leadsize == 0);
 	if (extent_size_get(*extent) < leadsize + esize) {
+		__A_VARIABLE = 1;
 		return extent_split_interior_cant_alloc;
 	}
 	size_t trailsize = extent_size_get(*extent) - leadsize - esize;
@@ -963,6 +1062,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 		if (*extent == NULL) {
 			*to_leak = *lead;
 			*lead = NULL;
+			__A_VARIABLE = 1;
 			return extent_split_interior_error;
 		}
 	}
@@ -977,6 +1077,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 			*to_salvage = *lead;
 			*lead = NULL;
 			*extent = NULL;
+			__A_VARIABLE = 1;
 			return extent_split_interior_error;
 		}
 	}
@@ -999,6 +1100,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return extent_split_interior_ok;
 }
 
@@ -1062,6 +1164,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, void *new_addr, size_t size, size_t pad,
     size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit,
     bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 	assert(new_addr == NULL || !slab);
@@ -1075,6 +1178,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	    rtree_ctx, extents, new_addr, size, pad, alignment, slab,
 	    growing_retained);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1082,6 +1186,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	    extents, new_addr, size, pad, alignment, slab, szind, extent,
 	    growing_retained);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1090,6 +1195,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		    0, extent_size_get(extent), growing_retained)) {
 			extent_record(tsdn, arena, r_extent_hooks, extents,
 			    extent, growing_retained);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		extent_zeroed_set(extent, true);
@@ -1125,6 +1231,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 			}
 		}
 	}
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1137,6 +1244,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 static void *
 extent_alloc_core(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
     size_t alignment, bool *zero, bool *commit, dss_prec_t dss_prec) {
+	volatile int __A_VARIABLE;
 	void *ret;
 
 	assert(size != 0);
@@ -1146,39 +1254,46 @@ extent_alloc_core(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 	if (have_dss && dss_prec == dss_prec_primary && (ret =
 	    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
 	    commit)) != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	/* mmap. */
 	if ((ret = extent_alloc_mmap(new_addr, size, alignment, zero, commit))
 	    != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	/* "secondary" dss. */
 	if (have_dss && dss_prec == dss_prec_secondary && (ret =
 	    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
 	    commit)) != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 
 	/* All strategies for allocation failed. */
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static void *
 extent_alloc_default_impl(tsdn_t *tsdn, arena_t *arena, void *new_addr,
     size_t size, size_t alignment, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	void *ret = extent_alloc_core(tsdn, arena, new_addr, size, alignment, zero,
 	    commit, (dss_prec_t)atomic_load_u(&arena->dss_prec,
 	    ATOMIC_RELAXED));
 	if (have_madvise_huge && ret) {
 		pages_set_thp_state(ret, size);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void *
 extent_alloc_default(extent_hooks_t *extent_hooks, void *new_addr, size_t size,
     size_t alignment, bool *zero, bool *commit, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn;
 	arena_t *arena;
 
@@ -1190,12 +1305,14 @@ extent_alloc_default(extent_hooks_t *extent_hooks, void *new_addr, size_t size,
 	 */
 	assert(arena != NULL);
 
+	__A_VARIABLE = 1;
 	return extent_alloc_default_impl(tsdn, arena, new_addr, size,
 	    alignment, zero, commit);
 }
 
 static void
 extent_hook_pre_reentrancy(tsdn_t *tsdn, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd = tsdn_null(tsdn) ? tsd_fetch() : tsdn_tsd(tsdn);
 	if (arena == arena_get(tsd_tsdn(tsd), 0, false)) {
 		/*
@@ -1209,12 +1326,15 @@ extent_hook_pre_reentrancy(tsdn_t *tsdn, arena_t *arena) {
 	} else {
 		pre_reentrancy(tsd, arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_hook_post_reentrancy(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd = tsdn_null(tsdn) ? tsd_fetch() : tsdn_tsd(tsdn);
 	post_reentrancy(tsd);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -1226,6 +1346,7 @@ static extent_t *
 extent_grow_retained(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, size_t size, size_t pad, size_t alignment,
     bool slab, szind_t szind, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &arena->extent_grow_mtx);
 	assert(pad == 0 || !slab);
 	assert(!*zero || !slab);
@@ -1380,9 +1501,11 @@ extent_grow_retained(tsdn_t *tsdn, arena_t *arena,
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 label_err:
 	malloc_mutex_unlock(tsdn, &arena->extent_grow_mtx);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1390,6 +1513,7 @@ static extent_t *
 extent_alloc_retained(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, void *new_addr, size_t size, size_t pad,
     size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	assert(size != 0);
 	assert(alignment != 0);
 
@@ -1412,6 +1536,7 @@ extent_alloc_retained(tsdn_t *tsdn, arena_t *arena,
 	}
 	malloc_mutex_assert_not_owner(tsdn, &arena->extent_grow_mtx);
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1419,9 +1544,11 @@ static extent_t *
 extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, void *new_addr, size_t size, size_t pad,
     size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	size_t esize = size + pad;
 	extent_t *extent = extent_alloc(tsdn, arena);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	void *addr;
@@ -1437,6 +1564,7 @@ extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
 	}
 	if (addr == NULL) {
 		extent_dalloc(tsdn, arena, extent);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	extent_init(extent, arena, addr, esize, slab, szind,
@@ -1448,9 +1576,11 @@ extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
 	if (extent_register(tsdn, extent)) {
 		extents_leak(tsdn, arena, r_extent_hooks,
 		    &arena->extents_retained, extent, false);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1458,6 +1588,7 @@ extent_t *
 extent_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, void *new_addr, size_t size, size_t pad,
     size_t alignment, bool slab, szind_t szind, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
 
@@ -1473,6 +1604,7 @@ extent_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 			 * that is very unlikely to succeed (unless it happens
 			 * to be at the end).
 			 */
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,
@@ -1480,26 +1612,32 @@ extent_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	assert(extent == NULL || extent_dumpable_get(extent));
+	__A_VARIABLE = 1;
 	return extent;
 }
 
 static bool
 extent_can_coalesce(arena_t *arena, extents_t *extents, const extent_t *inner,
     const extent_t *outer) {
+	volatile int __A_VARIABLE;
 	assert(extent_arena_get(inner) == arena);
 	if (extent_arena_get(outer) != arena) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	assert(extent_state_get(inner) == extent_state_active);
 	if (extent_state_get(outer) != extents->state) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	if (extent_committed_get(inner) != extent_committed_get(outer)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -1507,6 +1645,7 @@ static bool
 extent_coalesce(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, extent_t *inner, extent_t *outer, bool forward,
     bool growing_retained) {
+	volatile int __A_VARIABLE;
 	assert(extent_can_coalesce(arena, extents, inner, outer));
 
 	extent_activate_locked(tsdn, arena, extents, outer);
@@ -1520,6 +1659,7 @@ extent_coalesce(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		extent_deactivate_locked(tsdn, arena, extents, outer);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1527,6 +1667,7 @@ static extent_t *
 extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, rtree_ctx_t *rtree_ctx, extents_t *extents,
     extent_t *extent, bool *coalesced, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Continue attempting to coalesce until failure, to protect against
 	 * races with other threads that are thwarted by this one.
@@ -1555,6 +1696,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 				if (extents->delay_coalesce) {
 					/* Do minimal coalescing. */
 					*coalesced = true;
+					__A_VARIABLE = 1;
 					return extent;
 				}
 				again = true;
@@ -1576,6 +1718,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 				if (extents->delay_coalesce) {
 					/* Do minimal coalescing. */
 					*coalesced = true;
+					__A_VARIABLE = 1;
 					return extent;
 				}
 				again = true;
@@ -1586,6 +1729,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 	if (extents->delay_coalesce) {
 		*coalesced = false;
 	}
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1596,6 +1740,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 static void
 extent_record(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
     extents_t *extents, extent_t *extent, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	rtree_ctx_t rtree_ctx_fallback;
 	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
 
@@ -1634,10 +1779,12 @@ extent_record(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_deactivate_locked(tsdn, arena, extents, extent);
 
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 extent_dalloc_gap(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
@@ -1646,28 +1793,36 @@ extent_dalloc_gap(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 	if (extent_register(tsdn, extent)) {
 		extents_leak(tsdn, arena, &extent_hooks,
 		    &arena->extents_retained, extent, false);
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_dalloc_wrapper(tsdn, arena, &extent_hooks, extent);
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_dalloc_default_impl(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (!have_dss || !extent_in_dss(addr)) {
+		__A_VARIABLE = 1;
 		return extent_dalloc_mmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 extent_dalloc_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     bool committed, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_dalloc_default_impl(addr, size);
 }
 
 static bool
 extent_dalloc_wrapper_try(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	bool err;
 
 	assert(extent_base_get(extent) != NULL);
@@ -1696,12 +1851,14 @@ extent_dalloc_wrapper_try(tsdn_t *tsdn, arena_t *arena,
 		extent_dalloc(tsdn, arena, extent);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
 void
 extent_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	assert(extent_dumpable_get(extent));
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
@@ -1712,6 +1869,7 @@ extent_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 	 */
 	extent_deregister(tsdn, extent);
 	if (!extent_dalloc_wrapper_try(tsdn, arena, r_extent_hooks, extent)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1751,24 +1909,30 @@ extent_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 
 	extent_record(tsdn, arena, r_extent_hooks, &arena->extents_retained,
 	    extent, false);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_destroy_default_impl(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (!have_dss || !extent_in_dss(addr)) {
 		pages_unmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_destroy_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     bool committed, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	extent_destroy_default_impl(addr, size);
+	__A_VARIABLE = 1;
 }
 
 void
 extent_destroy_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	assert(extent_base_get(extent) != NULL);
 	assert(extent_size_get(extent) != 0);
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
@@ -1794,11 +1958,14 @@ extent_destroy_wrapper(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	extent_dalloc(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_commit_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t offset, size_t length, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_commit((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1807,6 +1974,7 @@ static bool
 extent_commit_impl(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 
@@ -1821,6 +1989,7 @@ extent_commit_impl(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 	extent_committed_set(extent, extent_committed_get(extent) || !err);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1828,6 +1997,8 @@ bool
 extent_commit_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_commit_impl(tsdn, arena, r_extent_hooks, extent, offset,
 	    length, false);
 }
@@ -1835,6 +2006,8 @@ extent_commit_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_decommit_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t offset, size_t length, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_decommit((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1843,6 +2016,7 @@ bool
 extent_decommit_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, 0);
 
@@ -1859,6 +2033,7 @@ extent_decommit_wrapper(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 	extent_committed_set(extent, extent_committed_get(extent) && err);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1866,11 +2041,13 @@ extent_decommit_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_purge_lazy_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t offset, size_t length, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	assert(addr != NULL);
 	assert((offset & PAGE_MASK) == 0);
 	assert(length != 0);
 	assert((length & PAGE_MASK) == 0);
 
+	__A_VARIABLE = 1;
 	return pages_purge_lazy((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1880,12 +2057,14 @@ static bool
 extent_purge_lazy_impl(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->purge_lazy == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (*r_extent_hooks != &extent_hooks_default) {
@@ -1898,6 +2077,7 @@ extent_purge_lazy_impl(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1905,6 +2085,8 @@ bool
 extent_purge_lazy_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_purge_lazy_impl(tsdn, arena, r_extent_hooks, extent,
 	    offset, length, false);
 }
@@ -1913,11 +2095,13 @@ extent_purge_lazy_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_purge_forced_default(extent_hooks_t *extent_hooks, void *addr,
     size_t size, size_t offset, size_t length, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	assert(addr != NULL);
 	assert((offset & PAGE_MASK) == 0);
 	assert(length != 0);
 	assert((length & PAGE_MASK) == 0);
 
+	__A_VARIABLE = 1;
 	return pages_purge_forced((void *)((uintptr_t)addr +
 	    (uintptr_t)offset), length);
 }
@@ -1927,12 +2111,14 @@ static bool
 extent_purge_forced_impl(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length, bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->purge_forced == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (*r_extent_hooks != &extent_hooks_default) {
@@ -1944,6 +2130,7 @@ extent_purge_forced_impl(tsdn_t *tsdn, arena_t *arena,
 	if (*r_extent_hooks != &extent_hooks_default) {
 		extent_hook_post_reentrancy(tsdn);
 	}
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1951,6 +2138,8 @@ bool
 extent_purge_forced_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_purge_forced_impl(tsdn, arena, r_extent_hooks, extent,
 	    offset, length, false);
 }
@@ -1959,6 +2148,8 @@ extent_purge_forced_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_split_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t size_a, size_t size_b, bool committed, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return !maps_coalesce;
 }
 #endif
@@ -1975,6 +2166,7 @@ extent_split_impl(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t size_a,
     szind_t szind_a, bool slab_a, size_t size_b, szind_t szind_b, bool slab_b,
     bool growing_retained) {
+	volatile int __A_VARIABLE;
 	assert(extent_size_get(extent) == size_a + size_b);
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
@@ -1982,6 +2174,7 @@ extent_split_impl(tsdn_t *tsdn, arena_t *arena,
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->split == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -2043,12 +2236,14 @@ extent_split_impl(tsdn_t *tsdn, arena_t *arena,
 
 	extent_unlock2(tsdn, extent, trail);
 
+	__A_VARIABLE = 1;
 	return trail;
 label_error_c:
 	extent_unlock2(tsdn, extent, trail);
 label_error_b:
 	extent_dalloc(tsdn, arena, trail);
 label_error_a:
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -2056,19 +2251,25 @@ extent_t *
 extent_split_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t size_a,
     szind_t szind_a, bool slab_a, size_t size_b, szind_t szind_b, bool slab_b) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_split_impl(tsdn, arena, r_extent_hooks, extent, size_a,
 	    szind_a, slab_a, size_b, szind_b, slab_b, false);
 }
 
 static bool
 extent_merge_default_impl(void *addr_a, void *addr_b) {
+	volatile int __A_VARIABLE;
 	if (!maps_coalesce) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (have_dss && !extent_dss_mergeable(addr_a, addr_b)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -2076,6 +2277,8 @@ extent_merge_default_impl(void *addr_a, void *addr_b) {
 static bool
 extent_merge_default(extent_hooks_t *extent_hooks, void *addr_a, size_t size_a,
     void *addr_b, size_t size_b, bool committed, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_merge_default_impl(addr_a, addr_b);
 }
 #endif
@@ -2084,12 +2287,14 @@ static bool
 extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *a, extent_t *b,
     bool growing_retained) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth_to_rank(tsdn_witness_tsdp_get(tsdn),
 	    WITNESS_RANK_CORE, growing_retained ? 1 : 0);
 
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->merge == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2108,6 +2313,7 @@ extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	if (err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2149,23 +2355,29 @@ extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
 
 	extent_dalloc(tsdn, extent_arena_get(b), b);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 extent_merge_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *a, extent_t *b) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_merge_impl(tsdn, arena, r_extent_hooks, a, b, false);
 }
 
 bool
 extent_boot(void) {
+	volatile int __A_VARIABLE;
 	if (rtree_new(&extents_rtree, true)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	if (mutex_pool_init(&extent_mutex_pool, "extent_mutex_pool",
 	    WITNESS_RANK_EXTENT_POOL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2173,5 +2385,6 @@ extent_boot(void) {
 		extent_dss_boot();
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/extent_dss.c b/deps/jemalloc/src/extent_dss.c
index 2b1ea9c..f4268e3 100644
--- a/deps/jemalloc/src/extent_dss.c
+++ b/deps/jemalloc/src/extent_dss.c
@@ -50,26 +50,33 @@ extent_dss_sbrk(intptr_t increment) {
 
 dss_prec_t
 extent_dss_prec_get(void) {
+	volatile int __A_VARIABLE;
 	dss_prec_t ret;
 
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return dss_prec_disabled;
 	}
 	ret = (dss_prec_t)atomic_load_u(&dss_prec_default, ATOMIC_ACQUIRE);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 bool
 extent_dss_prec_set(dss_prec_t dss_prec) {
+	volatile int __A_VARIABLE;
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return (dss_prec != dss_prec_disabled);
 	}
 	atomic_store_u(&dss_prec_default, (unsigned)dss_prec, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static void
 extent_dss_extending_start(void) {
+	volatile int __A_VARIABLE;
 	spin_t spinner = SPIN_INITIALIZER;
 	while (true) {
 		bool expected = false;
@@ -79,36 +86,44 @@ extent_dss_extending_start(void) {
 		}
 		spin_adaptive(&spinner);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_dss_extending_finish(void) {
+	volatile int __A_VARIABLE;
 	assert(atomic_load_b(&dss_extending, ATOMIC_RELAXED));
 
 	atomic_store_b(&dss_extending, false, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void *
 extent_dss_max_update(void *new_addr) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Get the current end of the DSS as max_cur and assure that dss_max is
 	 * up to date.
 	 */
 	void *max_cur = extent_dss_sbrk(0);
 	if (max_cur == (void *)-1) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	atomic_store_p(&dss_max, max_cur, ATOMIC_RELEASE);
 	/* Fixed new_addr can only be supported if it is at the edge of DSS. */
 	if (new_addr != NULL && max_cur != new_addr) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
+	__A_VARIABLE = 1;
 	return max_cur;
 }
 
 void *
 extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
     size_t alignment, bool *zero, bool *commit) {
+	volatile int __A_VARIABLE;
 	extent_t *gap;
 
 	cassert(have_dss);
@@ -120,11 +135,13 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 	 * interpret a large allocation request as a negative increment.
 	 */
 	if ((intptr_t)size < 0) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	gap = extent_alloc(tsdn, arena);
 	if (gap == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -207,6 +224,7 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 						memset(ret, 0, size);
 					}
 				}
+				__A_VARIABLE = 1;
 				return ret;
 			}
 			/*
@@ -224,47 +242,57 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 label_oom:
 	extent_dss_extending_finish();
 	extent_dalloc(tsdn, arena, gap);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static bool
 extent_in_dss_helper(void *addr, void *max) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return ((uintptr_t)addr >= (uintptr_t)dss_base && (uintptr_t)addr <
 	    (uintptr_t)max);
 }
 
 bool
 extent_in_dss(void *addr) {
+	volatile int __A_VARIABLE;
 	cassert(have_dss);
 
+	__A_VARIABLE = 1;
 	return extent_in_dss_helper(addr, atomic_load_p(&dss_max,
 	    ATOMIC_ACQUIRE));
 }
 
 bool
 extent_dss_mergeable(void *addr_a, void *addr_b) {
+	volatile int __A_VARIABLE;
 	void *max;
 
 	cassert(have_dss);
 
 	if ((uintptr_t)addr_a < (uintptr_t)dss_base && (uintptr_t)addr_b <
 	    (uintptr_t)dss_base) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	max = atomic_load_p(&dss_max, ATOMIC_ACQUIRE);
+	__A_VARIABLE = 1;
 	return (extent_in_dss_helper(addr_a, max) ==
 	    extent_in_dss_helper(addr_b, max));
 }
 
 void
 extent_dss_boot(void) {
+	volatile int __A_VARIABLE;
 	cassert(have_dss);
 
 	dss_base = extent_dss_sbrk(0);
 	atomic_store_b(&dss_extending, false, ATOMIC_RELAXED);
 	atomic_store_b(&dss_exhausted, dss_base == (void *)-1, ATOMIC_RELAXED);
 	atomic_store_p(&dss_max, dss_base, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
diff --git a/deps/jemalloc/src/extent_mmap.c b/deps/jemalloc/src/extent_mmap.c
index 8d607dc..cbc599e 100644
--- a/deps/jemalloc/src/extent_mmap.c
+++ b/deps/jemalloc/src/extent_mmap.c
@@ -21,22 +21,27 @@ bool	opt_retain =
 void *
 extent_alloc_mmap(void *new_addr, size_t size, size_t alignment, bool *zero,
     bool *commit) {
+	volatile int __A_VARIABLE;
 	void *ret = pages_map(new_addr, size, ALIGNMENT_CEILING(alignment,
 	    PAGE), commit);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	assert(ret != NULL);
 	if (*commit) {
 		*zero = true;
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 bool
 extent_dalloc_mmap(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (!opt_retain) {
 		pages_unmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 	return opt_retain;
 }
diff --git a/deps/jemalloc/src/jemalloc.c b/deps/jemalloc/src/jemalloc.c
index 5b936cb..9718faa 100644
--- a/deps/jemalloc/src/jemalloc.c
+++ b/deps/jemalloc/src/jemalloc.c
@@ -133,6 +133,7 @@ static bool init_lock_initialized = false;
 JEMALLOC_ATTR(constructor)
 static void WINAPI
 _init_init_lock(void) {
+	volatile int __A_VARIABLE;
 	/*
 	 * If another constructor in the same binary is using mallctl to e.g.
 	 * set up extent hooks, it may end up running before this one, and
@@ -148,6 +149,7 @@ _init_init_lock(void) {
 		    malloc_mutex_rank_exclusive);
 	}
 	init_lock_initialized = true;
+	__A_VARIABLE = 1;
 }
 
 #ifdef _MSC_VER
@@ -201,22 +203,30 @@ static bool	malloc_init_hard(void);
 
 bool
 malloc_initialized(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (malloc_init_state == malloc_init_initialized);
 }
 
 JEMALLOC_ALWAYS_INLINE bool
 malloc_init_a0(void) {
+	volatile int __A_VARIABLE;
 	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
+		__A_VARIABLE = 1;
 		return malloc_init_hard_a0();
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 JEMALLOC_ALWAYS_INLINE bool
 malloc_init(void) {
+	volatile int __A_VARIABLE;
 	if (unlikely(!malloc_initialized()) && malloc_init_hard()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -227,27 +237,36 @@ malloc_init(void) {
 
 static void *
 a0ialloc(size_t size, bool zero, bool is_internal) {
+	volatile int __A_VARIABLE;
 	if (unlikely(malloc_init_a0())) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,
 	    is_internal, arena_get(TSDN_NULL, 0, true), true);
 }
 
 static void
 a0idalloc(void *ptr, bool is_internal) {
+	volatile int __A_VARIABLE;
 	idalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);
+	__A_VARIABLE = 1;
 }
 
 void *
 a0malloc(size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return a0ialloc(size, false, true);
 }
 
 void
 a0dalloc(void *ptr) {
+	volatile int __A_VARIABLE;
 	a0idalloc(ptr, true);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -258,15 +277,18 @@ a0dalloc(void *ptr) {
 
 void *
 bootstrap_malloc(size_t size) {
+	volatile int __A_VARIABLE;
 	if (unlikely(size == 0)) {
 		size = 1;
 	}
 
+	__A_VARIABLE = 1;
 	return a0ialloc(size, false, false);
 }
 
 void *
 bootstrap_calloc(size_t num, size_t size) {
+	volatile int __A_VARIABLE;
 	size_t num_size;
 
 	num_size = num * size;
@@ -275,45 +297,59 @@ bootstrap_calloc(size_t num, size_t size) {
 		num_size = 1;
 	}
 
+	__A_VARIABLE = 1;
 	return a0ialloc(num_size, true, false);
 }
 
 void
 bootstrap_free(void *ptr) {
+	volatile int __A_VARIABLE;
 	if (unlikely(ptr == NULL)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	a0idalloc(ptr, false);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_set(unsigned ind, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	atomic_store_p(&arenas[ind], arena, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void
 narenas_total_set(unsigned narenas) {
+	volatile int __A_VARIABLE;
 	atomic_store_u(&narenas_total, narenas, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void
 narenas_total_inc(void) {
+	volatile int __A_VARIABLE;
 	atomic_fetch_add_u(&narenas_total, 1, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 unsigned
 narenas_total_get(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return atomic_load_u(&narenas_total, ATOMIC_ACQUIRE);
 }
 
 /* Create a new arena and insert it into the arenas array at index ind. */
 static arena_t *
 arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
+	volatile int __A_VARIABLE;
 	arena_t *arena;
 
 	assert(ind <= narenas_total_get());
 	if (ind >= MALLOCX_ARENA_LIMIT) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	if (ind == narenas_total_get()) {
@@ -327,18 +363,22 @@ arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	arena = arena_get(tsdn, ind, false);
 	if (arena != NULL) {
 		assert(ind < narenas_auto);
+		__A_VARIABLE = 1;
 		return arena;
 	}
 
 	/* Actually initialize the arena. */
 	arena = arena_new(tsdn, ind, extent_hooks);
 
+	__A_VARIABLE = 1;
 	return arena;
 }
 
 static void
 arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
+	volatile int __A_VARIABLE;
 	if (ind == 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (have_background_thread) {
@@ -352,10 +392,12 @@ arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 arena_t *
 arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
+	volatile int __A_VARIABLE;
 	arena_t *arena;
 
 	malloc_mutex_lock(tsdn, &arenas_lock);
@@ -364,11 +406,13 @@ arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 
 	arena_new_create_background_thread(tsdn, ind);
 
+	__A_VARIABLE = 1;
 	return arena;
 }
 
 static void
 arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
+	volatile int __A_VARIABLE;
 	arena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);
 	arena_nthreads_inc(arena, internal);
 
@@ -377,10 +421,12 @@ arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
 	} else {
 		tsd_arena_set(tsd, arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
+	volatile int __A_VARIABLE;
 	arena_t *oldarena, *newarena;
 
 	oldarena = arena_get(tsd_tsdn(tsd), oldind, false);
@@ -388,10 +434,12 @@ arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
 	arena_nthreads_dec(oldarena, false);
 	arena_nthreads_inc(newarena, false);
 	tsd_arena_set(tsd, newarena);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
+	volatile int __A_VARIABLE;
 	arena_t *arena;
 
 	arena = arena_get(tsd_tsdn(tsd), ind, false);
@@ -402,10 +450,12 @@ arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
 	} else {
 		tsd_arena_set(tsd, NULL);
 	}
+	__A_VARIABLE = 1;
 }
 
 arena_tdata_t *
 arena_tdata_get_hard(tsd_t *tsd, unsigned ind) {
+	volatile int __A_VARIABLE;
 	arena_tdata_t *tdata, *arenas_tdata_old;
 	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
 	unsigned narenas_tdata_old, i;
@@ -477,6 +527,7 @@ label_return:
 	if (arenas_tdata_old != NULL) {
 		a0dalloc(arenas_tdata_old);
 	}
+	__A_VARIABLE = 1;
 	return tdata;
 }
 
@@ -597,26 +648,31 @@ arena_choose_hard(tsd_t *tsd, bool internal) {
 
 void
 iarena_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	arena_t *iarena;
 
 	iarena = tsd_iarena_get(tsd);
 	if (iarena != NULL) {
 		arena_unbind(tsd, arena_ind_get(iarena), true);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	arena_t *arena;
 
 	arena = tsd_arena_get(tsd);
 	if (arena != NULL) {
 		arena_unbind(tsd, arena_ind_get(arena), false);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arenas_tdata_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	arena_tdata_t *arenas_tdata;
 
 	/* Prevent tsd->arenas_tdata from being (re)created. */
@@ -627,10 +683,12 @@ arenas_tdata_cleanup(tsd_t *tsd) {
 		tsd_arenas_tdata_set(tsd, NULL);
 		a0dalloc(arenas_tdata);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_print_atexit(void) {
+	volatile int __A_VARIABLE;
 	if (config_stats) {
 		tsdn_t *tsdn;
 		unsigned narenas, i;
@@ -659,6 +717,7 @@ stats_print_atexit(void) {
 		}
 	}
 	je_malloc_stats_print(NULL, NULL, opt_stats_print_opts);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -668,10 +727,13 @@ stats_print_atexit(void) {
  */
 JEMALLOC_ALWAYS_INLINE void
 check_entry_exit_locking(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tsdn_null(tsdn)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd_t *tsd = tsdn_tsd(tsdn);
@@ -681,9 +743,11 @@ check_entry_exit_locking(tsdn_t *tsdn) {
 	 */
 	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
 	if (reentrancy_level != 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -710,6 +774,7 @@ jemalloc_secure_getenv(const char *name) {
 
 static unsigned
 malloc_ncpus(void) {
+	volatile int __A_VARIABLE;
 	long result;
 
 #ifdef _WIN32
@@ -733,6 +798,7 @@ malloc_ncpus(void) {
 #else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 #endif
+	__A_VARIABLE = 1;
 	return ((result == -1) ? 1 : (unsigned)result);
 }
 
@@ -764,6 +830,7 @@ init_opt_stats_print_opts(const char *v, size_t vlen) {
 static bool
 malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
     char const **v_p, size_t *vlen_p) {
+	volatile int __A_VARIABLE;
 	bool accept;
 	const char *opts = *opts_p;
 
@@ -797,9 +864,11 @@ malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
 				malloc_write("<jemalloc>: Conf string ends "
 				    "with key\n");
 			}
+			__A_VARIABLE = 1;
 			return true;
 		default:
 			malloc_write("<jemalloc>: Malformed conf string\n");
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
@@ -833,28 +902,34 @@ malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
 	}
 
 	*opts_p = opts;
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static void
 malloc_abort_invalid_conf(void) {
+	volatile int __A_VARIABLE;
 	assert(opt_abort_conf);
 	malloc_printf("<jemalloc>: Abort (abort_conf:true) on invalid conf "
 	    "value (see above).\n");
 	abort();
+	__A_VARIABLE = 1;
 }
 
 static void
 malloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,
     size_t vlen) {
+	volatile int __A_VARIABLE;
 	malloc_printf("<jemalloc>: %s: %.*s:%.*s\n", msg, (int)klen, k,
 	    (int)vlen, v);
 	/* If abort_conf is set, error out after processing all options. */
 	had_conf_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 malloc_slow_flag_init(void) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Combine the runtime options into malloc_slow for fast path.  Called
 	 * after processing all the options.
@@ -866,10 +941,12 @@ malloc_slow_flag_init(void) {
 	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
 
 	malloc_slow = (malloc_slow_flags != 0);
+	__A_VARIABLE = 1;
 }
 
 static void
 malloc_conf_init(void) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 	char buf[PATH_MAX + 1];
 	const char *opts, *k, *v;
@@ -1243,6 +1320,7 @@ malloc_conf_init(void) {
 		}
 	}
 	atomic_store_b(&log_init_done, true, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1273,6 +1351,7 @@ malloc_init_hard_needed(void) {
 
 static bool
 malloc_init_hard_a0_locked() {
+	volatile int __A_VARIABLE;
 	malloc_initializer = INITIALIZER;
 
 	if (config_prof) {
@@ -1289,15 +1368,19 @@ malloc_init_hard_a0_locked() {
 		}
 	}
 	if (pages_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (base_boot(TSDN_NULL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (extent_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (ctl_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (config_prof) {
@@ -1305,10 +1388,12 @@ malloc_init_hard_a0_locked() {
 	}
 	arena_boot();
 	if (tcache_boot(TSDN_NULL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (malloc_mutex_init(&arenas_lock, "arenas", WITNESS_RANK_ARENAS,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	/*
@@ -1323,21 +1408,25 @@ malloc_init_hard_a0_locked() {
 	 */
 	if (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&extent_hooks_default)
 	    == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	a0 = arena_get(TSDN_NULL, 0, false);
 	malloc_init_state = malloc_init_a0_initialized;
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 malloc_init_hard_a0(void) {
+	volatile int __A_VARIABLE;
 	bool ret;
 
 	malloc_mutex_lock(TSDN_NULL, &init_lock);
 	ret = malloc_init_hard_a0_locked();
 	malloc_mutex_unlock(TSDN_NULL, &init_lock);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1385,6 +1474,7 @@ malloc_narenas_default(void) {
 
 static percpu_arena_mode_t
 percpu_arena_as_initialized(percpu_arena_mode_t mode) {
+	volatile int __A_VARIABLE;
 	assert(!malloc_initialized());
 	assert(mode <= percpu_arena_disabled);
 
@@ -1392,6 +1482,7 @@ percpu_arena_as_initialized(percpu_arena_mode_t mode) {
 		mode += percpu_arena_mode_enabled_base;
 	}
 
+	__A_VARIABLE = 1;
 	return mode;
 }
 
@@ -1469,23 +1560,29 @@ malloc_init_narenas(void) {
 
 static void
 malloc_init_percpu(void) {
+	volatile int __A_VARIABLE;
 	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
+	__A_VARIABLE = 1;
 }
 
 static bool
 malloc_init_hard_finish(void) {
+	volatile int __A_VARIABLE;
 	if (malloc_mutex_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	malloc_init_state = malloc_init_initialized;
 	malloc_slow_flag_init();
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static void
 malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, &init_lock);
 	malloc_mutex_unlock(tsdn, &init_lock);
 	if (reentrancy_set) {
@@ -1494,10 +1591,12 @@ malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
 		assert(tsd_reentrancy_level_get(tsd) > 0);
 		post_reentrancy(tsd);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 malloc_init_hard(void) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 
 #if defined(_WIN32) && _WIN32_WINNT < 0x0600
@@ -1522,9 +1621,11 @@ malloc_init_hard(void) {
 	/* Recursive allocation relies on functional tsd. */
 	tsd = malloc_tsd_boot0();
 	if (tsd == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (malloc_init_hard_recursible()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1565,10 +1666,12 @@ malloc_init_hard(void) {
 		bool err = background_thread_create(tsd, 0);
 		malloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);
 		if (err) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
 #undef UNLOCK_RETURN
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1625,6 +1728,7 @@ struct static_opts_s {
 
 JEMALLOC_ALWAYS_INLINE void
 static_opts_init(static_opts_t *static_opts) {
+	volatile int __A_VARIABLE;
 	static_opts->may_overflow = false;
 	static_opts->bump_empty_alloc = false;
 	static_opts->assert_nonempty_alloc = false;
@@ -1634,6 +1738,7 @@ static_opts_init(static_opts_t *static_opts) {
 	static_opts->oom_string = "";
 	static_opts->invalid_alignment_string = "";
 	static_opts->slow = false;
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -1658,6 +1763,7 @@ struct dynamic_opts_s {
 
 JEMALLOC_ALWAYS_INLINE void
 dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
+	volatile int __A_VARIABLE;
 	dynamic_opts->result = NULL;
 	dynamic_opts->num_items = 0;
 	dynamic_opts->item_size = 0;
@@ -1665,12 +1771,14 @@ dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
 	dynamic_opts->zero = false;
 	dynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;
 	dynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;
+	__A_VARIABLE = 1;
 }
 
 /* ind is ignored if dopts->alignment > 0. */
 JEMALLOC_ALWAYS_INLINE void *
 imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
     size_t size, size_t usize, szind_t ind) {
+	volatile int __A_VARIABLE;
 	tcache_t *tcache;
 	arena_t *arena;
 
@@ -1702,10 +1810,12 @@ imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
 	}
 
 	if (unlikely(dopts->alignment != 0)) {
+		__A_VARIABLE = 1;
 		return ipalloct(tsd_tsdn(tsd), usize, dopts->alignment,
 		    dopts->zero, tcache, arena);
 	}
 
+	__A_VARIABLE = 1;
 	return iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false,
 	    arena, sopts->slow);
 }
@@ -1748,6 +1858,7 @@ imalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
 JEMALLOC_ALWAYS_INLINE bool
 compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
     size_t *size) {
+	volatile int __A_VARIABLE;
 	/*
 	 * This function is just num_items * item_size, except that we may have
 	 * to check for overflow.
@@ -1756,6 +1867,7 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	if (!may_overflow) {
 		assert(dopts->num_items == 1);
 		*size = dopts->item_size;
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -1765,6 +1877,7 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	*size = dopts->item_size * dopts->num_items;
 
 	if (unlikely(*size == 0)) {
+		__A_VARIABLE = 1;
 		return (dopts->num_items != 0 && dopts->item_size != 0);
 	}
 
@@ -1775,16 +1888,20 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	 * can be represented in N bits (without the possibility of overflow).
 	 */
 	if (likely((high_bits & (dopts->num_items | dopts->item_size)) == 0)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (likely(*size / dopts->item_size == dopts->num_items)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 JEMALLOC_ALWAYS_INLINE int
 imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	/* Where the actual allocated memory will live. */
 	void *allocation = NULL;
 	/* Filled in by compute_size_with_overflow below. */
@@ -1928,6 +2045,7 @@ imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
 	/* Success! */
 	check_entry_exit_locking(tsd_tsdn(tsd));
 	*dopts->result = allocation;
+	__A_VARIABLE = 1;
 	return 0;
 
 label_oom:
@@ -1950,6 +2068,7 @@ label_oom:
 		*dopts->result = NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return ENOMEM;
 
 	/*
@@ -1977,6 +2096,7 @@ label_invalid_alignment:
 		*dopts->result = NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return EINVAL;
 }
 
@@ -2166,6 +2286,7 @@ irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
 JEMALLOC_ALWAYS_INLINE void *
 irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
    alloc_ctx_t *alloc_ctx) {
+	volatile int __A_VARIABLE;
 	void *p;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
@@ -2180,16 +2301,19 @@ irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
 	}
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, true);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
 	    old_tctx);
 
+	__A_VARIABLE = 1;
 	return p;
 }
 
 JEMALLOC_ALWAYS_INLINE void
 ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
+	volatile int __A_VARIABLE;
 	if (!slow_path) {
 		tsd_assert_fast(tsd);
 	}
@@ -2225,10 +2349,12 @@ ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
 		idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,
 		    true);
 	}
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ALWAYS_INLINE void
 isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
+	volatile int __A_VARIABLE;
 	if (!slow_path) {
 		tsd_assert_fast(tsd);
 	}
@@ -2281,6 +2407,7 @@ isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
 	} else {
 		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
@@ -2370,6 +2497,7 @@ je_realloc(void *ptr, size_t size) {
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_free(void *ptr) {
+	volatile int __A_VARIABLE;
 	LOG("core.free.entry", "ptr: %p", ptr);
 
 	UTRACE(ptr, 0, 0);
@@ -2402,6 +2530,7 @@ je_free(void *ptr) {
 		check_entry_exit_locking(tsd_tsdn(tsd));
 	}
 	LOG("core.free.exit", "");
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -2619,6 +2748,7 @@ JEMALLOC_ALWAYS_INLINE void *
 irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
     size_t alignment, size_t *usize, bool zero, tcache_t *tcache,
     arena_t *arena, alloc_ctx_t *alloc_ctx) {
+	volatile int __A_VARIABLE;
 	void *p;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
@@ -2635,6 +2765,7 @@ irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
 	}
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, false);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -2652,6 +2783,7 @@ irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
 	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
 	    old_usize, old_tctx);
 
+	__A_VARIABLE = 1;
 	return p;
 }
 
@@ -2752,33 +2884,40 @@ label_oom:
 JEMALLOC_ALWAYS_INLINE size_t
 ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
     size_t extra, size_t alignment, bool zero) {
+	volatile int __A_VARIABLE;
 	size_t usize;
 
 	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero)) {
+		__A_VARIABLE = 1;
 		return old_usize;
 	}
 	usize = isalloc(tsdn, ptr);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
 static size_t
 ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
     size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	size_t usize;
 
 	if (tctx == NULL) {
+		__A_VARIABLE = 1;
 		return old_usize;
 	}
 	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
 	    zero);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
     size_t extra, size_t alignment, bool zero, alloc_ctx_t *alloc_ctx) {
+	volatile int __A_VARIABLE;
 	size_t usize_max, usize;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
@@ -2817,16 +2956,19 @@ ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
 	}
 	if (usize == old_usize) {
 		prof_alloc_rollback(tsd, tctx, false);
+		__A_VARIABLE = 1;
 		return usize;
 	}
 	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
 	    old_tctx);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 je_xallocx(void *ptr, size_t size, size_t extra, int flags) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	size_t usize, old_usize;
 	size_t alignment = MALLOCX_ALIGN_GET(flags);
@@ -2886,6 +3028,7 @@ label_not_resized:
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.xallocx.exit", "result: %zu", usize);
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -2918,6 +3061,7 @@ je_sallocx(const void *ptr, UNUSED int flags) {
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_dallocx(void *ptr, int flags) {
+	volatile int __A_VARIABLE;
 	LOG("core.dallocx.entry", "ptr: %p, flags: %d", ptr, flags);
 
 	assert(ptr != NULL);
@@ -2959,10 +3103,12 @@ je_dallocx(void *ptr, int flags) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.dallocx.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 inallocx(tsdn_t *tsdn, size_t size, int flags) {
+	volatile int __A_VARIABLE;
 	check_entry_exit_locking(tsdn);
 
 	size_t usize;
@@ -2972,11 +3118,13 @@ inallocx(tsdn_t *tsdn, size_t size, int flags) {
 		usize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
 	}
 	check_entry_exit_locking(tsdn);
+	__A_VARIABLE = 1;
 	return usize;
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_sdallocx(void *ptr, size_t size, int flags) {
+	volatile int __A_VARIABLE;
 	assert(ptr != NULL);
 	assert(malloc_initialized() || IS_INITIALIZER);
 
@@ -3021,6 +3169,7 @@ je_sdallocx(void *ptr, size_t size, int flags) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.sdallocx.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
@@ -3053,6 +3202,7 @@ je_nallocx(size_t size, int flags) {
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
     size_t newlen) {
+	volatile int __A_VARIABLE;
 	int ret;
 	tsd_t *tsd;
 
@@ -3060,6 +3210,7 @@ je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctl.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3069,17 +3220,20 @@ je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.mallctl.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
+	volatile int __A_VARIABLE;
 	int ret;
 
 	LOG("core.mallctlnametomib.entry", "name: %s", name);
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctlnametomib.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3089,12 +3243,14 @@ je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.mallctlnametomib.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
   void *newp, size_t newlen) {
+	volatile int __A_VARIABLE;
 	int ret;
 	tsd_t *tsd;
 
@@ -3102,6 +3258,7 @@ je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctlbymib.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3110,12 +3267,14 @@ je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
 	check_entry_exit_locking(tsd_tsdn(tsd));
 	LOG("core.mallctlbymib.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *opts) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn;
 
 	LOG("core.malloc_stats_print.entry", "");
@@ -3125,10 +3284,12 @@ je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 	stats_print(write_cb, cbopaque, opts);
 	check_entry_exit_locking(tsdn);
 	LOG("core.malloc_stats_print.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	tsdn_t *tsdn;
 
@@ -3152,6 +3313,7 @@ je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
 
 	check_entry_exit_locking(tsdn);
 	LOG("core.malloc_usable_size.exit", "result: %zu", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -3181,7 +3343,9 @@ je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
 JEMALLOC_ATTR(constructor)
 static void
 jemalloc_constructor(void) {
+	volatile int __A_VARIABLE;
 	malloc_init();
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -3298,6 +3462,7 @@ _malloc_postfork(void)
 
 void
 jemalloc_postfork_child(void) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	unsigned i, narenas;
 
@@ -3321,6 +3486,7 @@ jemalloc_postfork_child(void) {
 	malloc_mutex_postfork_child(tsd_tsdn(tsd), &arenas_lock);
 	tcache_postfork_child(tsd_tsdn(tsd));
 	ctl_postfork_child(tsd_tsdn(tsd));
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
@@ -3332,6 +3498,8 @@ jemalloc_postfork_child(void) {
  * If the application decides to re-allocate it should use MALLOCX_TCACHE_NONE when doing so. */
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
+	volatile int __A_VARIABLE;
 	assert(ptr != NULL);
+	__A_VARIABLE = 1;
 	return iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);
 }
diff --git a/deps/jemalloc/src/large.c b/deps/jemalloc/src/large.c
index 27a2c67..ec7111a 100644
--- a/deps/jemalloc/src/large.c
+++ b/deps/jemalloc/src/large.c
@@ -12,14 +12,17 @@
 
 void *
 large_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero) {
+	volatile int __A_VARIABLE;
 	assert(usize == sz_s2u(usize));
 
+	__A_VARIABLE = 1;
 	return large_palloc(tsdn, arena, usize, CACHELINE, zero);
 }
 
 void *
 large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
     bool zero) {
+	volatile int __A_VARIABLE;
 	size_t ausize;
 	extent_t *extent;
 	bool is_zeroed;
@@ -29,6 +32,7 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 
 	ausize = sz_sa2u(usize, alignment);
 	if (unlikely(ausize == 0 || ausize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -46,6 +50,7 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 	}
 	if (unlikely(arena == NULL) || (extent = arena_extent_alloc_large(tsdn,
 	    arena, usize, alignment, &is_zeroed)) == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -68,17 +73,21 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 	}
 
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 	return extent_addr_get(extent);
 }
 
 static void
 large_dalloc_junk_impl(void *ptr, size_t size) {
+	volatile int __A_VARIABLE;
 	memset(ptr, JEMALLOC_FREE_JUNK, size);
+	__A_VARIABLE = 1;
 }
 large_dalloc_junk_t *JET_MUTABLE large_dalloc_junk = large_dalloc_junk_impl;
 
 static void
 large_dalloc_maybe_junk_impl(void *ptr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (config_fill && have_dss && unlikely(opt_junk_free)) {
 		/*
 		 * Only bother junk filling if the extent isn't about to be
@@ -88,6 +97,7 @@ large_dalloc_maybe_junk_impl(void *ptr, size_t size) {
 			large_dalloc_junk(ptr, size);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 large_dalloc_maybe_junk_t *JET_MUTABLE large_dalloc_maybe_junk =
     large_dalloc_maybe_junk_impl;
@@ -263,15 +273,19 @@ large_ralloc_no_move(tsdn_t *tsdn, extent_t *extent, size_t usize_min,
 static void *
 large_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero) {
+	volatile int __A_VARIABLE;
 	if (alignment <= CACHELINE) {
+		__A_VARIABLE = 1;
 		return large_malloc(tsdn, arena, usize, zero);
 	}
+	__A_VARIABLE = 1;
 	return large_palloc(tsdn, arena, usize, alignment, zero);
 }
 
 void *
 large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
     size_t alignment, bool zero, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	size_t oldusize = extent_usize_get(extent);
 
 	/* The following should have been caught by callers. */
@@ -281,6 +295,7 @@ large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
 
 	/* Try to avoid moving the allocation. */
 	if (!large_ralloc_no_move(tsdn, extent, usize, usize, zero)) {
+		__A_VARIABLE = 1;
 		return extent_addr_get(extent);
 	}
 
@@ -292,12 +307,14 @@ large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
 	void *ret = large_ralloc_move_helper(tsdn, arena, usize, alignment,
 	    zero);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	size_t copysize = (usize < oldusize) ? usize : oldusize;
 	memcpy(ret, extent_addr_get(extent), copysize);
 	isdalloct(tsdn, extent_addr_get(extent), oldusize, tcache, NULL, true);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -308,6 +325,7 @@ large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
 static void
 large_dalloc_prep_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
     bool junked_locked) {
+	volatile int __A_VARIABLE;
 	if (!junked_locked) {
 		/* See comments in arena_bin_slabs_full_insert(). */
 		if (!arena_is_auto(arena)) {
@@ -324,48 +342,65 @@ large_dalloc_prep_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		}
 	}
 	arena_extent_dalloc_large_prep(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 static void
 large_dalloc_finish_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, extent);
+	__A_VARIABLE = 1;
 }
 
 void
 large_dalloc_prep_junked_locked(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	large_dalloc_prep_impl(tsdn, extent_arena_get(extent), extent, true);
+	__A_VARIABLE = 1;
 }
 
 void
 large_dalloc_finish(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
+	__A_VARIABLE = 1;
 }
 
 void
 large_dalloc(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	arena_t *arena = extent_arena_get(extent);
 	large_dalloc_prep_impl(tsdn, arena, extent, false);
 	large_dalloc_finish_impl(tsdn, arena, extent);
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 size_t
 large_salloc(tsdn_t *tsdn, const extent_t *extent) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_usize_get(extent);
 }
 
 prof_tctx_t *
 large_prof_tctx_get(tsdn_t *tsdn, const extent_t *extent) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return extent_prof_tctx_get(extent);
 }
 
 void
 large_prof_tctx_set(tsdn_t *tsdn, extent_t *extent, prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	extent_prof_tctx_set(extent, tctx);
+	__A_VARIABLE = 1;
 }
 
 void
 large_prof_tctx_reset(tsdn_t *tsdn, extent_t *extent) {
+	volatile int __A_VARIABLE;
 	large_prof_tctx_set(tsdn, extent, (prof_tctx_t *)(uintptr_t)1U);
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/log.c b/deps/jemalloc/src/log.c
index 778902f..352d8bc 100644
--- a/deps/jemalloc/src/log.c
+++ b/deps/jemalloc/src/log.c
@@ -12,9 +12,11 @@ atomic_b_t log_init_done = ATOMIC_INIT(false);
  */
 static const char *
 log_var_extract_segment(const char* segment_begin) {
+	volatile int __A_VARIABLE;
 	const char *end;
 	for (end = segment_begin; *end != '\0' && *end != '|'; end++) {
 	}
+	__A_VARIABLE = 1;
 	return end;
 }
 
@@ -42,6 +44,7 @@ log_var_matches_segment(const char *segment_begin, const char *segment_end,
 
 unsigned
 log_var_update_state(log_var_t *log_var) {
+	volatile int __A_VARIABLE;
 	const char *log_var_begin = log_var->name;
 	const char *log_var_end = log_var->name + strlen(log_var->name);
 
@@ -53,6 +56,7 @@ log_var_update_state(log_var_t *log_var) {
 	 * avoid log-spew, we default to not displaying anything.
 	 */
 	if (!atomic_load_b(&log_init_done, ATOMIC_ACQUIRE)) {
+		__A_VARIABLE = 1;
 		return LOG_INITIALIZED_NOT_ENABLED;
 	}
 
@@ -64,15 +68,18 @@ log_var_update_state(log_var_t *log_var) {
 		    log_var_begin, log_var_end)) {
 			atomic_store_u(&log_var->state, LOG_ENABLED,
 			    ATOMIC_RELAXED);
+			__A_VARIABLE = 1;
 			return LOG_ENABLED;
 		}
 		if (*segment_end == '\0') {
 			/* Hit the end of the segment string with no match. */
 			atomic_store_u(&log_var->state,
 			    LOG_INITIALIZED_NOT_ENABLED, ATOMIC_RELAXED);
+			__A_VARIABLE = 1;
 			return LOG_INITIALIZED_NOT_ENABLED;
 		}
 		/* Otherwise, skip the delimiter and continue. */
 		segment_begin = segment_end + 1;
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/malloc_io.c b/deps/jemalloc/src/malloc_io.c
index 7bdc13f..52db465 100644
--- a/deps/jemalloc/src/malloc_io.c
+++ b/deps/jemalloc/src/malloc_io.c
@@ -70,7 +70,9 @@ static char *x2s(uintmax_t x, bool alt_form, bool uppercase, char *s,
 /* malloc_message() setup. */
 static void
 wrtmessage(void *cbopaque, const char *s) {
+	volatile int __A_VARIABLE;
 	malloc_write_fd(STDERR_FILENO, s, strlen(s));
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT void	(*je_malloc_message)(void *, const char *s);
@@ -81,11 +83,13 @@ JEMALLOC_EXPORT void	(*je_malloc_message)(void *, const char *s);
  */
 void
 malloc_write(const char *s) {
+	volatile int __A_VARIABLE;
 	if (je_malloc_message != NULL) {
 		je_malloc_message(NULL, s);
 	} else {
 		wrtmessage(NULL, s);
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -112,6 +116,7 @@ buferror(int err, char *buf, size_t buflen) {
 
 uintmax_t
 malloc_strtoumax(const char *restrict nptr, char **restrict endptr, int base) {
+	volatile int __A_VARIABLE;
 	uintmax_t ret, digit;
 	unsigned b;
 	bool neg;
@@ -228,11 +233,13 @@ label_return:
 			*endptr = (char *)p;
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static char *
 u2s(uintmax_t x, unsigned base, bool uppercase, char *s, size_t *slen_p) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	i = U2S_BUFSIZE - 1;
@@ -270,11 +277,13 @@ u2s(uintmax_t x, unsigned base, bool uppercase, char *s, size_t *slen_p) {
 	}}
 
 	*slen_p = U2S_BUFSIZE - 1 - i;
+	__A_VARIABLE = 1;
 	return &s[i];
 }
 
 static char *
 d2s(intmax_t x, char sign, char *s, size_t *slen_p) {
+	volatile int __A_VARIABLE;
 	bool neg;
 
 	if ((neg = (x < 0))) {
@@ -298,28 +307,33 @@ d2s(intmax_t x, char sign, char *s, size_t *slen_p) {
 		break;
 	default: not_reached();
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
 static char *
 o2s(uintmax_t x, bool alt_form, char *s, size_t *slen_p) {
+	volatile int __A_VARIABLE;
 	s = u2s(x, 8, false, s, slen_p);
 	if (alt_form && *s != '0') {
 		s--;
 		(*slen_p)++;
 		*s = '0';
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
 static char *
 x2s(uintmax_t x, bool alt_form, bool uppercase, char *s, size_t *slen_p) {
+	volatile int __A_VARIABLE;
 	s = u2s(x, 16, uppercase, s, slen_p);
 	if (alt_form) {
 		s -= 2;
 		(*slen_p) += 2;
 		memcpy(s, uppercase ? "0X" : "0x", 2);
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
@@ -609,6 +623,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap) {
 JEMALLOC_FORMAT_PRINTF(3, 4)
 size_t
 malloc_snprintf(char *str, size_t size, const char *format, ...) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	va_list ap;
 
@@ -616,12 +631,14 @@ malloc_snprintf(char *str, size_t size, const char *format, ...) {
 	ret = malloc_vsnprintf(str, size, format, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *format, va_list ap) {
+	volatile int __A_VARIABLE;
 	char buf[MALLOC_PRINTF_BUFSIZE];
 
 	if (write_cb == NULL) {
@@ -637,6 +654,7 @@ malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
 
 	malloc_vsnprintf(buf, sizeof(buf), format, ap);
 	write_cb(cbopaque, buf);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -647,22 +665,26 @@ JEMALLOC_FORMAT_PRINTF(3, 4)
 void
 malloc_cprintf(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *format, ...) {
+	volatile int __A_VARIABLE;
 	va_list ap;
 
 	va_start(ap, format);
 	malloc_vcprintf(write_cb, cbopaque, format, ap);
 	va_end(ap);
+	__A_VARIABLE = 1;
 }
 
 /* Print to stderr in such a way as to avoid memory allocation. */
 JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 malloc_printf(const char *format, ...) {
+	volatile int __A_VARIABLE;
 	va_list ap;
 
 	va_start(ap, format);
 	malloc_vcprintf(NULL, NULL, format, ap);
 	va_end(ap);
+	__A_VARIABLE = 1;
 }
 
 /*
diff --git a/deps/jemalloc/src/mutex.c b/deps/jemalloc/src/mutex.c
index 30222b3..c5746b2 100644
--- a/deps/jemalloc/src/mutex.c
+++ b/deps/jemalloc/src/mutex.c
@@ -32,6 +32,8 @@ JEMALLOC_EXPORT int
 pthread_create(pthread_t *__restrict thread,
     const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),
     void *__restrict arg) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pthread_create_wrapper(thread, attr, start_routine, arg);
 }
 #endif
@@ -45,6 +47,7 @@ JEMALLOC_EXPORT int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
 
 void
 malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
+	volatile int __A_VARIABLE;
 	mutex_prof_data_t *data = &mutex->prof_data;
 	UNUSED nstime_t before = NSTIME_ZERO_INITIALIZER;
 
@@ -57,6 +60,7 @@ malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
 		spin_cpu_spinwait();
 		if (!malloc_mutex_trylock_final(mutex)) {
 			data->n_spin_acquired++;
+			__A_VARIABLE = 1;
 			return;
 		}
 	} while (cnt++ < max_cnt);
@@ -64,6 +68,7 @@ malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
 	if (!config_stats) {
 		/* Only spin is useful when stats is off. */
 		malloc_mutex_lock_final(mutex);
+		__A_VARIABLE = 1;
 		return;
 	}
 label_spin_done:
@@ -77,6 +82,7 @@ label_spin_done:
 	if (!malloc_mutex_trylock_final(mutex)) {
 		atomic_fetch_sub_u32(&data->n_waiting_thds, 1, ATOMIC_RELAXED);
 		data->n_spin_acquired++;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -98,20 +104,25 @@ label_spin_done:
 	if (n_thds > data->max_n_thds) {
 		data->max_n_thds = n_thds;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 mutex_prof_data_init(mutex_prof_data_t *data) {
+	volatile int __A_VARIABLE;
 	memset(data, 0, sizeof(mutex_prof_data_t));
 	nstime_init(&data->max_wait_time, 0);
 	nstime_init(&data->tot_wait_time, 0);
 	data->prev_owner = NULL;
+	__A_VARIABLE = 1;
 }
 
 void
 malloc_mutex_prof_data_reset(tsdn_t *tsdn, malloc_mutex_t *mutex) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, mutex);
 	mutex_prof_data_init(&mutex->prof_data);
+	__A_VARIABLE = 1;
 }
 
 static int
@@ -184,16 +195,21 @@ malloc_mutex_init(malloc_mutex_t *mutex, const char *name,
 
 void
 malloc_mutex_prefork(tsdn_t *tsdn, malloc_mutex_t *mutex) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsdn, mutex);
+	__A_VARIABLE = 1;
 }
 
 void
 malloc_mutex_postfork_parent(tsdn_t *tsdn, malloc_mutex_t *mutex) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_unlock(tsdn, mutex);
+	__A_VARIABLE = 1;
 }
 
 void
 malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex) {
+	volatile int __A_VARIABLE;
 #ifdef JEMALLOC_MUTEX_INIT_CB
 	malloc_mutex_unlock(tsdn, mutex);
 #else
@@ -206,6 +222,7 @@ malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex) {
 		}
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 bool
diff --git a/deps/jemalloc/src/mutex_pool.c b/deps/jemalloc/src/mutex_pool.c
index f24d10e..40dc3f4 100644
--- a/deps/jemalloc/src/mutex_pool.c
+++ b/deps/jemalloc/src/mutex_pool.c
@@ -8,11 +8,14 @@
 
 bool
 mutex_pool_init(mutex_pool_t *pool, const char *name, witness_rank_t rank) {
+	volatile int __A_VARIABLE;
 	for (int i = 0; i < MUTEX_POOL_SIZE; ++i) {
 		if (malloc_mutex_init(&pool->mutexes[i], name, rank,
 		    malloc_mutex_address_ordered)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/nstime.c b/deps/jemalloc/src/nstime.c
index 71db353..78b05cc 100644
--- a/deps/jemalloc/src/nstime.c
+++ b/deps/jemalloc/src/nstime.c
@@ -10,91 +10,121 @@
 
 void
 nstime_init(nstime_t *time, uint64_t ns) {
+	volatile int __A_VARIABLE;
 	time->ns = ns;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_init2(nstime_t *time, uint64_t sec, uint64_t nsec) {
+	volatile int __A_VARIABLE;
 	time->ns = sec * BILLION + nsec;
+	__A_VARIABLE = 1;
 }
 
 uint64_t
 nstime_ns(const nstime_t *time) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return time->ns;
 }
 
 uint64_t
 nstime_msec(const nstime_t *time) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return time->ns / MILLION;
 }
 
 uint64_t
 nstime_sec(const nstime_t *time) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return time->ns / BILLION;
 }
 
 uint64_t
 nstime_nsec(const nstime_t *time) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return time->ns % BILLION;
 }
 
 void
 nstime_copy(nstime_t *time, const nstime_t *source) {
+	volatile int __A_VARIABLE;
 	*time = *source;
+	__A_VARIABLE = 1;
 }
 
 int
 nstime_compare(const nstime_t *a, const nstime_t *b) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return (a->ns > b->ns) - (a->ns < b->ns);
 }
 
 void
 nstime_add(nstime_t *time, const nstime_t *addend) {
+	volatile int __A_VARIABLE;
 	assert(UINT64_MAX - time->ns >= addend->ns);
 
 	time->ns += addend->ns;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_iadd(nstime_t *time, uint64_t addend) {
+	volatile int __A_VARIABLE;
 	assert(UINT64_MAX - time->ns >= addend);
 
 	time->ns += addend;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_subtract(nstime_t *time, const nstime_t *subtrahend) {
+	volatile int __A_VARIABLE;
 	assert(nstime_compare(time, subtrahend) >= 0);
 
 	time->ns -= subtrahend->ns;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_isubtract(nstime_t *time, uint64_t subtrahend) {
+	volatile int __A_VARIABLE;
 	assert(time->ns >= subtrahend);
 
 	time->ns -= subtrahend;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_imultiply(nstime_t *time, uint64_t multiplier) {
+	volatile int __A_VARIABLE;
 	assert((((time->ns | multiplier) & (UINT64_MAX << (sizeof(uint64_t) <<
 	    2))) == 0) || ((time->ns * multiplier) / multiplier == time->ns));
 
 	time->ns *= multiplier;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_idivide(nstime_t *time, uint64_t divisor) {
+	volatile int __A_VARIABLE;
 	assert(divisor != 0);
 
 	time->ns /= divisor;
+	__A_VARIABLE = 1;
 }
 
 uint64_t
 nstime_divide(const nstime_t *time, const nstime_t *divisor) {
+	volatile int __A_VARIABLE;
 	assert(divisor->ns != 0);
 
+	__A_VARIABLE = 1;
 	return time->ns / divisor->ns;
 }
 
@@ -102,6 +132,7 @@ nstime_divide(const nstime_t *time, const nstime_t *divisor) {
 #  define NSTIME_MONOTONIC true
 static void
 nstime_get(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	FILETIME ft;
 	uint64_t ticks_100ns;
 
@@ -109,44 +140,55 @@ nstime_get(nstime_t *time) {
 	ticks_100ns = (((uint64_t)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 
 	nstime_init(time, ticks_100ns * 100);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE)
 #  define NSTIME_MONOTONIC true
 static void
 nstime_get(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	struct timespec ts;
 
 	clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
 	nstime_init2(time, ts.tv_sec, ts.tv_nsec);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_CLOCK_MONOTONIC)
 #  define NSTIME_MONOTONIC true
 static void
 nstime_get(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	struct timespec ts;
 
 	clock_gettime(CLOCK_MONOTONIC, &ts);
 	nstime_init2(time, ts.tv_sec, ts.tv_nsec);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_MACH_ABSOLUTE_TIME)
 #  define NSTIME_MONOTONIC true
 static void
 nstime_get(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	nstime_init(time, mach_absolute_time());
+	__A_VARIABLE = 1;
 }
 #else
 #  define NSTIME_MONOTONIC false
 static void
 nstime_get(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
 	nstime_init2(time, tv.tv_sec, tv.tv_usec * 1000);
+	__A_VARIABLE = 1;
 }
 #endif
 
 static bool
 nstime_monotonic_impl(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return NSTIME_MONOTONIC;
 #undef NSTIME_MONOTONIC
 }
@@ -154,6 +196,7 @@ nstime_monotonic_t *JET_MUTABLE nstime_monotonic = nstime_monotonic_impl;
 
 static bool
 nstime_update_impl(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	nstime_t old_time;
 
 	nstime_copy(&old_time, time);
@@ -162,9 +205,11 @@ nstime_update_impl(nstime_t *time) {
 	/* Handle non-monotonic clocks. */
 	if (unlikely(nstime_compare(&old_time, time) > 0)) {
 		nstime_copy(time, &old_time);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 nstime_update_t *JET_MUTABLE nstime_update = nstime_update_impl;
diff --git a/deps/jemalloc/src/pages.c b/deps/jemalloc/src/pages.c
index 2600269..d5c709c 100644
--- a/deps/jemalloc/src/pages.c
+++ b/deps/jemalloc/src/pages.c
@@ -52,6 +52,7 @@ static void os_pages_unmap(void *addr, size_t size);
 
 static void *
 os_pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
+	volatile int __A_VARIABLE;
 	assert(ALIGNMENT_ADDR2BASE(addr, os_page) == addr);
 	assert(ALIGNMENT_CEILING(size, os_page) == size);
 	assert(size != 0);
@@ -92,6 +93,7 @@ os_pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
 #endif
 	assert(ret == NULL || (addr == NULL && ret != addr) || (addr != NULL &&
 	    ret == addr));
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -126,6 +128,7 @@ os_pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size,
 
 static void
 os_pages_unmap(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	assert(ALIGNMENT_ADDR2BASE(addr, os_page) == addr);
 	assert(ALIGNMENT_CEILING(size, os_page) == size);
 
@@ -149,13 +152,16 @@ os_pages_unmap(void *addr, size_t size) {
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
 pages_map_slow(size_t size, size_t alignment, bool *commit) {
+	volatile int __A_VARIABLE;
 	size_t alloc_size = size + alignment - os_page;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -163,6 +169,7 @@ pages_map_slow(size_t size, size_t alignment, bool *commit) {
 	do {
 		void *pages = os_pages_map(NULL, alloc_size, alignment, commit);
 		if (pages == NULL) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		size_t leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment)
@@ -172,11 +179,13 @@ pages_map_slow(size_t size, size_t alignment, bool *commit) {
 
 	assert(ret != NULL);
 	assert(PAGE_ADDR2BASE(ret) == ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void *
 pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
+	volatile int __A_VARIABLE;
 	assert(alignment >= PAGE);
 	assert(ALIGNMENT_ADDR2BASE(addr, alignment) == addr);
 
@@ -196,24 +205,29 @@ pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
 
 	void *ret = os_pages_map(addr, size, os_page, commit);
 	if (ret == NULL || ret == addr) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	assert(addr == NULL);
 	if (ALIGNMENT_ADDR2OFFSET(ret, alignment) != 0) {
 		os_pages_unmap(ret, size);
+		__A_VARIABLE = 1;
 		return pages_map_slow(size, alignment, commit);
 	}
 
 	assert(PAGE_ADDR2BASE(ret) == ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 pages_unmap(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
 	assert(PAGE_ADDR2BASE(addr) == addr);
 	assert(PAGE_CEILING(size) == size);
 
 	os_pages_unmap(addr, size);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -251,11 +265,15 @@ pages_commit_impl(void *addr, size_t size, bool commit) {
 
 bool
 pages_commit(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_commit_impl(addr, size, true);
 }
 
 bool
 pages_decommit(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_commit_impl(addr, size, false);
 }
 
@@ -329,11 +347,15 @@ pages_huge_impl(void *addr, size_t size, bool aligned) {
 
 bool
 pages_huge(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_huge_impl(addr, size, true);
 }
 
 static bool
 pages_huge_unaligned(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_huge_impl(addr, size, false);
 }
 
@@ -353,11 +375,15 @@ pages_nohuge_impl(void *addr, size_t size, bool aligned) {
 
 bool
 pages_nohuge(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_nohuge_impl(addr, size, true);
 }
 
 static bool
 pages_nohuge_unaligned(void *addr, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return pages_nohuge_impl(addr, size, false);
 }
 
@@ -434,6 +460,7 @@ os_overcommits_sysctl(void) {
  */
 static bool
 os_overcommits_proc(void) {
+	volatile int __A_VARIABLE;
 	int fd;
 	char buf[1];
 
@@ -470,6 +497,7 @@ os_overcommits_proc(void) {
 #endif
 
 	if (fd == -1) {
+		__A_VARIABLE = 1;
 		return false; /* Error. */
 	}
 
@@ -481,6 +509,7 @@ os_overcommits_proc(void) {
 #endif
 
 	if (nread < 1) {
+		__A_VARIABLE = 1;
 		return false; /* Error. */
 	}
 	/*
@@ -489,13 +518,16 @@ os_overcommits_proc(void) {
 	 * 1: Always overcommit.
 	 * 2: Never overcommit.
 	 */
+	__A_VARIABLE = 1;
 	return (buf[0] == '0' || buf[0] == '1');
 }
 #endif
 
 void
 pages_set_thp_state (void *ptr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (opt_thp == thp_mode_default || opt_thp == init_system_thp_mode) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	assert(opt_thp != thp_mode_not_supported &&
@@ -510,10 +542,12 @@ pages_set_thp_state (void *ptr, size_t size) {
 		    init_system_thp_mode == thp_mode_always);
 		pages_nohuge_unaligned(ptr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 init_thp_state(void) {
+	volatile int __A_VARIABLE;
 	if (!have_madvise_huge) {
 		if (metadata_thp_enabled() && opt_abort) {
 			malloc_write("<jemalloc>: no MADV_HUGEPAGE support\n");
@@ -553,19 +587,23 @@ init_thp_state(void) {
 	} else {
 		goto label_error;
 	}
+	__A_VARIABLE = 1;
 	return;
 label_error:
 	opt_thp = init_system_thp_mode = thp_mode_not_supported;
+	__A_VARIABLE = 1;
 }
 
 bool
 pages_boot(void) {
+	volatile int __A_VARIABLE;
 	os_page = os_page_detect();
 	if (os_page > PAGE) {
 		malloc_write("<jemalloc>: Unsupported system page size\n");
 		if (opt_abort) {
 			abort();
 		}
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -593,6 +631,7 @@ pages_boot(void) {
 		bool committed = false;
 		void *madv_free_page = os_pages_map(NULL, PAGE, PAGE, &committed);
 		if (madv_free_page == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		assert(pages_can_purge_lazy_runtime);
@@ -602,5 +641,6 @@ pages_boot(void) {
 		os_pages_unmap(madv_free_page, PAGE);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/prof.c b/deps/jemalloc/src/prof.c
index 13df641..e6d45c2 100644
--- a/deps/jemalloc/src/prof.c
+++ b/deps/jemalloc/src/prof.c
@@ -150,6 +150,7 @@ static char	*prof_thread_name_alloc(tsdn_t *tsdn, const char *thread_name);
 
 static int
 prof_tctx_comp(const prof_tctx_t *a, const prof_tctx_t *b) {
+	volatile int __A_VARIABLE;
 	uint64_t a_thr_uid = a->thr_uid;
 	uint64_t b_thr_uid = b->thr_uid;
 	int ret = (a_thr_uid > b_thr_uid) - (a_thr_uid < b_thr_uid);
@@ -165,6 +166,7 @@ prof_tctx_comp(const prof_tctx_t *a, const prof_tctx_t *b) {
 			    b_tctx_uid);
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -173,6 +175,7 @@ rb_gen(static UNUSED, tctx_tree_, prof_tctx_tree_t, prof_tctx_t,
 
 static int
 prof_gctx_comp(const prof_gctx_t *a, const prof_gctx_t *b) {
+	volatile int __A_VARIABLE;
 	unsigned a_len = a->bt.len;
 	unsigned b_len = b->bt.len;
 	unsigned comp_len = (a_len < b_len) ? a_len : b_len;
@@ -180,6 +183,7 @@ prof_gctx_comp(const prof_gctx_t *a, const prof_gctx_t *b) {
 	if (ret == 0) {
 		ret = (a_len > b_len) - (a_len < b_len);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -188,6 +192,7 @@ rb_gen(static UNUSED, gctx_tree_, prof_gctx_tree_t, prof_gctx_t, dump_link,
 
 static int
 prof_tdata_comp(const prof_tdata_t *a, const prof_tdata_t *b) {
+	volatile int __A_VARIABLE;
 	int ret;
 	uint64_t a_uid = a->thr_uid;
 	uint64_t b_uid = b->thr_uid;
@@ -199,6 +204,7 @@ prof_tdata_comp(const prof_tdata_t *a, const prof_tdata_t *b) {
 
 		ret = ((a_discrim > b_discrim) - (a_discrim < b_discrim));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -209,6 +215,7 @@ rb_gen(static UNUSED, tdata_tree_, prof_tdata_tree_t, prof_tdata_t, tdata_link,
 
 void
 prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
@@ -235,11 +242,13 @@ prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated) {
 			malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 prof_malloc_sample_object(tsdn_t *tsdn, const void *ptr, size_t usize,
     prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	prof_tctx_set(tsdn, ptr, usize, NULL, tctx);
 
 	malloc_mutex_lock(tsdn, tctx->tdata->lock);
@@ -251,10 +260,12 @@ prof_malloc_sample_object(tsdn_t *tsdn, const void *ptr, size_t usize,
 	}
 	tctx->prepared = false;
 	malloc_mutex_unlock(tsdn, tctx->tdata->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsd_tsdn(tsd), tctx->tdata->lock);
 	assert(tctx->cnts.curobjs > 0);
 	assert(tctx->cnts.curbytes >= usize);
@@ -266,18 +277,22 @@ prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx) {
 	} else {
 		malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 bt_init(prof_bt_t *bt, void **vec) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	bt->vec = vec;
 	bt->len = 0;
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_enter(tsd_t *tsd, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(tdata == prof_tdata_get(tsd, false));
 
@@ -287,10 +302,12 @@ prof_enter(tsd_t *tsd, prof_tdata_t *tdata) {
 	}
 
 	malloc_mutex_lock(tsd_tsdn(tsd), &bt2gctx_mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_leave(tsd_t *tsd, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(tdata == prof_tdata_get(tsd, false));
 
@@ -313,11 +330,13 @@ prof_leave(tsd_t *tsd, prof_tdata_t *tdata) {
 			prof_gdump(tsd_tsdn(tsd));
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 #ifdef JEMALLOC_PROF_LIBUNWIND
 void
 prof_backtrace(prof_bt_t *bt) {
+	volatile int __A_VARIABLE;
 	int nframes;
 
 	cassert(config_prof);
@@ -326,20 +345,25 @@ prof_backtrace(prof_bt_t *bt) {
 
 	nframes = unw_backtrace(bt->vec, PROF_BT_MAX);
 	if (nframes <= 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	bt->len = nframes;
+	__A_VARIABLE = 1;
 }
 #elif (defined(JEMALLOC_PROF_LIBGCC))
 static _Unwind_Reason_Code
 prof_unwind_init_callback(struct _Unwind_Context *context, void *arg) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
+	__A_VARIABLE = 1;
 	return _URC_NO_REASON;
 }
 
 static _Unwind_Reason_Code
 prof_unwind_callback(struct _Unwind_Context *context, void *arg) {
+	volatile int __A_VARIABLE;
 	prof_unwind_data_t *data = (prof_unwind_data_t *)arg;
 	void *ip;
 
@@ -347,24 +371,29 @@ prof_unwind_callback(struct _Unwind_Context *context, void *arg) {
 
 	ip = (void *)_Unwind_GetIP(context);
 	if (ip == NULL) {
+		__A_VARIABLE = 1;
 		return _URC_END_OF_STACK;
 	}
 	data->bt->vec[data->bt->len] = ip;
 	data->bt->len++;
 	if (data->bt->len == data->max) {
+		__A_VARIABLE = 1;
 		return _URC_END_OF_STACK;
 	}
 
+	__A_VARIABLE = 1;
 	return _URC_NO_REASON;
 }
 
 void
 prof_backtrace(prof_bt_t *bt) {
+	volatile int __A_VARIABLE;
 	prof_unwind_data_t data = {bt, PROF_BT_MAX};
 
 	cassert(config_prof);
 
 	_Unwind_Backtrace(prof_unwind_callback, &data);
+	__A_VARIABLE = 1;
 }
 #elif (defined(JEMALLOC_PROF_GCC))
 void
@@ -532,25 +561,32 @@ prof_backtrace(prof_bt_t *bt) {
 #else
 void
 prof_backtrace(prof_bt_t *bt) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	not_reached();
+	__A_VARIABLE = 1;
 }
 #endif
 
 static malloc_mutex_t *
 prof_gctx_mutex_choose(void) {
+	volatile int __A_VARIABLE;
 	unsigned ngctxs = atomic_fetch_add_u(&cum_gctxs, 1, ATOMIC_RELAXED);
 
+	__A_VARIABLE = 1;
 	return &gctx_locks[(ngctxs - 1) % PROF_NCTX_LOCKS];
 }
 
 static malloc_mutex_t *
 prof_tdata_mutex_choose(uint64_t thr_uid) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return &tdata_locks[thr_uid % PROF_NTDATA_LOCKS];
 }
 
 static prof_gctx_t *
 prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt) {
+	volatile int __A_VARIABLE;
 	/*
 	 * Create a single allocation that has space for vec of length bt->len.
 	 */
@@ -559,6 +595,7 @@ prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt) {
 	    sz_size2index(size), false, NULL, true, arena_get(TSDN_NULL, 0, true),
 	    true);
 	if (gctx == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	gctx->lock = prof_gctx_mutex_choose();
@@ -572,12 +609,14 @@ prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt) {
 	memcpy(gctx->vec, bt->vec, bt->len * sizeof(void *));
 	gctx->bt.vec = gctx->vec;
 	gctx->bt.len = bt->len;
+	__A_VARIABLE = 1;
 	return gctx;
 }
 
 static void
 prof_gctx_try_destroy(tsd_t *tsd, prof_tdata_t *tdata_self, prof_gctx_t *gctx,
     prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	/*
@@ -608,40 +647,52 @@ prof_gctx_try_destroy(tsd_t *tsd, prof_tdata_t *tdata_self, prof_gctx_t *gctx,
 		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 		prof_leave(tsd, tdata_self);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 prof_tctx_should_destroy(tsdn_t *tsdn, prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, tctx->tdata->lock);
 
 	if (opt_prof_accum) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (tctx->cnts.curobjs != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (tctx->prepared) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 prof_gctx_should_destroy(prof_gctx_t *gctx) {
+	volatile int __A_VARIABLE;
 	if (opt_prof_accum) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (!tctx_tree_empty(&gctx->tctxs)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (gctx->nlimbo != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static void
 prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata = tctx->tdata;
 	prof_gctx_t *gctx = tctx->gctx;
 	bool destroy_tdata, destroy_tctx, destroy_gctx;
@@ -714,6 +765,7 @@ prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx) {
 	if (destroy_tctx) {
 		idalloctm(tsd_tsdn(tsd), tctx, NULL, NULL, true, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -783,6 +835,7 @@ prof_lookup_global(tsd_t *tsd, prof_bt_t *bt, prof_tdata_t *tdata,
 
 prof_tctx_t *
 prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
+	volatile int __A_VARIABLE;
 	union {
 		prof_tctx_t	*p;
 		void		*v;
@@ -794,6 +847,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -814,6 +868,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 		 */
 		if (prof_lookup_global(tsd, bt, tdata, &btkey, &gctx,
 		    &new_gctx)) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 
@@ -825,6 +880,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 			if (new_gctx) {
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 			}
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		ret.p->tdata = tdata;
@@ -843,6 +899,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 			}
 			idalloctm(tsd_tsdn(tsd), ret.v, NULL, NULL, true, true);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
@@ -852,6 +909,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 	}
 
+	__A_VARIABLE = 1;
 	return ret.p;
 }
 
@@ -913,15 +971,18 @@ prof_sample_threshold_update(prof_tdata_t *tdata) {
 static prof_tdata_t *
 prof_tdata_count_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
     void *arg) {
+	volatile int __A_VARIABLE;
 	size_t *tdata_count = (size_t *)arg;
 
 	(*tdata_count)++;
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 size_t
 prof_tdata_count(void) {
+	volatile int __A_VARIABLE;
 	size_t tdata_count = 0;
 	tsdn_t *tsdn;
 
@@ -931,11 +992,13 @@ prof_tdata_count(void) {
 	    (void *)&tdata_count);
 	malloc_mutex_unlock(tsdn, &tdatas_mtx);
 
+	__A_VARIABLE = 1;
 	return tdata_count;
 }
 
 size_t
 prof_bt_count(void) {
+	volatile int __A_VARIABLE;
 	size_t bt_count;
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
@@ -943,6 +1006,7 @@ prof_bt_count(void) {
 	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -950,12 +1014,14 @@ prof_bt_count(void) {
 	bt_count = ckh_count(&bt2gctx);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &bt2gctx_mtx);
 
+	__A_VARIABLE = 1;
 	return bt_count;
 }
 #endif
 
 static int
 prof_dump_open_impl(bool propagate_err, const char *filename) {
+	volatile int __A_VARIABLE;
 	int fd;
 
 	fd = creat(filename, 0644);
@@ -967,12 +1033,14 @@ prof_dump_open_impl(bool propagate_err, const char *filename) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 prof_dump_open_t *JET_MUTABLE prof_dump_open = prof_dump_open_impl;
 
 static bool
 prof_dump_flush(bool propagate_err) {
+	volatile int __A_VARIABLE;
 	bool ret = false;
 	ssize_t err;
 
@@ -991,11 +1059,13 @@ prof_dump_flush(bool propagate_err) {
 	}
 	prof_dump_buf_end = 0;
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static bool
 prof_dump_close(bool propagate_err) {
+	volatile int __A_VARIABLE;
 	bool ret;
 
 	assert(prof_dump_fd != -1);
@@ -1003,11 +1073,13 @@ prof_dump_close(bool propagate_err) {
 	close(prof_dump_fd);
 	prof_dump_fd = -1;
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static bool
 prof_dump_write(bool propagate_err, const char *s) {
+	volatile int __A_VARIABLE;
 	size_t i, slen, n;
 
 	cassert(config_prof);
@@ -1018,6 +1090,7 @@ prof_dump_write(bool propagate_err, const char *s) {
 		/* Flush the buffer if it is full. */
 		if (prof_dump_buf_end == PROF_DUMP_BUFSIZE) {
 			if (prof_dump_flush(propagate_err) && propagate_err) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -1034,12 +1107,14 @@ prof_dump_write(bool propagate_err, const char *s) {
 		i += n;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 JEMALLOC_FORMAT_PRINTF(2, 3)
 static bool
 prof_dump_printf(bool propagate_err, const char *format, ...) {
+	volatile int __A_VARIABLE;
 	bool ret;
 	va_list ap;
 	char buf[PROF_PRINTF_BUFSIZE];
@@ -1049,11 +1124,13 @@ prof_dump_printf(bool propagate_err, const char *format, ...) {
 	va_end(ap);
 	ret = prof_dump_write(propagate_err, buf);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, tctx->tdata->lock);
 
 	malloc_mutex_lock(tsdn, tctx->gctx->lock);
@@ -1061,6 +1138,7 @@ prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata) {
 	switch (tctx->state) {
 	case prof_tctx_state_initializing:
 		malloc_mutex_unlock(tsdn, tctx->gctx->lock);
+		__A_VARIABLE = 1;
 		return;
 	case prof_tctx_state_nominal:
 		tctx->state = prof_tctx_state_dumping;
@@ -1081,10 +1159,12 @@ prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata) {
 	case prof_tctx_state_purgatory:
 		not_reached();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_tctx_merge_gctx(tsdn_t *tsdn, prof_tctx_t *tctx, prof_gctx_t *gctx) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, gctx->lock);
 
 	gctx->cnt_summed.curobjs += tctx->dump_cnts.curobjs;
@@ -1093,10 +1173,12 @@ prof_tctx_merge_gctx(tsdn_t *tsdn, prof_tctx_t *tctx, prof_gctx_t *gctx) {
 		gctx->cnt_summed.accumobjs += tctx->dump_cnts.accumobjs;
 		gctx->cnt_summed.accumbytes += tctx->dump_cnts.accumbytes;
 	}
+	__A_VARIABLE = 1;
 }
 
 static prof_tctx_t *
 prof_tctx_merge_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn = (tsdn_t *)arg;
 
 	malloc_mutex_assert_owner(tsdn, tctx->gctx->lock);
@@ -1113,6 +1195,7 @@ prof_tctx_merge_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
 		not_reached();
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1123,6 +1206,7 @@ struct prof_tctx_dump_iter_arg_s {
 
 static prof_tctx_t *
 prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *opaque) {
+	volatile int __A_VARIABLE;
 	struct prof_tctx_dump_iter_arg_s *arg =
 	    (struct prof_tctx_dump_iter_arg_s *)opaque;
 
@@ -1140,17 +1224,20 @@ prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *opaque) {
 		    "%"FMTu64"]\n", tctx->thr_uid, tctx->dump_cnts.curobjs,
 		    tctx->dump_cnts.curbytes, tctx->dump_cnts.accumobjs,
 		    tctx->dump_cnts.accumbytes)) {
+			__A_VARIABLE = 1;
 			return tctx;
 		}
 		break;
 	default:
 		not_reached();
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static prof_tctx_t *
 prof_tctx_finish_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn = (tsdn_t *)arg;
 	prof_tctx_t *ret;
 
@@ -1172,11 +1259,13 @@ prof_tctx_finish_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
 
 	ret = NULL;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 prof_dump_gctx_prep(tsdn_t *tsdn, prof_gctx_t *gctx, prof_gctx_tree_t *gctxs) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	malloc_mutex_lock(tsdn, gctx->lock);
@@ -1192,6 +1281,7 @@ prof_dump_gctx_prep(tsdn_t *tsdn, prof_gctx_t *gctx, prof_gctx_tree_t *gctxs) {
 	memset(&gctx->cnt_summed, 0, sizeof(prof_cnt_t));
 
 	malloc_mutex_unlock(tsdn, gctx->lock);
+	__A_VARIABLE = 1;
 }
 
 struct prof_gctx_merge_iter_arg_s {
@@ -1201,6 +1291,7 @@ struct prof_gctx_merge_iter_arg_s {
 
 static prof_gctx_t *
 prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
+	volatile int __A_VARIABLE;
 	struct prof_gctx_merge_iter_arg_s *arg =
 	    (struct prof_gctx_merge_iter_arg_s *)opaque;
 
@@ -1212,11 +1303,13 @@ prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
 	}
 	malloc_mutex_unlock(arg->tsdn, gctx->lock);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static void
 prof_gctx_finish(tsd_t *tsd, prof_gctx_tree_t *gctxs) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata = prof_tdata_get(tsd, false);
 	prof_gctx_t *gctx;
 
@@ -1259,6 +1352,7 @@ prof_gctx_finish(tsd_t *tsd, prof_gctx_tree_t *gctxs) {
 			malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 struct prof_tdata_merge_iter_arg_s {
@@ -1269,6 +1363,7 @@ struct prof_tdata_merge_iter_arg_s {
 static prof_tdata_t *
 prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
     void *opaque) {
+	volatile int __A_VARIABLE;
 	struct prof_tdata_merge_iter_arg_s *arg =
 	    (struct prof_tdata_merge_iter_arg_s *)opaque;
 
@@ -1298,15 +1393,18 @@ prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 	}
 	malloc_mutex_unlock(arg->tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static prof_tdata_t *
 prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
     void *arg) {
+	volatile int __A_VARIABLE;
 	bool propagate_err = *(bool *)arg;
 
 	if (!tdata->dumping) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1317,14 +1415,17 @@ prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 	    tdata->cnt_summed.accumbytes,
 	    (tdata->thread_name != NULL) ? " " : "",
 	    (tdata->thread_name != NULL) ? tdata->thread_name : "")) {
+		__A_VARIABLE = 1;
 		return tdata;
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static bool
 prof_dump_header_impl(tsdn_t *tsdn, bool propagate_err,
     const prof_cnt_t *cnt_all) {
+	volatile int __A_VARIABLE;
 	bool ret;
 
 	if (prof_dump_printf(propagate_err,
@@ -1332,6 +1433,7 @@ prof_dump_header_impl(tsdn_t *tsdn, bool propagate_err,
 	    "  t*: %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]\n",
 	    ((uint64_t)1U << lg_prof_sample), cnt_all->curobjs,
 	    cnt_all->curbytes, cnt_all->accumobjs, cnt_all->accumbytes)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1339,6 +1441,7 @@ prof_dump_header_impl(tsdn_t *tsdn, bool propagate_err,
 	ret = (tdata_tree_iter(&tdatas, NULL, prof_tdata_dump_iter,
 	    (void *)&propagate_err) != NULL);
 	malloc_mutex_unlock(tsdn, &tdatas_mtx);
+	__A_VARIABLE = 1;
 	return ret;
 }
 prof_dump_header_t *JET_MUTABLE prof_dump_header = prof_dump_header_impl;
@@ -1346,6 +1449,7 @@ prof_dump_header_t *JET_MUTABLE prof_dump_header = prof_dump_header_impl;
 static bool
 prof_dump_gctx(tsdn_t *tsdn, bool propagate_err, prof_gctx_t *gctx,
     const prof_bt_t *bt, prof_gctx_tree_t *gctxs) {
+	volatile int __A_VARIABLE;
 	bool ret;
 	unsigned i;
 	struct prof_tctx_dump_iter_arg_s prof_tctx_dump_iter_arg;
@@ -1395,6 +1499,7 @@ prof_dump_gctx(tsdn_t *tsdn, bool propagate_err, prof_gctx_t *gctx,
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1402,6 +1507,7 @@ label_return:
 JEMALLOC_FORMAT_PRINTF(1, 2)
 static int
 prof_open_maps(const char *format, ...) {
+	volatile int __A_VARIABLE;
 	int mfd;
 	va_list ap;
 	char filename[PATH_MAX + 1];
@@ -1419,6 +1525,7 @@ prof_open_maps(const char *format, ...) {
 	}
 #endif
 
+	__A_VARIABLE = 1;
 	return mfd;
 }
 #endif
@@ -1434,6 +1541,7 @@ prof_getpid(void) {
 
 static bool
 prof_dump_maps(bool propagate_err) {
+	volatile int __A_VARIABLE;
 	bool ret;
 	int mfd;
 
@@ -1485,6 +1593,7 @@ label_return:
 	if (mfd != -1) {
 		close(mfd);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1495,6 +1604,7 @@ label_return:
 static void
 prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_ngctx,
     const char *filename) {
+	volatile int __A_VARIABLE;
 #ifdef JEMALLOC_PROF
 	/*
 	 * Scaling is equivalent AdjustSamples() in jeprof, but the result may
@@ -1521,6 +1631,7 @@ prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_ngctx,
 		    filename);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 struct prof_gctx_dump_iter_arg_s {
@@ -1530,6 +1641,7 @@ struct prof_gctx_dump_iter_arg_s {
 
 static prof_gctx_t *
 prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
+	volatile int __A_VARIABLE;
 	prof_gctx_t *ret;
 	struct prof_gctx_dump_iter_arg_s *arg =
 	    (struct prof_gctx_dump_iter_arg_s *)opaque;
@@ -1545,6 +1657,7 @@ prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
 	ret = NULL;
 label_return:
 	malloc_mutex_unlock(arg->tsdn, gctx->lock);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1553,6 +1666,7 @@ prof_dump_prep(tsd_t *tsd, prof_tdata_t *tdata,
     struct prof_tdata_merge_iter_arg_s *prof_tdata_merge_iter_arg,
     struct prof_gctx_merge_iter_arg_s *prof_gctx_merge_iter_arg,
     prof_gctx_tree_t *gctxs) {
+	volatile int __A_VARIABLE;
 	size_t tabind;
 	union {
 		prof_gctx_t	*p;
@@ -1588,6 +1702,7 @@ prof_dump_prep(tsd_t *tsd, prof_tdata_t *tdata,
 	    (void *)prof_gctx_merge_iter_arg);
 
 	prof_leave(tsd, tdata);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1597,8 +1712,10 @@ prof_dump_file(tsd_t *tsd, bool propagate_err, const char *filename,
     struct prof_gctx_merge_iter_arg_s *prof_gctx_merge_iter_arg,
     struct prof_gctx_dump_iter_arg_s *prof_gctx_dump_iter_arg,
     prof_gctx_tree_t *gctxs) {
+	volatile int __A_VARIABLE;
 	/* Create dump file. */
 	if ((prof_dump_fd = prof_dump_open(propagate_err, filename)) == -1) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1622,23 +1739,28 @@ prof_dump_file(tsd_t *tsd, bool propagate_err, const char *filename,
 	}
 
 	if (prof_dump_close(propagate_err)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 label_write_error:
 	prof_dump_close(propagate_err);
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
     bool leakcheck) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(tsd_reentrancy_level_get(tsd) == 0);
 
 	prof_tdata_t * tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1660,6 +1782,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 	post_reentrancy(tsd);
 
 	if (err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1667,6 +1790,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 		prof_leakcheck(&prof_tdata_merge_iter_arg.cnt_all,
 		    prof_gctx_merge_iter_arg.leak_ngctx, filename);
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1674,6 +1798,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 void
 prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
     uint64_t *accumbytes) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
 	struct prof_tdata_merge_iter_arg_s prof_tdata_merge_iter_arg;
@@ -1695,6 +1820,7 @@ prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
 		if (accumbytes != NULL) {
 			*accumbytes = 0;
 		}
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1714,6 +1840,7 @@ prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
 	if (accumbytes != NULL) {
 		*accumbytes = prof_tdata_merge_iter_arg.cnt_all.accumbytes;
 	}
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -1721,6 +1848,7 @@ prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
 #define VSEQ_INVALID		UINT64_C(0xffffffffffffffff)
 static void
 prof_dump_filename(char *filename, char v, uint64_t vseq) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	if (vseq != VSEQ_INVALID) {
@@ -1735,10 +1863,12 @@ prof_dump_filename(char *filename, char v, uint64_t vseq) {
 		    opt_prof_prefix, prof_getpid(), prof_dump_seq, v);
 	}
 	prof_dump_seq++;
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_fdump(void) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	char filename[DUMP_FILENAME_BUFSIZE];
 
@@ -1747,6 +1877,7 @@ prof_fdump(void) {
 	assert(opt_prof_prefix[0] != '\0');
 
 	if (!prof_booted) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsd_fetch();
@@ -1756,6 +1887,7 @@ prof_fdump(void) {
 	prof_dump_filename(filename, 'f', VSEQ_INVALID);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 	prof_dump(tsd, false, filename, opt_prof_leak);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -1776,25 +1908,30 @@ prof_accum_init(tsdn_t *tsdn, prof_accum_t *prof_accum) {
 
 void
 prof_idump(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
 	if (!prof_booted || tsdn_null(tsdn) || !prof_active_get_unlocked()) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsdn_tsd(tsdn);
 	if (tsd_reentrancy_level_get(tsd) > 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tdata->enq) {
 		tdata->enq_idump = true;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1806,20 +1943,24 @@ prof_idump(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
 prof_mdump(tsd_t *tsd, const char *filename) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 	assert(tsd_reentrancy_level_get(tsd) == 0);
 
 	if (!opt_prof || !prof_booted) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	char filename_buf[DUMP_FILENAME_BUFSIZE];
 	if (filename == NULL) {
 		/* No filename specified, so automatically generate one. */
 		if (opt_prof_prefix[0] == '\0') {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
@@ -1828,30 +1969,36 @@ prof_mdump(tsd_t *tsd, const char *filename) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		filename = filename_buf;
 	}
+	__A_VARIABLE = 1;
 	return prof_dump(tsd, true, filename, false);
 }
 
 void
 prof_gdump(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
 	if (!prof_booted || tsdn_null(tsdn) || !prof_active_get_unlocked()) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsdn_tsd(tsdn);
 	if (tsd_reentrancy_level_get(tsd) > 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tdata->enq) {
 		tdata->enq_gdump = true;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1863,32 +2010,39 @@ prof_gdump(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsdn, &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_bt_hash(const void *key, size_t r_hash[2]) {
+	volatile int __A_VARIABLE;
 	prof_bt_t *bt = (prof_bt_t *)key;
 
 	cassert(config_prof);
 
 	hash(bt->vec, bt->len * sizeof(void *), 0x94122f33U, r_hash);
+	__A_VARIABLE = 1;
 }
 
 static bool
 prof_bt_keycomp(const void *k1, const void *k2) {
+	volatile int __A_VARIABLE;
 	const prof_bt_t *bt1 = (prof_bt_t *)k1;
 	const prof_bt_t *bt2 = (prof_bt_t *)k2;
 
 	cassert(config_prof);
 
 	if (bt1->len != bt2->len) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return (memcmp(bt1->vec, bt2->vec, bt1->len * sizeof(void *)) == 0);
 }
 
 static uint64_t
 prof_thr_uid_alloc(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	uint64_t thr_uid;
 
 	malloc_mutex_lock(tsdn, &next_thr_uid_mtx);
@@ -1896,12 +2050,14 @@ prof_thr_uid_alloc(tsdn_t *tsdn) {
 	next_thr_uid++;
 	malloc_mutex_unlock(tsdn, &next_thr_uid_mtx);
 
+	__A_VARIABLE = 1;
 	return thr_uid;
 }
 
 static prof_tdata_t *
 prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
     char *thread_name, bool active) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
@@ -1911,6 +2067,7 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	    sz_size2index(sizeof(prof_tdata_t)), false, NULL, true,
 	    arena_get(TSDN_NULL, 0, true), true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1925,6 +2082,7 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	if (ckh_new(tsd, &tdata->bt2tctx, PROF_CKH_MINITEMS, prof_bt_hash,
 	    prof_bt_keycomp)) {
 		idalloctm(tsd_tsdn(tsd), tdata, NULL, NULL, true, true);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1942,37 +2100,47 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	tdata_tree_insert(&tdatas, tdata);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 
+	__A_VARIABLE = 1;
 	return tdata;
 }
 
 prof_tdata_t *
 prof_tdata_init(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return prof_tdata_init_impl(tsd, prof_thr_uid_alloc(tsd_tsdn(tsd)), 0,
 	    NULL, prof_thread_active_init_get(tsd_tsdn(tsd)));
 }
 
 static bool
 prof_tdata_should_destroy_unlocked(prof_tdata_t *tdata, bool even_if_attached) {
+	volatile int __A_VARIABLE;
 	if (tdata->attached && !even_if_attached) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (ckh_count(&tdata->bt2tctx) != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 prof_tdata_should_destroy(tsdn_t *tsdn, prof_tdata_t *tdata,
     bool even_if_attached) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return prof_tdata_should_destroy_unlocked(tdata, even_if_attached);
 }
 
 static void
 prof_tdata_destroy_locked(tsd_t *tsd, prof_tdata_t *tdata,
     bool even_if_attached) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &tdatas_mtx);
 
 	tdata_tree_remove(&tdatas, tdata);
@@ -1985,17 +2153,21 @@ prof_tdata_destroy_locked(tsd_t *tsd, prof_tdata_t *tdata,
 	}
 	ckh_delete(tsd, &tdata->bt2tctx);
 	idalloctm(tsd_tsdn(tsd), tdata, NULL, NULL, true, true);
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata, bool even_if_attached) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
 	prof_tdata_destroy_locked(tsd, tdata, even_if_attached);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
 prof_tdata_detach(tsd_t *tsd, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	bool destroy_tdata;
 
 	malloc_mutex_lock(tsd_tsdn(tsd), tdata->lock);
@@ -2017,10 +2189,12 @@ prof_tdata_detach(tsd_t *tsd, prof_tdata_t *tdata) {
 	if (destroy_tdata) {
 		prof_tdata_destroy(tsd, tdata, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 prof_tdata_t *
 prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	uint64_t thr_uid = tdata->thr_uid;
 	uint64_t thr_discrim = tdata->thr_discrim + 1;
 	char *thread_name = (tdata->thread_name != NULL) ?
@@ -2028,12 +2202,14 @@ prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata) {
 	bool active = tdata->active;
 
 	prof_tdata_detach(tsd, tdata);
+	__A_VARIABLE = 1;
 	return prof_tdata_init_impl(tsd, thr_uid, thr_discrim, thread_name,
 	    active);
 }
 
 static bool
 prof_tdata_expire(tsdn_t *tsdn, prof_tdata_t *tdata) {
+	volatile int __A_VARIABLE;
 	bool destroy_tdata;
 
 	malloc_mutex_lock(tsdn, tdata->lock);
@@ -2046,19 +2222,23 @@ prof_tdata_expire(tsdn_t *tsdn, prof_tdata_t *tdata) {
 	}
 	malloc_mutex_unlock(tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return destroy_tdata;
 }
 
 static prof_tdata_t *
 prof_tdata_reset_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
     void *arg) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn = (tsdn_t *)arg;
 
+	__A_VARIABLE = 1;
 	return (prof_tdata_expire(tsdn, tdata) ? tdata : NULL);
 }
 
 void
 prof_reset(tsd_t *tsd, size_t lg_sample) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *next;
 
 	assert(lg_sample < (sizeof(uint64_t) << 3));
@@ -2082,13 +2262,16 @@ prof_reset(tsd_t *tsd, size_t lg_sample) {
 
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 prof_tdata_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	if (!config_prof) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -2096,87 +2279,105 @@ prof_tdata_cleanup(tsd_t *tsd) {
 	if (tdata != NULL) {
 		prof_tdata_detach(tsd, tdata);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
 prof_active_get(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	bool prof_active_current;
 
 	malloc_mutex_lock(tsdn, &prof_active_mtx);
 	prof_active_current = prof_active;
 	malloc_mutex_unlock(tsdn, &prof_active_mtx);
+	__A_VARIABLE = 1;
 	return prof_active_current;
 }
 
 bool
 prof_active_set(tsdn_t *tsdn, bool active) {
+	volatile int __A_VARIABLE;
 	bool prof_active_old;
 
 	malloc_mutex_lock(tsdn, &prof_active_mtx);
 	prof_active_old = prof_active;
 	prof_active = active;
 	malloc_mutex_unlock(tsdn, &prof_active_mtx);
+	__A_VARIABLE = 1;
 	return prof_active_old;
 }
 
 const char *
 prof_thread_name_get(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return "";
 	}
+	__A_VARIABLE = 1;
 	return (tdata->thread_name != NULL ? tdata->thread_name : "");
 }
 
 static char *
 prof_thread_name_alloc(tsdn_t *tsdn, const char *thread_name) {
+	volatile int __A_VARIABLE;
 	char *ret;
 	size_t size;
 
 	if (thread_name == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	size = strlen(thread_name) + 1;
 	if (size == 1) {
+		__A_VARIABLE = 1;
 		return "";
 	}
 
 	ret = iallocztm(tsdn, size, sz_size2index(size), false, NULL, true,
 	    arena_get(TSDN_NULL, 0, true), true);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	memcpy(ret, thread_name, size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 int
 prof_thread_name_set(tsd_t *tsd, const char *thread_name) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 	unsigned i;
 	char *s;
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
 	/* Validate input. */
 	if (thread_name == NULL) {
+		__A_VARIABLE = 1;
 		return EFAULT;
 	}
 	for (i = 0; thread_name[i] != '\0'; i++) {
 		char c = thread_name[i];
 		if (!isgraph(c) && !isblank(c)) {
+			__A_VARIABLE = 1;
 			return EFAULT;
 		}
 	}
 
 	s = prof_thread_name_alloc(tsd_tsdn(tsd), thread_name);
 	if (s == NULL) {
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -2188,84 +2389,102 @@ prof_thread_name_set(tsd_t *tsd, const char *thread_name) {
 	if (strlen(s) > 0) {
 		tdata->thread_name = s;
 	}
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 bool
 prof_thread_active_get(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return tdata->active;
 }
 
 bool
 prof_thread_active_set(tsd_t *tsd, bool active) {
+	volatile int __A_VARIABLE;
 	prof_tdata_t *tdata;
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	tdata->active = active;
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 prof_thread_active_init_get(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	bool active_init;
 
 	malloc_mutex_lock(tsdn, &prof_thread_active_init_mtx);
 	active_init = prof_thread_active_init;
 	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
+	__A_VARIABLE = 1;
 	return active_init;
 }
 
 bool
 prof_thread_active_init_set(tsdn_t *tsdn, bool active_init) {
+	volatile int __A_VARIABLE;
 	bool active_init_old;
 
 	malloc_mutex_lock(tsdn, &prof_thread_active_init_mtx);
 	active_init_old = prof_thread_active_init;
 	prof_thread_active_init = active_init;
 	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
+	__A_VARIABLE = 1;
 	return active_init_old;
 }
 
 bool
 prof_gdump_get(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	bool prof_gdump_current;
 
 	malloc_mutex_lock(tsdn, &prof_gdump_mtx);
 	prof_gdump_current = prof_gdump_val;
 	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
+	__A_VARIABLE = 1;
 	return prof_gdump_current;
 }
 
 bool
 prof_gdump_set(tsdn_t *tsdn, bool gdump) {
+	volatile int __A_VARIABLE;
 	bool prof_gdump_old;
 
 	malloc_mutex_lock(tsdn, &prof_gdump_mtx);
 	prof_gdump_old = prof_gdump_val;
 	prof_gdump_val = gdump;
 	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
+	__A_VARIABLE = 1;
 	return prof_gdump_old;
 }
 
 void
 prof_boot0(void) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	memcpy(opt_prof_prefix, PROF_PREFIX_DEFAULT,
 	    sizeof(PROF_PREFIX_DEFAULT));
+	__A_VARIABLE = 1;
 }
 
 void
 prof_boot1(void) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	/*
@@ -2286,10 +2505,12 @@ prof_boot1(void) {
 			    opt_lg_prof_interval);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
 prof_boot2(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	cassert(config_prof);
 
 	if (opt_prof) {
@@ -2300,12 +2521,14 @@ prof_boot2(tsd_t *tsd) {
 		prof_active = opt_prof_active;
 		if (malloc_mutex_init(&prof_active_mtx, "prof_active",
 		    WITNESS_RANK_PROF_ACTIVE, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		prof_gdump_val = opt_prof_gdump;
 		if (malloc_mutex_init(&prof_gdump_mtx, "prof_gdump",
 		    WITNESS_RANK_PROF_GDUMP, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
@@ -2314,36 +2537,43 @@ prof_boot2(tsd_t *tsd) {
 		    "prof_thread_active_init",
 		    WITNESS_RANK_PROF_THREAD_ACTIVE_INIT,
 		    malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		if (ckh_new(tsd, &bt2gctx, PROF_CKH_MINITEMS, prof_bt_hash,
 		    prof_bt_keycomp)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		if (malloc_mutex_init(&bt2gctx_mtx, "prof_bt2gctx",
 		    WITNESS_RANK_PROF_BT2GCTX, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		tdata_tree_new(&tdatas);
 		if (malloc_mutex_init(&tdatas_mtx, "prof_tdatas",
 		    WITNESS_RANK_PROF_TDATAS, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		next_thr_uid = 0;
 		if (malloc_mutex_init(&next_thr_uid_mtx, "prof_next_thr_uid",
 		    WITNESS_RANK_PROF_NEXT_THR_UID, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		if (malloc_mutex_init(&prof_dump_seq_mtx, "prof_dump_seq",
 		    WITNESS_RANK_PROF_DUMP_SEQ, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		if (malloc_mutex_init(&prof_dump_mtx, "prof_dump",
 		    WITNESS_RANK_PROF_DUMP, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
@@ -2359,12 +2589,14 @@ prof_boot2(tsd_t *tsd) {
 		    b0get(), PROF_NCTX_LOCKS * sizeof(malloc_mutex_t),
 		    CACHELINE);
 		if (gctx_locks == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		for (i = 0; i < PROF_NCTX_LOCKS; i++) {
 			if (malloc_mutex_init(&gctx_locks[i], "prof_gctx",
 			    WITNESS_RANK_PROF_GCTX,
 			    malloc_mutex_rank_exclusive)) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -2373,12 +2605,14 @@ prof_boot2(tsd_t *tsd) {
 		    b0get(), PROF_NTDATA_LOCKS * sizeof(malloc_mutex_t),
 		    CACHELINE);
 		if (tdata_locks == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		for (i = 0; i < PROF_NTDATA_LOCKS; i++) {
 			if (malloc_mutex_init(&tdata_locks[i], "prof_tdata",
 			    WITNESS_RANK_PROF_TDATA,
 			    malloc_mutex_rank_exclusive)) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -2394,11 +2628,13 @@ prof_boot2(tsd_t *tsd) {
 
 	prof_booted = true;
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 void
 prof_prefork0(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (config_prof && opt_prof) {
 		unsigned i;
 
@@ -2412,10 +2648,12 @@ prof_prefork0(tsdn_t *tsdn) {
 			malloc_mutex_prefork(tsdn, &gctx_locks[i]);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 prof_prefork1(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (config_prof && opt_prof) {
 		malloc_mutex_prefork(tsdn, &prof_active_mtx);
 		malloc_mutex_prefork(tsdn, &prof_dump_seq_mtx);
@@ -2423,10 +2661,12 @@ prof_prefork1(tsdn_t *tsdn) {
 		malloc_mutex_prefork(tsdn, &next_thr_uid_mtx);
 		malloc_mutex_prefork(tsdn, &prof_thread_active_init_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 prof_postfork_parent(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (config_prof && opt_prof) {
 		unsigned i;
 
@@ -2446,10 +2686,12 @@ prof_postfork_parent(tsdn_t *tsdn) {
 		malloc_mutex_postfork_parent(tsdn, &bt2gctx_mtx);
 		malloc_mutex_postfork_parent(tsdn, &prof_dump_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 prof_postfork_child(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (config_prof && opt_prof) {
 		unsigned i;
 
@@ -2468,6 +2710,7 @@ prof_postfork_child(tsdn_t *tsdn) {
 		malloc_mutex_postfork_child(tsdn, &bt2gctx_mtx);
 		malloc_mutex_postfork_child(tsdn, &prof_dump_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
diff --git a/deps/jemalloc/src/stats.c b/deps/jemalloc/src/stats.c
index 08b9507..e1fc6df 100644
--- a/deps/jemalloc/src/stats.c
+++ b/deps/jemalloc/src/stats.c
@@ -55,8 +55,10 @@ char opt_stats_print_opts[stats_print_tot_num_options+1] = "";
 /* Calculate x.yyy and output a string (takes a fixed sized char array). */
 static bool
 get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
+	volatile int __A_VARIABLE;
 	if (divisor == 0 || dividend > divisor) {
 		/* The rate is not supposed to be greater than 1. */
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (dividend > 0) {
@@ -74,6 +76,7 @@ get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
 		malloc_snprintf(str, 6, "1");
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -81,7 +84,9 @@ get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
 static void
 gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
     const char *mutex, const char *counter) {
+	volatile int __A_VARIABLE;
 	malloc_snprintf(str, buf_len, "stats.%s.%s.%s", prefix, mutex, counter);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -89,6 +94,7 @@ mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
     emitter_col_t *name,
     emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
     emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
+	volatile int __A_VARIABLE;
 	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
 	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
 
@@ -116,12 +122,14 @@ mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
 #undef OP
 #undef WIDTH_uint32_t
 #undef WIDTH_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
 mutex_stats_read_global(const char *name, emitter_col_t *col_name,
     emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
     emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
+	volatile int __A_VARIABLE;
 	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
 
 	col_name->str_val = name;
@@ -139,6 +147,7 @@ mutex_stats_read_global(const char *name, emitter_col_t *col_name,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -146,6 +155,7 @@ mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
     const char *name, emitter_col_t *col_name,
     emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
     emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
+	volatile int __A_VARIABLE;
 	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
 
 	col_name->str_val = name;
@@ -164,12 +174,14 @@ mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
 mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
     emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
     emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
+	volatile int __A_VARIABLE;
 	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
 	emitter_col_t *dst;
 
@@ -186,6 +198,7 @@ mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 /* "row" can be NULL to avoid emitting in table mode. */
@@ -193,6 +206,7 @@ static void
 mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
     emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
     emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
+	volatile int __A_VARIABLE;
 	if (row != NULL) {
 		emitter_table_row(emitter, row);
 	}
@@ -213,10 +227,12 @@ mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i) {
+	volatile int __A_VARIABLE;
 	size_t page;
 	bool in_gap, in_gap_prev;
 	unsigned nbins, j;
@@ -405,10 +421,12 @@ stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i) {
 	if (in_gap) {
 		emitter_table_printf(emitter, "                     ---\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_arena_lextents_print(emitter_t *emitter, unsigned i) {
+	volatile int __A_VARIABLE;
 	unsigned nbins, nlextents, j;
 	bool in_gap, in_gap_prev;
 
@@ -492,10 +510,12 @@ stats_arena_lextents_print(emitter_t *emitter, unsigned i) {
 	if (in_gap) {
 		emitter_table_printf(emitter, "                     ---\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	emitter_row_t row;
 	emitter_col_t col_name;
 	emitter_col_t col64[mutex_prof_num_uint64_t_counters];
@@ -517,11 +537,13 @@ stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind) {
 		emitter_json_dict_end(emitter); /* Close the mutex dict. */
 	}
 	emitter_json_dict_end(emitter); /* End "mutexes". */
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
     bool mutex) {
+	volatile int __A_VARIABLE;
 	unsigned nthreads;
 	const char *dss;
 	ssize_t dirty_decay_ms, muzzy_decay_ms;
@@ -820,10 +842,12 @@ stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
 	if (large) {
 		stats_arena_lextents_print(emitter, i);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_general_print(emitter_t *emitter) {
+	volatile int __A_VARIABLE;
 	const char *cpv;
 	bool bv, bv2;
 	unsigned uv;
@@ -1059,11 +1083,13 @@ stats_general_print(emitter_t *emitter) {
 	}
 
 	emitter_json_dict_end(emitter); /* Close "arenas" */
+	__A_VARIABLE = 1;
 }
 
 static void
 stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
     bool unmerged, bool bins, bool large, bool mutex) {
+	volatile int __A_VARIABLE;
 	/*
 	 * These should be deleted.  We keep them around for a while, to aid in
 	 * the transition to the emitter code.
@@ -1219,6 +1245,7 @@ stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
 		}
 		emitter_json_dict_end(emitter); /* Close "stats.arenas". */
 	}
+	__A_VARIABLE = 1;
 }
 
 void
diff --git a/deps/jemalloc/src/tcache.c b/deps/jemalloc/src/tcache.c
index a769a6b..f83fe72 100644
--- a/deps/jemalloc/src/tcache.c
+++ b/deps/jemalloc/src/tcache.c
@@ -33,11 +33,14 @@ static malloc_mutex_t	tcaches_mtx;
 
 size_t
 tcache_salloc(tsdn_t *tsdn, const void *ptr) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arena_salloc(tsdn, ptr);
 }
 
 void
 tcache_event_hard(tsd_t *tsd, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	szind_t binind = tcache->next_gc_bin;
 
 	cache_bin_t *tbin;
@@ -82,11 +85,13 @@ tcache_event_hard(tsd_t *tsd, tcache_t *tcache) {
 	if (tcache->next_gc_bin == nhbins) {
 		tcache->next_gc_bin = 0;
 	}
+	__A_VARIABLE = 1;
 }
 
 void *
 tcache_alloc_small_hard(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
     cache_bin_t *tbin, szind_t binind, bool *tcache_success) {
+	volatile int __A_VARIABLE;
 	void *ret;
 
 	assert(tcache->arena != NULL);
@@ -97,12 +102,14 @@ tcache_alloc_small_hard(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
 	}
 	ret = cache_bin_alloc_easy(tbin, tcache_success);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, cache_bin_t *tbin,
     szind_t binind, unsigned rem) {
+	volatile int __A_VARIABLE;
 	bool merged_stats = false;
 
 	assert(binind < NBINS);
@@ -183,11 +190,13 @@ tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, cache_bin_t *tbin,
 	if (tbin->ncached < tbin->low_water) {
 		tbin->low_water = tbin->ncached;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_bin_flush_large(tsd_t *tsd, cache_bin_t *tbin, szind_t binind,
     unsigned rem, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	bool merged_stats = false;
 
 	assert(binind < nhbins);
@@ -281,10 +290,12 @@ tcache_bin_flush_large(tsd_t *tsd, cache_bin_t *tbin, szind_t binind,
 	if (tbin->ncached < tbin->low_water) {
 		tbin->low_water = tbin->ncached;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_arena_associate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	assert(tcache->arena == NULL);
 	tcache->arena = arena;
 
@@ -302,10 +313,12 @@ tcache_arena_associate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
 
 		malloc_mutex_unlock(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 tcache_arena_dissociate(tsdn_t *tsdn, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	arena_t *arena = tcache->arena;
 	assert(arena != NULL);
 	if (config_stats) {
@@ -329,16 +342,20 @@ tcache_arena_dissociate(tsdn_t *tsdn, tcache_t *tcache) {
 		malloc_mutex_unlock(tsdn, &arena->tcache_ql_mtx);
 	}
 	tcache->arena = NULL;
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_arena_reassociate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	tcache_arena_dissociate(tsdn, tcache);
 	tcache_arena_associate(tsdn, tcache, arena);
+	__A_VARIABLE = 1;
 }
 
 bool
 tsd_tcache_enabled_data_init(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	/* Called upon tsd initialization. */
 	tsd_tcache_enabled_set(tsd, opt_tcache);
 	tsd_slow_update(tsd);
@@ -348,12 +365,14 @@ tsd_tcache_enabled_data_init(tsd_t *tsd) {
 		tsd_tcache_data_init(tsd);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 /* Initialize auto tcache (embedded in TSD). */
 static void
 tcache_init(tsd_t *tsd, tcache_t *tcache, void *avail_stack) {
+	volatile int __A_VARIABLE;
 	memset(&tcache->link, 0, sizeof(ql_elm(tcache_t)));
 	tcache->prof_accumbytes = 0;
 	tcache->next_gc_bin = 0;
@@ -383,11 +402,13 @@ tcache_init(tsd_t *tsd, tcache_t *tcache, void *avail_stack) {
 		    (void **)((uintptr_t)avail_stack + (uintptr_t)stack_offset);
 	}
 	assert(stack_offset == stack_nelms * sizeof(void *));
+	__A_VARIABLE = 1;
 }
 
 /* Initialize auto tcache (embedded in TSD). */
 bool
 tsd_tcache_data_init(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	tcache_t *tcache = tsd_tcachep_get_unsafe(tsd);
 	assert(tcache_small_bin_get(tcache, 0)->avail == NULL);
 	size_t size = stack_nelms * sizeof(void *);
@@ -397,6 +418,7 @@ tsd_tcache_data_init(tsd_t *tsd) {
 	void *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true,
 	    NULL, true, arena_get(TSDN_NULL, 0, true));
 	if (avail_array == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -424,12 +446,14 @@ tsd_tcache_data_init(tsd_t *tsd) {
 	}
 	assert(arena == tcache->arena);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 /* Created manual tcache for tcache.create mallctl. */
 tcache_t *
 tcache_create_explicit(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	tcache_t *tcache;
 	size_t size, stack_offset;
 
@@ -444,6 +468,7 @@ tcache_create_explicit(tsd_t *tsd) {
 	tcache = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true, NULL, true,
 	    arena_get(TSDN_NULL, 0, true));
 	if (tcache == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -451,11 +476,13 @@ tcache_create_explicit(tsd_t *tsd) {
 	    (void *)((uintptr_t)tcache + (uintptr_t)stack_offset));
 	tcache_arena_associate(tsd_tsdn(tsd), tcache, arena_ichoose(tsd, NULL));
 
+	__A_VARIABLE = 1;
 	return tcache;
 }
 
 static void
 tcache_flush_cache(tsd_t *tsd, tcache_t *tcache) {
+	volatile int __A_VARIABLE;
 	assert(tcache->arena != NULL);
 
 	for (unsigned i = 0; i < NBINS; i++) {
@@ -480,16 +507,20 @@ tcache_flush_cache(tsd_t *tsd, tcache_t *tcache) {
 	    tcache->prof_accumbytes)) {
 		prof_idump(tsd_tsdn(tsd));
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_flush(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	assert(tcache_available(tsd));
 	tcache_flush_cache(tsd, tsd_tcachep_get(tsd));
+	__A_VARIABLE = 1;
 }
 
 static void
 tcache_destroy(tsd_t *tsd, tcache_t *tcache, bool tsd_tcache) {
+	volatile int __A_VARIABLE;
 	tcache_flush_cache(tsd, tcache);
 	tcache_arena_dissociate(tsd_tsdn(tsd), tcache);
 
@@ -503,17 +534,20 @@ tcache_destroy(tsd_t *tsd, tcache_t *tcache, bool tsd_tcache) {
 		/* Release both the tcache struct and avail array. */
 		idalloctm(tsd_tsdn(tsd), tcache, NULL, NULL, true, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 /* For auto tcache (embedded in TSD) only. */
 void
 tcache_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	tcache_t *tcache = tsd_tcachep_get(tsd);
 	if (!tcache_available(tsd)) {
 		assert(tsd_tcache_enabled_get(tsd) == false);
 		if (config_debug) {
 			assert(tcache_small_bin_get(tcache, 0)->avail == NULL);
 		}
+		__A_VARIABLE = 1;
 		return;
 	}
 	assert(tsd_tcache_enabled_get(tsd));
@@ -523,10 +557,12 @@ tcache_cleanup(tsd_t *tsd) {
 	if (config_debug) {
 		tcache_small_bin_get(tcache, 0)->avail = NULL;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_stats_merge(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	cassert(config_stats);
@@ -547,10 +583,12 @@ tcache_stats_merge(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
 		    tbin->tstats.nrequests);
 		tbin->tstats.nrequests = 0;
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 tcaches_create_prep(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	bool err;
 
 	malloc_mutex_lock(tsd_tsdn(tsd), &tcaches_mtx);
@@ -572,11 +610,13 @@ tcaches_create_prep(tsd_t *tsd) {
 	err = false;
 label_return:
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tcaches_mtx);
+	__A_VARIABLE = 1;
 	return err;
 }
 
 bool
 tcaches_create(tsd_t *tsd, unsigned *r_ind) {
+	volatile int __A_VARIABLE;
 	witness_assert_depth(tsdn_witness_tsdp_get(tsd_tsdn(tsd)), 0);
 
 	bool err;
@@ -610,33 +650,40 @@ tcaches_create(tsd_t *tsd, unsigned *r_ind) {
 	err = false;
 label_return:
 	witness_assert_depth(tsdn_witness_tsdp_get(tsd_tsdn(tsd)), 0);
+	__A_VARIABLE = 1;
 	return err;
 }
 
 static tcache_t *
 tcaches_elm_remove(tsd_t *tsd, tcaches_t *elm) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &tcaches_mtx);
 
 	if (elm->tcache == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	tcache_t *tcache = elm->tcache;
 	elm->tcache = NULL;
+	__A_VARIABLE = 1;
 	return tcache;
 }
 
 void
 tcaches_flush(tsd_t *tsd, unsigned ind) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsd_tsdn(tsd), &tcaches_mtx);
 	tcache_t *tcache = tcaches_elm_remove(tsd, &tcaches[ind]);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tcaches_mtx);
 	if (tcache != NULL) {
 		tcache_destroy(tsd, tcache, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcaches_destroy(tsd_t *tsd, unsigned ind) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(tsd_tsdn(tsd), &tcaches_mtx);
 	tcaches_t *elm = &tcaches[ind];
 	tcache_t *tcache = tcaches_elm_remove(tsd, elm);
@@ -646,10 +693,12 @@ tcaches_destroy(tsd_t *tsd, unsigned ind) {
 	if (tcache != NULL) {
 		tcache_destroy(tsd, tcache, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
 tcache_boot(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	/* If necessary, clamp opt_lg_tcache_max. */
 	if (opt_lg_tcache_max < 0 || (ZU(1) << opt_lg_tcache_max) <
 	    SMALL_MAXCLASS) {
@@ -660,6 +709,7 @@ tcache_boot(tsdn_t *tsdn) {
 
 	if (malloc_mutex_init(&tcaches_mtx, "tcaches", WITNESS_RANK_TCACHES,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -669,6 +719,7 @@ tcache_boot(tsdn_t *tsdn) {
 	tcache_bin_info = (cache_bin_info_t *)base_alloc(tsdn, b0get(), nhbins
 	    * sizeof(cache_bin_info_t), CACHELINE);
 	if (tcache_bin_info == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	stack_nelms = 0;
@@ -692,26 +743,33 @@ tcache_boot(tsdn_t *tsdn) {
 		stack_nelms += tcache_bin_info[i].ncached_max;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 void
 tcache_prefork(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_prefork(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_postfork_parent(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_postfork_parent(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_postfork_child(tsdn_t *tsdn) {
+	volatile int __A_VARIABLE;
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_postfork_child(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/tsd.c b/deps/jemalloc/src/tsd.c
index c143068..bc93fa2 100644
--- a/deps/jemalloc/src/tsd.c
+++ b/deps/jemalloc/src/tsd.c
@@ -53,6 +53,7 @@ bool tsd_booted = false;
 
 void
 tsd_slow_update(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	if (tsd_nominal(tsd)) {
 		if (malloc_slow || !tsd_tcache_enabled_get(tsd) ||
 		    tsd_reentrancy_level_get(tsd) > 0) {
@@ -61,6 +62,7 @@ tsd_slow_update(tsd_t *tsd) {
 			tsd->state = tsd_state_nominal;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -86,6 +88,7 @@ tsd_data_init(tsd_t *tsd) {
 
 static void
 assert_tsd_data_cleanup_done(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	assert(!tsd_nominal(tsd));
 	assert(*tsd_arenap_get_unsafe(tsd) == NULL);
 	assert(*tsd_iarenap_get_unsafe(tsd) == NULL);
@@ -93,10 +96,12 @@ assert_tsd_data_cleanup_done(tsd_t *tsd) {
 	assert(*tsd_arenas_tdatap_get_unsafe(tsd) == NULL);
 	assert(*tsd_tcache_enabledp_get_unsafe(tsd) == false);
 	assert(*tsd_prof_tdatap_get_unsafe(tsd) == NULL);
+	__A_VARIABLE = 1;
 }
 
 static bool
 tsd_data_init_nocleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	assert(tsd->state == tsd_state_reincarnated ||
 	    tsd->state == tsd_state_minimal_initialized);
 	/*
@@ -110,11 +115,13 @@ tsd_data_init_nocleanup(tsd_t *tsd) {
 	*tsd_reentrancy_levelp_get(tsd) = 1;
 	assert_tsd_data_cleanup_done(tsd);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 tsd_t *
 tsd_fetch_slow(tsd_t *tsd, bool minimal) {
+	volatile int __A_VARIABLE;
 	assert(!tsd_fast(tsd));
 
 	if (tsd->state == tsd_state_nominal_slow) {
@@ -153,17 +160,22 @@ tsd_fetch_slow(tsd_t *tsd, bool minimal) {
 		assert(tsd->state == tsd_state_reincarnated);
 	}
 
+	__A_VARIABLE = 1;
 	return tsd;
 }
 
 void *
 malloc_tsd_malloc(size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return a0malloc(CACHELINE_CEILING(size));
 }
 
 void
 malloc_tsd_dalloc(void *wrapper) {
+	volatile int __A_VARIABLE;
 	a0dalloc(wrapper);
+	__A_VARIABLE = 1;
 }
 
 #if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
@@ -172,6 +184,7 @@ JEMALLOC_EXPORT
 #endif
 void
 _malloc_thread_cleanup(void) {
+	volatile int __A_VARIABLE;
 	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
 	unsigned i;
 
@@ -190,28 +203,34 @@ _malloc_thread_cleanup(void) {
 			}
 		}
 	} while (again);
+	__A_VARIABLE = 1;
 }
 #endif
 
 void
 malloc_tsd_cleanup_register(bool (*f)(void)) {
+	volatile int __A_VARIABLE;
 	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
 	cleanups[ncleanups] = f;
 	ncleanups++;
+	__A_VARIABLE = 1;
 }
 
 static void
 tsd_do_data_cleanup(tsd_t *tsd) {
+	volatile int __A_VARIABLE;
 	prof_tdata_cleanup(tsd);
 	iarena_cleanup(tsd);
 	arena_cleanup(tsd);
 	arenas_tdata_cleanup(tsd);
 	tcache_cleanup(tsd);
 	witnesses_cleanup(tsd_witness_tsdp_get_unsafe(tsd));
+	__A_VARIABLE = 1;
 }
 
 void
 tsd_cleanup(void *arg) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd = (tsd_t *)arg;
 
 	switch (tsd->state) {
@@ -253,33 +272,40 @@ tsd_cleanup(void *arg) {
 		test_callback(data);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 tsd_t *
 malloc_tsd_boot0(void) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 
 	ncleanups = 0;
 	if (tsd_boot0()) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	tsd = tsd_fetch();
 	*tsd_arenas_tdata_bypassp_get(tsd) = true;
+	__A_VARIABLE = 1;
 	return tsd;
 }
 
 void
 malloc_tsd_boot1(void) {
+	volatile int __A_VARIABLE;
 	tsd_boot1();
 	tsd_t *tsd = tsd_fetch();
 	/* malloc_slow has been set properly.  Update tsd_slow. */
 	tsd_slow_update(tsd);
 	*tsd_arenas_tdata_bypassp_get(tsd) = false;
+	__A_VARIABLE = 1;
 }
 
 #ifdef _WIN32
 static BOOL WINAPI
 _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
+	volatile int __A_VARIABLE;
 	switch (fdwReason) {
 #ifdef JEMALLOC_LAZY_LOCK
 	case DLL_THREAD_ATTACH:
@@ -292,6 +318,7 @@ _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
 	default:
 		break;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -323,6 +350,7 @@ BOOL	(WINAPI *const tls_callback)(HINSTANCE hinstDLL,
     !defined(_WIN32))
 void *
 tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
+	volatile int __A_VARIABLE;
 	pthread_t self = pthread_self();
 	tsd_init_block_t *iter;
 
@@ -331,6 +359,7 @@ tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
 	ql_foreach(iter, &head->blocks, link) {
 		if (iter->thread == self) {
 			malloc_mutex_unlock(TSDN_NULL, &head->lock);
+			__A_VARIABLE = 1;
 			return iter->data;
 		}
 	}
@@ -339,13 +368,16 @@ tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
 	block->thread = self;
 	ql_tail_insert(&head->blocks, block, link);
 	malloc_mutex_unlock(TSDN_NULL, &head->lock);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 void
 tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block) {
+	volatile int __A_VARIABLE;
 	malloc_mutex_lock(TSDN_NULL, &head->lock);
 	ql_remove(&head->blocks, block, link);
 	malloc_mutex_unlock(TSDN_NULL, &head->lock);
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/deps/jemalloc/src/witness.c b/deps/jemalloc/src/witness.c
index f42b72a..67aa6e1 100644
--- a/deps/jemalloc/src/witness.c
+++ b/deps/jemalloc/src/witness.c
@@ -8,15 +8,18 @@
 void
 witness_init(witness_t *witness, const char *name, witness_rank_t rank,
     witness_comp_t *comp, void *opaque) {
+	volatile int __A_VARIABLE;
 	witness->name = name;
 	witness->rank = rank;
 	witness->comp = comp;
 	witness->opaque = opaque;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_lock_error_impl(const witness_list_t *witnesses,
     const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	witness_t *w;
 
 	malloc_printf("<jemalloc>: Lock rank order reversal:");
@@ -25,23 +28,28 @@ witness_lock_error_impl(const witness_list_t *witnesses,
 	}
 	malloc_printf(" %s(%u)\n", witness->name, witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_lock_error_t *JET_MUTABLE witness_lock_error = witness_lock_error_impl;
 
 static void
 witness_owner_error_impl(const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	malloc_printf("<jemalloc>: Should own %s(%u)\n", witness->name,
 	    witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_owner_error_t *JET_MUTABLE witness_owner_error =
     witness_owner_error_impl;
 
 static void
 witness_not_owner_error_impl(const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	malloc_printf("<jemalloc>: Should not own %s(%u)\n", witness->name,
 	    witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_not_owner_error_t *JET_MUTABLE witness_not_owner_error =
     witness_not_owner_error_impl;
@@ -49,6 +57,7 @@ witness_not_owner_error_t *JET_MUTABLE witness_not_owner_error =
 static void
 witness_depth_error_impl(const witness_list_t *witnesses,
     witness_rank_t rank_inclusive, unsigned depth) {
+	volatile int __A_VARIABLE;
 	witness_t *w;
 
 	malloc_printf("<jemalloc>: Should own %u lock%s of rank >= %u:", depth,
@@ -58,36 +67,47 @@ witness_depth_error_impl(const witness_list_t *witnesses,
 	}
 	malloc_printf("\n");
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_depth_error_t *JET_MUTABLE witness_depth_error =
     witness_depth_error_impl;
 
 void
 witnesses_cleanup(witness_tsd_t *witness_tsd) {
+	volatile int __A_VARIABLE;
 	witness_assert_lockless(witness_tsd_tsdn(witness_tsd));
 
 	/* Do nothing. */
+	__A_VARIABLE = 1;
 }
 
 void
 witness_prefork(witness_tsd_t *witness_tsd) {
+	volatile int __A_VARIABLE;
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_tsd->forking = true;
+	__A_VARIABLE = 1;
 }
 
 void
 witness_postfork_parent(witness_tsd_t *witness_tsd) {
+	volatile int __A_VARIABLE;
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_tsd->forking = false;
+	__A_VARIABLE = 1;
 }
 
 void
 witness_postfork_child(witness_tsd_t *witness_tsd) {
+	volatile int __A_VARIABLE;
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 #ifndef JEMALLOC_MUTEX_INIT_CB
@@ -97,4 +117,5 @@ witness_postfork_child(witness_tsd_t *witness_tsd) {
 	ql_new(witnesses);
 #endif
 	witness_tsd->forking = false;
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/zone.c b/deps/jemalloc/src/zone.c
index 23dfdd0..d40faa1 100644
--- a/deps/jemalloc/src/zone.c
+++ b/deps/jemalloc/src/zone.c
@@ -131,6 +131,7 @@ static void	zone_reinit_lock(malloc_zone_t *zone);
 
 static size_t
 zone_size(malloc_zone_t *zone, const void *ptr) {
+	volatile int __A_VARIABLE;
 	/*
 	 * There appear to be places within Darwin (such as setenv(3)) that
 	 * cause calls to this function with pointers that *no* zone owns.  If
@@ -140,79 +141,100 @@ zone_size(malloc_zone_t *zone, const void *ptr) {
 	 * not work in practice, we must check all pointers to assure that they
 	 * reside within a mapped extent before determining size.
 	 */
+	__A_VARIABLE = 1;
 	return ivsalloc(tsdn_fetch(), ptr);
 }
 
 static void *
 zone_malloc(malloc_zone_t *zone, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return je_malloc(size);
 }
 
 static void *
 zone_calloc(malloc_zone_t *zone, size_t num, size_t size) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return je_calloc(num, size);
 }
 
 static void *
 zone_valloc(malloc_zone_t *zone, size_t size) {
+	volatile int __A_VARIABLE;
 	void *ret = NULL; /* Assignment avoids useless compiler warning. */
 
 	je_posix_memalign(&ret, PAGE, size);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 zone_free(malloc_zone_t *zone, void *ptr) {
+	volatile int __A_VARIABLE;
 	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
 		je_free(ptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(ptr);
+	__A_VARIABLE = 1;
 }
 
 static void *
 zone_realloc(malloc_zone_t *zone, void *ptr, size_t size) {
+	volatile int __A_VARIABLE;
 	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
+		__A_VARIABLE = 1;
 		return je_realloc(ptr, size);
 	}
 
+	__A_VARIABLE = 1;
 	return realloc(ptr, size);
 }
 
 static void *
 zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size) {
+	volatile int __A_VARIABLE;
 	void *ret = NULL; /* Assignment avoids useless compiler warning. */
 
 	je_posix_memalign(&ret, alignment, size);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 zone_free_definite_size(malloc_zone_t *zone, void *ptr, size_t size) {
+	volatile int __A_VARIABLE;
 	size_t alloc_size;
 
 	alloc_size = ivsalloc(tsdn_fetch(), ptr);
 	if (alloc_size != 0) {
 		assert(alloc_size == size);
 		je_free(ptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(ptr);
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_destroy(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
 	/* This function should never be called. */
 	not_reached();
+	__A_VARIABLE = 1;
 }
 
 static unsigned
 zone_batch_malloc(struct _malloc_zone_t *zone, size_t size, void **results,
     unsigned num_requested) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 0; i < num_requested; i++) {
@@ -221,30 +243,37 @@ zone_batch_malloc(struct _malloc_zone_t *zone, size_t size, void **results,
 			break;
 	}
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
 static void
 zone_batch_free(struct _malloc_zone_t *zone, void **to_be_freed,
     unsigned num_to_be_freed) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 0; i < num_to_be_freed; i++) {
 		zone_free(zone, to_be_freed[i]);
 		to_be_freed[i] = NULL;
 	}
+	__A_VARIABLE = 1;
 }
 
 static size_t
 zone_pressure_relief(struct _malloc_zone_t *zone, size_t goal) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 static size_t
 zone_good_size(malloc_zone_t *zone, size_t size) {
+	volatile int __A_VARIABLE;
 	if (size == 0) {
 		size = 1;
 	}
+	__A_VARIABLE = 1;
 	return sz_s2u(size);
 }
 
@@ -252,24 +281,33 @@ static kern_return_t
 zone_enumerator(task_t task, void *data, unsigned type_mask,
     vm_address_t zone_address, memory_reader_t reader,
     vm_range_recorder_t recorder) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return KERN_SUCCESS;
 }
 
 static boolean_t
 zone_check(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static void
 zone_print(malloc_zone_t *zone, boolean_t verbose) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_log(malloc_zone_t *zone, void *address) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_force_lock(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
 	if (isthreaded) {
 		/*
 		 * See the note in zone_force_unlock, below, to see why we need
@@ -279,10 +317,12 @@ zone_force_lock(malloc_zone_t *zone) {
 		zone_force_lock_pid = getpid();
 		jemalloc_prefork();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_force_unlock(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
 	/*
 	 * zone_force_lock and zone_force_unlock are the entry points to the
 	 * forking machinery on OS X.  The tricky thing is, the child is not
@@ -304,32 +344,40 @@ zone_force_unlock(malloc_zone_t *zone) {
 		}
 		zone_force_lock_pid = -1;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {
+	volatile int __A_VARIABLE;
 	/* We make no effort to actually fill the values */
 	stats->blocks_in_use = 0;
 	stats->size_in_use = 0;
 	stats->max_size_in_use = 0;
 	stats->size_allocated = 0;
+	__A_VARIABLE = 1;
 }
 
 static boolean_t
 zone_locked(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
 	/* Pretend no lock is being held */
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static void
 zone_reinit_lock(malloc_zone_t *zone) {
+	volatile int __A_VARIABLE;
 	/* As of OSX 10.12, this function is only used when force_unlock would
 	 * be used if the zone version were < 9. So just use force_unlock. */
 	zone_force_unlock(zone);
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_init(void) {
+	volatile int __A_VARIABLE;
 	jemalloc_zone.size = zone_size;
 	jemalloc_zone.malloc = zone_malloc;
 	jemalloc_zone.calloc = zone_calloc;
@@ -364,10 +412,12 @@ zone_init(void) {
 	jemalloc_zone_introspect.enumerate_unavailable_without_blocks = NULL;
 #endif
 	jemalloc_zone_introspect.reinit_lock = zone_reinit_lock;
+	__A_VARIABLE = 1;
 }
 
 static malloc_zone_t *
 zone_default_get(void) {
+	volatile int __A_VARIABLE;
 	malloc_zone_t **zones = NULL;
 	unsigned int num_zones = 0;
 
@@ -390,15 +440,18 @@ zone_default_get(void) {
 	}
 
 	if (num_zones) {
+		__A_VARIABLE = 1;
 		return zones[0];
 	}
 
+	__A_VARIABLE = 1;
 	return malloc_default_zone();
 }
 
 /* As written, this function can only promote jemalloc_zone. */
 static void
 zone_promote(void) {
+	volatile int __A_VARIABLE;
 	malloc_zone_t *zone;
 
 	do {
@@ -431,11 +484,13 @@ zone_promote(void) {
 
 		zone = zone_default_get();
 	} while (zone != &jemalloc_zone);
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ATTR(constructor)
 void
 zone_register(void) {
+	volatile int __A_VARIABLE;
 	/*
 	 * If something else replaced the system default zone allocator, don't
 	 * register jemalloc's.
@@ -443,6 +498,7 @@ zone_register(void) {
 	default_zone = zone_default_get();
 	if (!default_zone->zone_name || strcmp(default_zone->zone_name,
 	    "DefaultMallocZone") != 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -466,4 +522,5 @@ zone_register(void) {
 
 	/* Promote the custom zone to be default. */
 	zone_promote();
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/integration/MALLOCX_ARENA.c b/deps/jemalloc/test/integration/MALLOCX_ARENA.c
index 222164d..284c9dd 100644
--- a/deps/jemalloc/test/integration/MALLOCX_ARENA.c
+++ b/deps/jemalloc/test/integration/MALLOCX_ARENA.c
@@ -12,6 +12,7 @@ static bool have_dss =
 
 void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	unsigned thread_ind = (unsigned)(uintptr_t)arg;
 	unsigned arena_ind;
 	void *p;
@@ -41,10 +42,12 @@ thd_start(void *arg) {
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	dallocx(p, 0);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_MALLOCX_ARENA) {
+	volatile int __A_VARIABLE;
 	thd_t thds[NTHREADS];
 	unsigned i;
 
@@ -56,11 +59,14 @@ TEST_BEGIN(test_MALLOCX_ARENA) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_MALLOCX_ARENA);
 }
diff --git a/deps/jemalloc/test/integration/aligned_alloc.c b/deps/jemalloc/test/integration/aligned_alloc.c
index 536b67e..bbefac4 100644
--- a/deps/jemalloc/test/integration/aligned_alloc.c
+++ b/deps/jemalloc/test/integration/aligned_alloc.c
@@ -9,11 +9,14 @@
  */
 static void
 purge(void) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_alignment_errors) {
+	volatile int __A_VARIABLE;
 	size_t alignment;
 	void *p;
 
@@ -31,10 +34,12 @@ TEST_BEGIN(test_alignment_errors) {
 		    "Expected error for invalid alignment %zu",
 		    alignment + 1);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_oom_errors) {
+	volatile int __A_VARIABLE;
 	size_t alignment, size;
 	void *p;
 
@@ -75,10 +80,12 @@ TEST_BEGIN(test_oom_errors) {
 	assert_false(p != NULL || get_errno() != ENOMEM,
 	    "Expected error for aligned_alloc(&p, %zu, %zu)",
 	    alignment, size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size) {
+	volatile int __A_VARIABLE;
 #define NITER 4
 	size_t alignment, size, total;
 	unsigned i;
@@ -121,11 +128,14 @@ TEST_BEGIN(test_alignment_and_size) {
 		purge();
 	}
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_alignment_errors,
 	    test_oom_errors,
diff --git a/deps/jemalloc/test/integration/allocated.c b/deps/jemalloc/test/integration/allocated.c
index 1425fd0..dea7ee5 100644
--- a/deps/jemalloc/test/integration/allocated.c
+++ b/deps/jemalloc/test/integration/allocated.c
@@ -10,6 +10,7 @@ static const bool config_stats =
 
 void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	int err;
 	void *p;
 	uint64_t a0, a1, d0, d1;
@@ -91,30 +92,38 @@ thd_start(void *arg) {
 	    "Deallocated memory counter should increase by at least the amount "
 	    "explicitly deallocated");
 
+	__A_VARIABLE = 1;
 	return NULL;
 label_ENOENT:
 	assert_false(config_stats,
 	    "ENOENT should only be returned if stats are disabled");
 	test_skip("\"thread.allocated\" mallctl not available");
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_main_thread) {
+	volatile int __A_VARIABLE;
 	thd_start(NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_subthread) {
+	volatile int __A_VARIABLE;
 	thd_t thd;
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	/* Run tests multiple times to check for bad interactions. */
+	__A_VARIABLE = 1;
 	return test(
 	    test_main_thread,
 	    test_subthread,
diff --git a/deps/jemalloc/test/integration/extent.c b/deps/jemalloc/test/integration/extent.c
index b5db087..21f5b7c 100644
--- a/deps/jemalloc/test/integration/extent.c
+++ b/deps/jemalloc/test/integration/extent.c
@@ -4,18 +4,22 @@
 
 static bool
 check_background_thread_enabled(void) {
+	volatile int __A_VARIABLE;
 	bool enabled;
 	size_t sz = sizeof(bool);
 	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
 	if (ret == ENOENT) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	assert_d_eq(ret, 0, "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 	return enabled;
 }
 
 static void
 test_extent_body(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t large0, large1, large2, sz;
 	size_t purge_mib[3];
@@ -96,10 +100,12 @@ test_extent_body(unsigned arena_ind) {
 	p = mallocx(42, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 static void
 test_manual_hook_auto_arena(void) {
+	volatile int __A_VARIABLE;
 	unsigned narenas;
 	size_t old_size, new_size, sz;
 	size_t hooks_mib[3];
@@ -113,6 +119,7 @@ test_manual_hook_auto_arena(void) {
 	assert_d_eq(mallctl("opt.narenas", (void *)&narenas, &sz, NULL, 0),
 	    0, "Unexpected mallctl() failure");
 	if (narenas == 1) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -133,10 +140,12 @@ test_manual_hook_auto_arena(void) {
 		    "Expected auto arena 1 created only once.");
 		auto_arena_created = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_manual_hook_body(void) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t old_size, new_size, sz;
 	size_t hooks_mib[3];
@@ -203,9 +212,11 @@ test_manual_hook_body(void) {
 	    "Unexpected extent_hooks error");
 	assert_ptr_eq(old_hooks->merge, default_hooks->merge,
 	    "Unexpected extent_hooks error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_extent_manual_hook) {
+	volatile int __A_VARIABLE;
 	test_manual_hook_auto_arena();
 	test_manual_hook_body();
 
@@ -219,10 +230,12 @@ TEST_BEGIN(test_extent_manual_hook) {
 	test_manual_hook_body();
 
 	try_split = try_merge = try_purge_lazy = try_purge_forced = true;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_extent_auto_hook) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t new_size, sz;
 	extent_hooks_t *new_hooks;
@@ -237,11 +250,14 @@ TEST_BEGIN(test_extent_auto_hook) {
 
 	test_skip_if(check_background_thread_enabled());
 	test_extent_body(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_extent_manual_hook,
 	    test_extent_auto_hook);
diff --git a/deps/jemalloc/test/integration/mallocx.c b/deps/jemalloc/test/integration/mallocx.c
index fd960f3..7637baf 100644
--- a/deps/jemalloc/test/integration/mallocx.c
+++ b/deps/jemalloc/test/integration/mallocx.c
@@ -2,6 +2,7 @@
 
 static unsigned
 get_nsizes_impl(const char *cmd) {
+	volatile int __A_VARIABLE;
 	unsigned ret;
 	size_t z;
 
@@ -9,16 +10,20 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nlarge(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
 static size_t
 get_size_impl(const char *cmd, size_t ind) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	size_t z;
 	size_t mib[4];
@@ -32,11 +37,14 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_large_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
@@ -47,11 +55,14 @@ get_large_size(size_t ind) {
  */
 static void
 purge(void) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_overflow) {
+	volatile int __A_VARIABLE;
 	size_t largemax;
 
 	largemax = get_large_size(get_nlarge()-1);
@@ -68,10 +79,12 @@ TEST_BEGIN(test_overflow) {
 	assert_ptr_null(mallocx(1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)),
 	    "Expected OOM for mallocx(size=1, MALLOCX_ALIGN(%#zx))",
 	    ZU(PTRDIFF_MAX)+1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_oom) {
+	volatile int __A_VARIABLE;
 	size_t largemax;
 	bool oom;
 	void *ptrs[3];
@@ -110,10 +123,12 @@ TEST_BEGIN(test_oom) {
 	assert_ptr_null(mallocx(0x80000000UL, MALLOCX_ALIGN(0x80000000UL)),
 	    "Expected OOM for mallocx()");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_basic) {
+	volatile int __A_VARIABLE;
 #define MAXSZ (((size_t)1) << 23)
 	size_t sz;
 
@@ -147,10 +162,12 @@ TEST_BEGIN(test_basic) {
 		purge();
 	}
 #undef MAXSZ
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size) {
+	volatile int __A_VARIABLE;
 	const char *percpu_arena;
 	size_t sz = sizeof(percpu_arena);
 
@@ -215,11 +232,14 @@ TEST_BEGIN(test_alignment_and_size) {
 	}
 #undef MAXALIGN
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_overflow,
 	    test_oom,
diff --git a/deps/jemalloc/test/integration/overflow.c b/deps/jemalloc/test/integration/overflow.c
index 6a9785b..17208cc 100644
--- a/deps/jemalloc/test/integration/overflow.c
+++ b/deps/jemalloc/test/integration/overflow.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_overflow) {
+	volatile int __A_VARIABLE;
 	unsigned nlextents;
 	size_t mib[4];
 	size_t sz, miblen, max_size_class;
@@ -36,11 +37,14 @@ TEST_BEGIN(test_overflow) {
 	assert_ptr_null(realloc(p, SIZE_T_MAX),
 	    "Expected OOM due to over-sized allocation request");
 	free(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_overflow);
 }
diff --git a/deps/jemalloc/test/integration/posix_memalign.c b/deps/jemalloc/test/integration/posix_memalign.c
index 2c2726d..e35321d 100644
--- a/deps/jemalloc/test/integration/posix_memalign.c
+++ b/deps/jemalloc/test/integration/posix_memalign.c
@@ -9,11 +9,14 @@
  */
 static void
 purge(void) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_alignment_errors) {
+	volatile int __A_VARIABLE;
 	size_t alignment;
 	void *p;
 
@@ -29,10 +32,12 @@ TEST_BEGIN(test_alignment_errors) {
 		    "Expected error for invalid alignment %zu",
 		    alignment + 1);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_oom_errors) {
+	volatile int __A_VARIABLE;
 	size_t alignment, size;
 	void *p;
 
@@ -67,10 +72,12 @@ TEST_BEGIN(test_oom_errors) {
 	assert_d_ne(posix_memalign(&p, alignment, size), 0,
 	    "Expected error for posix_memalign(&p, %zu, %zu)",
 	    alignment, size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size) {
+	volatile int __A_VARIABLE;
 #define NITER 4
 	size_t alignment, size, total;
 	unsigned i;
@@ -115,11 +122,14 @@ TEST_BEGIN(test_alignment_and_size) {
 		purge();
 	}
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_alignment_errors,
 	    test_oom_errors,
diff --git a/deps/jemalloc/test/integration/rallocx.c b/deps/jemalloc/test/integration/rallocx.c
index 7821ca5..2795ec4 100644
--- a/deps/jemalloc/test/integration/rallocx.c
+++ b/deps/jemalloc/test/integration/rallocx.c
@@ -2,6 +2,7 @@
 
 static unsigned
 get_nsizes_impl(const char *cmd) {
+	volatile int __A_VARIABLE;
 	unsigned ret;
 	size_t z;
 
@@ -9,16 +10,20 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nlarge(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
 static size_t
 get_size_impl(const char *cmd, size_t ind) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	size_t z;
 	size_t mib[4];
@@ -32,15 +37,19 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_large_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
 TEST_BEGIN(test_grow_and_shrink) {
+	volatile int __A_VARIABLE;
 	void *p, *q;
 	size_t tsz;
 #define NCYCLES 3
@@ -81,6 +90,7 @@ TEST_BEGIN(test_grow_and_shrink) {
 #undef MAXSZ
 #undef NSZS
 #undef NCYCLES
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -104,6 +114,7 @@ validate_fill(const void *p, uint8_t c, size_t offset, size_t len) {
 }
 
 TEST_BEGIN(test_zero) {
+	volatile int __A_VARIABLE;
 	void *p, *q;
 	size_t psz, qsz, i, j;
 	size_t start_sizes[] = {1, 3*1024, 63*1024, 4095*1024};
@@ -144,10 +155,12 @@ TEST_BEGIN(test_zero) {
 		dallocx(p, 0);
 	}
 #undef FILL_BYTE
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_align) {
+	volatile int __A_VARIABLE;
 	void *p, *q;
 	size_t align;
 #define MAX_ALIGN (ZU(1) << 25)
@@ -168,10 +181,12 @@ TEST_BEGIN(test_align) {
 	}
 	dallocx(p, 0);
 #undef MAX_ALIGN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_lg_align_and_zero) {
+	volatile int __A_VARIABLE;
 	void *p, *q;
 	unsigned lg_align;
 	size_t sz;
@@ -205,10 +220,12 @@ TEST_BEGIN(test_lg_align_and_zero) {
 	dallocx(p, 0);
 #undef MAX_VALIDATE
 #undef MAX_LG_ALIGN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_overflow) {
+	volatile int __A_VARIABLE;
 	size_t largemax;
 	void *p;
 
@@ -231,11 +248,14 @@ TEST_BEGIN(test_overflow) {
 	    ZU(PTRDIFF_MAX)+1);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_grow_and_shrink,
 	    test_zero,
diff --git a/deps/jemalloc/test/integration/sdallocx.c b/deps/jemalloc/test/integration/sdallocx.c
index ca01448..9c645aa 100644
--- a/deps/jemalloc/test/integration/sdallocx.c
+++ b/deps/jemalloc/test/integration/sdallocx.c
@@ -4,12 +4,15 @@
 #define NITER 3
 
 TEST_BEGIN(test_basic) {
+	volatile int __A_VARIABLE;
 	void *ptr = mallocx(64, 0);
 	sdallocx(ptr, 64, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size) {
+	volatile int __A_VARIABLE;
 	size_t nsz, sz, alignment, total;
 	unsigned i;
 	void *ps[NITER];
@@ -44,11 +47,14 @@ TEST_BEGIN(test_alignment_and_size) {
 			}
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_basic,
 	    test_alignment_and_size);
diff --git a/deps/jemalloc/test/integration/thread_arena.c b/deps/jemalloc/test/integration/thread_arena.c
index 1e5ec05..992d4b6 100644
--- a/deps/jemalloc/test/integration/thread_arena.c
+++ b/deps/jemalloc/test/integration/thread_arena.c
@@ -4,6 +4,7 @@
 
 void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	unsigned main_arena_ind = *(unsigned *)arg;
 	void *p;
 	unsigned arena_ind;
@@ -34,18 +35,22 @@ thd_start(void *arg) {
 	assert_u_eq(arena_ind, main_arena_ind,
 	    "Arena index should be same as for main thread");
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static void
 mallctl_failure(int err) {
+	volatile int __A_VARIABLE;
 	char buf[BUFERROR_BUF];
 
 	buferror(err, buf, sizeof(buf));
 	test_fail("Error in mallctl(): %s", buf);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_thread_arena) {
+	volatile int __A_VARIABLE;
 	void *p;
 	int err;
 	thd_t thds[NTHREADS];
@@ -76,11 +81,14 @@ TEST_BEGIN(test_thread_arena) {
 		assert_zd_eq(join_ret, 0, "Unexpected thread join error");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_thread_arena);
 }
diff --git a/deps/jemalloc/test/integration/thread_tcache_enabled.c b/deps/jemalloc/test/integration/thread_tcache_enabled.c
index 95c9acc..ae74078 100644
--- a/deps/jemalloc/test/integration/thread_tcache_enabled.c
+++ b/deps/jemalloc/test/integration/thread_tcache_enabled.c
@@ -2,6 +2,7 @@
 
 void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	bool e0, e1;
 	size_t sz = sizeof(bool);
 	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz, NULL,
@@ -59,25 +60,32 @@ thd_start(void *arg) {
 	assert_false(e0, "tcache should be disabled");
 
 	free(malloc(1));
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_main_thread) {
+	volatile int __A_VARIABLE;
 	thd_start(NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_subthread) {
+	volatile int __A_VARIABLE;
 	thd_t thd;
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	/* Run tests multiple times to check for bad interactions. */
+	__A_VARIABLE = 1;
 	return test(
 	    test_main_thread,
 	    test_subthread,
diff --git a/deps/jemalloc/test/integration/xallocx.c b/deps/jemalloc/test/integration/xallocx.c
index cd0ca04..bb01475 100644
--- a/deps/jemalloc/test/integration/xallocx.c
+++ b/deps/jemalloc/test/integration/xallocx.c
@@ -7,6 +7,7 @@
  */
 static unsigned
 arena_ind(void) {
+	volatile int __A_VARIABLE;
 	static unsigned ind = 0;
 
 	if (ind == 0) {
@@ -15,10 +16,12 @@ arena_ind(void) {
 		    0), 0, "Unexpected mallctl failure creating arena");
 	}
 
+	__A_VARIABLE = 1;
 	return ind;
 }
 
 TEST_BEGIN(test_same_size) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, tsz;
 
@@ -30,10 +33,12 @@ TEST_BEGIN(test_same_size) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_extra_no_move) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, tsz;
 
@@ -45,10 +50,12 @@ TEST_BEGIN(test_extra_no_move) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_no_move_fail) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, tsz;
 
@@ -60,6 +67,7 @@ TEST_BEGIN(test_no_move_fail) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -77,16 +85,21 @@ get_nsizes_impl(const char *cmd) {
 
 static unsigned
 get_nsmall(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nbins");
 }
 
 static unsigned
 get_nlarge(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
 static size_t
 get_size_impl(const char *cmd, size_t ind) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	size_t z;
 	size_t mib[4];
@@ -100,20 +113,26 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_small_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.bin.0.size", ind);
 }
 
 static size_t
 get_large_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
 TEST_BEGIN(test_size) {
+	volatile int __A_VARIABLE;
 	size_t small0, largemax;
 	void *p;
 
@@ -139,10 +158,12 @@ TEST_BEGIN(test_size) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_size_extra_overflow) {
+	volatile int __A_VARIABLE;
 	size_t small0, largemax;
 	void *p;
 
@@ -170,10 +191,12 @@ TEST_BEGIN(test_size_extra_overflow) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_extra_small) {
+	volatile int __A_VARIABLE;
 	size_t small0, small1, largemax;
 	void *p;
 
@@ -201,10 +224,12 @@ TEST_BEGIN(test_extra_small) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_extra_large) {
+	volatile int __A_VARIABLE;
 	int flags = MALLOCX_ARENA(arena_ind());
 	size_t smallmax, large1, large2, large3, largemax;
 	void *p;
@@ -270,11 +295,13 @@ TEST_BEGIN(test_extra_large) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 print_filled_extents(const void *p, uint8_t c, size_t len) {
+	volatile int __A_VARIABLE;
 	const uint8_t *pc = (const uint8_t *)p;
 	size_t i, range0;
 	uint8_t c0;
@@ -290,10 +317,12 @@ print_filled_extents(const void *p, uint8_t c, size_t len) {
 		}
 	}
 	malloc_printf(" %#x[%zu..%zu)\n", c0, range0, i);
+	__A_VARIABLE = 1;
 }
 
 static bool
 validate_fill(const void *p, uint8_t c, size_t offset, size_t len) {
+	volatile int __A_VARIABLE;
 	const uint8_t *pc = (const uint8_t *)p;
 	bool err;
 	size_t i;
@@ -308,11 +337,13 @@ validate_fill(const void *p, uint8_t c, size_t offset, size_t len) {
 		print_filled_extents(p, c, offset + len);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
 static void
 test_zero(size_t szmin, size_t szmax) {
+	volatile int __A_VARIABLE;
 	int flags = MALLOCX_ARENA(arena_ind()) | MALLOCX_ZERO;
 	size_t sz, nsz;
 	void *p;
@@ -357,9 +388,11 @@ test_zero(size_t szmin, size_t szmax) {
 	}
 
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_zero_large) {
+	volatile int __A_VARIABLE;
 	size_t large0, large1;
 
 	/* Get size classes. */
@@ -367,11 +400,14 @@ TEST_BEGIN(test_zero_large) {
 	large1 = get_large_size(1);
 
 	test_zero(large1, large0 * 2);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_same_size,
 	    test_extra_no_move,
diff --git a/deps/jemalloc/test/src/SFMT.c b/deps/jemalloc/test/src/SFMT.c
index c05e218..646c620 100644
--- a/deps/jemalloc/test/src/SFMT.c
+++ b/deps/jemalloc/test/src/SFMT.c
@@ -143,10 +143,14 @@ static inline void swap(w128_t *array, int size);
  */
 #ifdef ONLY64
 static inline int idxof(int i) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return i ^ 1;
 }
 #else
 static inline int idxof(int i) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return i;
 }
 #endif
@@ -161,6 +165,7 @@ static inline int idxof(int i) {
 #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
 #ifdef ONLY64
 static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
+    volatile int __A_VARIABLE;
     uint64_t th, tl, oh, ol;
 
     th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
@@ -173,9 +178,11 @@ static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[1] = (uint32_t)ol;
     out->u[2] = (uint32_t)(oh >> 32);
     out->u[3] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #else
 static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
+    volatile int __A_VARIABLE;
     uint64_t th, tl, oh, ol;
 
     th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
@@ -188,6 +195,7 @@ static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[0] = (uint32_t)ol;
     out->u[3] = (uint32_t)(oh >> 32);
     out->u[2] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #endif
 /**
@@ -200,6 +208,7 @@ static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
  */
 #ifdef ONLY64
 static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
+    volatile int __A_VARIABLE;
     uint64_t th, tl, oh, ol;
 
     th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
@@ -212,9 +221,11 @@ static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[1] = (uint32_t)ol;
     out->u[2] = (uint32_t)(oh >> 32);
     out->u[3] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #else
 static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
+    volatile int __A_VARIABLE;
     uint64_t th, tl, oh, ol;
 
     th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
@@ -227,6 +238,7 @@ static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[0] = (uint32_t)ol;
     out->u[3] = (uint32_t)(oh >> 32);
     out->u[2] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #endif
 #endif
@@ -243,6 +255,7 @@ static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
 #ifdef ONLY64
 static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 				w128_t *d) {
+    volatile int __A_VARIABLE;
     w128_t x;
     w128_t y;
 
@@ -256,10 +269,12 @@ static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 	^ (d->u[2] << SL1);
     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3]
 	^ (d->u[3] << SL1);
+    __A_VARIABLE = 1;
 }
 #else
 static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 				w128_t *d) {
+    volatile int __A_VARIABLE;
     w128_t x;
     w128_t y;
 
@@ -273,6 +288,7 @@ static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 	^ (d->u[2] << SL1);
     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3]
 	^ (d->u[3] << SL1);
+    __A_VARIABLE = 1;
 }
 #endif
 #endif
@@ -283,6 +299,7 @@ static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
  * integers.
  */
 static inline void gen_rand_all(sfmt_t *ctx) {
+    volatile int __A_VARIABLE;
     int i;
     w128_t *r1, *r2;
 
@@ -300,6 +317,7 @@ static inline void gen_rand_all(sfmt_t *ctx) {
 	r1 = r2;
 	r2 = &ctx->sfmt[i];
     }
+    __A_VARIABLE = 1;
 }
 
 /**
@@ -310,6 +328,7 @@ static inline void gen_rand_all(sfmt_t *ctx) {
  * @param size number of 128-bit pseudorandom numbers to be generated.
  */
 static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size) {
+    volatile int __A_VARIABLE;
     int i, j;
     w128_t *r1, *r2;
 
@@ -339,11 +358,13 @@ static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size) {
 	r2 = &array[i];
 	ctx->sfmt[j] = array[i];
     }
+    __A_VARIABLE = 1;
 }
 #endif
 
 #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC)
 static inline void swap(w128_t *array, int size) {
+    volatile int __A_VARIABLE;
     int i;
     uint32_t x, y;
 
@@ -355,6 +376,7 @@ static inline void swap(w128_t *array, int size) {
 	array[i].u[1] = x;
 	array[i].u[3] = y;
     }
+    __A_VARIABLE = 1;
 }
 #endif
 /**
@@ -364,6 +386,8 @@ static inline void swap(w128_t *array, int size) {
  * @return 32-bit integer
  */
 static uint32_t func1(uint32_t x) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (x ^ (x >> 27)) * (uint32_t)1664525UL;
 }
 
@@ -374,6 +398,8 @@ static uint32_t func1(uint32_t x) {
  * @return 32-bit integer
  */
 static uint32_t func2(uint32_t x) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (x ^ (x >> 27)) * (uint32_t)1566083941UL;
 }
 
@@ -381,6 +407,7 @@ static uint32_t func2(uint32_t x) {
  * This function certificate the period of 2^{MEXP}
  */
 static void period_certification(sfmt_t *ctx) {
+    volatile int __A_VARIABLE;
     int inner = 0;
     int i, j;
     uint32_t work;
@@ -393,6 +420,7 @@ static void period_certification(sfmt_t *ctx) {
     inner &= 1;
     /* check OK */
     if (inner == 1) {
+	__A_VARIABLE = 1;
 	return;
     }
     /* check NG, and modification */
@@ -401,11 +429,13 @@ static void period_certification(sfmt_t *ctx) {
 	for (j = 0; j < 32; j++) {
 	    if ((work & parity[i]) != 0) {
 		psfmt32[idxof(i)] ^= work;
+		__A_VARIABLE = 1;
 		return;
 	    }
 	    work = work << 1;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 /*----------------
@@ -417,6 +447,8 @@ static void period_certification(sfmt_t *ctx) {
  * and all parameters of this generator.
  */
 const char *get_idstring(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return IDSTR;
 }
 
@@ -426,6 +458,8 @@ const char *get_idstring(void) {
  * @return minimum size of array used for fill_array32() function.
  */
 int get_min_array_size32(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return N32;
 }
 
@@ -435,6 +469,8 @@ int get_min_array_size32(void) {
  * @return minimum size of array used for fill_array64() function.
  */
 int get_min_array_size64(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return N64;
 }
 
@@ -445,6 +481,7 @@ int get_min_array_size64(void) {
  * @return 32-bit pseudorandom number
  */
 uint32_t gen_rand32(sfmt_t *ctx) {
+    volatile int __A_VARIABLE;
     uint32_t r;
     uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
 
@@ -454,11 +491,13 @@ uint32_t gen_rand32(sfmt_t *ctx) {
 	ctx->idx = 0;
     }
     r = psfmt32[ctx->idx++];
+    __A_VARIABLE = 1;
     return r;
 }
 
 /* Generate a random integer in [0..limit). */
 uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit) {
+    volatile int __A_VARIABLE;
     uint32_t ret, above;
 
     above = 0xffffffffU - (0xffffffffU % limit);
@@ -469,6 +508,7 @@ uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit) {
 	    break;
 	}
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 #endif
@@ -509,6 +549,7 @@ uint64_t gen_rand64(sfmt_t *ctx) {
 
 /* Generate a random integer in [0..limit). */
 uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
+    volatile int __A_VARIABLE;
     uint64_t ret, above;
 
     above = KQU(0xffffffffffffffff) - (KQU(0xffffffffffffffff) % limit);
@@ -519,6 +560,7 @@ uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
 	    break;
 	}
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -549,6 +591,7 @@ uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
  * returns the pointer to the aligned memory block.
  */
 void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
+    volatile int __A_VARIABLE;
     assert(ctx->initialized);
     assert(ctx->idx == N32);
     assert(size % 4 == 0);
@@ -556,6 +599,7 @@ void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
 
     gen_rand_array(ctx, (w128_t *)array, size / 4);
     ctx->idx = N32;
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -585,6 +629,7 @@ void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
  * returns the pointer to the aligned memory block.
  */
 void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
+    volatile int __A_VARIABLE;
     assert(ctx->initialized);
     assert(ctx->idx == N32);
     assert(size % 2 == 0);
@@ -596,6 +641,7 @@ void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
 #if defined(BIG_ENDIAN64) && !defined(ONLY64)
     swap((w128_t *)array, size /2);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /**
@@ -605,12 +651,14 @@ void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
  * @param seed a 32-bit integer used as the seed.
  */
 sfmt_t *init_gen_rand(uint32_t seed) {
+    volatile int __A_VARIABLE;
     void *p;
     sfmt_t *ctx;
     int i;
     uint32_t *psfmt32;
 
     if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
+	__A_VARIABLE = 1;
 	return NULL;
     }
     ctx = (sfmt_t *)p;
@@ -626,6 +674,7 @@ sfmt_t *init_gen_rand(uint32_t seed) {
     period_certification(ctx);
     ctx->initialized = 1;
 
+    __A_VARIABLE = 1;
     return ctx;
 }
 
@@ -636,6 +685,7 @@ sfmt_t *init_gen_rand(uint32_t seed) {
  * @param key_length the length of init_key.
  */
 sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
+    volatile int __A_VARIABLE;
     void *p;
     sfmt_t *ctx;
     int i, j, count;
@@ -646,6 +696,7 @@ sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
     uint32_t *psfmt32;
 
     if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
+	__A_VARIABLE = 1;
 	return NULL;
     }
     ctx = (sfmt_t *)p;
@@ -708,12 +759,15 @@ sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
     period_certification(ctx);
     ctx->initialized = 1;
 
+    __A_VARIABLE = 1;
     return ctx;
 }
 
 void fini_gen_rand(sfmt_t *ctx) {
+    volatile int __A_VARIABLE;
     assert(ctx != NULL);
 
     ctx->initialized = 0;
     free(ctx);
+    __A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/btalloc.c b/deps/jemalloc/test/src/btalloc.c
index d570952..db3505e 100644
--- a/deps/jemalloc/test/src/btalloc.c
+++ b/deps/jemalloc/test/src/btalloc.c
@@ -2,5 +2,7 @@
 
 void *
 btalloc(size_t size, unsigned bits) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return btalloc_0(size, bits);
 }
diff --git a/deps/jemalloc/test/src/mq.c b/deps/jemalloc/test/src/mq.c
index 9b5f672..c1f5d09 100644
--- a/deps/jemalloc/test/src/mq.c
+++ b/deps/jemalloc/test/src/mq.c
@@ -6,6 +6,7 @@
  */
 void
 mq_nanosleep(unsigned ns) {
+	volatile int __A_VARIABLE;
 	assert(ns <= 1000*1000*1000);
 
 #ifdef _WIN32
@@ -24,4 +25,5 @@ mq_nanosleep(unsigned ns) {
 		nanosleep(&timeout, NULL);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/mtx.c b/deps/jemalloc/test/src/mtx.c
index a393c01..d709cb4 100644
--- a/deps/jemalloc/test/src/mtx.c
+++ b/deps/jemalloc/test/src/mtx.c
@@ -33,16 +33,19 @@ mtx_init(mtx_t *mtx) {
 
 void
 mtx_fini(mtx_t *mtx) {
+	volatile int __A_VARIABLE;
 #ifdef _WIN32
 #elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
 #elif (defined(JEMALLOC_OSSPIN))
 #else
 	pthread_mutex_destroy(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 void
 mtx_lock(mtx_t *mtx) {
+	volatile int __A_VARIABLE;
 #ifdef _WIN32
 	EnterCriticalSection(&mtx->lock);
 #elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
@@ -52,10 +55,12 @@ mtx_lock(mtx_t *mtx) {
 #else
 	pthread_mutex_lock(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 void
 mtx_unlock(mtx_t *mtx) {
+	volatile int __A_VARIABLE;
 #ifdef _WIN32
 	LeaveCriticalSection(&mtx->lock);
 #elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
@@ -65,4 +70,5 @@ mtx_unlock(mtx_t *mtx) {
 #else
 	pthread_mutex_unlock(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/test.c b/deps/jemalloc/test/src/test.c
index 01a4d73..815144a 100644
--- a/deps/jemalloc/test/src/test.c
+++ b/deps/jemalloc/test/src/test.c
@@ -22,20 +22,26 @@ static bool arena_new_hook_ran = false;
 
 static const char *
 reentrancy_t_str(reentrancy_t r) {
+	volatile int __A_VARIABLE;
 	switch (r) {
 	case non_reentrant:
+		__A_VARIABLE = 1;
 		return "non-reentrant";
 	case libc_reentrant:
+		__A_VARIABLE = 1;
 		return "libc-reentrant";
 	case arena_new_reentrant:
+		__A_VARIABLE = 1;
 		return "arena_new-reentrant";
 	default:
 		unreachable();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 do_hook(bool *hook_ran, void (**hook)()) {
+	volatile int __A_VARIABLE;
 	*hook_ran = true;
 	*hook = NULL;
 
@@ -44,27 +50,35 @@ do_hook(bool *hook_ran, void (**hook)()) {
 		free(malloc(alloc_size));
 		alloc_size *= 2;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 libc_reentrancy_hook() {
+	volatile int __A_VARIABLE;
 	do_hook(&libc_hook_ran, &hooks_libc_hook);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_new_reentrancy_hook() {
+	volatile int __A_VARIABLE;
 	do_hook(&arena_new_hook_ran, &hooks_arena_new_hook);
+	__A_VARIABLE = 1;
 }
 
 /* Actual test infrastructure. */
 bool
 test_is_reentrant() {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return reentrancy != non_reentrant;
 }
 
 JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 test_skip(const char *format, ...) {
+	volatile int __A_VARIABLE;
 	va_list ap;
 
 	va_start(ap, format);
@@ -72,11 +86,13 @@ test_skip(const char *format, ...) {
 	va_end(ap);
 	malloc_printf("\n");
 	test_status = test_status_skip;
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 test_fail(const char *format, ...) {
+	volatile int __A_VARIABLE;
 	va_list ap;
 
 	va_start(ap, format);
@@ -84,34 +100,45 @@ test_fail(const char *format, ...) {
 	va_end(ap);
 	malloc_printf("\n");
 	test_status = test_status_fail;
+	__A_VARIABLE = 1;
 }
 
 static const char *
 test_status_string(test_status_t test_status) {
+	volatile int __A_VARIABLE;
 	switch (test_status) {
-	case test_status_pass: return "pass";
-	case test_status_skip: return "skip";
-	case test_status_fail: return "fail";
+	case test_status_pass: __A_VARIABLE = 1;
+		return "pass";
+	case test_status_skip: __A_VARIABLE = 1;
+		return "skip";
+	case test_status_fail: __A_VARIABLE = 1;
+		return "fail";
 	default: not_reached();
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 p_test_init(const char *name) {
+	volatile int __A_VARIABLE;
 	test_count++;
 	test_status = test_status_pass;
 	test_name = name;
+	__A_VARIABLE = 1;
 }
 
 void
 p_test_fini(void) {
+	volatile int __A_VARIABLE;
 	test_counts[test_status]++;
 	malloc_printf("%s (%s): %s\n", test_name, reentrancy_t_str(reentrancy),
 	    test_status_string(test_status));
+	__A_VARIABLE = 1;
 }
 
 static test_status_t
 p_test_impl(bool do_malloc_init, bool do_reentrant, test_t *t, va_list ap) {
+	volatile int __A_VARIABLE;
 	test_status_t ret;
 
 	if (do_malloc_init) {
@@ -123,6 +150,7 @@ p_test_impl(bool do_malloc_init, bool do_reentrant, test_t *t, va_list ap) {
 		 */
 		if (nallocx(1, 0) == 0) {
 			malloc_printf("Initialization error");
+			__A_VARIABLE = 1;
 			return test_status_fail;
 		}
 	}
@@ -164,11 +192,13 @@ p_test_impl(bool do_malloc_init, bool do_reentrant, test_t *t, va_list ap) {
 	    test_status_string(test_status_fail),
 	    test_counts[test_status_fail], test_count);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 test_status_t
 p_test(test_t *t, ...) {
+	volatile int __A_VARIABLE;
 	test_status_t ret;
 	va_list ap;
 
@@ -177,11 +207,13 @@ p_test(test_t *t, ...) {
 	ret = p_test_impl(true, true, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 test_status_t
 p_test_no_reentrancy(test_t *t, ...) {
+	volatile int __A_VARIABLE;
 	test_status_t ret;
 	va_list ap;
 
@@ -190,11 +222,13 @@ p_test_no_reentrancy(test_t *t, ...) {
 	ret = p_test_impl(true, false, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 test_status_t
 p_test_no_malloc_init(test_t *t, ...) {
+	volatile int __A_VARIABLE;
 	test_status_t ret;
 	va_list ap;
 
@@ -207,11 +241,14 @@ p_test_no_malloc_init(test_t *t, ...) {
 	ret = p_test_impl(false, false, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 void
 p_test_fail(const char *prefix, const char *message) {
+	volatile int __A_VARIABLE;
 	malloc_cprintf(NULL, NULL, "%s%s\n", prefix, message);
 	test_status = test_status_fail;
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/thd.c b/deps/jemalloc/test/src/thd.c
index 9a15eab..bd8e42e 100644
--- a/deps/jemalloc/test/src/thd.c
+++ b/deps/jemalloc/test/src/thd.c
@@ -3,32 +3,40 @@
 #ifdef _WIN32
 void
 thd_create(thd_t *thd, void *(*proc)(void *), void *arg) {
+	volatile int __A_VARIABLE;
 	LPTHREAD_START_ROUTINE routine = (LPTHREAD_START_ROUTINE)proc;
 	*thd = CreateThread(NULL, 0, routine, arg, 0, NULL);
 	if (*thd == NULL) {
 		test_fail("Error in CreateThread()\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 thd_join(thd_t thd, void **ret) {
+	volatile int __A_VARIABLE;
 	if (WaitForSingleObject(thd, INFINITE) == WAIT_OBJECT_0 && ret) {
 		DWORD exit_code;
 		GetExitCodeThread(thd, (LPDWORD) &exit_code);
 		*ret = (void *)(uintptr_t)exit_code;
 	}
+	__A_VARIABLE = 1;
 }
 
 #else
 void
 thd_create(thd_t *thd, void *(*proc)(void *), void *arg) {
+	volatile int __A_VARIABLE;
 	if (pthread_create(thd, NULL, proc, arg) != 0) {
 		test_fail("Error in pthread_create()\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 thd_join(thd_t thd, void **ret) {
+	volatile int __A_VARIABLE;
 	pthread_join(thd, ret);
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/deps/jemalloc/test/src/timer.c b/deps/jemalloc/test/src/timer.c
index c451c63..efdb989 100644
--- a/deps/jemalloc/test/src/timer.c
+++ b/deps/jemalloc/test/src/timer.c
@@ -2,27 +2,34 @@
 
 void
 timer_start(timedelta_t *timer) {
+	volatile int __A_VARIABLE;
 	nstime_init(&timer->t0, 0);
 	nstime_update(&timer->t0);
+	__A_VARIABLE = 1;
 }
 
 void
 timer_stop(timedelta_t *timer) {
+	volatile int __A_VARIABLE;
 	nstime_copy(&timer->t1, &timer->t0);
 	nstime_update(&timer->t1);
+	__A_VARIABLE = 1;
 }
 
 uint64_t
 timer_usec(const timedelta_t *timer) {
+	volatile int __A_VARIABLE;
 	nstime_t delta;
 
 	nstime_copy(&delta, &timer->t1);
 	nstime_subtract(&delta, &timer->t0);
+	__A_VARIABLE = 1;
 	return nstime_ns(&delta) / 1000;
 }
 
 void
 timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen) {
+	volatile int __A_VARIABLE;
 	uint64_t t0 = timer_usec(a);
 	uint64_t t1 = timer_usec(b);
 	uint64_t mult;
@@ -33,6 +40,7 @@ timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen) {
 	n = malloc_snprintf(&buf[i], buflen-i, "%"FMTu64, t0 / t1);
 	i += n;
 	if (i >= buflen) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	mult = 1;
@@ -53,4 +61,5 @@ timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen) {
 		i += n;
 		mult *= 10;
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/stress/microbench.c b/deps/jemalloc/test/stress/microbench.c
index 988b793..e634bc9 100644
--- a/deps/jemalloc/test/stress/microbench.c
+++ b/deps/jemalloc/test/stress/microbench.c
@@ -3,6 +3,7 @@
 static inline void
 time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter,
     void (*func)(void)) {
+	volatile int __A_VARIABLE;
 	uint64_t i;
 
 	for (i = 0; i < nwarmup; i++) {
@@ -13,11 +14,13 @@ time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter,
 		func();
 	}
 	timer_stop(timer);
+	__A_VARIABLE = 1;
 }
 
 void
 compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
     void (*func_a), const char *name_b, void (*func_b)) {
+	volatile int __A_VARIABLE;
 	timedelta_t timer_a, timer_b;
 	char ratio_buf[6];
 	void *p;
@@ -25,6 +28,7 @@ compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
 	p = mallocx(1, 0);
 	if (p == NULL) {
 		test_fail("Unexpected mallocx() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -38,32 +42,41 @@ compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
 	    ratio_buf);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 
 static void
 malloc_free(void) {
+	volatile int __A_VARIABLE;
 	/* The compiler can optimize away free(malloc(1))! */
 	void *p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 static void
 mallocx_free(void) {
+	volatile int __A_VARIABLE;
 	void *p = mallocx(1, 0);
 	if (p == NULL) {
 		test_fail("Unexpected mallocx() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_malloc_vs_mallocx) {
+	volatile int __A_VARIABLE;
 	compare_funcs(10*1000*1000, 100*1000*1000, "malloc",
 	    malloc_free, "mallocx", mallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -79,83 +92,105 @@ malloc_dallocx(void) {
 
 static void
 malloc_sdallocx(void) {
+	volatile int __A_VARIABLE;
 	void *p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	sdallocx(p, 1, 0);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_free_vs_dallocx) {
+	volatile int __A_VARIABLE;
 	compare_funcs(10*1000*1000, 100*1000*1000, "free", malloc_free,
 	    "dallocx", malloc_dallocx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_dallocx_vs_sdallocx) {
+	volatile int __A_VARIABLE;
 	compare_funcs(10*1000*1000, 100*1000*1000, "dallocx", malloc_dallocx,
 	    "sdallocx", malloc_sdallocx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 malloc_mus_free(void) {
+	volatile int __A_VARIABLE;
 	void *p;
 
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	malloc_usable_size(p);
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 static void
 malloc_sallocx_free(void) {
+	volatile int __A_VARIABLE;
 	void *p;
 
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (sallocx(p, 0) < 1) {
 		test_fail("Unexpected sallocx() failure");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_mus_vs_sallocx) {
+	volatile int __A_VARIABLE;
 	compare_funcs(10*1000*1000, 100*1000*1000, "malloc_usable_size",
 	    malloc_mus_free, "sallocx", malloc_sallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 malloc_nallocx_free(void) {
+	volatile int __A_VARIABLE;
 	void *p;
 
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (nallocx(1, 0) < 1) {
 		test_fail("Unexpected nallocx() failure");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_sallocx_vs_nallocx) {
+	volatile int __A_VARIABLE;
 	compare_funcs(10*1000*1000, 100*1000*1000, "sallocx",
 	    malloc_sallocx_free, "nallocx", malloc_nallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_malloc_vs_mallocx,
 	    test_free_vs_dallocx,
diff --git a/deps/jemalloc/test/unit/SFMT.c b/deps/jemalloc/test/unit/SFMT.c
index 1fc8cf1..72a4164 100644
--- a/deps/jemalloc/test/unit/SFMT.c
+++ b/deps/jemalloc/test/unit/SFMT.c
@@ -1591,6 +1591,8 @@ TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_gen_rand_32,
 	    test_by_array_32,
diff --git a/deps/jemalloc/test/unit/a0.c b/deps/jemalloc/test/unit/a0.c
index a27ab3f..02c33b1 100644
--- a/deps/jemalloc/test/unit/a0.c
+++ b/deps/jemalloc/test/unit/a0.c
@@ -1,16 +1,20 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_a0) {
+	volatile int __A_VARIABLE;
 	void *p;
 
 	p = a0malloc(1);
 	assert_ptr_not_null(p, "Unexpected a0malloc() error");
 	a0dalloc(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_malloc_init(
 	    test_a0);
 }
diff --git a/deps/jemalloc/test/unit/arena_reset.c b/deps/jemalloc/test/unit/arena_reset.c
index f5fb24d..58b24fd 100644
--- a/deps/jemalloc/test/unit/arena_reset.c
+++ b/deps/jemalloc/test/unit/arena_reset.c
@@ -9,6 +9,7 @@
 
 static unsigned
 get_nsizes_impl(const char *cmd) {
+	volatile int __A_VARIABLE;
 	unsigned ret;
 	size_t z;
 
@@ -16,21 +17,27 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nsmall(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nbins");
 }
 
 static unsigned
 get_nlarge(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
 static size_t
 get_size_impl(const char *cmd, size_t ind) {
+	volatile int __A_VARIABLE;
 	size_t ret;
 	size_t z;
 	size_t mib[4];
@@ -44,22 +51,28 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_small_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.bin.0.size", ind);
 }
 
 static size_t
 get_large_size(size_t ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
 /* Like ivsalloc(), but safe to call on discarded allocations. */
 static size_t
 vsalloc(tsdn_t *tsdn, const void *ptr) {
+	volatile int __A_VARIABLE;
 	rtree_ctx_t rtree_ctx_fallback;
 	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
 
@@ -67,35 +80,43 @@ vsalloc(tsdn_t *tsdn, const void *ptr) {
 	szind_t szind;
 	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)ptr, false, &extent, &szind)) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 	if (extent_state_get(extent) != extent_state_active) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
 	if (szind == NSIZES) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
+	__A_VARIABLE = 1;
 	return sz_index2size(szind);
 }
 
 static unsigned
 do_arena_create(extent_hooks_t *h) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t sz = sizeof(unsigned);
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
 	    (void *)(h != NULL ? &h : NULL), (h != NULL ? sizeof(h) : 0)), 0,
 	    "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
 static void
 do_arena_reset_pre(unsigned arena_ind, void ***ptrs, unsigned *nptrs) {
+	volatile int __A_VARIABLE;
 #define NLARGE	32
 	unsigned nsmall, nlarge, i;
 	size_t sz;
@@ -131,10 +152,12 @@ do_arena_reset_pre(unsigned arena_ind, void ***ptrs, unsigned *nptrs) {
 		assert_zu_gt(ivsalloc(tsdn, (*ptrs)[i]), 0,
 		    "Allocation should have queryable size");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_reset_post(void **ptrs, unsigned nptrs, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn;
 	unsigned i;
 
@@ -155,10 +178,12 @@ do_arena_reset_post(void **ptrs, unsigned nptrs, unsigned arena_ind) {
 	}
 
 	free(ptrs);
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_reset_destroy(const char *name, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen;
 
@@ -168,19 +193,25 @@ do_arena_reset_destroy(const char *name, unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_reset(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_arena_reset_destroy("arena.0.reset", arena_ind);
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_destroy(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_arena_reset_destroy("arena.0.destroy", arena_ind);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_arena_reset) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	void **ptrs;
 	unsigned nptrs;
@@ -189,6 +220,7 @@ TEST_BEGIN(test_arena_reset) {
 	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
 	do_arena_reset(arena_ind);
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -216,12 +248,15 @@ arena_i_initialized(unsigned arena_ind, bool refresh) {
 }
 
 TEST_BEGIN(test_arena_destroy_initial) {
+	volatile int __A_VARIABLE;
 	assert_false(arena_i_initialized(MALLCTL_ARENAS_DESTROYED, false),
 	    "Destroyed arena stats should not be initialized");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_destroy_hooks_default) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind, arena_ind_another, arena_ind_prev;
 	void **ptrs;
 	unsigned nptrs;
@@ -258,6 +293,7 @@ TEST_BEGIN(test_arena_destroy_hooks_default) {
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
 
 	do_arena_destroy(arena_ind_another);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -268,6 +304,7 @@ TEST_END
 static bool
 extent_dalloc_unmap(extent_hooks_t *extent_hooks, void *addr, size_t size,
     bool committed, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	TRACE_HOOK("%s(extent_hooks=%p, addr=%p, size=%zu, committed=%s, "
 	    "arena_ind=%u)\n", __func__, extent_hooks, addr, size, committed ?
 	    "true" : "false", arena_ind);
@@ -277,10 +314,12 @@ extent_dalloc_unmap(extent_hooks_t *extent_hooks, void *addr, size_t size,
 	    "Wrong hook function");
 	called_dalloc = true;
 	if (!try_dalloc) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	pages_unmap(addr, size);
 	did_dalloc = true;
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -299,6 +338,7 @@ static extent_hooks_t hooks_unmap = {
 };
 
 TEST_BEGIN(test_arena_destroy_hooks_unmap) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	void **ptrs;
 	unsigned nptrs;
@@ -331,11 +371,14 @@ TEST_BEGIN(test_arena_destroy_hooks_unmap) {
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
 
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_arena_reset,
 	    test_arena_destroy_initial,
diff --git a/deps/jemalloc/test/unit/atomic.c b/deps/jemalloc/test/unit/atomic.c
index 572d8d2..dbff01d 100644
--- a/deps/jemalloc/test/unit/atomic.c
+++ b/deps/jemalloc/test/unit/atomic.c
@@ -177,48 +177,62 @@ typedef struct {							\
 
 TEST_STRUCT(uint64_t, u64);
 TEST_BEGIN(test_atomic_u64) {
+	volatile int __A_VARIABLE;
 #if !(LG_SIZEOF_PTR == 3 || LG_SIZEOF_INT == 3)
 	test_skip("64-bit atomic operations not supported");
 #else
 	INTEGER_TEST_BODY(uint64_t, u64);
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 
 TEST_STRUCT(uint32_t, u32);
 TEST_BEGIN(test_atomic_u32) {
+	volatile int __A_VARIABLE;
 	INTEGER_TEST_BODY(uint32_t, u32);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(void *, p);
 TEST_BEGIN(test_atomic_p) {
+	volatile int __A_VARIABLE;
 	TEST_BODY(void *, p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(size_t, zu);
 TEST_BEGIN(test_atomic_zu) {
+	volatile int __A_VARIABLE;
 	INTEGER_TEST_BODY(size_t, zu);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(ssize_t, zd);
 TEST_BEGIN(test_atomic_zd) {
+	volatile int __A_VARIABLE;
 	INTEGER_TEST_BODY(ssize_t, zd);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 
 TEST_STRUCT(unsigned, u);
 TEST_BEGIN(test_atomic_u) {
+	volatile int __A_VARIABLE;
 	INTEGER_TEST_BODY(unsigned, u);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_atomic_u64,
 	    test_atomic_u32,
diff --git a/deps/jemalloc/test/unit/background_thread.c b/deps/jemalloc/test/unit/background_thread.c
index f7bd37c..76138f6 100644
--- a/deps/jemalloc/test/unit/background_thread.c
+++ b/deps/jemalloc/test/unit/background_thread.c
@@ -4,6 +4,7 @@
 
 static void
 test_switch_background_thread_ctl(bool new_val) {
+	volatile int __A_VARIABLE;
 	bool e0, e1;
 	size_t sz = sizeof(bool);
 
@@ -19,10 +20,12 @@ test_switch_background_thread_ctl(bool new_val) {
 		assert_zu_eq(n_background_threads, 0,
 		    "Number of background threads should be zero.\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_repeat_background_thread_ctl(bool before) {
+	volatile int __A_VARIABLE;
 	bool e0, e1;
 	size_t sz = sizeof(bool);
 
@@ -38,9 +41,11 @@ test_repeat_background_thread_ctl(bool before) {
 		assert_zu_eq(n_background_threads, 0,
 		    "Number of background threads should be zero.\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_background_thread_ctl) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!have_background_thread);
 
 	bool e0, e1;
@@ -67,10 +72,12 @@ TEST_BEGIN(test_background_thread_ctl) {
 		test_repeat_background_thread_ctl(false);
 		test_repeat_background_thread_ctl(false);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_background_thread_running) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!have_background_thread);
 	test_skip_if(!config_stats);
 
@@ -107,12 +114,15 @@ TEST_BEGIN(test_background_thread_running) {
 	}
 	test_switch_background_thread_ctl(false);
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	/* Background_thread creation tests reentrancy naturally. */
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_background_thread_ctl,
 	    test_background_thread_running);
diff --git a/deps/jemalloc/test/unit/background_thread_enable.c b/deps/jemalloc/test/unit/background_thread_enable.c
index ff95e67..aa780f2 100644
--- a/deps/jemalloc/test/unit/background_thread_enable.c
+++ b/deps/jemalloc/test/unit/background_thread_enable.c
@@ -3,6 +3,7 @@
 const char *malloc_conf = "background_thread:false,narenas:1,max_background_threads:20";
 
 TEST_BEGIN(test_deferred) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!have_background_thread);
 
 	unsigned id;
@@ -27,10 +28,12 @@ TEST_BEGIN(test_deferred) {
 	enable = false;
 	assert_d_eq(mallctl("background_thread", NULL, NULL, &enable, sz_b), 0,
 	    "Failed to disable background threads");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_max_background_threads) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!have_background_thread);
 
 	size_t maxt;
@@ -72,11 +75,14 @@ TEST_BEGIN(test_max_background_threads) {
 		    0, "Failed to set max background threads");
 	assert_zu_eq(n_background_threads, maxt,
 		     "Number of background threads should be 3.\n");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 		test_deferred,
 		test_max_background_threads);
diff --git a/deps/jemalloc/test/unit/base.c b/deps/jemalloc/test/unit/base.c
index 6b792cf..ce9af08 100644
--- a/deps/jemalloc/test/unit/base.c
+++ b/deps/jemalloc/test/unit/base.c
@@ -27,6 +27,7 @@ static extent_hooks_t hooks_not_null = {
 };
 
 TEST_BEGIN(test_base_hooks_default) {
+	volatile int __A_VARIABLE;
 	base_t *base;
 	size_t allocated0, allocated1, resident, mapped, n_thp;
 
@@ -55,10 +56,12 @@ TEST_BEGIN(test_base_hooks_default) {
 	}
 
 	base_delete(tsdn, base);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_base_hooks_null) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t hooks_orig;
 	base_t *base;
 	size_t allocated0, allocated1, resident, mapped, n_thp;
@@ -100,10 +103,12 @@ TEST_BEGIN(test_base_hooks_null) {
 	base_delete(tsdn, base);
 
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_base_hooks_not_null) {
+	volatile int __A_VARIABLE;
 	extent_hooks_t hooks_orig;
 	base_t *base;
 	void *p, *q, *r, *r_exp;
@@ -222,11 +227,14 @@ TEST_BEGIN(test_base_hooks_not_null) {
 	try_purge_lazy = true;
 	try_purge_forced = true;
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_base_hooks_default,
 	    test_base_hooks_null,
diff --git a/deps/jemalloc/test/unit/bit_util.c b/deps/jemalloc/test/unit/bit_util.c
index 42a9701..2ede59e 100644
--- a/deps/jemalloc/test/unit/bit_util.c
+++ b/deps/jemalloc/test/unit/bit_util.c
@@ -34,22 +34,30 @@
 } while (0)
 
 TEST_BEGIN(test_pow2_ceil_u64) {
+	volatile int __A_VARIABLE;
 	TEST_POW2_CEIL(uint64_t, u64, FMTu64);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_pow2_ceil_u32) {
+	volatile int __A_VARIABLE;
 	TEST_POW2_CEIL(uint32_t, u32, FMTu32);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_pow2_ceil_zu) {
+	volatile int __A_VARIABLE;
 	TEST_POW2_CEIL(size_t, zu, "zu");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_pow2_ceil_u64,
 	    test_pow2_ceil_u32,
diff --git a/deps/jemalloc/test/unit/ckh.c b/deps/jemalloc/test/unit/ckh.c
index 707ea5f..fb5e507 100644
--- a/deps/jemalloc/test/unit/ckh.c
+++ b/deps/jemalloc/test/unit/ckh.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_new_delete) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	ckh_t ckh;
 
@@ -13,10 +14,12 @@ TEST_BEGIN(test_new_delete) {
 	assert_false(ckh_new(tsd, &ckh, 3, ckh_pointer_hash,
 	    ckh_pointer_keycomp), "Unexpected ckh_new() error");
 	ckh_delete(tsd, &ckh);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_count_insert_search_remove) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd;
 	ckh_t ckh;
 	const char *strs[] = {
@@ -100,10 +103,12 @@ TEST_BEGIN(test_count_insert_search_remove) {
 	}
 
 	ckh_delete(tsd, &ckh);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_insert_iter_remove) {
+	volatile int __A_VARIABLE;
 #define NITEMS ZU(1000)
 	tsd_t *tsd;
 	ckh_t ckh;
@@ -199,11 +204,14 @@ TEST_BEGIN(test_insert_iter_remove) {
 	    ZU(0), ckh_count(&ckh));
 	ckh_delete(tsd, &ckh);
 #undef NITEMS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_new_delete,
 	    test_count_insert_search_remove,
diff --git a/deps/jemalloc/test/unit/decay.c b/deps/jemalloc/test/unit/decay.c
index f727bf9..62af387 100644
--- a/deps/jemalloc/test/unit/decay.c
+++ b/deps/jemalloc/test/unit/decay.c
@@ -11,32 +11,40 @@ static bool monotonic_mock;
 
 static bool
 check_background_thread_enabled(void) {
+	volatile int __A_VARIABLE;
 	bool enabled;
 	size_t sz = sizeof(bool);
 	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
 	if (ret == ENOENT) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	assert_d_eq(ret, 0, "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 	return enabled;
 }
 
 static bool
 nstime_monotonic_mock(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return monotonic_mock;
 }
 
 static bool
 nstime_update_mock(nstime_t *time) {
+	volatile int __A_VARIABLE;
 	nupdates_mock++;
 	if (monotonic_mock) {
 		nstime_copy(time, &time_mock);
 	}
+	__A_VARIABLE = 1;
 	return !monotonic_mock;
 }
 
 static unsigned
 do_arena_create(ssize_t dirty_decay_ms, ssize_t muzzy_decay_ms) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t sz = sizeof(unsigned);
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
@@ -58,11 +66,13 @@ do_arena_create(ssize_t dirty_decay_ms, ssize_t muzzy_decay_ms) {
 	    (void *)&muzzy_decay_ms, sizeof(muzzy_decay_ms)), 0,
 	    "Unexpected mallctlbymib() failure");
 
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
 static void
 do_arena_destroy(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arena.0.destroy", mib, &miblen), 0,
@@ -70,17 +80,21 @@ do_arena_destroy(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 void
 do_epoch(void) {
+	volatile int __A_VARIABLE;
 	uint64_t epoch = 1;
 	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
 	    0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 
 void
 do_purge(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arena.0.purge", mib, &miblen), 0,
@@ -88,10 +102,12 @@ do_purge(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 void
 do_decay(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arena.0.decay", mib, &miblen), 0,
@@ -99,10 +115,12 @@ do_decay(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static uint64_t
 get_arena_npurge_impl(const char *mibname, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[4];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib(mibname, mib, &miblen), 0,
@@ -112,30 +130,38 @@ get_arena_npurge_impl(const char *mibname, unsigned arena_ind) {
 	size_t sz = sizeof(npurge);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&npurge, &sz, NULL, 0),
 	    config_stats ? 0 : ENOENT, "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return npurge;
 }
 
 static uint64_t
 get_arena_dirty_npurge(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.dirty_npurge", arena_ind);
 }
 
 static uint64_t
 get_arena_muzzy_npurge(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.muzzy_npurge", arena_ind);
 }
 
 static uint64_t
 get_arena_npurge(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.dirty_npurge", arena_ind) +
 	    get_arena_npurge_impl("stats.arenas.0.muzzy_npurge", arena_ind);
 }
 
 static size_t
 get_arena_pdirty(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_epoch();
 	size_t mib[4];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
@@ -146,11 +172,13 @@ get_arena_pdirty(unsigned arena_ind) {
 	size_t sz = sizeof(pdirty);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&pdirty, &sz, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return pdirty;
 }
 
 static size_t
 get_arena_pmuzzy(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	do_epoch();
 	size_t mib[4];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
@@ -161,24 +189,30 @@ get_arena_pmuzzy(unsigned arena_ind) {
 	size_t sz = sizeof(pmuzzy);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&pmuzzy, &sz, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return pmuzzy;
 }
 
 static void *
 do_mallocx(size_t size, int flags) {
+	volatile int __A_VARIABLE;
 	void *p = mallocx(size, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
+	__A_VARIABLE = 1;
 	return p;
 }
 
 static void
 generate_dirty(unsigned arena_ind, size_t size) {
+	volatile int __A_VARIABLE;
 	int flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
 	void *p = do_mallocx(size, flags);
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_decay_ticks) {
+	volatile int __A_VARIABLE;
 	test_skip_if(check_background_thread_enabled());
 
 	ticker_t *decay_ticker;
@@ -369,6 +403,7 @@ TEST_BEGIN(test_decay_ticks) {
 			    "flush (sz=%zu)", sz);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -419,6 +454,7 @@ decay_ticker_helper(unsigned arena_ind, int flags, bool dirty, ssize_t dt,
 }
 
 TEST_BEGIN(test_decay_ticker) {
+	volatile int __A_VARIABLE;
 	test_skip_if(check_background_thread_enabled());
 #define NPS 2048
 	ssize_t ddt = opt_dirty_decay_ms;
@@ -477,10 +513,12 @@ TEST_BEGIN(test_decay_ticker) {
 	nstime_monotonic = nstime_monotonic_orig;
 	nstime_update = nstime_update_orig;
 #undef NPS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_decay_nonmonotonic) {
+	volatile int __A_VARIABLE;
 	test_skip_if(check_background_thread_enabled());
 #define NPS (SMOOTHSTEP_NSTEPS + 1)
 	int flags = (MALLOCX_ARENA(0) | MALLOCX_TCACHE_NONE);
@@ -535,10 +573,12 @@ TEST_BEGIN(test_decay_nonmonotonic) {
 	nstime_monotonic = nstime_monotonic_orig;
 	nstime_update = nstime_update_orig;
 #undef NPS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_decay_now) {
+	volatile int __A_VARIABLE;
 	test_skip_if(check_background_thread_enabled());
 
 	unsigned arena_ind = do_arena_create(0, 0);
@@ -555,10 +595,12 @@ TEST_BEGIN(test_decay_now) {
 		    "Unexpected muzzy pages");
 	}
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_decay_never) {
+	volatile int __A_VARIABLE;
 	test_skip_if(check_background_thread_enabled());
 
 	unsigned arena_ind = do_arena_create(-1, -1);
@@ -585,11 +627,14 @@ TEST_BEGIN(test_decay_never) {
 		pdirty_prev = pdirty;
 	}
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_decay_ticks,
 	    test_decay_ticker,
diff --git a/deps/jemalloc/test/unit/div.c b/deps/jemalloc/test/unit/div.c
index b47f10b..b4bb294 100644
--- a/deps/jemalloc/test/unit/div.c
+++ b/deps/jemalloc/test/unit/div.c
@@ -3,6 +3,7 @@
 #include "jemalloc/internal/div.h"
 
 TEST_BEGIN(test_div_exhaustive) {
+	volatile int __A_VARIABLE;
 	for (size_t divisor = 2; divisor < 1000 * 1000; ++divisor) {
 		div_info_t div_info;
 		div_init(&div_info, divisor);
@@ -19,11 +20,14 @@ TEST_BEGIN(test_div_exhaustive) {
 			    "got quotient %zu", divisor, dividend, quotient);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_div_exhaustive);
 }
diff --git a/deps/jemalloc/test/unit/emitter.c b/deps/jemalloc/test/unit/emitter.c
index 535c7cf..56a8667 100644
--- a/deps/jemalloc/test/unit/emitter.c
+++ b/deps/jemalloc/test/unit/emitter.c
@@ -23,6 +23,7 @@ struct buf_descriptor_s {
  */
 static void
 forwarding_cb(void *buf_descriptor_v, const char *str) {
+	volatile int __A_VARIABLE;
 	buf_descriptor_t *buf_descriptor = (buf_descriptor_t *)buf_descriptor_v;
 
 	if (print_raw) {
@@ -62,11 +63,13 @@ forwarding_cb(void *buf_descriptor_v, const char *str) {
 	buf_descriptor->buf += written;
 	buf_descriptor->len -= written;
 	assert_zu_gt(buf_descriptor->len, 0, "Buffer out of space!");
+	__A_VARIABLE = 1;
 }
 
 static void
 assert_emit_output(void (*emit_fn)(emitter_t *),
     const char *expected_json_output, const char *expected_table_output) {
+	volatile int __A_VARIABLE;
 	emitter_t emitter;
 	char buf[MALLOC_PRINTF_BUFSIZE];
 	buf_descriptor_t buf_descriptor;
@@ -88,10 +91,12 @@ assert_emit_output(void (*emit_fn)(emitter_t *),
 	    &buf_descriptor);
 	(*emit_fn)(&emitter);
 	assert_str_eq(expected_table_output, buf, "table output failure");
+	__A_VARIABLE = 1;
 }
 
 static void
 emit_dict(emitter_t *emitter) {
+	volatile int __A_VARIABLE;
 	bool b_false = false;
 	bool b_true = true;
 	int i_123 = 123;
@@ -107,6 +112,7 @@ emit_dict(emitter_t *emitter) {
 	    "note_key2", emitter_type_bool, &b_false);
 	emitter_dict_end(emitter);
 	emitter_end(emitter);
+	__A_VARIABLE = 1;
 }
 static const char *dict_json =
 "{\n"
@@ -125,7 +131,9 @@ static const char *dict_table =
 "  JKL: \"a string\" (note_key2: false)\n";
 
 TEST_BEGIN(test_dict) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_dict, dict_json, dict_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -147,8 +155,10 @@ static const char *table_printf_table =
 "Table note 2 with format string\n";
 
 TEST_BEGIN(test_table_printf) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_table_printf, table_printf_json,
 	    table_printf_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -192,8 +202,10 @@ static const char *nested_dict_table =
 "  Another primitive: 123\n";
 
 TEST_BEGIN(test_nested_dict) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_nested_dict, nested_dict_json,
 	    nested_dict_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -247,7 +259,9 @@ static const char *types_table =
 "K8: 10000000000\n";
 
 TEST_BEGIN(test_types) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_types, types_json, types_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -293,7 +307,9 @@ const char *modal_table =
 "  I6: 123\n";
 
 TEST_BEGIN(test_modal) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_modal, modal_json, modal_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -339,7 +355,9 @@ static const char *json_arr_json =
 static const char *json_arr_table = "";
 
 TEST_BEGIN(test_json_arr) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_json_arr, json_arr_json, json_arr_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -396,12 +414,16 @@ static const char *table_row_table =
 "\"a string\"          false  ghi\n";
 
 TEST_BEGIN(test_table_row) {
+	volatile int __A_VARIABLE;
 	assert_emit_output(&emit_table_row, table_row_json, table_row_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_dict,
 	    test_table_printf,
diff --git a/deps/jemalloc/test/unit/extent_quantize.c b/deps/jemalloc/test/unit/extent_quantize.c
index 0ca7a75..bd0cec7 100644
--- a/deps/jemalloc/test/unit/extent_quantize.c
+++ b/deps/jemalloc/test/unit/extent_quantize.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_small_extent_size) {
+	volatile int __A_VARIABLE;
 	unsigned nbins, i;
 	size_t sz, extent_size;
 	size_t mib[4];
@@ -31,10 +32,12 @@ TEST_BEGIN(test_small_extent_size) {
 		    "Small extent quantization should be a no-op "
 		    "(extent_size=%zu)", extent_size);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_large_extent_size) {
+	volatile int __A_VARIABLE;
 	bool cache_oblivious;
 	unsigned nlextents, i;
 	size_t sz, extent_size_prev, ceil_prev;
@@ -95,10 +98,12 @@ TEST_BEGIN(test_large_extent_size) {
 			    PAGE);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_monotonic) {
+	volatile int __A_VARIABLE;
 #define SZ_MAX	ZU(4 * 1024 * 1024)
 	unsigned i;
 	size_t floor_prev, ceil_prev;
@@ -129,11 +134,14 @@ TEST_BEGIN(test_monotonic) {
 		floor_prev = floor;
 		ceil_prev = ceil;
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_small_extent_size,
 	    test_large_extent_size,
diff --git a/deps/jemalloc/test/unit/fork.c b/deps/jemalloc/test/unit/fork.c
index b169075..c6964ed 100644
--- a/deps/jemalloc/test/unit/fork.c
+++ b/deps/jemalloc/test/unit/fork.c
@@ -7,6 +7,7 @@
 #ifndef _WIN32
 static void
 wait_for_child_exit(int pid) {
+	volatile int __A_VARIABLE;
 	int status;
 	while (true) {
 		if (waitpid(pid, &status, 0) == -1) {
@@ -25,10 +26,12 @@ wait_for_child_exit(int pid) {
 			break;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 #endif
 
 TEST_BEGIN(test_fork) {
+	volatile int __A_VARIABLE;
 #ifndef _WIN32
 	void *p;
 	pid_t pid;
@@ -69,6 +72,7 @@ TEST_BEGIN(test_fork) {
 #else
 	test_skip("fork(2) is irrelevant to Windows");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -96,14 +100,17 @@ do_fork_thd(void *arg) {
 #ifndef _WIN32
 static void
 do_test_fork_multithreaded() {
+	volatile int __A_VARIABLE;
 	thd_t child;
 	thd_create(&child, do_fork_thd, NULL);
 	do_fork_thd(NULL);
 	thd_join(child, NULL);
+	__A_VARIABLE = 1;
 }
 #endif
 
 TEST_BEGIN(test_fork_multithreaded) {
+	volatile int __A_VARIABLE;
 #ifndef _WIN32
 	/*
 	 * We've seen bugs involving hanging on arenas_lock (though the same
@@ -130,11 +137,14 @@ TEST_BEGIN(test_fork_multithreaded) {
 #else
 	test_skip("fork(2) is irrelevant to Windows");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_fork,
 	    test_fork_multithreaded);
diff --git a/deps/jemalloc/test/unit/hooks.c b/deps/jemalloc/test/unit/hooks.c
index b70172e..91c20c8 100644
--- a/deps/jemalloc/test/unit/hooks.c
+++ b/deps/jemalloc/test/unit/hooks.c
@@ -4,34 +4,44 @@ static bool hook_called = false;
 
 static void
 hook() {
+	volatile int __A_VARIABLE;
 	hook_called = true;
+	__A_VARIABLE = 1;
 }
 
 static int
 func_to_hook(int arg1, int arg2) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return arg1 + arg2;
 }
 
 #define func_to_hook JEMALLOC_HOOK(func_to_hook, hooks_libc_hook)
 
 TEST_BEGIN(unhooked_call) {
+	volatile int __A_VARIABLE;
 	hooks_libc_hook = NULL;
 	hook_called = false;
 	assert_d_eq(3, func_to_hook(1, 2), "Hooking changed return value.");
 	assert_false(hook_called, "Nulling out hook didn't take.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(hooked_call) {
+	volatile int __A_VARIABLE;
 	hooks_libc_hook = &hook;
 	hook_called = false;
 	assert_d_eq(3, func_to_hook(1, 2), "Hooking changed return value.");
 	assert_true(hook_called, "Hook should have executed.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    unhooked_call,
 	    hooked_call);
diff --git a/deps/jemalloc/test/unit/junk.c b/deps/jemalloc/test/unit/junk.c
index 243ced4..f7de61f 100644
--- a/deps/jemalloc/test/unit/junk.c
+++ b/deps/jemalloc/test/unit/junk.c
@@ -10,12 +10,15 @@ static bool saw_junking;
 
 static void
 watch_junking(void *p) {
+	volatile int __A_VARIABLE;
 	watch_for_junking = p;
 	saw_junking = false;
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_junk_small_intercept(void *ptr, const bin_info_t *bin_info) {
+	volatile int __A_VARIABLE;
 	size_t i;
 
 	arena_dalloc_junk_small_orig(ptr, bin_info);
@@ -27,10 +30,12 @@ arena_dalloc_junk_small_intercept(void *ptr, const bin_info_t *bin_info) {
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 large_dalloc_junk_intercept(void *ptr, size_t usize) {
+	volatile int __A_VARIABLE;
 	size_t i;
 
 	large_dalloc_junk_orig(ptr, usize);
@@ -42,18 +47,22 @@ large_dalloc_junk_intercept(void *ptr, size_t usize) {
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 large_dalloc_maybe_junk_intercept(void *ptr, size_t usize) {
+	volatile int __A_VARIABLE;
 	large_dalloc_maybe_junk_orig(ptr, usize);
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_junk(size_t sz_min, size_t sz_max) {
+	volatile int __A_VARIABLE;
 	uint8_t *s;
 	size_t sz_prev, sz, i;
 
@@ -119,22 +128,29 @@ test_junk(size_t sz_min, size_t sz_max) {
 		large_dalloc_junk = large_dalloc_junk_orig;
 		large_dalloc_maybe_junk = large_dalloc_maybe_junk_orig;
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_junk_small) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_fill);
 	test_junk(1, SMALL_MAXCLASS-1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_junk_large) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_fill);
 	test_junk(SMALL_MAXCLASS+1, (1U << (LG_LARGE_MINCLASS+1)));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_junk_small,
 	    test_junk_large);
diff --git a/deps/jemalloc/test/unit/log.c b/deps/jemalloc/test/unit/log.c
index a52bd73..95a0330 100644
--- a/deps/jemalloc/test/unit/log.c
+++ b/deps/jemalloc/test/unit/log.c
@@ -29,6 +29,7 @@ expect_no_logging(const char *names) {
 }
 
 TEST_BEGIN(test_log_disabled) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_log);
 	atomic_store_b(&log_init_done, true, ATOMIC_RELAXED);
 	expect_no_logging("");
@@ -37,6 +38,7 @@ TEST_BEGIN(test_log_disabled) {
 	expect_no_logging("l12");
 	expect_no_logging("l123|a456|b789");
 	expect_no_logging("|||");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -175,14 +177,18 @@ TEST_END
  * any test code to run.
  */
 TEST_BEGIN(test_log_only_format_string) {
+	volatile int __A_VARIABLE;
 	if (false) {
 		LOG("log_str", "No arguments follow this format string.");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_log_disabled,
 	    test_log_enabled_direct,
diff --git a/deps/jemalloc/test/unit/mallctl.c b/deps/jemalloc/test/unit/mallctl.c
index 1ecbab0..5c55179 100644
--- a/deps/jemalloc/test/unit/mallctl.c
+++ b/deps/jemalloc/test/unit/mallctl.c
@@ -3,6 +3,7 @@
 #include "jemalloc/internal/util.h"
 
 TEST_BEGIN(test_mallctl_errors) {
+	volatile int __A_VARIABLE;
 	uint64_t epoch;
 	size_t sz;
 
@@ -26,20 +27,24 @@ TEST_BEGIN(test_mallctl_errors) {
 	sz = sizeof(epoch)+1;
 	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
 	    "mallctl() should return EINVAL for output size mismatch");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctlnametomib_errors) {
+	volatile int __A_VARIABLE;
 	size_t mib[1];
 	size_t miblen;
 
 	miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("no_such_name", mib, &miblen), ENOENT,
 	    "mallctlnametomib() should return ENOENT for non-existent names");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctlbymib_errors) {
+	volatile int __A_VARIABLE;
 	uint64_t epoch;
 	size_t sz;
 	size_t mib[1];
@@ -72,10 +77,12 @@ TEST_BEGIN(test_mallctlbymib_errors) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
 	    EINVAL,
 	    "mallctlbymib() should return EINVAL for output size mismatch");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_read_write) {
+	volatile int __A_VARIABLE;
 	uint64_t old_epoch, new_epoch;
 	size_t sz = sizeof(old_epoch);
 
@@ -99,10 +106,12 @@ TEST_BEGIN(test_mallctl_read_write) {
 	    (void *)&new_epoch, sizeof(new_epoch)), 0,
 	    "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctlnametomib_short_mib) {
+	volatile int __A_VARIABLE;
 	size_t mib[4];
 	size_t miblen;
 
@@ -113,10 +122,12 @@ TEST_BEGIN(test_mallctlnametomib_short_mib) {
 	assert_zu_eq(miblen, 3, "Unexpected mib output length");
 	assert_zu_eq(mib[3], 42,
 	    "mallctlnametomib() wrote past the end of the input mib");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_config) {
+	volatile int __A_VARIABLE;
 #define TEST_MALLCTL_CONFIG(config, t) do {				\
 	t oldval;							\
 	size_t sz = sizeof(oldval);					\
@@ -139,10 +150,12 @@ TEST_BEGIN(test_mallctl_config) {
 	TEST_MALLCTL_CONFIG(xmalloc, bool);
 
 #undef TEST_MALLCTL_CONFIG
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_opt) {
+	volatile int __A_VARIABLE;
 	bool config_always = true;
 
 #define TEST_MALLCTL_OPT(t, opt, config) do {				\
@@ -186,10 +199,12 @@ TEST_BEGIN(test_mallctl_opt) {
 	TEST_MALLCTL_OPT(bool, prof_leak, prof);
 
 #undef TEST_MALLCTL_OPT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_manpage_example) {
+	volatile int __A_VARIABLE;
 	unsigned nbins, i;
 	size_t mib[4];
 	size_t len, miblen;
@@ -210,10 +225,12 @@ TEST_BEGIN(test_manpage_example) {
 		    NULL, 0), 0, "Unexpected mallctlbymib() failure");
 		/* Do something with bin_size... */
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_tcache_none) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!opt_tcache);
 
 	/* Allocate p and q. */
@@ -233,10 +250,12 @@ TEST_BEGIN(test_tcache_none) {
 
 	/* Clean up. */
 	dallocx(p1, MALLOCX_TCACHE_NONE);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_tcache) {
+	volatile int __A_VARIABLE;
 #define NTCACHES	10
 	unsigned tis[NTCACHES];
 	void *ps[NTCACHES];
@@ -326,10 +345,12 @@ TEST_BEGIN(test_tcache) {
 		    (void *)&tis[i], sizeof(unsigned)), 0,
 		    "Unexpected mallctl() failure, i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_thread_arena) {
+	volatile int __A_VARIABLE;
 	unsigned old_arena_ind, new_arena_ind, narenas;
 
 	const char *opa;
@@ -362,10 +383,12 @@ TEST_BEGIN(test_thread_arena) {
 			    "should not be allowed with percpu arena");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_initialized) {
+	volatile int __A_VARIABLE;
 	unsigned narenas, i;
 	size_t sz;
 	size_t mib[3];
@@ -400,10 +423,12 @@ TEST_BEGIN(test_arena_i_initialized) {
 	    "Unexpected mallctl() failure");
 	assert_true(initialized,
 	    "Merged arena statistics should always be initialized");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_dirty_decay_ms) {
+	volatile int __A_VARIABLE;
 	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
 	size_t sz = sizeof(ssize_t);
 
@@ -432,10 +457,12 @@ TEST_BEGIN(test_arena_i_dirty_decay_ms) {
 		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
 		    "Unexpected old arena.0.dirty_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
+	volatile int __A_VARIABLE;
 	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
 	size_t sz = sizeof(ssize_t);
 
@@ -464,10 +491,12 @@ TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
 		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
 		    "Unexpected old arena.0.muzzy_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_purge) {
+	volatile int __A_VARIABLE;
 	unsigned narenas;
 	size_t sz = sizeof(unsigned);
 	size_t mib[3];
@@ -487,10 +516,12 @@ TEST_BEGIN(test_arena_i_purge) {
 	mib[1] = MALLCTL_ARENAS_ALL;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_decay) {
+	volatile int __A_VARIABLE;
 	unsigned narenas;
 	size_t sz = sizeof(unsigned);
 	size_t mib[3];
@@ -510,10 +541,12 @@ TEST_BEGIN(test_arena_i_decay) {
 	mib[1] = MALLCTL_ARENAS_ALL;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_dss) {
+	volatile int __A_VARIABLE;
 	const char *dss_prec_old, *dss_prec_new;
 	size_t sz = sizeof(dss_prec_old);
 	size_t mib[3];
@@ -555,10 +588,12 @@ TEST_BEGIN(test_arena_i_dss) {
 	    0), 0, "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected value for dss precedence");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_retain_grow_limit) {
+	volatile int __A_VARIABLE;
 	size_t old_limit, new_limit, default_limit;
 	size_t mib[3];
 	size_t miblen;
@@ -603,10 +638,12 @@ TEST_BEGIN(test_arena_i_retain_grow_limit) {
 	/* Restore to default. */
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &default_limit,
 	    sizeof(default_limit)), 0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_dirty_decay_ms) {
+	volatile int __A_VARIABLE;
 	ssize_t dirty_decay_ms, orig_dirty_decay_ms, prev_dirty_decay_ms;
 	size_t sz = sizeof(ssize_t);
 
@@ -635,10 +672,12 @@ TEST_BEGIN(test_arenas_dirty_decay_ms) {
 		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
 		    "Unexpected old arenas.dirty_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_muzzy_decay_ms) {
+	volatile int __A_VARIABLE;
 	ssize_t muzzy_decay_ms, orig_muzzy_decay_ms, prev_muzzy_decay_ms;
 	size_t sz = sizeof(ssize_t);
 
@@ -667,10 +706,12 @@ TEST_BEGIN(test_arenas_muzzy_decay_ms) {
 		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
 		    "Unexpected old arenas.muzzy_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_constants) {
+	volatile int __A_VARIABLE;
 #define TEST_ARENAS_CONSTANT(t, name, expected) do {			\
 	t name;								\
 	size_t sz = sizeof(t);						\
@@ -685,10 +726,12 @@ TEST_BEGIN(test_arenas_constants) {
 	TEST_ARENAS_CONSTANT(unsigned, nlextents, NSIZES - NBINS);
 
 #undef TEST_ARENAS_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_bin_constants) {
+	volatile int __A_VARIABLE;
 #define TEST_ARENAS_BIN_CONSTANT(t, name, expected) do {		\
 	t name;								\
 	size_t sz = sizeof(t);						\
@@ -703,10 +746,12 @@ TEST_BEGIN(test_arenas_bin_constants) {
 	    bin_infos[0].slab_size);
 
 #undef TEST_ARENAS_BIN_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_lextent_constants) {
+	volatile int __A_VARIABLE;
 #define TEST_ARENAS_LEXTENT_CONSTANT(t, name, expected) do {		\
 	t name;								\
 	size_t sz = sizeof(t);						\
@@ -718,10 +763,12 @@ TEST_BEGIN(test_arenas_lextent_constants) {
 	TEST_ARENAS_LEXTENT_CONSTANT(size_t, size, LARGE_MINCLASS);
 
 #undef TEST_ARENAS_LEXTENT_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_create) {
+	volatile int __A_VARIABLE;
 	unsigned narenas_before, arena, narenas_after;
 	size_t sz = sizeof(unsigned);
 
@@ -735,10 +782,12 @@ TEST_BEGIN(test_arenas_create) {
 	assert_u_eq(narenas_before+1, narenas_after,
 	    "Unexpected number of arenas before versus after extension");
 	assert_u_eq(arena, narenas_after-1, "Unexpected arena index");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_lookup) {
+	volatile int __A_VARIABLE;
 	unsigned arena, arena1;
 	void *ptr;
 	size_t sz = sizeof(unsigned);
@@ -751,10 +800,12 @@ TEST_BEGIN(test_arenas_lookup) {
 	    0, "Unexpected mallctl() failure");
 	assert_u_eq(arena, arena1, "Unexpected arena index");
 	dallocx(ptr, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_stats_arenas) {
+	volatile int __A_VARIABLE;
 #define TEST_STATS_ARENAS(t, name) do {					\
 	t name;								\
 	size_t sz = sizeof(t);						\
@@ -770,11 +821,14 @@ TEST_BEGIN(test_stats_arenas) {
 	TEST_STATS_ARENAS(size_t, pdirty);
 
 #undef TEST_STATS_ARENAS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_mallctl_errors,
 	    test_mallctlnametomib_errors,
diff --git a/deps/jemalloc/test/unit/malloc_io.c b/deps/jemalloc/test/unit/malloc_io.c
index 79ba7fc..ff3bfd9 100644
--- a/deps/jemalloc/test/unit/malloc_io.c
+++ b/deps/jemalloc/test/unit/malloc_io.c
@@ -1,16 +1,19 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_malloc_strtoumax_no_endptr) {
+	volatile int __A_VARIABLE;
 	int err;
 
 	set_errno(0);
 	assert_ju_eq(malloc_strtoumax("0", NULL, 0), 0, "Unexpected result");
 	err = get_errno();
 	assert_d_eq(err, 0, "Unexpected failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_malloc_strtoumax) {
+	volatile int __A_VARIABLE;
 	struct test_s {
 		const char *input;
 		const char *expected_remainder;
@@ -101,10 +104,12 @@ TEST_BEGIN(test_malloc_strtoumax) {
 			    test->input, test->base);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_malloc_snprintf_truncated) {
+	volatile int __A_VARIABLE;
 #define BUFLEN	15
 	char buf[BUFLEN];
 	size_t result;
@@ -133,10 +138,12 @@ TEST_BEGIN(test_malloc_snprintf_truncated) {
 	}
 #undef BUFLEN
 #undef TEST
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_malloc_snprintf) {
+	volatile int __A_VARIABLE;
 #define BUFLEN	128
 	char buf[BUFLEN];
 	size_t result;
@@ -245,11 +252,14 @@ TEST_BEGIN(test_malloc_snprintf) {
 	TEST("_0x1234abc_", "_%#zx_", ((ssize_t)0x1234abc));
 	TEST("_0X1234ABC_", "_%#zX_", ((ssize_t)0x1234ABC));
 #undef BUFLEN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_malloc_strtoumax_no_endptr,
 	    test_malloc_strtoumax,
diff --git a/deps/jemalloc/test/unit/math.c b/deps/jemalloc/test/unit/math.c
index 09ef20c..4c2930b 100644
--- a/deps/jemalloc/test/unit/math.c
+++ b/deps/jemalloc/test/unit/math.c
@@ -15,17 +15,21 @@
 
 static bool
 double_eq_rel(double a, double b, double max_rel_err, double max_abs_err) {
+	volatile int __A_VARIABLE;
 	double rel_err;
 
 	if (fabs(a - b) < max_abs_err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	rel_err = (fabs(b) > fabs(a)) ? fabs((a-b)/b) : fabs((a-b)/a);
+	__A_VARIABLE = 1;
 	return (rel_err < max_rel_err);
 }
 
 static uint64_t
 factorial(unsigned x) {
+	volatile int __A_VARIABLE;
 	uint64_t ret = 1;
 	unsigned i;
 
@@ -33,10 +37,12 @@ factorial(unsigned x) {
 		ret *= (uint64_t)i;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 TEST_BEGIN(test_ln_gamma_factorial) {
+	volatile int __A_VARIABLE;
 	unsigned x;
 
 	/* exp(ln_gamma(x)) == (x-1)! for integer x. */
@@ -45,6 +51,7 @@ TEST_BEGIN(test_ln_gamma_factorial) {
 		    (double)factorial(x-1), MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect factorial result for x=%u", x);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -188,6 +195,7 @@ static const double ln_gamma_misc_expected[] = {
 };
 
 TEST_BEGIN(test_ln_gamma_misc) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 1; i < sizeof(ln_gamma_misc_expected)/sizeof(double); i++) {
@@ -196,6 +204,7 @@ TEST_BEGIN(test_ln_gamma_misc) {
 		    ln_gamma_misc_expected[i], MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect ln_gamma result for i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -238,6 +247,7 @@ static const double pt_norm_expected[] = {
 };
 
 TEST_BEGIN(test_pt_norm) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 1; i < sizeof(pt_norm_expected)/sizeof(double); i++) {
@@ -246,6 +256,7 @@ TEST_BEGIN(test_pt_norm) {
 		    MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect pt_norm result for i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -287,6 +298,7 @@ static const double pt_chi2_expected[] = {
 };
 
 TEST_BEGIN(test_pt_chi2) {
+	volatile int __A_VARIABLE;
 	unsigned i, j;
 	unsigned e = 0;
 
@@ -301,6 +313,7 @@ TEST_BEGIN(test_pt_chi2) {
 			e++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -348,6 +361,7 @@ static const double pt_gamma_expected[] = {
 };
 
 TEST_BEGIN(test_pt_gamma_shape) {
+	volatile int __A_VARIABLE;
 	unsigned i, j;
 	unsigned e = 0;
 
@@ -363,10 +377,12 @@ TEST_BEGIN(test_pt_gamma_shape) {
 			e++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_pt_gamma_scale) {
+	volatile int __A_VARIABLE;
 	double shape = 1.0;
 	double ln_gamma_shape = ln_gamma(shape);
 
@@ -375,11 +391,14 @@ TEST_BEGIN(test_pt_gamma_scale) {
 	    pt_gamma(0.5, shape, 10.0, ln_gamma_shape), MAX_REL_ERR,
 	    MAX_ABS_ERR),
 	    "Scale should be trivially equivalent to external multiplication");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_ln_gamma_factorial,
 	    test_ln_gamma_misc,
diff --git a/deps/jemalloc/test/unit/mq.c b/deps/jemalloc/test/unit/mq.c
index 57a4d54..27faa53 100644
--- a/deps/jemalloc/test/unit/mq.c
+++ b/deps/jemalloc/test/unit/mq.c
@@ -10,6 +10,7 @@ struct mq_msg_s {
 mq_gen(static, mq_, mq_t, mq_msg_t, link)
 
 TEST_BEGIN(test_mq_basic) {
+	volatile int __A_VARIABLE;
 	mq_t mq;
 	mq_msg_t msg;
 
@@ -26,6 +27,7 @@ TEST_BEGIN(test_mq_basic) {
 	assert_ptr_eq(mq_get(&mq), &msg, "mq_get() should return msg");
 
 	mq_fini(&mq);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -44,6 +46,7 @@ thd_receiver_start(void *arg) {
 
 static void *
 thd_sender_start(void *arg) {
+	volatile int __A_VARIABLE;
 	mq_t *mq = (mq_t *)arg;
 	unsigned i;
 
@@ -55,10 +58,12 @@ thd_sender_start(void *arg) {
 		msg = (mq_msg_t *)p;
 		mq_put(mq, msg);
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_mq_threaded) {
+	volatile int __A_VARIABLE;
 	mq_t mq;
 	thd_t receiver;
 	thd_t senders[NSENDERS];
@@ -77,11 +82,14 @@ TEST_BEGIN(test_mq_threaded) {
 	}
 
 	mq_fini(&mq);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_mq_basic,
 	    test_mq_threaded);
diff --git a/deps/jemalloc/test/unit/mtx.c b/deps/jemalloc/test/unit/mtx.c
index 424587b..92a19d7 100644
--- a/deps/jemalloc/test/unit/mtx.c
+++ b/deps/jemalloc/test/unit/mtx.c
@@ -4,12 +4,14 @@
 #define NINCRS		2000000
 
 TEST_BEGIN(test_mtx_basic) {
+	volatile int __A_VARIABLE;
 	mtx_t mtx;
 
 	assert_false(mtx_init(&mtx), "Unexpected mtx_init() failure");
 	mtx_lock(&mtx);
 	mtx_unlock(&mtx);
 	mtx_fini(&mtx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -20,6 +22,7 @@ typedef struct {
 
 static void *
 thd_start(void *varg) {
+	volatile int __A_VARIABLE;
 	thd_start_arg_t *arg = (thd_start_arg_t *)varg;
 	unsigned i;
 
@@ -28,10 +31,12 @@ thd_start(void *varg) {
 		arg->x++;
 		mtx_unlock(&arg->mtx);
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_mtx_race) {
+	volatile int __A_VARIABLE;
 	thd_start_arg_t arg;
 	thd_t thds[NTHREADS];
 	unsigned i;
@@ -46,11 +51,14 @@ TEST_BEGIN(test_mtx_race) {
 	}
 	assert_u_eq(arg.x, NTHREADS * NINCRS,
 	    "Race-related counter corruption");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_mtx_basic,
 	    test_mtx_race);
diff --git a/deps/jemalloc/test/unit/nstime.c b/deps/jemalloc/test/unit/nstime.c
index f313780..6a05828 100644
--- a/deps/jemalloc/test/unit/nstime.c
+++ b/deps/jemalloc/test/unit/nstime.c
@@ -3,25 +3,30 @@
 #define BILLION	UINT64_C(1000000000)
 
 TEST_BEGIN(test_nstime_init) {
+	volatile int __A_VARIABLE;
 	nstime_t nst;
 
 	nstime_init(&nst, 42000000043);
 	assert_u64_eq(nstime_ns(&nst), 42000000043, "ns incorrectly read");
 	assert_u64_eq(nstime_sec(&nst), 42, "sec incorrectly read");
 	assert_u64_eq(nstime_nsec(&nst), 43, "nsec incorrectly read");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_init2) {
+	volatile int __A_VARIABLE;
 	nstime_t nst;
 
 	nstime_init2(&nst, 42, 43);
 	assert_u64_eq(nstime_sec(&nst), 42, "sec incorrectly read");
 	assert_u64_eq(nstime_nsec(&nst), 43, "nsec incorrectly read");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_copy) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -29,10 +34,12 @@ TEST_BEGIN(test_nstime_copy) {
 	nstime_copy(&nstb, &nsta);
 	assert_u64_eq(nstime_sec(&nstb), 42, "sec incorrectly copied");
 	assert_u64_eq(nstime_nsec(&nstb), 43, "nsec incorrectly copied");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_compare) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -63,10 +70,12 @@ TEST_BEGIN(test_nstime_compare) {
 	    "nsta should be less than nstb");
 	assert_d_eq(nstime_compare(&nstb, &nsta), 1,
 	    "nstb should be greater than nsta");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_add) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -82,10 +91,12 @@ TEST_BEGIN(test_nstime_add) {
 	nstime_init2(&nstb, 85, BILLION - 2);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect addition result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_iadd) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, BILLION - 1);
@@ -99,10 +110,12 @@ TEST_BEGIN(test_nstime_iadd) {
 	nstime_init2(&nstb, 43, 2);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect addition result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_subtract) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -118,10 +131,12 @@ TEST_BEGIN(test_nstime_subtract) {
 	nstime_init2(&nstb, 0, BILLION - 1);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect subtraction result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_isubtract) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -135,10 +150,12 @@ TEST_BEGIN(test_nstime_isubtract) {
 	nstime_init2(&nstb, 0, BILLION - 1);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect subtraction result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_imultiply) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -152,10 +169,12 @@ TEST_BEGIN(test_nstime_imultiply) {
 	nstime_init2(&nstb, 127, 999999998);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect multiplication result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_idivide) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb;
 
 	nstime_init2(&nsta, 42, 43);
@@ -171,10 +190,12 @@ TEST_BEGIN(test_nstime_idivide) {
 	nstime_idivide(&nsta, 3);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect division result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_divide) {
+	volatile int __A_VARIABLE;
 	nstime_t nsta, nstb, nstc;
 
 	nstime_init2(&nsta, 42, 43);
@@ -198,15 +219,19 @@ TEST_BEGIN(test_nstime_divide) {
 	nstime_subtract(&nsta, &nstc);
 	assert_u64_eq(nstime_divide(&nsta, &nstb), 9,
 	    "Incorrect division result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_monotonic) {
+	volatile int __A_VARIABLE;
 	nstime_monotonic();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_update) {
+	volatile int __A_VARIABLE;
 	nstime_t nst;
 
 	nstime_init(&nst, 0);
@@ -226,12 +251,15 @@ TEST_BEGIN(test_nstime_update) {
 		    "Update should detect time roll-back.");
 		assert_d_eq(nstime_compare(&nst, &nst0), 0,
 		    "Time should not have been modified");
+		__A_VARIABLE = 1;
 	}
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_nstime_init,
 	    test_nstime_init2,
diff --git a/deps/jemalloc/test/unit/pack.c b/deps/jemalloc/test/unit/pack.c
index fc188b0..b929c15 100644
--- a/deps/jemalloc/test/unit/pack.c
+++ b/deps/jemalloc/test/unit/pack.c
@@ -18,6 +18,7 @@
 
 static unsigned
 binind_compute(void) {
+	volatile int __A_VARIABLE;
 	size_t sz;
 	unsigned nbins, i;
 
@@ -38,16 +39,19 @@ binind_compute(void) {
 		assert_d_eq(mallctlbymib(mib, miblen, (void *)&size, &sz, NULL,
 		    0), 0, "Unexpected mallctlbymib failure");
 		if (size == SZ) {
+			__A_VARIABLE = 1;
 			return i;
 		}
 	}
 
 	test_fail("Unable to compute nregs_per_run");
+	__A_VARIABLE = 1;
 	return 0;
 }
 
 static size_t
 nregs_per_run_compute(void) {
+	volatile int __A_VARIABLE;
 	uint32_t nregs;
 	size_t sz;
 	unsigned binind = binind_compute();
@@ -60,11 +64,13 @@ nregs_per_run_compute(void) {
 	sz = sizeof(nregs);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&nregs, &sz, NULL,
 	    0), 0, "Unexpected mallctlbymib failure");
+	__A_VARIABLE = 1;
 	return nregs;
 }
 
 static unsigned
 arenas_create_mallctl(void) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t sz;
 
@@ -72,11 +78,13 @@ arenas_create_mallctl(void) {
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
 	    0, "Error in arenas.create");
 
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
 static void
 arena_reset_mallctl(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen = sizeof(mib)/sizeof(size_t);
 
@@ -85,9 +93,11 @@ arena_reset_mallctl(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_pack) {
+	volatile int __A_VARIABLE;
 	bool prof_enabled;
 	size_t sz = sizeof(prof_enabled);
 	if (mallctl("opt.prof", (void *)&prof_enabled, &sz, NULL, 0) == 0) {
@@ -156,11 +166,14 @@ TEST_BEGIN(test_pack) {
 
 	/* Clean up. */
 	arena_reset_mallctl(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_pack);
 }
diff --git a/deps/jemalloc/test/unit/pages.c b/deps/jemalloc/test/unit/pages.c
index ee729ee..55272ed 100644
--- a/deps/jemalloc/test/unit/pages.c
+++ b/deps/jemalloc/test/unit/pages.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_pages_huge) {
+	volatile int __A_VARIABLE;
 	size_t alloc_size;
 	bool commit;
 	void *pages, *hugepage;
@@ -19,11 +20,14 @@ TEST_BEGIN(test_pages_huge) {
 	}
 
 	pages_unmap(pages, alloc_size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_pages_huge);
 }
diff --git a/deps/jemalloc/test/unit/ph.c b/deps/jemalloc/test/unit/ph.c
index 88bf56f..0292f18 100644
--- a/deps/jemalloc/test/unit/ph.c
+++ b/deps/jemalloc/test/unit/ph.c
@@ -13,6 +13,7 @@ struct node_s {
 
 static int
 node_cmp(const node_t *a, const node_t *b) {
+	volatile int __A_VARIABLE;
 	int ret;
 
 	ret = (a->key > b->key) - (a->key < b->key);
@@ -24,15 +25,18 @@ node_cmp(const node_t *a, const node_t *b) {
 		ret = (((uintptr_t)a) > ((uintptr_t)b))
 		    - (((uintptr_t)a) < ((uintptr_t)b));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static int
 node_cmp_magic(const node_t *a, const node_t *b) {
+	volatile int __A_VARIABLE;
 
 	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
 	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
 
+	__A_VARIABLE = 1;
 	return node_cmp(a, b);
 }
 
@@ -41,6 +45,7 @@ ph_gen(static, heap_, heap_t, node_t, link, node_cmp_magic);
 
 static void
 node_print(const node_t *node, unsigned depth) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 	node_t *leftmost_child, *sibling;
 
@@ -51,6 +56,7 @@ node_print(const node_t *node, unsigned depth) {
 
 	leftmost_child = phn_lchild_get(node_t, link, node);
 	if (leftmost_child == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	node_print(leftmost_child, depth + 1);
@@ -59,10 +65,12 @@ node_print(const node_t *node, unsigned depth) {
 	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
 		node_print(sibling, depth + 1);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 heap_print(const heap_t *heap) {
+	volatile int __A_VARIABLE;
 	node_t *auxelm;
 
 	malloc_printf("vvv heap %p vvv\n", heap);
@@ -82,10 +90,12 @@ heap_print(const heap_t *heap) {
 
 label_return:
 	malloc_printf("^^^ heap %p ^^^\n", heap);
+	__A_VARIABLE = 1;
 }
 
 static unsigned
 node_validate(const node_t *node, const node_t *parent) {
+	volatile int __A_VARIABLE;
 	unsigned nnodes = 1;
 	node_t *leftmost_child, *sibling;
 
@@ -96,6 +106,7 @@ node_validate(const node_t *node, const node_t *parent) {
 
 	leftmost_child = phn_lchild_get(node_t, link, node);
 	if (leftmost_child == NULL) {
+		__A_VARIABLE = 1;
 		return nnodes;
 	}
 	assert_ptr_eq((void *)phn_prev_get(node_t, link, leftmost_child),
@@ -109,11 +120,13 @@ node_validate(const node_t *node, const node_t *parent) {
 		    "sibling's prev doesn't link to sibling");
 		nnodes += node_validate(sibling, node);
 	}
+	__A_VARIABLE = 1;
 	return nnodes;
 }
 
 static unsigned
 heap_validate(const heap_t *heap) {
+	volatile int __A_VARIABLE;
 	unsigned nnodes = 0;
 	node_t *auxelm;
 
@@ -135,16 +148,19 @@ label_return:
 	if (false) {
 		heap_print(heap);
 	}
+	__A_VARIABLE = 1;
 	return nnodes;
 }
 
 TEST_BEGIN(test_ph_empty) {
+	volatile int __A_VARIABLE;
 	heap_t heap;
 
 	heap_new(&heap);
 	assert_true(heap_empty(&heap), "Heap should be empty");
 	assert_ptr_null(heap_first(&heap), "Unexpected node");
 	assert_ptr_null(heap_any(&heap), "Unexpected node");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -157,19 +173,24 @@ node_remove(heap_t *heap, node_t *node) {
 
 static node_t *
 node_remove_first(heap_t *heap) {
+	volatile int __A_VARIABLE;
 	node_t *node = heap_remove_first(heap);
 	node->magic = 0;
+	__A_VARIABLE = 1;
 	return node;
 }
 
 static node_t *
 node_remove_any(heap_t *heap) {
+	volatile int __A_VARIABLE;
 	node_t *node = heap_remove_any(heap);
 	node->magic = 0;
+	__A_VARIABLE = 1;
 	return node;
 }
 
 TEST_BEGIN(test_ph_random) {
+	volatile int __A_VARIABLE;
 #define NNODES 25
 #define NBAGS 250
 #define SEED 42
@@ -307,11 +328,14 @@ TEST_BEGIN(test_ph_random) {
 	fini_gen_rand(sfmt);
 #undef NNODES
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_ph_empty,
 	    test_ph_random);
diff --git a/deps/jemalloc/test/unit/prng.c b/deps/jemalloc/test/unit/prng.c
index b5795c2..fe1e81d 100644
--- a/deps/jemalloc/test/unit/prng.c
+++ b/deps/jemalloc/test/unit/prng.c
@@ -2,6 +2,7 @@
 
 static void
 test_prng_lg_range_u32(bool atomic) {
+	volatile int __A_VARIABLE;
 	atomic_u32_t sa, sb;
 	uint32_t ra, rb;
 	unsigned lg_range;
@@ -35,10 +36,12 @@ test_prng_lg_range_u32(bool atomic) {
 		    "Expected high order bits of full-width result, "
 		    "lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_prng_lg_range_u64(void) {
+	volatile int __A_VARIABLE;
 	uint64_t sa, sb, ra, rb;
 	unsigned lg_range;
 
@@ -71,10 +74,12 @@ test_prng_lg_range_u64(void) {
 		    "Expected high order bits of full-width result, "
 		    "lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_prng_lg_range_zu(bool atomic) {
+	volatile int __A_VARIABLE;
 	atomic_zu_t sa, sb;
 	size_t ra, rb;
 	unsigned lg_range;
@@ -109,35 +114,47 @@ test_prng_lg_range_zu(bool atomic) {
 		    lg_range)), "Expected high order bits of full-width "
 		    "result, lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prng_lg_range_u32_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_lg_range_u32(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_u32_atomic) {
+	volatile int __A_VARIABLE;
 	test_prng_lg_range_u32(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_u64_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_lg_range_u64();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_zu_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_lg_range_zu(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_zu_atomic) {
+	volatile int __A_VARIABLE;
 	test_prng_lg_range_zu(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 test_prng_range_u32(bool atomic) {
+	volatile int __A_VARIABLE;
 	uint32_t range;
 #define MAX_RANGE	10000000
 #define RANGE_STEP	97
@@ -154,10 +171,12 @@ test_prng_range_u32(bool atomic) {
 			assert_u32_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_prng_range_u64(void) {
+	volatile int __A_VARIABLE;
 	uint64_t range;
 #define MAX_RANGE	10000000
 #define RANGE_STEP	97
@@ -174,10 +193,12 @@ test_prng_range_u64(void) {
 			assert_u64_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_prng_range_zu(bool atomic) {
+	volatile int __A_VARIABLE;
 	size_t range;
 #define MAX_RANGE	10000000
 #define RANGE_STEP	97
@@ -194,35 +215,48 @@ test_prng_range_zu(bool atomic) {
 			assert_zu_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prng_range_u32_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_range_u32(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_u32_atomic) {
+	volatile int __A_VARIABLE;
 	test_prng_range_u32(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_u64_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_range_u64();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_zu_nonatomic) {
+	volatile int __A_VARIABLE;
 	test_prng_range_zu(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_zu_atomic) {
+	volatile int __A_VARIABLE;
 	test_prng_range_zu(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_prng_lg_range_u32_nonatomic,
 	    test_prng_lg_range_u32_atomic,
diff --git a/deps/jemalloc/test/unit/prof_accum.c b/deps/jemalloc/test/unit/prof_accum.c
index 2522006..43ec32d 100644
--- a/deps/jemalloc/test/unit/prof_accum.c
+++ b/deps/jemalloc/test/unit/prof_accum.c
@@ -7,21 +7,26 @@
 
 static int
 prof_dump_open_intercept(bool propagate_err, const char *filename) {
+	volatile int __A_VARIABLE;
 	int fd;
 
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 static void *
 alloc_from_permuted_backtrace(unsigned thd_ind, unsigned iteration) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return btalloc(1, thd_ind*NALLOCS_PER_THREAD + iteration);
 }
 
 static void *
 thd_start(void *varg) {
+	volatile int __A_VARIABLE;
 	unsigned thd_ind = *(unsigned *)varg;
 	size_t bt_count_prev, bt_count;
 	unsigned i_prev, i;
@@ -46,10 +51,12 @@ thd_start(void *varg) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_idump) {
+	volatile int __A_VARIABLE;
 	bool active;
 	thd_t thds[NTHREADS];
 	unsigned thd_args[NTHREADS];
@@ -71,11 +78,14 @@ TEST_BEGIN(test_idump) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_idump);
 }
diff --git a/deps/jemalloc/test/unit/prof_active.c b/deps/jemalloc/test/unit/prof_active.c
index 850a24a..a1ac30d 100644
--- a/deps/jemalloc/test/unit/prof_active.c
+++ b/deps/jemalloc/test/unit/prof_active.c
@@ -2,6 +2,7 @@
 
 static void
 mallctl_bool_get(const char *name, bool expected, const char *func, int line) {
+	volatile int __A_VARIABLE;
 	bool old;
 	size_t sz;
 
@@ -10,11 +11,13 @@ mallctl_bool_get(const char *name, bool expected, const char *func, int line) {
 	    "%s():%d: Unexpected mallctl failure reading %s", func, line, name);
 	assert_b_eq(old, expected, "%s():%d: Unexpected %s value", func, line,
 	    name);
+	__A_VARIABLE = 1;
 }
 
 static void
 mallctl_bool_set(const char *name, bool old_expected, bool val_new,
     const char *func, int line) {
+	volatile int __A_VARIABLE;
 	bool old;
 	size_t sz;
 
@@ -25,12 +28,15 @@ mallctl_bool_set(const char *name, bool old_expected, bool val_new,
 	    line, name);
 	assert_b_eq(old, old_expected, "%s():%d: Unexpected %s value", func,
 	    line, name);
+	__A_VARIABLE = 1;
 }
 
 static void
 mallctl_prof_active_get_impl(bool prof_active_old_expected, const char *func,
     int line) {
+	volatile int __A_VARIABLE;
 	mallctl_bool_get("prof.active", prof_active_old_expected, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_prof_active_get(a)					\
 	mallctl_prof_active_get_impl(a, __func__, __LINE__)
@@ -38,8 +44,10 @@ mallctl_prof_active_get_impl(bool prof_active_old_expected, const char *func,
 static void
 mallctl_prof_active_set_impl(bool prof_active_old_expected,
     bool prof_active_new, const char *func, int line) {
+	volatile int __A_VARIABLE;
 	mallctl_bool_set("prof.active", prof_active_old_expected,
 	    prof_active_new, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_prof_active_set(a, b)					\
 	mallctl_prof_active_set_impl(a, b, __func__, __LINE__)
@@ -47,8 +55,10 @@ mallctl_prof_active_set_impl(bool prof_active_old_expected,
 static void
 mallctl_thread_prof_active_get_impl(bool thread_prof_active_old_expected,
     const char *func, int line) {
+	volatile int __A_VARIABLE;
 	mallctl_bool_get("thread.prof.active", thread_prof_active_old_expected,
 	    func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_prof_active_get(a)				\
 	mallctl_thread_prof_active_get_impl(a, __func__, __LINE__)
@@ -56,14 +66,17 @@ mallctl_thread_prof_active_get_impl(bool thread_prof_active_old_expected,
 static void
 mallctl_thread_prof_active_set_impl(bool thread_prof_active_old_expected,
     bool thread_prof_active_new, const char *func, int line) {
+	volatile int __A_VARIABLE;
 	mallctl_bool_set("thread.prof.active", thread_prof_active_old_expected,
 	    thread_prof_active_new, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_prof_active_set(a, b)				\
 	mallctl_thread_prof_active_set_impl(a, b, __func__, __LINE__)
 
 static void
 prof_sampling_probe_impl(bool expect_sample, const char *func, int line) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t expected_backtraces = expect_sample ? 1 : 0;
 
@@ -74,11 +87,13 @@ prof_sampling_probe_impl(bool expect_sample, const char *func, int line) {
 	assert_zu_eq(prof_bt_count(), expected_backtraces,
 	    "%s():%d: Unexpected backtrace count", func, line);
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 #define prof_sampling_probe(a)						\
 	prof_sampling_probe_impl(a, __func__, __LINE__)
 
 TEST_BEGIN(test_prof_active) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_prof);
 
 	mallctl_prof_active_get(true);
@@ -107,11 +122,14 @@ TEST_BEGIN(test_prof_active) {
 	/* Restore settings. */
 	mallctl_prof_active_set(true, true);
 	mallctl_thread_prof_active_set(true, false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_active);
 }
diff --git a/deps/jemalloc/test/unit/prof_gdump.c b/deps/jemalloc/test/unit/prof_gdump.c
index fcb434c..dfb48cb 100644
--- a/deps/jemalloc/test/unit/prof_gdump.c
+++ b/deps/jemalloc/test/unit/prof_gdump.c
@@ -4,6 +4,7 @@ static bool did_prof_dump_open;
 
 static int
 prof_dump_open_intercept(bool propagate_err, const char *filename) {
+	volatile int __A_VARIABLE;
 	int fd;
 
 	did_prof_dump_open = true;
@@ -11,10 +12,12 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 TEST_BEGIN(test_gdump) {
+	volatile int __A_VARIABLE;
 	bool active, gdump, gdump_old;
 	void *p, *q, *r, *s;
 	size_t sz;
@@ -64,11 +67,14 @@ TEST_BEGIN(test_gdump) {
 	dallocx(q, 0);
 	dallocx(r, 0);
 	dallocx(s, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_gdump);
 }
diff --git a/deps/jemalloc/test/unit/prof_idump.c b/deps/jemalloc/test/unit/prof_idump.c
index 1cc6c98..c1850cd 100644
--- a/deps/jemalloc/test/unit/prof_idump.c
+++ b/deps/jemalloc/test/unit/prof_idump.c
@@ -4,6 +4,7 @@ static bool did_prof_dump_open;
 
 static int
 prof_dump_open_intercept(bool propagate_err, const char *filename) {
+	volatile int __A_VARIABLE;
 	int fd;
 
 	did_prof_dump_open = true;
@@ -11,10 +12,12 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 TEST_BEGIN(test_idump) {
+	volatile int __A_VARIABLE;
 	bool active;
 	void *p;
 
@@ -32,11 +35,14 @@ TEST_BEGIN(test_idump) {
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 	dallocx(p, 0);
 	assert_true(did_prof_dump_open, "Expected a profile dump");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_idump);
 }
diff --git a/deps/jemalloc/test/unit/prof_reset.c b/deps/jemalloc/test/unit/prof_reset.c
index 7cce42d..fe5e63d 100644
--- a/deps/jemalloc/test/unit/prof_reset.c
+++ b/deps/jemalloc/test/unit/prof_reset.c
@@ -2,41 +2,50 @@
 
 static int
 prof_dump_open_intercept(bool propagate_err, const char *filename) {
+	volatile int __A_VARIABLE;
 	int fd;
 
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 static void
 set_prof_active(bool active) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
 	    sizeof(active)), 0, "Unexpected mallctl failure");
+	__A_VARIABLE = 1;
 }
 
 static size_t
 get_lg_prof_sample(void) {
+	volatile int __A_VARIABLE;
 	size_t lg_prof_sample;
 	size_t sz = sizeof(size_t);
 
 	assert_d_eq(mallctl("prof.lg_sample", (void *)&lg_prof_sample, &sz,
 	    NULL, 0), 0,
 	    "Unexpected mallctl failure while reading profiling sample rate");
+	__A_VARIABLE = 1;
 	return lg_prof_sample;
 }
 
 static void
 do_prof_reset(size_t lg_prof_sample) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("prof.reset", NULL, NULL,
 	    (void *)&lg_prof_sample, sizeof(size_t)), 0,
 	    "Unexpected mallctl failure while resetting profile data");
 	assert_zu_eq(lg_prof_sample, get_lg_prof_sample(),
 	    "Expected profile sample rate change");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prof_reset_basic) {
+	volatile int __A_VARIABLE;
 	size_t lg_prof_sample_orig, lg_prof_sample, lg_prof_sample_next;
 	size_t sz;
 	unsigned i;
@@ -78,6 +87,7 @@ TEST_BEGIN(test_prof_reset_basic) {
 	assert_zu_eq(lg_prof_sample_orig, lg_prof_sample,
 	    "Unexpected disagreement between \"opt.lg_prof_sample\" and "
 	    "\"prof.lg_sample\"");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -86,13 +96,16 @@ prof_cnt_t cnt_all_copy = {0, 0, 0, 0};
 static bool
 prof_dump_header_intercept(tsdn_t *tsdn, bool propagate_err,
     const prof_cnt_t *cnt_all) {
+	volatile int __A_VARIABLE;
 	prof_dump_header_intercepted = true;
 	memcpy(&cnt_all_copy, cnt_all, sizeof(prof_cnt_t));
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 TEST_BEGIN(test_prof_reset_cleanup) {
+	volatile int __A_VARIABLE;
 	void *p;
 	prof_dump_header_t *prof_dump_header_orig;
 
@@ -127,6 +140,7 @@ TEST_BEGIN(test_prof_reset_cleanup) {
 	assert_zu_eq(prof_bt_count(), 0, "Expected 0 backtraces");
 
 	set_prof_active(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -137,6 +151,7 @@ TEST_END
 #define DUMP_INTERVAL		3677
 static void *
 thd_start(void *varg) {
+	volatile int __A_VARIABLE;
 	unsigned thd_ind = *(unsigned *)varg;
 	unsigned i;
 	void *objs[OBJ_RING_BUF_COUNT];
@@ -176,10 +191,12 @@ thd_start(void *varg) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_prof_reset) {
+	volatile int __A_VARIABLE;
 	size_t lg_prof_sample_orig;
 	thd_t thds[NTHREADS];
 	unsigned thd_args[NTHREADS];
@@ -214,6 +231,7 @@ TEST_BEGIN(test_prof_reset) {
 	set_prof_active(false);
 
 	do_prof_reset(lg_prof_sample_orig);
+	__A_VARIABLE = 1;
 }
 TEST_END
 #undef NTHREADS
@@ -275,9 +293,11 @@ TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	/* Intercept dumping prior to running any tests. */
 	prof_dump_open = prof_dump_open_intercept;
 
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_reset_basic,
 	    test_prof_reset_cleanup,
diff --git a/deps/jemalloc/test/unit/prof_tctx.c b/deps/jemalloc/test/unit/prof_tctx.c
index ff3b2b0..2033c8e 100644
--- a/deps/jemalloc/test/unit/prof_tctx.c
+++ b/deps/jemalloc/test/unit/prof_tctx.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_prof_realloc) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn;
 	int flags;
 	void *p, *q;
@@ -36,11 +37,14 @@ TEST_BEGIN(test_prof_realloc) {
 	prof_cnt_all(&curobjs_3, NULL, NULL, NULL);
 	assert_u64_eq(curobjs_0, curobjs_3,
 	    "Sample size should have returned to base level");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_realloc);
 }
diff --git a/deps/jemalloc/test/unit/prof_thread_name.c b/deps/jemalloc/test/unit/prof_thread_name.c
index c9c2a2b..24165c8 100644
--- a/deps/jemalloc/test/unit/prof_thread_name.c
+++ b/deps/jemalloc/test/unit/prof_thread_name.c
@@ -3,6 +3,7 @@
 static void
 mallctl_thread_name_get_impl(const char *thread_name_expected, const char *func,
     int line) {
+	volatile int __A_VARIABLE;
 	const char *thread_name_old;
 	size_t sz;
 
@@ -13,6 +14,7 @@ mallctl_thread_name_get_impl(const char *thread_name_expected, const char *func,
 	    func, line);
 	assert_str_eq(thread_name_old, thread_name_expected,
 	    "%s():%d: Unexpected thread.prof.name value", func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_name_get(a)					\
 	mallctl_thread_name_get_impl(a, __func__, __LINE__)
@@ -20,16 +22,19 @@ mallctl_thread_name_get_impl(const char *thread_name_expected, const char *func,
 static void
 mallctl_thread_name_set_impl(const char *thread_name, const char *func,
     int line) {
+	volatile int __A_VARIABLE;
 	assert_d_eq(mallctl("thread.prof.name", NULL, NULL,
 	    (void *)&thread_name, sizeof(thread_name)), 0,
 	    "%s():%d: Unexpected mallctl failure reading thread.prof.name",
 	    func, line);
 	mallctl_thread_name_get_impl(thread_name, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_name_set(a)					\
 	mallctl_thread_name_set_impl(a, __func__, __LINE__)
 
 TEST_BEGIN(test_prof_thread_name_validation) {
+	volatile int __A_VARIABLE;
 	const char *thread_name;
 
 	test_skip_if(!config_prof);
@@ -65,6 +70,7 @@ TEST_BEGIN(test_prof_thread_name_validation) {
 	}
 
 	mallctl_thread_name_set("");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -94,6 +100,7 @@ thd_start(void *varg) {
 }
 
 TEST_BEGIN(test_prof_thread_name_threaded) {
+	volatile int __A_VARIABLE;
 	thd_t thds[NTHREADS];
 	unsigned thd_args[NTHREADS];
 	unsigned i;
@@ -107,6 +114,7 @@ TEST_BEGIN(test_prof_thread_name_threaded) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 #undef NTHREADS
@@ -114,6 +122,8 @@ TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_prof_thread_name_validation,
 	    test_prof_thread_name_threaded);
diff --git a/deps/jemalloc/test/unit/ql.c b/deps/jemalloc/test/unit/ql.c
index b76c24c..1ee830a 100644
--- a/deps/jemalloc/test/unit/ql.c
+++ b/deps/jemalloc/test/unit/ql.c
@@ -15,6 +15,7 @@ struct list_s {
 
 static void
 test_empty_list(list_head_t *head) {
+	volatile int __A_VARIABLE;
 	list_t *t;
 	unsigned i;
 
@@ -33,13 +34,16 @@ test_empty_list(list_head_t *head) {
 		i++;
 	}
 	assert_u_eq(i, 0, "Unexpected element for empty list");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_ql_empty) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 
 	ql_new(&head);
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -55,6 +59,7 @@ init_entries(list_t *entries, unsigned nentries) {
 
 static void
 test_entries_list(list_head_t *head, list_t *entries, unsigned nentries) {
+	volatile int __A_VARIABLE;
 	list_t *t;
 	unsigned i;
 
@@ -87,9 +92,11 @@ test_entries_list(list_head_t *head, list_t *entries, unsigned nentries) {
 		t = ql_prev(head, &entries[i], link);
 		assert_c_eq(t->id, entries[i-1].id, "Element id mismatch");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_ql_tail_insert) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 	list_t entries[NENTRIES];
 	unsigned i;
@@ -101,10 +108,12 @@ TEST_BEGIN(test_ql_tail_insert) {
 	}
 
 	test_entries_list(&head, entries, NENTRIES);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ql_tail_remove) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 	list_t entries[NENTRIES];
 	unsigned i;
@@ -120,10 +129,12 @@ TEST_BEGIN(test_ql_tail_remove) {
 		ql_tail_remove(&head, list_t, link);
 	}
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ql_head_insert) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 	list_t entries[NENTRIES];
 	unsigned i;
@@ -135,10 +146,12 @@ TEST_BEGIN(test_ql_head_insert) {
 	}
 
 	test_entries_list(&head, entries, NENTRIES);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ql_head_remove) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 	list_t entries[NENTRIES];
 	unsigned i;
@@ -154,10 +167,12 @@ TEST_BEGIN(test_ql_head_remove) {
 		ql_head_remove(&head, list_t, link);
 	}
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ql_insert) {
+	volatile int __A_VARIABLE;
 	list_head_t head;
 	list_t entries[8];
 	list_t *a, *b, *c, *d, *e, *f, *g, *h;
@@ -189,11 +204,14 @@ TEST_BEGIN(test_ql_insert) {
 	ql_before_insert(&head, f, e, link);
 
 	test_entries_list(&head, entries, sizeof(entries)/sizeof(list_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_ql_empty,
 	    test_ql_tail_insert,
diff --git a/deps/jemalloc/test/unit/qr.c b/deps/jemalloc/test/unit/qr.c
index 271a109..72b22d8 100644
--- a/deps/jemalloc/test/unit/qr.c
+++ b/deps/jemalloc/test/unit/qr.c
@@ -16,16 +16,19 @@ struct ring_s {
 
 static void
 init_entries(ring_t *entries) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	for (i = 0; i < NENTRIES; i++) {
 		qr_new(&entries[i], link);
 		entries[i].id = 'a' + i;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 test_independent_entries(ring_t *entries) {
+	volatile int __A_VARIABLE;
 	ring_t *t;
 	unsigned i, j;
 
@@ -59,13 +62,16 @@ test_independent_entries(ring_t *entries) {
 		    "Previous element in single-element ring should be same as "
 		    "current element");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_qr_one) {
+	volatile int __A_VARIABLE;
 	ring_t entries[NENTRIES];
 
 	init_entries(entries);
 	test_independent_entries(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -103,6 +109,7 @@ test_entries_ring(ring_t *entries) {
 }
 
 TEST_BEGIN(test_qr_after_insert) {
+	volatile int __A_VARIABLE;
 	ring_t entries[NENTRIES];
 	unsigned i;
 
@@ -111,10 +118,12 @@ TEST_BEGIN(test_qr_after_insert) {
 		qr_after_insert(&entries[i - 1], &entries[i], link);
 	}
 	test_entries_ring(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_qr_remove) {
+	volatile int __A_VARIABLE;
 	ring_t entries[NENTRIES];
 	ring_t *t;
 	unsigned i, j;
@@ -140,10 +149,12 @@ TEST_BEGIN(test_qr_remove) {
 		qr_remove(&entries[i], link);
 	}
 	test_independent_entries(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_qr_before_insert) {
+	volatile int __A_VARIABLE;
 	ring_t entries[NENTRIES];
 	ring_t *t;
 	unsigned i, j;
@@ -178,11 +189,13 @@ TEST_BEGIN(test_qr_before_insert) {
 		assert_c_eq(t->id, entries[(i+1) % NENTRIES].id,
 		    "Element id mismatch");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 test_split_entries(ring_t *entries) {
+	volatile int __A_VARIABLE;
 	ring_t *t;
 	unsigned i, j;
 
@@ -201,9 +214,11 @@ test_split_entries(ring_t *entries) {
 			j++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_qr_meld_split) {
+	volatile int __A_VARIABLE;
 	ring_t entries[NENTRIES];
 	unsigned i;
 
@@ -229,11 +244,14 @@ TEST_BEGIN(test_qr_meld_split) {
 
 	qr_meld(&entries[0], &entries[0], ring_t, link);
 	test_entries_ring(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_qr_one,
 	    test_qr_after_insert,
diff --git a/deps/jemalloc/test/unit/rb.c b/deps/jemalloc/test/unit/rb.c
index 65c0492..4d48aaf 100644
--- a/deps/jemalloc/test/unit/rb.c
+++ b/deps/jemalloc/test/unit/rb.c
@@ -24,6 +24,7 @@ struct node_s {
 
 static int
 node_cmp(const node_t *a, const node_t *b) {
+	volatile int __A_VARIABLE;
 	int ret;
 
 	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
@@ -38,6 +39,7 @@ node_cmp(const node_t *a, const node_t *b) {
 		ret = (((uintptr_t)a) > ((uintptr_t)b))
 		    - (((uintptr_t)a) < ((uintptr_t)b));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -119,6 +121,7 @@ tree_recurse(node_t *node, unsigned black_height, unsigned black_depth) {
 
 static node_t *
 tree_iterate_cb(tree_t *tree, node_t *node, void *data) {
+	volatile int __A_VARIABLE;
 	unsigned *i = (unsigned *)data;
 	node_t *search_node;
 
@@ -141,31 +144,37 @@ tree_iterate_cb(tree_t *tree, node_t *node, void *data) {
 
 	(*i)++;
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static unsigned
 tree_iterate(tree_t *tree) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	i = 0;
 	tree_iter(tree, NULL, tree_iterate_cb, (void *)&i);
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
 static unsigned
 tree_iterate_reverse(tree_t *tree) {
+	volatile int __A_VARIABLE;
 	unsigned i;
 
 	i = 0;
 	tree_reverse_iter(tree, NULL, tree_iterate_cb, (void *)&i);
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
 static void
 node_remove(tree_t *tree, node_t *node, unsigned nnodes) {
+	volatile int __A_VARIABLE;
 	node_t *search_node;
 	unsigned black_height, imbalances;
 
@@ -194,37 +203,45 @@ node_remove(tree_t *tree, node_t *node, unsigned nnodes) {
 	    "Unexpected node iteration count");
 	assert_u_eq(tree_iterate_reverse(tree), nnodes-1,
 	    "Unexpected node iteration count");
+	__A_VARIABLE = 1;
 }
 
 static node_t *
 remove_iterate_cb(tree_t *tree, node_t *node, void *data) {
+	volatile int __A_VARIABLE;
 	unsigned *nnodes = (unsigned *)data;
 	node_t *ret = tree_next(tree, node);
 
 	node_remove(tree, node, *nnodes);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static node_t *
 remove_reverse_iterate_cb(tree_t *tree, node_t *node, void *data) {
+	volatile int __A_VARIABLE;
 	unsigned *nnodes = (unsigned *)data;
 	node_t *ret = tree_prev(tree, node);
 
 	node_remove(tree, node, *nnodes);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static void
 destroy_cb(node_t *node, void *data) {
+	volatile int __A_VARIABLE;
 	unsigned *nnodes = (unsigned *)data;
 
 	assert_u_gt(*nnodes, 0, "Destruction removed too many nodes");
 	(*nnodes)--;
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_rb_random) {
+	volatile int __A_VARIABLE;
 #define NNODES 25
 #define NBAGS 250
 #define SEED 42
@@ -344,11 +361,14 @@ TEST_BEGIN(test_rb_random) {
 #undef NNODES
 #undef NBAGS
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_rb_empty,
 	    test_rb_random);
diff --git a/deps/jemalloc/test/unit/retained.c b/deps/jemalloc/test/unit/retained.c
index d51a598..ab0c326 100644
--- a/deps/jemalloc/test/unit/retained.c
+++ b/deps/jemalloc/test/unit/retained.c
@@ -12,16 +12,19 @@ static atomic_u_t	nfinished;
 
 static unsigned
 do_arena_create(extent_hooks_t *h) {
+	volatile int __A_VARIABLE;
 	unsigned arena_ind;
 	size_t sz = sizeof(unsigned);
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
 	    (void *)(h != NULL ? &h : NULL), (h != NULL ? sizeof(h) : 0)), 0,
 	    "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
 static void
 do_arena_destroy(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[3];
 	size_t miblen;
 
@@ -31,17 +34,21 @@ do_arena_destroy(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static void
 do_refresh(void) {
+	volatile int __A_VARIABLE;
 	uint64_t epoch = 1;
 	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
 	    sizeof(epoch)), 0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 
 static size_t
 do_get_size_impl(const char *cmd, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	size_t mib[4];
 	size_t miblen = sizeof(mib) / sizeof(size_t);
 	size_t z = sizeof(size_t);
@@ -53,21 +60,27 @@ do_get_size_impl(const char *cmd, unsigned arena_ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&size, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\"], ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return size;
 }
 
 static size_t
 do_get_active(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return do_get_size_impl("stats.arenas.0.pactive", arena_ind) * PAGE;
 }
 
 static size_t
 do_get_mapped(unsigned arena_ind) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return do_get_size_impl("stats.arenas.0.mapped", arena_ind);
 }
 
 static void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	for (unsigned next_epoch = 1; next_epoch < NEPOCHS; next_epoch++) {
 		/* Busy-wait for next epoch. */
 		unsigned cur_epoch;
@@ -94,10 +107,12 @@ thd_start(void *arg) {
 		atomic_fetch_add_u(&nfinished, 1, ATOMIC_RELEASE);
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_retained) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_stats);
 
 	arena_ind = do_arena_create(NULL);
@@ -171,11 +186,14 @@ TEST_BEGIN(test_retained) {
 	}
 
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_retained);
 }
diff --git a/deps/jemalloc/test/unit/rtree.c b/deps/jemalloc/test/unit/rtree.c
index 908100f..ac0458d 100644
--- a/deps/jemalloc/test/unit/rtree.c
+++ b/deps/jemalloc/test/unit/rtree.c
@@ -12,9 +12,11 @@ rtree_t test_rtree;
 
 static rtree_node_elm_t *
 rtree_node_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
+	volatile int __A_VARIABLE;
 	rtree_node_elm_t *node;
 
 	if (rtree != &test_rtree) {
+		__A_VARIABLE = 1;
 		return rtree_node_alloc_orig(tsdn, rtree, nelms);
 	}
 
@@ -23,25 +25,31 @@ rtree_node_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	assert_ptr_not_null(node, "Unexpected calloc() failure");
 	malloc_mutex_lock(tsdn, &rtree->init_lock);
 
+	__A_VARIABLE = 1;
 	return node;
 }
 
 static void
 rtree_node_dalloc_intercept(tsdn_t *tsdn, rtree_t *rtree,
     rtree_node_elm_t *node) {
+	volatile int __A_VARIABLE;
 	if (rtree != &test_rtree) {
 		rtree_node_dalloc_orig(tsdn, rtree, node);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(node);
+	__A_VARIABLE = 1;
 }
 
 static rtree_leaf_elm_t *
 rtree_leaf_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
+	volatile int __A_VARIABLE;
 	rtree_leaf_elm_t *leaf;
 
 	if (rtree != &test_rtree) {
+		__A_VARIABLE = 1;
 		return rtree_leaf_alloc_orig(tsdn, rtree, nelms);
 	}
 
@@ -50,21 +58,26 @@ rtree_leaf_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	assert_ptr_not_null(leaf, "Unexpected calloc() failure");
 	malloc_mutex_lock(tsdn, &rtree->init_lock);
 
+	__A_VARIABLE = 1;
 	return leaf;
 }
 
 static void
 rtree_leaf_dalloc_intercept(tsdn_t *tsdn, rtree_t *rtree,
     rtree_leaf_elm_t *leaf) {
+	volatile int __A_VARIABLE;
 	if (rtree != &test_rtree) {
 		rtree_leaf_dalloc_orig(tsdn, rtree, leaf);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(leaf);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_rtree_read_empty) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn;
 
 	tsdn = tsdn_fetch();
@@ -76,6 +89,7 @@ TEST_BEGIN(test_rtree_read_empty) {
 	assert_ptr_null(rtree_extent_read(tsdn, rtree, &rtree_ctx, PAGE,
 	    false), "rtree_extent_read() should return NULL for empty tree");
 	rtree_delete(tsdn, rtree);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -119,6 +133,7 @@ TEST_BEGIN(test_rtree_extrema) {
 TEST_END
 
 TEST_BEGIN(test_rtree_bits) {
+	volatile int __A_VARIABLE;
 	tsdn_t *tsdn = tsdn_fetch();
 
 	uintptr_t keys[] = {PAGE, PAGE + 1,
@@ -152,10 +167,12 @@ TEST_BEGIN(test_rtree_bits) {
 	}
 
 	rtree_delete(tsdn, rtree);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_rtree_random) {
+	volatile int __A_VARIABLE;
 #define NSET 16
 #define SEED 42
 	sfmt_t *sfmt = init_gen_rand(SEED);
@@ -205,11 +222,13 @@ TEST_BEGIN(test_rtree_random) {
 	fini_gen_rand(sfmt);
 #undef NSET
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	rtree_node_alloc_orig = rtree_node_alloc;
 	rtree_node_alloc = rtree_node_alloc_intercept;
 	rtree_node_dalloc_orig = rtree_node_dalloc;
@@ -219,6 +238,7 @@ main(void) {
 	rtree_leaf_dalloc_orig = rtree_leaf_dalloc;
 	rtree_leaf_dalloc = rtree_leaf_dalloc_intercept;
 
+	__A_VARIABLE = 1;
 	return test(
 	    test_rtree_read_empty,
 	    test_rtree_extrema,
diff --git a/deps/jemalloc/test/unit/size_classes.c b/deps/jemalloc/test/unit/size_classes.c
index bcff560..7a41df2 100644
--- a/deps/jemalloc/test/unit/size_classes.c
+++ b/deps/jemalloc/test/unit/size_classes.c
@@ -2,6 +2,7 @@
 
 static size_t
 get_max_size_class(void) {
+	volatile int __A_VARIABLE;
 	unsigned nlextents;
 	size_t mib[4];
 	size_t sz, miblen, max_size_class;
@@ -19,10 +20,12 @@ get_max_size_class(void) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
 	    NULL, 0), 0, "Unexpected mallctlbymib() error");
 
+	__A_VARIABLE = 1;
 	return max_size_class;
 }
 
 TEST_BEGIN(test_size_classes) {
+	volatile int __A_VARIABLE;
 	size_t size_class, max_size_class;
 	szind_t index, max_index;
 
@@ -77,10 +80,12 @@ TEST_BEGIN(test_size_classes) {
 	    "sz_s2u() does not round up to size class");
 	assert_zu_eq(size_class, sz_s2u(size_class),
 	    "sz_s2u() does not compute same size class");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_psize_classes) {
+	volatile int __A_VARIABLE;
 	size_t size_class, max_psz;
 	pszind_t pind, max_pind;
 
@@ -133,10 +138,12 @@ TEST_BEGIN(test_psize_classes) {
 	    "sz_psz2u() does not round up to size class");
 	assert_zu_eq(size_class, sz_psz2u(size_class),
 	    "sz_psz2u() does not compute same size class");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_overflow) {
+	volatile int __A_VARIABLE;
 	size_t max_size_class, max_psz;
 
 	max_size_class = get_max_size_class();
@@ -171,11 +178,14 @@ TEST_BEGIN(test_overflow) {
 	    "size");
 	assert_zu_eq(sz_psz2u(SIZE_T_MAX), max_psz,
 	    "sz_psz2u() should return (LARGE_MAXCLASS + PAGE) on overflow");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_size_classes,
 	    test_psize_classes,
diff --git a/deps/jemalloc/test/unit/slab.c b/deps/jemalloc/test/unit/slab.c
index 7e662ae..0b882d2 100644
--- a/deps/jemalloc/test/unit/slab.c
+++ b/deps/jemalloc/test/unit/slab.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_arena_slab_regind) {
+	volatile int __A_VARIABLE;
 	szind_t binind;
 
 	for (binind = 0; binind < NBINS; binind++) {
@@ -22,11 +23,14 @@ TEST_BEGIN(test_arena_slab_regind) {
 		}
 		free(extent_addr_get(&slab));
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_arena_slab_regind);
 }
diff --git a/deps/jemalloc/test/unit/smoothstep.c b/deps/jemalloc/test/unit/smoothstep.c
index 7c5dbb7..22d621c 100644
--- a/deps/jemalloc/test/unit/smoothstep.c
+++ b/deps/jemalloc/test/unit/smoothstep.c
@@ -8,6 +8,7 @@ static const uint64_t smoothstep_tab[] = {
 };
 
 TEST_BEGIN(test_smoothstep_integral) {
+	volatile int __A_VARIABLE;
 	uint64_t sum, min, max;
 	unsigned i;
 
@@ -33,10 +34,12 @@ TEST_BEGIN(test_smoothstep_integral) {
 		malloc_printf("%"FMTu64" ulps under 1/2 (limit %d)\n",
 		    max - sum, SMOOTHSTEP_NSTEPS);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_smoothstep_monotonic) {
+	volatile int __A_VARIABLE;
 	uint64_t prev_h;
 	unsigned i;
 
@@ -54,10 +57,12 @@ TEST_BEGIN(test_smoothstep_monotonic) {
 	}
 	assert_u64_eq(smoothstep_tab[SMOOTHSTEP_NSTEPS-1],
 	    (KQU(1) << SMOOTHSTEP_BFP), "Last step must equal 1");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_smoothstep_slope) {
+	volatile int __A_VARIABLE;
 	uint64_t prev_h, prev_delta;
 	unsigned i;
 
@@ -90,11 +95,14 @@ TEST_BEGIN(test_smoothstep_slope) {
 		prev_h = h;
 		prev_delta = delta;
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_smoothstep_integral,
 	    test_smoothstep_monotonic,
diff --git a/deps/jemalloc/test/unit/spin.c b/deps/jemalloc/test/unit/spin.c
index b965f74..debf3e4 100644
--- a/deps/jemalloc/test/unit/spin.c
+++ b/deps/jemalloc/test/unit/spin.c
@@ -3,16 +3,20 @@
 #include "jemalloc/internal/spin.h"
 
 TEST_BEGIN(test_spin) {
+	volatile int __A_VARIABLE;
 	spin_t spinner = SPIN_INITIALIZER;
 
 	for (unsigned i = 0; i < 100; i++) {
 		spin_adaptive(&spinner);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_spin);
 }
diff --git a/deps/jemalloc/test/unit/stats.c b/deps/jemalloc/test/unit/stats.c
index 231010e..76b1b97 100644
--- a/deps/jemalloc/test/unit/stats.c
+++ b/deps/jemalloc/test/unit/stats.c
@@ -1,6 +1,7 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_stats_summary) {
+	volatile int __A_VARIABLE;
 	size_t sz, allocated, active, resident, mapped;
 	int expected = config_stats ? 0 : ENOENT;
 
@@ -22,10 +23,12 @@ TEST_BEGIN(test_stats_summary) {
 		assert_zu_lt(active, mapped,
 		    "active should be less than mapped");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_stats_large) {
+	volatile int __A_VARIABLE;
 	void *p;
 	uint64_t epoch;
 	size_t allocated;
@@ -62,10 +65,12 @@ TEST_BEGIN(test_stats_large) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_stats_arenas_summary) {
+	volatile int __A_VARIABLE;
 	void *little, *large;
 	uint64_t epoch;
 	size_t sz;
@@ -124,23 +129,29 @@ TEST_BEGIN(test_stats_arenas_summary) {
 		assert_u64_le(muzzy_nmadvise, muzzy_purged,
 		    "muzzy_nmadvise should be no greater than muzzy_purged");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static void
 no_lazy_lock(void) {
+	volatile int __A_VARIABLE;
 	thd_t thd;
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_stats_arenas_small) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, allocated;
 	uint64_t epoch, nmalloc, ndalloc, nrequests;
@@ -182,10 +193,12 @@ TEST_BEGIN(test_stats_arenas_small) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_stats_arenas_large) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, allocated;
 	uint64_t epoch, nmalloc, ndalloc;
@@ -217,15 +230,19 @@ TEST_BEGIN(test_stats_arenas_large) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 gen_mallctl_str(char *cmd, char *name, unsigned arena_ind) {
+	volatile int __A_VARIABLE;
 	sprintf(cmd, "stats.arenas.%u.bins.0.%s", arena_ind, name);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_stats_arenas_bins) {
+	volatile int __A_VARIABLE;
 	void *p;
 	size_t sz, curslabs, curregs;
 	uint64_t epoch, nmalloc, ndalloc, nrequests, nfills, nflushes;
@@ -311,10 +328,12 @@ TEST_BEGIN(test_stats_arenas_bins) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_stats_arenas_lextents) {
+	volatile int __A_VARIABLE;
 	void *p;
 	uint64_t epoch, nmalloc, ndalloc;
 	size_t curlextents, sz, hsize;
@@ -352,11 +371,14 @@ TEST_BEGIN(test_stats_arenas_lextents) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_stats_summary,
 	    test_stats_large,
diff --git a/deps/jemalloc/test/unit/ticker.c b/deps/jemalloc/test/unit/ticker.c
index e5790a3..f52afdf 100644
--- a/deps/jemalloc/test/unit/ticker.c
+++ b/deps/jemalloc/test/unit/ticker.c
@@ -3,6 +3,7 @@
 #include "jemalloc/internal/ticker.h"
 
 TEST_BEGIN(test_ticker_tick) {
+	volatile int __A_VARIABLE;
 #define NREPS 2
 #define NTICKS 3
 	ticker_t ticker;
@@ -24,10 +25,12 @@ TEST_BEGIN(test_ticker_tick) {
 		    "Expected ticker reset");
 	}
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ticker_ticks) {
+	volatile int __A_VARIABLE;
 #define NTICKS 3
 	ticker_t ticker;
 
@@ -42,10 +45,12 @@ TEST_BEGIN(test_ticker_ticks) {
 	assert_true(ticker_ticks(&ticker, NTICKS + 1), "Expected ticker fire");
 	assert_u_eq(ticker_read(&ticker), NTICKS, "Unexpected ticker value");
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_ticker_copy) {
+	volatile int __A_VARIABLE;
 #define NTICKS 3
 	ticker_t ta, tb;
 
@@ -61,11 +66,14 @@ TEST_BEGIN(test_ticker_copy) {
 	assert_true(ticker_ticks(&tb, NTICKS), "Expected ticker fire");
 	assert_u_eq(ticker_read(&tb), NTICKS, "Unexpected ticker value");
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_ticker_tick,
 	    test_ticker_ticks,
diff --git a/deps/jemalloc/test/unit/tsd.c b/deps/jemalloc/test/unit/tsd.c
index 6c47913..12eb49c 100644
--- a/deps/jemalloc/test/unit/tsd.c
+++ b/deps/jemalloc/test/unit/tsd.c
@@ -4,6 +4,7 @@ static int data_cleanup_count;
 
 void
 data_cleanup(int *data) {
+	volatile int __A_VARIABLE;
 	if (data_cleanup_count == 0) {
 		assert_x_eq(*data, MALLOC_TSD_TEST_DATA_INIT,
 		    "Argument passed into cleanup function should match tsd "
@@ -26,6 +27,7 @@ data_cleanup(int *data) {
 		reincarnate = true;
 		break;
 	case 2:
+		__A_VARIABLE = 1;
 		return;
 	default:
 		not_reached();
@@ -36,10 +38,12 @@ data_cleanup(int *data) {
 		assert_ptr_not_null(p, "Unexpeced mallocx() failure");
 		dallocx(p, 0);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
 thd_start(void *arg) {
+	volatile int __A_VARIABLE;
 	int d = (int)(uintptr_t)arg;
 	void *p;
 
@@ -61,15 +65,19 @@ thd_start(void *arg) {
 	tsd_test_callback_set(tsd, &data_cleanup);
 
 	free(p);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_tsd_main_thread) {
+	volatile int __A_VARIABLE;
 	thd_start((void *)(uintptr_t)0xa5f3e329);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_tsd_sub_thread) {
+	volatile int __A_VARIABLE;
 	thd_t thd;
 
 	data_cleanup_count = 0;
@@ -81,11 +89,13 @@ TEST_BEGIN(test_tsd_sub_thread) {
 	 */
 	assert_x_ge(data_cleanup_count, 3,
 	    "Cleanup function should have executed multiple times.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void *
 thd_start_reincarnated(void *arg) {
+	volatile int __A_VARIABLE;
 	tsd_t *tsd = tsd_fetch();
 	assert(tsd);
 
@@ -114,24 +124,30 @@ thd_start_reincarnated(void *arg) {
 	assert_ptr_null(*tsd_arenap_get_unsafe(tsd),
 	    "TSD arena should have been cleared after 2nd cleanup.");
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_tsd_reincarnation) {
+	volatile int __A_VARIABLE;
 	thd_t thd;
 	thd_create(&thd, thd_start_reincarnated, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
 	/* Ensure tsd bootstrapped. */
 	if (nallocx(1, 0) == 0) {
 		malloc_printf("Initialization error");
+		__A_VARIABLE = 1;
 		return test_status_fail;
 	}
 
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_tsd_main_thread,
 	    test_tsd_sub_thread,
diff --git a/deps/jemalloc/test/unit/witness.c b/deps/jemalloc/test/unit/witness.c
index 5986da4..fd6a80d 100644
--- a/deps/jemalloc/test/unit/witness.c
+++ b/deps/jemalloc/test/unit/witness.c
@@ -13,47 +13,60 @@ static bool saw_depth_error;
 static void
 witness_lock_error_intercept(const witness_list_t *witnesses,
     const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	saw_lock_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_owner_error_intercept(const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	saw_owner_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_not_owner_error_intercept(const witness_t *witness) {
+	volatile int __A_VARIABLE;
 	saw_not_owner_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_depth_error_intercept(const witness_list_t *witnesses,
     witness_rank_t rank_inclusive, unsigned depth) {
+	volatile int __A_VARIABLE;
 	saw_depth_error = true;
+	__A_VARIABLE = 1;
 }
 
 static int
 witness_comp(const witness_t *a, void *oa, const witness_t *b, void *ob) {
+	volatile int __A_VARIABLE;
 	assert_u_eq(a->rank, b->rank, "Witnesses should have equal rank");
 
 	assert(oa == (void *)a);
 	assert(ob == (void *)b);
 
+	__A_VARIABLE = 1;
 	return strcmp(a->name, b->name);
 }
 
 static int
 witness_comp_reverse(const witness_t *a, void *oa, const witness_t *b,
     void *ob) {
+	volatile int __A_VARIABLE;
 	assert_u_eq(a->rank, b->rank, "Witnesses should have equal rank");
 
 	assert(oa == (void *)a);
 	assert(ob == (void *)b);
 
+	__A_VARIABLE = 1;
 	return -strcmp(a->name, b->name);
 }
 
 TEST_BEGIN(test_witness) {
+	volatile int __A_VARIABLE;
 	witness_t a, b;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -90,10 +103,12 @@ TEST_BEGIN(test_witness) {
 	witness_assert_lockless(&witness_tsdn);
 	witness_assert_depth(&witness_tsdn, 0);
 	witness_assert_depth_to_rank(&witness_tsdn, (witness_rank_t)1U, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_witness_comp) {
+	volatile int __A_VARIABLE;
 	witness_t a, b, c, d;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -142,10 +157,12 @@ TEST_BEGIN(test_witness_comp) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_lock_error = witness_lock_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_witness_reversal) {
+	volatile int __A_VARIABLE;
 	witness_t a, b;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -173,10 +190,12 @@ TEST_BEGIN(test_witness_reversal) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_lock_error = witness_lock_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_witness_recursive) {
+	volatile int __A_VARIABLE;
 	witness_t a;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -208,10 +227,12 @@ TEST_BEGIN(test_witness_recursive) {
 	witness_owner_error = witness_owner_error_orig;
 	witness_lock_error = witness_lock_error_orig;
 
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_witness_unlock_not_owned) {
+	volatile int __A_VARIABLE;
 	witness_t a;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -232,10 +253,12 @@ TEST_BEGIN(test_witness_unlock_not_owned) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_owner_error = witness_owner_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_witness_depth) {
+	volatile int __A_VARIABLE;
 	witness_t a;
 	witness_tsdn_t witness_tsdn = { WITNESS_TSD_INITIALIZER };
 
@@ -265,11 +288,14 @@ TEST_BEGIN(test_witness_depth) {
 	witness_assert_depth(&witness_tsdn, 0);
 
 	witness_depth_error = witness_depth_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_witness,
 	    test_witness_comp,
diff --git a/deps/jemalloc/test/unit/zero.c b/deps/jemalloc/test/unit/zero.c
index 553692b..5679c6f 100644
--- a/deps/jemalloc/test/unit/zero.c
+++ b/deps/jemalloc/test/unit/zero.c
@@ -2,6 +2,7 @@
 
 static void
 test_zero(size_t sz_min, size_t sz_max) {
+	volatile int __A_VARIABLE;
 	uint8_t *s;
 	size_t sz_prev, sz, i;
 #define MAGIC	((uint8_t)0x61)
@@ -37,22 +38,29 @@ test_zero(size_t sz_min, size_t sz_max) {
 
 	dallocx(s, 0);
 #undef MAGIC
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_zero_small) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_fill);
 	test_zero(1, SMALL_MAXCLASS-1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_zero_large) {
+	volatile int __A_VARIABLE;
 	test_skip_if(!config_fill);
 	test_zero(SMALL_MAXCLASS+1, (1U << (LG_LARGE_MINCLASS+1)));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return test(
 	    test_zero_small,
 	    test_zero_large);
diff --git a/deps/linenoise/example.c b/deps/linenoise/example.c
index 3a544d3..d2523b9 100644
--- a/deps/linenoise/example.c
+++ b/deps/linenoise/example.c
@@ -5,22 +5,28 @@
 
 
 void completion(const char *buf, linenoiseCompletions *lc) {
+    volatile int __A_VARIABLE;
     if (buf[0] == 'h') {
         linenoiseAddCompletion(lc,"hello");
         linenoiseAddCompletion(lc,"hello there");
     }
+    __A_VARIABLE = 1;
 }
 
 char *hints(const char *buf, int *color, int *bold) {
+    volatile int __A_VARIABLE;
     if (!strcasecmp(buf,"hello")) {
         *color = 35;
         *bold = 0;
+        __A_VARIABLE = 1;
         return " World";
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 int main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     char *line;
     char *prgname = argv[0];
 
@@ -70,5 +76,6 @@ int main(int argc, char **argv) {
         }
         free(line);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/linenoise/linenoise.c b/deps/linenoise/linenoise.c
index fce14a7..c06f692 100644
--- a/deps/linenoise/linenoise.c
+++ b/deps/linenoise/linenoise.c
@@ -199,23 +199,34 @@ FILE *lndebug_fp = NULL;
 
 /* Set if to use or not the multi line mode. */
 void linenoiseSetMultiLine(int ml) {
+    volatile int __A_VARIABLE;
     mlmode = ml;
+    __A_VARIABLE = 1;
 }
 
 /* Return true if the terminal name is in the list of terminals we know are
  * not able to understand basic escape sequences. */
 static int isUnsupportedTerm(void) {
+    volatile int __A_VARIABLE;
     char *term = getenv("TERM");
     int j;
 
-    if (term == NULL) return 0;
+    if (term == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     for (j = 0; unsupported_term[j]; j++)
-        if (!strcasecmp(term,unsupported_term[j])) return 1;
+        if (!strcasecmp(term,unsupported_term[j])) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Raw mode: 1960 magic shit. */
 static int enableRawMode(int fd) {
+    volatile int __A_VARIABLE;
     struct termios raw;
 
     if (!isatty(STDIN_FILENO)) goto fatal;
@@ -243,29 +254,37 @@ static int enableRawMode(int fd) {
     /* put terminal in raw mode after flushing */
     if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;
     rawmode = 1;
+    __A_VARIABLE = 1;
     return 0;
 
 fatal:
     errno = ENOTTY;
+    __A_VARIABLE = 1;
     return -1;
 }
 
 static void disableRawMode(int fd) {
+    volatile int __A_VARIABLE;
     /* Don't even check the return value as it's too late. */
     if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)
         rawmode = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Use the ESC [6n escape sequence to query the horizontal cursor position
  * and return it. On error -1 is returned, on success the position of the
  * cursor. */
 static int getCursorPosition(int ifd, int ofd) {
+    volatile int __A_VARIABLE;
     char buf[32];
     int cols, rows;
     unsigned int i = 0;
 
     /* Report cursor location */
-    if (write(ofd, "\x1b[6n", 4) != 4) return -1;
+    if (write(ofd, "\x1b[6n", 4) != 4) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Read the response: ESC [ rows ; cols R */
     while (i < sizeof(buf)-1) {
@@ -276,8 +295,15 @@ static int getCursorPosition(int ifd, int ofd) {
     buf[i] = '\0';
 
     /* Parse it. */
-    if (buf[0] != ESC || buf[1] != '[') return -1;
-    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
+    if (buf[0] != ESC || buf[1] != '[') {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return cols;
 }
 
@@ -318,27 +344,33 @@ failed:
 
 /* Clear the screen. Used to handle ctrl+l */
 void linenoiseClearScreen(void) {
+    volatile int __A_VARIABLE;
     if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
         /* nothing to do, just to avoid warning. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* Beep, used for completion when there is nothing to complete or when all
  * the choices were already shown. */
 static void linenoiseBeep(void) {
+    volatile int __A_VARIABLE;
     fprintf(stderr, "\x7");
     fflush(stderr);
+    __A_VARIABLE = 1;
 }
 
 /* ============================== Completion ================================ */
 
 /* Free a list of completion option populated by linenoiseAddCompletion(). */
 static void freeCompletions(linenoiseCompletions *lc) {
+    volatile int __A_VARIABLE;
     size_t i;
     for (i = 0; i < lc->len; i++)
         free(lc->cvec[i]);
     if (lc->cvec != NULL)
         free(lc->cvec);
+    __A_VARIABLE = 1;
 }
 
 /* This is an helper function for linenoiseEdit() and is called when the
@@ -407,19 +439,25 @@ static int completeLine(struct linenoiseState *ls) {
 
 /* Register a callback function to be called for tab-completion. */
 void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
+    volatile int __A_VARIABLE;
     completionCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* Register a hits function to be called to show hits to the user at the
  * right of the prompt. */
 void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
+    volatile int __A_VARIABLE;
     hintsCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* Register a function to free the hints returned by the hints callback
  * registered with linenoiseSetHintsCallback(). */
 void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
+    volatile int __A_VARIABLE;
     freeHintsCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* This function is used by the callback function registered by the user
@@ -427,19 +465,25 @@ void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
  * user typed <tab>. See the example.c source code for a very easy to
  * understand example. */
 void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
+    volatile int __A_VARIABLE;
     size_t len = strlen(str);
     char *copy, **cvec;
 
     copy = malloc(len+1);
-    if (copy == NULL) return;
+    if (copy == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memcpy(copy,str,len+1);
     cvec = realloc(lc->cvec,sizeof(char*)*(lc->len+1));
     if (cvec == NULL) {
         free(copy);
+        __A_VARIABLE = 1;
         return;
     }
     lc->cvec = cvec;
     lc->cvec[lc->len++] = copy;
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Line editing ================================= */
@@ -454,26 +498,36 @@ struct abuf {
 };
 
 static void abInit(struct abuf *ab) {
+    volatile int __A_VARIABLE;
     ab->b = NULL;
     ab->len = 0;
+    __A_VARIABLE = 1;
 }
 
 static void abAppend(struct abuf *ab, const char *s, int len) {
+    volatile int __A_VARIABLE;
     char *new = realloc(ab->b,ab->len+len);
 
-    if (new == NULL) return;
+    if (new == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memcpy(new+ab->len,s,len);
     ab->b = new;
     ab->len += len;
+    __A_VARIABLE = 1;
 }
 
 static void abFree(struct abuf *ab) {
+    volatile int __A_VARIABLE;
     free(ab->b);
+    __A_VARIABLE = 1;
 }
 
 /* Helper of refreshSingleLine() and refreshMultiLine() to show hints
  * to the right of the prompt. */
 void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
+    volatile int __A_VARIABLE;
     char seq[64];
     if (hintsCallback && plen+l->len < l->cols) {
         int color = -1, bold = 0;
@@ -493,6 +547,7 @@ void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
             if (freeHintsCallback) freeHintsCallback(hint);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Single line low level line refresh.
@@ -500,6 +555,7 @@ void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
  * Rewrite the currently edited line accordingly to the buffer content,
  * cursor position, and number of columns of the terminal. */
 static void refreshSingleLine(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     char seq[64];
     size_t plen = strlen(l->prompt);
     int fd = l->ofd;
@@ -534,6 +590,7 @@ static void refreshSingleLine(struct linenoiseState *l) {
     abAppend(&ab,seq,strlen(seq));
     if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
     abFree(&ab);
+    __A_VARIABLE = 1;
 }
 
 /* Multi line low level line refresh.
@@ -541,6 +598,7 @@ static void refreshSingleLine(struct linenoiseState *l) {
  * Rewrite the currently edited line accordingly to the buffer content,
  * cursor position, and number of columns of the terminal. */
 static void refreshMultiLine(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     char seq[64];
     int plen = strlen(l->prompt);
     int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */
@@ -621,15 +679,18 @@ static void refreshMultiLine(struct linenoiseState *l) {
 
     if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
     abFree(&ab);
+    __A_VARIABLE = 1;
 }
 
 /* Calls the two low level functions refreshSingleLine() or
  * refreshMultiLine() according to the selected mode. */
 static void refreshLine(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (mlmode)
         refreshMultiLine(l);
     else
         refreshSingleLine(l);
+    __A_VARIABLE = 1;
 }
 
 /* Insert the character 'c' at cursor current position.
@@ -663,34 +724,42 @@ int linenoiseEditInsert(struct linenoiseState *l, char c) {
 
 /* Move cursor on the left. */
 void linenoiseEditMoveLeft(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->pos > 0) {
         l->pos--;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor on the right. */
 void linenoiseEditMoveRight(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->pos != l->len) {
         l->pos++;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor to the start of the line. */
 void linenoiseEditMoveHome(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->pos != 0) {
         l->pos = 0;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor to the end of the line. */
 void linenoiseEditMoveEnd(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->pos != l->len) {
         l->pos = l->len;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Substitute the currently edited line with the next or previous history
@@ -722,16 +791,19 @@ void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
 /* Delete the character at the right of the cursor without altering the cursor
  * position. Basically this is what happens with the "Delete" keyboard key. */
 void linenoiseEditDelete(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->len > 0 && l->pos < l->len) {
         memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);
         l->len--;
         l->buf[l->len] = '\0';
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Backspace implementation. */
 void linenoiseEditBackspace(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     if (l->pos > 0 && l->len > 0) {
         memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
         l->pos--;
@@ -739,11 +811,13 @@ void linenoiseEditBackspace(struct linenoiseState *l) {
         l->buf[l->len] = '\0';
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Delete the previosu word, maintaining the cursor at the start of the
  * current word. */
 void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
+    volatile int __A_VARIABLE;
     size_t old_pos = l->pos;
     size_t diff;
 
@@ -755,6 +829,7 @@ void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
     memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
     l->len -= diff;
     refreshLine(l);
+    __A_VARIABLE = 1;
 }
 
 /* This function is the core of the line editing capability of linenoise.
@@ -953,11 +1028,15 @@ static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen,
  * on screen for debugging / development purposes. It is implemented
  * by the linenoise_example program using the --keycodes option. */
 void linenoisePrintKeyCodes(void) {
+    volatile int __A_VARIABLE;
     char quit[4];
 
     printf("Linenoise key codes debugging mode.\n"
             "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
-    if (enableRawMode(STDIN_FILENO) == -1) return;
+    if (enableRawMode(STDIN_FILENO) == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memset(quit,' ',4);
     while(1) {
         char c;
@@ -975,22 +1054,29 @@ void linenoisePrintKeyCodes(void) {
         fflush(stdout);
     }
     disableRawMode(STDIN_FILENO);
+    __A_VARIABLE = 1;
 }
 
 /* This function calls the line editing function linenoiseEdit() using
  * the STDIN file descriptor set in raw mode. */
 static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
+    volatile int __A_VARIABLE;
     int count;
 
     if (buflen == 0) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return -1;
     }
 
-    if (enableRawMode(STDIN_FILENO) == -1) return -1;
+    if (enableRawMode(STDIN_FILENO) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
     disableRawMode(STDIN_FILENO);
     printf("\n");
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -1067,7 +1153,9 @@ char *linenoise(const char *prompt) {
  * created with. Useful when the main program is using an alternative
  * allocator. */
 void linenoiseFree(void *ptr) {
+    volatile int __A_VARIABLE;
     free(ptr);
+    __A_VARIABLE = 1;
 }
 
 /* ================================ History ================================= */
@@ -1075,6 +1163,7 @@ void linenoiseFree(void *ptr) {
 /* Free the history, but does not reset it. Only used when we have to
  * exit() to avoid memory leaks are reported by valgrind & co. */
 static void freeHistory(void) {
+    volatile int __A_VARIABLE;
     if (history) {
         int j;
 
@@ -1082,12 +1171,15 @@ static void freeHistory(void) {
             free(history[j]);
         free(history);
     }
+    __A_VARIABLE = 1;
 }
 
 /* At exit we'll try to fix the terminal to the initial conditions. */
 static void linenoiseAtExit(void) {
+    volatile int __A_VARIABLE;
     disableRawMode(STDIN_FILENO);
     freeHistory();
+    __A_VARIABLE = 1;
 }
 
 /* This is the API call to add a new entry in the linenoise history.
@@ -1098,24 +1190,37 @@ static void linenoiseAtExit(void) {
  *
  * Using a circular buffer is smarter, but a bit more complex to handle. */
 int linenoiseHistoryAdd(const char *line) {
+    volatile int __A_VARIABLE;
     char *linecopy;
 
-    if (history_max_len == 0) return 0;
+    if (history_max_len == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Initialization on first call. */
     if (history == NULL) {
         history = malloc(sizeof(char*)*history_max_len);
-        if (history == NULL) return 0;
+        if (history == NULL) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         memset(history,0,(sizeof(char*)*history_max_len));
     }
 
     /* Don't add duplicated lines. */
-    if (history_len && !strcmp(history[history_len-1], line)) return 0;
+    if (history_len && !strcmp(history[history_len-1], line)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Add an heap allocated copy of the line in the history.
      * If we reached the max length, remove the older line. */
     linecopy = strdup(line);
-    if (!linecopy) return 0;
+    if (!linecopy) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (history_len == history_max_len) {
         free(history[0]);
         memmove(history,history+1,sizeof(char*)*(history_max_len-1));
@@ -1123,6 +1228,7 @@ int linenoiseHistoryAdd(const char *line) {
     }
     history[history_len] = linecopy;
     history_len++;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1131,14 +1237,21 @@ int linenoiseHistoryAdd(const char *line) {
  * just the latest 'len' elements if the new history length value is smaller
  * than the amount of items already inside the history. */
 int linenoiseHistorySetMaxLen(int len) {
+    volatile int __A_VARIABLE;
     char **new;
 
-    if (len < 1) return 0;
+    if (len < 1) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (history) {
         int tocopy = history_len;
 
         new = malloc(sizeof(char*)*len);
-        if (new == NULL) return 0;
+        if (new == NULL) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
 
         /* If we can't copy everything, free the elements we'll not use. */
         if (len < tocopy) {
@@ -1155,23 +1268,29 @@ int linenoiseHistorySetMaxLen(int len) {
     history_max_len = len;
     if (history_len > history_max_len)
         history_len = history_max_len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Save the history in the specified file. On success 0 is returned
  * otherwise -1 is returned. */
 int linenoiseHistorySave(const char *filename) {
+    volatile int __A_VARIABLE;
     mode_t old_umask = umask(S_IXUSR|S_IRWXG|S_IRWXO);
     FILE *fp;
     int j;
 
     fp = fopen(filename,"w");
     umask(old_umask);
-    if (fp == NULL) return -1;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     chmod(filename,S_IRUSR|S_IWUSR);
     for (j = 0; j < history_len; j++)
         fprintf(fp,"%s\n",history[j]);
     fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1181,10 +1300,14 @@ int linenoiseHistorySave(const char *filename) {
  * If the file exists and the operation succeeded 0 is returned, otherwise
  * on error -1 is returned. */
 int linenoiseHistoryLoad(const char *filename) {
+    volatile int __A_VARIABLE;
     FILE *fp = fopen(filename,"r");
     char buf[LINENOISE_MAX_LINE];
 
-    if (fp == NULL) return -1;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
         char *p;
@@ -1195,5 +1318,6 @@ int linenoiseHistoryLoad(const char *filename) {
         linenoiseHistoryAdd(buf);
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/lua/etc/min.c b/deps/lua/etc/min.c
index 6a85a4d..ee5f32c 100644
--- a/deps/lua/etc/min.c
+++ b/deps/lua/etc/min.c
@@ -11,6 +11,7 @@
 
 static int print(lua_State *L)
 {
+ volatile int __A_VARIABLE;
  int n=lua_gettop(L);
  int i;
  for (i=1; i<=n; i++)
@@ -26,14 +27,17 @@ static int print(lua_State *L)
    printf("%s:%p",luaL_typename(L,i),lua_topointer(L,i));
  }
  printf("\n");
+ __A_VARIABLE = 1;
  return 0;
 }
 
 int main(void)
 {
+ volatile int __A_VARIABLE;
  lua_State *L=lua_open();
  lua_register(L,"print",print);
  if (luaL_dofile(L,NULL)!=0) fprintf(stderr,"%s\n",lua_tostring(L,-1));
  lua_close(L);
+ __A_VARIABLE = 1;
  return 0;
 }
diff --git a/deps/lua/etc/noparser.c b/deps/lua/etc/noparser.c
index 13ba546..56dc075 100644
--- a/deps/lua/etc/noparser.c
+++ b/deps/lua/etc/noparser.c
@@ -19,15 +19,19 @@
 #include "lzio.h"
 
 LUAI_FUNC void luaX_init (lua_State *L) {
+  volatile int __A_VARIABLE;
   UNUSED(L);
+  __A_VARIABLE = 1;
 }
 
 LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
+  volatile int __A_VARIABLE;
   UNUSED(z);
   UNUSED(buff);
   UNUSED(name);
   lua_pushliteral(L,"parser not loaded");
   lua_error(L);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -35,12 +39,14 @@ LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *n
 #include "lundump.h"
 
 LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip) {
+  volatile int __A_VARIABLE;
   UNUSED(f);
   UNUSED(w);
   UNUSED(data);
   UNUSED(strip);
 #if 1
   UNUSED(L);
+  __A_VARIABLE = 1;
   return 0;
 #else
   lua_pushliteral(L,"dumper not loaded");
diff --git a/deps/lua/src/fpconv.c b/deps/lua/src/fpconv.c
index 7990831..9a8162b 100644
--- a/deps/lua/src/fpconv.c
+++ b/deps/lua/src/fpconv.c
@@ -51,6 +51,7 @@ static char locale_decimal_point = '.';
  * locale does change, at least Lua CJSON won't crash. */
 static void fpconv_update_locale()
 {
+    volatile int __A_VARIABLE;
     char buf[8];
 
     snprintf(buf, sizeof(buf), "%g", 0.5);
@@ -63,6 +64,7 @@ static void fpconv_update_locale()
     }
 
     locale_decimal_point = buf[1];
+    __A_VARIABLE = 1;
 }
 
 /* Check for a valid number character: [-+0-9a-yA-Y.]
@@ -74,18 +76,26 @@ static void fpconv_update_locale()
  * be allocated before a parse error occurs. */
 static inline int valid_number_character(char ch)
 {
+    volatile int __A_VARIABLE;
     char lower_ch;
 
-    if ('0' <= ch && ch <= '9')
+    if ('0' <= ch && ch <= '9') {
+        __A_VARIABLE = 1;
         return 1;
-    if (ch == '-' || ch == '+' || ch == '.')
+    }
+    if (ch == '-' || ch == '+' || ch == '.') {
+        __A_VARIABLE = 1;
         return 1;
+    }
 
     /* Hex digits, exponent (e), base (p), "infinity",.. */
     lower_ch = ch | 0x20;
-    if ('a' <= lower_ch && lower_ch <= 'y')
+    if ('a' <= lower_ch && lower_ch <= 'y') {
+        __A_VARIABLE = 1;
         return 1;
+    }
 
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -93,11 +103,13 @@ static inline int valid_number_character(char ch)
  * conversion. */
 static int strtod_buffer_size(const char *s)
 {
+    volatile int __A_VARIABLE;
     const char *p = s;
 
     while (valid_number_character(*p))
         p++;
 
+    __A_VARIABLE = 1;
     return p - s;
 }
 
@@ -105,19 +117,23 @@ static int strtod_buffer_size(const char *s)
  * character. Guaranteed to be called at the start of any valid number in a string */
 double fpconv_strtod(const char *nptr, char **endptr)
 {
+    volatile int __A_VARIABLE;
     char localbuf[FPCONV_G_FMT_BUFSIZE];
     char *buf, *endbuf, *dp;
     int buflen;
     double value;
 
     /* System strtod() is fine when decimal point is '.' */
-    if (locale_decimal_point == '.')
+    if (locale_decimal_point == '.') {
+        __A_VARIABLE = 1;
         return strtod(nptr, endptr);
+    }
 
     buflen = strtod_buffer_size(nptr);
     if (!buflen) {
         /* No valid characters found, standard strtod() return */
         *endptr = (char *)nptr;
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -146,12 +162,14 @@ double fpconv_strtod(const char *nptr, char **endptr)
     if (buflen >= FPCONV_G_FMT_BUFSIZE)
         free(buf);
 
+    __A_VARIABLE = 1;
     return value;
 }
 
 /* "fmt" must point to a buffer of at least 6 characters */
 static void set_number_format(char *fmt, int precision)
 {
+    volatile int __A_VARIABLE;
     int d1, d2, i;
 
     assert(1 <= precision && precision <= 14);
@@ -168,11 +186,13 @@ static void set_number_format(char *fmt, int precision)
     fmt[i++] = '0' + d2;
     fmt[i++] = 'g';
     fmt[i] = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Assumes there is always at least 32 characters available in the target buffer */
 int fpconv_g_fmt(char *str, double num, int precision)
 {
+    volatile int __A_VARIABLE;
     char buf[FPCONV_G_FMT_BUFSIZE];
     char fmt[6];
     int len;
@@ -181,8 +201,10 @@ int fpconv_g_fmt(char *str, double num, int precision)
     set_number_format(fmt, precision);
 
     /* Pass through when decimal point character is dot. */
-    if (locale_decimal_point == '.')
+    if (locale_decimal_point == '.') {
+        __A_VARIABLE = 1;
         return snprintf(str, FPCONV_G_FMT_BUFSIZE, fmt, num);
+    }
 
     /* snprintf() to a buffer then translate for other decimal point characters */
     len = snprintf(buf, FPCONV_G_FMT_BUFSIZE, fmt, num);
@@ -193,12 +215,15 @@ int fpconv_g_fmt(char *str, double num, int precision)
         *str++ = (*b == locale_decimal_point ? '.' : *b);
     } while(*b++);
 
+    __A_VARIABLE = 1;
     return len;
 }
 
 void fpconv_init()
 {
+    volatile int __A_VARIABLE;
     fpconv_update_locale();
+    __A_VARIABLE = 1;
 }
 
 /* vi:ai et sw=4 ts=4:
diff --git a/deps/lua/src/lapi.c b/deps/lua/src/lapi.c
index 5d5145d..5964617 100644
--- a/deps/lua/src/lapi.c
+++ b/deps/lua/src/lapi.c
@@ -87,12 +87,15 @@ static Table *getcurrenv (lua_State *L) {
 
 
 void luaA_pushobject (lua_State *L, const TValue *o) {
+  volatile int __A_VARIABLE;
   setobj2s(L, L->top, o);
   api_incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API int lua_checkstack (lua_State *L, int size) {
+  volatile int __A_VARIABLE;
   int res = 1;
   lua_lock(L);
   if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK)
@@ -103,13 +106,18 @@ LUA_API int lua_checkstack (lua_State *L, int size) {
       L->ci->top = L->top + size;
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
 
 LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  volatile int __A_VARIABLE;
   int i;
-  if (from == to) return;
+  if (from == to) {
+    __A_VARIABLE = 1;
+    return;
+  }
   lua_lock(to);
   api_checknelems(from, n);
   api_check(from, G(from) == G(to));
@@ -119,25 +127,31 @@ LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
     setobj2s(to, to->top++, from->top + i);
   }
   lua_unlock(to);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
+  volatile int __A_VARIABLE;
   to->nCcalls = from->nCcalls;
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  volatile int __A_VARIABLE;
   lua_CFunction old;
   lua_lock(L);
   old = G(L)->panic;
   G(L)->panic = panicf;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return old;
 }
 
 
 LUA_API lua_State *lua_newthread (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_State *L1;
   lua_lock(L);
   luaC_checkGC(L);
@@ -146,6 +160,7 @@ LUA_API lua_State *lua_newthread (lua_State *L) {
   api_incr_top(L);
   lua_unlock(L);
   luai_userstatethread(L, L1);
+  __A_VARIABLE = 1;
   return L1;
 }
 
@@ -157,11 +172,14 @@ LUA_API lua_State *lua_newthread (lua_State *L) {
 
 
 LUA_API int lua_gettop (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return cast_int(L->top - L->base);
 }
 
 
 LUA_API void lua_settop (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   if (idx >= 0) {
     api_check(L, idx <= L->stack_last - L->base);
@@ -174,10 +192,12 @@ LUA_API void lua_settop (lua_State *L, int idx) {
     L->top += idx+1;  /* `subtract' index (index is negative) */
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_remove (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId p;
   lua_lock(L);
   p = index2adr(L, idx);
@@ -185,10 +205,12 @@ LUA_API void lua_remove (lua_State *L, int idx) {
   while (++p < L->top) setobjs2s(L, p-1, p);
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_insert (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId p;
   StkId q;
   lua_lock(L);
@@ -197,10 +219,12 @@ LUA_API void lua_insert (lua_State *L, int idx) {
   for (q = L->top; q>p; q--) setobjs2s(L, q, q-1);
   setobjs2s(L, p, L->top);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_replace (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o;
   lua_lock(L);
   /* explicit test for incompatible code */
@@ -222,14 +246,17 @@ LUA_API void lua_replace (lua_State *L, int idx) {
   }
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setobj2s(L, L->top, index2adr(L, idx));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -240,51 +267,66 @@ LUA_API void lua_pushvalue (lua_State *L, int idx) {
 
 
 LUA_API int lua_type (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);
 }
 
 
 LUA_API const char *lua_typename (lua_State *L, int t) {
+  volatile int __A_VARIABLE;
   UNUSED(L);
+  __A_VARIABLE = 1;
   return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
 }
 
 
 LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return iscfunction(o);
 }
 
 
 LUA_API int lua_isnumber (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   TValue n;
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return tonumber(o, &n);
 }
 
 
 LUA_API int lua_isstring (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   int t = lua_type(L, idx);
+  __A_VARIABLE = 1;
   return (t == LUA_TSTRING || t == LUA_TNUMBER);
 }
 
 
 LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (ttisuserdata(o) || ttislightuserdata(o));
 }
 
 
 LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  volatile int __A_VARIABLE;
   StkId o1 = index2adr(L, index1);
   StkId o2 = index2adr(L, index2);
+  __A_VARIABLE = 1;
   return (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
          : luaO_rawequalObj(o1, o2);
 }
 
 
 LUA_API int lua_equal (lua_State *L, int index1, int index2) {
+  volatile int __A_VARIABLE;
   StkId o1, o2;
   int i;
   lua_lock(L);  /* may call tag method */
@@ -292,11 +334,13 @@ LUA_API int lua_equal (lua_State *L, int index1, int index2) {
   o2 = index2adr(L, index2);
   i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0 : equalobj(L, o1, o2);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return i;
 }
 
 
 LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
+  volatile int __A_VARIABLE;
   StkId o1, o2;
   int i;
   lua_lock(L);  /* may call tag method */
@@ -305,6 +349,7 @@ LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
   i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
        : luaV_lessthan(L, o1, o2);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -335,18 +380,22 @@ LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {
 
 
 LUA_API int lua_toboolean (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return !l_isfalse(o);
 }
 
 
 LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
   if (!ttisstring(o)) {
     lua_lock(L);  /* `luaV_tostring' may create a new string */
     if (!luaV_tostring(L, o)) {  /* conversion failed? */
       if (len != NULL) *len = 0;
       lua_unlock(L);
+      __A_VARIABLE = 1;
       return NULL;
     }
     luaC_checkGC(L);
@@ -354,60 +403,81 @@ LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
     lua_unlock(L);
   }
   if (len != NULL) *len = tsvalue(o)->len;
+  __A_VARIABLE = 1;
   return svalue(o);
 }
 
 
 LUA_API size_t lua_objlen (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TSTRING: return tsvalue(o)->len;
-    case LUA_TUSERDATA: return uvalue(o)->len;
-    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    case LUA_TSTRING: __A_VARIABLE = 1;
+    return tsvalue(o)->len;
+    case LUA_TUSERDATA: __A_VARIABLE = 1;
+    return uvalue(o)->len;
+    case LUA_TTABLE: __A_VARIABLE = 1;
+    return luaH_getn(hvalue(o));
     case LUA_TNUMBER: {
       size_t l;
       lua_lock(L);  /* `luaV_tostring' may create a new string */
       l = (luaV_tostring(L, o) ? tsvalue(o)->len : 0);
       lua_unlock(L);
+      __A_VARIABLE = 1;
       return l;
     }
-    default: return 0;
+    default: __A_VARIABLE = 1;
+    return 0;
   }
 }
 
 
 LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (!iscfunction(o)) ? NULL : clvalue(o)->c.f;
 }
 
 
 LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
-    case LUA_TLIGHTUSERDATA: return pvalue(o);
-    default: return NULL;
+    case LUA_TUSERDATA: __A_VARIABLE = 1;
+      return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: __A_VARIABLE = 1;
+      return pvalue(o);
+    default: __A_VARIABLE = 1;
+    return NULL;
   }
 }
 
 
 LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (!ttisthread(o)) ? NULL : thvalue(o);
 }
 
 
 LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TTABLE: return hvalue(o);
-    case LUA_TFUNCTION: return clvalue(o);
-    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TTABLE: __A_VARIABLE = 1;
+      return hvalue(o);
+    case LUA_TFUNCTION: __A_VARIABLE = 1;
+      return clvalue(o);
+    case LUA_TTHREAD: __A_VARIABLE = 1;
+      return thvalue(o);
     case LUA_TUSERDATA:
     case LUA_TLIGHTUSERDATA:
+      __A_VARIABLE = 1;
       return lua_touserdata(L, idx);
-    default: return NULL;
+    default: __A_VARIABLE = 1;
+      return NULL;
   }
 }
 
@@ -419,58 +489,71 @@ LUA_API const void *lua_topointer (lua_State *L, int idx) {
 
 
 LUA_API void lua_pushnil (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setnilvalue(L->top);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setnvalue(L->top, n);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setnvalue(L->top, cast_num(n));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   luaC_checkGC(L);
   setsvalue2s(L, L->top, luaS_newlstr(L, s, len));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushstring (lua_State *L, const char *s) {
+  volatile int __A_VARIABLE;
   if (s == NULL)
     lua_pushnil(L);
   else
     lua_pushlstring(L, s, strlen(s));
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
                                       va_list argp) {
+  volatile int __A_VARIABLE;
   const char *ret;
   lua_lock(L);
   luaC_checkGC(L);
   ret = luaO_pushvfstring(L, fmt, argp);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return ret;
 }
 
 
 LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  volatile int __A_VARIABLE;
   const char *ret;
   va_list argp;
   lua_lock(L);
@@ -479,11 +562,13 @@ LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
   ret = luaO_pushvfstring(L, fmt, argp);
   va_end(argp);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return ret;
 }
 
 
 LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  volatile int __A_VARIABLE;
   Closure *cl;
   lua_lock(L);
   luaC_checkGC(L);
@@ -497,30 +582,37 @@ LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
   lua_assert(iswhite(obj2gco(cl)));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushboolean (lua_State *L, int b) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setpvalue(L->top, p);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API int lua_pushthread (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   setthvalue(L, L->top, L);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return (G(L)->mainthread == L);
 }
 
@@ -532,16 +624,19 @@ LUA_API int lua_pushthread (lua_State *L) {
 
 
 LUA_API void lua_gettable (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId t;
   lua_lock(L);
   t = index2adr(L, idx);
   api_checkvalidindex(L, t);
   luaV_gettable(L, t, L->top - 1, L->top - 1);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+  volatile int __A_VARIABLE;
   StkId t;
   TValue key;
   lua_lock(L);
@@ -551,20 +646,24 @@ LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
   luaV_gettable(L, t, &key, L->top);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_rawget (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId t;
   lua_lock(L);
   t = index2adr(L, idx);
   api_check(L, ttistable(t));
   setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  volatile int __A_VARIABLE;
   StkId o;
   lua_lock(L);
   o = index2adr(L, idx);
@@ -572,19 +671,23 @@ LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
   setobj2s(L, L->top, luaH_getnum(hvalue(o), n));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   luaC_checkGC(L);
   sethvalue(L, L->top, luaH_new(L, narray, nrec));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  volatile int __A_VARIABLE;
   const TValue *obj;
   Table *mt = NULL;
   int res;
@@ -609,11 +712,13 @@ LUA_API int lua_getmetatable (lua_State *L, int objindex) {
     res = 1;
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
 
 LUA_API void lua_getfenv (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o;
   lua_lock(L);
   o = index2adr(L, idx);
@@ -634,6 +739,7 @@ LUA_API void lua_getfenv (lua_State *L, int idx) {
   }
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -643,6 +749,7 @@ LUA_API void lua_getfenv (lua_State *L, int idx) {
 
 
 LUA_API void lua_settable (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId t;
   lua_lock(L);
   api_checknelems(L, 2);
@@ -651,10 +758,12 @@ LUA_API void lua_settable (lua_State *L, int idx) {
   luaV_settable(L, t, L->top - 2, L->top - 1);
   L->top -= 2;  /* pop index and value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
+  volatile int __A_VARIABLE;
   StkId t;
   TValue key;
   lua_lock(L);
@@ -665,10 +774,12 @@ LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
   luaV_settable(L, t, &key, L->top - 1);
   L->top--;  /* pop value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_rawset (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId t;
   lua_lock(L);
   api_checknelems(L, 2);
@@ -678,10 +789,12 @@ LUA_API void lua_rawset (lua_State *L, int idx) {
   luaC_barriert(L, hvalue(t), L->top-1);
   L->top -= 2;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  volatile int __A_VARIABLE;
   StkId o;
   lua_lock(L);
   api_checknelems(L, 1);
@@ -691,10 +804,12 @@ LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
   luaC_barriert(L, hvalue(o), L->top-1);
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  volatile int __A_VARIABLE;
   TValue *obj;
   Table *mt;
   lua_lock(L);
@@ -727,11 +842,13 @@ LUA_API int lua_setmetatable (lua_State *L, int objindex) {
   }
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 LUA_API int lua_setfenv (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId o;
   int res = 1;
   lua_lock(L);
@@ -756,6 +873,7 @@ LUA_API int lua_setfenv (lua_State *L, int idx) {
   if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -774,6 +892,7 @@ LUA_API int lua_setfenv (lua_State *L, int idx) {
 	
 
 LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
+  volatile int __A_VARIABLE;
   StkId func;
   lua_lock(L);
   api_checknelems(L, nargs+1);
@@ -782,6 +901,7 @@ LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
   luaD_call(L, func, nresults);
   adjustresults(L, nresults);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -796,13 +916,16 @@ struct CallS {  /* data to `f_call' */
 
 
 static void f_call (lua_State *L, void *ud) {
+  volatile int __A_VARIABLE;
   struct CallS *c = cast(struct CallS *, ud);
   luaD_call(L, c->func, c->nresults);
+  __A_VARIABLE = 1;
 }
 
 
 
 LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  volatile int __A_VARIABLE;
   struct CallS c;
   int status;
   ptrdiff_t func;
@@ -821,6 +944,7 @@ LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
   status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
   adjustresults(L, nresults);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -835,6 +959,7 @@ struct CCallS {  /* data to `f_Ccall' */
 
 
 static void f_Ccall (lua_State *L, void *ud) {
+  volatile int __A_VARIABLE;
   struct CCallS *c = cast(struct CCallS *, ud);
   Closure *cl;
   cl = luaF_newCclosure(L, 0, getcurrenv(L));
@@ -844,10 +969,12 @@ static void f_Ccall (lua_State *L, void *ud) {
   setpvalue(L->top, c->ud);  /* push only argument */
   api_incr_top(L);
   luaD_call(L, L->top - 2, 0);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
+  volatile int __A_VARIABLE;
   struct CCallS c;
   int status;
   lua_lock(L);
@@ -855,12 +982,14 @@ LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
   c.ud = ud;
   status = luaD_pcall(L, f_Ccall, &c, savestack(L, L->top), 0);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
                       const char *chunkname) {
+  volatile int __A_VARIABLE;
   ZIO z;
   int status;
   lua_lock(L);
@@ -868,11 +997,13 @@ LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
   luaZ_init(L, &z, reader, data);
   status = luaD_protectedparser(L, &z, chunkname);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+  volatile int __A_VARIABLE;
   int status;
   TValue *o;
   lua_lock(L);
@@ -883,11 +1014,14 @@ LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
   else
     status = 1;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int  lua_status (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return L->status;
 }
 
@@ -897,6 +1031,7 @@ LUA_API int  lua_status (lua_State *L) {
 */
 
 LUA_API int lua_gc (lua_State *L, int what, int data) {
+  volatile int __A_VARIABLE;
   int res = 0;
   global_State *g;
   lua_lock(L);
@@ -951,6 +1086,7 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
     default: res = -1;  /* invalid option */
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -962,15 +1098,18 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
 
 
 LUA_API int lua_error (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   api_checknelems(L, 1);
   luaG_errormsg(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return 0;  /* to avoid warnings */
 }
 
 
 LUA_API int lua_next (lua_State *L, int idx) {
+  volatile int __A_VARIABLE;
   StkId t;
   int more;
   lua_lock(L);
@@ -983,11 +1122,13 @@ LUA_API int lua_next (lua_State *L, int idx) {
   else  /* no more elements */
     L->top -= 1;  /* remove key */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return more;
 }
 
 
 LUA_API void lua_concat (lua_State *L, int n) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   api_checknelems(L, n);
   if (n >= 2) {
@@ -1001,28 +1142,34 @@ LUA_API void lua_concat (lua_State *L, int n) {
   }
   /* else n == 1; nothing to do */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
+  volatile int __A_VARIABLE;
   lua_Alloc f;
   lua_lock(L);
   if (ud) *ud = G(L)->ud;
   f = G(L)->frealloc;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return f;
 }
 
 
 LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
+  volatile int __A_VARIABLE;
   lua_lock(L);
   G(L)->ud = ud;
   G(L)->frealloc = f;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  volatile int __A_VARIABLE;
   Udata *u;
   lua_lock(L);
   luaC_checkGC(L);
@@ -1030,6 +1177,7 @@ LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
   setuvalue(L, L->top, u);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return u + 1;
 }
 
@@ -1055,6 +1203,7 @@ static const char *aux_upvalue (StkId fi, int n, TValue **val) {
 
 
 LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  volatile int __A_VARIABLE;
   const char *name;
   TValue *val;
   lua_lock(L);
@@ -1064,11 +1213,13 @@ LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
     api_incr_top(L);
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
 
 LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  volatile int __A_VARIABLE;
   const char *name;
   TValue *val;
   StkId fi;
@@ -1082,6 +1233,7 @@ LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
     luaC_barrier(L, clvalue(fi), L->top);
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
diff --git a/deps/lua/src/lauxlib.c b/deps/lua/src/lauxlib.c
index 10f14e2..90524a8 100644
--- a/deps/lua/src/lauxlib.c
+++ b/deps/lua/src/lauxlib.c
@@ -41,55 +41,70 @@
 
 
 LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  volatile int __A_VARIABLE;
   lua_Debug ar;
-  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */ {
+    __A_VARIABLE = 1;
     return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  }
   lua_getinfo(L, "n", &ar);
   if (strcmp(ar.namewhat, "method") == 0) {
     narg--;  /* do not count `self' */
-    if (narg == 0)  /* error is in the self argument itself? */
+    if (narg == 0)  /* error is in the self argument itself? */ {
+      __A_VARIABLE = 1;
       return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
                            ar.name, extramsg);
+    }
   }
   if (ar.name == NULL)
     ar.name = "?";
+  __A_VARIABLE = 1;
   return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
                         narg, ar.name, extramsg);
 }
 
 
 LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
+  volatile int __A_VARIABLE;
   const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                     tname, luaL_typename(L, narg));
+  __A_VARIABLE = 1;
   return luaL_argerror(L, narg, msg);
 }
 
 
 static void tag_error (lua_State *L, int narg, int tag) {
+  volatile int __A_VARIABLE;
   luaL_typerror(L, narg, lua_typename(L, tag));
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_where (lua_State *L, int level) {
+  volatile int __A_VARIABLE;
   lua_Debug ar;
   if (lua_getstack(L, level, &ar)) {  /* check function at level */
     lua_getinfo(L, "Sl", &ar);  /* get info about it */
     if (ar.currentline > 0) {  /* is there info? */
       lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      __A_VARIABLE = 1;
       return;
     }
   }
   lua_pushliteral(L, "");  /* else, no information available... */
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  volatile int __A_VARIABLE;
   va_list argp;
   va_start(argp, fmt);
   luaL_where(L, 1);
   lua_pushvfstring(L, fmt, argp);
   va_end(argp);
   lua_concat(L, 2);
+  __A_VARIABLE = 1;
   return lua_error(L);
 }
 
@@ -98,66 +113,85 @@ LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
 
 LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
                                  const char *const lst[]) {
+  volatile int __A_VARIABLE;
   const char *name = (def) ? luaL_optstring(L, narg, def) :
                              luaL_checkstring(L, narg);
   int i;
   for (i=0; lst[i]; i++)
-    if (strcmp(lst[i], name) == 0)
+    if (strcmp(lst[i], name) == 0) {
+      __A_VARIABLE = 1;
       return i;
+    }
+  __A_VARIABLE = 1;
   return luaL_argerror(L, narg,
                        lua_pushfstring(L, "invalid option " LUA_QS, name));
 }
 
 
 LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  volatile int __A_VARIABLE;
   lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get registry.name */
-  if (!lua_isnil(L, -1))  /* name already in use? */
-    return 0;  /* leave previous value on top, but return 0 */
+  if (!lua_isnil(L, -1))  /* name already in use? */ {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* leave previous value on top, but return 0 */
   lua_pop(L, 1);
   lua_newtable(L);  /* create metatable */
   lua_pushvalue(L, -1);
   lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  volatile int __A_VARIABLE;
   void *p = lua_touserdata(L, ud);
   if (p != NULL) {  /* value is a userdata? */
     if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
       lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */
       if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
         lua_pop(L, 2);  /* remove both metatables */
+        __A_VARIABLE = 1;
         return p;
       }
     }
   }
   luaL_typerror(L, ud, tname);  /* else error */
+  __A_VARIABLE = 1;
   return NULL;  /* to avoid warnings */
 }
 
 
 LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
+  volatile int __A_VARIABLE;
   if (!lua_checkstack(L, space))
     luaL_error(L, "stack overflow (%s)", mes);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  volatile int __A_VARIABLE;
   if (lua_type(L, narg) != t)
     tag_error(L, narg, t);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  volatile int __A_VARIABLE;
   if (lua_type(L, narg) == LUA_TNONE)
     luaL_argerror(L, narg, "value expected");
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  volatile int __A_VARIABLE;
   const char *s = lua_tolstring(L, narg, len);
   if (!s) tag_error(L, narg, LUA_TSTRING);
+  __A_VARIABLE = 1;
   return s;
 }
 
@@ -174,28 +208,36 @@ LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
 
 
 LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  volatile int __A_VARIABLE;
   lua_Number d = lua_tonumber(L, narg);
   if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
     tag_error(L, narg, LUA_TNUMBER);
+  __A_VARIABLE = 1;
   return d;
 }
 
 
 LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return luaL_opt(L, luaL_checknumber, narg, def);
 }
 
 
 LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
+  volatile int __A_VARIABLE;
   lua_Integer d = lua_tointeger(L, narg);
   if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
     tag_error(L, narg, LUA_TNUMBER);
+  __A_VARIABLE = 1;
   return d;
 }
 
 
 LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
                                                       lua_Integer def) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return luaL_opt(L, luaL_checkinteger, narg, def);
 }
 
@@ -217,11 +259,15 @@ LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
 
 
 LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  volatile int __A_VARIABLE;
   obj = abs_index(L, obj);
-  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */ {
+    __A_VARIABLE = 1;
     return 0;
+  }
   lua_pushvalue(L, obj);
   lua_call(L, 1, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -233,14 +279,17 @@ LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
 
 
 static int libsize (const luaL_Reg *l) {
+  volatile int __A_VARIABLE;
   int size = 0;
   for (; l->name; l++) size++;
+  __A_VARIABLE = 1;
   return size;
 }
 
 
 LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
                               const luaL_Reg *l, int nup) {
+  volatile int __A_VARIABLE;
   if (libname) {
     int size = libsize(l);
     /* check whether lib already exists */
@@ -265,6 +314,7 @@ LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
     lua_setfield(L, -(nup+2), l->name);
   }
   lua_pop(L, nup);  /* remove upvalues */
+  __A_VARIABLE = 1;
 }
 
 
@@ -278,13 +328,16 @@ LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
 #if defined(LUA_COMPAT_GETN)
 
 static int checkint (lua_State *L, int topop) {
+  volatile int __A_VARIABLE;
   int n = (lua_type(L, -1) == LUA_TNUMBER) ? lua_tointeger(L, -1) : -1;
   lua_pop(L, topop);
+  __A_VARIABLE = 1;
   return n;
 }
 
 
 static void getsizes (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_getfield(L, LUA_REGISTRYINDEX, "LUA_SIZES");
   if (lua_isnil(L, -1)) {  /* no `size' table? */
     lua_pop(L, 1);  /* remove nil */
@@ -296,10 +349,12 @@ static void getsizes (lua_State *L) {
     lua_pushvalue(L, -1);
     lua_setfield(L, LUA_REGISTRYINDEX, "LUA_SIZES");  /* store in register */
   }
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_setn (lua_State *L, int t, int n) {
+  volatile int __A_VARIABLE;
   t = abs_index(L, t);
   lua_pushliteral(L, "n");
   lua_rawget(L, t);
@@ -315,19 +370,28 @@ LUALIB_API void luaL_setn (lua_State *L, int t, int n) {
     lua_rawset(L, -3);  /* sizes[t] = n */
     lua_pop(L, 1);  /* remove `sizes' */
   }
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API int luaL_getn (lua_State *L, int t) {
+  volatile int __A_VARIABLE;
   int n;
   t = abs_index(L, t);
   lua_pushliteral(L, "n");  /* try t.n */
   lua_rawget(L, t);
-  if ((n = checkint(L, 1)) >= 0) return n;
+  if ((n = checkint(L, 1)) >= 0) {
+    __A_VARIABLE = 1;
+    return n;
+  }
   getsizes(L);  /* else try sizes[t] */
   lua_pushvalue(L, t);
   lua_rawget(L, -2);
-  if ((n = checkint(L, 2)) >= 0) return n;
+  if ((n = checkint(L, 2)) >= 0) {
+    __A_VARIABLE = 1;
+    return n;
+  }
+  __A_VARIABLE = 1;
   return (int)lua_objlen(L, t);
 }
 
@@ -339,6 +403,7 @@ LUALIB_API int luaL_getn (lua_State *L, int t) {
 
 LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
                                                                const char *r) {
+  volatile int __A_VARIABLE;
   const char *wild;
   size_t l = strlen(p);
   luaL_Buffer b;
@@ -350,6 +415,7 @@ LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
   }
   luaL_addstring(&b, s);  /* push last suffix */
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return lua_tostring(L, -1);
 }
 
@@ -408,6 +474,7 @@ static int emptybuffer (luaL_Buffer *B) {
 
 
 static void adjuststack (luaL_Buffer *B) {
+  volatile int __A_VARIABLE;
   if (B->lvl > 1) {
     lua_State *L = B->L;
     int toget = 1;  /* number of levels to concat */
@@ -423,35 +490,45 @@ static void adjuststack (luaL_Buffer *B) {
     lua_concat(L, toget);
     B->lvl = B->lvl - toget + 1;
   }
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
+  volatile int __A_VARIABLE;
   if (emptybuffer(B))
     adjuststack(B);
+  __A_VARIABLE = 1;
   return B->buffer;
 }
 
 
 LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  volatile int __A_VARIABLE;
   while (l--)
     luaL_addchar(B, *s++);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  volatile int __A_VARIABLE;
   luaL_addlstring(B, s, strlen(s));
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  volatile int __A_VARIABLE;
   emptybuffer(B);
   lua_concat(B->L, B->lvl);
   B->lvl = 1;
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  volatile int __A_VARIABLE;
   lua_State *L = B->L;
   size_t vl;
   const char *s = lua_tolstring(L, -1, &vl);
@@ -466,23 +543,28 @@ LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
     B->lvl++;  /* add new value into B stack */
     adjuststack(B);
   }
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  volatile int __A_VARIABLE;
   B->L = L;
   B->p = B->buffer;
   B->lvl = 0;
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================== */
 
 
 LUALIB_API int luaL_ref (lua_State *L, int t) {
+  volatile int __A_VARIABLE;
   int ref;
   t = abs_index(L, t);
   if (lua_isnil(L, -1)) {
     lua_pop(L, 1);  /* remove from stack */
+    __A_VARIABLE = 1;
     return LUA_REFNIL;  /* `nil' has a unique fixed reference */
   }
   lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
@@ -497,11 +579,13 @@ LUALIB_API int luaL_ref (lua_State *L, int t) {
     ref++;  /* create new reference */
   }
   lua_rawseti(L, t, ref);
+  __A_VARIABLE = 1;
   return ref;
 }
 
 
 LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  volatile int __A_VARIABLE;
   if (ref >= 0) {
     t = abs_index(L, t);
     lua_rawgeti(L, t, FREELIST_REF);
@@ -509,6 +593,7 @@ LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
     lua_pushinteger(L, ref);
     lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -527,24 +612,32 @@ typedef struct LoadF {
 
 
 static const char *getF (lua_State *L, void *ud, size_t *size) {
+  volatile int __A_VARIABLE;
   LoadF *lf = (LoadF *)ud;
   (void)L;
   if (lf->extraline) {
     lf->extraline = 0;
     *size = 1;
+    __A_VARIABLE = 1;
     return "\n";
   }
-  if (feof(lf->f)) return NULL;
+  if (feof(lf->f)) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);
+  __A_VARIABLE = 1;
   return (*size > 0) ? lf->buff : NULL;
 }
 
 
 static int errfile (lua_State *L, const char *what, int fnameindex) {
+  volatile int __A_VARIABLE;
   const char *serr = strerror(errno);
   const char *filename = lua_tostring(L, fnameindex) + 1;
   lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
   lua_remove(L, fnameindex);
+  __A_VARIABLE = 1;
   return LUA_ERRFILE;
 }
 
@@ -597,20 +690,27 @@ typedef struct LoadS {
 
 
 static const char *getS (lua_State *L, void *ud, size_t *size) {
+  volatile int __A_VARIABLE;
   LoadS *ls = (LoadS *)ud;
   (void)L;
-  if (ls->size == 0) return NULL;
+  if (ls->size == 0) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   *size = ls->size;
   ls->size = 0;
+  __A_VARIABLE = 1;
   return ls->s;
 }
 
 
 LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
                                 const char *name) {
+  volatile int __A_VARIABLE;
   LoadS ls;
   ls.s = buff;
   ls.size = size;
+  __A_VARIABLE = 1;
   return lua_load(L, getS, &ls, name);
 }
 
@@ -637,16 +737,20 @@ static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
 
 
 static int panic (lua_State *L) {
+  volatile int __A_VARIABLE;
   (void)L;  /* to avoid warnings */
   fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
                    lua_tostring(L, -1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 LUALIB_API lua_State *luaL_newstate (void) {
+  volatile int __A_VARIABLE;
   lua_State *L = lua_newstate(l_alloc, NULL);
   if (L) lua_atpanic(L, &panic);
+  __A_VARIABLE = 1;
   return L;
 }
 
diff --git a/deps/lua/src/lbaselib.c b/deps/lua/src/lbaselib.c
index 2ab550b..001e117 100644
--- a/deps/lua/src/lbaselib.c
+++ b/deps/lua/src/lbaselib.c
@@ -29,6 +29,7 @@
 ** (a console window or a log file, for instance).
 */
 static int luaB_print (lua_State *L) {
+  volatile int __A_VARIABLE;
   int n = lua_gettop(L);  /* number of arguments */
   int i;
   lua_getglobal(L, "tostring");
@@ -38,14 +39,17 @@ static int luaB_print (lua_State *L) {
     lua_pushvalue(L, i);   /* value to print */
     lua_call(L, 1, 1);
     s = lua_tostring(L, -1);  /* get result */
-    if (s == NULL)
+    if (s == NULL) {
+      __A_VARIABLE = 1;
       return luaL_error(L, LUA_QL("tostring") " must return a string to "
                            LUA_QL("print"));
+    }
     if (i>1) fputs("\t", stdout);
     fputs(s, stdout);
     lua_pop(L, 1);  /* pop result */
   }
   fputs("\n", stdout);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -79,6 +83,7 @@ static int luaB_tonumber (lua_State *L) {
 
 
 static int luaB_error (lua_State *L) {
+  volatile int __A_VARIABLE;
   int level = luaL_optint(L, 2, 1);
   lua_settop(L, 1);
   if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
@@ -86,22 +91,27 @@ static int luaB_error (lua_State *L) {
     lua_pushvalue(L, 1);
     lua_concat(L, 2);
   }
+  __A_VARIABLE = 1;
   return lua_error(L);
 }
 
 
 static int luaB_getmetatable (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
   if (!lua_getmetatable(L, 1)) {
     lua_pushnil(L);
+    __A_VARIABLE = 1;
     return 1;  /* no metatable */
   }
   luaL_getmetafield(L, 1, "__metatable");
+  __A_VARIABLE = 1;
   return 1;  /* returns either __metatable field (if present) or metatable */
 }
 
 
 static int luaB_setmetatable (lua_State *L) {
+  volatile int __A_VARIABLE;
   int t = lua_type(L, 2);
   luaL_checktype(L, 1, LUA_TTABLE);
   luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
@@ -110,11 +120,13 @@ static int luaB_setmetatable (lua_State *L) {
     luaL_error(L, "cannot change a protected metatable");
   lua_settop(L, 2);
   lua_setmetatable(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static void getfunc (lua_State *L, int opt) {
+  volatile int __A_VARIABLE;
   if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
   else {
     lua_Debug ar;
@@ -127,15 +139,18 @@ static void getfunc (lua_State *L, int opt) {
       luaL_error(L, "no function environment for tail call at level %d",
                     level);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int luaB_getfenv (lua_State *L) {
+  volatile int __A_VARIABLE;
   getfunc(L, 1);
   if (lua_iscfunction(L, -1))  /* is a C function? */
     lua_pushvalue(L, LUA_GLOBALSINDEX);  /* return the thread's global env. */
   else
     lua_getfenv(L, -1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -159,38 +174,47 @@ static int luaB_setfenv (lua_State *L) {
 
 
 static int luaB_rawequal (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
   luaL_checkany(L, 2);
   lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_rawget (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   luaL_checkany(L, 2);
   lua_settop(L, 2);
   lua_rawget(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int luaB_rawset (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   luaL_checkany(L, 2);
   luaL_checkany(L, 3);
   lua_settop(L, 3);
   lua_rawset(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_gcinfo (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushinteger(L, lua_getgccount(L));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_collectgarbage (lua_State *L) {
+  volatile int __A_VARIABLE;
   static const char *const opts[] = {"stop", "restart", "collect",
     "count", "step", "setpause", "setstepmul", NULL};
   static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
@@ -202,14 +226,17 @@ static int luaB_collectgarbage (lua_State *L) {
     case LUA_GCCOUNT: {
       int b = lua_gc(L, LUA_GCCOUNTB, 0);
       lua_pushnumber(L, res + ((lua_Number)b/1024));
+      __A_VARIABLE = 1;
       return 1;
     }
     case LUA_GCSTEP: {
       lua_pushboolean(L, res);
+      __A_VARIABLE = 1;
       return 1;
     }
     default: {
       lua_pushnumber(L, res);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
@@ -217,8 +244,10 @@ static int luaB_collectgarbage (lua_State *L) {
 
 
 static int luaB_type (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
   lua_pushstring(L, luaL_typename(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -236,29 +265,35 @@ static int luaB_next (lua_State *L) {
 
 
 static int luaB_pairs (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
   lua_pushvalue(L, 1);  /* state, */
   lua_pushnil(L);  /* and initial value */
+  __A_VARIABLE = 1;
   return 3;
 }
 
 
 static int ipairsaux (lua_State *L) {
+  volatile int __A_VARIABLE;
   int i = luaL_checkint(L, 2);
   luaL_checktype(L, 1, LUA_TTABLE);
   i++;  /* next value */
   lua_pushinteger(L, i);
   lua_rawgeti(L, 1, i);
+  __A_VARIABLE = 1;
   return (lua_isnil(L, -1)) ? 0 : 2;
 }
 
 
 static int luaB_ipairs (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
   lua_pushvalue(L, 1);  /* state, */
   lua_pushinteger(L, 0);  /* and initial value */
+  __A_VARIABLE = 1;
   return 3;
 }
 
@@ -275,15 +310,19 @@ static int load_aux (lua_State *L, int status) {
 
 
 static int luaB_loadstring (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
   const char *chunkname = luaL_optstring(L, 2, s);
+  __A_VARIABLE = 1;
   return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
 }
 
 
 static int luaB_loadfile (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *fname = luaL_optstring(L, 1, NULL);
+  __A_VARIABLE = 1;
   return load_aux(L, luaL_loadfile(L, fname));
 }
 
@@ -313,44 +352,59 @@ static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
 
 
 static int luaB_load (lua_State *L) {
+  volatile int __A_VARIABLE;
   int status;
   const char *cname = luaL_optstring(L, 2, "=(load)");
   luaL_checktype(L, 1, LUA_TFUNCTION);
   lua_settop(L, 3);  /* function, eventual name, plus one reserved slot */
   status = lua_load(L, generic_reader, NULL, cname);
+  __A_VARIABLE = 1;
   return load_aux(L, status);
 }
 
 
 static int luaB_dofile (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *fname = luaL_optstring(L, 1, NULL);
   int n = lua_gettop(L);
   if (luaL_loadfile(L, fname) != 0) lua_error(L);
   lua_call(L, 0, LUA_MULTRET);
+  __A_VARIABLE = 1;
   return lua_gettop(L) - n;
 }
 
 
 static int luaB_assert (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
-  if (!lua_toboolean(L, 1))
+  if (!lua_toboolean(L, 1)) {
+    __A_VARIABLE = 1;
     return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  }
+  __A_VARIABLE = 1;
   return lua_gettop(L);
 }
 
 
 static int luaB_unpack (lua_State *L) {
+  volatile int __A_VARIABLE;
   int i, e, n;
   luaL_checktype(L, 1, LUA_TTABLE);
   i = luaL_optint(L, 2, 1);
   e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
-  if (i > e) return 0;  /* empty range */
+  if (i > e) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* empty range */
   n = e - i + 1;  /* number of elements */
-  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */ {
+    __A_VARIABLE = 1;
     return luaL_error(L, "too many results to unpack");
+  }
   lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
   while (i++ < e)  /* push arg[i + 1...e] */
     lua_rawgeti(L, 1, i);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -372,16 +426,19 @@ static int luaB_select (lua_State *L) {
 
 
 static int luaB_pcall (lua_State *L) {
+  volatile int __A_VARIABLE;
   int status;
   luaL_checkany(L, 1);
   status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
   lua_pushboolean(L, (status == 0));
   lua_insert(L, 1);
+  __A_VARIABLE = 1;
   return lua_gettop(L);  /* return status + all results */
 }
 
 
 static int luaB_xpcall (lua_State *L) {
+  volatile int __A_VARIABLE;
   int status;
   luaL_checkany(L, 2);
   lua_settop(L, 2);
@@ -389,14 +446,18 @@ static int luaB_xpcall (lua_State *L) {
   status = lua_pcall(L, 0, LUA_MULTRET, 1);
   lua_pushboolean(L, (status == 0));
   lua_replace(L, 1);
+  __A_VARIABLE = 1;
   return lua_gettop(L);  /* return status + all results */
 }
 
 
 static int luaB_tostring (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
-  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
-    return 1;  /* use its value */
+  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */ {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* use its value */
   switch (lua_type(L, 1)) {
     case LUA_TNUMBER:
       lua_pushstring(L, lua_tostring(L, 1));
@@ -414,6 +475,7 @@ static int luaB_tostring (lua_State *L) {
       lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
       break;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -508,9 +570,11 @@ static int costatus (lua_State *L, lua_State *co) {
 
 
 static int luaB_costatus (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_State *co = lua_tothread(L, 1);
   luaL_argcheck(L, co, 1, "coroutine expected");
   lua_pushstring(L, statnames[costatus(L, co)]);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -559,6 +623,7 @@ static int luaB_coresume (lua_State *L) {
 
 
 static int luaB_auxwrap (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_State *co = lua_tothread(L, lua_upvalueindex(1));
   int r = auxresume(L, co, lua_gettop(L));
   if (r < 0) {
@@ -569,35 +634,44 @@ static int luaB_auxwrap (lua_State *L) {
     }
     lua_error(L);  /* propagate error */
   }
+  __A_VARIABLE = 1;
   return r;
 }
 
 
 static int luaB_cocreate (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_State *NL = lua_newthread(L);
   luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1), 1,
     "Lua function expected");
   lua_pushvalue(L, 1);  /* move function to top */
   lua_xmove(L, NL, 1);  /* move function from L to NL */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_cowrap (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaB_cocreate(L);
   lua_pushcclosure(L, luaB_auxwrap, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_yield (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return lua_yield(L, lua_gettop(L));
 }
 
 
 static int luaB_corunning (lua_State *L) {
+  volatile int __A_VARIABLE;
   if (lua_pushthread(L))
     lua_pushnil(L);  /* main thread is not a coroutine */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -617,13 +691,16 @@ static const luaL_Reg co_funcs[] = {
 
 static void auxopen (lua_State *L, const char *name,
                      lua_CFunction f, lua_CFunction u) {
+  volatile int __A_VARIABLE;
   lua_pushcfunction(L, u);
   lua_pushcclosure(L, f, 1);
   lua_setfield(L, -2, name);
+  __A_VARIABLE = 1;
 }
 
 
 static void base_open (lua_State *L) {
+  volatile int __A_VARIABLE;
   /* set global _G */
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   lua_setglobal(L, "_G");
@@ -642,12 +719,15 @@ static void base_open (lua_State *L) {
   lua_setfield(L, -2, "__mode");  /* metatable(w).__mode = "kv" */
   lua_pushcclosure(L, luaB_newproxy, 1);
   lua_setglobal(L, "newproxy");  /* set global `newproxy' */
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API int luaopen_base (lua_State *L) {
+  volatile int __A_VARIABLE;
   base_open(L);
   luaL_register(L, LUA_COLIBNAME, co_funcs);
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/deps/lua/src/lcode.c b/deps/lua/src/lcode.c
index 679cb9c..1e1c775 100644
--- a/deps/lua/src/lcode.c
+++ b/deps/lua/src/lcode.c
@@ -28,6 +28,8 @@
 
 
 static int isnumeral(expdesc *e) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
 }
 
@@ -57,33 +59,41 @@ void luaK_nil (FuncState *fs, int from, int n) {
 
 
 int luaK_jump (FuncState *fs) {
+  volatile int __A_VARIABLE;
   int jpc = fs->jpc;  /* save list of jumps to here */
   int j;
   fs->jpc = NO_JUMP;
   j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
   luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  __A_VARIABLE = 1;
   return j;
 }
 
 
 void luaK_ret (FuncState *fs, int first, int nret) {
+  volatile int __A_VARIABLE;
   luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+  __A_VARIABLE = 1;
 }
 
 
 static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  volatile int __A_VARIABLE;
   luaK_codeABC(fs, op, A, B, C);
+  __A_VARIABLE = 1;
   return luaK_jump(fs);
 }
 
 
 static void fixjump (FuncState *fs, int pc, int dest) {
+  volatile int __A_VARIABLE;
   Instruction *jmp = &fs->f->code[pc];
   int offset = dest-(pc+1);
   lua_assert(dest != NO_JUMP);
   if (abs(offset) > MAXARG_sBx)
     luaX_syntaxerror(fs->ls, "control structure too long");
   SETARG_sBx(*jmp, offset);
+  __A_VARIABLE = 1;
 }
 
 
@@ -92,7 +102,9 @@ static void fixjump (FuncState *fs, int pc, int dest) {
 ** optimizations with consecutive instructions not in the same basic block).
 */
 int luaK_getlabel (FuncState *fs) {
+  volatile int __A_VARIABLE;
   fs->lasttarget = fs->pc;
+  __A_VARIABLE = 1;
   return fs->pc;
 }
 
@@ -120,35 +132,47 @@ static Instruction *getjumpcontrol (FuncState *fs, int pc) {
 ** (or produce an inverted value)
 */
 static int need_value (FuncState *fs, int list) {
+  volatile int __A_VARIABLE;
   for (; list != NO_JUMP; list = getjump(fs, list)) {
     Instruction i = *getjumpcontrol(fs, list);
-    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+    if (GET_OPCODE(i) != OP_TESTSET) {
+      __A_VARIABLE = 1;
+      return 1;
+    }
   }
+  __A_VARIABLE = 1;
   return 0;  /* not found */
 }
 
 
 static int patchtestreg (FuncState *fs, int node, int reg) {
+  volatile int __A_VARIABLE;
   Instruction *i = getjumpcontrol(fs, node);
-  if (GET_OPCODE(*i) != OP_TESTSET)
-    return 0;  /* cannot patch other instructions */
+  if (GET_OPCODE(*i) != OP_TESTSET) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* cannot patch other instructions */
   if (reg != NO_REG && reg != GETARG_B(*i))
     SETARG_A(*i, reg);
   else  /* no register to put value or register already has the value */
     *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static void removevalues (FuncState *fs, int list) {
+  volatile int __A_VARIABLE;
   for (; list != NO_JUMP; list = getjump(fs, list))
       patchtestreg(fs, list, NO_REG);
+  __A_VARIABLE = 1;
 }
 
 
 static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
                           int dtarget) {
+  volatile int __A_VARIABLE;
   while (list != NO_JUMP) {
     int next = getjump(fs, list);
     if (patchtestreg(fs, list, reg))
@@ -157,28 +181,35 @@ static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
       fixjump(fs, list, dtarget);  /* jump to default target */
     list = next;
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void dischargejpc (FuncState *fs) {
+  volatile int __A_VARIABLE;
   patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
   fs->jpc = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_patchlist (FuncState *fs, int list, int target) {
+  volatile int __A_VARIABLE;
   if (target == fs->pc)
     luaK_patchtohere(fs, list);
   else {
     lua_assert(target < fs->pc);
     patchlistaux(fs, list, target, NO_REG, target);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_patchtohere (FuncState *fs, int list) {
+  volatile int __A_VARIABLE;
   luaK_getlabel(fs);
   luaK_concat(fs, &fs->jpc, list);
+  __A_VARIABLE = 1;
 }
 
 
@@ -197,32 +228,40 @@ void luaK_concat (FuncState *fs, int *l1, int l2) {
 
 
 void luaK_checkstack (FuncState *fs, int n) {
+  volatile int __A_VARIABLE;
   int newstack = fs->freereg + n;
   if (newstack > fs->f->maxstacksize) {
     if (newstack >= MAXSTACK)
       luaX_syntaxerror(fs->ls, "function or expression too complex");
     fs->f->maxstacksize = cast_byte(newstack);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_reserveregs (FuncState *fs, int n) {
+  volatile int __A_VARIABLE;
   luaK_checkstack(fs, n);
   fs->freereg += n;
+  __A_VARIABLE = 1;
 }
 
 
 static void freereg (FuncState *fs, int reg) {
+  volatile int __A_VARIABLE;
   if (!ISK(reg) && reg >= fs->nactvar) {
     fs->freereg--;
     lua_assert(reg == fs->freereg);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void freeexp (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   if (e->k == VNONRELOC)
     freereg(fs, e->u.s.info);
+  __A_VARIABLE = 1;
 }
 
 
@@ -248,36 +287,45 @@ static int addk (FuncState *fs, TValue *k, TValue *v) {
 
 
 int luaK_stringK (FuncState *fs, TString *s) {
+  volatile int __A_VARIABLE;
   TValue o;
   setsvalue(fs->L, &o, s);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
 
 int luaK_numberK (FuncState *fs, lua_Number r) {
+  volatile int __A_VARIABLE;
   TValue o;
   setnvalue(&o, r);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
 
 static int boolK (FuncState *fs, int b) {
+  volatile int __A_VARIABLE;
   TValue o;
   setbvalue(&o, b);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
 
 static int nilK (FuncState *fs) {
+  volatile int __A_VARIABLE;
   TValue k, v;
   setnilvalue(&v);
   /* cannot use nil as key; instead use table itself to represent nil */
   sethvalue(fs->L, &k, fs->h);
+  __A_VARIABLE = 1;
   return addk(fs, &k, &v);
 }
 
 
 void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
+  volatile int __A_VARIABLE;
   if (e->k == VCALL) {  /* expression is an open function call? */
     SETARG_C(getcode(fs, e), nresults+1);
   }
@@ -286,10 +334,12 @@ void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
     SETARG_A(getcode(fs, e), fs->freereg);
     luaK_reserveregs(fs, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_setoneret (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   if (e->k == VCALL) {  /* expression is an open function call? */
     e->k = VNONRELOC;
     e->u.s.info = GETARG_A(getcode(fs, e));
@@ -298,10 +348,12 @@ void luaK_setoneret (FuncState *fs, expdesc *e) {
     SETARG_B(getcode(fs, e), 2);
     e->k = VRELOCABLE;  /* can relocate its simple result */
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   switch (e->k) {
     case VLOCAL: {
       e->k = VNONRELOC;
@@ -331,16 +383,20 @@ void luaK_dischargevars (FuncState *fs, expdesc *e) {
     }
     default: break;  /* there is one value available (somewhere) */
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int code_label (FuncState *fs, int A, int b, int jump) {
+  volatile int __A_VARIABLE;
   luaK_getlabel(fs);  /* those instructions may be jump targets */
+  __A_VARIABLE = 1;
   return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
 }
 
 
 static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  volatile int __A_VARIABLE;
   luaK_dischargevars(fs, e);
   switch (e->k) {
     case VNIL: {
@@ -371,23 +427,28 @@ static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
     }
     default: {
       lua_assert(e->k == VVOID || e->k == VJMP);
+      __A_VARIABLE = 1;
       return;  /* nothing to do... */
     }
   }
   e->u.s.info = reg;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
 static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   if (e->k != VNONRELOC) {
     luaK_reserveregs(fs, 1);
     discharge2reg(fs, e, fs->freereg-1);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void exp2reg (FuncState *fs, expdesc *e, int reg) {
+  volatile int __A_VARIABLE;
   discharge2reg(fs, e, reg);
   if (e->k == VJMP)
     luaK_concat(fs, &e->t, e->u.s.info);  /* put this jump in `t' list */
@@ -408,36 +469,47 @@ static void exp2reg (FuncState *fs, expdesc *e, int reg) {
   e->f = e->t = NO_JUMP;
   e->u.s.info = reg;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   luaK_dischargevars(fs, e);
   freeexp(fs, e);
   luaK_reserveregs(fs, 1);
   exp2reg(fs, e, fs->freereg - 1);
+  __A_VARIABLE = 1;
 }
 
 
 int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   luaK_dischargevars(fs, e);
   if (e->k == VNONRELOC) {
-    if (!hasjumps(e)) return e->u.s.info;  /* exp is already in a register */
+    if (!hasjumps(e)) {
+      __A_VARIABLE = 1;
+      return e->u.s.info;
+    }  /* exp is already in a register */
     if (e->u.s.info >= fs->nactvar) {  /* reg. is not a local? */
       exp2reg(fs, e, e->u.s.info);  /* put value on it */
+      __A_VARIABLE = 1;
       return e->u.s.info;
     }
   }
   luaK_exp2nextreg(fs, e);  /* default */
+  __A_VARIABLE = 1;
   return e->u.s.info;
 }
 
 
 void luaK_exp2val (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   if (hasjumps(e))
     luaK_exp2anyreg(fs, e);
   else
     luaK_dischargevars(fs, e);
+  __A_VARIABLE = 1;
 }
 
 
@@ -470,10 +542,12 @@ int luaK_exp2RK (FuncState *fs, expdesc *e) {
 
 
 void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
+  volatile int __A_VARIABLE;
   switch (var->k) {
     case VLOCAL: {
       freeexp(fs, ex);
       exp2reg(fs, ex, var->u.s.info);
+      __A_VARIABLE = 1;
       return;
     }
     case VUPVAL: {
@@ -497,10 +571,12 @@ void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
     }
   }
   freeexp(fs, ex);
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  volatile int __A_VARIABLE;
   int func;
   luaK_exp2anyreg(fs, e);
   freeexp(fs, e);
@@ -510,33 +586,40 @@ void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
   freeexp(fs, key);
   e->u.s.info = func;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
 static void invertjump (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   Instruction *pc = getjumpcontrol(fs, e->u.s.info);
   lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
                                            GET_OPCODE(*pc) != OP_TEST);
   SETARG_A(*pc, !(GETARG_A(*pc)));
+  __A_VARIABLE = 1;
 }
 
 
 static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  volatile int __A_VARIABLE;
   if (e->k == VRELOCABLE) {
     Instruction ie = getcode(fs, e);
     if (GET_OPCODE(ie) == OP_NOT) {
       fs->pc--;  /* remove previous OP_NOT */
+      __A_VARIABLE = 1;
       return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
     }
     /* else go through */
   }
   discharge2anyreg(fs, e);
   freeexp(fs, e);
+  __A_VARIABLE = 1;
   return condjump(fs, OP_TESTSET, NO_REG, e->u.s.info, cond);
 }
 
 
 void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   int pc;  /* pc of last jump */
   luaK_dischargevars(fs, e);
   switch (e->k) {
@@ -557,10 +640,12 @@ void luaK_goiftrue (FuncState *fs, expdesc *e) {
   luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
   luaK_patchtohere(fs, e->t);
   e->t = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
 static void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   int pc;  /* pc of last jump */
   luaK_dischargevars(fs, e);
   switch (e->k) {
@@ -580,10 +665,12 @@ static void luaK_goiffalse (FuncState *fs, expdesc *e) {
   luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
   luaK_patchtohere(fs, e->f);
   e->f = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
 static void codenot (FuncState *fs, expdesc *e) {
+  volatile int __A_VARIABLE;
   luaK_dischargevars(fs, e);
   switch (e->k) {
     case VNIL: case VFALSE: {
@@ -615,18 +702,25 @@ static void codenot (FuncState *fs, expdesc *e) {
   { int temp = e->f; e->f = e->t; e->t = temp; }
   removevalues(fs, e->f);
   removevalues(fs, e->t);
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  volatile int __A_VARIABLE;
   t->u.s.aux = luaK_exp2RK(fs, k);
   t->k = VINDEXED;
+  __A_VARIABLE = 1;
 }
 
 
 static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
+  volatile int __A_VARIABLE;
   lua_Number v1, v2, r;
-  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if (!isnumeral(e1) || !isnumeral(e2)) {
+      __A_VARIABLE = 1;
+      return 0;
+  }
   v1 = e1->u.nval;
   v2 = e2->u.nval;
   switch (op) {
@@ -634,18 +728,29 @@ static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
     case OP_SUB: r = luai_numsub(v1, v2); break;
     case OP_MUL: r = luai_nummul(v1, v2); break;
     case OP_DIV:
-      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+      if (v2 == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+      }  /* do not attempt to divide by 0 */
       r = luai_numdiv(v1, v2); break;
     case OP_MOD:
-      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+      if (v2 == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+      }  /* do not attempt to divide by 0 */
       r = luai_nummod(v1, v2); break;
     case OP_POW: r = luai_numpow(v1, v2); break;
     case OP_UNM: r = luai_numunm(v1); break;
-    case OP_LEN: return 0;  /* no constant folding for 'len' */
+    case OP_LEN: __A_VARIABLE = 1;
+      return 0;  /* no constant folding for 'len' */
     default: lua_assert(0); r = 0; break;
   }
-  if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
+  if (luai_numisnan(r)) {
+      __A_VARIABLE = 1;
+      return 0;
+  }  /* do not attempt to produce NaN */
   e1->u.nval = r;
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -672,6 +777,7 @@ static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
 
 static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
                                                           expdesc *e2) {
+  volatile int __A_VARIABLE;
   int o1 = luaK_exp2RK(fs, e1);
   int o2 = luaK_exp2RK(fs, e2);
   freeexp(fs, e2);
@@ -683,10 +789,12 @@ static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
   }
   e1->u.s.info = condjump(fs, op, cond, o1, o2);
   e1->k = VJMP;
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
+  volatile int __A_VARIABLE;
   expdesc e2;
   e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
   switch (op) {
@@ -704,10 +812,12 @@ void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  volatile int __A_VARIABLE;
   switch (op) {
     case OPR_AND: {
       luaK_goiftrue(fs, v);
@@ -731,10 +841,12 @@ void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
       break;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
+  volatile int __A_VARIABLE;
   switch (op) {
     case OPR_AND: {
       lua_assert(e1->t == NO_JUMP);  /* list must be closed */
@@ -778,15 +890,19 @@ void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
     case OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); break;
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_fixline (FuncState *fs, int line) {
+  volatile int __A_VARIABLE;
   fs->f->lineinfo[fs->pc - 1] = line;
+  __A_VARIABLE = 1;
 }
 
 
 static int luaK_code (FuncState *fs, Instruction i, int line) {
+  volatile int __A_VARIABLE;
   Proto *f = fs->f;
   dischargejpc(fs);  /* `pc' will change */
   /* put new instruction in code array */
@@ -797,26 +913,32 @@ static int luaK_code (FuncState *fs, Instruction i, int line) {
   luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                   MAX_INT, "code size overflow");
   f->lineinfo[fs->pc] = line;
+  __A_VARIABLE = 1;
   return fs->pc++;
 }
 
 
 int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  volatile int __A_VARIABLE;
   lua_assert(getOpMode(o) == iABC);
   lua_assert(getBMode(o) != OpArgN || b == 0);
   lua_assert(getCMode(o) != OpArgN || c == 0);
+  __A_VARIABLE = 1;
   return luaK_code(fs, CREATE_ABC(o, a, b, c), fs->ls->lastline);
 }
 
 
 int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  volatile int __A_VARIABLE;
   lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
   lua_assert(getCMode(o) == OpArgN);
+  __A_VARIABLE = 1;
   return luaK_code(fs, CREATE_ABx(o, a, bc), fs->ls->lastline);
 }
 
 
 void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
+  volatile int __A_VARIABLE;
   int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
   int b = (tostore == LUA_MULTRET) ? 0 : tostore;
   lua_assert(tostore != 0);
@@ -827,5 +949,6 @@ void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
     luaK_code(fs, cast(Instruction, c), fs->ls->lastline);
   }
   fs->freereg = base + 1;  /* free registers with list values */
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/ldblib.c b/deps/lua/src/ldblib.c
index 2027eda..c40e660 100644
--- a/deps/lua/src/ldblib.c
+++ b/deps/lua/src/ldblib.c
@@ -20,56 +20,70 @@
 
 
 static int db_getregistry (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushvalue(L, LUA_REGISTRYINDEX);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int db_getmetatable (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
   if (!lua_getmetatable(L, 1)) {
     lua_pushnil(L);  /* no metatable */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int db_setmetatable (lua_State *L) {
+  volatile int __A_VARIABLE;
   int t = lua_type(L, 2);
   luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
                     "nil or table expected");
   lua_settop(L, 2);
   lua_pushboolean(L, lua_setmetatable(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int db_getfenv (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 1);
   lua_getfenv(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int db_setfenv (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 2, LUA_TTABLE);
   lua_settop(L, 2);
   if (lua_setfenv(L, 1) == 0)
     luaL_error(L, LUA_QL("setfenv")
                   " cannot change environment of given object");
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static void settabss (lua_State *L, const char *i, const char *v) {
+  volatile int __A_VARIABLE;
   lua_pushstring(L, v);
   lua_setfield(L, -2, i);
+  __A_VARIABLE = 1;
 }
 
 
 static void settabsi (lua_State *L, const char *i, int v) {
+  volatile int __A_VARIABLE;
   lua_pushinteger(L, v);
   lua_setfield(L, -2, i);
+  __A_VARIABLE = 1;
 }
 
 
@@ -86,6 +100,7 @@ static lua_State *getthread (lua_State *L, int *arg) {
 
 
 static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
+  volatile int __A_VARIABLE;
   if (L == L1) {
     lua_pushvalue(L, -2);
     lua_remove(L, -3);
@@ -93,6 +108,7 @@ static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
   else
     lua_xmove(L1, L, 1);
   lua_setfield(L, -2, fname);
+  __A_VARIABLE = 1;
 }
 
 
@@ -163,39 +179,55 @@ static int db_getlocal (lua_State *L) {
 
 
 static int db_setlocal (lua_State *L) {
+  volatile int __A_VARIABLE;
   int arg;
   lua_State *L1 = getthread(L, &arg);
   lua_Debug ar;
-  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */ {
+    __A_VARIABLE = 1;
     return luaL_argerror(L, arg+1, "level out of range");
+  }
   luaL_checkany(L, arg+3);
   lua_settop(L, arg+3);
   lua_xmove(L, L1, 1);
   lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int auxupvalue (lua_State *L, int get) {
+  volatile int __A_VARIABLE;
   const char *name;
   int n = luaL_checkint(L, 2);
   luaL_checktype(L, 1, LUA_TFUNCTION);
-  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  if (lua_iscfunction(L, 1)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* cannot touch C upvalues from Lua */
   name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
-  if (name == NULL) return 0;
+  if (name == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   lua_pushstring(L, name);
   lua_insert(L, -(get+1));
+  __A_VARIABLE = 1;
   return get + 1;
 }
 
 
 static int db_getupvalue (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return auxupvalue(L, 1);
 }
 
 
 static int db_setupvalue (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkany(L, 3);
+  __A_VARIABLE = 1;
   return auxupvalue(L, 0);
 }
 
@@ -205,6 +237,7 @@ static const char KEY_HOOK = 'h';
 
 
 static void hookf (lua_State *L, lua_Debug *ar) {
+  volatile int __A_VARIABLE;
   static const char *const hooknames[] =
     {"call", "return", "line", "count", "tail return"};
   lua_pushlightuserdata(L, (void *)&KEY_HOOK);
@@ -219,30 +252,36 @@ static void hookf (lua_State *L, lua_Debug *ar) {
     lua_assert(lua_getinfo(L, "lS", ar));
     lua_call(L, 2, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int makemask (const char *smask, int count) {
+  volatile int __A_VARIABLE;
   int mask = 0;
   if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
   if (strchr(smask, 'r')) mask |= LUA_MASKRET;
   if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
   if (count > 0) mask |= LUA_MASKCOUNT;
+  __A_VARIABLE = 1;
   return mask;
 }
 
 
 static char *unmakemask (int mask, char *smask) {
+  volatile int __A_VARIABLE;
   int i = 0;
   if (mask & LUA_MASKCALL) smask[i++] = 'c';
   if (mask & LUA_MASKRET) smask[i++] = 'r';
   if (mask & LUA_MASKLINE) smask[i++] = 'l';
   smask[i] = '\0';
+  __A_VARIABLE = 1;
   return smask;
 }
 
 
 static void gethooktable (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushlightuserdata(L, (void *)&KEY_HOOK);
   lua_rawget(L, LUA_REGISTRYINDEX);
   if (!lua_istable(L, -1)) {
@@ -252,10 +291,12 @@ static void gethooktable (lua_State *L) {
     lua_pushvalue(L, -2);
     lua_rawset(L, LUA_REGISTRYINDEX);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int db_sethook (lua_State *L) {
+  volatile int __A_VARIABLE;
   int arg, mask, count;
   lua_Hook func;
   lua_State *L1 = getthread(L, &arg);
@@ -275,11 +316,13 @@ static int db_sethook (lua_State *L) {
   lua_rawset(L, -3);  /* set new hook */
   lua_pop(L, 1);  /* remove hook table */
   lua_sethook(L1, func, mask, count);  /* set hooks */
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int db_gethook (lua_State *L) {
+  volatile int __A_VARIABLE;
   int arg;
   lua_State *L1 = getthread(L, &arg);
   char buff[5];
@@ -295,17 +338,21 @@ static int db_gethook (lua_State *L) {
   }
   lua_pushstring(L, unmakemask(mask, buff));
   lua_pushinteger(L, lua_gethookcount(L1));
+  __A_VARIABLE = 1;
   return 3;
 }
 
 
 static int db_debug (lua_State *L) {
+  volatile int __A_VARIABLE;
   for (;;) {
     char buffer[250];
     fputs("lua_debug> ", stderr);
     if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
-        strcmp(buffer, "cont\n") == 0)
+        strcmp(buffer, "cont\n") == 0) {
+      __A_VARIABLE = 1;
       return 0;
+    }
     if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
         lua_pcall(L, 0, 0, 0)) {
       fputs(lua_tostring(L, -1), stderr);
@@ -313,6 +360,7 @@ static int db_debug (lua_State *L) {
     }
     lua_settop(L, 0);  /* remove eventual returns */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -392,7 +440,9 @@ static const luaL_Reg dblib[] = {
 
 
 LUALIB_API int luaopen_debug (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, LUA_DBLIBNAME, dblib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ldebug.c b/deps/lua/src/ldebug.c
index 50ad3d3..8232007 100644
--- a/deps/lua/src/ldebug.c
+++ b/deps/lua/src/ldebug.c
@@ -34,9 +34,14 @@ static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
 
 
 static int currentpc (lua_State *L, CallInfo *ci) {
-  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  volatile int __A_VARIABLE;
+  if (!isLua(ci)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* function is not a Lua function? */
   if (ci == L->ci)
     ci->savedpc = L->savedpc;
+  __A_VARIABLE = 1;
   return pcRel(ci->savedpc, ci_func(ci)->l.p);
 }
 
@@ -54,6 +59,7 @@ static int currentline (lua_State *L, CallInfo *ci) {
 ** this function can be called asynchronous (e.g. during a signal)
 */
 LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  volatile int __A_VARIABLE;
   if (func == NULL || mask == 0) {  /* turn off hooks? */
     mask = 0;
     func = NULL;
@@ -62,26 +68,34 @@ LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
   L->basehookcount = count;
   resethookcount(L);
   L->hookmask = cast_byte(mask);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 LUA_API lua_Hook lua_gethook (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return L->hook;
 }
 
 
 LUA_API int lua_gethookmask (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return L->hookmask;
 }
 
 
 LUA_API int lua_gethookcount (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return L->basehookcount;
 }
 
 
 LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  volatile int __A_VARIABLE;
   int status;
   CallInfo *ci;
   lua_lock(L);
@@ -100,11 +114,14 @@ LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
   }
   else status = 0;  /* no such level */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static Proto *getluaproto (CallInfo *ci) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return (isLua(ci) ? ci_func(ci)->l.p : NULL);
 }
 
@@ -125,17 +142,20 @@ static const char *findlocal (lua_State *L, CallInfo *ci, int n) {
 
 
 LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  volatile int __A_VARIABLE;
   CallInfo *ci = L->base_ci + ar->i_ci;
   const char *name = findlocal(L, ci, n);
   lua_lock(L);
   if (name)
       luaA_pushobject(L, ci->base + (n - 1));
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
 
 LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  volatile int __A_VARIABLE;
   CallInfo *ci = L->base_ci + ar->i_ci;
   const char *name = findlocal(L, ci, n);
   lua_lock(L);
@@ -143,11 +163,13 @@ LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
       setobjs2s(L, ci->base + (n - 1), L->top - 1);
   L->top--;  /* pop value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
 
 static void funcinfo (lua_Debug *ar, Closure *cl) {
+  volatile int __A_VARIABLE;
   if (cl->c.isC) {
     ar->source = "=[C]";
     ar->linedefined = -1;
@@ -161,20 +183,24 @@ static void funcinfo (lua_Debug *ar, Closure *cl) {
     ar->what = (ar->linedefined == 0) ? "main" : "Lua";
   }
   luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+  __A_VARIABLE = 1;
 }
 
 
 static void info_tailcall (lua_Debug *ar) {
+  volatile int __A_VARIABLE;
   ar->name = ar->namewhat = "";
   ar->what = "tail";
   ar->lastlinedefined = ar->linedefined = ar->currentline = -1;
   ar->source = "=(tail call)";
   luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
   ar->nups = 0;
+  __A_VARIABLE = 1;
 }
 
 
 static void collectvalidlines (lua_State *L, Closure *f) {
+  volatile int __A_VARIABLE;
   if (f == NULL || f->c.isC) {
     setnilvalue(L->top);
   }
@@ -187,14 +213,17 @@ static void collectvalidlines (lua_State *L, Closure *f) {
     sethvalue(L, L->top, t); 
   }
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
 static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
                     Closure *f, CallInfo *ci) {
+  volatile int __A_VARIABLE;
   int status = 1;
   if (f == NULL) {
     info_tailcall(ar);
+    __A_VARIABLE = 1;
     return status;
   }
   for (; *what; what++) {
@@ -225,11 +254,13 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
       default: status = 0;  /* invalid option */
     }
   }
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  volatile int __A_VARIABLE;
   int status;
   Closure *f = NULL;
   CallInfo *ci = NULL;
@@ -255,6 +286,7 @@ LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
   if (strchr(what, 'L'))
     collectvalidlines(L, f);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -274,6 +306,7 @@ LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
 
 
 static int precheck (const Proto *pt) {
+  volatile int __A_VARIABLE;
   check(pt->maxstacksize <= MAXSTACK);
   check(pt->numparams+(pt->is_vararg & VARARG_HASARG) <= pt->maxstacksize);
   check(!(pt->is_vararg & VARARG_NEEDSARG) ||
@@ -281,6 +314,7 @@ static int precheck (const Proto *pt) {
   check(pt->sizeupvalues <= pt->nups);
   check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
   check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -288,20 +322,24 @@ static int precheck (const Proto *pt) {
 #define checkopenop(pt,pc)	luaG_checkopenop((pt)->code[(pc)+1])
 
 int luaG_checkopenop (Instruction i) {
+  volatile int __A_VARIABLE;
   switch (GET_OPCODE(i)) {
     case OP_CALL:
     case OP_TAILCALL:
     case OP_RETURN:
     case OP_SETLIST: {
       check(GETARG_B(i) == 0);
+      __A_VARIABLE = 1;
       return 1;
     }
-    default: return 0;  /* invalid instruction after an open call */
+    default: __A_VARIABLE = 1;
+    return 0;  /* invalid instruction after an open call */
   }
 }
 
 
 static int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {
+  volatile int __A_VARIABLE;
   switch (mode) {
     case OpArgN: check(r == 0); break;
     case OpArgU: break;
@@ -310,11 +348,13 @@ static int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {
       check(ISK(r) ? INDEXK(r) < pt->sizek : r < pt->maxstacksize);
       break;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
+  volatile int __A_VARIABLE;
   int pc;
   int last;  /* stores position of last instruction that changed `reg' */
   last = pt->sizecode-1;  /* points to final return (a `neutral' instruction) */
@@ -471,6 +511,7 @@ static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return pt->code[last];
 }
 
@@ -482,6 +523,8 @@ static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
 
 
 int luaG_checkcode (const Proto *pt) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return (symbexec(pt, pt->sizecode, NO_REG) != 0);
 }
 
@@ -496,13 +539,16 @@ static const char *kname (Proto *p, int c) {
 
 static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
                                const char **name) {
+  volatile int __A_VARIABLE;
   if (isLua(ci)) {  /* a Lua function? */
     Proto *p = ci_func(ci)->l.p;
     int pc = currentpc(L, ci);
     Instruction i;
     *name = luaF_getlocalname(p, stackpos+1, pc);
-    if (*name)  /* is a local? */
+    if (*name)  /* is a local? */ {
+      __A_VARIABLE = 1;
       return "local";
+    }
     i = symbexec(p, pc, stackpos);  /* try symbolic execution */
     lua_assert(pc != -1);
     switch (GET_OPCODE(i)) {
@@ -510,33 +556,40 @@ static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
         int g = GETARG_Bx(i);  /* global index */
         lua_assert(ttisstring(&p->k[g]));
         *name = svalue(&p->k[g]);
+        __A_VARIABLE = 1;
         return "global";
       }
       case OP_MOVE: {
         int a = GETARG_A(i);
         int b = GETARG_B(i);  /* move from `b' to `a' */
-        if (b < a)
-          return getobjname(L, ci, b, name);  /* get name for `b' */
+        if (b < a) {
+          __A_VARIABLE = 1;
+          return getobjname(L, ci, b, name);
+        }  /* get name for `b' */
         break;
       }
       case OP_GETTABLE: {
         int k = GETARG_C(i);  /* key index */
         *name = kname(p, k);
+        __A_VARIABLE = 1;
         return "field";
       }
       case OP_GETUPVAL: {
         int u = GETARG_B(i);  /* upvalue index */
         *name = p->upvalues ? getstr(p->upvalues[u]) : "?";
+        __A_VARIABLE = 1;
         return "upvalue";
       }
       case OP_SELF: {
         int k = GETARG_C(i);  /* key index */
         *name = kname(p, k);
+        __A_VARIABLE = 1;
         return "method";
       }
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* no useful name found */
 }
 
@@ -557,14 +610,20 @@ static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
 
 /* only ANSI way to check whether a pointer points to an array */
 static int isinstack (CallInfo *ci, const TValue *o) {
+  volatile int __A_VARIABLE;
   StkId p;
   for (p = ci->base; p < ci->top; p++)
-    if (o == p) return 1;
+    if (o == p) {
+      __A_VARIABLE = 1;
+      return 1;
+    }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  volatile int __A_VARIABLE;
   const char *name = NULL;
   const char *t = luaT_typenames[ttype(o)];
   const char *kind = (isinstack(L->ci, o)) ?
@@ -575,36 +634,44 @@ void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
                 op, kind, name, t);
   else
     luaG_runerror(L, "attempt to %s a %s value", op, t);
+  __A_VARIABLE = 1;
 }
 
 
 void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  volatile int __A_VARIABLE;
   if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
   lua_assert(!ttisstring(p1) && !ttisnumber(p1));
   luaG_typeerror(L, p1, "concatenate");
+  __A_VARIABLE = 1;
 }
 
 
 void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
+  volatile int __A_VARIABLE;
   TValue temp;
   if (luaV_tonumber(p1, &temp) == NULL)
     p2 = p1;  /* first operand is wrong */
   luaG_typeerror(L, p2, "perform arithmetic on");
+  __A_VARIABLE = 1;
 }
 
 
 int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
+  volatile int __A_VARIABLE;
   const char *t1 = luaT_typenames[ttype(p1)];
   const char *t2 = luaT_typenames[ttype(p2)];
   if (t1[2] == t2[2])
     luaG_runerror(L, "attempt to compare two %s values", t1);
   else
     luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static void addinfo (lua_State *L, const char *msg) {
+  volatile int __A_VARIABLE;
   CallInfo *ci = L->ci;
   if (isLua(ci)) {  /* is Lua code? */
     char buff[LUA_IDSIZE];  /* add file:line information */
@@ -612,10 +679,12 @@ static void addinfo (lua_State *L, const char *msg) {
     luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
     luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaG_errormsg (lua_State *L) {
+  volatile int __A_VARIABLE;
   if (L->errfunc != 0) {  /* is there an error handling function? */
     StkId errfunc = restorestack(L, L->errfunc);
     if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
@@ -625,14 +694,17 @@ void luaG_errormsg (lua_State *L) {
     luaD_call(L, L->top - 2, 1);  /* call it */
   }
   luaD_throw(L, LUA_ERRRUN);
+  __A_VARIABLE = 1;
 }
 
 
 void luaG_runerror (lua_State *L, const char *fmt, ...) {
+  volatile int __A_VARIABLE;
   va_list argp;
   va_start(argp, fmt);
   addinfo(L, luaO_pushvfstring(L, fmt, argp));
   va_end(argp);
   luaG_errormsg(L);
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/ldo.c b/deps/lua/src/ldo.c
index 514f7a2..9fb5224 100644
--- a/deps/lua/src/ldo.c
+++ b/deps/lua/src/ldo.c
@@ -49,6 +49,7 @@ struct lua_longjmp {
 
 
 void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  volatile int __A_VARIABLE;
   switch (errcode) {
     case LUA_ERRMEM: {
       setsvalue2s(L, oldtop, luaS_newliteral(L, MEMERRMSG));
@@ -65,20 +66,24 @@ void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
     }
   }
   L->top = oldtop + 1;
+  __A_VARIABLE = 1;
 }
 
 
 static void restore_stack_limit (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);
   if (L->size_ci > LUAI_MAXCALLS) {  /* there was an overflow? */
     int inuse = cast_int(L->ci - L->base_ci);
     if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */
       luaD_reallocCI(L, LUAI_MAXCALLS);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void resetstack (lua_State *L, int status) {
+  volatile int __A_VARIABLE;
   L->ci = L->base_ci;
   L->base = L->ci->base;
   luaF_close(L, L->base);  /* close eventual pending closures */
@@ -88,10 +93,12 @@ static void resetstack (lua_State *L, int status) {
   restore_stack_limit(L);
   L->errfunc = 0;
   L->errorJmp = NULL;
+  __A_VARIABLE = 1;
 }
 
 
 void luaD_throw (lua_State *L, int errcode) {
+  volatile int __A_VARIABLE;
   if (L->errorJmp) {
     L->errorJmp->status = errcode;
     LUAI_THROW(L, L->errorJmp);
@@ -105,10 +112,12 @@ void luaD_throw (lua_State *L, int errcode) {
     }
     exit(EXIT_FAILURE);
   }
+  __A_VARIABLE = 1;
 }
 
 
 int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  volatile int __A_VARIABLE;
   struct lua_longjmp lj;
   lj.status = 0;
   lj.previous = L->errorJmp;  /* chain new error handler */
@@ -117,6 +126,7 @@ int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
     (*f)(L, ud);
   );
   L->errorJmp = lj.previous;  /* restore old error handler */
+  __A_VARIABLE = 1;
   return lj.status;
 }
 
@@ -124,6 +134,7 @@ int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
 
 
 static void correctstack (lua_State *L, TValue *oldstack) {
+  volatile int __A_VARIABLE;
   CallInfo *ci;
   GCObject *up;
   L->top = (L->top - oldstack) + L->stack;
@@ -135,10 +146,12 @@ static void correctstack (lua_State *L, TValue *oldstack) {
     ci->func = (ci->func - oldstack) + L->stack;
   }
   L->base = (L->base - oldstack) + L->stack;
+  __A_VARIABLE = 1;
 }
 
 
 void luaD_reallocstack (lua_State *L, int newsize) {
+  volatile int __A_VARIABLE;
   TValue *oldstack = L->stack;
   int realsize = newsize + 1 + EXTRA_STACK;
   lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1);
@@ -146,27 +159,33 @@ void luaD_reallocstack (lua_State *L, int newsize) {
   L->stacksize = realsize;
   L->stack_last = L->stack+newsize;
   correctstack(L, oldstack);
+  __A_VARIABLE = 1;
 }
 
 
 void luaD_reallocCI (lua_State *L, int newsize) {
+  volatile int __A_VARIABLE;
   CallInfo *oldci = L->base_ci;
   luaM_reallocvector(L, L->base_ci, L->size_ci, newsize, CallInfo);
   L->size_ci = newsize;
   L->ci = (L->ci - oldci) + L->base_ci;
   L->end_ci = L->base_ci + L->size_ci - 1;
+  __A_VARIABLE = 1;
 }
 
 
 void luaD_growstack (lua_State *L, int n) {
+  volatile int __A_VARIABLE;
   if (n <= L->stacksize)  /* double size is enough? */
     luaD_reallocstack(L, 2*L->stacksize);
   else
     luaD_reallocstack(L, L->stacksize + n);
+  __A_VARIABLE = 1;
 }
 
 
 static CallInfo *growCI (lua_State *L) {
+  volatile int __A_VARIABLE;
   if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
     luaD_throw(L, LUA_ERRERR);
   else {
@@ -174,11 +193,13 @@ static CallInfo *growCI (lua_State *L) {
     if (L->size_ci > LUAI_MAXCALLS)
       luaG_runerror(L, "stack overflow");
   }
+  __A_VARIABLE = 1;
   return ++L->ci;
 }
 
 
 void luaD_callhook (lua_State *L, int event, int line) {
+  volatile int __A_VARIABLE;
   lua_Hook hook = L->hook;
   if (hook && L->allowhook) {
     ptrdiff_t top = savestack(L, L->top);
@@ -202,10 +223,12 @@ void luaD_callhook (lua_State *L, int event, int line) {
     L->ci->top = restorestack(L, ci_top);
     L->top = restorestack(L, top);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
+  volatile int __A_VARIABLE;
   int i;
   int nfixargs = p->numparams;
   Table *htab = NULL;
@@ -237,11 +260,13 @@ static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
     sethvalue(L, L->top++, htab);
     lua_assert(iswhite(obj2gco(htab)));
   }
+  __A_VARIABLE = 1;
   return base;
 }
 
 
 static StkId tryfuncTM (lua_State *L, StkId func) {
+  volatile int __A_VARIABLE;
   const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
   StkId p;
   ptrdiff_t funcr = savestack(L, func);
@@ -252,6 +277,7 @@ static StkId tryfuncTM (lua_State *L, StkId func) {
   incr_top(L);
   func = restorestack(L, funcr);  /* previous call may change stack */
   setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  __A_VARIABLE = 1;
   return func;
 }
 
@@ -330,17 +356,20 @@ int luaD_precall (lua_State *L, StkId func, int nresults) {
 
 
 static StkId callrethooks (lua_State *L, StkId firstResult) {
+  volatile int __A_VARIABLE;
   ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
   luaD_callhook(L, LUA_HOOKRET, -1);
   if (f_isLua(L->ci)) {  /* Lua function? */
     while ((L->hookmask & LUA_MASKRET) && L->ci->tailcalls--) /* tail calls */
       luaD_callhook(L, LUA_HOOKTAILRET, -1);
   }
+  __A_VARIABLE = 1;
   return restorestack(L, fr);
 }
 
 
 int luaD_poscall (lua_State *L, StkId firstResult) {
+  volatile int __A_VARIABLE;
   StkId res;
   int wanted, i;
   CallInfo *ci;
@@ -357,6 +386,7 @@ int luaD_poscall (lua_State *L, StkId firstResult) {
   while (i-- > 0)
     setnilvalue(res++);
   L->top = res;
+  __A_VARIABLE = 1;
   return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
 }
 
@@ -368,6 +398,7 @@ int luaD_poscall (lua_State *L, StkId firstResult) {
 ** function position.
 */ 
 void luaD_call (lua_State *L, StkId func, int nResults) {
+  volatile int __A_VARIABLE;
   if (++L->nCcalls >= LUAI_MAXCCALLS) {
     if (L->nCcalls == LUAI_MAXCCALLS)
       luaG_runerror(L, "C stack overflow");
@@ -378,6 +409,7 @@ void luaD_call (lua_State *L, StkId func, int nResults) {
     luaV_execute(L, 1);  /* call it */
   L->nCcalls--;
   luaC_checkGC(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -407,21 +439,28 @@ static void resume (lua_State *L, void *ud) {
 
 
 static int resume_error (lua_State *L, const char *msg) {
+  volatile int __A_VARIABLE;
   L->top = L->ci->base;
   setsvalue2s(L, L->top, luaS_new(L, msg));
   incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return LUA_ERRRUN;
 }
 
 
 LUA_API int lua_resume (lua_State *L, int nargs) {
+  volatile int __A_VARIABLE;
   int status;
   lua_lock(L);
-  if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
+  if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci)) {
+      __A_VARIABLE = 1;
       return resume_error(L, "cannot resume non-suspended coroutine");
-  if (L->nCcalls >= LUAI_MAXCCALLS)
+  }
+  if (L->nCcalls >= LUAI_MAXCCALLS) {
+    __A_VARIABLE = 1;
     return resume_error(L, "C stack overflow");
+  }
   luai_userstateresume(L, nargs);
   lua_assert(L->errfunc == 0);
   L->baseCcalls = ++L->nCcalls;
@@ -437,11 +476,13 @@ LUA_API int lua_resume (lua_State *L, int nargs) {
   }
   --L->nCcalls;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int lua_yield (lua_State *L, int nresults) {
+  volatile int __A_VARIABLE;
   luai_userstateyield(L, nresults);
   lua_lock(L);
   if (L->nCcalls > L->baseCcalls)
@@ -449,12 +490,14 @@ LUA_API int lua_yield (lua_State *L, int nresults) {
   L->base = L->top - nresults;  /* protect stack slots below */
   L->status = LUA_YIELD;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return -1;
 }
 
 
 int luaD_pcall (lua_State *L, Pfunc func, void *u,
                 ptrdiff_t old_top, ptrdiff_t ef) {
+  volatile int __A_VARIABLE;
   int status;
   unsigned short oldnCcalls = L->nCcalls;
   ptrdiff_t old_ci = saveci(L, L->ci);
@@ -474,6 +517,7 @@ int luaD_pcall (lua_State *L, Pfunc func, void *u,
     restore_stack_limit(L);
   }
   L->errfunc = old_errfunc;
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -489,6 +533,7 @@ struct SParser {  /* data to `f_parser' */
 };
 
 static void f_parser (lua_State *L, void *ud) {
+  volatile int __A_VARIABLE;
   int i;
   Proto *tf;
   Closure *cl;
@@ -503,16 +548,19 @@ static void f_parser (lua_State *L, void *ud) {
     cl->l.upvals[i] = luaF_newupval(L);
   setclvalue(L, L->top, cl);
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
 int luaD_protectedparser (lua_State *L, ZIO *z, const char *name) {
+  volatile int __A_VARIABLE;
   struct SParser p;
   int status;
   p.z = z; p.name = name;
   luaZ_initbuffer(L, &p.buff);
   status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
   luaZ_freebuffer(L, &p.buff);
+  __A_VARIABLE = 1;
   return status;
 }
 
diff --git a/deps/lua/src/ldump.c b/deps/lua/src/ldump.c
index c9d3d48..0b754a5 100644
--- a/deps/lua/src/ldump.c
+++ b/deps/lua/src/ldump.c
@@ -28,38 +28,49 @@ typedef struct {
 
 static void DumpBlock(const void* b, size_t size, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  if (D->status==0)
  {
   lua_unlock(D->L);
   D->status=(*D->writer)(D->L,b,size,D->data);
   lua_lock(D->L);
  }
+ __A_VARIABLE = 1;
 }
 
 static void DumpChar(int y, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  char x=(char)y;
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpInt(int x, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpNumber(lua_Number x, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  DumpInt(n,D);
  DumpMem(b,n,size,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpString(const TString* s, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  if (s==NULL || getstr(s)==NULL)
  {
   size_t size=0;
@@ -71,6 +82,7 @@ static void DumpString(const TString* s, DumpState* D)
   DumpVar(size,D);
   DumpBlock(getstr(s),size,D);
  }
+ __A_VARIABLE = 1;
 }
 
 #define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
@@ -79,6 +91,7 @@ static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
 
 static void DumpConstants(const Proto* f, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  int i,n=f->sizek;
  DumpInt(n,D);
  for (i=0; i<n; i++)
@@ -106,10 +119,12 @@ static void DumpConstants(const Proto* f, DumpState* D)
  n=f->sizep;
  DumpInt(n,D);
  for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpDebug(const Proto* f, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  int i,n;
  n= (D->strip) ? 0 : f->sizelineinfo;
  DumpVector(f->lineinfo,n,sizeof(int),D);
@@ -124,10 +139,12 @@ static void DumpDebug(const Proto* f, DumpState* D)
  n= (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n,D);
  for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
 {
+ volatile int __A_VARIABLE;
  DumpString((f->source==p || D->strip) ? NULL : f->source,D);
  DumpInt(f->linedefined,D);
  DumpInt(f->lastlinedefined,D);
@@ -138,13 +155,16 @@ static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
  DumpCode(f,D);
  DumpConstants(f,D);
  DumpDebug(f,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpHeader(DumpState* D)
 {
+ volatile int __A_VARIABLE;
  char h[LUAC_HEADERSIZE];
  luaU_header(h);
  DumpBlock(h,LUAC_HEADERSIZE,D);
+ __A_VARIABLE = 1;
 }
 
 /*
@@ -152,6 +172,7 @@ static void DumpHeader(DumpState* D)
 */
 int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
 {
+ volatile int __A_VARIABLE;
  DumpState D;
  D.L=L;
  D.writer=w;
@@ -160,5 +181,6 @@ int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip
  D.status=0;
  DumpHeader(&D);
  DumpFunction(f,NULL,&D);
+ __A_VARIABLE = 1;
  return D.status;
 }
diff --git a/deps/lua/src/lfunc.c b/deps/lua/src/lfunc.c
index 813e88f..ddbce81 100644
--- a/deps/lua/src/lfunc.c
+++ b/deps/lua/src/lfunc.c
@@ -21,36 +21,43 @@
 
 
 Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
+  volatile int __A_VARIABLE;
   Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
   luaC_link(L, obj2gco(c), LUA_TFUNCTION);
   c->c.isC = 1;
   c->c.env = e;
   c->c.nupvalues = cast_byte(nelems);
+  __A_VARIABLE = 1;
   return c;
 }
 
 
 Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
+  volatile int __A_VARIABLE;
   Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
   luaC_link(L, obj2gco(c), LUA_TFUNCTION);
   c->l.isC = 0;
   c->l.env = e;
   c->l.nupvalues = cast_byte(nelems);
   while (nelems--) c->l.upvals[nelems] = NULL;
+  __A_VARIABLE = 1;
   return c;
 }
 
 
 UpVal *luaF_newupval (lua_State *L) {
+  volatile int __A_VARIABLE;
   UpVal *uv = luaM_new(L, UpVal);
   luaC_link(L, obj2gco(uv), LUA_TUPVAL);
   uv->v = &uv->u.value;
   setnilvalue(uv->v);
+  __A_VARIABLE = 1;
   return uv;
 }
 
 
 UpVal *luaF_findupval (lua_State *L, StkId level) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   GCObject **pp = &L->openupval;
   UpVal *p;
@@ -60,6 +67,7 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
     if (p->v == level) {  /* found a corresponding upvalue? */
       if (isdead(g, obj2gco(p)))  /* is it dead? */
         changewhite(obj2gco(p));  /* ressurect it */
+      __A_VARIABLE = 1;
       return p;
     }
     pp = &p->next;
@@ -75,25 +83,31 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
   uv->u.l.next->u.l.prev = uv;
   g->uvhead.u.l.next = uv;
   lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  __A_VARIABLE = 1;
   return uv;
 }
 
 
 static void unlinkupval (UpVal *uv) {
+  volatile int __A_VARIABLE;
   lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
   uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
   uv->u.l.prev->u.l.next = uv->u.l.next;
+  __A_VARIABLE = 1;
 }
 
 
 void luaF_freeupval (lua_State *L, UpVal *uv) {
+  volatile int __A_VARIABLE;
   if (uv->v != &uv->u.value)  /* is it open? */
     unlinkupval(uv);  /* remove from open list */
   luaM_free(L, uv);  /* free upvalue */
+  __A_VARIABLE = 1;
 }
 
 
 void luaF_close (lua_State *L, StkId level) {
+  volatile int __A_VARIABLE;
   UpVal *uv;
   global_State *g = G(L);
   while (L->openupval != NULL && (uv = ngcotouv(L->openupval))->v >= level) {
@@ -109,10 +123,12 @@ void luaF_close (lua_State *L, StkId level) {
       luaC_linkupval(L, uv);  /* link upvalue into `gcroot' list */
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 Proto *luaF_newproto (lua_State *L) {
+  volatile int __A_VARIABLE;
   Proto *f = luaM_new(L, Proto);
   luaC_link(L, obj2gco(f), LUA_TPROTO);
   f->k = NULL;
@@ -134,11 +150,13 @@ Proto *luaF_newproto (lua_State *L) {
   f->linedefined = 0;
   f->lastlinedefined = 0;
   f->source = NULL;
+  __A_VARIABLE = 1;
   return f;
 }
 
 
 void luaF_freeproto (lua_State *L, Proto *f) {
+  volatile int __A_VARIABLE;
   luaM_freearray(L, f->code, f->sizecode, Instruction);
   luaM_freearray(L, f->p, f->sizep, Proto *);
   luaM_freearray(L, f->k, f->sizek, TValue);
@@ -146,13 +164,16 @@ void luaF_freeproto (lua_State *L, Proto *f) {
   luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
   luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
   luaM_free(L, f);
+  __A_VARIABLE = 1;
 }
 
 
 void luaF_freeclosure (lua_State *L, Closure *c) {
+  volatile int __A_VARIABLE;
   int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
                           sizeLclosure(c->l.nupvalues);
   luaM_freemem(L, c, size);
+  __A_VARIABLE = 1;
 }
 
 
@@ -161,14 +182,18 @@ void luaF_freeclosure (lua_State *L, Closure *c) {
 ** Returns NULL if not found.
 */
 const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  volatile int __A_VARIABLE;
   int i;
   for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
     if (pc < f->locvars[i].endpc) {  /* is variable active? */
       local_number--;
-      if (local_number == 0)
+      if (local_number == 0) {
+        __A_VARIABLE = 1;
         return getstr(f->locvars[i].varname);
+      }
     }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* not found */
 }
 
diff --git a/deps/lua/src/lgc.c b/deps/lua/src/lgc.c
index e909c79..5f5e187 100644
--- a/deps/lua/src/lgc.c
+++ b/deps/lua/src/lgc.c
@@ -60,17 +60,21 @@
 
 
 static void removeentry (Node *n) {
+  volatile int __A_VARIABLE;
   lua_assert(ttisnil(gval(n)));
   if (iscollectable(gkey(n)))
     setttype(gkey(n), LUA_TDEADKEY);  /* dead key; remove it */
+  __A_VARIABLE = 1;
 }
 
 
 static void reallymarkobject (global_State *g, GCObject *o) {
+  volatile int __A_VARIABLE;
   lua_assert(iswhite(o) && !isdead(g, o));
   white2gray(o);
   switch (o->gch.tt) {
     case LUA_TSTRING: {
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TUSERDATA: {
@@ -78,6 +82,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
       gray2black(o);  /* udata are never gray */
       if (mt) markobject(g, mt);
       markobject(g, gco2u(o)->env);
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TUPVAL: {
@@ -85,6 +90,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
       markvalue(g, uv->v);
       if (uv->v == &uv->u.value)  /* closed? */
         gray2black(o);  /* open upvalues are never black */
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TFUNCTION: {
@@ -109,10 +115,12 @@ static void reallymarkobject (global_State *g, GCObject *o) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void marktmu (global_State *g) {
+  volatile int __A_VARIABLE;
   GCObject *u = g->tmudata;
   if (u) {
     do {
@@ -121,11 +129,13 @@ static void marktmu (global_State *g) {
       reallymarkobject(g, u);
     } while (u != g->tmudata);
   }
+  __A_VARIABLE = 1;
 }
 
 
 /* move `dead' udata that need finalization to list `tmudata' */
 size_t luaC_separateudata (lua_State *L, int all) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   size_t deadmem = 0;
   GCObject **p = &g->mainthread->next;
@@ -151,11 +161,13 @@ size_t luaC_separateudata (lua_State *L, int all) {
       }
     }
   }
+  __A_VARIABLE = 1;
   return deadmem;
 }
 
 
 static int traversetable (global_State *g, Table *h) {
+  volatile int __A_VARIABLE;
   int i;
   int weakkey = 0;
   int weakvalue = 0;
@@ -174,7 +186,10 @@ static int traversetable (global_State *g, Table *h) {
       g->weak = obj2gco(h);  /* ... so put in the appropriate list */
     }
   }
-  if (weakkey && weakvalue) return 1;
+  if (weakkey && weakvalue) {
+    __A_VARIABLE = 1;
+    return 1;
+  }
   if (!weakvalue) {
     i = h->sizearray;
     while (i--)
@@ -192,6 +207,7 @@ static int traversetable (global_State *g, Table *h) {
       if (!weakvalue) markvalue(g, gval(n));
     }
   }
+  __A_VARIABLE = 1;
   return weakkey || weakvalue;
 }
 
@@ -201,6 +217,7 @@ static int traversetable (global_State *g, Table *h) {
 ** prototype is still being created
 */
 static void traverseproto (global_State *g, Proto *f) {
+  volatile int __A_VARIABLE;
   int i;
   if (f->source) stringmark(f->source);
   for (i=0; i<f->sizek; i++)  /* mark literals */
@@ -217,11 +234,13 @@ static void traverseproto (global_State *g, Proto *f) {
     if (f->locvars[i].varname)
       stringmark(f->locvars[i].varname);
   }
+  __A_VARIABLE = 1;
 }
 
 
 
 static void traverseclosure (global_State *g, Closure *cl) {
+  volatile int __A_VARIABLE;
   markobject(g, cl->c.env);
   if (cl->c.isC) {
     int i;
@@ -235,14 +254,18 @@ static void traverseclosure (global_State *g, Closure *cl) {
     for (i=0; i<cl->l.nupvalues; i++)  /* mark its upvalues */
       markobject(g, cl->l.upvals[i]);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void checkstacksizes (lua_State *L, StkId max) {
+  volatile int __A_VARIABLE;
   int ci_used = cast_int(L->ci - L->base_ci);  /* number of `ci' in use */
   int s_used = cast_int(max - L->stack);  /* part of stack in use */
-  if (L->size_ci > LUAI_MAXCALLS)  /* handling overflow? */
-    return;  /* do not touch the stacks */
+  if (L->size_ci > LUAI_MAXCALLS)  /* handling overflow? */ {
+    __A_VARIABLE = 1;
+    return;
+  }  /* do not touch the stacks */
   if (4*ci_used < L->size_ci && 2*BASIC_CI_SIZE < L->size_ci)
     luaD_reallocCI(L, L->size_ci/2);  /* still big enough... */
   condhardstacktests(luaD_reallocCI(L, ci_used + 1));
@@ -250,10 +273,12 @@ static void checkstacksizes (lua_State *L, StkId max) {
       2*(BASIC_STACK_SIZE+EXTRA_STACK) < L->stacksize)
     luaD_reallocstack(L, L->stacksize/2);  /* still big enough... */
   condhardstacktests(luaD_reallocstack(L, s_used));
+  __A_VARIABLE = 1;
 }
 
 
 static void traversestack (global_State *g, lua_State *l) {
+  volatile int __A_VARIABLE;
   StkId o, lim;
   CallInfo *ci;
   markvalue(g, gt(l));
@@ -267,6 +292,7 @@ static void traversestack (global_State *g, lua_State *l) {
   for (; o <= lim; o++)
     setnilvalue(o);
   checkstacksizes(l, lim);
+  __A_VARIABLE = 1;
 }
 
 
@@ -275,6 +301,7 @@ static void traversestack (global_State *g, lua_State *l) {
 ** Returns `quantity' traversed.
 */
 static l_mem propagatemark (global_State *g) {
+  volatile int __A_VARIABLE;
   GCObject *o = g->gray;
   lua_assert(isgray(o));
   gray2black(o);
@@ -284,6 +311,7 @@ static l_mem propagatemark (global_State *g) {
       g->gray = h->gclist;
       if (traversetable(g, h))  /* table is weak? */
         black2gray(o);  /* keep it gray */
+      __A_VARIABLE = 1;
       return sizeof(Table) + sizeof(TValue) * h->sizearray +
                              sizeof(Node) * sizenode(h);
     }
@@ -291,6 +319,7 @@ static l_mem propagatemark (global_State *g) {
       Closure *cl = gco2cl(o);
       g->gray = cl->c.gclist;
       traverseclosure(g, cl);
+      __A_VARIABLE = 1;
       return (cl->c.isC) ? sizeCclosure(cl->c.nupvalues) :
                            sizeLclosure(cl->l.nupvalues);
     }
@@ -301,6 +330,7 @@ static l_mem propagatemark (global_State *g) {
       g->grayagain = o;
       black2gray(o);
       traversestack(g, th);
+      __A_VARIABLE = 1;
       return sizeof(lua_State) + sizeof(TValue) * th->stacksize +
                                  sizeof(CallInfo) * th->size_ci;
     }
@@ -308,6 +338,7 @@ static l_mem propagatemark (global_State *g) {
       Proto *p = gco2p(o);
       g->gray = p->gclist;
       traverseproto(g, p);
+      __A_VARIABLE = 1;
       return sizeof(Proto) + sizeof(Instruction) * p->sizecode +
                              sizeof(Proto *) * p->sizep +
                              sizeof(TValue) * p->sizek + 
@@ -315,14 +346,17 @@ static l_mem propagatemark (global_State *g) {
                              sizeof(LocVar) * p->sizelocvars +
                              sizeof(TString *) * p->sizeupvalues;
     }
-    default: lua_assert(0); return 0;
+    default: lua_assert(0); __A_VARIABLE = 1;
+    return 0;
   }
 }
 
 
 static size_t propagateall (global_State *g) {
+  volatile int __A_VARIABLE;
   size_t m = 0;
   while (g->gray) m += propagatemark(g);
+  __A_VARIABLE = 1;
   return m;
 }
 
@@ -335,11 +369,17 @@ static size_t propagateall (global_State *g) {
 ** being finalized, keep them in keys, but not in values
 */
 static int iscleared (const TValue *o, int iskey) {
-  if (!iscollectable(o)) return 0;
+  volatile int __A_VARIABLE;
+  if (!iscollectable(o)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (ttisstring(o)) {
     stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return iswhite(gcvalue(o)) ||
     (ttisuserdata(o) && (!iskey && isfinalized(uvalue(o))));
 }
@@ -349,6 +389,7 @@ static int iscleared (const TValue *o, int iskey) {
 ** clear collected entries from weaktables
 */
 static void cleartable (GCObject *l) {
+  volatile int __A_VARIABLE;
   while (l) {
     Table *h = gco2h(l);
     int i = h->sizearray;
@@ -372,10 +413,12 @@ static void cleartable (GCObject *l) {
     }
     l = h->gclist;
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void freeobj (lua_State *L, GCObject *o) {
+  volatile int __A_VARIABLE;
   switch (o->gch.tt) {
     case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
     case LUA_TFUNCTION: luaF_freeclosure(L, gco2cl(o)); break;
@@ -397,6 +440,7 @@ static void freeobj (lua_State *L, GCObject *o) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -405,6 +449,7 @@ static void freeobj (lua_State *L, GCObject *o) {
 
 
 static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
+  volatile int __A_VARIABLE;
   GCObject *curr;
   global_State *g = G(L);
   int deadmask = otherwhite(g);
@@ -424,11 +469,13 @@ static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
       freeobj(L, curr);
     }
   }
+  __A_VARIABLE = 1;
   return p;
 }
 
 
 static void checkSizes (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   /* check size of string hash */
   if (g->strt.nuse < cast(lu_int32, g->strt.size/4) &&
@@ -439,10 +486,12 @@ static void checkSizes (lua_State *L) {
     size_t newsize = luaZ_sizebuffer(&g->buff) / 2;
     luaZ_resizebuffer(L, &g->buff, newsize);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void GCTM (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   GCObject *o = g->tmudata->gch.next;  /* get first element */
   Udata *udata = rawgco2u(o);
@@ -468,6 +517,7 @@ static void GCTM (lua_State *L) {
     L->allowhook = oldah;  /* restore hooks */
     g->GCthreshold = oldt;  /* restore threshold */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -475,30 +525,37 @@ static void GCTM (lua_State *L) {
 ** Call all GC tag methods
 */
 void luaC_callGCTM (lua_State *L) {
+  volatile int __A_VARIABLE;
   while (G(L)->tmudata)
     GCTM(L);
+  __A_VARIABLE = 1;
 }
 
 
 void luaC_freeall (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   int i;
   g->currentwhite = WHITEBITS | bitmask(SFIXEDBIT);  /* mask to collect all elements */
   sweepwholelist(L, &g->rootgc);
   for (i = 0; i < g->strt.size; i++)  /* free all string lists */
     sweepwholelist(L, &g->strt.hash[i]);
+  __A_VARIABLE = 1;
 }
 
 
 static void markmt (global_State *g) {
+  volatile int __A_VARIABLE;
   int i;
   for (i=0; i<NUM_TAGS; i++)
     if (g->mt[i]) markobject(g, g->mt[i]);
+  __A_VARIABLE = 1;
 }
 
 
 /* mark root set */
 static void markroot (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   g->gray = NULL;
   g->grayagain = NULL;
@@ -509,20 +566,24 @@ static void markroot (lua_State *L) {
   markvalue(g, registry(L));
   markmt(g);
   g->gcstate = GCSpropagate;
+  __A_VARIABLE = 1;
 }
 
 
 static void remarkupvals (global_State *g) {
+  volatile int __A_VARIABLE;
   UpVal *uv;
   for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
     lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
     if (isgray(obj2gco(uv)))
       markvalue(g, uv->v);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void atomic (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   size_t udsize;  /* total size of userdata to be finalized */
   /* remark occasional upvalues of (maybe) dead threads */
@@ -550,6 +611,7 @@ static void atomic (lua_State *L) {
   g->sweepgc = &g->rootgc;
   g->gcstate = GCSsweepstring;
   g->estimate = g->totalbytes - udsize;  /* first estimate */
+  __A_VARIABLE = 1;
 }
 
 
@@ -608,6 +670,7 @@ static l_mem singlestep (lua_State *L) {
 
 
 void luaC_step (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   l_mem lim = (GCSTEPSIZE/100) * g->gcstepmul;
   if (lim == 0)
@@ -629,10 +692,12 @@ void luaC_step (lua_State *L) {
   else {
     setthreshold(g);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaC_fullgc (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   if (g->gcstate <= GCSpropagate) {
     /* reset sweep marks to sweep all elements (returning them to white) */
@@ -655,10 +720,12 @@ void luaC_fullgc (lua_State *L) {
     singlestep(L);
   }
   setthreshold(g);
+  __A_VARIABLE = 1;
 }
 
 
 void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
   lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
@@ -668,10 +735,12 @@ void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
     reallymarkobject(g, v);  /* restore invariant */
   else  /* don't mind */
     makewhite(g, o);  /* mark as white just to avoid other barriers */
+    __A_VARIABLE = 1;
 }
 
 
 void luaC_barrierback (lua_State *L, Table *t) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   GCObject *o = obj2gco(t);
   lua_assert(isblack(o) && !isdead(g, o));
@@ -679,19 +748,23 @@ void luaC_barrierback (lua_State *L, Table *t) {
   black2gray(o);  /* make table gray (again) */
   t->gclist = g->grayagain;
   g->grayagain = o;
+  __A_VARIABLE = 1;
 }
 
 
 void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   o->gch.next = g->rootgc;
   g->rootgc = o;
   o->gch.marked = luaC_white(g);
   o->gch.tt = tt;
+  __A_VARIABLE = 1;
 }
 
 
 void luaC_linkupval (lua_State *L, UpVal *uv) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   GCObject *o = obj2gco(uv);
   o->gch.next = g->rootgc;  /* link upvalue into `rootgc' list */
@@ -706,5 +779,6 @@ void luaC_linkupval (lua_State *L, UpVal *uv) {
       lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
     }
   }
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/linit.c b/deps/lua/src/linit.c
index c1f90df..46a34d4 100644
--- a/deps/lua/src/linit.c
+++ b/deps/lua/src/linit.c
@@ -28,11 +28,13 @@ static const luaL_Reg lualibs[] = {
 
 
 LUALIB_API void luaL_openlibs (lua_State *L) {
+  volatile int __A_VARIABLE;
   const luaL_Reg *lib = lualibs;
   for (; lib->func; lib++) {
     lua_pushcfunction(L, lib->func);
     lua_pushstring(L, lib->name);
     lua_call(L, 1, 0);
   }
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/liolib.c b/deps/lua/src/liolib.c
index 649f9a5..d5f9bea 100644
--- a/deps/lua/src/liolib.c
+++ b/deps/lua/src/liolib.c
@@ -46,8 +46,10 @@ static int pushresult (lua_State *L, int i, const char *filename) {
 
 
 static void fileerror (lua_State *L, int arg, const char *filename) {
+  volatile int __A_VARIABLE;
   lua_pushfstring(L, "%s: %s", filename, strerror(errno));
   luaL_argerror(L, arg, lua_tostring(L, -1));
+  __A_VARIABLE = 1;
 }
 
 
@@ -55,6 +57,7 @@ static void fileerror (lua_State *L, int arg, const char *filename) {
 
 
 static int io_type (lua_State *L) {
+  volatile int __A_VARIABLE;
   void *ud;
   luaL_checkany(L, 1);
   ud = lua_touserdata(L, 1);
@@ -65,14 +68,17 @@ static int io_type (lua_State *L) {
     lua_pushliteral(L, "closed file");
   else
     lua_pushliteral(L, "file");
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static FILE *tofile (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE **f = tofilep(L);
   if (*f == NULL)
     luaL_error(L, "attempt to use a closed file");
+  __A_VARIABLE = 1;
   return *f;
 }
 
@@ -84,10 +90,12 @@ static FILE *tofile (lua_State *L) {
 ** file is not left opened.
 */
 static FILE **newfile (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
   *pf = NULL;  /* file handle is currently `closed' */
   luaL_getmetatable(L, LUA_FILEHANDLE);
   lua_setmetatable(L, -2);
+  __A_VARIABLE = 1;
   return pf;
 }
 
@@ -96,8 +104,10 @@ static FILE **newfile (lua_State *L) {
 ** function to (not) close the standard files stdin, stdout, and stderr
 */
 static int io_noclose (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnil(L);
   lua_pushliteral(L, "cannot close standard file");
+  __A_VARIABLE = 1;
   return 2;
 }
 
@@ -106,9 +116,11 @@ static int io_noclose (lua_State *L) {
 ** function to close 'popen' files
 */
 static int io_pclose (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE **p = tofilep(L);
   int ok = lua_pclose(L, *p);
   *p = NULL;
+  __A_VARIABLE = 1;
   return pushresult(L, ok, NULL);
 }
 
@@ -117,52 +129,64 @@ static int io_pclose (lua_State *L) {
 ** function to close regular files
 */
 static int io_fclose (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE **p = tofilep(L);
   int ok = (fclose(*p) == 0);
   *p = NULL;
+  __A_VARIABLE = 1;
   return pushresult(L, ok, NULL);
 }
 
 
 static int aux_close (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_getfenv(L, 1);
   lua_getfield(L, -1, "__close");
+  __A_VARIABLE = 1;
   return (lua_tocfunction(L, -1))(L);
 }
 
 
 static int io_close (lua_State *L) {
+  volatile int __A_VARIABLE;
   if (lua_isnone(L, 1))
     lua_rawgeti(L, LUA_ENVIRONINDEX, IO_OUTPUT);
   tofile(L);  /* make sure argument is a file */
+  __A_VARIABLE = 1;
   return aux_close(L);
 }
 
 
 static int io_gc (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE *f = *tofilep(L);
   /* ignore closed files */
   if (f != NULL)
     aux_close(L);
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int io_tostring (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE *f = *tofilep(L);
   if (f == NULL)
     lua_pushliteral(L, "file (closed)");
   else
     lua_pushfstring(L, "file (%p)", f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int io_open (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, "r");
   FILE **pf = newfile(L);
   *pf = fopen(filename, mode);
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
@@ -172,32 +196,39 @@ static int io_open (lua_State *L) {
 ** correct __close for 'popen' files
 */
 static int io_popen (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *filename = luaL_checkstring(L, 1);
   const char *mode = luaL_optstring(L, 2, "r");
   FILE **pf = newfile(L);
   *pf = lua_popen(L, filename, mode);
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
 
 static int io_tmpfile (lua_State *L) {
+  volatile int __A_VARIABLE;
   FILE **pf = newfile(L);
   *pf = tmpfile();
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
 }
 
 
 static FILE *getiofile (lua_State *L, int findex) {
+  volatile int __A_VARIABLE;
   FILE *f;
   lua_rawgeti(L, LUA_ENVIRONINDEX, findex);
   f = *(FILE **)lua_touserdata(L, -1);
   if (f == NULL)
     luaL_error(L, "standard %s file is closed", fnames[findex - 1]);
+  __A_VARIABLE = 1;
   return f;
 }
 
 
 static int g_iofile (lua_State *L, int f, const char *mode) {
+  volatile int __A_VARIABLE;
   if (!lua_isnoneornil(L, 1)) {
     const char *filename = lua_tostring(L, 1);
     if (filename) {
@@ -214,16 +245,21 @@ static int g_iofile (lua_State *L, int f, const char *mode) {
   }
   /* return current value */
   lua_rawgeti(L, LUA_ENVIRONINDEX, f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int io_input (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_iofile(L, IO_INPUT, "r");
 }
 
 
 static int io_output (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_iofile(L, IO_OUTPUT, "w");
 }
 
@@ -232,15 +268,19 @@ static int io_readline (lua_State *L);
 
 
 static void aux_lines (lua_State *L, int idx, int toclose) {
+  volatile int __A_VARIABLE;
   lua_pushvalue(L, idx);
   lua_pushboolean(L, toclose);  /* close/not close file when finished */
   lua_pushcclosure(L, io_readline, 2);
+  __A_VARIABLE = 1;
 }
 
 
 static int f_lines (lua_State *L) {
+  volatile int __A_VARIABLE;
   tofile(L);  /* check that it's a valid file handle */
   aux_lines(L, 1, 0);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -284,9 +324,11 @@ static int read_number (lua_State *L, FILE *f) {
 
 
 static int test_eof (lua_State *L, FILE *f) {
+  volatile int __A_VARIABLE;
   int c = getc(f);
   ungetc(c, f);
   lua_pushlstring(L, NULL, 0);
+  __A_VARIABLE = 1;
   return (c != EOF);
 }
 
@@ -314,6 +356,7 @@ static int read_line (lua_State *L, FILE *f) {
 
 
 static int read_chars (lua_State *L, FILE *f, size_t n) {
+  volatile int __A_VARIABLE;
   size_t rlen;  /* how much to read */
   size_t nr;  /* number of chars actually read */
   luaL_Buffer b;
@@ -327,6 +370,7 @@ static int read_chars (lua_State *L, FILE *f, size_t n) {
     n -= nr;  /* still have to read `n' chars */
   } while (n > 0 && nr == rlen);  /* until end of count or eof */
   luaL_pushresult(&b);  /* close buffer */
+  __A_VARIABLE = 1;
   return (n == 0 || lua_objlen(L, -1) > 0);
 }
 
@@ -379,11 +423,15 @@ static int g_read (lua_State *L, FILE *f, int first) {
 
 
 static int io_read (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_read(L, getiofile(L, IO_INPUT), 1);
 }
 
 
 static int f_read (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_read(L, tofile(L), 2);
 }
 
@@ -411,6 +459,7 @@ static int io_readline (lua_State *L) {
 
 
 static int g_write (lua_State *L, FILE *f, int arg) {
+  volatile int __A_VARIABLE;
   int nargs = lua_gettop(L) - 1;
   int status = 1;
   for (; nargs--; arg++) {
@@ -425,16 +474,21 @@ static int g_write (lua_State *L, FILE *f, int arg) {
       status = status && (fwrite(s, sizeof(char), l, f) == l);
     }
   }
+  __A_VARIABLE = 1;
   return pushresult(L, status, NULL);
 }
 
 
 static int io_write (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_write(L, getiofile(L, IO_OUTPUT), 1);
 }
 
 
 static int f_write (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return g_write(L, tofile(L), 2);
 }
 
@@ -456,23 +510,29 @@ static int f_seek (lua_State *L) {
 
 
 static int f_setvbuf (lua_State *L) {
+  volatile int __A_VARIABLE;
   static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
   static const char *const modenames[] = {"no", "full", "line", NULL};
   FILE *f = tofile(L);
   int op = luaL_checkoption(L, 2, NULL, modenames);
   lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
   int res = setvbuf(f, NULL, mode[op], sz);
+  __A_VARIABLE = 1;
   return pushresult(L, res == 0, NULL);
 }
 
 
 
 static int io_flush (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
 }
 
 
 static int f_flush (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return pushresult(L, fflush(tofile(L)) == 0, NULL);
 }
 
@@ -508,14 +568,17 @@ static const luaL_Reg flib[] = {
 
 
 static void createmeta (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
   lua_pushvalue(L, -1);  /* push metatable */
   lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
   luaL_register(L, NULL, flib);  /* file methods */
+  __A_VARIABLE = 1;
 }
 
 
 static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {
+  volatile int __A_VARIABLE;
   *newfile(L) = f;
   if (k > 0) {
     lua_pushvalue(L, -1);
@@ -524,17 +587,21 @@ static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {
   lua_pushvalue(L, -2);  /* copy environment */
   lua_setfenv(L, -2);  /* set it */
   lua_setfield(L, -3, fname);
+  __A_VARIABLE = 1;
 }
 
 
 static void newfenv (lua_State *L, lua_CFunction cls) {
+  volatile int __A_VARIABLE;
   lua_createtable(L, 0, 1);
   lua_pushcfunction(L, cls);
   lua_setfield(L, -2, "__close");
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API int luaopen_io (lua_State *L) {
+  volatile int __A_VARIABLE;
   createmeta(L);
   /* create (private) environment (with fields IO_INPUT, IO_OUTPUT, __close) */
   newfenv(L, io_fclose);
@@ -551,6 +618,7 @@ LUALIB_API int luaopen_io (lua_State *L) {
   newfenv(L, io_pclose);  /* create environment for 'popen' */
   lua_setfenv(L, -2);  /* set fenv for 'popen' */
   lua_pop(L, 1);  /* pop 'popen' */
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/lmathlib.c b/deps/lua/src/lmathlib.c
index 441fbf7..6235fc7 100644
--- a/deps/lua/src/lmathlib.c
+++ b/deps/lua/src/lmathlib.c
@@ -24,133 +24,182 @@
 
 
 static int math_abs (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_sin (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, sin(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_sinh (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, sinh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_cos (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, cos(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_cosh (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, cosh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_tan (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, tan(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_tanh (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, tanh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_asin (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, asin(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_acos (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, acos(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_atan (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, atan(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_atan2 (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_ceil (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_floor (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_fmod (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_modf (lua_State *L) {
+  volatile int __A_VARIABLE;
   double ip;
   double fp = modf(luaL_checknumber(L, 1), &ip);
   lua_pushnumber(L, ip);
   lua_pushnumber(L, fp);
+  __A_VARIABLE = 1;
   return 2;
 }
 
 static int math_sqrt (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_pow (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_log (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_log10 (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_exp (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_deg (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_rad (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_frexp (lua_State *L) {
+  volatile int __A_VARIABLE;
   int e;
   lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &e));
   lua_pushinteger(L, e);
+  __A_VARIABLE = 1;
   return 2;
 }
 
 static int math_ldexp (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 
 static int math_min (lua_State *L) {
+  volatile int __A_VARIABLE;
   int n = lua_gettop(L);  /* number of arguments */
   lua_Number dmin = luaL_checknumber(L, 1);
   int i;
@@ -160,11 +209,13 @@ static int math_min (lua_State *L) {
       dmin = d;
   }
   lua_pushnumber(L, dmin);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int math_max (lua_State *L) {
+  volatile int __A_VARIABLE;
   int n = lua_gettop(L);  /* number of arguments */
   lua_Number dmax = luaL_checknumber(L, 1);
   int i;
@@ -174,11 +225,13 @@ static int math_max (lua_State *L) {
       dmax = d;
   }
   lua_pushnumber(L, dmax);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int math_random (lua_State *L) {
+  volatile int __A_VARIABLE;
   /* the `%' avoids the (rare) case of r==1, and is needed also because on
      some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
   lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
@@ -200,14 +253,18 @@ static int math_random (lua_State *L) {
       lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
       break;
     }
-    default: return luaL_error(L, "wrong number of arguments");
+    default: __A_VARIABLE = 1;
+    return luaL_error(L, "wrong number of arguments");
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int math_randomseed (lua_State *L) {
+  volatile int __A_VARIABLE;
   srand(luaL_checkint(L, 1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -249,6 +306,7 @@ static const luaL_Reg mathlib[] = {
 ** Open math library
 */
 LUALIB_API int luaopen_math (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, LUA_MATHLIBNAME, mathlib);
   lua_pushnumber(L, PI);
   lua_setfield(L, -2, "pi");
@@ -258,6 +316,7 @@ LUALIB_API int luaopen_math (lua_State *L) {
   lua_getfield(L, -1, "fmod");
   lua_setfield(L, -2, "mod");
 #endif
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/lmem.c b/deps/lua/src/lmem.c
index ae7d8c9..452a2af 100644
--- a/deps/lua/src/lmem.c
+++ b/deps/lua/src/lmem.c
@@ -45,6 +45,7 @@
 
 void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
                      int limit, const char *errormsg) {
+  volatile int __A_VARIABLE;
   void *newblock;
   int newsize;
   if (*size >= limit/2) {  /* cannot double it? */
@@ -59,12 +60,15 @@ void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
   }
   newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
   *size = newsize;  /* update only when everything else is OK */
+  __A_VARIABLE = 1;
   return newblock;
 }
 
 
 void *luaM_toobig (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaG_runerror(L, "memory allocation error: block too big");
+  __A_VARIABLE = 1;
   return NULL;  /* to avoid warnings */
 }
 
@@ -74,6 +78,7 @@ void *luaM_toobig (lua_State *L) {
 ** generic allocation routine.
 */
 void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   lua_assert((osize == 0) == (block == NULL));
   block = (*g->frealloc)(g->ud, block, osize, nsize);
@@ -81,6 +86,7 @@ void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
     luaD_throw(L, LUA_ERRMEM);
   lua_assert((nsize == 0) == (block == NULL));
   g->totalbytes = (g->totalbytes - osize) + nsize;
+  __A_VARIABLE = 1;
   return block;
 }
 
diff --git a/deps/lua/src/loadlib.c b/deps/lua/src/loadlib.c
index 6158c53..cba7dda 100644
--- a/deps/lua/src/loadlib.c
+++ b/deps/lua/src/loadlib.c
@@ -61,20 +61,26 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
 #include <dlfcn.h>
 
 static void ll_unloadlib (void *lib) {
+  volatile int __A_VARIABLE;
   dlclose(lib);
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   void *lib = dlopen(path, RTLD_NOW);
   if (lib == NULL) lua_pushstring(L, dlerror());
+  __A_VARIABLE = 1;
   return lib;
 }
 
 
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  volatile int __A_VARIABLE;
   lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
   if (f == NULL) lua_pushstring(L, dlerror());
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -95,6 +101,7 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
 #undef setprogdir
 
 static void setprogdir (lua_State *L) {
+  volatile int __A_VARIABLE;
   char buff[MAX_PATH + 1];
   char *lb;
   DWORD nsize = sizeof(buff)/sizeof(char);
@@ -106,10 +113,12 @@ static void setprogdir (lua_State *L) {
     luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);
     lua_remove(L, -2);  /* remove original string */
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void pusherror (lua_State *L) {
+  volatile int __A_VARIABLE;
   int error = GetLastError();
   char buffer[128];
   if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
@@ -117,23 +126,30 @@ static void pusherror (lua_State *L) {
     lua_pushstring(L, buffer);
   else
     lua_pushfstring(L, "system error %d\n", error);
+  __A_VARIABLE = 1;
 }
 
 static void ll_unloadlib (void *lib) {
+  volatile int __A_VARIABLE;
   FreeLibrary((HINSTANCE)lib);
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   HINSTANCE lib = LoadLibraryA(path);
   if (lib == NULL) pusherror(L);
+  __A_VARIABLE = 1;
   return lib;
 }
 
 
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  volatile int __A_VARIABLE;
   lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);
   if (f == NULL) pusherror(L);
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -157,43 +173,55 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
 
 
 static void pusherror (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *err_str;
   const char *err_file;
   NSLinkEditErrors err;
   int err_num;
   NSLinkEditError(&err, &err_num, &err_file, &err_str);
   lua_pushstring(L, err_str);
+  __A_VARIABLE = 1;
 }
 
 
 static const char *errorfromcode (NSObjectFileImageReturnCode ret) {
+  volatile int __A_VARIABLE;
   switch (ret) {
     case NSObjectFileImageInappropriateFile:
+      __A_VARIABLE = 1;
       return "file is not a bundle";
     case NSObjectFileImageArch:
+      __A_VARIABLE = 1;
       return "library is for wrong CPU type";
     case NSObjectFileImageFormat:
+      __A_VARIABLE = 1;
       return "bad format";
     case NSObjectFileImageAccess:
+      __A_VARIABLE = 1;
       return "cannot access file";
     case NSObjectFileImageFailure:
     default:
+      __A_VARIABLE = 1;
       return "unable to load library";
   }
 }
 
 
 static void ll_unloadlib (void *lib) {
+  volatile int __A_VARIABLE;
   NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   NSObjectFileImage img;
   NSObjectFileImageReturnCode ret;
   /* this would be a rare case, but prevents crashing if it happens */
   if(!_dyld_present()) {
     lua_pushliteral(L, "dyld not present");
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = NSCreateObjectFileImageFromFile(path, &img);
@@ -202,19 +230,24 @@ static void *ll_load (lua_State *L, const char *path) {
                        NSLINKMODULE_OPTION_RETURN_ON_ERROR);
     NSDestroyObjectFileImage(img);
     if (mod == NULL) pusherror(L);
+    __A_VARIABLE = 1;
     return mod;
   }
   lua_pushstring(L, errorfromcode(ret));
+  __A_VARIABLE = 1;
   return NULL;
 }
 
 
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  volatile int __A_VARIABLE;
   NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);
   if (nss == NULL) {
     lua_pushfstring(L, "symbol " LUA_QS " not found", sym);
+    __A_VARIABLE = 1;
     return NULL;
   }
+  __A_VARIABLE = 1;
   return (lua_CFunction)NSAddressOfSymbol(nss);
 }
 
@@ -237,20 +270,26 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
 
 
 static void ll_unloadlib (void *lib) {
+  volatile int __A_VARIABLE;
   (void)lib;  /* to avoid warnings */
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   (void)path;  /* to avoid warnings */
   lua_pushliteral(L, DLMSG);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
 
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  volatile int __A_VARIABLE;
   (void)lib; (void)sym;  /* to avoid warnings */
   lua_pushliteral(L, DLMSG);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -260,6 +299,7 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
 
 
 static void **ll_register (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   void **plib;
   lua_pushfstring(L, "%s%s", LIBPREFIX, path);
   lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */
@@ -275,6 +315,7 @@ static void **ll_register (lua_State *L, const char *path) {
     lua_pushvalue(L, -2);
     lua_settable(L, LUA_REGISTRYINDEX);
   }
+  __A_VARIABLE = 1;
   return plib;
 }
 
@@ -284,9 +325,11 @@ static void **ll_register (lua_State *L, const char *path) {
 ** handle
 */
 static int gctm (lua_State *L) {
+  volatile int __A_VARIABLE;
   void **lib = (void **)luaL_checkudata(L, 1, "_LOADLIB");
   if (*lib) ll_unloadlib(*lib);
   *lib = NULL;  /* mark library as closed */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -330,26 +373,37 @@ static int ll_loadlib (lua_State *L) {
 
 
 static int readable (const char *filename) {
+  volatile int __A_VARIABLE;
   FILE *f = fopen(filename, "r");  /* try to open file */
-  if (f == NULL) return 0;  /* open failed */
+  if (f == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* open failed */
   fclose(f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static const char *pushnexttemplate (lua_State *L, const char *path) {
+  volatile int __A_VARIABLE;
   const char *l;
   while (*path == *LUA_PATHSEP) path++;  /* skip separators */
-  if (*path == '\0') return NULL;  /* no more templates */
+  if (*path == '\0') {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no more templates */
   l = strchr(path, *LUA_PATHSEP);  /* find next separator */
   if (l == NULL) l = path + strlen(path);
   lua_pushlstring(L, path, l - path);  /* template */
+  __A_VARIABLE = 1;
   return l;
 }
 
 
 static const char *findfile (lua_State *L, const char *name,
                                            const char *pname) {
+  volatile int __A_VARIABLE;
   const char *path;
   name = luaL_gsub(L, name, ".", LUA_DIRSEP);
   lua_getfield(L, LUA_ENVIRONINDEX, pname);
@@ -361,78 +415,105 @@ static const char *findfile (lua_State *L, const char *name,
     const char *filename;
     filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);
     lua_remove(L, -2);  /* remove path template */
-    if (readable(filename))  /* does file exist and is readable? */
-      return filename;  /* return that file name */
+    if (readable(filename))  /* does file exist and is readable? */ {
+      __A_VARIABLE = 1;
+      return filename;
+    }  /* return that file name */
     lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
     lua_remove(L, -2);  /* remove file name */
     lua_concat(L, 2);  /* add entry to possible error message */
   }
+  __A_VARIABLE = 1;
   return NULL;  /* not found */
 }
 
 
 static void loaderror (lua_State *L, const char *filename) {
+  volatile int __A_VARIABLE;
   luaL_error(L, "error loading module " LUA_QS " from file " LUA_QS ":\n\t%s",
                 lua_tostring(L, 1), filename, lua_tostring(L, -1));
+  __A_VARIABLE = 1;
 }
 
 
 static int loader_Lua (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *filename;
   const char *name = luaL_checkstring(L, 1);
   filename = findfile(L, name, "path");
-  if (filename == NULL) return 1;  /* library not found in this path */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* library not found in this path */
   if (luaL_loadfile(L, filename) != 0)
     loaderror(L, filename);
+  __A_VARIABLE = 1;
   return 1;  /* library loaded successfully */
 }
 
 
 static const char *mkfuncname (lua_State *L, const char *modname) {
+  volatile int __A_VARIABLE;
   const char *funcname;
   const char *mark = strchr(modname, *LUA_IGMARK);
   if (mark) modname = mark + 1;
   funcname = luaL_gsub(L, modname, ".", LUA_OFSEP);
   funcname = lua_pushfstring(L, POF"%s", funcname);
   lua_remove(L, -2);  /* remove 'gsub' result */
+  __A_VARIABLE = 1;
   return funcname;
 }
 
 
 static int loader_C (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *funcname;
   const char *name = luaL_checkstring(L, 1);
   const char *filename = findfile(L, name, "cpath");
-  if (filename == NULL) return 1;  /* library not found in this path */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* library not found in this path */
   funcname = mkfuncname(L, name);
   if (ll_loadfunc(L, filename, funcname) != 0)
     loaderror(L, filename);
+  __A_VARIABLE = 1;
   return 1;  /* library loaded successfully */
 }
 
 
 static int loader_Croot (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *funcname;
   const char *filename;
   const char *name = luaL_checkstring(L, 1);
   const char *p = strchr(name, '.');
   int stat;
-  if (p == NULL) return 0;  /* is root */
+  if (p == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* is root */
   lua_pushlstring(L, name, p - name);
   filename = findfile(L, lua_tostring(L, -1), "cpath");
-  if (filename == NULL) return 1;  /* root not found */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* root not found */
   funcname = mkfuncname(L, name);
   if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {
     if (stat != ERRFUNC) loaderror(L, filename);  /* real error */
     lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
                        name, filename);
+    __A_VARIABLE = 1;
     return 1;  /* function not found */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int loader_preload (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *name = luaL_checkstring(L, 1);
   lua_getfield(L, LUA_ENVIRONINDEX, "preload");
   if (!lua_istable(L, -1))
@@ -440,6 +521,7 @@ static int loader_preload (lua_State *L) {
   lua_getfield(L, -1, name);
   if (lua_isnil(L, -1))  /* not found? */
     lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -449,6 +531,7 @@ static const int sentinel_ = 0;
 
 
 static int ll_require (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *name = luaL_checkstring(L, 1);
   int i;
   lua_settop(L, 1);  /* _LOADED table will be at index 2 */
@@ -457,6 +540,7 @@ static int ll_require (lua_State *L) {
   if (lua_toboolean(L, -1)) {  /* is it there? */
     if (lua_touserdata(L, -1) == sentinel)  /* check loops */
       luaL_error(L, "loop or previous error loading module " LUA_QS, name);
+    __A_VARIABLE = 1;
     return 1;  /* package is already loaded */
   }
   /* else must load it; iterate over available loaders */
@@ -490,6 +574,7 @@ static int ll_require (lua_State *L) {
     lua_pushvalue(L, -1);  /* extra copy to be returned */
     lua_setfield(L, 2, name);  /* _LOADED[name] = true */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -505,6 +590,7 @@ static int ll_require (lua_State *L) {
   
 
 static void setfenv (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_Debug ar;
   if (lua_getstack(L, 1, &ar) == 0 ||
       lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
@@ -513,20 +599,24 @@ static void setfenv (lua_State *L) {
   lua_pushvalue(L, -2);
   lua_setfenv(L, -2);
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
 }
 
 
 static void dooptions (lua_State *L, int n) {
+  volatile int __A_VARIABLE;
   int i;
   for (i = 2; i <= n; i++) {
     lua_pushvalue(L, i);  /* get option (a function) */
     lua_pushvalue(L, -2);  /* module */
     lua_call(L, 1, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void modinit (lua_State *L, const char *modname) {
+  volatile int __A_VARIABLE;
   const char *dot;
   lua_pushvalue(L, -1);
   lua_setfield(L, -2, "_M");  /* module._M = module */
@@ -538,10 +628,12 @@ static void modinit (lua_State *L, const char *modname) {
   /* set _PACKAGE as package name (full module name minus last part) */
   lua_pushlstring(L, modname, dot - modname);
   lua_setfield(L, -2, "_PACKAGE");
+  __A_VARIABLE = 1;
 }
 
 
 static int ll_module (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *modname = luaL_checkstring(L, 1);
   int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */
   lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
@@ -549,8 +641,10 @@ static int ll_module (lua_State *L) {
   if (!lua_istable(L, -1)) {  /* not found? */
     lua_pop(L, 1);  /* remove previous result */
     /* try global variable (and create one if it does not exist) */
-    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)
+    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL) {
+      __A_VARIABLE = 1;
       return luaL_error(L, "name conflict for module " LUA_QS, modname);
+    }
     lua_pushvalue(L, -1);
     lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */
   }
@@ -565,11 +659,13 @@ static int ll_module (lua_State *L) {
   lua_pushvalue(L, -1);
   setfenv(L);
   dooptions(L, loaded - 1);
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int ll_seeall (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   if (!lua_getmetatable(L, 1)) {
     lua_createtable(L, 0, 1); /* create new metatable */
@@ -578,6 +674,7 @@ static int ll_seeall (lua_State *L) {
   }
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -591,6 +688,7 @@ static int ll_seeall (lua_State *L) {
 
 static void setpath (lua_State *L, const char *fieldname, const char *envname,
                                    const char *def) {
+  volatile int __A_VARIABLE;
   const char *path = getenv(envname);
   if (path == NULL)  /* no environment variable? */
     lua_pushstring(L, def);  /* use default */
@@ -603,6 +701,7 @@ static void setpath (lua_State *L, const char *fieldname, const char *envname,
   }
   setprogdir(L);
   lua_setfield(L, -2, fieldname);
+  __A_VARIABLE = 1;
 }
 
 
@@ -625,6 +724,7 @@ static const lua_CFunction loaders[] =
 
 
 LUALIB_API int luaopen_package (lua_State *L) {
+  volatile int __A_VARIABLE;
   int i;
   /* create new type _LOADLIB */
   luaL_newmetatable(L, "_LOADLIB");
@@ -661,6 +761,7 @@ LUALIB_API int luaopen_package (lua_State *L) {
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   luaL_register(L, NULL, ll_funcs);  /* open lib into global table */
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
   return 1;  /* return 'package' table */
 }
 
diff --git a/deps/lua/src/lobject.c b/deps/lua/src/lobject.c
index 4ff5073..700c290 100644
--- a/deps/lua/src/lobject.c
+++ b/deps/lua/src/lobject.c
@@ -52,6 +52,7 @@ int luaO_fb2int (int x) {
 
 
 int luaO_log2 (unsigned int x) {
+  volatile int __A_VARIABLE;
   static const lu_byte log_2[256] = {
     0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
     6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
@@ -64,6 +65,7 @@ int luaO_log2 (unsigned int x) {
   };
   int l = -1;
   while (x >= 256) { l += 8; x >>= 8; }
+  __A_VARIABLE = 1;
   return l + log_2[x];
 
 }
@@ -88,27 +90,41 @@ int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
 
 
 int luaO_str2d (const char *s, lua_Number *result) {
+  volatile int __A_VARIABLE;
   char *endptr;
   *result = lua_str2number(s, &endptr);
-  if (endptr == s) return 0;  /* conversion failed */
+  if (endptr == s) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* conversion failed */
   if (*endptr == 'x' || *endptr == 'X')  /* maybe an hexadecimal constant? */
     *result = cast_num(strtoul(s, &endptr, 16));
-  if (*endptr == '\0') return 1;  /* most common case */
+  if (*endptr == '\0') {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* most common case */
   while (isspace(cast(unsigned char, *endptr))) endptr++;
-  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  if (*endptr != '\0') {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* invalid trailing characters? */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 
 static void pushstr (lua_State *L, const char *str) {
+  volatile int __A_VARIABLE;
   setsvalue2s(L, L->top, luaS_new(L, str));
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
 /* this function handles only `%d', `%c', %f, %p, and `%s' formats */
 const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  volatile int __A_VARIABLE;
   int n = 1;
   pushstr(L, "");
   for (;;) {
@@ -165,21 +181,25 @@ const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
   pushstr(L, fmt);
   luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);
   L->top -= n;
+  __A_VARIABLE = 1;
   return svalue(L->top - 1);
 }
 
 
 const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  volatile int __A_VARIABLE;
   const char *msg;
   va_list argp;
   va_start(argp, fmt);
   msg = luaO_pushvfstring(L, fmt, argp);
   va_end(argp);
+  __A_VARIABLE = 1;
   return msg;
 }
 
 
 void luaO_chunkid (char *out, const char *source, size_t bufflen) {
+  volatile int __A_VARIABLE;
   if (*source == '=') {
     strncpy(out, source+1, bufflen);  /* remove first char */
     out[bufflen-1] = '\0';  /* ensures null termination */
@@ -211,4 +231,5 @@ void luaO_chunkid (char *out, const char *source, size_t bufflen) {
       strcat(out, "\"]");
     }
   }
+  __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/loslib.c b/deps/lua/src/loslib.c
index da06a57..d6d58b3 100644
--- a/deps/lua/src/loslib.c
+++ b/deps/lua/src/loslib.c
@@ -36,43 +36,57 @@ static int os_pushresult (lua_State *L, int i, const char *filename) {
 
 
 static int os_execute (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushinteger(L, system(luaL_optstring(L, 1, NULL)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_remove (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *filename = luaL_checkstring(L, 1);
+  __A_VARIABLE = 1;
   return os_pushresult(L, remove(filename) == 0, filename);
 }
 
 
 static int os_rename (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *fromname = luaL_checkstring(L, 1);
   const char *toname = luaL_checkstring(L, 2);
+  __A_VARIABLE = 1;
   return os_pushresult(L, rename(fromname, toname) == 0, fromname);
 }
 
 
 static int os_tmpname (lua_State *L) {
+  volatile int __A_VARIABLE;
   char buff[LUA_TMPNAMBUFSIZE];
   int err;
   lua_tmpnam(buff, err);
-  if (err)
+  if (err) {
+    __A_VARIABLE = 1;
     return luaL_error(L, "unable to generate a unique filename");
+  }
   lua_pushstring(L, buff);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_getenv (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_clock (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -86,22 +100,30 @@ static int os_clock (lua_State *L) {
 */
 
 static void setfield (lua_State *L, const char *key, int value) {
+  volatile int __A_VARIABLE;
   lua_pushinteger(L, value);
   lua_setfield(L, -2, key);
+  __A_VARIABLE = 1;
 }
 
 static void setboolfield (lua_State *L, const char *key, int value) {
-  if (value < 0)  /* undefined? */
-    return;  /* does not set field */
+  volatile int __A_VARIABLE;
+  if (value < 0)  /* undefined? */ {
+    __A_VARIABLE = 1;
+    return;
+  }  /* does not set field */
   lua_pushboolean(L, value);
   lua_setfield(L, -2, key);
+  __A_VARIABLE = 1;
 }
 
 static int getboolfield (lua_State *L, const char *key) {
+  volatile int __A_VARIABLE;
   int res;
   lua_getfield(L, -1, key);
   res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -122,6 +144,7 @@ static int getfield (lua_State *L, const char *key, int d) {
 
 
 static int os_date (lua_State *L) {
+  volatile int __A_VARIABLE;
   const char *s = luaL_optstring(L, 1, "%c");
   time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
   struct tm *stm;
@@ -163,11 +186,13 @@ static int os_date (lua_State *L) {
     }
     luaL_pushresult(&b);
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_time (lua_State *L) {
+  volatile int __A_VARIABLE;
   time_t t;
   if (lua_isnoneornil(L, 1))  /* called without args? */
     t = time(NULL);  /* get current time */
@@ -188,13 +213,16 @@ static int os_time (lua_State *L) {
     lua_pushnil(L);
   else
     lua_pushnumber(L, (lua_Number)t);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_difftime (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
                              (time_t)(luaL_optnumber(L, 2, 0))));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -202,6 +230,7 @@ static int os_difftime (lua_State *L) {
 
 
 static int os_setlocale (lua_State *L) {
+  volatile int __A_VARIABLE;
   static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
                       LC_NUMERIC, LC_TIME};
   static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
@@ -209,12 +238,15 @@ static int os_setlocale (lua_State *L) {
   const char *l = luaL_optstring(L, 1, NULL);
   int op = luaL_checkoption(L, 2, "all", catnames);
   lua_pushstring(L, setlocale(cat[op], l));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_exit (lua_State *L) {
+  volatile int __A_VARIABLE;
   exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  __A_VARIABLE = 1;
 }
 
 static const luaL_Reg syslib[] = {
@@ -237,7 +269,9 @@ static const luaL_Reg syslib[] = {
 
 
 LUALIB_API int luaopen_os (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, LUA_OSLIBNAME, syslib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/lparser.c b/deps/lua/src/lparser.c
index dda7488..a46afd4 100644
--- a/deps/lua/src/lparser.c
+++ b/deps/lua/src/lparser.c
@@ -55,25 +55,31 @@ static void expr (LexState *ls, expdesc *v);
 
 
 static void anchor_token (LexState *ls) {
+  volatile int __A_VARIABLE;
   if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
     TString *ts = ls->t.seminfo.ts;
     luaX_newstring(ls, getstr(ts), ts->tsv.len);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void error_expected (LexState *ls, int token) {
+  volatile int __A_VARIABLE;
   luaX_syntaxerror(ls,
       luaO_pushfstring(ls->L, LUA_QS " expected", luaX_token2str(ls, token)));
+  __A_VARIABLE = 1;
 }
 
 
 static void errorlimit (FuncState *fs, int limit, const char *what) {
+  volatile int __A_VARIABLE;
   const char *msg = (fs->f->linedefined == 0) ?
     luaO_pushfstring(fs->L, "main function has more than %d %s", limit, what) :
     luaO_pushfstring(fs->L, "function at line %d has more than %d %s",
                             fs->f->linedefined, limit, what);
   luaX_lexerror(fs->ls, msg, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -87,13 +93,17 @@ static int testnext (LexState *ls, int c) {
 
 
 static void check (LexState *ls, int c) {
+  volatile int __A_VARIABLE;
   if (ls->t.token != c)
     error_expected(ls, c);
+  __A_VARIABLE = 1;
 }
 
 static void checknext (LexState *ls, int c) {
+  volatile int __A_VARIABLE;
   check(ls, c);
   luaX_next(ls);
+  __A_VARIABLE = 1;
 }
 
 
@@ -102,6 +112,7 @@ static void checknext (LexState *ls, int c) {
 
 
 static void check_match (LexState *ls, int what, int who, int where) {
+  volatile int __A_VARIABLE;
   if (!testnext(ls, what)) {
     if (where == ls->linenumber)
       error_expected(ls, what);
@@ -111,36 +122,46 @@ static void check_match (LexState *ls, int what, int who, int where) {
               luaX_token2str(ls, what), luaX_token2str(ls, who), where));
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static TString *str_checkname (LexState *ls) {
+  volatile int __A_VARIABLE;
   TString *ts;
   check(ls, TK_NAME);
   ts = ls->t.seminfo.ts;
   luaX_next(ls);
+  __A_VARIABLE = 1;
   return ts;
 }
 
 
 static void init_exp (expdesc *e, expkind k, int i) {
+  volatile int __A_VARIABLE;
   e->f = e->t = NO_JUMP;
   e->k = k;
   e->u.s.info = i;
+  __A_VARIABLE = 1;
 }
 
 
 static void codestring (LexState *ls, expdesc *e, TString *s) {
+  volatile int __A_VARIABLE;
   init_exp(e, VK, luaK_stringK(ls->fs, s));
+  __A_VARIABLE = 1;
 }
 
 
 static void checkname(LexState *ls, expdesc *e) {
+  volatile int __A_VARIABLE;
   codestring(ls, e, str_checkname(ls));
+  __A_VARIABLE = 1;
 }
 
 
 static int registerlocalvar (LexState *ls, TString *varname) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
   int oldsize = f->sizelocvars;
@@ -149,6 +170,7 @@ static int registerlocalvar (LexState *ls, TString *varname) {
   while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
   f->locvars[fs->nlocvars].varname = varname;
   luaC_objbarrier(ls->L, f, varname);
+  __A_VARIABLE = 1;
   return fs->nlocvars++;
 }
 
@@ -158,35 +180,43 @@ static int registerlocalvar (LexState *ls, TString *varname) {
 
 
 static void new_localvar (LexState *ls, TString *name, int n) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
   fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
+  __A_VARIABLE = 1;
 }
 
 
 static void adjustlocalvars (LexState *ls, int nvars) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   fs->nactvar = cast_byte(fs->nactvar + nvars);
   for (; nvars; nvars--) {
     getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void removevars (LexState *ls, int tolevel) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   while (fs->nactvar > tolevel)
     getlocvar(fs, --fs->nactvar).endpc = fs->pc;
+  __A_VARIABLE = 1;
 }
 
 
 static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
+  volatile int __A_VARIABLE;
   int i;
   Proto *f = fs->f;
   int oldsize = f->sizeupvalues;
   for (i=0; i<f->nups; i++) {
     if (fs->upvalues[i].k == v->k && fs->upvalues[i].info == v->u.s.info) {
       lua_assert(f->upvalues[i] == name);
+      __A_VARIABLE = 1;
       return i;
     }
   }
@@ -200,24 +230,31 @@ static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
   lua_assert(v->k == VLOCAL || v->k == VUPVAL);
   fs->upvalues[f->nups].k = cast_byte(v->k);
   fs->upvalues[f->nups].info = cast_byte(v->u.s.info);
+  __A_VARIABLE = 1;
   return f->nups++;
 }
 
 
 static int searchvar (FuncState *fs, TString *n) {
+  volatile int __A_VARIABLE;
   int i;
   for (i=fs->nactvar-1; i >= 0; i--) {
-    if (n == getlocvar(fs, i).varname)
+    if (n == getlocvar(fs, i).varname) {
+      __A_VARIABLE = 1;
       return i;
+    }
   }
+  __A_VARIABLE = 1;
   return -1;  /* not found */
 }
 
 
 static void markupval (FuncState *fs, int level) {
+  volatile int __A_VARIABLE;
   BlockCnt *bl = fs->bl;
   while (bl && bl->nactvar > level) bl = bl->previous;
   if (bl) bl->upval = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -246,14 +283,17 @@ static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
 
 
 static void singlevar (LexState *ls, expdesc *var) {
+  volatile int __A_VARIABLE;
   TString *varname = str_checkname(ls);
   FuncState *fs = ls->fs;
   if (singlevaraux(fs, varname, var, 1) == VGLOBAL)
     var->u.s.info = luaK_stringK(fs, varname);  /* info points to global name */
+  __A_VARIABLE = 1;
 }
 
 
 static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   int extra = nvars - nexps;
   if (hasmultret(e->k)) {
@@ -270,12 +310,15 @@ static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
       luaK_nil(fs, reg, extra);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void enterlevel (LexState *ls) {
+  volatile int __A_VARIABLE;
   if (++ls->L->nCcalls > LUAI_MAXCCALLS)
 	luaX_lexerror(ls, "chunk has too many syntax levels", 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -283,6 +326,7 @@ static void enterlevel (LexState *ls) {
 
 
 static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
+  volatile int __A_VARIABLE;
   bl->breaklist = NO_JUMP;
   bl->isbreakable = isbreakable;
   bl->nactvar = fs->nactvar;
@@ -290,10 +334,12 @@ static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
   bl->previous = fs->bl;
   fs->bl = bl;
   lua_assert(fs->freereg == fs->nactvar);
+  __A_VARIABLE = 1;
 }
 
 
 static void leaveblock (FuncState *fs) {
+  volatile int __A_VARIABLE;
   BlockCnt *bl = fs->bl;
   fs->bl = bl->previous;
   removevars(fs->ls, bl->nactvar);
@@ -304,10 +350,12 @@ static void leaveblock (FuncState *fs) {
   lua_assert(bl->nactvar == fs->nactvar);
   fs->freereg = fs->nactvar;  /* free registers */
   luaK_patchtohere(fs, bl->breaklist);
+  __A_VARIABLE = 1;
 }
 
 
 static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
   int oldsize = f->sizep;
@@ -322,10 +370,12 @@ static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
     OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
     luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void open_func (LexState *ls, FuncState *fs) {
+  volatile int __A_VARIABLE;
   lua_State *L = ls->L;
   Proto *f = luaF_newproto(L);
   fs->f = f;
@@ -350,10 +400,12 @@ static void open_func (LexState *ls, FuncState *fs) {
   incr_top(L);
   setptvalue2s(L, L->top, f);
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
 static void close_func (LexState *ls) {
+  volatile int __A_VARIABLE;
   lua_State *L = ls->L;
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
@@ -377,10 +429,12 @@ static void close_func (LexState *ls) {
   /* last token read was anchored in defunct function; must reanchor it */
   if (fs) anchor_token(ls);
   L->top -= 2;  /* remove table and prototype from the stack */
+  __A_VARIABLE = 1;
 }
 
 
 Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
+  volatile int __A_VARIABLE;
   struct LexState lexstate;
   struct FuncState funcstate;
   lexstate.buff = buff;
@@ -394,6 +448,7 @@ Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
   lua_assert(funcstate.prev == NULL);
   lua_assert(funcstate.f->nups == 0);
   lua_assert(lexstate.fs == NULL);
+  __A_VARIABLE = 1;
   return funcstate.f;
 }
 
@@ -405,6 +460,7 @@ Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
 
 
 static void field (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* field -> ['.' | ':'] NAME */
   FuncState *fs = ls->fs;
   expdesc key;
@@ -412,15 +468,18 @@ static void field (LexState *ls, expdesc *v) {
   luaX_next(ls);  /* skip the dot or colon */
   checkname(ls, &key);
   luaK_indexed(fs, v, &key);
+  __A_VARIABLE = 1;
 }
 
 
 static void yindex (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* index -> '[' expr ']' */
   luaX_next(ls);  /* skip the '[' */
   expr(ls, v);
   luaK_exp2val(ls->fs, v);
   checknext(ls, ']');
+  __A_VARIABLE = 1;
 }
 
 
@@ -441,6 +500,7 @@ struct ConsControl {
 
 
 static void recfield (LexState *ls, struct ConsControl *cc) {
+  volatile int __A_VARIABLE;
   /* recfield -> (NAME | `['exp1`]') = exp1 */
   FuncState *fs = ls->fs;
   int reg = ls->fs->freereg;
@@ -458,22 +518,32 @@ static void recfield (LexState *ls, struct ConsControl *cc) {
   expr(ls, &val);
   luaK_codeABC(fs, OP_SETTABLE, cc->t->u.s.info, rkkey, luaK_exp2RK(fs, &val));
   fs->freereg = reg;  /* free registers */
+  __A_VARIABLE = 1;
 }
 
 
 static void closelistfield (FuncState *fs, struct ConsControl *cc) {
-  if (cc->v.k == VVOID) return;  /* there is no list item */
+  volatile int __A_VARIABLE;
+  if (cc->v.k == VVOID) {
+    __A_VARIABLE = 1;
+    return;
+  }  /* there is no list item */
   luaK_exp2nextreg(fs, &cc->v);
   cc->v.k = VVOID;
   if (cc->tostore == LFIELDS_PER_FLUSH) {
     luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);  /* flush */
     cc->tostore = 0;  /* no more items pending */
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
-  if (cc->tostore == 0) return;
+  volatile int __A_VARIABLE;
+  if (cc->tostore == 0) {
+    __A_VARIABLE = 1;
+    return;
+  }
   if (hasmultret(cc->v.k)) {
     luaK_setmultret(fs, &cc->v);
     luaK_setlist(fs, cc->t->u.s.info, cc->na, LUA_MULTRET);
@@ -484,18 +554,22 @@ static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
       luaK_exp2nextreg(fs, &cc->v);
     luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void listfield (LexState *ls, struct ConsControl *cc) {
+  volatile int __A_VARIABLE;
   expr(ls, &cc->v);
   luaY_checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
   cc->na++;
   cc->tostore++;
+  __A_VARIABLE = 1;
 }
 
 
 static void constructor (LexState *ls, expdesc *t) {
+  volatile int __A_VARIABLE;
   /* constructor -> ?? */
   FuncState *fs = ls->fs;
   int line = ls->linenumber;
@@ -534,6 +608,7 @@ static void constructor (LexState *ls, expdesc *t) {
   lastlistfield(fs, &cc);
   SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
   SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================================== */
@@ -541,6 +616,7 @@ static void constructor (LexState *ls, expdesc *t) {
 
 
 static void parlist (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* parlist -> [ param { `,' param } ] */
   FuncState *fs = ls->fs;
   Proto *f = fs->f;
@@ -570,10 +646,12 @@ static void parlist (LexState *ls) {
   adjustlocalvars(ls, nparams);
   f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));
   luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+  __A_VARIABLE = 1;
 }
 
 
 static void body (LexState *ls, expdesc *e, int needself, int line) {
+  volatile int __A_VARIABLE;
   /* body ->  `(' parlist `)' chunk END */
   FuncState new_fs;
   open_func(ls, &new_fs);
@@ -590,10 +668,12 @@ static void body (LexState *ls, expdesc *e, int needself, int line) {
   check_match(ls, TK_END, TK_FUNCTION, line);
   close_func(ls);
   pushclosure(ls, &new_fs, e);
+  __A_VARIABLE = 1;
 }
 
 
 static int explist1 (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* explist1 -> expr { `,' expr } */
   int n = 1;  /* at least one expression */
   expr(ls, v);
@@ -602,11 +682,13 @@ static int explist1 (LexState *ls, expdesc *v) {
     expr(ls, v);
     n++;
   }
+  __A_VARIABLE = 1;
   return n;
 }
 
 
 static void funcargs (LexState *ls, expdesc *f) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   expdesc args;
   int base, nparams;
@@ -636,6 +718,7 @@ static void funcargs (LexState *ls, expdesc *f) {
     }
     default: {
       luaX_syntaxerror(ls, "function arguments expected");
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -652,6 +735,7 @@ static void funcargs (LexState *ls, expdesc *f) {
   luaK_fixline(fs, line);
   fs->freereg = base+1;  /* call remove function and arguments and leaves
                             (unless changed) one result */
+  __A_VARIABLE = 1;
 }
 
 
@@ -665,6 +749,7 @@ static void funcargs (LexState *ls, expdesc *f) {
 
 
 static void prefixexp (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* prefixexp -> NAME | '(' expr ')' */
   switch (ls->t.token) {
     case '(': {
@@ -673,14 +758,17 @@ static void prefixexp (LexState *ls, expdesc *v) {
       expr(ls, v);
       check_match(ls, ')', '(', line);
       luaK_dischargevars(ls->fs, v);
+      __A_VARIABLE = 1;
       return;
     }
     case TK_NAME: {
       singlevar(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
     default: {
       luaX_syntaxerror(ls, "unexpected symbol");
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -688,6 +776,7 @@ static void prefixexp (LexState *ls, expdesc *v) {
 
 
 static void primaryexp (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* primaryexp ->
         prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
   FuncState *fs = ls->fs;
@@ -718,13 +807,16 @@ static void primaryexp (LexState *ls, expdesc *v) {
         funcargs(ls, v);
         break;
       }
-      default: return;
+      default: __A_VARIABLE = 1;
+      return;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void simpleexp (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* simpleexp -> NUMBER | STRING | NIL | true | false | ... |
                   constructor | FUNCTION body | primaryexp */
   switch (ls->t.token) {
@@ -759,50 +851,76 @@ static void simpleexp (LexState *ls, expdesc *v) {
     }
     case '{': {  /* constructor */
       constructor(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
     case TK_FUNCTION: {
       luaX_next(ls);
       body(ls, v, 0, ls->linenumber);
+      __A_VARIABLE = 1;
       return;
     }
     default: {
       primaryexp(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
   }
   luaX_next(ls);
+  __A_VARIABLE = 1;
 }
 
 
 static UnOpr getunopr (int op) {
+  volatile int __A_VARIABLE;
   switch (op) {
-    case TK_NOT: return OPR_NOT;
-    case '-': return OPR_MINUS;
-    case '#': return OPR_LEN;
-    default: return OPR_NOUNOPR;
+    case TK_NOT: __A_VARIABLE = 1;
+      return OPR_NOT;
+    case '-': __A_VARIABLE = 1;
+      return OPR_MINUS;
+    case '#': __A_VARIABLE = 1;
+      return OPR_LEN;
+    default: __A_VARIABLE = 1;
+    return OPR_NOUNOPR;
   }
 }
 
 
 static BinOpr getbinopr (int op) {
+  volatile int __A_VARIABLE;
   switch (op) {
-    case '+': return OPR_ADD;
-    case '-': return OPR_SUB;
-    case '*': return OPR_MUL;
-    case '/': return OPR_DIV;
-    case '%': return OPR_MOD;
-    case '^': return OPR_POW;
-    case TK_CONCAT: return OPR_CONCAT;
-    case TK_NE: return OPR_NE;
-    case TK_EQ: return OPR_EQ;
-    case '<': return OPR_LT;
-    case TK_LE: return OPR_LE;
-    case '>': return OPR_GT;
-    case TK_GE: return OPR_GE;
-    case TK_AND: return OPR_AND;
-    case TK_OR: return OPR_OR;
-    default: return OPR_NOBINOPR;
+    case '+': __A_VARIABLE = 1;
+      return OPR_ADD;
+    case '-': __A_VARIABLE = 1;
+      return OPR_SUB;
+    case '*': __A_VARIABLE = 1;
+      return OPR_MUL;
+    case '/': __A_VARIABLE = 1;
+      return OPR_DIV;
+    case '%': __A_VARIABLE = 1;
+      return OPR_MOD;
+    case '^': __A_VARIABLE = 1;
+      return OPR_POW;
+    case TK_CONCAT: __A_VARIABLE = 1;
+      return OPR_CONCAT;
+    case TK_NE: __A_VARIABLE = 1;
+      return OPR_NE;
+    case TK_EQ: __A_VARIABLE = 1;
+      return OPR_EQ;
+    case '<': __A_VARIABLE = 1;
+      return OPR_LT;
+    case TK_LE: __A_VARIABLE = 1;
+      return OPR_LE;
+    case '>': __A_VARIABLE = 1;
+      return OPR_GT;
+    case TK_GE: __A_VARIABLE = 1;
+      return OPR_GE;
+    case TK_AND: __A_VARIABLE = 1;
+      return OPR_AND;
+    case TK_OR: __A_VARIABLE = 1;
+      return OPR_OR;
+    default: __A_VARIABLE = 1;
+    return OPR_NOBINOPR;
   }
 }
 
@@ -826,6 +944,7 @@ static const struct {
 ** where `binop' is any binary operator with a priority higher than `limit'
 */
 static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
+  volatile int __A_VARIABLE;
   BinOpr op;
   UnOpr uop;
   enterlevel(ls);
@@ -849,12 +968,15 @@ static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
     op = nextop;
   }
   leavelevel(ls);
+  __A_VARIABLE = 1;
   return op;  /* return first untreated operator */
 }
 
 
 static void expr (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   subexpr(ls, v, 0);
+  __A_VARIABLE = 1;
 }
 
 /* }==================================================================== */
@@ -869,16 +991,20 @@ static void expr (LexState *ls, expdesc *v) {
 
 
 static int block_follow (int token) {
+  volatile int __A_VARIABLE;
   switch (token) {
     case TK_ELSE: case TK_ELSEIF: case TK_END:
     case TK_UNTIL: case TK_EOS:
+      __A_VARIABLE = 1;
       return 1;
-    default: return 0;
+    default: __A_VARIABLE = 1;
+      return 0;
   }
 }
 
 
 static void block (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* block -> chunk */
   FuncState *fs = ls->fs;
   BlockCnt bl;
@@ -886,6 +1012,7 @@ static void block (LexState *ls) {
   chunk(ls);
   lua_assert(bl.breaklist == NO_JUMP);
   leaveblock(fs);
+  __A_VARIABLE = 1;
 }
 
 
@@ -906,6 +1033,7 @@ struct LHS_assign {
 ** assignment.
 */
 static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   int extra = fs->freereg;  /* eventual position to save local variable */
   int conflict = 0;
@@ -925,6 +1053,7 @@ static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
     luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */
     luaK_reserveregs(fs, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -963,16 +1092,19 @@ static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
 
 
 static int cond (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* cond -> exp */
   expdesc v;
   expr(ls, &v);  /* read condition */
   if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
   luaK_goiftrue(ls->fs, &v);
+  __A_VARIABLE = 1;
   return v.f;
 }
 
 
 static void breakstat (LexState *ls) {
+  volatile int __A_VARIABLE;
   FuncState *fs = ls->fs;
   BlockCnt *bl = fs->bl;
   int upval = 0;
@@ -985,10 +1117,12 @@ static void breakstat (LexState *ls) {
   if (upval)
     luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
   luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
+  __A_VARIABLE = 1;
 }
 
 
 static void whilestat (LexState *ls, int line) {
+  volatile int __A_VARIABLE;
   /* whilestat -> WHILE cond DO block END */
   FuncState *fs = ls->fs;
   int whileinit;
@@ -1004,10 +1138,12 @@ static void whilestat (LexState *ls, int line) {
   check_match(ls, TK_END, TK_WHILE, line);
   leaveblock(fs);
   luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+  __A_VARIABLE = 1;
 }
 
 
 static void repeatstat (LexState *ls, int line) {
+  volatile int __A_VARIABLE;
   /* repeatstat -> REPEAT block UNTIL cond */
   int condexit;
   FuncState *fs = ls->fs;
@@ -1030,20 +1166,24 @@ static void repeatstat (LexState *ls, int line) {
     luaK_patchlist(ls->fs, luaK_jump(fs), repeat_init);  /* and repeat */
   }
   leaveblock(fs);  /* finish loop */
+  __A_VARIABLE = 1;
 }
 
 
 static int exp1 (LexState *ls) {
+  volatile int __A_VARIABLE;
   expdesc e;
   int k;
   expr(ls, &e);
   k = e.k;
   luaK_exp2nextreg(ls->fs, &e);
+  __A_VARIABLE = 1;
   return k;
 }
 
 
 static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  volatile int __A_VARIABLE;
   /* forbody -> DO block */
   BlockCnt bl;
   FuncState *fs = ls->fs;
@@ -1061,10 +1201,12 @@ static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
                      luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
   luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
   luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
+  __A_VARIABLE = 1;
 }
 
 
 static void fornum (LexState *ls, TString *varname, int line) {
+  volatile int __A_VARIABLE;
   /* fornum -> NAME = exp1,exp1[,exp1] forbody */
   FuncState *fs = ls->fs;
   int base = fs->freereg;
@@ -1083,10 +1225,12 @@ static void fornum (LexState *ls, TString *varname, int line) {
     luaK_reserveregs(fs, 1);
   }
   forbody(ls, base, line, 1, 1);
+  __A_VARIABLE = 1;
 }
 
 
 static void forlist (LexState *ls, TString *indexname) {
+  volatile int __A_VARIABLE;
   /* forlist -> NAME {,NAME} IN explist1 forbody */
   FuncState *fs = ls->fs;
   expdesc e;
@@ -1106,10 +1250,12 @@ static void forlist (LexState *ls, TString *indexname) {
   adjust_assign(ls, 3, explist1(ls, &e), &e);
   luaK_checkstack(fs, 3);  /* extra space to call generator */
   forbody(ls, base, line, nvars - 3, 0);
+  __A_VARIABLE = 1;
 }
 
 
 static void forstat (LexState *ls, int line) {
+  volatile int __A_VARIABLE;
   /* forstat -> FOR (fornum | forlist) END */
   FuncState *fs = ls->fs;
   TString *varname;
@@ -1124,21 +1270,25 @@ static void forstat (LexState *ls, int line) {
   }
   check_match(ls, TK_END, TK_FOR, line);
   leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+  __A_VARIABLE = 1;
 }
 
 
 static int test_then_block (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* test_then_block -> [IF | ELSEIF] cond THEN block */
   int condexit;
   luaX_next(ls);  /* skip IF or ELSEIF */
   condexit = cond(ls);
   checknext(ls, TK_THEN);
   block(ls);  /* `then' part */
+  __A_VARIABLE = 1;
   return condexit;
 }
 
 
 static void ifstat (LexState *ls, int line) {
+  volatile int __A_VARIABLE;
   /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
   FuncState *fs = ls->fs;
   int flist;
@@ -1159,10 +1309,12 @@ static void ifstat (LexState *ls, int line) {
     luaK_concat(fs, &escapelist, flist);
   luaK_patchtohere(fs, escapelist);
   check_match(ls, TK_END, TK_IF, line);
+  __A_VARIABLE = 1;
 }
 
 
 static void localfunc (LexState *ls) {
+  volatile int __A_VARIABLE;
   expdesc v, b;
   FuncState *fs = ls->fs;
   new_localvar(ls, str_checkname(ls), 0);
@@ -1173,10 +1325,12 @@ static void localfunc (LexState *ls) {
   luaK_storevar(fs, &v, &b);
   /* debug information will only see the variable after this point! */
   getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;
+  __A_VARIABLE = 1;
 }
 
 
 static void localstat (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
   int nvars = 0;
   int nexps;
@@ -1192,10 +1346,12 @@ static void localstat (LexState *ls) {
   }
   adjust_assign(ls, nvars, nexps, &e);
   adjustlocalvars(ls, nvars);
+  __A_VARIABLE = 1;
 }
 
 
 static int funcname (LexState *ls, expdesc *v) {
+  volatile int __A_VARIABLE;
   /* funcname -> NAME {field} [`:' NAME] */
   int needself = 0;
   singlevar(ls, v);
@@ -1205,11 +1361,13 @@ static int funcname (LexState *ls, expdesc *v) {
     needself = 1;
     field(ls, v);
   }
+  __A_VARIABLE = 1;
   return needself;
 }
 
 
 static void funcstat (LexState *ls, int line) {
+  volatile int __A_VARIABLE;
   /* funcstat -> FUNCTION funcname body */
   int needself;
   expdesc v, b;
@@ -1218,10 +1376,12 @@ static void funcstat (LexState *ls, int line) {
   body(ls, &b, needself, line);
   luaK_storevar(ls->fs, &v, &b);
   luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+  __A_VARIABLE = 1;
 }
 
 
 static void exprstat (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* stat -> func | assignment */
   FuncState *fs = ls->fs;
   struct LHS_assign v;
@@ -1232,10 +1392,12 @@ static void exprstat (LexState *ls) {
     v.prev = NULL;
     assignment(ls, &v, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void retstat (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* stat -> RETURN explist */
   FuncState *fs = ls->fs;
   expdesc e;
@@ -1265,36 +1427,44 @@ static void retstat (LexState *ls) {
     }
   }
   luaK_ret(fs, first, nret);
+  __A_VARIABLE = 1;
 }
 
 
 static int statement (LexState *ls) {
+  volatile int __A_VARIABLE;
   int line = ls->linenumber;  /* may be needed for error messages */
   switch (ls->t.token) {
     case TK_IF: {  /* stat -> ifstat */
       ifstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_WHILE: {  /* stat -> whilestat */
       whilestat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_DO: {  /* stat -> DO block END */
       luaX_next(ls);  /* skip DO */
       block(ls);
       check_match(ls, TK_END, TK_DO, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_FOR: {  /* stat -> forstat */
       forstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_REPEAT: {  /* stat -> repeatstat */
       repeatstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_FUNCTION: {
       funcstat(ls, line);  /* stat -> funcstat */
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_LOCAL: {  /* stat -> localstat */
@@ -1303,19 +1473,23 @@ static int statement (LexState *ls) {
         localfunc(ls);
       else
         localstat(ls);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_RETURN: {  /* stat -> retstat */
       retstat(ls);
+      __A_VARIABLE = 1;
       return 1;  /* must be last statement */
     }
     case TK_BREAK: {  /* stat -> breakstat */
       luaX_next(ls);  /* skip BREAK */
       breakstat(ls);
+      __A_VARIABLE = 1;
       return 1;  /* must be last statement */
     }
     default: {
       exprstat(ls);
+      __A_VARIABLE = 1;
       return 0;  /* to avoid warnings */
     }
   }
@@ -1323,6 +1497,7 @@ static int statement (LexState *ls) {
 
 
 static void chunk (LexState *ls) {
+  volatile int __A_VARIABLE;
   /* chunk -> { stat [`;'] } */
   int islast = 0;
   enterlevel(ls);
@@ -1334,6 +1509,7 @@ static void chunk (LexState *ls) {
     ls->fs->freereg = ls->fs->nactvar;  /* free registers */
   }
   leavelevel(ls);
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================================== */
diff --git a/deps/lua/src/lstate.c b/deps/lua/src/lstate.c
index 4313b83..ddcb7ef 100644
--- a/deps/lua/src/lstate.c
+++ b/deps/lua/src/lstate.c
@@ -40,6 +40,7 @@ typedef struct LG {
 
 
 static void stack_init (lua_State *L1, lua_State *L) {
+  volatile int __A_VARIABLE;
   /* initialize CallInfo array */
   L1->base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
   L1->ci = L1->base_ci;
@@ -55,12 +56,15 @@ static void stack_init (lua_State *L1, lua_State *L) {
   setnilvalue(L1->top++);  /* `function' entry for this `ci' */
   L1->base = L1->ci->base = L1->top;
   L1->ci->top = L1->top + LUA_MINSTACK;
+  __A_VARIABLE = 1;
 }
 
 
 static void freestack (lua_State *L, lua_State *L1) {
+  volatile int __A_VARIABLE;
   luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
   luaM_freearray(L, L1->stack, L1->stacksize, TValue);
+  __A_VARIABLE = 1;
 }
 
 
@@ -68,6 +72,7 @@ static void freestack (lua_State *L, lua_State *L1) {
 ** open parts that may cause memory-allocation errors
 */
 static void f_luaopen (lua_State *L, void *ud) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   UNUSED(ud);
   stack_init(L, L);  /* init stack */
@@ -78,10 +83,12 @@ static void f_luaopen (lua_State *L, void *ud) {
   luaX_init(L);
   luaS_fix(luaS_newliteral(L, MEMERRMSG));
   g->GCthreshold = 4*g->totalbytes;
+  __A_VARIABLE = 1;
 }
 
 
 static void preinit_state (lua_State *L, global_State *g) {
+  volatile int __A_VARIABLE;
   G(L) = g;
   L->stack = NULL;
   L->stacksize = 0;
@@ -99,10 +106,12 @@ static void preinit_state (lua_State *L, global_State *g) {
   L->savedpc = NULL;
   L->errfunc = 0;
   setnilvalue(gt(L));
+  __A_VARIABLE = 1;
 }
 
 
 static void close_state (lua_State *L) {
+  volatile int __A_VARIABLE;
   global_State *g = G(L);
   luaF_close(L, L->stack);  /* close all upvalues for this thread */
   luaC_freeall(L);  /* collect all objects */
@@ -113,10 +122,12 @@ static void close_state (lua_State *L) {
   freestack(L, L);
   lua_assert(g->totalbytes == sizeof(LG));
   (*g->frealloc)(g->ud, fromstate(L), state_size(LG), 0);
+  __A_VARIABLE = 1;
 }
 
 
 lua_State *luaE_newthread (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));
   luaC_link(L, obj2gco(L1), LUA_TTHREAD);
   preinit_state(L1, G(L));
@@ -127,25 +138,32 @@ lua_State *luaE_newthread (lua_State *L) {
   L1->hook = L->hook;
   resethookcount(L1);
   lua_assert(iswhite(obj2gco(L1)));
+  __A_VARIABLE = 1;
   return L1;
 }
 
 
 void luaE_freethread (lua_State *L, lua_State *L1) {
+  volatile int __A_VARIABLE;
   luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
   lua_assert(L1->openupval == NULL);
   luai_userstatefree(L1);
   freestack(L, L1);
   luaM_freemem(L, fromstate(L1), state_size(lua_State));
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
+  volatile int __A_VARIABLE;
   int i;
   lua_State *L;
   global_State *g;
   void *l = (*f)(ud, NULL, 0, state_size(LG));
-  if (l == NULL) return NULL;
+  if (l == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   L = tostate(l);
   g = &((LG *)L)->g;
   L->next = NULL;
@@ -186,17 +204,21 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   }
   else
     luai_userstateopen(L);
+  __A_VARIABLE = 1;
   return L;
 }
 
 
 static void callallgcTM (lua_State *L, void *ud) {
+  volatile int __A_VARIABLE;
   UNUSED(ud);
   luaC_callGCTM(L);  /* call GC metamethods for all udata */
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_close (lua_State *L) {
+  volatile int __A_VARIABLE;
   L = G(L)->mainthread;  /* only the main thread can be closed */
   lua_lock(L);
   luaF_close(L, L->stack);  /* close all upvalues for this thread */
@@ -210,5 +232,6 @@ LUA_API void lua_close (lua_State *L) {
   lua_assert(G(L)->tmudata == NULL);
   luai_userstateclose(L);
   close_state(L);
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/lstring.c b/deps/lua/src/lstring.c
index 4911315..8658a2f 100644
--- a/deps/lua/src/lstring.c
+++ b/deps/lua/src/lstring.c
@@ -20,11 +20,14 @@
 
 
 void luaS_resize (lua_State *L, int newsize) {
+  volatile int __A_VARIABLE;
   GCObject **newhash;
   stringtable *tb;
   int i;
-  if (G(L)->gcstate == GCSsweepstring)
-    return;  /* cannot resize during GC traverse */
+  if (G(L)->gcstate == GCSsweepstring) {
+    __A_VARIABLE = 1;
+    return;
+  }  /* cannot resize during GC traverse */
   newhash = luaM_newvector(L, newsize, GCObject *);
   tb = &G(L)->strt;
   for (i=0; i<newsize; i++) newhash[i] = NULL;
@@ -44,11 +47,13 @@ void luaS_resize (lua_State *L, int newsize) {
   luaM_freearray(L, tb->hash, tb->size, TString *);
   tb->size = newsize;
   tb->hash = newhash;
+  __A_VARIABLE = 1;
 }
 
 
 static TString *newlstr (lua_State *L, const char *str, size_t l,
                                        unsigned int h) {
+  volatile int __A_VARIABLE;
   TString *ts;
   stringtable *tb;
   if (l+1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
@@ -68,11 +73,13 @@ static TString *newlstr (lua_State *L, const char *str, size_t l,
   tb->nuse++;
   if (tb->nuse > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
     luaS_resize(L, tb->size*2);  /* too crowded */
+  __A_VARIABLE = 1;
   return ts;
 }
 
 
 TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  volatile int __A_VARIABLE;
   GCObject *o;
   unsigned int h = cast(unsigned int, l);  /* seed */
   size_t step = (l>>5)+1;  /* if string is too long, don't hash all its chars */
@@ -86,14 +93,17 @@ TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
     if (ts->tsv.len == l && (memcmp(str, getstr(ts), l) == 0)) {
       /* string may be dead */
       if (isdead(G(L), o)) changewhite(o);
+      __A_VARIABLE = 1;
       return ts;
     }
   }
+  __A_VARIABLE = 1;
   return newlstr(L, str, l, h);  /* not found */
 }
 
 
 Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+  volatile int __A_VARIABLE;
   Udata *u;
   if (s > MAX_SIZET - sizeof(Udata))
     luaM_toobig(L);
@@ -106,6 +116,7 @@ Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
   /* chain it on udata list (after main thread) */
   u->uv.next = G(L)->mainthread->next;
   G(L)->mainthread->next = obj2gco(u);
+  __A_VARIABLE = 1;
   return u;
 }
 
diff --git a/deps/lua/src/lstrlib.c b/deps/lua/src/lstrlib.c
index 7a03489..13fdba7 100644
--- a/deps/lua/src/lstrlib.c
+++ b/deps/lua/src/lstrlib.c
@@ -26,21 +26,26 @@
 
 
 static int str_len (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   luaL_checklstring(L, 1, &l);
   lua_pushinteger(L, l);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
+  volatile int __A_VARIABLE;
   /* relative string position: negative means back from end */
   if (pos < 0) pos += (ptrdiff_t)len + 1;
+  __A_VARIABLE = 1;
   return (pos >= 0) ? pos : 0;
 }
 
 
 static int str_sub (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
   ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
@@ -50,22 +55,26 @@ static int str_sub (lua_State *L) {
   if (start <= end)
     lua_pushlstring(L, s+start-1, end-start+1);
   else lua_pushliteral(L, "");
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int str_reverse (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   luaL_Buffer b;
   const char *s = luaL_checklstring(L, 1, &l);
   luaL_buffinit(L, &b);
   while (l--) luaL_addchar(&b, s[l]);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int str_lower (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   size_t i;
   luaL_Buffer b;
@@ -74,11 +83,13 @@ static int str_lower (lua_State *L) {
   for (i=0; i<l; i++)
     luaL_addchar(&b, tolower(uchar(s[i])));
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int str_upper (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   size_t i;
   luaL_Buffer b;
@@ -87,10 +98,12 @@ static int str_upper (lua_State *L) {
   for (i=0; i<l; i++)
     luaL_addchar(&b, toupper(uchar(s[i])));
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int str_rep (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   luaL_Buffer b;
   const char *s = luaL_checklstring(L, 1, &l);
@@ -99,11 +112,13 @@ static int str_rep (lua_State *L) {
   while (n-- > 0)
     luaL_addlstring(&b, s, l);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int str_byte (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
   ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
@@ -111,18 +126,23 @@ static int str_byte (lua_State *L) {
   int n, i;
   if (posi <= 0) posi = 1;
   if ((size_t)pose > l) pose = l;
-  if (posi > pose) return 0;  /* empty interval; return no values */
+  if (posi > pose) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* empty interval; return no values */
   n = (int)(pose -  posi + 1);
   if (posi + n <= pose)  /* overflow? */
     luaL_error(L, "string slice too long");
   luaL_checkstack(L, n, "string slice too long");
   for (i=0; i<n; i++)
     lua_pushinteger(L, uchar(s[posi+i-1]));
+  __A_VARIABLE = 1;
   return n;
 }
 
 
 static int str_char (lua_State *L) {
+  volatile int __A_VARIABLE;
   int n = lua_gettop(L);  /* number of arguments */
   int i;
   luaL_Buffer b;
@@ -133,18 +153,22 @@ static int str_char (lua_State *L) {
     luaL_addchar(&b, uchar(c));
   }
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  volatile int __A_VARIABLE;
   (void)L;
   luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int str_dump (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_Buffer b;
   luaL_checktype(L, 1, LUA_TFUNCTION);
   lua_settop(L, 1);
@@ -152,6 +176,7 @@ static int str_dump (lua_State *L) {
   if (lua_dump(L, writer, &b) != 0)
     luaL_error(L, "unable to dump given function");
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -184,26 +209,37 @@ typedef struct MatchState {
 
 
 static int check_capture (MatchState *ms, int l) {
+  volatile int __A_VARIABLE;
   l -= '1';
-  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED) {
+    __A_VARIABLE = 1;
     return luaL_error(ms->L, "invalid capture index");
+  }
+  __A_VARIABLE = 1;
   return l;
 }
 
 
 static int capture_to_close (MatchState *ms) {
+  volatile int __A_VARIABLE;
   int level = ms->level;
   for (level--; level>=0; level--)
-    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+    if (ms->capture[level].len == CAP_UNFINISHED) {
+      __A_VARIABLE = 1;
+      return level;
+    }
+  __A_VARIABLE = 1;
   return luaL_error(ms->L, "invalid pattern capture");
 }
 
 
 static const char *classend (MatchState *ms, const char *p) {
+  volatile int __A_VARIABLE;
   switch (*p++) {
     case L_ESC: {
       if (*p == '\0')
         luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      __A_VARIABLE = 1;
       return p+1;
     }
     case '[': {
@@ -214,9 +250,11 @@ static const char *classend (MatchState *ms, const char *p) {
         if (*(p++) == L_ESC && *p != '\0')
           p++;  /* skip escapes (e.g. `%]') */
       } while (*p != ']');
+      __A_VARIABLE = 1;
       return p+1;
     }
     default: {
+      __A_VARIABLE = 1;
       return p;
     }
   }
@@ -224,6 +262,7 @@ static const char *classend (MatchState *ms, const char *p) {
 
 
 static int match_class (int c, int cl) {
+  volatile int __A_VARIABLE;
   int res;
   switch (tolower(cl)) {
     case 'a' : res = isalpha(c); break;
@@ -236,8 +275,10 @@ static int match_class (int c, int cl) {
     case 'w' : res = isalnum(c); break;
     case 'x' : res = isxdigit(c); break;
     case 'z' : res = (c == 0); break;
-    default: return (cl == c);
+    default: __A_VARIABLE = 1;
+    return (cl == c);
   }
+  __A_VARIABLE = 1;
   return (islower(cl) ? res : !res);
 }
 
@@ -266,11 +307,16 @@ static int matchbracketclass (int c, const char *p, const char *ec) {
 
 
 static int singlematch (int c, const char *p, const char *ep) {
+  volatile int __A_VARIABLE;
   switch (*p) {
-    case '.': return 1;  /* matches any char */
-    case L_ESC: return match_class(c, uchar(*(p+1)));
-    case '[': return matchbracketclass(c, p, ep-1);
-    default:  return (uchar(*p) == c);
+    case '.': __A_VARIABLE = 1;
+      return 1;  /* matches any char */
+    case L_ESC: __A_VARIABLE = 1;
+      return match_class(c, uchar(*(p+1)));
+    case '[': __A_VARIABLE = 1;
+      return matchbracketclass(c, p, ep-1);
+    default:  __A_VARIABLE = 1;
+    return (uchar(*p) == c);
   }
 }
 
@@ -300,15 +346,20 @@ static const char *matchbalance (MatchState *ms, const char *s,
 
 static const char *max_expand (MatchState *ms, const char *s,
                                  const char *p, const char *ep) {
+  volatile int __A_VARIABLE;
   ptrdiff_t i = 0;  /* counts maximum expand for item */
   while ((s+i)<ms->src_end && singlematch(uchar(*(s+i)), p, ep))
     i++;
   /* keeps trying to match with the maximum repetitions */
   while (i>=0) {
     const char *res = match(ms, (s+i), ep+1);
-    if (res) return res;
+    if (res) {
+      __A_VARIABLE = 1;
+      return res;
+    }
     i--;  /* else didn't match; reduce 1 repetition to try again */
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -328,6 +379,7 @@ static const char *min_expand (MatchState *ms, const char *s,
 
 static const char *start_capture (MatchState *ms, const char *s,
                                     const char *p, int what) {
+  volatile int __A_VARIABLE;
   const char *res;
   int level = ms->level;
   if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
@@ -336,17 +388,20 @@ static const char *start_capture (MatchState *ms, const char *s,
   ms->level = level+1;
   if ((res=match(ms, s, p)) == NULL)  /* match failed? */
     ms->level--;  /* undo capture */
+  __A_VARIABLE = 1;
   return res;
 }
 
 
 static const char *end_capture (MatchState *ms, const char *s,
                                   const char *p) {
+  volatile int __A_VARIABLE;
   int l = capture_to_close(ms);
   const char *res;
   ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
   if ((res = match(ms, s, p)) == NULL)  /* match failed? */
     ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -465,6 +520,7 @@ static const char *lmemfind (const char *s1, size_t l1,
 
 static void push_onecapture (MatchState *ms, int i, const char *s,
                                                     const char *e) {
+  volatile int __A_VARIABLE;
   if (i >= ms->level) {
     if (i == 0)  /* ms->level == 0, too */
       lua_pushlstring(ms->L, s, e - s);  /* add whole match */
@@ -479,15 +535,18 @@ static void push_onecapture (MatchState *ms, int i, const char *s,
     else
       lua_pushlstring(ms->L, ms->capture[i].init, l);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int push_captures (MatchState *ms, const char *s, const char *e) {
+  volatile int __A_VARIABLE;
   int i;
   int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
   luaL_checkstack(ms->L, nlevels, "too many captures");
   for (i = 0; i < nlevels; i++)
     push_onecapture(ms, i, s, e);
+  __A_VARIABLE = 1;
   return nlevels;  /* number of strings pushed */
 }
 
@@ -536,16 +595,21 @@ static int str_find_aux (lua_State *L, int find) {
 
 
 static int str_find (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return str_find_aux(L, 1);
 }
 
 
 static int str_match (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return str_find_aux(L, 0);
 }
 
 
 static int gmatch_aux (lua_State *L) {
+  volatile int __A_VARIABLE;
   MatchState ms;
   size_t ls;
   const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
@@ -564,24 +628,30 @@ static int gmatch_aux (lua_State *L) {
       if (e == src) newstart++;  /* empty match? go at least one position */
       lua_pushinteger(L, newstart);
       lua_replace(L, lua_upvalueindex(3));
+      __A_VARIABLE = 1;
       return push_captures(&ms, src, e);
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* not found */
 }
 
 
 static int gmatch (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checkstring(L, 1);
   luaL_checkstring(L, 2);
   lua_settop(L, 2);
   lua_pushinteger(L, 0);
   lua_pushcclosure(L, gmatch_aux, 3);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int gfind_nodef (lua_State *L) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return luaL_error(L, LUA_QL("string.gfind") " was renamed to "
                        LUA_QL("string.gmatch"));
 }
@@ -589,6 +659,7 @@ static int gfind_nodef (lua_State *L) {
 
 static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
                                                    const char *e) {
+  volatile int __A_VARIABLE;
   size_t l, i;
   const char *news = lua_tolstring(ms->L, 3, &l);
   for (i = 0; i < l; i++) {
@@ -606,16 +677,19 @@ static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
                                                        const char *e) {
+  volatile int __A_VARIABLE;
   lua_State *L = ms->L;
   switch (lua_type(L, 3)) {
     case LUA_TNUMBER:
     case LUA_TSTRING: {
       add_s(ms, b, s, e);
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TFUNCTION: {
@@ -638,10 +712,12 @@ static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
   else if (!lua_isstring(L, -1))
     luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1)); 
   luaL_addvalue(b);  /* add result to accumulator */
+  __A_VARIABLE = 1;
 }
 
 
 static int str_gsub (lua_State *L) {
+  volatile int __A_VARIABLE;
   size_t srcl;
   const char *src = luaL_checklstring(L, 1, &srcl);
   const char *p = luaL_checkstring(L, 2);
@@ -676,6 +752,7 @@ static int str_gsub (lua_State *L) {
   luaL_addlstring(&b, src, ms.src_end-src);
   luaL_pushresult(&b);
   lua_pushinteger(L, n);  /* number of substitutions */
+  __A_VARIABLE = 1;
   return 2;
 }
 
@@ -694,6 +771,7 @@ static int str_gsub (lua_State *L) {
 
 
 static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  volatile int __A_VARIABLE;
   size_t l;
   const char *s = luaL_checklstring(L, arg, &l);
   luaL_addchar(b, '"');
@@ -720,9 +798,11 @@ static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
     s++;
   }
   luaL_addchar(b, '"');
+  __A_VARIABLE = 1;
 }
 
 static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
+  volatile int __A_VARIABLE;
   const char *p = strfrmt;
   while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
   if ((size_t)(p - strfrmt) >= sizeof(FLAGS))
@@ -740,16 +820,19 @@ static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
   strncpy(form, strfrmt, p - strfrmt + 1);
   form += p - strfrmt + 1;
   *form = '\0';
+  __A_VARIABLE = 1;
   return p;
 }
 
 
 static void addintlen (char *form) {
+  volatile int __A_VARIABLE;
   size_t l = strlen(form);
   char spec = form[l - 1];
   strcpy(form + l - 1, LUA_INTFRMLEN);
   form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
   form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
+  __A_VARIABLE = 1;
 }
 
 
@@ -845,6 +928,7 @@ static const luaL_Reg strlib[] = {
 
 
 static void createmetatable (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_createtable(L, 0, 1);  /* create metatable for strings */
   lua_pushliteral(L, "");  /* dummy string */
   lua_pushvalue(L, -2);
@@ -853,6 +937,7 @@ static void createmetatable (lua_State *L) {
   lua_pushvalue(L, -2);  /* string library... */
   lua_setfield(L, -2, "__index");  /* ...is the __index metamethod */
   lua_pop(L, 1);  /* pop metatable */
+  __A_VARIABLE = 1;
 }
 
 
@@ -860,12 +945,14 @@ static void createmetatable (lua_State *L) {
 ** Open string library
 */
 LUALIB_API int luaopen_string (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, LUA_STRLIBNAME, strlib);
 #if defined(LUA_COMPAT_GFIND)
   lua_getfield(L, -1, "gmatch");
   lua_setfield(L, -2, "gfind");
 #endif
   createmetatable(L);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ltable.c b/deps/lua/src/ltable.c
index ec84f4f..49057f7 100644
--- a/deps/lua/src/ltable.c
+++ b/deps/lua/src/ltable.c
@@ -82,12 +82,16 @@ static const Node dummynode_ = {
 ** hash for lua_Numbers
 */
 static Node *hashnum (const Table *t, lua_Number n) {
+  volatile int __A_VARIABLE;
   unsigned int a[numints];
   int i;
-  if (luai_numeq(n, 0))  /* avoid problems with -0 */
+  if (luai_numeq(n, 0))  /* avoid problems with -0 */ {
+    __A_VARIABLE = 1;
     return gnode(t, 0);
+  }
   memcpy(a, &n, sizeof(a));
   for (i = 1; i < numints; i++) a[0] += a[i];
+  __A_VARIABLE = 1;
   return hashmod(t, a[0]);
 }
 
@@ -98,16 +102,22 @@ static Node *hashnum (const Table *t, lua_Number n) {
 ** of its hash value)
 */
 static Node *mainposition (const Table *t, const TValue *key) {
+  volatile int __A_VARIABLE;
   switch (ttype(key)) {
     case LUA_TNUMBER:
+      __A_VARIABLE = 1;
       return hashnum(t, nvalue(key));
     case LUA_TSTRING:
+      __A_VARIABLE = 1;
       return hashstr(t, rawtsvalue(key));
     case LUA_TBOOLEAN:
+      __A_VARIABLE = 1;
       return hashboolean(t, bvalue(key));
     case LUA_TLIGHTUSERDATA:
+      __A_VARIABLE = 1;
       return hashpointer(t, pvalue(key));
     default:
+      __A_VARIABLE = 1;
       return hashpointer(t, gcvalue(key));
   }
 }
@@ -118,13 +128,17 @@ static Node *mainposition (const Table *t, const TValue *key) {
 ** the array part of the table, -1 otherwise.
 */
 static int arrayindex (const TValue *key) {
+  volatile int __A_VARIABLE;
   if (ttisnumber(key)) {
     lua_Number n = nvalue(key);
     int k;
     lua_number2int(k, n);
-    if (luai_numeq(cast_num(k), n))
+    if (luai_numeq(cast_num(k), n)) {
+      __A_VARIABLE = 1;
       return k;
+    }
   }
+  __A_VARIABLE = 1;
   return -1;  /* `key' did not match some condition */
 }
 
@@ -160,11 +174,13 @@ static int findindex (lua_State *L, Table *t, StkId key) {
 
 
 int luaH_next (lua_State *L, Table *t, StkId key) {
+  volatile int __A_VARIABLE;
   int i = findindex(L, t, key);  /* find original element */
   for (i++; i < t->sizearray; i++) {  /* try first array part */
     if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
       setnvalue(key, cast_num(i+1));
       setobj2s(L, key+1, &t->array[i]);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
@@ -172,9 +188,11 @@ int luaH_next (lua_State *L, Table *t, StkId key) {
     if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
       setobj2s(L, key, key2tval(gnode(t, i)));
       setobj2s(L, key+1, gval(gnode(t, i)));
+      __A_VARIABLE = 1;
       return 1;
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* no more elements */
 }
 
@@ -187,6 +205,7 @@ int luaH_next (lua_State *L, Table *t, StkId key) {
 
 
 static int computesizes (int nums[], int *narray) {
+  volatile int __A_VARIABLE;
   int i;
   int twotoi;  /* 2^i */
   int a = 0;  /* number of elements smaller than 2^i */
@@ -204,6 +223,7 @@ static int computesizes (int nums[], int *narray) {
   }
   *narray = n;
   lua_assert(*narray/2 <= na && na <= *narray);
+  __A_VARIABLE = 1;
   return na;
 }
 
@@ -220,6 +240,7 @@ static int countint (const TValue *key, int *nums) {
 
 
 static int numusearray (const Table *t, int *nums) {
+  volatile int __A_VARIABLE;
   int lg;
   int ttlg;  /* 2^lg */
   int ause = 0;  /* summation of `nums' */
@@ -240,11 +261,13 @@ static int numusearray (const Table *t, int *nums) {
     nums[lg] += lc;
     ause += lc;
   }
+  __A_VARIABLE = 1;
   return ause;
 }
 
 
 static int numusehash (const Table *t, int *nums, int *pnasize) {
+  volatile int __A_VARIABLE;
   int totaluse = 0;  /* total number of elements */
   int ause = 0;  /* summation of `nums' */
   int i = sizenode(t);
@@ -256,20 +279,24 @@ static int numusehash (const Table *t, int *nums, int *pnasize) {
     }
   }
   *pnasize += ause;
+  __A_VARIABLE = 1;
   return totaluse;
 }
 
 
 static void setarrayvector (lua_State *L, Table *t, int size) {
+  volatile int __A_VARIABLE;
   int i;
   luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
   for (i=t->sizearray; i<size; i++)
      setnilvalue(&t->array[i]);
   t->sizearray = size;
+  __A_VARIABLE = 1;
 }
 
 
 static void setnodevector (lua_State *L, Table *t, int size) {
+  volatile int __A_VARIABLE;
   int lsize;
   if (size == 0) {  /* no elements to hash part? */
     t->node = cast(Node *, dummynode);  /* use common `dummynode' */
@@ -291,10 +318,12 @@ static void setnodevector (lua_State *L, Table *t, int size) {
   }
   t->lsizenode = cast_byte(lsize);
   t->lastfree = gnode(t, size);  /* all positions are free */
+  __A_VARIABLE = 1;
 }
 
 
 static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  volatile int __A_VARIABLE;
   int i;
   int oldasize = t->sizearray;
   int oldhsize = t->lsizenode;
@@ -321,16 +350,20 @@ static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
   }
   if (nold != dummynode)
     luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+  __A_VARIABLE = 1;
 }
 
 
 void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+  volatile int __A_VARIABLE;
   int nsize = (t->node == dummynode) ? 0 : sizenode(t);
   resize(L, t, nasize, nsize);
+  __A_VARIABLE = 1;
 }
 
 
 static void rehash (lua_State *L, Table *t, const TValue *ek) {
+  volatile int __A_VARIABLE;
   int nasize, na;
   int nums[MAXBITS+1];  /* nums[i] = number of keys between 2^(i-1) and 2^i */
   int i;
@@ -346,6 +379,7 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
   na = computesizes(nums, &nasize);
   /* resize the table to new computed sizes */
   resize(L, t, nasize, totaluse - na);
+  __A_VARIABLE = 1;
 }
 
 
@@ -356,6 +390,7 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
 
 
 Table *luaH_new (lua_State *L, int narray, int nhash) {
+  volatile int __A_VARIABLE;
   Table *t = luaM_new(L, Table);
   luaC_link(L, obj2gco(t), LUA_TTABLE);
   t->metatable = NULL;
@@ -367,23 +402,30 @@ Table *luaH_new (lua_State *L, int narray, int nhash) {
   t->node = cast(Node *, dummynode);
   setarrayvector(L, t, narray);
   setnodevector(L, t, nhash);
+  __A_VARIABLE = 1;
   return t;
 }
 
 
 void luaH_free (lua_State *L, Table *t) {
+  volatile int __A_VARIABLE;
   if (t->node != dummynode)
     luaM_freearray(L, t->node, sizenode(t), Node);
   luaM_freearray(L, t->array, t->sizearray, TValue);
   luaM_free(L, t);
+  __A_VARIABLE = 1;
 }
 
 
 static Node *getfreepos (Table *t) {
+  volatile int __A_VARIABLE;
   while (t->lastfree-- > t->node) {
-    if (ttisnil(gkey(t->lastfree)))
+    if (ttisnil(gkey(t->lastfree))) {
+      __A_VARIABLE = 1;
       return t->lastfree;
+    }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* could not find a free place */
 }
 
@@ -397,12 +439,14 @@ static Node *getfreepos (Table *t) {
 ** position), new key goes to an empty position. 
 */
 static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
+  volatile int __A_VARIABLE;
   Node *mp = mainposition(t, key);
   if (!ttisnil(gval(mp)) || mp == dummynode) {
     Node *othern;
     Node *n = getfreepos(t);  /* get a free place */
     if (n == NULL) {  /* cannot find a free place? */
       rehash(L, t, key);  /* grow table */
+      __A_VARIABLE = 1;
       return luaH_set(L, t, key);  /* re-insert key into grown table */
     }
     lua_assert(n != dummynode);
@@ -425,6 +469,7 @@ static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
   gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;
   luaC_barriert(L, t, key);
   lua_assert(ttisnil(gval(mp)));
+  __A_VARIABLE = 1;
   return gval(mp);
 }
 
@@ -530,6 +575,7 @@ TValue *luaH_setstr (lua_State *L, Table *t, TString *key) {
 
 
 static int unbound_search (Table *t, unsigned int j) {
+  volatile int __A_VARIABLE;
   unsigned int i = j;  /* i is zero or a present index */
   j++;
   /* find `i' and `j' such that i is present and j is not */
@@ -540,6 +586,7 @@ static int unbound_search (Table *t, unsigned int j) {
       /* table was built with bad purposes: resort to linear search */
       i = 1;
       while (!ttisnil(luaH_getnum(t, i))) i++;
+      __A_VARIABLE = 1;
       return i - 1;
     }
   }
@@ -549,6 +596,7 @@ static int unbound_search (Table *t, unsigned int j) {
     if (ttisnil(luaH_getnum(t, m))) j = m;
     else i = m;
   }
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -580,9 +628,13 @@ int luaH_getn (Table *t) {
 #if defined(LUA_DEBUG)
 
 Node *luaH_mainposition (const Table *t, const TValue *key) {
+  volatile int __A_VARIABLE;
+  __A_VARIABLE = 1;
   return mainposition(t, key);
 }
 
-int luaH_isdummy (Node *n) { return n == dummynode; }
+int luaH_isdummy (Node *n) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return n == dummynode; }
 
 #endif
diff --git a/deps/lua/src/ltablib.c b/deps/lua/src/ltablib.c
index b6d9cb4..08c14b1 100644
--- a/deps/lua/src/ltablib.c
+++ b/deps/lua/src/ltablib.c
@@ -20,6 +20,7 @@
 
 
 static int foreachi (lua_State *L) {
+  volatile int __A_VARIABLE;
   int i;
   int n = aux_getn(L, 1);
   luaL_checktype(L, 2, LUA_TFUNCTION);
@@ -28,15 +29,19 @@ static int foreachi (lua_State *L) {
     lua_pushinteger(L, i);  /* 1st argument */
     lua_rawgeti(L, 1, i);  /* 2nd argument */
     lua_call(L, 2, 1);
-    if (!lua_isnil(L, -1))
+    if (!lua_isnil(L, -1)) {
+      __A_VARIABLE = 1;
       return 1;
+    }
     lua_pop(L, 1);  /* remove nil result */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int foreach (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
   luaL_checktype(L, 2, LUA_TFUNCTION);
   lua_pushnil(L);  /* first key */
@@ -45,15 +50,19 @@ static int foreach (lua_State *L) {
     lua_pushvalue(L, -3);  /* key */
     lua_pushvalue(L, -3);  /* value */
     lua_call(L, 2, 1);
-    if (!lua_isnil(L, -1))
+    if (!lua_isnil(L, -1)) {
+      __A_VARIABLE = 1;
       return 1;
+    }
     lua_pop(L, 2);  /* remove value and result */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int maxn (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_Number max = 0;
   luaL_checktype(L, 1, LUA_TTABLE);
   lua_pushnil(L);  /* first key */
@@ -65,17 +74,21 @@ static int maxn (lua_State *L) {
     }
   }
   lua_pushnumber(L, max);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int getn (lua_State *L) {
+  volatile int __A_VARIABLE;
   lua_pushinteger(L, aux_getn(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int setn (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_checktype(L, 1, LUA_TTABLE);
 #ifndef luaL_setn
   luaL_setn(L, 1, luaL_checkint(L, 2));
@@ -83,11 +96,13 @@ static int setn (lua_State *L) {
   luaL_error(L, LUA_QL("setn") " is obsolete");
 #endif
   lua_pushvalue(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int tinsert (lua_State *L) {
+  volatile int __A_VARIABLE;
   int e = aux_getn(L, 1) + 1;  /* first empty element */
   int pos;  /* where to insert new element */
   switch (lua_gettop(L)) {
@@ -106,20 +121,25 @@ static int tinsert (lua_State *L) {
       break;
     }
     default: {
+      __A_VARIABLE = 1;
       return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
     }
   }
   luaL_setn(L, 1, e);  /* new size */
   lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int tremove (lua_State *L) {
+  volatile int __A_VARIABLE;
   int e = aux_getn(L, 1);
   int pos = luaL_optint(L, 2, e);
-  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */
-   return 0;  /* nothing to remove */
+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */ {
+   __A_VARIABLE = 1;
+   return 0;
+  }  /* nothing to remove */
   luaL_setn(L, 1, e - 1);  /* t.n = n-1 */
   lua_rawgeti(L, 1, pos);  /* result = t[pos] */
   for ( ;pos<e; pos++) {
@@ -128,20 +148,24 @@ static int tremove (lua_State *L) {
   }
   lua_pushnil(L);
   lua_rawseti(L, 1, e);  /* t[e] = nil */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  volatile int __A_VARIABLE;
   lua_rawgeti(L, 1, i);
   if (!lua_isstring(L, -1))
     luaL_error(L, "invalid value (%s) at index %d in table for "
                   LUA_QL("concat"), luaL_typename(L, -1), i);
     luaL_addvalue(b);
+    __A_VARIABLE = 1;
 }
 
 
 static int tconcat (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_Buffer b;
   size_t lsep;
   int i, last;
@@ -157,6 +181,7 @@ static int tconcat (lua_State *L) {
   if (i == last)  /* add last value (if interval was not empty) */
     addfield(L, &b, i);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -171,8 +196,10 @@ static int tconcat (lua_State *L) {
 
 
 static void set2 (lua_State *L, int i, int j) {
+  volatile int __A_VARIABLE;
   lua_rawseti(L, 1, i);
   lua_rawseti(L, 1, j);
+  __A_VARIABLE = 1;
 }
 
 static int sort_comp (lua_State *L, int a, int b) {
@@ -191,6 +218,7 @@ static int sort_comp (lua_State *L, int a, int b) {
 }
 
 static void auxsort (lua_State *L, int l, int u) {
+  volatile int __A_VARIABLE;
   while (l < u) {  /* for tail recursion */
     int i, j;
     /* sort elements a[l], a[(l+u)/2] and a[u] */
@@ -251,15 +279,18 @@ static void auxsort (lua_State *L, int l, int u) {
     }
     auxsort(L, j, i);  /* call recursively the smaller one */
   }  /* repeat the routine for the larger one */
+  __A_VARIABLE = 1;
 }
 
 static int sort (lua_State *L) {
+  volatile int __A_VARIABLE;
   int n = aux_getn(L, 1);
   luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
   if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
     luaL_checktype(L, 2, LUA_TFUNCTION);
   lua_settop(L, 2);  /* make sure there is two arguments */
   auxsort(L, 1, n);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -281,7 +312,9 @@ static const luaL_Reg tab_funcs[] = {
 
 
 LUALIB_API int luaopen_table (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, LUA_TABLIBNAME, tab_funcs);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ltm.c b/deps/lua/src/ltm.c
index c27f0f6..bc935dc 100644
--- a/deps/lua/src/ltm.c
+++ b/deps/lua/src/ltm.c
@@ -28,6 +28,7 @@ const char *const luaT_typenames[] = {
 
 
 void luaT_init (lua_State *L) {
+  volatile int __A_VARIABLE;
   static const char *const luaT_eventname[] = {  /* ORDER TM */
     "__index", "__newindex",
     "__gc", "__mode", "__eq",
@@ -40,6 +41,7 @@ void luaT_init (lua_State *L) {
     G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
     luaS_fix(G(L)->tmname[i]);  /* never collect these names */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -59,6 +61,7 @@ const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
 
 
 const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
+  volatile int __A_VARIABLE;
   Table *mt;
   switch (ttype(o)) {
     case LUA_TTABLE:
@@ -70,6 +73,7 @@ const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
     default:
       mt = G(L)->mt[ttype(o)];
   }
+  __A_VARIABLE = 1;
   return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
 }
 
diff --git a/deps/lua/src/lua.c b/deps/lua/src/lua.c
index 3a46609..66c6dd6 100644
--- a/deps/lua/src/lua.c
+++ b/deps/lua/src/lua.c
@@ -26,20 +26,25 @@ static const char *progname = LUA_PROGNAME;
 
 
 static void lstop (lua_State *L, lua_Debug *ar) {
+  volatile int __A_VARIABLE;
   (void)ar;  /* unused arg. */
   lua_sethook(L, NULL, 0, 0);
   luaL_error(L, "interrupted!");
+  __A_VARIABLE = 1;
 }
 
 
 static void laction (int i) {
+  volatile int __A_VARIABLE;
   signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                               terminate process (default action) */
   lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+  __A_VARIABLE = 1;
 }
 
 
 static void print_usage (void) {
+  volatile int __A_VARIABLE;
   fprintf(stderr,
   "usage: %s [options] [script [args]].\n"
   "Available options are:\n"
@@ -52,48 +57,60 @@ static void print_usage (void) {
   ,
   progname);
   fflush(stderr);
+  __A_VARIABLE = 1;
 }
 
 
 static void l_message (const char *pname, const char *msg) {
+  volatile int __A_VARIABLE;
   if (pname) fprintf(stderr, "%s: ", pname);
   fprintf(stderr, "%s\n", msg);
   fflush(stderr);
+  __A_VARIABLE = 1;
 }
 
 
 static int report (lua_State *L, int status) {
+  volatile int __A_VARIABLE;
   if (status && !lua_isnil(L, -1)) {
     const char *msg = lua_tostring(L, -1);
     if (msg == NULL) msg = "(error object is not a string)";
     l_message(progname, msg);
     lua_pop(L, 1);
   }
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static int traceback (lua_State *L) {
-  if (!lua_isstring(L, 1))  /* 'message' not a string? */
-    return 1;  /* keep it intact */
+  volatile int __A_VARIABLE;
+  if (!lua_isstring(L, 1))  /* 'message' not a string? */ {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* keep it intact */
   lua_getfield(L, LUA_GLOBALSINDEX, "debug");
   if (!lua_istable(L, -1)) {
     lua_pop(L, 1);
+    __A_VARIABLE = 1;
     return 1;
   }
   lua_getfield(L, -1, "traceback");
   if (!lua_isfunction(L, -1)) {
     lua_pop(L, 2);
+    __A_VARIABLE = 1;
     return 1;
   }
   lua_pushvalue(L, 1);  /* pass error message */
   lua_pushinteger(L, 2);  /* skip this function and traceback */
   lua_call(L, 2, 1);  /* call debug.traceback */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int docall (lua_State *L, int narg, int clear) {
+  volatile int __A_VARIABLE;
   int status;
   int base = lua_gettop(L) - narg;  /* function index */
   lua_pushcfunction(L, traceback);  /* push traceback function */
@@ -104,16 +121,20 @@ static int docall (lua_State *L, int narg, int clear) {
   lua_remove(L, base);  /* remove traceback function */
   /* force a complete garbage collection in case of errors */
   if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static void print_version (void) {
+  volatile int __A_VARIABLE;
   l_message(NULL, LUA_RELEASE "  " LUA_COPYRIGHT);
+  __A_VARIABLE = 1;
 }
 
 
 static int getargs (lua_State *L, char **argv, int n) {
+  volatile int __A_VARIABLE;
   int narg;
   int i;
   int argc = 0;
@@ -127,60 +148,75 @@ static int getargs (lua_State *L, char **argv, int n) {
     lua_pushstring(L, argv[i]);
     lua_rawseti(L, -2, i - n);
   }
+  __A_VARIABLE = 1;
   return narg;
 }
 
 
 static int dofile (lua_State *L, const char *name) {
+  volatile int __A_VARIABLE;
   int status = luaL_loadfile(L, name) || docall(L, 0, 1);
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
 
 static int dostring (lua_State *L, const char *s, const char *name) {
+  volatile int __A_VARIABLE;
   int status = luaL_loadbuffer(L, s, strlen(s), name) || docall(L, 0, 1);
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
 
 static int dolibrary (lua_State *L, const char *name) {
+  volatile int __A_VARIABLE;
   lua_getglobal(L, "require");
   lua_pushstring(L, name);
+  __A_VARIABLE = 1;
   return report(L, docall(L, 1, 1));
 }
 
 
 static const char *get_prompt (lua_State *L, int firstline) {
+  volatile int __A_VARIABLE;
   const char *p;
   lua_getfield(L, LUA_GLOBALSINDEX, firstline ? "_PROMPT" : "_PROMPT2");
   p = lua_tostring(L, -1);
   if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
   lua_pop(L, 1);  /* remove global */
+  __A_VARIABLE = 1;
   return p;
 }
 
 
 static int incomplete (lua_State *L, int status) {
+  volatile int __A_VARIABLE;
   if (status == LUA_ERRSYNTAX) {
     size_t lmsg;
     const char *msg = lua_tolstring(L, -1, &lmsg);
     const char *tp = msg + lmsg - (sizeof(LUA_QL("<eof>")) - 1);
     if (strstr(msg, LUA_QL("<eof>")) == tp) {
       lua_pop(L, 1);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* else... */
 }
 
 
 static int pushline (lua_State *L, int firstline) {
+  volatile int __A_VARIABLE;
   char buffer[LUA_MAXINPUT];
   char *b = buffer;
   size_t l;
   const char *prmt = get_prompt(L, firstline);
-  if (lua_readline(L, b, prmt) == 0)
-    return 0;  /* no input */
+  if (lua_readline(L, b, prmt) == 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* no input */
   l = strlen(b);
   if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
     b[l-1] = '\0';  /* remove it */
@@ -189,31 +225,39 @@ static int pushline (lua_State *L, int firstline) {
   else
     lua_pushstring(L, b);
   lua_freeline(L, b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int loadline (lua_State *L) {
+  volatile int __A_VARIABLE;
   int status;
   lua_settop(L, 0);
-  if (!pushline(L, 1))
-    return -1;  /* no input */
+  if (!pushline(L, 1)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* no input */
   for (;;) {  /* repeat until gets a complete line */
     status = luaL_loadbuffer(L, lua_tostring(L, 1), lua_strlen(L, 1), "=stdin");
     if (!incomplete(L, status)) break;  /* cannot try to add lines? */
-    if (!pushline(L, 0))  /* no more input? */
+    if (!pushline(L, 0))  /* no more input? */ {
+      __A_VARIABLE = 1;
       return -1;
+    }
     lua_pushliteral(L, "\n");  /* add a new line... */
     lua_insert(L, -2);  /* ...between the two lines */
     lua_concat(L, 3);  /* join them */
   }
   lua_saveline(L, 1);
   lua_remove(L, 1);  /* remove line */
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static void dotty (lua_State *L) {
+  volatile int __A_VARIABLE;
   int status;
   const char *oldprogname = progname;
   progname = NULL;
@@ -233,10 +277,12 @@ static void dotty (lua_State *L) {
   fputs("\n", stdout);
   fflush(stdout);
   progname = oldprogname;
+  __A_VARIABLE = 1;
 }
 
 
 static int handle_script (lua_State *L, char **argv, int n) {
+  volatile int __A_VARIABLE;
   int status;
   const char *fname;
   int narg = getargs(L, argv, n);  /* collect arguments */
@@ -250,6 +296,7 @@ static int handle_script (lua_State *L, char **argv, int n) {
     status = docall(L, narg, 0);
   else
     lua_pop(L, narg);      
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
@@ -259,15 +306,20 @@ static int handle_script (lua_State *L, char **argv, int n) {
 
 
 static int collectargs (char **argv, int *pi, int *pv, int *pe) {
+  volatile int __A_VARIABLE;
   int i;
   for (i = 1; argv[i] != NULL; i++) {
-    if (argv[i][0] != '-')  /* not an option? */
+    if (argv[i][0] != '-')  /* not an option? */ {
+        __A_VARIABLE = 1;
         return i;
+    }
     switch (argv[i][1]) {  /* option */
       case '-':
         notail(argv[i]);
+        __A_VARIABLE = 1;
         return (argv[i+1] != NULL ? i+1 : 0);
       case '\0':
+        __A_VARIABLE = 1;
         return i;
       case 'i':
         notail(argv[i]);
@@ -281,17 +333,23 @@ static int collectargs (char **argv, int *pi, int *pv, int *pe) {
       case 'l':
         if (argv[i][2] == '\0') {
           i++;
-          if (argv[i] == NULL) return -1;
+          if (argv[i] == NULL) {
+            __A_VARIABLE = 1;
+            return -1;
+          }
         }
         break;
-      default: return -1;  /* invalid option */
+      default: __A_VARIABLE = 1;
+        return -1;  /* invalid option */
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 static int runargs (lua_State *L, char **argv, int n) {
+  volatile int __A_VARIABLE;
   int i;
   for (i = 1; i < n; i++) {
     if (argv[i] == NULL) continue;
@@ -301,21 +359,26 @@ static int runargs (lua_State *L, char **argv, int n) {
         const char *chunk = argv[i] + 2;
         if (*chunk == '\0') chunk = argv[++i];
         lua_assert(chunk != NULL);
-        if (dostring(L, chunk, "=(command line)") != 0)
+        if (dostring(L, chunk, "=(command line)") != 0) {
+          __A_VARIABLE = 1;
           return 1;
+        }
         break;
       }
       case 'l': {
         const char *filename = argv[i] + 2;
         if (*filename == '\0') filename = argv[++i];
         lua_assert(filename != NULL);
-        if (dolibrary(L, filename))
-          return 1;  /* stop if file fails */
+        if (dolibrary(L, filename)) {
+          __A_VARIABLE = 1;
+          return 1;
+        }  /* stop if file fails */
         break;
       }
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -338,6 +401,7 @@ struct Smain {
 
 
 static int pmain (lua_State *L) {
+  volatile int __A_VARIABLE;
   struct Smain *s = (struct Smain *)lua_touserdata(L, 1);
   char **argv = s->argv;
   int script;
@@ -348,19 +412,29 @@ static int pmain (lua_State *L) {
   luaL_openlibs(L);  /* open libraries */
   lua_gc(L, LUA_GCRESTART, 0);
   s->status = handle_luainit(L);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   script = collectargs(argv, &has_i, &has_v, &has_e);
   if (script < 0) {  /* invalid args? */
     print_usage();
     s->status = 1;
+    __A_VARIABLE = 1;
     return 0;
   }
   if (has_v) print_version();
   s->status = runargs(L, argv, (script > 0) ? script : s->argc);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (script)
     s->status = handle_script(L, argv, script);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (has_i)
     dotty(L);
   else if (script == 0 && !has_e && !has_v) {
@@ -370,16 +444,19 @@ static int pmain (lua_State *L) {
     }
     else dofile(L, NULL);  /* executes stdin as a file */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 
 int main (int argc, char **argv) {
+  volatile int __A_VARIABLE;
   int status;
   struct Smain s;
   lua_State *L = lua_open();  /* create state */
   if (L == NULL) {
     l_message(argv[0], "cannot create state: not enough memory");
+    __A_VARIABLE = 1;
     return EXIT_FAILURE;
   }
   s.argc = argc;
@@ -387,6 +464,7 @@ int main (int argc, char **argv) {
   status = lua_cpcall(L, &pmain, &s);
   report(L, status);
   lua_close(L);
+  __A_VARIABLE = 1;
   return (status || s.status) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
 
diff --git a/deps/lua/src/lua_struct.c b/deps/lua/src/lua_struct.c
index 4d5f027..926facf 100644
--- a/deps/lua/src/lua_struct.c
+++ b/deps/lua/src/lua_struct.c
@@ -107,23 +107,34 @@ static int getnum (const char **fmt, int df) {
 
 
 static size_t optsize (lua_State *L, char opt, const char **fmt) {
+  volatile int __A_VARIABLE;
   switch (opt) {
-    case 'B': case 'b': return sizeof(char);
-    case 'H': case 'h': return sizeof(short);
-    case 'L': case 'l': return sizeof(long);
-    case 'T': return sizeof(size_t);
-    case 'f':  return sizeof(float);
-    case 'd':  return sizeof(double);
-    case 'x': return 1;
-    case 'c': return getnum(fmt, 1);
+    case 'B': case 'b': __A_VARIABLE = 1;
+    return sizeof(char);
+    case 'H': case 'h': __A_VARIABLE = 1;
+    return sizeof(short);
+    case 'L': case 'l': __A_VARIABLE = 1;
+    return sizeof(long);
+    case 'T': __A_VARIABLE = 1;
+    return sizeof(size_t);
+    case 'f':  __A_VARIABLE = 1;
+    return sizeof(float);
+    case 'd':  __A_VARIABLE = 1;
+    return sizeof(double);
+    case 'x': __A_VARIABLE = 1;
+    return 1;
+    case 'c': __A_VARIABLE = 1;
+    return getnum(fmt, 1);
     case 'i': case 'I': {
       int sz = getnum(fmt, sizeof(int));
       if (sz > MAXINTSIZE)
         luaL_error(L, "integral size %d is larger than limit of %d",
                        sz, MAXINTSIZE);
+      __A_VARIABLE = 1;
       return sz;
     }
-    default: return 0;  /* other cases do not need alignment */
+    default: __A_VARIABLE = 1;
+    return 0;  /* other cases do not need alignment */
   }
 }
 
@@ -133,9 +144,14 @@ static size_t optsize (lua_State *L, char opt, const char **fmt) {
 ** at current position 'len'
 */
 static int gettoalign (size_t len, Header *h, int opt, size_t size) {
-  if (size == 0 || opt == 'c') return 0;
+  volatile int __A_VARIABLE;
+  if (size == 0 || opt == 'c') {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (size > (size_t)h->align)
     size = h->align;  /* respect max. alignment */
+  __A_VARIABLE = 1;
   return (size - (len & (size - 1))) & (size - 1);
 }
 
@@ -145,15 +161,20 @@ static int gettoalign (size_t len, Header *h, int opt, size_t size) {
 */
 static void controloptions (lua_State *L, int opt, const char **fmt,
                             Header *h) {
+  volatile int __A_VARIABLE;
   switch (opt) {
-    case  ' ': return;  /* ignore white spaces */
-    case '>': h->endian = BIG; return;
-    case '<': h->endian = LITTLE; return;
+    case  ' ': __A_VARIABLE = 1;
+    return;  /* ignore white spaces */
+    case '>': h->endian = BIG; __A_VARIABLE = 1;
+    return;
+    case '<': h->endian = LITTLE; __A_VARIABLE = 1;
+    return;
     case '!': {
       int a = getnum(fmt, MAXALIGN);
       if (!isp2(a))
         luaL_error(L, "alignment %d is not a power of 2", a);
       h->align = a;
+      __A_VARIABLE = 1;
       return;
     }
     default: {
@@ -161,11 +182,13 @@ static void controloptions (lua_State *L, int opt, const char **fmt,
       luaL_argerror(L, 1, msg);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void putinteger (lua_State *L, luaL_Buffer *b, int arg, int endian,
                         int size) {
+  volatile int __A_VARIABLE;
   lua_Number n = luaL_checknumber(L, arg);
   Uinttype value;
   char buff[MAXINTSIZE];
@@ -188,10 +211,12 @@ static void putinteger (lua_State *L, luaL_Buffer *b, int arg, int endian,
     }
   }
   luaL_addlstring(b, buff, size);
+  __A_VARIABLE = 1;
 }
 
 
 static void correctbytes (char *b, int size, int endian) {
+  volatile int __A_VARIABLE;
   if (endian != native.endian) {
     int i = 0;
     while (i < --size) {
@@ -200,10 +225,12 @@ static void correctbytes (char *b, int size, int endian) {
       b[size] = temp;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int b_pack (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_Buffer b;
   const char *fmt = luaL_checkstring(L, 1);
   Header h;
@@ -257,6 +284,7 @@ static int b_pack (lua_State *L) {
     totalsize += size;
   }
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -289,6 +317,7 @@ static lua_Number getinteger (const char *buff, int endian,
 
 
 static int b_unpack (lua_State *L) {
+  volatile int __A_VARIABLE;
   Header h;
   const char *fmt = luaL_checkstring(L, 1);
   size_t ld;
@@ -357,11 +386,13 @@ static int b_unpack (lua_State *L) {
     pos += size;
   }
   lua_pushinteger(L, pos + 1);  /* next position */
+  __A_VARIABLE = 1;
   return n + 1;
 }
 
 
 static int b_size (lua_State *L) {
+  volatile int __A_VARIABLE;
   Header h;
   const char *fmt = luaL_checkstring(L, 1);
   size_t pos = 0;
@@ -379,6 +410,7 @@ static int b_size (lua_State *L) {
     pos += size;
   }
   lua_pushinteger(L, pos);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -397,7 +429,9 @@ static const struct luaL_Reg thislib[] = {
 LUALIB_API int luaopen_struct (lua_State *L);
 
 LUALIB_API int luaopen_struct (lua_State *L) {
+  volatile int __A_VARIABLE;
   luaL_register(L, "struct", thislib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/luac.c b/deps/lua/src/luac.c
index d070173..50c28f8 100644
--- a/deps/lua/src/luac.c
+++ b/deps/lua/src/luac.c
@@ -35,18 +35,23 @@ static const char* progname=PROGNAME;	/* actual program name */
 
 static void fatal(const char* message)
 {
+ volatile int __A_VARIABLE;
  fprintf(stderr,"%s: %s\n",progname,message);
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 static void cannot(const char* what)
 {
+ volatile int __A_VARIABLE;
  fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 static void usage(const char* message)
 {
+ volatile int __A_VARIABLE;
  if (*message=='-')
   fprintf(stderr,"%s: unrecognized option " LUA_QS "\n",progname,message);
  else
@@ -63,12 +68,14 @@ static void usage(const char* message)
  "  --       stop handling options\n",
  progname,Output);
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 #define	IS(s)	(strcmp(argv[i],s)==0)
 
 static int doargs(int argc, char* argv[])
 {
+ volatile int __A_VARIABLE;
  int i;
  int version=0;
  if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];
@@ -111,6 +118,7 @@ static int doargs(int argc, char* argv[])
   printf("%s  %s\n",LUA_RELEASE,LUA_COPYRIGHT);
   if (version==argc-1) exit(EXIT_SUCCESS);
  }
+ __A_VARIABLE = 1;
  return i;
 }
 
@@ -146,7 +154,9 @@ static const Proto* combine(lua_State* L, int n)
 
 static int writer(lua_State* L, const void* p, size_t size, void* u)
 {
+ volatile int __A_VARIABLE;
  UNUSED(L);
+ __A_VARIABLE = 1;
  return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
 }
 
@@ -157,6 +167,7 @@ struct Smain {
 
 static int pmain(lua_State* L)
 {
+ volatile int __A_VARIABLE;
  struct Smain* s = (struct Smain*)lua_touserdata(L, 1);
  int argc=s->argc;
  char** argv=s->argv;
@@ -180,11 +191,13 @@ static int pmain(lua_State* L)
   if (ferror(D)) cannot("write");
   if (fclose(D)) cannot("close");
  }
+ __A_VARIABLE = 1;
  return 0;
 }
 
 int main(int argc, char* argv[])
 {
+ volatile int __A_VARIABLE;
  lua_State* L;
  struct Smain s;
  int i=doargs(argc,argv);
@@ -196,5 +209,6 @@ int main(int argc, char* argv[])
  s.argv=argv;
  if (lua_cpcall(L,pmain,&s)!=0) fatal(lua_tostring(L,-1));
  lua_close(L);
+ __A_VARIABLE = 1;
  return EXIT_SUCCESS;
 }
diff --git a/deps/lua/src/lundump.c b/deps/lua/src/lundump.c
index 8010a45..c82842d 100644
--- a/deps/lua/src/lundump.c
+++ b/deps/lua/src/lundump.c
@@ -35,8 +35,10 @@ typedef struct {
 
 static void error(LoadState* S, const char* why)
 {
+ volatile int __A_VARIABLE;
  luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
  luaD_throw(S->L,LUA_ERRSYNTAX);
+ __A_VARIABLE = 1;
 }
 #endif
 
@@ -47,29 +49,37 @@ static void error(LoadState* S, const char* why)
 
 static void LoadBlock(LoadState* S, void* b, size_t size)
 {
+ volatile int __A_VARIABLE;
  size_t r=luaZ_read(S->Z,b,size);
  IF (r!=0, "unexpected end");
+ __A_VARIABLE = 1;
 }
 
 static int LoadChar(LoadState* S)
 {
+ volatile int __A_VARIABLE;
  char x;
  LoadVar(S,x);
+ __A_VARIABLE = 1;
  return x;
 }
 
 static int LoadInt(LoadState* S)
 {
+ volatile int __A_VARIABLE;
  int x;
  LoadVar(S,x);
  IF (x<0, "bad integer");
+ __A_VARIABLE = 1;
  return x;
 }
 
 static lua_Number LoadNumber(LoadState* S)
 {
+ volatile int __A_VARIABLE;
  lua_Number x;
  LoadVar(S,x);
+ __A_VARIABLE = 1;
  return x;
 }
 
@@ -89,16 +99,19 @@ static TString* LoadString(LoadState* S)
 
 static void LoadCode(LoadState* S, Proto* f)
 {
+ volatile int __A_VARIABLE;
  int n=LoadInt(S);
  f->code=luaM_newvector(S->L,n,Instruction);
  f->sizecode=n;
  LoadVector(S,f->code,n,sizeof(Instruction));
+ __A_VARIABLE = 1;
 }
 
 static Proto* LoadFunction(LoadState* S, TString* p);
 
 static void LoadConstants(LoadState* S, Proto* f)
 {
+ volatile int __A_VARIABLE;
  int i,n;
  n=LoadInt(S);
  f->k=luaM_newvector(S->L,n,TValue);
@@ -132,10 +145,12 @@ static void LoadConstants(LoadState* S, Proto* f)
  f->sizep=n;
  for (i=0; i<n; i++) f->p[i]=NULL;
  for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
+ __A_VARIABLE = 1;
 }
 
 static void LoadDebug(LoadState* S, Proto* f)
 {
+ volatile int __A_VARIABLE;
  int i,n;
  n=LoadInt(S);
  f->lineinfo=luaM_newvector(S->L,n,int);
@@ -156,10 +171,12 @@ static void LoadDebug(LoadState* S, Proto* f)
  f->sizeupvalues=n;
  for (i=0; i<n; i++) f->upvalues[i]=NULL;
  for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
+ __A_VARIABLE = 1;
 }
 
 static Proto* LoadFunction(LoadState* S, TString* p)
 {
+ volatile int __A_VARIABLE;
  Proto* f;
  if (++S->L->nCcalls > LUAI_MAXCCALLS) error(S,"code too deep");
  f=luaF_newproto(S->L);
@@ -177,16 +194,19 @@ static Proto* LoadFunction(LoadState* S, TString* p)
  IF (!luaG_checkcode(f), "bad code");
  S->L->top--;
  S->L->nCcalls--;
+ __A_VARIABLE = 1;
  return f;
 }
 
 static void LoadHeader(LoadState* S)
 {
+ volatile int __A_VARIABLE;
  char h[LUAC_HEADERSIZE];
  char s[LUAC_HEADERSIZE];
  luaU_header(h);
  LoadBlock(S,s,LUAC_HEADERSIZE);
  IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, "bad header");
+ __A_VARIABLE = 1;
 }
 
 /*
@@ -194,6 +214,7 @@ static void LoadHeader(LoadState* S)
 */
 Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
 {
+ volatile int __A_VARIABLE;
  LoadState S;
  if (*name=='@' || *name=='=')
   S.name=name+1;
@@ -205,6 +226,7 @@ Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
  S.Z=Z;
  S.b=buff;
  LoadHeader(&S);
+ __A_VARIABLE = 1;
  return LoadFunction(&S,luaS_newliteral(L,"=?"));
 }
 
@@ -213,6 +235,7 @@ Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
 */
 void luaU_header (char* h)
 {
+ volatile int __A_VARIABLE;
  int x=1;
  memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-1);
  h+=sizeof(LUA_SIGNATURE)-1;
@@ -224,4 +247,5 @@ void luaU_header (char* h)
  *h++=(char)sizeof(Instruction);
  *h++=(char)sizeof(lua_Number);
  *h++=(char)(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/lvm.c b/deps/lua/src/lvm.c
index e0a0cd8..bbcaee0 100644
--- a/deps/lua/src/lvm.c
+++ b/deps/lua/src/lvm.c
@@ -58,6 +58,7 @@ int luaV_tostring (lua_State *L, StkId obj) {
 
 
 static void traceexec (lua_State *L, const Instruction *pc) {
+  volatile int __A_VARIABLE;
   lu_byte mask = L->hookmask;
   const Instruction *oldpc = L->savedpc;
   L->savedpc = pc;
@@ -74,11 +75,13 @@ static void traceexec (lua_State *L, const Instruction *pc) {
     if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
       luaD_callhook(L, LUA_HOOKLINE, newline);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void callTMres (lua_State *L, StkId res, const TValue *f,
                         const TValue *p1, const TValue *p2) {
+  volatile int __A_VARIABLE;
   ptrdiff_t result = savestack(L, res);
   setobj2s(L, L->top, f);  /* push function */
   setobj2s(L, L->top+1, p1);  /* 1st argument */
@@ -89,12 +92,14 @@ static void callTMres (lua_State *L, StkId res, const TValue *f,
   res = restorestack(L, result);
   L->top--;
   setobjs2s(L, res, L->top);
+  __A_VARIABLE = 1;
 }
 
 
 
 static void callTM (lua_State *L, const TValue *f, const TValue *p1,
                     const TValue *p2, const TValue *p3) {
+  volatile int __A_VARIABLE;
   setobj2s(L, L->top, f);  /* push function */
   setobj2s(L, L->top+1, p1);  /* 1st argument */
   setobj2s(L, L->top+2, p2);  /* 2nd argument */
@@ -102,6 +107,7 @@ static void callTM (lua_State *L, const TValue *f, const TValue *p1,
   luaD_checkstack(L, 4);
   L->top += 4;
   luaD_call(L, L->top - 4, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -164,38 +170,63 @@ void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
 
 static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
                        StkId res, TMS event) {
+  volatile int __A_VARIABLE;
   const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
   if (ttisnil(tm))
     tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
-  if (ttisnil(tm)) return 0;
+  if (ttisnil(tm)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   callTMres(L, res, tm, p1, p2);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
                                   TMS event) {
+  volatile int __A_VARIABLE;
   const TValue *tm1 = fasttm(L, mt1, event);
   const TValue *tm2;
-  if (tm1 == NULL) return NULL;  /* no metamethod */
-  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  if (tm1 == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no metamethod */
+  if (mt1 == mt2) {
+    __A_VARIABLE = 1;
+    return tm1;
+  }  /* same metatables => same metamethods */
   tm2 = fasttm(L, mt2, event);
-  if (tm2 == NULL) return NULL;  /* no metamethod */
-  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+  if (tm2 == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */ {
+    __A_VARIABLE = 1;
     return tm1;
+  }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
 
 static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
                          TMS event) {
+  volatile int __A_VARIABLE;
   const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
   const TValue *tm2;
-  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  if (ttisnil(tm1)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* no metamethod? */
   tm2 = luaT_gettmbyobj(L, p2, event);
-  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */ {
+    __A_VARIABLE = 1;
     return -1;
+  }
   callTMres(L, L->top, tm1, p1, p2);
+  __A_VARIABLE = 1;
   return !l_isfalse(L->top);
 }
 
@@ -253,33 +284,50 @@ static int lessequal (lua_State *L, const TValue *l, const TValue *r) {
 
 
 int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
+  volatile int __A_VARIABLE;
   const TValue *tm;
   lua_assert(ttype(t1) == ttype(t2));
   switch (ttype(t1)) {
-    case LUA_TNIL: return 1;
-    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
-    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
-    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TNIL: __A_VARIABLE = 1;
+    return 1;
+    case LUA_TNUMBER: __A_VARIABLE = 1;
+    return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: __A_VARIABLE = 1;
+    return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: __A_VARIABLE = 1;
+    return pvalue(t1) == pvalue(t2);
     case LUA_TUSERDATA: {
-      if (uvalue(t1) == uvalue(t2)) return 1;
+      if (uvalue(t1) == uvalue(t2)) {
+        __A_VARIABLE = 1;
+        return 1;
+      }
       tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
                          TM_EQ);
       break;  /* will try TM */
     }
     case LUA_TTABLE: {
-      if (hvalue(t1) == hvalue(t2)) return 1;
+      if (hvalue(t1) == hvalue(t2)) {
+      __A_VARIABLE = 1;
+      return 1;
+      }
       tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
       break;  /* will try TM */
     }
-    default: return gcvalue(t1) == gcvalue(t2);
+    default: __A_VARIABLE = 1;
+    return gcvalue(t1) == gcvalue(t2);
   }
-  if (tm == NULL) return 0;  /* no TM? */
+  if (tm == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* no TM? */
   callTMres(L, L->top, tm, t1, t2);  /* call TM */
+  __A_VARIABLE = 1;
   return !l_isfalse(L->top);
 }
 
 
 void luaV_concat (lua_State *L, int total, int last) {
+  volatile int __A_VARIABLE;
   do {
     StkId top = L->base + last + 1;
     int n = 2;  /* number of elements handled in this pass (at least 2) */
@@ -311,11 +359,13 @@ void luaV_concat (lua_State *L, int total, int last) {
     total -= n-1;  /* got `n' strings to create 1 new */
     last -= n-1;
   } while (total > 1);  /* repeat until only 1 result left */
+  __A_VARIABLE = 1;
 }
 
 
 static void Arith (lua_State *L, StkId ra, const TValue *rb,
                    const TValue *rc, TMS op) {
+  volatile int __A_VARIABLE;
   TValue tempb, tempc;
   const TValue *b, *c;
   if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
@@ -334,6 +384,7 @@ static void Arith (lua_State *L, StkId ra, const TValue *rb,
   }
   else if (!call_binTM(L, rb, rc, ra, op))
     luaG_aritherror(L, rb, rc);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/deps/lua/src/lzio.c b/deps/lua/src/lzio.c
index 293edd5..8477cef 100644
--- a/deps/lua/src/lzio.c
+++ b/deps/lua/src/lzio.c
@@ -19,15 +19,20 @@
 
 
 int luaZ_fill (ZIO *z) {
+  volatile int __A_VARIABLE;
   size_t size;
   lua_State *L = z->L;
   const char *buff;
   lua_unlock(L);
   buff = z->reader(L, z->data, &size);
   lua_lock(L);
-  if (buff == NULL || size == 0) return EOZ;
+  if (buff == NULL || size == 0) {
+    __A_VARIABLE = 1;
+    return EOZ;
+  }
   z->n = size - 1;
   z->p = buff;
+  __A_VARIABLE = 1;
   return char2int(*(z->p++));
 }
 
@@ -46,20 +51,25 @@ int luaZ_lookahead (ZIO *z) {
 
 
 void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
+  volatile int __A_VARIABLE;
   z->L = L;
   z->reader = reader;
   z->data = data;
   z->n = 0;
   z->p = NULL;
+  __A_VARIABLE = 1;
 }
 
 
 /* --------------------------------------------------------------- read --- */
 size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  volatile int __A_VARIABLE;
   while (n) {
     size_t m;
-    if (luaZ_lookahead(z) == EOZ)
-      return n;  /* return number of missing bytes */
+    if (luaZ_lookahead(z) == EOZ) {
+      __A_VARIABLE = 1;
+      return n;
+    }  /* return number of missing bytes */
     m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
     memcpy(b, z->p, m);
     z->n -= m;
@@ -67,15 +77,18 @@ size_t luaZ_read (ZIO *z, void *b, size_t n) {
     b = (char *)b + m;
     n -= m;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
 /* ------------------------------------------------------------------------ */
 char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  volatile int __A_VARIABLE;
   if (n > buff->buffsize) {
     if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
     luaZ_resizebuffer(L, buff, n);
   }
+  __A_VARIABLE = 1;
   return buff->buffer;
 }
 
diff --git a/deps/lua/src/print.c b/deps/lua/src/print.c
index e240cfc..006f780 100644
--- a/deps/lua/src/print.c
+++ b/deps/lua/src/print.c
@@ -22,6 +22,7 @@
 
 static void PrintString(const TString* ts)
 {
+ volatile int __A_VARIABLE;
  const char* s=getstr(ts);
  size_t i,n=ts->tsv.len;
  putchar('"');
@@ -46,10 +47,12 @@ static void PrintString(const TString* ts)
   }
  }
  putchar('"');
+ __A_VARIABLE = 1;
 }
 
 static void PrintConstant(const Proto* f, int i)
 {
+ volatile int __A_VARIABLE;
  const TValue* o=&f->k[i];
  switch (ttype(o))
  {
@@ -69,10 +72,12 @@ static void PrintConstant(const Proto* f, int i)
 	printf("? type=%d",ttype(o));
 	break;
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintCode(const Proto* f)
 {
+ volatile int __A_VARIABLE;
  const Instruction* code=f->code;
  int pc,n=f->sizecode;
  for (pc=0; pc<n; pc++)
@@ -153,6 +158,7 @@ static void PrintCode(const Proto* f)
   }
   printf("\n");
  }
+ __A_VARIABLE = 1;
 }
 
 #define SS(x)	(x==1)?"":"s"
@@ -160,6 +166,7 @@ static void PrintCode(const Proto* f)
 
 static void PrintHeader(const Proto* f)
 {
+ volatile int __A_VARIABLE;
  const char* s=getstr(f->source);
  if (*s=='@' || *s=='=')
   s++;
@@ -176,10 +183,12 @@ static void PrintHeader(const Proto* f)
 	S(f->maxstacksize),S(f->nups));
  printf("%d local%s, %d constant%s, %d function%s\n",
 	S(f->sizelocvars),S(f->sizek),S(f->sizep));
+ __A_VARIABLE = 1;
 }
 
 static void PrintConstants(const Proto* f)
 {
+ volatile int __A_VARIABLE;
  int i,n=f->sizek;
  printf("constants (%d) for %p:\n",n,VOID(f));
  for (i=0; i<n; i++)
@@ -188,10 +197,12 @@ static void PrintConstants(const Proto* f)
   PrintConstant(f,i);
   printf("\n");
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintLocals(const Proto* f)
 {
+ volatile int __A_VARIABLE;
  int i,n=f->sizelocvars;
  printf("locals (%d) for %p:\n",n,VOID(f));
  for (i=0; i<n; i++)
@@ -199,21 +210,28 @@ static void PrintLocals(const Proto* f)
   printf("\t%d\t%s\t%d\t%d\n",
   i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintUpvalues(const Proto* f)
 {
+ volatile int __A_VARIABLE;
  int i,n=f->sizeupvalues;
  printf("upvalues (%d) for %p:\n",n,VOID(f));
- if (f->upvalues==NULL) return;
+ if (f->upvalues==NULL) {
+  __A_VARIABLE = 1;
+  return;
+ }
  for (i=0; i<n; i++)
  {
   printf("\t%d\t%s\n",i,getstr(f->upvalues[i]));
  }
+ __A_VARIABLE = 1;
 }
 
 void PrintFunction(const Proto* f, int full)
 {
+ volatile int __A_VARIABLE;
  int i,n=f->sizep;
  PrintHeader(f);
  PrintCode(f);
@@ -224,4 +242,5 @@ void PrintFunction(const Proto* f, int full)
   PrintUpvalues(f);
  }
  for (i=0; i<n; i++) PrintFunction(f->p[i],full);
+ __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/strbuf.c b/deps/lua/src/strbuf.c
index f0f7f4b..b8b6059 100644
--- a/deps/lua/src/strbuf.c
+++ b/deps/lua/src/strbuf.c
@@ -31,6 +31,7 @@
 
 static void die(const char *fmt, ...)
 {
+    volatile int __A_VARIABLE;
     va_list arg;
 
     va_start(arg, fmt);
@@ -39,10 +40,12 @@ static void die(const char *fmt, ...)
     fprintf(stderr, "\n");
 
     exit(-1);
+    __A_VARIABLE = 1;
 }
 
 void strbuf_init(strbuf_t *s, int len)
 {
+    volatile int __A_VARIABLE;
     int size;
 
     if (len <= 0)
@@ -63,10 +66,12 @@ void strbuf_init(strbuf_t *s, int len)
         die("Out of memory");
 
     strbuf_ensure_null(s);
+    __A_VARIABLE = 1;
 }
 
 strbuf_t *strbuf_new(int len)
 {
+    volatile int __A_VARIABLE;
     strbuf_t *s;
 
     s = malloc(sizeof(strbuf_t));
@@ -78,31 +83,37 @@ strbuf_t *strbuf_new(int len)
     /* Dynamic strbuf allocation / deallocation */
     s->dynamic = 1;
 
+    __A_VARIABLE = 1;
     return s;
 }
 
 void strbuf_set_increment(strbuf_t *s, int increment)
 {
+    volatile int __A_VARIABLE;
     /* Increment > 0:  Linear buffer growth rate
      * Increment < -1: Exponential buffer growth rate */
     if (increment == 0 || increment == -1)
         die("BUG: Invalid string increment");
 
     s->increment = increment;
+    __A_VARIABLE = 1;
 }
 
 static inline void debug_stats(strbuf_t *s)
 {
+    volatile int __A_VARIABLE;
     if (s->debug) {
         fprintf(stderr, "strbuf(%lx) reallocs: %d, length: %d, size: %d\n",
                 (long)s, s->reallocs, s->length, s->size);
     }
+    __A_VARIABLE = 1;
 }
 
 /* If strbuf_t has not been dynamically allocated, strbuf_free() can
  * be called any number of times strbuf_init() */
 void strbuf_free(strbuf_t *s)
 {
+    volatile int __A_VARIABLE;
     debug_stats(s);
 
     if (s->buf) {
@@ -111,10 +122,12 @@ void strbuf_free(strbuf_t *s)
     }
     if (s->dynamic)
         free(s);
+    __A_VARIABLE = 1;
 }
 
 char *strbuf_free_to_string(strbuf_t *s, int *len)
 {
+    volatile int __A_VARIABLE;
     char *buf;
 
     debug_stats(s);
@@ -128,11 +141,13 @@ char *strbuf_free_to_string(strbuf_t *s, int *len)
     if (s->dynamic)
         free(s);
 
+    __A_VARIABLE = 1;
     return buf;
 }
 
 static int calculate_new_size(strbuf_t *s, int len)
 {
+    volatile int __A_VARIABLE;
     int reqsize, newsize;
 
     if (len <= 0)
@@ -142,8 +157,10 @@ static int calculate_new_size(strbuf_t *s, int len)
     reqsize = len + 1;
 
     /* If the user has requested to shrink the buffer, do it exactly */
-    if (s->size > reqsize)
+    if (s->size > reqsize) {
+        __A_VARIABLE = 1;
         return reqsize;
+    }
 
     newsize = s->size;
     if (s->increment < 0) {
@@ -155,6 +172,7 @@ static int calculate_new_size(strbuf_t *s, int len)
         newsize = ((newsize + s->increment - 1) / s->increment) * s->increment;
     }
 
+    __A_VARIABLE = 1;
     return newsize;
 }
 
@@ -163,6 +181,7 @@ static int calculate_new_size(strbuf_t *s, int len)
  * optional termination). */
 void strbuf_resize(strbuf_t *s, int len)
 {
+    volatile int __A_VARIABLE;
     int newsize;
 
     newsize = calculate_new_size(s, len);
@@ -177,10 +196,12 @@ void strbuf_resize(strbuf_t *s, int len)
     if (!s->buf)
         die("Out of memory");
     s->reallocs++;
+    __A_VARIABLE = 1;
 }
 
 void strbuf_append_string(strbuf_t *s, const char *str)
 {
+    volatile int __A_VARIABLE;
     int space, i;
 
     space = strbuf_empty_length(s);
@@ -195,12 +216,14 @@ void strbuf_append_string(strbuf_t *s, const char *str)
         s->length++;
         space--;
     }
+    __A_VARIABLE = 1;
 }
 
 /* strbuf_append_fmt() should only be used when an upper bound
  * is known for the output string. */
 void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...)
 {
+    volatile int __A_VARIABLE;
     va_list arg;
     int fmt_len;
 
@@ -214,12 +237,14 @@ void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...)
         die("BUG: Unable to convert number");  /* This should never happen.. */
 
     s->length += fmt_len;
+    __A_VARIABLE = 1;
 }
 
 /* strbuf_append_fmt_retry() can be used when the there is no known
  * upper bound for the output string. */
 void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)
 {
+    volatile int __A_VARIABLE;
     va_list arg;
     int fmt_len, try;
     int empty_len;
@@ -245,6 +270,7 @@ void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)
     }
 
     s->length += fmt_len;
+    __A_VARIABLE = 1;
 }
 
 /* vi:ai et sw=4 ts=4:
diff --git a/src/adlist.c b/src/adlist.c
index ec5f8bb..a595fd2 100644
--- a/src/adlist.c
+++ b/src/adlist.c
@@ -40,15 +40,19 @@
  * On error, NULL is returned. Otherwise the pointer to the new list. */
 list *listCreate(void)
 {
+    volatile int __A_VARIABLE;
     struct list *list;
 
-    if ((list = zmalloc(sizeof(*list))) == NULL)
+    if ((list = zmalloc(sizeof(*list))) == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
     list->head = list->tail = NULL;
     list->len = 0;
     list->dup = NULL;
     list->free = NULL;
     list->match = NULL;
+    __A_VARIABLE = 1;
     return list;
 }
 
@@ -75,8 +79,10 @@ void listEmpty(list *list)
  * This function can't fail. */
 void listRelease(list *list)
 {
+    volatile int __A_VARIABLE;
     listEmpty(list);
     zfree(list);
+    __A_VARIABLE = 1;
 }
 
 /* Add a new node to the list, to head, containing the specified 'value'
@@ -198,7 +204,9 @@ listIter *listGetIterator(list *list, int direction)
 
 /* Release the iterator memory */
 void listReleaseIterator(listIter *iter) {
+    volatile int __A_VARIABLE;
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Create an iterator in the list private iterator structure */
@@ -228,6 +236,7 @@ void listRewindTail(list *list, listIter *li) {
  * */
 listNode *listNext(listIter *iter)
 {
+    volatile int __A_VARIABLE;
     listNode *current = iter->next;
 
     if (current != NULL) {
@@ -236,6 +245,7 @@ listNode *listNext(listIter *iter)
         else
             iter->next = current->prev;
     }
+    __A_VARIABLE = 1;
     return current;
 }
 
@@ -345,6 +355,7 @@ void listRotate(list *list) {
 /* Add all the elements of the list 'o' at the end of the
  * list 'l'. The list 'other' remains empty but otherwise valid. */
 void listJoin(list *l, list *o) {
+    volatile int __A_VARIABLE;
     if (o->head)
         o->head->prev = l->tail;
 
@@ -359,4 +370,5 @@ void listJoin(list *l, list *o) {
     /* Setup other as an empty list. */
     o->head = o->tail = NULL;
     o->len = 0;
+    __A_VARIABLE = 1;
 }
diff --git a/src/ae.c b/src/ae.c
index cd2894a..88a56b8 100644
--- a/src/ae.c
+++ b/src/ae.c
@@ -49,6 +49,7 @@
 int gettimeofday(struct timeval *tv, void *tz);
 static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 {
+	volatile int __A_VARIABLE;
 	int now;
 	struct timeval _ptimeval __attribute__((flexos_whitelist));
 	/* this argument is actually obsolete */
@@ -58,6 +59,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -80,6 +82,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 #endif
 
 aeEventLoop *aeCreateEventLoop(int setsize) {
+    volatile int __A_VARIABLE;
     aeEventLoop *eventLoop;
     int i;
 
@@ -100,6 +103,7 @@ aeEventLoop *aeCreateEventLoop(int setsize) {
      * vector with it. */
     for (i = 0; i < setsize; i++)
         eventLoop->events[i].mask = AE_NONE;
+    __A_VARIABLE = 1;
     return eventLoop;
 
 err:
@@ -108,11 +112,14 @@ err:
         zfree(eventLoop->fired);
         zfree(eventLoop);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Return the current set size. */
 int aeGetSetSize(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return eventLoop->setsize;
 }
 
@@ -124,11 +131,21 @@ int aeGetSetSize(aeEventLoop *eventLoop) {
  *
  * Otherwise AE_OK is returned and the operation is successful. */
 int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
+    volatile int __A_VARIABLE;
     int i;
 
-    if (setsize == eventLoop->setsize) return AE_OK;
-    if (eventLoop->maxfd >= setsize) return AE_ERR;
-    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;
+    if (setsize == eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return AE_OK;
+    }
+    if (eventLoop->maxfd >= setsize) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
+    if (aeApiResize(eventLoop,setsize) == -1) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
 
     eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
     eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
@@ -138,45 +155,62 @@ int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
      * an AE_NONE mask. */
     for (i = eventLoop->maxfd+1; i < setsize; i++)
         eventLoop->events[i].mask = AE_NONE;
+    __A_VARIABLE = 1;
     return AE_OK;
 }
 
 void aeDeleteEventLoop(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiFree(eventLoop);
     zfree(eventLoop->events);
     zfree(eventLoop->fired);
     zfree(eventLoop);
+    __A_VARIABLE = 1;
 }
 
 void aeStop(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     eventLoop->stop = 1;
+    __A_VARIABLE = 1;
 }
 
 int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
         aeFileProc *proc, void *clientData)
 {
+    volatile int __A_VARIABLE;
     if (fd >= eventLoop->setsize) {
         errno = ERANGE;
+        __A_VARIABLE = 1;
         return AE_ERR;
     }
     aeFileEvent *fe = &eventLoop->events[fd];
 
-    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
+    if (aeApiAddEvent(eventLoop, fd, mask) == -1) {
+        __A_VARIABLE = 1;
         return AE_ERR;
+    }
     fe->mask |= mask;
     if (mask & AE_READABLE) fe->rfileProc = proc;
     if (mask & AE_WRITABLE) fe->wfileProc = proc;
     fe->clientData = clientData;
     if (fd > eventLoop->maxfd)
         eventLoop->maxfd = fd;
+    __A_VARIABLE = 1;
     return AE_OK;
 }
 
 void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
 {
-    if (fd >= eventLoop->setsize) return;
+    volatile int __A_VARIABLE;
+    if (fd >= eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return;
+    }
     aeFileEvent *fe = &eventLoop->events[fd];
-    if (fe->mask == AE_NONE) return;
+    if (fe->mask == AE_NONE) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* We want to always remove AE_BARRIER if set when AE_WRITABLE
      * is removed. */
@@ -192,25 +226,34 @@ void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
             if (eventLoop->events[j].mask != AE_NONE) break;
         eventLoop->maxfd = j;
     }
+    __A_VARIABLE = 1;
 }
 
 int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {
-    if (fd >= eventLoop->setsize) return 0;
+    volatile int __A_VARIABLE;
+    if (fd >= eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     aeFileEvent *fe = &eventLoop->events[fd];
 
+    __A_VARIABLE = 1;
     return fe->mask;
 }
 
 static void aeGetTime(long *seconds, long *milliseconds)
 {
+    volatile int __A_VARIABLE;
     struct timeval tv;
 
     gettimeofday(&tv, NULL);
     *seconds = tv.tv_sec;
     *milliseconds = tv.tv_usec/1000;
+    __A_VARIABLE = 1;
 }
 
 static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {
+    volatile int __A_VARIABLE;
     long cur_sec, cur_ms, when_sec, when_ms;
 
     aeGetTime(&cur_sec, &cur_ms);
@@ -222,17 +265,22 @@ static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms)
     }
     *sec = when_sec;
     *ms = when_ms;
+    __A_VARIABLE = 1;
 }
 
 long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
         aeTimeProc *proc, void *clientData,
         aeEventFinalizerProc *finalizerProc)
 {
+    volatile int __A_VARIABLE;
     long long id = eventLoop->timeEventNextId++;
     aeTimeEvent *te;
 
     te = zmalloc(sizeof(*te));
-    if (te == NULL) return AE_ERR;
+    if (te == NULL) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
     te->id = id;
     aeAddMillisecondsToNow(milliseconds,&te->when_sec,&te->when_ms);
     te->timeProc = proc;
@@ -243,19 +291,23 @@ long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
     if (te->next)
         te->next->prev = te;
     eventLoop->timeEventHead = te;
+    __A_VARIABLE = 1;
     return id;
 }
 
 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
 {
+    volatile int __A_VARIABLE;
     aeTimeEvent *te = eventLoop->timeEventHead;
     while(te) {
         if (te->id == id) {
             te->id = AE_DELETED_EVENT_ID;
+            __A_VARIABLE = 1;
             return AE_OK;
         }
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return AE_ERR; /* NO event with the specified ID found */
 }
 
@@ -272,6 +324,7 @@ int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
  */
 static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)
 {
+    volatile int __A_VARIABLE;
     aeTimeEvent *te = eventLoop->timeEventHead;
     aeTimeEvent *nearest = NULL;
 
@@ -282,11 +335,13 @@ static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)
             nearest = te;
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return nearest;
 }
 
 /* Process time events */
 static int processTimeEvents(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     int processed = 0;
     aeTimeEvent *te;
     long long maxId;
@@ -357,6 +412,7 @@ static int processTimeEvents(aeEventLoop *eventLoop) {
         }
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return processed;
 }
 
@@ -377,10 +433,14 @@ static struct timeval tv __section(".data_shared"), *tvp __section(".data_shared
  * The function returns the number of events processed. */
 int aeProcessEvents(aeEventLoop *eventLoop, int flags)
 {
+    volatile int __A_VARIABLE;
     int processed = 0, numevents;
 
     /* Nothing to do? return ASAP */
-    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;
+    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Note that we want call select() even if there are no
      * file events to process as long as we want to process time
@@ -487,6 +547,7 @@ int aeProcessEvents(aeEventLoop *eventLoop, int flags)
     if (flags & AE_TIME_EVENTS)
         processed += processTimeEvents(eventLoop);
 
+    __A_VARIABLE = 1;
     return processed; /* return the number of processed file/time events */
 }
 
@@ -513,24 +574,32 @@ int aeWait(int fd, int mask, long long milliseconds) {
 }
 
 void aeMain(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     eventLoop->stop = 0;
     while (!eventLoop->stop) {
         if (eventLoop->beforesleep != NULL)
             eventLoop->beforesleep(eventLoop);
         aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
     }
+    __A_VARIABLE = 1;
 }
 
 char *aeGetApiName(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return aeApiName();
 }
 
 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
+    volatile int __A_VARIABLE;
     eventLoop->beforesleep = beforesleep;
+    __A_VARIABLE = 1;
 }
 
 void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
+    volatile int __A_VARIABLE;
     eventLoop->aftersleep = aftersleep;
+    __A_VARIABLE = 1;
 }
 
 #undef gettimeofday
diff --git a/src/ae_epoll.c b/src/ae_epoll.c
index 410aac7..c011b81 100644
--- a/src/ae_epoll.c
+++ b/src/ae_epoll.c
@@ -37,40 +37,52 @@ typedef struct aeApiState {
 } aeApiState;
 
 static int aeApiCreate(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = zmalloc(sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     state->events = zmalloc(sizeof(struct epoll_event)*eventLoop->setsize);
     if (!state->events) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     state->epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
     if (state->epfd == -1) {
         zfree(state->events);
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     state->events = zrealloc(state->events, sizeof(struct epoll_event)*setsize);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiFree(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     close(state->epfd);
     zfree(state->events);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     struct epoll_event ee = {0}; /* avoid valgrind warning */
     /* If the fd was already monitored for some event, we need a MOD
@@ -83,11 +95,16 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
     if (mask & AE_READABLE) ee.events |= EPOLLIN;
     if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
     ee.data.fd = fd;
-    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
+    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     struct epoll_event ee = {0}; /* avoid valgrind warning */
     int mask = eventLoop->events[fd].mask & (~delmask);
@@ -103,9 +120,11 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
          * EPOLL_CTL_DEL. */
         epoll_ctl(state->epfd,EPOLL_CTL_DEL,fd,&ee);
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     int retval, numevents = 0;
 
@@ -127,9 +146,12 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             eventLoop->fired[j].mask = mask;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return "epoll";
 }
diff --git a/src/ae_evport.c b/src/ae_evport.c
index 5c317be..5b22cef 100644
--- a/src/ae_evport.c
+++ b/src/ae_evport.c
@@ -73,13 +73,18 @@ typedef struct aeApiState {
 } aeApiState;
 
 static int aeApiCreate(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     int i;
     aeApiState *state = zmalloc(sizeof(aeApiState));
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     state->portfd = port_create();
     if (state->portfd == -1) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
 
@@ -91,29 +96,38 @@ static int aeApiCreate(aeEventLoop *eventLoop) {
     }
 
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    volatile int __A_VARIABLE;
     /* Nothing to resize here. */
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiFree(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     close(state->portfd);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiLookupPending(aeApiState *state, int fd) {
+    volatile int __A_VARIABLE;
     int i;
 
     for (i = 0; i < state->npending; i++) {
-        if (state->pending_fds[i] == fd)
+        if (state->pending_fds[i] == fd) {
+            __A_VARIABLE = 1;
             return (i);
+        }
     }
 
+    __A_VARIABLE = 1;
     return (-1);
 }
 
@@ -121,6 +135,7 @@ static int aeApiLookupPending(aeApiState *state, int fd) {
  * Helper function to invoke port_associate for the given fd and mask.
  */
 static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
+    volatile int __A_VARIABLE;
     int events = 0;
     int rv, err;
 
@@ -146,10 +161,12 @@ static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
             fprintf(stderr, "aeApiAssociate: event port limit exceeded.");
     }
 
+    __A_VARIABLE = 1;
     return rv;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     int fullmask, pfd;
 
@@ -174,13 +191,16 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
         if (evport_debug)
             fprintf(stderr, "aeApiAddEvent: adding to pending fd %d\n", fd);
         state->pending_masks[pfd] |= fullmask;
+        __A_VARIABLE = 1;
         return 0;
     }
 
+    __A_VARIABLE = 1;
     return (aeApiAssociate("aeApiAddEvent", state->portfd, fd, fullmask));
 }
 
 static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     int fullmask, pfd;
 
@@ -203,6 +223,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
         if (state->pending_masks[pfd] == AE_NONE)
             state->pending_fds[pfd] = -1;
 
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -238,9 +259,11 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
          */
         abort(); /* will not return */
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     struct timespec timeout, *tsp;
     int mask, i;
@@ -284,8 +307,10 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
     nevents = 1;
     if (port_getn(state->portfd, event, MAX_EVENT_BATCHSZ, &nevents,
         tsp) == -1 && (errno != ETIME || nevents == 0)) {
-        if (errno == ETIME || errno == EINTR)
+        if (errno == ETIME || errno == EINTR) {
+            __A_VARIABLE = 1;
             return 0;
+        }
 
         /* Any other error indicates a bug. */
         perror("aeApiPoll: port_get");
@@ -312,9 +337,12 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             state->pending_masks[i] = (uintptr_t)event[i].portev_user;
     }
 
+    __A_VARIABLE = 1;
     return nevents;
 }
 
 static char *aeApiName(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return "evport";
 }
diff --git a/src/ae_kqueue.c b/src/ae_kqueue.c
index 6796f4c..fdbbed0 100644
--- a/src/ae_kqueue.c
+++ b/src/ae_kqueue.c
@@ -39,55 +39,75 @@ typedef struct aeApiState {
 } aeApiState;
 
 static int aeApiCreate(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = zmalloc(sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     state->events = zmalloc(sizeof(struct kevent)*eventLoop->setsize);
     if (!state->events) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     state->kqfd = kqueue();
     if (state->kqfd == -1) {
         zfree(state->events);
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiFree(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     close(state->kqfd);
     zfree(state->events);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     struct kevent ke;
 
     if (mask & AE_READABLE) {
         EV_SET(&ke, fd, EVFILT_READ, EV_ADD, 0, 0, NULL);
-        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
     if (mask & AE_WRITABLE) {
         EV_SET(&ke, fd, EVFILT_WRITE, EV_ADD, 0, 0, NULL);
-        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     struct kevent ke;
 
@@ -99,9 +119,11 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
         EV_SET(&ke, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
         kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     int retval, numevents = 0;
 
@@ -130,9 +152,12 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             eventLoop->fired[j].mask = mask;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return "kqueue";
 }
diff --git a/src/ae_select.c b/src/ae_select.c
index ed4f2a3..bacf3dd 100644
--- a/src/ae_select.c
+++ b/src/ae_select.c
@@ -42,41 +42,58 @@ typedef struct aeApiState {
 #include <flexos/isolation.h>
 
 static int aeApiCreate(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     aeApiState *state = flexos_calloc_whitelist(1, sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     FD_ZERO(&state->rfds);
     FD_ZERO(&state->wfds);
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    volatile int __A_VARIABLE;
     /* Just ensure we have enough room in the fd_set type. */
-    if (setsize >= FD_SETSIZE) return -1;
+    if (setsize >= FD_SETSIZE) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiFree(aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     zfree(eventLoop->apidata);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
     if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
 
     if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
     if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
+    volatile int __A_VARIABLE;
     aeApiState *state = eventLoop->apidata;
     int retval, j, numevents = 0;
 
@@ -102,9 +119,12 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             numevents++;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return "select";
 }
diff --git a/src/anet.c b/src/anet.c
index 69005e5..f652c75 100644
--- a/src/anet.c
+++ b/src/anet.c
@@ -51,15 +51,21 @@
 
 static void anetSetError(char *err, const char *fmt, ...)
 {
+    volatile int __A_VARIABLE;
     va_list ap;
 
-    if (!err) return;
+    if (!err) {
+        __A_VARIABLE = 1;
+        return;
+    }
     va_start(ap, fmt);
     vsnprintf(err, ANET_ERR_LEN, fmt, ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 int anetSetBlock(char *err, int fd, int non_block) {
+    volatile int __A_VARIABLE;
     int flags;
 
     /* Set the socket blocking (if non_block is zero) or non-blocking.
@@ -67,6 +73,7 @@ int anetSetBlock(char *err, int fd, int non_block) {
      * interrupted by a signal. */
     if ((flags = fcntl(fd, F_GETFL)) == -1) {
         anetSetError(err, "fcntl(F_GETFL): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -77,16 +84,22 @@ int anetSetBlock(char *err, int fd, int non_block) {
 
     if (fcntl(fd, F_SETFL, flags) == -1) {
         anetSetError(err, "fcntl(F_SETFL,O_NONBLOCK): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetNonBlock(char *err, int fd) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetSetBlock(err,fd,1);
 }
 
 int anetBlock(char *err, int fd) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetSetBlock(err,fd,0);
 }
 
@@ -149,55 +162,69 @@ int anetKeepAlive(char *err, int fd, int interval)
 
 static int anetSetTcpNoDelay(char *err, int fd, int val)
 {
+    volatile int __A_VARIABLE;
     int _val __attribute__((flexos_whitelist)) = val;
     int ret;
     flexos_gate_r(liblwip, ret, setsockopt, fd, IPPROTO_TCP, TCP_NODELAY, &_val, sizeof(_val));
     if (ret == -1)
     {
         anetSetError(err, "setsockopt TCP_NODELAY: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetEnableTcpNoDelay(char *err, int fd)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetSetTcpNoDelay(err, fd, 1);
 }
 
 int anetDisableTcpNoDelay(char *err, int fd)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetSetTcpNoDelay(err, fd, 0);
 }
 
 
 int anetSetSendBuffer(char *err, int fd, int buffsize)
 {
+    volatile int __A_VARIABLE;
     int ret;
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_SNDBUF, &buffsize, sizeof(buffsize));
     if (ret == -1)
     {
         anetSetError(err, "setsockopt SO_SNDBUF: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetTcpKeepAlive(char *err, int fd)
 {
+    volatile int __A_VARIABLE;
     int yes = 1;
     int ret;
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_KEEPALIVE: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 /* Set the socket send timeout (SO_SNDTIMEO socket option) to the specified
  * number of milliseconds, or disable it if the 'ms' argument is zero. */
 int anetSendTimeout(char *err, int fd, long long ms) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
 
     tv.tv_sec = ms/1000;
@@ -206,8 +233,10 @@ int anetSendTimeout(char *err, int fd, long long ms) {
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_SNDTIMEO: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -221,6 +250,7 @@ int anetSendTimeout(char *err, int fd, long long ms) {
 int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
                        int flags)
 {
+    volatile int __A_VARIABLE;
     struct addrinfo hints, *info;
     int rv;
 
@@ -232,6 +262,7 @@ int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
     flexos_gate_r(liblwip, rv, getaddrinfo, host, NULL, &hints, &info);
     if (rv != 0) {
         anetSetError(err, "%s", gai_strerror(rv));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
     if (info->ai_family == AF_INET) {
@@ -243,18 +274,24 @@ int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
     }
 
     freeaddrinfo(info);
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetGenericResolve(err,host,ipbuf,ipbuf_len,ANET_NONE);
 }
 
 int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetGenericResolve(err,host,ipbuf,ipbuf_len,ANET_IP_ONLY);
 }
 
 static int anetSetReuseAddr(char *err, int fd) {
+    volatile int __A_VARIABLE;
     int yes __attribute__((flexos_whitelist)) = 1;
     /* Make sure connection-intensive things like the redis benchmark
      * will be able to close/open sockets a zillion of times */
@@ -262,16 +299,20 @@ static int anetSetReuseAddr(char *err, int fd) {
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_REUSEADDR: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 static int anetCreateSocket(char *err, int domain) {
+    volatile int __A_VARIABLE;
     int s;
     flexos_gate_r(liblwip, s, socket, domain, SOCK_STREAM, 0);
     if (s == -1) {
         anetSetError(err, "creating socket: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -279,8 +320,10 @@ static int anetCreateSocket(char *err, int domain) {
      * will be able to close/open sockets a zillion of times */
     if (anetSetReuseAddr(err,s) == ANET_ERR) {
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -372,17 +415,23 @@ end:
 
 int anetTcpConnect(char *err, char *addr, int port)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONE);
 }
 
 int anetTcpNonBlockConnect(char *err, char *addr, int port)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);
 }
 
 int anetTcpNonBlockBindConnect(char *err, char *addr, int port,
                                char *source_addr)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,source_addr,
             ANET_CONNECT_NONBLOCK);
 }
@@ -390,45 +439,59 @@ int anetTcpNonBlockBindConnect(char *err, char *addr, int port,
 int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port,
                                          char *source_addr)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,source_addr,
             ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);
 }
 
 int anetUnixGenericConnect(char *err, char *path, int flags)
 {
+    volatile int __A_VARIABLE;
     int s;
     struct sockaddr_un sa;
 
-    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
+    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
     if (flags & ANET_CONNECT_NONBLOCK) {
         if (anetNonBlock(err,s) != ANET_OK) {
             close(s);
+            __A_VARIABLE = 1;
             return ANET_ERR;
         }
     }
     if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
         if (errno == EINPROGRESS &&
-            flags & ANET_CONNECT_NONBLOCK)
+            flags & ANET_CONNECT_NONBLOCK) {
+            __A_VARIABLE = 1;
             return s;
+        }
 
         anetSetError(err, "connect: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 int anetUnixConnect(char *err, char *path)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetUnixGenericConnect(err,path,ANET_CONNECT_NONE);
 }
 
 int anetUnixNonBlockConnect(char *err, char *path)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return anetUnixGenericConnect(err,path,ANET_CONNECT_NONBLOCK);
 }
 
@@ -436,14 +499,22 @@ int anetUnixNonBlockConnect(char *err, char *path)
  * (unless error or EOF condition is encountered) */
 int anetRead(int fd, char *buf, int count)
 {
+    volatile int __A_VARIABLE;
     ssize_t nread, totlen = 0;
     while(totlen != count) {
         nread = read(fd,buf,count-totlen);
-        if (nread == 0) return totlen;
-        if (nread == -1) return -1;
+        if (nread == 0) {
+            __A_VARIABLE = 1;
+            return totlen;
+        }
+        if (nread == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         totlen += nread;
         buf += nread;
     }
+    __A_VARIABLE = 1;
     return totlen;
 }
 
@@ -451,24 +522,34 @@ int anetRead(int fd, char *buf, int count)
  * (unless error is encountered) */
 int anetWrite(int fd, char *buf, int count)
 {
+    volatile int __A_VARIABLE;
     ssize_t nwritten, totlen = 0;
     while(totlen != count) {
         nwritten = write(fd,buf,count-totlen);
-        if (nwritten == 0) return totlen;
-        if (nwritten == -1) return -1;
+        if (nwritten == 0) {
+            __A_VARIABLE = 1;
+            return totlen;
+        }
+        if (nwritten == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         totlen += nwritten;
         buf += nwritten;
     }
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {
+    volatile int __A_VARIABLE;
     int ret;
 
     flexos_gate_r(liblwip, ret, bind, s,sa,len);
     if (ret == -1) {
         anetSetError(err, "bind: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -476,25 +557,31 @@ static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int
     if (ret == -1) {
         anetSetError(err, "listen: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 static int anetV6Only(char *err, int s) {
+    volatile int __A_VARIABLE;
     int yes __attribute__((flexos_whitelist)) = 1;
     int ret;
     flexos_gate_r(liblwip, ret, setsockopt, s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes));
     if (ret == -1) {
         anetSetError(err, "setsockopt: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
 {
+    volatile int __A_VARIABLE;
     int s = -1, rv;
     char _port[6] __attribute__((flexos_whitelist));  /* strlen("65535") */
     struct addrinfo hints __attribute__((flexos_whitelist));
@@ -511,6 +598,7 @@ static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backl
 
     if (rv != 0) {
         anetSetError(err, "%s", gai_strerror(rv));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
     for (p = servinfo; p != NULL; p = p->ai_next) {
@@ -533,34 +621,45 @@ error:
     s = ANET_ERR;
 end:
     flexos_gate(liblwip, freeaddrinfo, servinfo);
+    __A_VARIABLE = 1;
     return s;
 }
 
 int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
 }
 
 int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);
 }
 
 int anetUnixServer(char *err, char *path, mode_t perm, int backlog)
 {
+    volatile int __A_VARIABLE;
     int s;
     struct sockaddr_un sa;
 
-    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
+    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     memset(&sa,0,sizeof(sa));
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
-    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)
+    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
     if (perm)
         chmod(sa.sun_path, perm);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -584,9 +683,12 @@ static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *l
 static struct sockaddr_storage sa __section(".data_shared");
 static socklen_t salen __section(".data_shared") = sizeof(sa);
 int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {
+    volatile int __A_VARIABLE;
     int fd;
-    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
+    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     if (sa.ss_family == AF_INET) {
         struct sockaddr_in *s = (struct sockaddr_in *)&sa;
@@ -597,20 +699,26 @@ int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {
         if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
         if (port) *port = ntohs(s->sin6_port);
     }
+    __A_VARIABLE = 1;
     return fd;
 }
 
 int anetUnixAccept(char *err, int s) {
+    volatile int __A_VARIABLE;
     int fd;
     struct sockaddr_un sa;
     socklen_t salen = sizeof(sa);
-    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
+    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return fd;
 }
 
 int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {
+    volatile int __A_VARIABLE;
     struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
     int ret;
@@ -633,6 +741,7 @@ int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {
     } else {
         goto error;
     }
+    __A_VARIABLE = 1;
     return 0;
 
 error:
@@ -645,6 +754,7 @@ error:
         }
     }
     if (port) *port = 0;
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -652,20 +762,25 @@ error:
  * (matches for ":"), the ip is surrounded by []. IP and port are just
  * separated by colons. This the standard to display addresses within Redis. */
 int anetFormatAddr(char *buf, size_t buf_len, char *ip, int port) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return snprintf(buf,buf_len, strchr(ip,':') ?
            "[%s]:%d" : "%s:%d", ip, port);
 }
 
 /* Like anetFormatAddr() but extract ip and port from the socket's peer. */
 int anetFormatPeer(int fd, char *buf, size_t buf_len) {
+    volatile int __A_VARIABLE;
     char ip[INET6_ADDRSTRLEN];
     int port;
 
     anetPeerToString(fd,ip,sizeof(ip),&port);
+    __A_VARIABLE = 1;
     return anetFormatAddr(buf, buf_len, ip, port);
 }
 
 int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
+    volatile int __A_VARIABLE;
     struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
 
@@ -673,6 +788,7 @@ int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
         if (port) *port = 0;
         ip[0] = '?';
         ip[1] = '\0';
+        __A_VARIABLE = 1;
         return -1;
     }
     if (sa.ss_family == AF_INET) {
@@ -684,13 +800,16 @@ int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
         if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
         if (port) *port = ntohs(s->sin6_port);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 int anetFormatSock(int fd, char *fmt, size_t fmt_len) {
+    volatile int __A_VARIABLE;
     char ip[INET6_ADDRSTRLEN];
     int port;
 
     anetSockName(fd,ip,sizeof(ip),&port);
+    __A_VARIABLE = 1;
     return anetFormatAddr(fmt, fmt_len, ip, port);
 }
diff --git a/src/aof.c b/src/aof.c
index 1014164..e493bf2 100644
--- a/src/aof.c
+++ b/src/aof.c
@@ -68,15 +68,18 @@ typedef struct aofrwblock {
  * a fresh new one. It tests for server.aof_rewrite_buf_blocks equal to NULL
  * so can be used for the first initialization as well. */
 void aofRewriteBufferReset(void) {
+    volatile int __A_VARIABLE;
     if (server.aof_rewrite_buf_blocks)
         listRelease(server.aof_rewrite_buf_blocks);
 
     server.aof_rewrite_buf_blocks = listCreate();
     listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
+    __A_VARIABLE = 1;
 }
 
 /* Return the current size of the AOF rewrite buffer. */
 unsigned long aofRewriteBufferSize(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     unsigned long size = 0;
@@ -86,6 +89,7 @@ unsigned long aofRewriteBufferSize(void) {
         aofrwblock *block = listNodeValue(ln);
         size += block->used;
     }
+    __A_VARIABLE = 1;
     return size;
 }
 
@@ -93,6 +97,7 @@ unsigned long aofRewriteBufferSize(void) {
  * rewrite. We send pieces of our AOF differences buffer so that the final
  * write when the child finishes the rewrite will be small. */
 void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     aofrwblock *block;
     ssize_t nwritten;
@@ -107,22 +112,28 @@ void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
         if (server.aof_stop_sending_diff || !block) {
             aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
                               AE_WRITABLE);
+            __A_VARIABLE = 1;
             return;
         }
         if (block->used > 0) {
             nwritten = write(server.aof_pipe_write_data_to_child,
                              block->buf,block->used);
-            if (nwritten <= 0) return;
+            if (nwritten <= 0) {
+            	__A_VARIABLE = 1;
+            	return;
+            }
             memmove(block->buf,block->buf+nwritten,block->used-nwritten);
             block->used -= nwritten;
             block->free += nwritten;
         }
         if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Append data to the AOF rewrite buffer, allocating new blocks if needed. */
 void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
+    volatile int __A_VARIABLE;
     listNode *ln = listLast(server.aof_rewrite_buf_blocks);
     aofrwblock *block = ln ? ln->value : NULL;
 
@@ -166,12 +177,14 @@ void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
         aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
             AE_WRITABLE, aofChildWriteDiffData, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Write the buffer (possibly composed of multiple blocks) into the specified
  * fd. If a short write or any other error happens -1 is returned,
  * otherwise the number of bytes written is returned. */
 ssize_t aofRewriteBufferWrite(int fd) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     ssize_t count = 0;
@@ -185,11 +198,13 @@ ssize_t aofRewriteBufferWrite(int fd) {
             nwritten = write(fd,block->buf,block->used);
             if (nwritten != (ssize_t)block->used) {
                 if (nwritten == 0) errno = EIO;
+                __A_VARIABLE = 1;
                 return -1;
             }
             count += nwritten;
         }
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -200,20 +215,28 @@ ssize_t aofRewriteBufferWrite(int fd) {
 /* Return true if an AOf fsync is currently already in progress in a
  * BIO thread. */
 int aofFsyncInProgress(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
 }
 
 /* Starts a background task that performs fsync() against the specified
  * file descriptor (the one of the AOF file) in another thread. */
 void aof_background_fsync(int fd) {
+    volatile int __A_VARIABLE;
     bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(long)fd,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Kills an AOFRW child process if exists */
 static void killAppendOnlyChild(void) {
+    volatile int __A_VARIABLE;
     int statloc;
     /* No AOFRW child? return. */
-    if (server.aof_child_pid == -1) return;
+    if (server.aof_child_pid == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Kill AOFRW child, wait for child exit. */
     serverLog(LL_NOTICE,"Killing running AOF rewrite child: %ld",
         (long) server.aof_child_pid);
@@ -227,11 +250,13 @@ static void killAppendOnlyChild(void) {
     server.aof_rewrite_time_start = -1;
     /* Close pipes used for IPC between the two processes. */
     aofClosePipes();
+    __A_VARIABLE = 1;
 }
 
 /* Called when the user switches from "appendonly yes" to "appendonly no"
  * at runtime using the CONFIG command. */
 void stopAppendOnly(void) {
+    volatile int __A_VARIABLE;
     serverAssert(server.aof_state != AOF_OFF);
     flushAppendOnlyFile(1);
     redis_fsync(server.aof_fd);
@@ -241,6 +266,7 @@ void stopAppendOnly(void) {
     server.aof_selected_db = -1;
     server.aof_state = AOF_OFF;
     killAppendOnlyChild();
+    __A_VARIABLE = 1;
 }
 
 /* Called when the user switches from "appendonly no" to "appendonly yes"
@@ -295,6 +321,7 @@ int startAppendOnly(void) {
  * true, and in general it looks just more resilient to retry the write. If
  * there is an actual error condition we'll get it at the next try. */
 ssize_t aofWrite(int fd, const char *buf, size_t len) {
+    volatile int __A_VARIABLE;
     ssize_t nwritten = 0, totwritten = 0;
 
     while(len) {
@@ -304,6 +331,7 @@ ssize_t aofWrite(int fd, const char *buf, size_t len) {
             if (errno == EINTR) {
                 continue;
             }
+            __A_VARIABLE = 1;
             return totwritten ? totwritten : -1;
         }
 
@@ -312,6 +340,7 @@ ssize_t aofWrite(int fd, const char *buf, size_t len) {
         totwritten += nwritten;
     }
 
+    __A_VARIABLE = 1;
     return totwritten;
 }
 
@@ -516,6 +545,7 @@ try_fsync:
 }
 
 sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
+    volatile int __A_VARIABLE;
     char buf[32];
     int len, j;
     robj *o;
@@ -537,6 +567,7 @@ sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
         dst = sdscatlen(dst,"\r\n",2);
         decrRefCount(o);
     }
+    __A_VARIABLE = 1;
     return dst;
 }
 
@@ -548,6 +579,7 @@ sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
  * into PEXPIREAT command so that we retain precision in the append only
  * file, and the time is always absolute and not relative. */
 sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {
+    volatile int __A_VARIABLE;
     long long when;
     robj *argv[3];
 
@@ -574,10 +606,12 @@ sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, r
     buf = catAppendOnlyGenericCommand(buf, 3, argv);
     decrRefCount(argv[0]);
     decrRefCount(argv[2]);
+    __A_VARIABLE = 1;
     return buf;
 }
 
 void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
+    volatile int __A_VARIABLE;
     sds buf = sdsempty();
     robj *tmpargv[3];
 
@@ -641,6 +675,7 @@ void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int a
         aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
 
     sdsfree(buf);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -650,6 +685,7 @@ void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int a
 /* In Redis commands are always executed in the context of a client, so in
  * order to load the append only file we need to create a fake client. */
 struct client *createFakeClient(void) {
+    volatile int __A_VARIABLE;
     struct client *c = zmalloc(sizeof(*c));
 
     selectDb(c,0);
@@ -673,29 +709,35 @@ struct client *createFakeClient(void) {
     listSetFreeMethod(c->reply,freeClientReplyValue);
     listSetDupMethod(c->reply,dupClientReplyValue);
     initClientMultiState(c);
+    __A_VARIABLE = 1;
     return c;
 }
 
 void freeFakeClientArgv(struct client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < c->argc; j++)
         decrRefCount(c->argv[j]);
     zfree(c->argv);
+    __A_VARIABLE = 1;
 }
 
 void freeFakeClient(struct client *c) {
+    volatile int __A_VARIABLE;
     sdsfree(c->querybuf);
     listRelease(c->reply);
     listRelease(c->watched_keys);
     freeClientMultiState(c);
     zfree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Replay the append log file. On success C_OK is returned. On non fatal
  * error (the append only file is zero-length) C_ERR is returned. On
  * fatal error an error message is logged and the program exists. */
 int loadAppendOnlyFile(char *filename) {
+    volatile int __A_VARIABLE;
     struct client *fakeClient;
     FILE *fp = fopen(filename,"r");
     struct redis_stat sb;
@@ -717,6 +759,7 @@ int loadAppendOnlyFile(char *filename) {
         server.aof_current_size = 0;
         server.aof_fsync_offset = server.aof_current_size;
         fclose(fp);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -855,6 +898,7 @@ loaded_ok: /* DB loaded, cleanup and return C_OK to the caller. */
     aofUpdateCurrentSize();
     server.aof_rewrite_base_size = server.aof_current_size;
     server.aof_fsync_offset = server.aof_current_size;
+    __A_VARIABLE = 1;
     return C_OK;
 
 readerr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */
@@ -897,6 +941,7 @@ fmterr: /* Format error. */
     if (fakeClient) freeFakeClient(fakeClient); /* avoid valgrind warning */
     serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -1096,6 +1141,7 @@ static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
 /* Emit the commands needed to rebuild a hash object.
  * The function returns 0 on error, 1 on success. */
 int rewriteHashObject(rio *r, robj *key, robj *o) {
+    volatile int __A_VARIABLE;
     hashTypeIterator *hi;
     long long count = 0, items = hashTypeLength(o);
 
@@ -1105,30 +1151,51 @@ int rewriteHashObject(rio *r, robj *key, robj *o) {
             int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                 AOF_REWRITE_ITEMS_PER_CMD : items;
 
-            if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
-            if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
-            if (rioWriteBulkObject(r,key) == 0) return 0;
+            if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
+            if (rioWriteBulkString(r,"HMSET",5) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
+            if (rioWriteBulkObject(r,key) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
         }
 
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
         items--;
     }
 
     hashTypeReleaseIterator(hi);
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Helper for rewriteStreamObject() that generates a bulk string into the
  * AOF representing the ID 'id'. */
 int rioWriteBulkStreamID(rio *r,streamID *id) {
+    volatile int __A_VARIABLE;
     int retval;
 
     sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
-    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) return 0;
+    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     sdsfree(replyid);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1137,23 +1204,64 @@ int rioWriteBulkStreamID(rio *r,streamID *id) {
  * list of the specified consumer. All this in the context of the specified
  * key and group. */
 int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
+    volatile int __A_VARIABLE;
      /* XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
                RETRYCOUNT <count> JUSTID FORCE. */
     streamID id;
     streamDecodeID(rawid,&id);
-    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
-    if (rioWriteBulkString(r,"XCLAIM",6) == 0) return 0;
-    if (rioWriteBulkObject(r,key) == 0) return 0;
-    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
-    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
-    if (rioWriteBulkString(r,"0",1) == 0) return 0;
-    if (rioWriteBulkStreamID(r,&id) == 0) return 0;
-    if (rioWriteBulkString(r,"TIME",4) == 0) return 0;
-    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
-    if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
-    if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) return 0;
-    if (rioWriteBulkString(r,"JUSTID",6) == 0) return 0;
-    if (rioWriteBulkString(r,"FORCE",5) == 0) return 0;
+    if (rioWriteBulkCount(r,'*',12) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"XCLAIM",6) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkObject(r,key) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,groupname,groupname_len) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"0",1) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkStreamID(r,&id) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"TIME",4) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"JUSTID",6) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"FORCE",5) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1259,6 +1367,7 @@ int rewriteStreamObject(rio *r, robj *key, robj *o) {
  * that is exported by a module and is not handled by Redis itself.
  * The function returns 0 on error, 1 on success. */
 int rewriteModuleObject(rio *r, robj *key, robj *o) {
+    volatile int __A_VARIABLE;
     RedisModuleIO io;
     moduleValue *mv = o->ptr;
     moduleType *mt = mv->type;
@@ -1268,6 +1377,7 @@ int rewriteModuleObject(rio *r, robj *key, robj *o) {
         moduleFreeContext(io.ctx);
         zfree(io.ctx);
     }
+    __A_VARIABLE = 1;
     return io.error ? 0 : 1;
 }
 
@@ -1275,6 +1385,7 @@ int rewriteModuleObject(rio *r, robj *key, robj *o) {
  * the difference accumulated from the parent into a buffer, that is
  * concatenated at the end of the rewrite. */
 ssize_t aofReadDiffFromParent(void) {
+    volatile int __A_VARIABLE;
     char buf[65536]; /* Default pipe buffer size on most Linux systems. */
     ssize_t nread, total = 0;
 
@@ -1283,10 +1394,12 @@ ssize_t aofReadDiffFromParent(void) {
         server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
         total += nread;
     }
+    __A_VARIABLE = 1;
     return total;
 }
 
 int rewriteAppendOnlyFileRio(rio *aof) {
+    volatile int __A_VARIABLE;
     dictIterator *di = NULL;
     dictEntry *de;
     size_t processed = 0;
@@ -1354,10 +1467,12 @@ int rewriteAppendOnlyFileRio(rio *aof) {
         dictReleaseIterator(di);
         di = NULL;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     if (di) dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1369,6 +1484,7 @@ werr:
  * and ZADD. However at max AOF_REWRITE_ITEMS_PER_CMD items per time
  * are inserted using a single command. */
 int rewriteAppendOnlyFile(char *filename) {
+    volatile int __A_VARIABLE;
     rio aof;
     FILE *fp;
     char tmpfile[256];
@@ -1380,6 +1496,7 @@ int rewriteAppendOnlyFile(char *filename) {
     fp = fopen(tmpfile,"w");
     if (!fp) {
         serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1454,15 +1571,18 @@ int rewriteAppendOnlyFile(char *filename) {
     if (rename(tmpfile,filename) == -1) {
         serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", strerror(errno));
         unlink(tmpfile);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     serverLog(LL_WARNING,"Write error writing append only file on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1474,6 +1594,7 @@ werr:
  * single '!' char to signal we should stop sending buffer diffs. The
  * parent sends a '!' as well to acknowledge. */
 void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     char byte;
     UNUSED(el);
     UNUSED(privdata);
@@ -1494,6 +1615,7 @@ void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
     /* Remove the handler since this can be called only one time during a
      * rewrite. */
     aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
+    __A_VARIABLE = 1;
 }
 
 /* Create the pipes used for parent - child process IPC during rewrite.
@@ -1502,6 +1624,7 @@ void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
  * the rewrite so no more data should be written, and another for the
  * parent to acknowledge it understood this new condition. */
 int aofCreatePipes(void) {
+    volatile int __A_VARIABLE;
     int fds[6] = {-1, -1, -1, -1, -1, -1};
     int j;
 
@@ -1520,16 +1643,19 @@ int aofCreatePipes(void) {
     server.aof_pipe_write_ack_to_child = fds[5];
     server.aof_pipe_read_ack_from_parent = fds[4];
     server.aof_stop_sending_diff = 0;
+    __A_VARIABLE = 1;
     return C_OK;
 
 error:
     serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
         strerror(errno));
     for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
 void aofClosePipes(void) {
+    volatile int __A_VARIABLE;
     aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
     aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
     close(server.aof_pipe_write_data_to_child);
@@ -1538,6 +1664,7 @@ void aofClosePipes(void) {
     close(server.aof_pipe_read_ack_from_child);
     close(server.aof_pipe_write_ack_to_child);
     close(server.aof_pipe_read_ack_from_parent);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -1617,6 +1744,7 @@ int rewriteAppendOnlyFileBackground(void) {
 }
 
 void bgrewriteaofCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (server.aof_child_pid != -1) {
         addReplyError(c,"Background append only file rewriting already in progress");
     } else if (server.rdb_child_pid != -1) {
@@ -1627,13 +1755,16 @@ void bgrewriteaofCommand(client *c) {
     } else {
         addReply(c,shared.err);
     }
+    __A_VARIABLE = 1;
 }
 
 void aofRemoveTempFile(pid_t childpid) {
+    volatile int __A_VARIABLE;
     char tmpfile[256];
 
     snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) childpid);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* Update the server.aof_current_size field explicitly using stat(2)
@@ -1641,6 +1772,7 @@ void aofRemoveTempFile(pid_t childpid) {
  * a restart, normally the size is updated just adding the write length
  * to the current length, that is much faster. */
 void aofUpdateCurrentSize(void) {
+    volatile int __A_VARIABLE;
     struct redis_stat sb;
     mstime_t latency;
 
@@ -1653,11 +1785,13 @@ void aofUpdateCurrentSize(void) {
     }
     latencyEndMonitor(latency);
     latencyAddSampleIfNeeded("aof-fstat",latency);
+    __A_VARIABLE = 1;
 }
 
 /* A background append only file rewriting (BGREWRITEAOF) terminated its work.
  * Handle this. */
 void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
+    volatile int __A_VARIABLE;
     if (!bysignal && exitcode == 0) {
         int newfd, oldfd;
         char tmpfile[256];
@@ -1805,4 +1939,5 @@ cleanup:
     /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */
     if (server.aof_state == AOF_WAIT_REWRITE)
         server.aof_rewrite_scheduled = 1;
+    __A_VARIABLE = 1;
 }
diff --git a/src/bio.c b/src/bio.c
index 2af6845..c3759c9 100644
--- a/src/bio.c
+++ b/src/bio.c
@@ -94,6 +94,7 @@ void lazyfreeFreeSlotsMapFromBioThread(zskiplist *sl);
 
 /* Initialize the background system, spawning the thread. */
 void bioInit(void) {
+    volatile int __A_VARIABLE;
     pthread_attr_t attr;
     pthread_t thread;
     size_t stacksize;
@@ -126,9 +127,11 @@ void bioInit(void) {
         }
         bio_threads[j] = thread;
     }
+    __A_VARIABLE = 1;
 }
 
 void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
+    volatile int __A_VARIABLE;
     struct bio_job *job = zmalloc(sizeof(*job));
 
     job->time = time(NULL);
@@ -140,9 +143,11 @@ void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
     bio_pending[type]++;
     pthread_cond_signal(&bio_newjob_cond[type]);
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
 }
 
 void *bioProcessBackgroundJobs(void *arg) {
+    volatile int __A_VARIABLE;
     struct bio_job *job;
     unsigned long type = (unsigned long) arg;
     sigset_t sigset;
@@ -151,6 +156,7 @@ void *bioProcessBackgroundJobs(void *arg) {
     if (type >= BIO_NUM_OPS) {
         serverLog(LL_WARNING,
             "Warning: bio thread started with wrong type %lu",type);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -213,14 +219,17 @@ void *bioProcessBackgroundJobs(void *arg) {
         /* Unblock threads blocked on bioWaitStepOfType() if any. */
         pthread_cond_broadcast(&bio_step_cond[type]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of pending jobs of the specified type. */
 unsigned long long bioPendingJobsOfType(int type) {
+    volatile int __A_VARIABLE;
     unsigned long long val;
     pthread_mutex_lock(&bio_mutex[type]);
     val = bio_pending[type];
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -235,6 +244,7 @@ unsigned long long bioPendingJobsOfType(int type) {
  * a bio.c thread to do more work in a blocking way.
  */
 unsigned long long bioWaitStepOfType(int type) {
+    volatile int __A_VARIABLE;
     unsigned long long val;
     pthread_mutex_lock(&bio_mutex[type]);
     val = bio_pending[type];
@@ -243,6 +253,7 @@ unsigned long long bioWaitStepOfType(int type) {
         val = bio_pending[type];
     }
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -251,6 +262,7 @@ unsigned long long bioWaitStepOfType(int type) {
  * Currently Redis does this only on crash (for instance on SIGSEGV) in order
  * to perform a fast memory check without other threads messing with memory. */
 void bioKillThreads(void) {
+    volatile int __A_VARIABLE;
     int err, j;
 
     for (j = 0; j < BIO_NUM_OPS; j++) {
@@ -265,4 +277,5 @@ void bioKillThreads(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/bitops.c b/src/bitops.c
index 7328d63..09b641c 100644
--- a/src/bitops.c
+++ b/src/bitops.c
@@ -38,6 +38,7 @@
  * 'count' bytes. The implementation of this function is required to
  * work with a input string length up to 512 MB. */
 size_t redisPopcount(void *s, long count) {
+    volatile int __A_VARIABLE;
     size_t bits = 0;
     unsigned char *p = s;
     uint32_t *p4;
@@ -88,6 +89,7 @@ size_t redisPopcount(void *s, long count) {
     /* Count the remaining bytes. */
     p = (unsigned char*)p4;
     while(count--) bits += bitsinbyte[*p++];
+    __A_VARIABLE = 1;
     return bits;
 }
 
@@ -99,6 +101,7 @@ size_t redisPopcount(void *s, long count) {
  * padded on the right. However if 'bit' is 1 it is possible that there is
  * not a single set bit in the bitmap. In this special case -1 is returned. */
 long redisBitpos(void *s, unsigned long count, int bit) {
+    volatile int __A_VARIABLE;
     unsigned long *l;
     unsigned char *c;
     unsigned long skipval, word = 0, one;
@@ -163,7 +166,10 @@ long redisBitpos(void *s, unsigned long count, int bit) {
      * return -1 to signal that there is not a single "1" in the whole
      * string. This can't happen when we are looking for "0" as we assume
      * that the right of the string is zero padded. */
-    if (bit == 1 && word == 0) return -1;
+    if (bit == 1 && word == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Last word left, scan bit by bit. The first thing we need is to
      * have a single "1" set in the most significant position in an
@@ -174,7 +180,10 @@ long redisBitpos(void *s, unsigned long count, int bit) {
     one = ~one;      /* All bits set to 0 but the MSB. */
 
     while(one) {
-        if (((one & word) != 0) == bit) return pos;
+        if (((one & word) != 0) == bit) {
+            __A_VARIABLE = 1;
+            return pos;
+        }
         pos++;
         one >>= 1;
     }
@@ -182,6 +191,7 @@ long redisBitpos(void *s, unsigned long count, int bit) {
     /* If we reached this point, there is a bug in the algorithm, since
      * the case of no match is handled as a special case before. */
     serverPanic("End of redisBitpos() reached.");
+    __A_VARIABLE = 1;
     return 0; /* Just to avoid warnings. */
 }
 
@@ -207,6 +217,7 @@ long redisBitpos(void *s, unsigned long count, int bit) {
  */
 
 void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
+    volatile int __A_VARIABLE;
     uint64_t byte, bit, byteval, bitval, j;
 
     for (j = 0; j < bits; j++) {
@@ -219,14 +230,18 @@ void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint6
         p[byte] = byteval & 0xff;
         offset++;
     }
+    __A_VARIABLE = 1;
 }
 
 void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
+    volatile int __A_VARIABLE;
     uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
     setUnsignedBitfield(p,offset,bits,uv);
+    __A_VARIABLE = 1;
 }
 
 uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
+    volatile int __A_VARIABLE;
     uint64_t byte, bit, byteval, bitval, j, value = 0;
 
     for (j = 0; j < bits; j++) {
@@ -237,10 +252,12 @@ uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
         value = (value<<1) | bitval;
         offset++;
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
 int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
+    volatile int __A_VARIABLE;
     int64_t value;
     union {uint64_t u; int64_t i;} conv;
 
@@ -259,6 +276,7 @@ int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
      * integers. */
     if (value & ((uint64_t)1 << (bits-1)))
         value |= ((uint64_t)-1) << bits;
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -377,6 +395,7 @@ handle_wrap:
 /* Debugging function. Just show bits in the specified bitmap. Not used
  * but here for not having to rewrite it when debugging is needed. */
 void printBits(unsigned char *p, unsigned long count) {
+    volatile int __A_VARIABLE;
     unsigned long j, i, byte;
 
     for (j = 0; j < count; j++) {
@@ -386,6 +405,7 @@ void printBits(unsigned char *p, unsigned long count) {
         printf("|");
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -409,6 +429,7 @@ void printBits(unsigned char *p, unsigned long count) {
  * will also parse bit offsets prefixed by "#". In such a case the offset
  * is multiplied by 'bits'. This is useful for the BITFIELD command. */
 int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {
+    volatile int __A_VARIABLE;
     long long loffset;
     char *err = "bit offset is not an integer or out of range";
     char *p = o->ptr;
@@ -420,6 +441,7 @@ int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int b
 
     if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -430,10 +452,12 @@ int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int b
     if ((loffset < 0) || ((unsigned long long)loffset >> 3) >= (512*1024*1024))
     {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     *offset = (size_t)loffset;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -504,6 +528,7 @@ robj *lookupStringForBitCommand(client *c, size_t maxbit) {
  * If the source object is NULL the function is guaranteed to return NULL
  * and set 'len' to 0. */
 unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
+    volatile int __A_VARIABLE;
     serverAssert(o->type == OBJ_STRING);
     unsigned char *p = NULL;
 
@@ -518,11 +543,13 @@ unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
     } else {
         if (len) *len = 0;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
 /* SETBIT key offset bitvalue */
 void setbitCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     char *err = "bit is not an integer or out of range";
     size_t bitoffset;
@@ -530,19 +557,27 @@ void setbitCommand(client *c) {
     int byteval, bitval;
     long on;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
-    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
+    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* Bits can only be set or cleared... */
     if (on & ~1) {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return;
     }
 
-    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;
+    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Get current values */
     byte = bitoffset >> 3;
@@ -558,21 +593,28 @@ void setbitCommand(client *c) {
     notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c, bitval ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 /* GETBIT key offset */
 void getbitCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     char llbuf[32];
     size_t bitoffset;
     size_t byte, bit;
     size_t bitval = 0;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     byte = bitoffset >> 3;
     bit = 7 - (bitoffset & 0x7);
@@ -585,6 +627,7 @@ void getbitCommand(client *c) {
     }
 
     addReply(c, bitval ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 /* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */
diff --git a/src/blocked.c b/src/blocked.c
index 2b43f2b..cb3dd5e 100644
--- a/src/blocked.c
+++ b/src/blocked.c
@@ -76,14 +76,18 @@ int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb
  * commands API this means no timeout) the value stored into 'timeout'
  * is zero. */
 int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {
+    volatile int __A_VARIABLE;
     long long tval;
 
     if (getLongLongFromObjectOrReply(c,object,&tval,
-        "timeout is not an integer or out of range") != C_OK)
+        "timeout is not an integer or out of range") != C_OK) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
 
     if (tval < 0) {
         addReplyError(c,"timeout is negative");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -93,6 +97,7 @@ int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int
     }
     *timeout = tval;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -100,16 +105,19 @@ int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int
  * flag is set client query buffer is not longer processed, but accumulated,
  * and will be processed when the client is unblocked. */
 void blockClient(client *c, int btype) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_BLOCKED;
     c->btype = btype;
     server.blocked_clients++;
     server.blocked_clients_by_type[btype]++;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called in the beforeSleep() function of the event loop
  * in order to process the pending input buffer of clients that were
  * unblocked after a blocking operation. */
 void processUnblockedClients(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     client *c;
 
@@ -130,6 +138,7 @@ void processUnblockedClients(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function will schedule the client for reprocessing at a safe time.
@@ -149,17 +158,20 @@ void processUnblockedClients(void) {
  *    process it for queries ready to be executed at a safe time.
  */
 void queueClientForReprocessing(client *c) {
+    volatile int __A_VARIABLE;
     /* The client may already be into the unblocked list because of a previous
      * blocking operation, don't add back it into the list multiple times. */
     if (!(c->flags & CLIENT_UNBLOCKED)) {
         c->flags |= CLIENT_UNBLOCKED;
         listAddNodeTail(server.unblocked_clients,c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Unblock a client calling the right function depending on the kind
  * of operation the client is blocking for. */
 void unblockClient(client *c) {
+    volatile int __A_VARIABLE;
     if (c->btype == BLOCKED_LIST ||
         c->btype == BLOCKED_ZSET ||
         c->btype == BLOCKED_STREAM) {
@@ -178,12 +190,14 @@ void unblockClient(client *c) {
     c->flags &= ~CLIENT_BLOCKED;
     c->btype = BLOCKED_NONE;
     queueClientForReprocessing(c);
+    __A_VARIABLE = 1;
 }
 
 /* This function gets called when a blocked client timed out in order to
  * send it a reply of some kind. After this function is called,
  * unblockClient() will be called with the same client as argument. */
 void replyToBlockedClientTimedOut(client *c) {
+    volatile int __A_VARIABLE;
     if (c->btype == BLOCKED_LIST ||
         c->btype == BLOCKED_ZSET ||
         c->btype == BLOCKED_STREAM) {
@@ -195,6 +209,7 @@ void replyToBlockedClientTimedOut(client *c) {
     } else {
         serverPanic("Unknown btype in replyToBlockedClientTimedOut().");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Mass-unblock clients because something changed in the instance that makes
@@ -205,6 +220,7 @@ void replyToBlockedClientTimedOut(client *c) {
  * The semantics is to send an -UNBLOCKED error to the client, disconnecting
  * it at the same time. */
 void disconnectAllBlockedClients(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
 
@@ -220,6 +236,7 @@ void disconnectAllBlockedClients(void) {
             c->flags |= CLIENT_CLOSE_AFTER_REPLY;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function should be called by Redis every time a single command,
@@ -244,6 +261,7 @@ void disconnectAllBlockedClients(void) {
  * be used only for a single type, like virtually any Redis application will
  * do, the function is already fair. */
 void handleClientsBlockedOnKeys(void) {
+    volatile int __A_VARIABLE;
     while(listLength(server.ready_keys) != 0) {
         list *l;
 
@@ -465,6 +483,7 @@ void handleClientsBlockedOnKeys(void) {
         }
         listRelease(l); /* We have the new list on place at this point. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* This is how the current blocking lists/sorted sets/streams work, we use
@@ -495,6 +514,7 @@ void handleClientsBlockedOnKeys(void) {
  * be unblocked only when items with an ID greater or equal to the specified
  * one is appended to the stream. */
 void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, robj *target, streamID *ids) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     list *l;
     int j;
@@ -536,11 +556,13 @@ void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeo
         listAddNodeTail(l,c);
     }
     blockClient(c,btype);
+    __A_VARIABLE = 1;
 }
 
 /* Unblock a client that's waiting in a blocking operation such as BLPOP.
  * You should never call this function directly, but unblockClient() instead. */
 void unblockClientWaitingData(client *c) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     dictIterator *di;
     list *l;
@@ -573,6 +595,7 @@ void unblockClientWaitingData(client *c) {
         c->bpop.xread_group = NULL;
         c->bpop.xread_consumer = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* If the specified key has clients blocked waiting for list pushes, this
@@ -583,13 +606,20 @@ void unblockClientWaitingData(client *c) {
  *
  * The list will be finally processed by handleClientsBlockedOnLists() */
 void signalKeyAsReady(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     readyList *rl;
 
     /* No clients blocking for this key? No need to queue it. */
-    if (dictFind(db->blocking_keys,key) == NULL) return;
+    if (dictFind(db->blocking_keys,key) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Key was already signaled? No need to queue it again. */
-    if (dictFind(db->ready_keys,key) != NULL) return;
+    if (dictFind(db->ready_keys,key) != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Ok, we need to queue this key into server.ready_keys. */
     rl = zmalloc(sizeof(*rl));
@@ -603,6 +633,7 @@ void signalKeyAsReady(redisDb *db, robj *key) {
      * check. */
     incrRefCount(key);
     serverAssert(dictAdd(db->ready_keys,key,NULL) == DICT_OK);
+    __A_VARIABLE = 1;
 }
 
 
diff --git a/src/childinfo.c b/src/childinfo.c
index 719025e..558debd 100644
--- a/src/childinfo.c
+++ b/src/childinfo.c
@@ -34,6 +34,7 @@
  * RDB / AOF saving process from the child to the parent (for instance
  * the amount of copy on write memory used) */
 void openChildInfoPipe(void) {
+    volatile int __A_VARIABLE;
     if (pipe(server.child_info_pipe) == -1) {
         /* On error our two file descriptors should be still set to -1,
          * but we call anyway cloesChildInfoPipe() since can't hurt. */
@@ -43,10 +44,12 @@ void openChildInfoPipe(void) {
     } else {
         memset(&server.child_info_data,0,sizeof(server.child_info_data));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Close the pipes opened with openChildInfoPipe(). */
 void closeChildInfoPipe(void) {
+    volatile int __A_VARIABLE;
     if (server.child_info_pipe[0] != -1 ||
         server.child_info_pipe[1] != -1)
     {
@@ -55,23 +58,33 @@ void closeChildInfoPipe(void) {
         server.child_info_pipe[0] = -1;
         server.child_info_pipe[1] = -1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send COW data to parent. The child should call this function after populating
  * the corresponding fields it want to sent (according to the process type). */
 void sendChildInfo(int ptype) {
-    if (server.child_info_pipe[1] == -1) return;
+    volatile int __A_VARIABLE;
+    if (server.child_info_pipe[1] == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     server.child_info_data.magic = CHILD_INFO_MAGIC;
     server.child_info_data.process_type = ptype;
     ssize_t wlen = sizeof(server.child_info_data);
     if (write(server.child_info_pipe[1],&server.child_info_data,wlen) != wlen) {
         /* Nothing to do on error, this will be detected by the other side. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* Receive COW data from parent. */
 void receiveChildInfo(void) {
-    if (server.child_info_pipe[0] == -1) return;
+    volatile int __A_VARIABLE;
+    if (server.child_info_pipe[0] == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ssize_t wlen = sizeof(server.child_info_data);
     if (read(server.child_info_pipe[0],&server.child_info_data,wlen) == wlen &&
         server.child_info_data.magic == CHILD_INFO_MAGIC)
@@ -82,4 +95,5 @@ void receiveChildInfo(void) {
             server.stat_aof_cow_bytes = server.child_info_data.cow_size;
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/cluster.c b/src/cluster.c
index 858c0c9..6338694 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -311,6 +311,7 @@ fmterr:
  * bigger we pad our payload with newlines that are anyway ignored and truncate
  * the file afterward. */
 int clusterSaveConfig(int do_fsync) {
+    volatile int __A_VARIABLE;
     sds ci;
     size_t content_size;
     struct stat sb;
@@ -349,19 +350,23 @@ int clusterSaveConfig(int do_fsync) {
     }
     close(fd);
     sdsfree(ci);
+    __A_VARIABLE = 1;
     return 0;
 
 err:
     if (fd != -1) close(fd);
     sdsfree(ci);
+    __A_VARIABLE = 1;
     return -1;
 }
 
 void clusterSaveConfigOrDie(int do_fsync) {
+    volatile int __A_VARIABLE;
     if (clusterSaveConfig(do_fsync) == -1) {
         serverLog(LL_WARNING,"Fatal: can't update cluster config file.");
         exit(1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Lock the cluster config using flock(), and leaks the file descritor used to
@@ -416,6 +421,7 @@ int clusterLockConfig(char *filename) {
  * that may change at runtime via CONFIG SET. This function changes the
  * set of flags in myself->flags accordingly. */
 void clusterUpdateMyselfFlags(void) {
+    volatile int __A_VARIABLE;
     int oldflags = myself->flags;
     int nofailover = server.cluster_slave_no_failover ?
                      CLUSTER_NODE_NOFAILOVER : 0;
@@ -425,9 +431,11 @@ void clusterUpdateMyselfFlags(void) {
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE);
     }
+    __A_VARIABLE = 1;
 }
 
 void clusterInit(void) {
+    volatile int __A_VARIABLE;
     int saveconf = 0;
 
     server.cluster = zmalloc(sizeof(clusterState));
@@ -518,6 +526,7 @@ void clusterInit(void) {
     server.cluster->mf_end = 0;
     resetManualFailover();
     clusterUpdateMyselfFlags();
+    __A_VARIABLE = 1;
 }
 
 /* Reset a node performing a soft or hard reset:
@@ -530,6 +539,7 @@ void clusterInit(void) {
  * 7) The new configuration is saved and the cluster state updated.
  * 8) If the node was a slave, the whole data set is flushed away. */
 void clusterReset(int hard) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int j;
@@ -581,6 +591,7 @@ void clusterReset(int hard) {
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE|
                          CLUSTER_TODO_FSYNC_CONFIG);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -588,12 +599,14 @@ void clusterReset(int hard) {
  * -------------------------------------------------------------------------- */
 
 clusterLink *createClusterLink(clusterNode *node) {
+    volatile int __A_VARIABLE;
     clusterLink *link = zmalloc(sizeof(*link));
     link->ctime = mstime();
     link->sndbuf = sdsempty();
     link->rcvbuf = sdsempty();
     link->node = node;
     link->fd = -1;
+    __A_VARIABLE = 1;
     return link;
 }
 
@@ -601,6 +614,7 @@ clusterLink *createClusterLink(clusterNode *node) {
  * This function will just make sure that the original node associated
  * with this link will have the 'link' field set to NULL. */
 void freeClusterLink(clusterLink *link) {
+    volatile int __A_VARIABLE;
     if (link->fd != -1) {
         aeDeleteFileEvent(server.el, link->fd, AE_READABLE|AE_WRITABLE);
     }
@@ -610,10 +624,12 @@ void freeClusterLink(clusterLink *link) {
         link->node->link = NULL;
     close(link->fd);
     zfree(link);
+    __A_VARIABLE = 1;
 }
 
 #define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
 void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     int cport, cfd;
     int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
     char cip[NET_IP_STR_LEN];
@@ -624,7 +640,10 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
 
     /* If the server is starting up, don't accept cluster connections:
      * UPDATE messages may interact with the database content. */
-    if (server.masterhost == NULL && server.loading) return;
+    if (server.masterhost == NULL && server.loading) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     while(max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
@@ -632,6 +651,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_VERBOSE,
                     "Error accepting cluster node: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         anetNonBlock(NULL,cfd);
@@ -648,6 +668,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         link->fd = cfd;
         aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -661,23 +682,31 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
  * { and } is hashed. This may be useful in the future to force certain
  * keys to be in the same node (assuming no resharding is in progress). */
 unsigned int keyHashSlot(char *key, int keylen) {
+    volatile int __A_VARIABLE;
     int s, e; /* start-end indexes of { and } */
 
     for (s = 0; s < keylen; s++)
         if (key[s] == '{') break;
 
     /* No '{' ? Hash the whole key. This is the base case. */
-    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
+    if (s == keylen) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* '{' found? Check if we have the corresponding '}'. */
     for (e = s+1; e < keylen; e++)
         if (key[e] == '}') break;
 
     /* No '}' or nothing between {} ? Hash the whole key. */
-    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
+    if (e == keylen || e == s+1) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* If we are here there is both a { and a } on its right. Hash
      * what is in the middle between { and }. */
+    __A_VARIABLE = 1;
     return crc16(key+s+1,e-s-1) & 0x3FFF;
 }
 
@@ -693,6 +722,7 @@ unsigned int keyHashSlot(char *key, int keylen) {
  * The node is created and returned to the user, but it is not automatically
  * added to the nodes hash table. */
 clusterNode *createClusterNode(char *nodename, int flags) {
+    volatile int __A_VARIABLE;
     clusterNode *node = zmalloc(sizeof(*node));
 
     if (nodename)
@@ -719,6 +749,7 @@ clusterNode *createClusterNode(char *nodename, int flags) {
     node->repl_offset_time = 0;
     node->repl_offset = 0;
     listSetFreeMethod(node->fail_reports,zfree);
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -733,6 +764,7 @@ clusterNode *createClusterNode(char *nodename, int flags) {
  * failure report from the same sender. 1 is returned if a new failure
  * report is created. */
 int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
+    volatile int __A_VARIABLE;
     list *l = failing->fail_reports;
     listNode *ln;
     listIter li;
@@ -745,6 +777,7 @@ int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
         fr = ln->value;
         if (fr->node == sender) {
             fr->time = mstime();
+            __A_VARIABLE = 1;
             return 0;
         }
     }
@@ -754,6 +787,7 @@ int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
     fr->node = sender;
     fr->time = mstime();
     listAddNodeTail(l,fr);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -763,6 +797,7 @@ int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
  * older than the global node timeout, so we don't just trust the number
  * of failure reports from other nodes. */
 void clusterNodeCleanupFailureReports(clusterNode *node) {
+    volatile int __A_VARIABLE;
     list *l = node->fail_reports;
     listNode *ln;
     listIter li;
@@ -776,6 +811,7 @@ void clusterNodeCleanupFailureReports(clusterNode *node) {
         fr = ln->value;
         if (now - fr->time > maxtime) listDelNode(l,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Remove the failing report for 'node' if it was previously considered
@@ -790,6 +826,7 @@ void clusterNodeCleanupFailureReports(clusterNode *node) {
  * The function returns 1 if the failure report was found and removed.
  * Otherwise 0 is returned. */
 int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
+    volatile int __A_VARIABLE;
     list *l = node->fail_reports;
     listNode *ln;
     listIter li;
@@ -801,11 +838,15 @@ int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
         fr = ln->value;
         if (fr->node == sender) break;
     }
-    if (!ln) return 0; /* No failure report from this sender. */
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* No failure report from this sender. */
 
     /* Remove the failure report. */
     listDelNode(l,ln);
     clusterNodeCleanupFailureReports(node);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -813,11 +854,14 @@ int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
  * not including this node, that may have a PFAIL or FAIL state for this
  * node as well. */
 int clusterNodeFailureReportsCount(clusterNode *node) {
+    volatile int __A_VARIABLE;
     clusterNodeCleanupFailureReports(node);
+    __A_VARIABLE = 1;
     return listLength(node->fail_reports);
 }
 
 int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < master->numslaves; j++) {
@@ -830,36 +874,46 @@ int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
             master->numslaves--;
             if (master->numslaves == 0)
                 master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
+            __A_VARIABLE = 1;
             return C_OK;
         }
     }
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
 int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
+    volatile int __A_VARIABLE;
     int j;
 
     /* If it's already a slave, don't add it again. */
     for (j = 0; j < master->numslaves; j++)
-        if (master->slaves[j] == slave) return C_ERR;
+        if (master->slaves[j] == slave) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     master->slaves = zrealloc(master->slaves,
         sizeof(clusterNode*)*(master->numslaves+1));
     master->slaves[master->numslaves] = slave;
     master->numslaves++;
     master->flags |= CLUSTER_NODE_MIGRATE_TO;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 int clusterCountNonFailingSlaves(clusterNode *n) {
+    volatile int __A_VARIABLE;
     int j, okslaves = 0;
 
     for (j = 0; j < n->numslaves; j++)
         if (!nodeFailed(n->slaves[j])) okslaves++;
+    __A_VARIABLE = 1;
     return okslaves;
 }
 
 /* Low level cleanup of the node structure. Only called by clusterDelNode(). */
 void freeClusterNode(clusterNode *n) {
+    volatile int __A_VARIABLE;
     sds nodename;
     int j;
 
@@ -881,14 +935,17 @@ void freeClusterNode(clusterNode *n) {
     listRelease(n->fail_reports);
     zfree(n->slaves);
     zfree(n);
+    __A_VARIABLE = 1;
 }
 
 /* Add a node to the nodes hash table */
 int clusterAddNode(clusterNode *node) {
+    volatile int __A_VARIABLE;
     int retval;
 
     retval = dictAdd(server.cluster->nodes,
             sdsnewlen(node->name,CLUSTER_NAMELEN), node);
+    __A_VARIABLE = 1;
     return (retval == DICT_OK) ? C_OK : C_ERR;
 }
 
@@ -904,6 +961,7 @@ int clusterAddNode(clusterNode *node) {
  *    it is a slave node.
  */
 void clusterDelNode(clusterNode *delnode) {
+    volatile int __A_VARIABLE;
     int j;
     dictIterator *di;
     dictEntry *de;
@@ -930,16 +988,22 @@ void clusterDelNode(clusterNode *delnode) {
 
     /* 3) Free the node, unlinking it from the cluster. */
     freeClusterNode(delnode);
+    __A_VARIABLE = 1;
 }
 
 /* Node lookup by name */
 clusterNode *clusterLookupNode(const char *name) {
+    volatile int __A_VARIABLE;
     sds s = sdsnewlen(name, CLUSTER_NAMELEN);
     dictEntry *de;
 
     de = dictFind(server.cluster->nodes,s);
     sdsfree(s);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return dictGetVal(de);
 }
 
@@ -948,6 +1012,7 @@ clusterNode *clusterLookupNode(const char *name) {
  * pick a random one, and will fix it when we receive the PONG request using
  * this function. */
 void clusterRenameNode(clusterNode *node, char *newname) {
+    volatile int __A_VARIABLE;
     int retval;
     sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);
 
@@ -958,6 +1023,7 @@ void clusterRenameNode(clusterNode *node, char *newname) {
     serverAssert(retval == DICT_OK);
     memcpy(node->name, newname, CLUSTER_NAMELEN);
     clusterAddNode(node);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -967,6 +1033,7 @@ void clusterRenameNode(clusterNode *node, char *newname) {
 /* Return the greatest configEpoch found in the cluster, or the current
  * epoch if greater than any node configEpoch. */
 uint64_t clusterGetMaxEpoch(void) {
+    volatile int __A_VARIABLE;
     uint64_t max = 0;
     dictIterator *di;
     dictEntry *de;
@@ -978,6 +1045,7 @@ uint64_t clusterGetMaxEpoch(void) {
     }
     dictReleaseIterator(di);
     if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
+    __A_VARIABLE = 1;
     return max;
 }
 
@@ -1076,11 +1144,18 @@ int clusterBumpConfigEpochWithoutConsensus(void) {
  * end with a different configuration epoch.
  */
 void clusterHandleConfigEpochCollision(clusterNode *sender) {
+    volatile int __A_VARIABLE;
     /* Prerequisites: nodes have the same configEpoch and are both masters. */
     if (sender->configEpoch != myself->configEpoch ||
-        !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
+        !nodeIsMaster(sender) || !nodeIsMaster(myself)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     /* Don't act if the colliding node has a smaller Node ID. */
-    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
+    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     /* Get the next ID available at the best of this node knowledge. */
     server.cluster->currentEpoch++;
     myself->configEpoch = server.cluster->currentEpoch;
@@ -1090,6 +1165,7 @@ void clusterHandleConfigEpochCollision(clusterNode *sender) {
         " configEpoch set to %llu",
         sender->name,
         (unsigned long long) myself->configEpoch);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -1124,6 +1200,7 @@ void clusterHandleConfigEpochCollision(clusterNode *sender) {
  * However without the cleanup during long uptimes and with some automated
  * node add/removal procedures, entries could accumulate. */
 void clusterBlacklistCleanup(void) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -1135,10 +1212,12 @@ void clusterBlacklistCleanup(void) {
             dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Cleanup the blacklist and add a new node ID to the black list. */
 void clusterBlacklistAddNode(clusterNode *node) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);
 
@@ -1151,18 +1230,21 @@ void clusterBlacklistAddNode(clusterNode *node) {
     de = dictFind(server.cluster->nodes_black_list,id);
     dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
     sdsfree(id);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if the specified node ID exists in the blacklist.
  * You don't need to pass an sds string here, any pointer to 40 bytes
  * will work. */
 int clusterBlacklistExists(char *nodeid) {
+    volatile int __A_VARIABLE;
     sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
     int retval;
 
     clusterBlacklistCleanup();
     retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
     sdsfree(id);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1192,16 +1274,26 @@ int clusterBlacklistExists(char *nodeid) {
  *    FAIL flag will be cleared after some time.
  */
 void markNodeAsFailingIfNeeded(clusterNode *node) {
+    volatile int __A_VARIABLE;
     int failures;
     int needed_quorum = (server.cluster->size / 2) + 1;
 
-    if (!nodeTimedOut(node)) return; /* We can reach it. */
-    if (nodeFailed(node)) return; /* Already FAILing. */
+    if (!nodeTimedOut(node)) {
+        __A_VARIABLE = 1;
+        return;
+    } /* We can reach it. */
+    if (nodeFailed(node)) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Already FAILing. */
 
     failures = clusterNodeFailureReportsCount(node);
     /* Also count myself as a voter if I'm a master. */
     if (nodeIsMaster(myself)) failures++;
-    if (failures < needed_quorum) return; /* No weak agreement from masters. */
+    if (failures < needed_quorum) {
+        __A_VARIABLE = 1;
+        return;
+    } /* No weak agreement from masters. */
 
     serverLog(LL_NOTICE,
         "Marking node %.40s as failing (quorum reached).", node->name);
@@ -1215,12 +1307,14 @@ void markNodeAsFailingIfNeeded(clusterNode *node) {
      * reachable nodes to flag the node as FAIL. */
     if (nodeIsMaster(myself)) clusterSendFail(node->name);
     clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called only if a node is marked as FAIL, but we are able
  * to reach it again. It checks if there are the conditions to undo the FAIL
  * state. */
 void clearNodeFailureIfNeeded(clusterNode *node) {
+    volatile int __A_VARIABLE;
     mstime_t now = mstime();
 
     serverAssert(nodeFailed(node));
@@ -1250,12 +1344,14 @@ void clearNodeFailureIfNeeded(clusterNode *node) {
         node->flags &= ~CLUSTER_NODE_FAIL;
         clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return true if we already have a node in HANDSHAKE state matching the
  * specified ip address and port number. This function is used in order to
  * avoid adding a new handshake node for the same address multiple times. */
 int clusterHandshakeInProgress(char *ip, int port, int cport) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -1269,6 +1365,7 @@ int clusterHandshakeInProgress(char *ip, int port, int cport) {
             node->cport == cport) break;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return de != NULL;
 }
 
@@ -1337,6 +1434,7 @@ int clusterStartHandshake(char *ip, int port, int cport) {
  * by the caller, not in the content of the gossip section, but in the
  * length. */
 void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
+    volatile int __A_VARIABLE;
     uint16_t count = ntohs(hdr->count);
     clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
     clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender);
@@ -1437,18 +1535,21 @@ void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
         /* Next node */
         g++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* IP -> string conversion. 'buf' is supposed to at least be 46 bytes.
  * If 'announced_ip' length is non-zero, it is used instead of extracting
  * the IP from the socket peer address. */
 void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
+    volatile int __A_VARIABLE;
     if (announced_ip[0] != '\0') {
         memcpy(buf,announced_ip,NET_IP_STR_LEN);
         buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
     } else {
         anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Update the node address to the IP address that can be extracted
@@ -1466,6 +1567,7 @@ void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
 int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
                               clusterMsg *hdr)
 {
+    volatile int __A_VARIABLE;
     char ip[NET_IP_STR_LEN] = {0};
     int port = ntohs(hdr->port);
     int cport = ntohs(hdr->cport);
@@ -1476,11 +1578,17 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
      *
      * As a side effect this function never frees the passed 'link', so
      * it is safe to call during packet processing. */
-    if (link == node->link) return 0;
+    if (link == node->link) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     nodeIp2String(ip,link,hdr->myip);
     if (node->port == port && node->cport == cport &&
-        strcmp(ip,node->ip) == 0) return 0;
+        strcmp(ip,node->ip) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* IP / port is different, update it. */
     memcpy(node->ip,ip,sizeof(ip));
@@ -1495,6 +1603,7 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
      * replication target as well. */
     if (nodeIsSlave(myself) && myself->slaveof == node)
         replicationSetMaster(node->ip, node->port);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1502,7 +1611,11 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
  * a node that we believed to be a slave is now acting as master in order to
  * update the state of the node. */
 void clusterSetNodeAsMaster(clusterNode *n) {
-    if (nodeIsMaster(n)) return;
+    volatile int __A_VARIABLE;
+    if (nodeIsMaster(n)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (n->slaveof) {
         clusterNodeRemoveSlave(n->slaveof,n);
@@ -1515,6 +1628,7 @@ void clusterSetNodeAsMaster(clusterNode *n) {
     /* Update config and state. */
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when we receive a master configuration via a
@@ -1529,6 +1643,7 @@ void clusterSetNodeAsMaster(clusterNode *n) {
  * Sometimes it is not actually the "Sender" of the information, like in the
  * case we receive the info via an UPDATE packet. */
 void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
+    volatile int __A_VARIABLE;
     int j;
     clusterNode *curmaster, *newmaster = NULL;
     /* The dirty slots list is a list of slots for which we lose the ownership
@@ -1548,6 +1663,7 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
 
     if (sender == myself) {
         serverLog(LL_WARNING,"Discarding UPDATE message about myself.");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1593,8 +1709,10 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
     /* After updating the slots configuration, don't do any actual change
      * in the state of the server if a module disabled Redis Cluster
      * keys redirections. */
-    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
+    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* If at least one slot was reassigned from a node to another node
      * with a greater configEpoch, it is possible that:
@@ -1622,6 +1740,7 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
         for (j = 0; j < dirty_slots_count; j++)
             delKeysInSlot(dirty_slots[j]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* When this function is called, there is a packet to process starting
@@ -2112,13 +2231,16 @@ int clusterProcessPacket(clusterLink *link) {
    Instead if the node is a temporary node used to accept a query, we
    completely free the node on error. */
 void handleLinkIOError(clusterLink *link) {
+    volatile int __A_VARIABLE;
     freeClusterLink(link);
+    __A_VARIABLE = 1;
 }
 
 /* Send data. This is handled using a trivial send buffer that gets
  * consumed by write(). We don't try to optimize this for speed too much
  * as this is a very low traffic channel. */
 void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     clusterLink *link = (clusterLink*) privdata;
     ssize_t nwritten;
     UNUSED(el);
@@ -2129,11 +2251,13 @@ void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         serverLog(LL_DEBUG,"I/O error writing to node link: %s",
             (nwritten == -1) ? strerror(errno) : "short write");
         handleLinkIOError(link);
+        __A_VARIABLE = 1;
         return;
     }
     sdsrange(link->sndbuf,nwritten,-1);
     if (sdslen(link->sndbuf) == 0)
         aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
+    __A_VARIABLE = 1;
 }
 
 /* Read data. Try to read the first field of the header first to check the
@@ -2208,6 +2332,7 @@ void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
  * the link to be invalidated, so it is safe to call this function
  * from event handlers that will do stuff with the same link later. */
 void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
+    volatile int __A_VARIABLE;
     if (sdslen(link->sndbuf) == 0 && msglen != 0)
         aeCreateFileEvent(server.el,link->fd,AE_WRITABLE|AE_BARRIER,
                     clusterWriteHandler,link);
@@ -2219,6 +2344,7 @@ void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
     uint16_t type = ntohs(hdr->type);
     if (type < CLUSTERMSG_TYPE_COUNT)
         server.cluster->stats_bus_messages_sent[type]++;
+    __A_VARIABLE = 1;
 }
 
 /* Send a message to all the nodes that are part of the cluster having
@@ -2228,6 +2354,7 @@ void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
  * some node->link to be invalidated, so it is safe to call this function
  * from event handlers that will do stuff with node links later. */
 void clusterBroadcastMessage(void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -2241,11 +2368,13 @@ void clusterBroadcastMessage(void *buf, size_t len) {
         clusterSendMessage(node->link,buf,len);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Build the message header. hdr must point to a buffer at least
  * sizeof(clusterMsg) in bytes. */
 void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
+    volatile int __A_VARIABLE;
     int totlen = 0;
     uint64_t offset;
     clusterNode *master;
@@ -2317,23 +2446,27 @@ void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
     }
     hdr->totlen = htonl(totlen);
     /* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */
+    __A_VARIABLE = 1;
 }
 
 /* Return non zero if the node is already present in the gossip section of the
  * message pointed by 'hdr' and having 'count' gossip entries. Otherwise
  * zero is returned. Helper for clusterSendPing(). */
 int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {
+    volatile int __A_VARIABLE;
     int j;
     for (j = 0; j < count; j++) {
         if (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
                 CLUSTER_NAMELEN) == 0) break;
     }
+    __A_VARIABLE = 1;
     return j != count;
 }
 
 /* Set the i-th entry of the gossip section in the message pointed by 'hdr'
  * to the info of the specified node 'n'. */
 void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
+    volatile int __A_VARIABLE;
     clusterMsgDataGossip *gossip;
     gossip = &(hdr->data.ping.gossip[i]);
     memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
@@ -2344,11 +2477,13 @@ void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
     gossip->cport = htons(n->cport);
     gossip->flags = htons(n->flags);
     gossip->notused1 = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Send a PING or PONG packet to the specified node, making sure to add enough
  * gossip informations. */
 void clusterSendPing(clusterLink *link, int type) {
+    volatile int __A_VARIABLE;
     unsigned char *buf;
     clusterMsg *hdr;
     int gossipcount = 0; /* Number of gossip sections added so far. */
@@ -2474,6 +2609,7 @@ void clusterSendPing(clusterLink *link, int type) {
     hdr->totlen = htonl(totlen);
     clusterSendMessage(link,buf,totlen);
     zfree(buf);
+    __A_VARIABLE = 1;
 }
 
 /* Send a PONG packet to every connected node that's not in handshake state
@@ -2493,6 +2629,7 @@ void clusterSendPing(clusterLink *link, int type) {
 #define CLUSTER_BROADCAST_ALL 0
 #define CLUSTER_BROADCAST_LOCAL_SLAVES 1
 void clusterBroadcastPong(int target) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -2511,12 +2648,14 @@ void clusterBroadcastPong(int target) {
         clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Send a PUBLISH message.
  *
  * If link is NULL, then the message is broadcasted to the whole cluster. */
 void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)], *payload;
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
@@ -2555,6 +2694,7 @@ void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
     decrRefCount(channel);
     decrRefCount(message);
     if (payload != buf) zfree(payload);
+    __A_VARIABLE = 1;
 }
 
 /* Send a FAIL message to all the nodes we are able to contact.
@@ -2563,27 +2703,34 @@ void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
  * we switch the node state to CLUSTER_NODE_FAIL and ask all the other
  * nodes to do the same ASAP. */
 void clusterSendFail(char *nodename) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
 
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
     memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
     clusterBroadcastMessage(buf,ntohl(hdr->totlen));
+    __A_VARIABLE = 1;
 }
 
 /* Send an UPDATE message to the specified link carrying the specified 'node'
  * slots configuration. The node name, slots bitmap, and configEpoch info
  * are included. */
 void clusterSendUpdate(clusterLink *link, clusterNode *node) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
 
-    if (link == NULL) return;
+    if (link == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);
     memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
     hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
     memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
     clusterSendMessage(link,buf,ntohl(hdr->totlen));
+    __A_VARIABLE = 1;
 }
 
 /* Send a MODULE message.
@@ -2591,6 +2738,7 @@ void clusterSendUpdate(clusterLink *link, clusterNode *node) {
  * If link is NULL, then the message is broadcasted to the whole cluster. */
 void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
                        unsigned char *payload, uint32_t len) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)], *heapbuf;
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
@@ -2620,6 +2768,7 @@ void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
         clusterBroadcastMessage(heapbuf,totlen);
 
     if (heapbuf != buf) zfree(heapbuf);
+    __A_VARIABLE = 1;
 }
 
 /* This function gets a cluster node ID string as target, the same way the nodes
@@ -2629,15 +2778,20 @@ void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
  * The function returns C_OK if the target is valid, otherwise C_ERR is
  * returned. */
 int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len) {
+    volatile int __A_VARIABLE;
     clusterNode *node = NULL;
 
     if (target != NULL) {
         node = clusterLookupNode(target);
-        if (node == NULL || node->link == NULL) return C_ERR;
+        if (node == NULL || node->link == NULL) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     }
 
     clusterSendModule(target ? node->link : NULL,
                       module_id, type, payload, len);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2649,7 +2803,9 @@ int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uin
  * messages to hosts without receives for a given channel.
  * -------------------------------------------------------------------------- */
 void clusterPropagatePublish(robj *channel, robj *message) {
+    volatile int __A_VARIABLE;
     clusterSendPublish(NULL, channel, message);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -2663,6 +2819,7 @@ void clusterPropagatePublish(robj *channel, robj *message) {
  * Note that we send the failover request to everybody, master and slave nodes,
  * but only the masters are supposed to reply to our query. */
 void clusterRequestFailoverAuth(void) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
@@ -2675,36 +2832,48 @@ void clusterRequestFailoverAuth(void) {
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterBroadcastMessage(buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Send a FAILOVER_AUTH_ACK message to the specified node. */
 void clusterSendFailoverAuth(clusterNode *node) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
 
-    if (!node->link) return;
+    if (!node->link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterSendMessage(node->link,buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Send a MFSTART message to the specified node. */
 void clusterSendMFStart(clusterNode *node) {
+    volatile int __A_VARIABLE;
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
 
-    if (!node->link) return;
+    if (!node->link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART);
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterSendMessage(node->link,buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Vote for the node asking for our vote if there are the conditions. */
 void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
+    volatile int __A_VARIABLE;
     clusterNode *master = node->slaveof;
     uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);
     uint64_t requestConfigEpoch = ntohu64(request->configEpoch);
@@ -2716,7 +2885,10 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
      * right to vote, as the cluster size in Redis Cluster is the number
      * of masters serving at least one slot, and quorum is the cluster
      * size + 1 */
-    if (nodeIsSlave(myself) || myself->numslots == 0) return;
+    if (nodeIsSlave(myself) || myself->numslots == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Request epoch must be >= our currentEpoch.
      * Note that it is impossible for it to actually be greater since
@@ -2728,6 +2900,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
             node->name,
             (unsigned long long) requestCurrentEpoch,
             (unsigned long long) server.cluster->currentEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2737,6 +2910,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 "Failover auth denied to %.40s: already voted for epoch %llu",
                 node->name,
                 (unsigned long long) server.cluster->currentEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2759,6 +2933,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                     "Failover auth denied to %.40s: its master is up",
                     node->name);
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2773,6 +2948,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 node->name,
                 (long long) ((server.cluster_node_timeout*2)-
                              (mstime() - node->slaveof->voted_time)));
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2795,6 +2971,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 node->name, j,
                 (unsigned long long) server.cluster->slots[j]->configEpoch,
                 (unsigned long long) requestConfigEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2805,6 +2982,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
     clusterSendFailoverAuth(node);
     serverLog(LL_WARNING, "Failover auth granted to %.40s for epoch %llu",
         node->name, (unsigned long long) server.cluster->currentEpoch);
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the "rank" of this instance, a slave, in the context
@@ -2820,19 +2998,24 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
  * get voted and replace a failing master. Slaves with better replication
  * offsets are more likely to win. */
 int clusterGetSlaveRank(void) {
+    volatile int __A_VARIABLE;
     long long myoffset;
     int j, rank = 0;
     clusterNode *master;
 
     serverAssert(nodeIsSlave(myself));
     master = myself->slaveof;
-    if (master == NULL) return 0; /* Never called by slaves without master. */
+    if (master == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Never called by slaves without master. */
 
     myoffset = replicationGetSlaveOffset();
     for (j = 0; j < master->numslaves; j++)
         if (master->slaves[j] != myself &&
             !nodeCantFailover(master->slaves[j]) &&
             master->slaves[j]->repl_offset > myoffset) rank++;
+    __A_VARIABLE = 1;
     return rank;
 }
 
@@ -2859,14 +3042,17 @@ int clusterGetSlaveRank(void) {
  *
  * The function is guaranteed to be called only if 'myself' is a slave. */
 void clusterLogCantFailover(int reason) {
+    volatile int __A_VARIABLE;
     char *msg;
     static time_t lastlog_time = 0;
     mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;
 
     /* Don't log if we have the same reason for some time. */
     if (reason == server.cluster->cant_failover_reason &&
-        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
+        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     server.cluster->cant_failover_reason = reason;
 
@@ -2875,7 +3061,10 @@ void clusterLogCantFailover(int reason) {
      * a long time. */
     if (myself->slaveof &&
         nodeFailed(myself->slaveof) &&
-        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;
+        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     switch(reason) {
     case CLUSTER_CANT_FAILOVER_DATA_AGE:
@@ -2898,6 +3087,7 @@ void clusterLogCantFailover(int reason) {
     }
     lastlog_time = time(NULL);
     serverLog(LL_WARNING,"Currently unable to failover: %s", msg);
+    __A_VARIABLE = 1;
 }
 
 /* This function implements the final part of automatic and manual failovers,
@@ -2907,10 +3097,14 @@ void clusterLogCantFailover(int reason) {
  * Note that it's up to the caller to be sure that the node got a new
  * configuration epoch already. */
 void clusterFailoverReplaceYourMaster(void) {
+    volatile int __A_VARIABLE;
     int j;
     clusterNode *oldmaster = myself->slaveof;
 
-    if (nodeIsMaster(myself) || oldmaster == NULL) return;
+    if (nodeIsMaster(myself) || oldmaster == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* 1) Turn this node into a master. */
     clusterSetNodeAsMaster(myself);
@@ -2934,6 +3128,7 @@ void clusterFailoverReplaceYourMaster(void) {
 
     /* 5) If there was a manual failover in progress, clear the state. */
     resetManualFailover();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called if we are a slave node and our master serving
@@ -2945,6 +3140,7 @@ void clusterFailoverReplaceYourMaster(void) {
  * 3) Perform the failover informing all the other nodes.
  */
 void clusterHandleSlaveFailover(void) {
+    volatile int __A_VARIABLE;
     mstime_t data_age;
     mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
     int needed_quorum = (server.cluster->size / 2) + 1;
@@ -2981,6 +3177,7 @@ void clusterHandleSlaveFailover(void) {
         /* There are no reasons to failover, so we set the reason why we
          * are returning without failing over to NONE. */
         server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3010,6 +3207,7 @@ void clusterHandleSlaveFailover(void) {
     {
         if (!manual_failover) {
             clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -3044,6 +3242,7 @@ void clusterHandleSlaveFailover(void) {
          * to all the other slaves so that they'll updated their offsets
          * if our offset is better. */
         clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3070,12 +3269,14 @@ void clusterHandleSlaveFailover(void) {
     /* Return ASAP if we can't still start the election. */
     if (mstime() < server.cluster->failover_auth_time) {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* Return ASAP if the election is too old to be valid. */
     if (auth_age > auth_timeout) {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3090,6 +3291,7 @@ void clusterHandleSlaveFailover(void) {
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE|
                              CLUSTER_TODO_FSYNC_CONFIG);
+        __A_VARIABLE = 1;
         return; /* Wait for replies. */
     }
 
@@ -3113,6 +3315,7 @@ void clusterHandleSlaveFailover(void) {
     } else {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3143,21 +3346,31 @@ void clusterHandleSlaveFailover(void) {
  * Additional conditions for migration are examined inside the function.
  */
 void clusterHandleSlaveMigration(int max_slaves) {
+    volatile int __A_VARIABLE;
     int j, okslaves = 0;
     clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
     dictIterator *di;
     dictEntry *de;
 
     /* Step 1: Don't migrate if the cluster state is not ok. */
-    if (server.cluster->state != CLUSTER_OK) return;
+    if (server.cluster->state != CLUSTER_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Step 2: Don't migrate if my master will not be left with at least
      *         'migration-barrier' slaves after my migration. */
-    if (mymaster == NULL) return;
+    if (mymaster == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (j = 0; j < mymaster->numslaves; j++)
         if (!nodeFailed(mymaster->slaves[j]) &&
             !nodeTimedOut(mymaster->slaves[j])) okslaves++;
-    if (okslaves <= server.cluster_migration_barrier) return;
+    if (okslaves <= server.cluster_migration_barrier) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Step 3: Identify a candidate for migration, and check if among the
      * masters with the greatest number of ok slaves, I'm the one with the
@@ -3225,6 +3438,7 @@ void clusterHandleSlaveMigration(int max_slaves) {
             target->name);
         clusterSetMaster(target);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3262,6 +3476,7 @@ void clusterHandleSlaveMigration(int max_slaves) {
  * The function can be used both to initialize the manual failover state at
  * startup or to abort a manual failover in progress. */
 void resetManualFailover(void) {
+    volatile int __A_VARIABLE;
     if (server.cluster->mf_end && clientsArePaused()) {
         server.clients_pause_end_time = 0;
         clientsArePaused(); /* Just use the side effect of the function. */
@@ -3270,27 +3485,40 @@ void resetManualFailover(void) {
     server.cluster->mf_can_start = 0;
     server.cluster->mf_slave = NULL;
     server.cluster->mf_master_offset = 0;
+    __A_VARIABLE = 1;
 }
 
 /* If a manual failover timed out, abort it. */
 void manualFailoverCheckTimeout(void) {
+    volatile int __A_VARIABLE;
     if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
         serverLog(LL_WARNING,"Manual failover timed out.");
         resetManualFailover();
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called from the cluster cron function in order to go
  * forward with a manual failover state machine. */
 void clusterHandleManualFailover(void) {
+    volatile int __A_VARIABLE;
     /* Return ASAP if no manual failover is in progress. */
-    if (server.cluster->mf_end == 0) return;
+    if (server.cluster->mf_end == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If mf_can_start is non-zero, the failover was already triggered so the
      * next steps are performed by clusterHandleSlaveFailover(). */
-    if (server.cluster->mf_can_start) return;
+    if (server.cluster->mf_can_start) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
-    if (server.cluster->mf_master_offset == 0) return; /* Wait for offset... */
+    if (server.cluster->mf_master_offset == 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Wait for offset... */
 
     if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
         /* Our replication offset matches the master replication offset
@@ -3300,6 +3528,7 @@ void clusterHandleManualFailover(void) {
             "All master replication stream processed, "
             "manual failover can start.");
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3308,6 +3537,7 @@ void clusterHandleManualFailover(void) {
 
 /* This is executed 10 times every second */
 void clusterCron(void) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int update_state = 0;
@@ -3585,6 +3815,7 @@ void clusterCron(void) {
 
     if (update_state || server.cluster->state == CLUSTER_FAIL)
         clusterUpdateState();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called before the event handler returns to sleep for
@@ -3593,6 +3824,7 @@ void clusterCron(void) {
  * handlers, or to perform potentially expansive tasks that we need to do
  * a single time before replying to clients. */
 void clusterBeforeSleep(void) {
+    volatile int __A_VARIABLE;
     /* Handle failover, this is needed when it is likely that there is already
      * the quorum from masters in order to react fast. */
     if (server.cluster->todo_before_sleep & CLUSTER_TODO_HANDLE_FAILOVER)
@@ -3612,10 +3844,13 @@ void clusterBeforeSleep(void) {
     /* Reset our flags (not strictly needed since every single function
      * called for flags set should be able to clear its flag). */
     server.cluster->todo_before_sleep = 0;
+    __A_VARIABLE = 1;
 }
 
 void clusterDoBeforeSleep(int flags) {
+    volatile int __A_VARIABLE;
     server.cluster->todo_before_sleep |= flags;
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3625,29 +3860,36 @@ void clusterDoBeforeSleep(int flags) {
 /* Test bit 'pos' in a generic bitmap. Return 1 if the bit is set,
  * otherwise 0. */
 int bitmapTestBit(unsigned char *bitmap, int pos) {
+    volatile int __A_VARIABLE;
     off_t byte = pos/8;
     int bit = pos&7;
+    __A_VARIABLE = 1;
     return (bitmap[byte] & (1<<bit)) != 0;
 }
 
 /* Set the bit at position 'pos' in a bitmap. */
 void bitmapSetBit(unsigned char *bitmap, int pos) {
+    volatile int __A_VARIABLE;
     off_t byte = pos/8;
     int bit = pos&7;
     bitmap[byte] |= 1<<bit;
+    __A_VARIABLE = 1;
 }
 
 /* Clear the bit at position 'pos' in a bitmap. */
 void bitmapClearBit(unsigned char *bitmap, int pos) {
+    volatile int __A_VARIABLE;
     off_t byte = pos/8;
     int bit = pos&7;
     bitmap[byte] &= ~(1<<bit);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if there is at least one master with slaves in the cluster.
  * Otherwise zero is returned. Used by clusterNodeSetSlotBit() to set the
  * MIGRATE_TO flag the when a master gets the first slot. */
 int clusterMastersHaveSlaves(void) {
+    volatile int __A_VARIABLE;
     dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
     dictEntry *de;
     int slaves = 0;
@@ -3658,11 +3900,13 @@ int clusterMastersHaveSlaves(void) {
         slaves += node->numslaves;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return slaves != 0;
 }
 
 /* Set the slot bit and return the old value. */
 int clusterNodeSetSlotBit(clusterNode *n, int slot) {
+    volatile int __A_VARIABLE;
     int old = bitmapTestBit(n->slots,slot);
     bitmapSetBit(n->slots,slot);
     if (!old) {
@@ -3683,19 +3927,24 @@ int clusterNodeSetSlotBit(clusterNode *n, int slot) {
         if (n->numslots == 1 && clusterMastersHaveSlaves())
             n->flags |= CLUSTER_NODE_MIGRATE_TO;
     }
+    __A_VARIABLE = 1;
     return old;
 }
 
 /* Clear the slot bit and return the old value. */
 int clusterNodeClearSlotBit(clusterNode *n, int slot) {
+    volatile int __A_VARIABLE;
     int old = bitmapTestBit(n->slots,slot);
     bitmapClearBit(n->slots,slot);
     if (old) n->numslots--;
+    __A_VARIABLE = 1;
     return old;
 }
 
 /* Return the slot bit from the cluster node structure. */
 int clusterNodeGetSlotBit(clusterNode *n, int slot) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return bitmapTestBit(n->slots,slot);
 }
 
@@ -3704,9 +3953,14 @@ int clusterNodeGetSlotBit(clusterNode *n, int slot) {
  * If the slot is already assigned to another instance this is considered
  * an error and C_ERR is returned. */
 int clusterAddSlot(clusterNode *n, int slot) {
-    if (server.cluster->slots[slot]) return C_ERR;
+    volatile int __A_VARIABLE;
+    if (server.cluster->slots[slot]) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     clusterNodeSetSlotBit(n,slot);
     server.cluster->slots[slot] = n;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3714,17 +3968,23 @@ int clusterAddSlot(clusterNode *n, int slot) {
  * Returns C_OK if the slot was assigned, otherwise if the slot was
  * already unassigned C_ERR is returned. */
 int clusterDelSlot(int slot) {
+    volatile int __A_VARIABLE;
     clusterNode *n = server.cluster->slots[slot];
 
-    if (!n) return C_ERR;
+    if (!n) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
     server.cluster->slots[slot] = NULL;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 /* Delete all the slots associated with the specified node.
  * The number of deleted slots is returned. */
 int clusterDelNodeSlots(clusterNode *node) {
+    volatile int __A_VARIABLE;
     int deleted = 0, j;
 
     for (j = 0; j < CLUSTER_SLOTS; j++) {
@@ -3733,16 +3993,19 @@ int clusterDelNodeSlots(clusterNode *node) {
             deleted++;
         }
     }
+    __A_VARIABLE = 1;
     return deleted;
 }
 
 /* Clear the migrating / importing state for all the slots.
  * This is useful at initialization and when turning a master into slave. */
 void clusterCloseAllSlots(void) {
+    volatile int __A_VARIABLE;
     memset(server.cluster->migrating_slots_to,0,
         sizeof(server.cluster->migrating_slots_to));
     memset(server.cluster->importing_slots_from,0,
         sizeof(server.cluster->importing_slots_from));
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3758,6 +4021,7 @@ void clusterCloseAllSlots(void) {
 #define CLUSTER_WRITABLE_DELAY 2000
 
 void clusterUpdateState(void) {
+    volatile int __A_VARIABLE;
     int j, new_state;
     int reachable_masters = 0;
     static mstime_t among_minority_time;
@@ -3774,7 +4038,10 @@ void clusterUpdateState(void) {
     if (first_call_time == 0) first_call_time = mstime();
     if (nodeIsMaster(myself) &&
         server.cluster->state == CLUSTER_FAIL &&
-        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;
+        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Start assuming the state is OK. We'll turn it into FAIL if there
      * are the right conditions. */
@@ -3843,6 +4110,7 @@ void clusterUpdateState(void) {
             nodeIsMaster(myself) &&
             mstime() - among_minority_time < rejoin_delay)
         {
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -3851,6 +4119,7 @@ void clusterUpdateState(void) {
             new_state == CLUSTER_OK ? "ok" : "fail");
         server.cluster->state = new_state;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called after the node startup in order to verify that data
@@ -3876,21 +4145,30 @@ void clusterUpdateState(void) {
  * about desynchronizations between the data we have in memory and the
  * cluster configuration. */
 int verifyClusterConfigWithData(void) {
+    volatile int __A_VARIABLE;
     int j;
     int update_config = 0;
 
     /* Return ASAP if a module disabled cluster redirections. In that case
      * every master can store keys about every possible hash slot. */
-    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
+    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION) {
+        __A_VARIABLE = 1;
         return C_OK;
+    }
 
     /* If this node is a slave, don't perform the check at all as we
      * completely depend on the replication stream. */
-    if (nodeIsSlave(myself)) return C_OK;
+    if (nodeIsSlave(myself)) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Make sure we only have keys in DB0. */
     for (j = 1; j < server.dbnum; j++) {
-        if (dictSize(server.db[j].dict)) return C_ERR;
+        if (dictSize(server.db[j].dict)) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     }
 
     /* Check that all the slots we see populated memory have a corresponding
@@ -3921,6 +4199,7 @@ int verifyClusterConfigWithData(void) {
         }
     }
     if (update_config) clusterSaveConfigOrDie(1);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3931,6 +4210,7 @@ int verifyClusterConfigWithData(void) {
 /* Set the specified node 'n' as master for this node.
  * If this node is currently a master, it is turned into a slave. */
 void clusterSetMaster(clusterNode *n) {
+    volatile int __A_VARIABLE;
     serverAssert(n != myself);
     serverAssert(myself->numslots == 0);
 
@@ -3946,6 +4226,7 @@ void clusterSetMaster(clusterNode *n) {
     clusterNodeAddSlave(n,myself);
     replicationSetMaster(n->ip, n->port);
     resetManualFailover();
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3971,6 +4252,7 @@ static struct redisNodeFlags redisNodeFlagsTable[] = {
 /* Concatenate the comma separated list of node flags to the given SDS
  * string 'ci'. */
 sds representClusterNodeFlags(sds ci, uint16_t flags) {
+    volatile int __A_VARIABLE;
     size_t orig_len = sdslen(ci);
     int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
     for (i = 0; i < size; i++) {
@@ -3980,6 +4262,7 @@ sds representClusterNodeFlags(sds ci, uint16_t flags) {
     /* If no flag was added, add the "noflags" special flag. */
     if (sdslen(ci) == orig_len) ci = sdscat(ci,"noflags,");
     sdsIncrLen(ci,-1); /* Remove trailing comma. */
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -3988,6 +4271,7 @@ sds representClusterNodeFlags(sds ci, uint16_t flags) {
  *
  * The function returns the string representation as an SDS string. */
 sds clusterGenNodeDescription(clusterNode *node) {
+    volatile int __A_VARIABLE;
     int j, start;
     sds ci;
 
@@ -4049,6 +4333,7 @@ sds clusterGenNodeDescription(clusterNode *node) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -4065,6 +4350,7 @@ sds clusterGenNodeDescription(clusterNode *node) {
  * of the CLUSTER NODES function, and as format for the cluster
  * configuration file (nodes.conf) for a given node. */
 sds clusterGenNodesDescription(int filter) {
+    volatile int __A_VARIABLE;
     sds ci = sdsempty(), ni;
     dictIterator *di;
     dictEntry *de;
@@ -4080,6 +4366,7 @@ sds clusterGenNodesDescription(int filter) {
         ci = sdscatlen(ci,"\n",1);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -4088,34 +4375,50 @@ sds clusterGenNodesDescription(int filter) {
  * -------------------------------------------------------------------------- */
 
 const char *clusterGetMessageTypeString(int type) {
+    volatile int __A_VARIABLE;
     switch(type) {
-    case CLUSTERMSG_TYPE_PING: return "ping";
-    case CLUSTERMSG_TYPE_PONG: return "pong";
-    case CLUSTERMSG_TYPE_MEET: return "meet";
-    case CLUSTERMSG_TYPE_FAIL: return "fail";
-    case CLUSTERMSG_TYPE_PUBLISH: return "publish";
-    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return "auth-req";
-    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return "auth-ack";
-    case CLUSTERMSG_TYPE_UPDATE: return "update";
-    case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
-    case CLUSTERMSG_TYPE_MODULE: return "module";
-    }
+    case CLUSTERMSG_TYPE_PING: __A_VARIABLE = 1;
+        return "ping";
+    case CLUSTERMSG_TYPE_PONG: __A_VARIABLE = 1;
+        return "pong";
+    case CLUSTERMSG_TYPE_MEET: __A_VARIABLE = 1;
+        return "meet";
+    case CLUSTERMSG_TYPE_FAIL: __A_VARIABLE = 1;
+        return "fail";
+    case CLUSTERMSG_TYPE_PUBLISH: __A_VARIABLE = 1;
+        return "publish";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: __A_VARIABLE = 1;
+        return "auth-req";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: __A_VARIABLE = 1;
+        return "auth-ack";
+    case CLUSTERMSG_TYPE_UPDATE: __A_VARIABLE = 1;
+        return "update";
+    case CLUSTERMSG_TYPE_MFSTART: __A_VARIABLE = 1;
+        return "mfstart";
+    case CLUSTERMSG_TYPE_MODULE: __A_VARIABLE = 1;
+        return "module";
+    }
+    __A_VARIABLE = 1;
     return "unknown";
 }
 
 int getSlotOrReply(client *c, robj *o) {
+    volatile int __A_VARIABLE;
     long long slot;
 
     if (getLongLongFromObject(o,&slot) != C_OK ||
         slot < 0 || slot >= CLUSTER_SLOTS)
     {
         addReplyError(c,"Invalid or out of range slot");
+        __A_VARIABLE = 1;
         return -1;
     }
+    __A_VARIABLE = 1;
     return (int) slot;
 }
 
 void clusterReplyMultiBulkSlots(client *c) {
+    volatile int __A_VARIABLE;
     /* Format: 1) 1) start slot
      *            2) end slot
      *            3) 1) master IP
@@ -4187,6 +4490,7 @@ void clusterReplyMultiBulkSlots(client *c) {
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c, slot_replylen, num_masters);
+    __A_VARIABLE = 1;
 }
 
 void clusterCommand(client *c) {
@@ -4778,6 +5082,7 @@ NULL
 /* Generates a DUMP-format representation of the object 'o', adding it to the
  * io stream pointed by 'rio'. This function can't fail. */
 void createDumpPayload(rio *payload, robj *o, robj *key) {
+    volatile int __A_VARIABLE;
     unsigned char buf[2];
     uint64_t crc;
 
@@ -4804,6 +5109,7 @@ void createDumpPayload(rio *payload, robj *o, robj *key) {
                 sdslen(payload->io.buffer.ptr));
     memrev64ifbe(&crc);
     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
+    __A_VARIABLE = 1;
 }
 
 /* Verify that the RDB version of the dump payload matches the one of this Redis
@@ -4811,21 +5117,29 @@ void createDumpPayload(rio *payload, robj *o, robj *key) {
  * If the DUMP payload looks valid C_OK is returned, otherwise C_ERR
  * is returned. */
 int verifyDumpPayload(unsigned char *p, size_t len) {
+    volatile int __A_VARIABLE;
     unsigned char *footer;
     uint16_t rdbver;
     uint64_t crc;
 
     /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
-    if (len < 10) return C_ERR;
+    if (len < 10) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     footer = p+(len-10);
 
     /* Verify RDB version */
     rdbver = (footer[1] << 8) | footer[0];
-    if (rdbver > RDB_VERSION) return C_ERR;
+    if (rdbver > RDB_VERSION) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Verify CRC64 */
     crc = crc64(0,p,len-8);
     memrev64ifbe(&crc);
+    __A_VARIABLE = 1;
     return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
 }
 
@@ -4833,12 +5147,14 @@ int verifyDumpPayload(unsigned char *p, size_t len) {
  * DUMP is actually not used by Redis Cluster but it is the obvious
  * complement of RESTORE and can be useful for different applications. */
 void dumpCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o, *dumpobj;
     rio payload;
 
     /* Check if the key is here. */
     if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
         addReply(c,shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -4849,6 +5165,7 @@ void dumpCommand(client *c) {
     dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);
     addReplyBulk(c,dumpobj);
     decrRefCount(dumpobj);
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -4964,6 +5281,7 @@ typedef struct migrateCachedSocket {
  * should be called so that the connection will be created from scratch
  * the next time. */
 migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {
+    volatile int __A_VARIABLE;
     int fd;
     sds name = sdsempty();
     migrateCachedSocket *cs;
@@ -4976,6 +5294,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
     if (cs) {
         sdsfree(name);
         cs->last_use_time = server.unixtime;
+        __A_VARIABLE = 1;
         return cs;
     }
 
@@ -4996,6 +5315,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
         sdsfree(name);
         addReplyErrorFormat(c,"Can't connect to target node: %s",
             server.neterr);
+        __A_VARIABLE = 1;
         return NULL;
     }
     anetEnableTcpNoDelay(server.neterr,fd);
@@ -5006,6 +5326,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
         addReplySds(c,
             sdsnew("-IOERR error or timeout connecting to the client\r\n"));
         close(fd);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -5015,11 +5336,13 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
     cs->last_dbid = -1;
     cs->last_use_time = server.unixtime;
     dictAdd(server.migrate_cached_sockets,name,cs);
+    __A_VARIABLE = 1;
     return cs;
 }
 
 /* Free a migrate cached connection. */
 void migrateCloseSocket(robj *host, robj *port) {
+    volatile int __A_VARIABLE;
     sds name = sdsempty();
     migrateCachedSocket *cs;
 
@@ -5029,6 +5352,7 @@ void migrateCloseSocket(robj *host, robj *port) {
     cs = dictFetchValue(server.migrate_cached_sockets,name);
     if (!cs) {
         sdsfree(name);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -5036,9 +5360,11 @@ void migrateCloseSocket(robj *host, robj *port) {
     zfree(cs);
     dictDelete(server.migrate_cached_sockets,name);
     sdsfree(name);
+    __A_VARIABLE = 1;
 }
 
 void migrateCloseTimedoutSockets(void) {
+    volatile int __A_VARIABLE;
     dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
     dictEntry *de;
 
@@ -5052,6 +5378,7 @@ void migrateCloseTimedoutSockets(void) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* MIGRATE host port key dbid timeout [COPY | REPLACE | AUTH password]
@@ -5392,30 +5719,38 @@ socket_err:
  * the target instance. See the Redis Cluster specification for more
  * information. */
 void askingCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_ASKING;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* The READONLY command is used by clients to enter the read-only mode.
  * In this mode slaves will not redirect clients as long as clients access
  * with read-only commands to keys that are served by the slave's master. */
 void readonlyCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_READONLY;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* The READWRITE command just clears the READONLY command state. */
 void readwriteCommand(client *c) {
+    volatile int __A_VARIABLE;
     c->flags &= ~CLIENT_READONLY;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* Return the pointer to the cluster node that is able to serve the command.
@@ -5630,6 +5965,7 @@ clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, in
  * node we want to mention in the redirection. Moreover hashslot should
  * be set to the hash slot that caused the redirection. */
 void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
+    volatile int __A_VARIABLE;
     if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
         addReplySds(c,sdsnew("-CROSSSLOT Keys in request don't hash to the same slot\r\n"));
     } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
@@ -5651,6 +5987,7 @@ void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_co
     } else {
         serverPanic("getNodeByQuery() unknown error.");
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by the function processing clients incrementally
@@ -5665,6 +6002,7 @@ void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_co
  * longer handles, the client is sent a redirection error, and the function
  * returns 1. Otherwise 0 is returned and no operation is performed. */
 int clusterRedirectBlockedClientIfNeeded(client *c) {
+    volatile int __A_VARIABLE;
     if (c->flags & CLIENT_BLOCKED &&
         (c->btype == BLOCKED_LIST ||
          c->btype == BLOCKED_ZSET ||
@@ -5676,6 +6014,7 @@ int clusterRedirectBlockedClientIfNeeded(client *c) {
         /* If the cluster is down, unblock the client with the right error. */
         if (server.cluster->state == CLUSTER_FAIL) {
             clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
+            __A_VARIABLE = 1;
             return 1;
         }
 
@@ -5700,10 +6039,12 @@ int clusterRedirectBlockedClientIfNeeded(client *c) {
                         CLUSTER_REDIR_MOVED);
                 }
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return 1;
             }
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/src/config.c b/src/config.c
index ba8e17e..4d5342e 100644
--- a/src/config.c
+++ b/src/config.c
@@ -104,31 +104,45 @@ clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
 
 /* Get enum value from name. If there is no match INT_MIN is returned. */
 int configEnumGetValue(configEnum *ce, char *name) {
+    volatile int __A_VARIABLE;
     while(ce->name != NULL) {
-        if (!strcasecmp(ce->name,name)) return ce->val;
+        if (!strcasecmp(ce->name,name)) {
+            __A_VARIABLE = 1;
+            return ce->val;
+        }
         ce++;
     }
+    __A_VARIABLE = 1;
     return INT_MIN;
 }
 
 /* Get enum name from value. If no match is found NULL is returned. */
 const char *configEnumGetName(configEnum *ce, int val) {
+    volatile int __A_VARIABLE;
     while(ce->name != NULL) {
-        if (ce->val == val) return ce->name;
+        if (ce->val == val) {
+            __A_VARIABLE = 1;
+            return ce->name;
+        }
         ce++;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Wrapper for configEnumGetName() returning "unknown" instead of NULL if
  * there is no match. */
 const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
+    volatile int __A_VARIABLE;
     const char *name = configEnumGetName(ce,val);
+    __A_VARIABLE = 1;
     return name ? name : "unknown";
 }
 
 /* Used for INFO generation. */
 const char *evictPolicyToString(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
 }
 
@@ -143,19 +157,24 @@ int yesnotoi(char *s) {
 }
 
 void appendServerSaveParams(time_t seconds, int changes) {
+    volatile int __A_VARIABLE;
     server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));
     server.saveparams[server.saveparamslen].seconds = seconds;
     server.saveparams[server.saveparamslen].changes = changes;
     server.saveparamslen++;
+    __A_VARIABLE = 1;
 }
 
 void resetServerSaveParams(void) {
+    volatile int __A_VARIABLE;
     zfree(server.saveparams);
     server.saveparams = NULL;
     server.saveparamslen = 0;
+    __A_VARIABLE = 1;
 }
 
 void queueLoadModule(sds path, sds *argv, int argc) {
+    volatile int __A_VARIABLE;
     int i;
     struct moduleLoadQueueEntry *loadmod;
 
@@ -167,9 +186,11 @@ void queueLoadModule(sds path, sds *argv, int argc) {
         loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
     }
     listAddNodeTail(server.loadmodule_queue,loadmod);
+    __A_VARIABLE = 1;
 }
 
 void loadServerConfigFromString(char *config) {
+    volatile int __A_VARIABLE;
     char *err = NULL;
     int linenum = 0, totlines, i;
     int slaveof_linenum = 0;
@@ -814,6 +835,7 @@ void loadServerConfigFromString(char *config) {
     }
 
     sdsfreesplitres(lines,totlines);
+    __A_VARIABLE = 1;
     return;
 
 loaderr:
@@ -822,6 +844,7 @@ loaderr:
     fprintf(stderr, ">>> '%s'\n", lines[i]);
     fprintf(stderr, "%s\n", err);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Load the server configuration from the specified filename.
@@ -832,6 +855,7 @@ loaderr:
  * empty. This way loadServerConfig can be used to just load a file or
  * just load a string. */
 void loadServerConfig(char *filename, char *options) {
+    volatile int __A_VARIABLE;
     sds config = sdsempty();
     char buf[CONFIG_MAX_LINE+1];
 
@@ -859,6 +883,7 @@ void loadServerConfig(char *filename, char *options) {
     }
     loadServerConfigFromString(config);
     sdsfree(config);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -1323,6 +1348,7 @@ badfmt: /* Bad format errors */
 } while(0);
 
 void configGetCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o = c->argv[2];
     void *replylen = addDeferredMultiBulkLength(c);
     char *pattern = o->ptr;
@@ -1572,6 +1598,7 @@ void configGetCommand(client *c) {
         matches++;
     }
     setDeferredMultiBulkLength(c,replylen,matches*2);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -1622,12 +1649,15 @@ struct rewriteConfigState {
 
 /* Append the new line to the current configuration state. */
 void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
+    volatile int __A_VARIABLE;
     state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
     state->lines[state->numlines++] = line;
+    __A_VARIABLE = 1;
 }
 
 /* Populate the option -> list of line numbers map. */
 void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
+    volatile int __A_VARIABLE;
     list *l = dictFetchValue(state->option_to_line,option);
 
     if (l == NULL) {
@@ -1635,6 +1665,7 @@ void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds op
         dictAdd(state->option_to_line,sdsdup(option),l);
     }
     listAddNodeTail(l,(void*)(long)linenum);
+    __A_VARIABLE = 1;
 }
 
 /* Add the specified option to the set of processed options.
@@ -1642,9 +1673,11 @@ void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds op
  * in the config file, while options the rewrite process does not understand
  * remain untouched. */
 void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
+    volatile int __A_VARIABLE;
     sds opt = sdsnew(option);
 
     if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
+    __A_VARIABLE = 1;
 }
 
 /* Read the old file, split it into lines to populate a newly created
@@ -1653,8 +1686,12 @@ void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *
  * If it is impossible to read the old file, NULL is returned.
  * If the old file does not exist at all, an empty state is returned. */
 struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
+    volatile int __A_VARIABLE;
     FILE *fp = fopen(path,"r");
-    if (fp == NULL && errno != ENOENT) return NULL;
+    if (fp == NULL && errno != ENOENT) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     char buf[CONFIG_MAX_LINE+1];
     int linenum = -1;
@@ -1664,7 +1701,10 @@ struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
     state->numlines = 0;
     state->lines = NULL;
     state->has_tail = 0;
-    if (fp == NULL) return state;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return state;
+    }
 
     /* Read the old file line by line, populate the state. */
     while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
@@ -1717,6 +1757,7 @@ struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
         sdsfreesplitres(argv,argc);
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return state;
 }
 
@@ -1737,6 +1778,7 @@ struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
  * "line" is either used, or freed, so the caller does not need to free it
  * in any way. */
 void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
+    volatile int __A_VARIABLE;
     sds o = sdsnew(option);
     list *l = dictFetchValue(state->option_to_line,o);
 
@@ -1746,6 +1788,7 @@ void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *opti
         /* Option not used previously, and we are not forced to use it. */
         sdsfree(line);
         sdsfree(o);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1769,6 +1812,7 @@ void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *opti
         rewriteConfigAppendLine(state,line);
     }
     sdsfree(o);
+    __A_VARIABLE = 1;
 }
 
 /* Write the long long 'bytes' value as a string in a way that is parsable
@@ -1791,6 +1835,7 @@ int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {
 
 /* Rewrite a simple "option-name <bytes>" configuration option. */
 void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {
+    volatile int __A_VARIABLE;
     char buf[64];
     int force = value != defvalue;
     sds line;
@@ -1798,19 +1843,23 @@ void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, lo
     rewriteConfigFormatMemory(buf,sizeof(buf),value);
     line = sdscatprintf(sdsempty(),"%s %s",option,buf);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a yes/no option. */
 void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
+    volatile int __A_VARIABLE;
     int force = value != defvalue;
     sds line = sdscatprintf(sdsempty(),"%s %s",option,
         value ? "yes" : "no");
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a string option. */
 void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
+    volatile int __A_VARIABLE;
     int force = 1;
     sds line;
 
@@ -1818,6 +1867,7 @@ void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, c
      * configuration file to be set to NULL again at the next reboot. */
     if (value == NULL) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1829,38 +1879,46 @@ void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, c
     line = sdscatrepr(line, value, strlen(value));
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a numerical (long long range) option. */
 void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {
+    volatile int __A_VARIABLE;
     int force = value != defvalue;
     sds line = sdscatprintf(sdsempty(),"%s %lld",option,value);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a octal option. */
 void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
+    volatile int __A_VARIABLE;
     int force = value != defvalue;
     sds line = sdscatprintf(sdsempty(),"%s %o",option,value);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite an enumeration option. It takes as usually state and option name,
  * and in addition the enumeration array and the default value for the
  * option. */
 void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {
+    volatile int __A_VARIABLE;
     sds line;
     const char *name = configEnumGetNameOrUnknown(ce,value);
     int force = value != defval;
 
     line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the syslog-facility option. */
 void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     int value = server.syslog_facility;
     int force = value != LOG_LOCAL0;
     const char *name = NULL, *option = "syslog-facility";
@@ -1869,10 +1927,12 @@ void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
     name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
     line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the save option. */
 void rewriteConfigSaveOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     int j;
     sds line;
 
@@ -1886,21 +1946,26 @@ void rewriteConfigSaveOption(struct rewriteConfigState *state) {
     }
     /* Mark "save" as processed in case server.saveparamslen is zero. */
     rewriteConfigMarkAsProcessed(state,"save");
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the dir option, always using absolute paths.*/
 void rewriteConfigDirOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     char cwd[1024];
 
     if (getcwd(cwd,sizeof(cwd)) == NULL) {
         rewriteConfigMarkAsProcessed(state,"dir");
+        __A_VARIABLE = 1;
         return; /* no rewrite on error. */
     }
     rewriteConfigStringOption(state,"dir",cwd,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the slaveof option. */
 void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {
+    volatile int __A_VARIABLE;
     sds line;
 
     /* If this is a master, we want all the slaveof config options
@@ -1908,15 +1973,18 @@ void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option)
      * we don't want a slaveof directive inside redis.conf. */
     if (server.cluster_enabled || server.masterhost == NULL) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
     line = sdscatprintf(sdsempty(),"%s %s %d", option,
         server.masterhost, server.masterport);
     rewriteConfigRewriteLine(state,option,line,1);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the notify-keyspace-events option. */
 void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     int force = server.notify_keyspace_events != 0;
     char *option = "notify-keyspace-events";
     sds line, flags;
@@ -1927,10 +1995,12 @@ void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
     line = sdscatrepr(line, flags, sdslen(flags));
     sdsfree(flags);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the client-output-buffer-limit option. */
 void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     int j;
     char *option = "client-output-buffer-limit";
 
@@ -1956,10 +2026,12 @@ void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state
                 (long) server.client_obuf_limits[j].soft_limit_seconds);
         rewriteConfigRewriteLine(state,option,line,force);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the bind option. */
 void rewriteConfigBindOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     int force = 1;
     sds line, addresses;
     char *option = "bind";
@@ -1967,6 +2039,7 @@ void rewriteConfigBindOption(struct rewriteConfigState *state) {
     /* Nothing to rewrite if we don't have bind addresses. */
     if (server.bindaddr_count == 0) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1978,11 +2051,13 @@ void rewriteConfigBindOption(struct rewriteConfigState *state) {
     sdsfree(addresses);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Glue together the configuration lines in the current configuration
  * rewrite state into a single string, stripping multiple empty lines. */
 sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     sds content = sdsempty();
     int j, was_empty = 0;
 
@@ -1997,15 +2072,18 @@ sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
         content = sdscatsds(content,state->lines[j]);
         content = sdscatlen(content,"\n",1);
     }
+    __A_VARIABLE = 1;
     return content;
 }
 
 /* Free the configuration rewrite state. */
 void rewriteConfigReleaseState(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     sdsfreesplitres(state->lines,state->numlines);
     dictRelease(state->option_to_line);
     dictRelease(state->rewritten);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 /* At the end of the rewrite process the state contains the remaining
@@ -2017,6 +2095,7 @@ void rewriteConfigReleaseState(struct rewriteConfigState *state) {
  * This function does just this, iterating all the option names and
  * blanking all the lines still associated. */
 void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     dictIterator *di = dictGetIterator(state->option_to_line);
     dictEntry *de;
 
@@ -2041,6 +2120,7 @@ void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function overwrites the old configuration file with the new content.
@@ -2056,6 +2136,7 @@ void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
  * The function returns 0 on success, otherwise -1 is returned and errno
  * set accordingly. */
 int rewriteConfigOverwriteFile(char *configfile, sds content) {
+    volatile int __A_VARIABLE;
     int retval = 0;
     int fd = open(configfile,O_RDWR|O_CREAT,0644);
     int content_size = sdslen(content), padding = 0;
@@ -2064,9 +2145,13 @@ int rewriteConfigOverwriteFile(char *configfile, sds content) {
 
     /* 1) Open the old file (or create a new one if it does not
      *    exist), get the size. */
-    if (fd == -1) return -1; /* errno set by open(). */
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* errno set by open(). */
     if (fstat(fd,&sb) == -1) {
         close(fd);
+        __A_VARIABLE = 1;
         return -1; /* errno set by fstat(). */
     }
 
@@ -2097,6 +2182,7 @@ int rewriteConfigOverwriteFile(char *configfile, sds content) {
 cleanup:
     sdsfree(content_padded);
     close(fd);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -2109,12 +2195,16 @@ cleanup:
  *
  * On error -1 is returned and errno is set accordingly, otherwise 0. */
 int rewriteConfig(char *path) {
+    volatile int __A_VARIABLE;
     struct rewriteConfigState *state;
     sds newcontent;
     int retval;
 
     /* Step 1: read the old config into our rewrite state. */
-    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
+    if ((state = rewriteConfigReadOldFile(path)) == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Step 2: rewrite every single option, replacing or appending it inside
      * the rewrite state. */
@@ -2234,6 +2324,7 @@ int rewriteConfig(char *path) {
 
     sdsfree(newcontent);
     rewriteConfigReleaseState(state);
+    __A_VARIABLE = 1;
     return retval;
 }
 
diff --git a/src/crc16.c b/src/crc16.c
index 7b8c1da..039b24e 100644
--- a/src/crc16.c
+++ b/src/crc16.c
@@ -80,9 +80,11 @@ static const uint16_t crc16tab[256]= {
 };
 
 uint16_t crc16(const char *buf, int len) {
+    volatile int __A_VARIABLE;
     int counter;
     uint16_t crc = 0;
     for (counter = 0; counter < len; counter++)
             crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
+    __A_VARIABLE = 1;
     return crc;
 }
diff --git a/src/crc64.c b/src/crc64.c
index f1f7649..5b055e4 100644
--- a/src/crc64.c
+++ b/src/crc64.c
@@ -171,12 +171,14 @@ static const uint64_t crc64_tab[256] = {
 };
 
 uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
+    volatile int __A_VARIABLE;
     uint64_t j;
 
     for (j = 0; j < l; j++) {
         uint8_t byte = s[j];
         crc = crc64_tab[(uint8_t)crc ^ byte] ^ (crc >> 8);
     }
+    __A_VARIABLE = 1;
     return crc;
 }
 
@@ -186,10 +188,12 @@ uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
 
 #define UNUSED(x) (void)(x)
 int crc64Test(int argc, char *argv[]) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     UNUSED(argv);
     printf("e9c6d914c4b8d9ca == %016llx\n",
         (unsigned long long) crc64(0,(unsigned char*)"123456789",9));
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/db.c b/src/db.c
index 62c8aa1..b3fb281 100644
--- a/src/db.c
+++ b/src/db.c
@@ -44,9 +44,11 @@ int keyIsExpired(redisDb *db, robj *key);
  * Firstly, decrement the counter if the decrement time is reached.
  * Then logarithmically increment the counter, and update the access time. */
 void updateLFU(robj *val) {
+    volatile int __A_VARIABLE;
     unsigned long counter = LFUDecrAndReturn(val);
     counter = LFULogIncr(counter);
     val->lru = (LFUGetTimeInMinutes()<<8) | counter;
+    __A_VARIABLE = 1;
 }
 
 /* Low level key lookup API, not actually called directly from commands
@@ -98,6 +100,7 @@ robj *lookupKey(redisDb *db, robj *key, int flags) {
  * correctly report a key is expired on slaves even if the master is lagging
  * expiring our key via DELs in the replication link. */
 robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
+    volatile int __A_VARIABLE;
     robj *val;
 
     if (expireIfNeeded(db,key) == 1) {
@@ -106,6 +109,7 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
          * to return NULL ASAP. */
         if (server.masterhost == NULL) {
             server.stat_keyspace_misses++;
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -127,6 +131,7 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
             server.current_client->cmd->flags & CMD_READONLY)
         {
             server.stat_keyspace_misses++;
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -135,12 +140,15 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
         server.stat_keyspace_misses++;
     else
         server.stat_keyspace_hits++;
+    __A_VARIABLE = 1;
     return val;
 }
 
 /* Like lookupKeyReadWithFlags(), but does not use any flag, which is the
  * common case. */
 robj *lookupKeyRead(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
 }
 
@@ -150,19 +158,25 @@ robj *lookupKeyRead(redisDb *db, robj *key) {
  * Returns the linked value object if the key exists or NULL if the key
  * does not exist in the specified DB. */
 robj *lookupKeyWrite(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     expireIfNeeded(db,key);
+    __A_VARIABLE = 1;
     return lookupKey(db,key,LOOKUP_NONE);
 }
 
 robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyRead(c->db, key);
     if (!o) addReply(c,reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyWrite(c->db, key);
     if (!o) addReply(c,reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -171,6 +185,7 @@ robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
  *
  * The program is aborted if the key already exists. */
 void dbAdd(redisDb *db, robj *key, robj *val) {
+    volatile int __A_VARIABLE;
     sds copy = sdsdup(key->ptr);
     int retval = dictAdd(db->dict, copy, val);
 
@@ -179,6 +194,7 @@ void dbAdd(redisDb *db, robj *key, robj *val) {
         val->type == OBJ_ZSET)
         signalKeyAsReady(db, key);
     if (server.cluster_enabled) slotToKeyAdd(key);
+    __A_VARIABLE = 1;
 }
 
 /* Overwrite an existing key with a new value. Incrementing the reference
@@ -187,6 +203,7 @@ void dbAdd(redisDb *db, robj *key, robj *val) {
  *
  * The program is aborted if the key was not already present. */
 void dbOverwrite(redisDb *db, robj *key, robj *val) {
+    volatile int __A_VARIABLE;
     dictEntry *de = dictFind(db->dict,key->ptr);
 
     serverAssertWithInfo(NULL,key,de != NULL);
@@ -203,6 +220,7 @@ void dbOverwrite(redisDb *db, robj *key, robj *val) {
     }
 
     dictFreeVal(db->dict, &auxentry);
+    __A_VARIABLE = 1;
 }
 
 /* High level Set operation. This function can be used in order to set
@@ -214,6 +232,7 @@ void dbOverwrite(redisDb *db, robj *key, robj *val) {
  *
  * All the new keys in the database should be created via this interface. */
 void setKey(redisDb *db, robj *key, robj *val) {
+    volatile int __A_VARIABLE;
     if (lookupKeyWrite(db,key) == NULL) {
         dbAdd(db,key,val);
     } else {
@@ -222,9 +241,12 @@ void setKey(redisDb *db, robj *key, robj *val) {
     incrRefCount(val);
     removeExpire(db,key);
     signalModifiedKey(db,key);
+    __A_VARIABLE = 1;
 }
 
 int dbExists(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictFind(db->dict,key->ptr) != NULL;
 }
 
@@ -233,6 +255,7 @@ int dbExists(redisDb *db, robj *key) {
  *
  * The function makes sure to return keys not already expired. */
 robj *dbRandomKey(redisDb *db) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     int maxtries = 100;
     int allvolatile = dictSize(db->dict) == dictSize(db->expires);
@@ -242,7 +265,10 @@ robj *dbRandomKey(redisDb *db) {
         robj *keyobj;
 
         de = dictGetRandomKey(db->dict);
-        if (de == NULL) return NULL;
+        if (de == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
 
         key = dictGetKey(de);
         keyobj = createStringObject(key,sdslen(key));
@@ -256,6 +282,7 @@ robj *dbRandomKey(redisDb *db) {
                  * To prevent the infinite loop we do some tries, but if there
                  * are the conditions for an infinite loop, eventually we
                  * return a key name that may be already expired. */
+                __A_VARIABLE = 1;
                 return keyobj;
             }
             if (expireIfNeeded(db,keyobj)) {
@@ -263,8 +290,10 @@ robj *dbRandomKey(redisDb *db) {
                 continue; /* search for another key. This expired. */
             }
         }
+        __A_VARIABLE = 1;
         return keyobj;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Delete a key, value, and associated expiration entry if any, from the DB */
@@ -283,6 +312,8 @@ int dbSyncDelete(redisDb *db, robj *key) {
 /* This is a wrapper whose behavior depends on the Redis lazy free
  * configuration. Deletes the key synchronously or asynchronously. */
 int dbDelete(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return server.lazyfree_lazy_server_del ? dbAsyncDelete(db,key) :
                                              dbSyncDelete(db,key);
 }
@@ -315,6 +346,7 @@ int dbDelete(redisDb *db, robj *key) {
  * using an sdscat() call to append some data, or anything else.
  */
 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
+    volatile int __A_VARIABLE;
     serverAssert(o->type == OBJ_STRING);
     if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
         robj *decoded = getDecodedObject(o);
@@ -322,6 +354,7 @@ robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
         decrRefCount(decoded);
         dbOverwrite(db,key,o);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -340,11 +373,13 @@ robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
  * database(s). Otherwise -1 is returned in the specific case the
  * DB number is out of range, and errno is set to EINVAL. */
 long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
+    volatile int __A_VARIABLE;
     int async = (flags & EMPTYDB_ASYNC);
     long long removed = 0;
 
     if (dbnum < -1 || dbnum >= server.dbnum) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return -1;
     }
 
@@ -373,13 +408,18 @@ long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
         }
     }
     if (dbnum == -1) flushSlaveKeysWithExpireList();
+    __A_VARIABLE = 1;
     return removed;
 }
 
 int selectDb(client *c, int id) {
-    if (id < 0 || id >= server.dbnum)
+    volatile int __A_VARIABLE;
+    if (id < 0 || id >= server.dbnum) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
     c->db = &server.db[id];
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -393,11 +433,15 @@ int selectDb(client *c, int id) {
  *----------------------------------------------------------------------------*/
 
 void signalModifiedKey(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     touchWatchedKey(db,key);
+    __A_VARIABLE = 1;
 }
 
 void signalFlushedDb(int dbid) {
+    volatile int __A_VARIABLE;
     touchWatchedKeysOnFlush(dbid);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -430,21 +474,30 @@ int getFlushCommandFlags(client *c, int *flags) {
  *
  * Flushes the currently SELECTed Redis DB. */
 void flushdbCommand(client *c) {
+    volatile int __A_VARIABLE;
     int flags;
 
-    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
+    if (getFlushCommandFlags(c,&flags) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     signalFlushedDb(c->db->id);
     server.dirty += emptyDb(c->db->id,flags,NULL);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* FLUSHALL [ASYNC]
  *
  * Flushes the whole server data set. */
 void flushallCommand(client *c) {
+    volatile int __A_VARIABLE;
     int flags;
 
-    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
+    if (getFlushCommandFlags(c,&flags) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     signalFlushedDb(-1);
     server.dirty += emptyDb(-1,flags,NULL);
     addReply(c,shared.ok);
@@ -462,10 +515,12 @@ void flushallCommand(client *c) {
         server.dirty = saved_dirty;
     }
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 /* This command implements DEL and LAZYDEL. */
 void delGenericCommand(client *c, int lazy) {
+    volatile int __A_VARIABLE;
     int numdel = 0, j;
 
     for (j = 1; j < c->argc; j++) {
@@ -481,19 +536,25 @@ void delGenericCommand(client *c, int lazy) {
         }
     }
     addReplyLongLong(c,numdel);
+    __A_VARIABLE = 1;
 }
 
 void delCommand(client *c) {
+    volatile int __A_VARIABLE;
     delGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void unlinkCommand(client *c) {
+    volatile int __A_VARIABLE;
     delGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* EXISTS key1 key2 ... key_N.
  * Return value is the number of keys existing. */
 void existsCommand(client *c) {
+    volatile int __A_VARIABLE;
     long long count = 0;
     int j;
 
@@ -501,17 +562,22 @@ void existsCommand(client *c) {
         if (lookupKeyRead(c->db,c->argv[j])) count++;
     }
     addReplyLongLong(c,count);
+    __A_VARIABLE = 1;
 }
 
 void selectCommand(client *c) {
+    volatile int __A_VARIABLE;
     long id;
 
     if (getLongFromObjectOrReply(c, c->argv[1], &id,
-        "invalid DB index") != C_OK)
+        "invalid DB index") != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (server.cluster_enabled && id != 0) {
         addReplyError(c,"SELECT is not allowed in cluster mode");
+        __A_VARIABLE = 1;
         return;
     }
     if (selectDb(c,id) == C_ERR) {
@@ -519,21 +585,26 @@ void selectCommand(client *c) {
     } else {
         addReply(c,shared.ok);
     }
+    __A_VARIABLE = 1;
 }
 
 void randomkeyCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *key;
 
     if ((key = dbRandomKey(c->db)) == NULL) {
         addReply(c,shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
     addReplyBulk(c,key);
     decrRefCount(key);
+    __A_VARIABLE = 1;
 }
 
 void keysCommand(client *c) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     sds pattern = c->argv[1]->ptr;
@@ -558,11 +629,13 @@ void keysCommand(client *c) {
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c,replylen,numkeys);
+    __A_VARIABLE = 1;
 }
 
 /* This callback is used by scanGenericCommand in order to collect elements
  * returned by the dictionary iterator into a list. */
 void scanCallback(void *privdata, const dictEntry *de) {
+    volatile int __A_VARIABLE;
     void **pd = (void**) privdata;
     list *keys = pd[0];
     robj *o = pd[1];
@@ -589,6 +662,7 @@ void scanCallback(void *privdata, const dictEntry *de) {
 
     listAddNodeTail(keys, key);
     if (val) listAddNodeTail(keys, val);
+    __A_VARIABLE = 1;
 }
 
 /* Try to parse a SCAN cursor stored at object 'o':
@@ -596,6 +670,7 @@ void scanCallback(void *privdata, const dictEntry *de) {
  * returns C_OK. Otherwise return C_ERR and send an error to the
  * client. */
 int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
+    volatile int __A_VARIABLE;
     char *eptr;
 
     /* Use strtoul() because we need an *unsigned* long, so
@@ -605,8 +680,10 @@ int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
     if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
     {
         addReplyError(c, "invalid cursor");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -622,6 +699,7 @@ int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
  * In the case of a Hash object the function returns both the field and value
  * of every element on the Hash. */
 void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
+    volatile int __A_VARIABLE;
     int i, j;
     list *keys = listCreate();
     listNode *node, *nextnode;
@@ -796,24 +874,35 @@ void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
 cleanup:
     listSetFreeMethod(keys,decrRefCountVoid);
     listRelease(keys);
+    __A_VARIABLE = 1;
 }
 
 /* The SCAN command completely relies on scanGenericCommand. */
 void scanCommand(client *c) {
+    volatile int __A_VARIABLE;
     unsigned long cursor;
-    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     scanGenericCommand(c,NULL,cursor);
+    __A_VARIABLE = 1;
 }
 
 void dbsizeCommand(client *c) {
+    volatile int __A_VARIABLE;
     addReplyLongLong(c,dictSize(c->db->dict));
+    __A_VARIABLE = 1;
 }
 
 void lastsaveCommand(client *c) {
+    volatile int __A_VARIABLE;
     addReplyLongLong(c,server.lastsave);
+    __A_VARIABLE = 1;
 }
 
 void typeCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     char *type;
 
@@ -836,6 +925,7 @@ void typeCommand(client *c) {
         }
     }
     addReplyStatus(c,type);
+    __A_VARIABLE = 1;
 }
 
 void shutdownCommand(client *c) {
@@ -867,6 +957,7 @@ void shutdownCommand(client *c) {
 }
 
 void renameGenericCommand(client *c, int nx) {
+    volatile int __A_VARIABLE;
     robj *o;
     long long expire;
     int samekey = 0;
@@ -875,11 +966,14 @@ void renameGenericCommand(client *c, int nx) {
      * if the key exists, however we still return an error on unexisting key. */
     if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
 
-    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (samekey) {
         addReply(c,nx ? shared.czero : shared.ok);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -889,6 +983,7 @@ void renameGenericCommand(client *c, int nx) {
         if (nx) {
             decrRefCount(o);
             addReply(c,shared.czero);
+            __A_VARIABLE = 1;
             return;
         }
         /* Overwrite: delete the old key before creating the new one
@@ -906,17 +1001,23 @@ void renameGenericCommand(client *c, int nx) {
         c->argv[2],c->db->id);
     server.dirty++;
     addReply(c,nx ? shared.cone : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void renameCommand(client *c) {
+    volatile int __A_VARIABLE;
     renameGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void renamenxCommand(client *c) {
+    volatile int __A_VARIABLE;
     renameGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void moveCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     redisDb *src, *dst;
     int srcid;
@@ -924,6 +1025,7 @@ void moveCommand(client *c) {
 
     if (server.cluster_enabled) {
         addReplyError(c,"MOVE is not allowed in cluster mode");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -936,6 +1038,7 @@ void moveCommand(client *c) {
         selectDb(c,dbid) == C_ERR)
     {
         addReply(c,shared.outofrangeerr);
+        __A_VARIABLE = 1;
         return;
     }
     dst = c->db;
@@ -945,6 +1048,7 @@ void moveCommand(client *c) {
      * DB as the source DB it is probably an error. */
     if (src == dst) {
         addReply(c,shared.sameobjecterr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -952,6 +1056,7 @@ void moveCommand(client *c) {
     o = lookupKeyWrite(c->db,c->argv[1]);
     if (!o) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     expire = getExpire(c->db,c->argv[1]);
@@ -959,6 +1064,7 @@ void moveCommand(client *c) {
     /* Return zero if the key already exists in the target DB */
     if (lookupKeyWrite(dst,c->argv[1]) != NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     dbAdd(dst,c->argv[1],o);
@@ -969,6 +1075,7 @@ void moveCommand(client *c) {
     dbDelete(src,c->argv[1]);
     server.dirty++;
     addReply(c,shared.cone);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for dbSwapDatabases(): scans the list of keys that have
@@ -976,6 +1083,7 @@ void moveCommand(client *c) {
  * and signal the keys as ready if they are of the right type. See the comment
  * where the function is used for more info. */
 void scanDatabaseForReadyLists(redisDb *db) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     dictIterator *di = dictGetSafeIterator(db->blocking_keys);
     while((de = dictNext(di)) != NULL) {
@@ -987,6 +1095,7 @@ void scanDatabaseForReadyLists(redisDb *db) {
             signalKeyAsReady(db, key);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Swap two databases at runtime so that all clients will magically see
@@ -998,9 +1107,16 @@ void scanDatabaseForReadyLists(redisDb *db) {
  * Returns C_ERR if at least one of the DB ids are out of range, otherwise
  * C_OK is returned. */
 int dbSwapDatabases(int id1, int id2) {
+    volatile int __A_VARIABLE;
     if (id1 < 0 || id1 >= server.dbnum ||
-        id2 < 0 || id2 >= server.dbnum) return C_ERR;
-    if (id1 == id2) return C_OK;
+        id2 < 0 || id2 >= server.dbnum) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    }
+    if (id1 == id2) {
+    	__A_VARIABLE = 1;
+    	return C_OK;
+    }
     redisDb aux = server.db[id1];
     redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
 
@@ -1026,6 +1142,7 @@ int dbSwapDatabases(int id1, int id2) {
      * if needed. */
     scanDatabaseForReadyLists(db1);
     scanDatabaseForReadyLists(db2);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1063,9 +1180,11 @@ void swapdbCommand(client *c) {
  *----------------------------------------------------------------------------*/
 
 int removeExpire(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     /* An expire may only be removed if there is a corresponding entry in the
      * main dict. Otherwise, the key will never be freed. */
     serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    __A_VARIABLE = 1;
     return dictDelete(db->expires,key->ptr) == DICT_OK;
 }
 
@@ -1074,6 +1193,7 @@ int removeExpire(redisDb *db, robj *key) {
  * to NULL. The 'when' parameter is the absolute unix time in milliseconds
  * after which the key will no longer be considered valid. */
 void setExpire(client *c, redisDb *db, robj *key, long long when) {
+    volatile int __A_VARIABLE;
     dictEntry *kde, *de;
 
     /* Reuse the sds from the main dict in the expire dict */
@@ -1085,20 +1205,26 @@ void setExpire(client *c, redisDb *db, robj *key, long long when) {
     int writable_slave = server.masterhost && server.repl_slave_ro == 0;
     if (c && writable_slave && !(c->flags & CLIENT_MASTER))
         rememberSlaveKeyWithExpire(db,key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the expire time of the specified key, or -1 if no expire
  * is associated with this key (i.e. the key is non volatile) */
 long long getExpire(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
 
     /* No expire? return ASAP */
     if (dictSize(db->expires) == 0 ||
-       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;
+       (de = dictFind(db->expires,key->ptr)) == NULL) {
+    	__A_VARIABLE = 1;
+    	return -1;
+    }
 
     /* The entry was found in the expire dict, this means it should also
      * be present in the main dict (safety check). */
     serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    __A_VARIABLE = 1;
     return dictGetSignedIntegerVal(de);
 }
 
@@ -1111,6 +1237,7 @@ long long getExpire(redisDb *db, robj *key) {
  * will be consistent even if we allow write operations against expiring
  * keys. */
 void propagateExpire(redisDb *db, robj *key, int lazy) {
+    volatile int __A_VARIABLE;
     robj *argv[2];
 
     argv[0] = lazy ? shared.unlink : shared.del;
@@ -1124,16 +1251,24 @@ void propagateExpire(redisDb *db, robj *key, int lazy) {
 
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
+    __A_VARIABLE = 1;
 }
 
 /* Check if the key is expired. */
 int keyIsExpired(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     mstime_t when = getExpire(db,key);
 
-    if (when < 0) return 0; /* No expire for this key */
+    if (when < 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* No expire for this key */
 
     /* Don't expire anything while loading. It will be done later. */
-    if (server.loading) return 0;
+    if (server.loading) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* If we are in the context of a Lua script, we pretend that time is
      * blocked to when the Lua script started. This way a key can expire
@@ -1142,6 +1277,7 @@ int keyIsExpired(redisDb *db, robj *key) {
      * See issue #1525 on Github for more information. */
     mstime_t now = server.lua_caller ? server.lua_time_start : mstime();
 
+    __A_VARIABLE = 1;
     return now > when;
 }
 
@@ -1165,7 +1301,11 @@ int keyIsExpired(redisDb *db, robj *key) {
  * The return value of the function is 0 if the key is still valid,
  * otherwise the function returns 1 if the key is expired. */
 int expireIfNeeded(redisDb *db, robj *key) {
-    if (!keyIsExpired(db,key)) return 0;
+    volatile int __A_VARIABLE;
+    if (!keyIsExpired(db,key)) {
+                                         __A_VARIABLE = 1;
+                                         return 0;
+    }
 
     /* If we are running in the context of a slave, instead of
      * evicting the expired key from the database, we return ASAP:
@@ -1175,13 +1315,17 @@ int expireIfNeeded(redisDb *db, robj *key) {
      * Still we try to return the right information to the caller,
      * that is, 0 if we think the key should be still valid, 1 if
      * we think the key is expired at this time. */
-    if (server.masterhost != NULL) return 1;
+    if (server.masterhost != NULL) {
+                                         __A_VARIABLE = 1;
+                                         return 1;
+    }
 
     /* Delete the key */
     server.stat_expiredkeys++;
     propagateExpire(db,key,server.lazyfree_lazy_expire);
     notifyKeyspaceEvent(NOTIFY_EXPIRED,
         "expired",key,db->id);
+    __A_VARIABLE = 1;
     return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                          dbSyncDelete(db,key);
 }
@@ -1249,13 +1393,16 @@ int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *nu
 
 /* Free the result of getKeysFromCommand. */
 void getKeysFreeResult(int *result) {
+    volatile int __A_VARIABLE;
     zfree(result);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to extract keys from following commands:
  * ZUNIONSTORE <destkey> <num-keys> <key> <key> ... <key> <options>
  * ZINTERSTORE <destkey> <num-keys> <key> <key> ... <key> <options> */
 int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, num, *keys;
     UNUSED(cmd);
 
@@ -1264,6 +1411,7 @@ int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *nu
      * reply with syntax error. */
     if (num < 1 || num > (argc-3)) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1278,6 +1426,7 @@ int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *nu
     /* Finally add the argv[1] key position (the storage key target). */
     keys[num] = 1;
     *numkeys = num+1;  /* Total keys = {union,inter} keys + storage key */
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1285,6 +1434,7 @@ int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *nu
  * EVAL <script> <num-keys> <key> <key> ... <key> [more stuff]
  * EVALSHA <script> <num-keys> <key> <key> ... <key> [more stuff] */
 int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, num, *keys;
     UNUSED(cmd);
 
@@ -1293,6 +1443,7 @@ int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
      * reply with syntax error. */
     if (num <= 0 || num > (argc-3)) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1302,6 +1453,7 @@ int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     /* Add all key positions for argv[3...n] to keys[] */
     for (i = 0; i < num; i++) keys[i] = 3+i;
 
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1313,6 +1465,7 @@ int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
  * follow in SQL-alike style. Here we parse just the minimum in order to
  * correctly identify keys in the "STORE" option. */
 int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, j, num, *keys, found_store = 0;
     UNUSED(cmd);
 
@@ -1351,10 +1504,12 @@ int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
         }
     }
     *numkeys = num + found_store;
+    __A_VARIABLE = 1;
     return keys;
 }
 
 int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, num, first, *keys;
     UNUSED(cmd);
 
@@ -1378,6 +1533,7 @@ int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkey
     keys = zmalloc(sizeof(int)*num);
     for (i = 0; i < num; i++) keys[i] = first+i;
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1386,6 +1542,7 @@ int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkey
  *                             [COUNT count] [STORE key] [STOREDIST key]
  * GEORADIUSBYMEMBER key member radius unit ... options ... */
 int *georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, num, *keys;
     UNUSED(cmd);
 
@@ -1416,12 +1573,14 @@ int *georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numk
          keys[1] = stored_key;
     }
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
 /* XREAD [BLOCK <milliseconds>] [COUNT <count>] [GROUP <groupname> <ttl>]
  *       STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N */
 int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     int i, num = 0, *keys;
     UNUSED(cmd);
 
@@ -1452,6 +1611,7 @@ int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     /* Syntax error. */
     if (streams_pos == -1 || num == 0 || num % 2 != 0) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
     num /= 2; /* We have half the keys as there are arguments because
@@ -1460,6 +1620,7 @@ int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     keys = zmalloc(sizeof(int) * num);
     for (i = streams_pos+1; i < argc-num; i++) keys[i-streams_pos-1] = i;
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1468,6 +1629,7 @@ int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
  * while rehashing the cluster and in other conditions when we need to
  * understand if we have keys for a given hash slot. */
 void slotToKeyUpdateKey(robj *key, int add) {
+    volatile int __A_VARIABLE;
     unsigned int hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));
     unsigned char buf[64];
     unsigned char *indexed = buf;
@@ -1484,27 +1646,35 @@ void slotToKeyUpdateKey(robj *key, int add) {
         raxRemove(server.cluster->slots_to_keys,indexed,keylen+2,NULL);
     }
     if (indexed != buf) zfree(indexed);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyAdd(robj *key) {
+    volatile int __A_VARIABLE;
     slotToKeyUpdateKey(key,1);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyDel(robj *key) {
+    volatile int __A_VARIABLE;
     slotToKeyUpdateKey(key,0);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyFlush(void) {
+    volatile int __A_VARIABLE;
     raxFree(server.cluster->slots_to_keys);
     server.cluster->slots_to_keys = raxNew();
     memset(server.cluster->slots_keys_count,0,
            sizeof(server.cluster->slots_keys_count));
+    __A_VARIABLE = 1;
 }
 
 /* Pupulate the specified array of objects with keys in the specified slot.
  * New objects are returned to represent keys, it's up to the caller to
  * decrement the reference count to release the keys names. */
 unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {
+    volatile int __A_VARIABLE;
     raxIterator iter;
     int j = 0;
     unsigned char indexed[2];
@@ -1518,12 +1688,14 @@ unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int coun
         keys[j++] = createStringObject((char*)iter.key+2,iter.key_len-2);
     }
     raxStop(&iter);
+    __A_VARIABLE = 1;
     return j;
 }
 
 /* Remove all the keys in the specified hash slot.
  * The number of removed items is returned. */
 unsigned int delKeysInSlot(unsigned int hashslot) {
+    volatile int __A_VARIABLE;
     raxIterator iter;
     int j = 0;
     unsigned char indexed[2];
@@ -1541,9 +1713,12 @@ unsigned int delKeysInSlot(unsigned int hashslot) {
         j++;
     }
     raxStop(&iter);
+    __A_VARIABLE = 1;
     return j;
 }
 
 unsigned int countKeysInSlot(unsigned int hashslot) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return server.cluster->slots_keys_count[hashslot];
 }
diff --git a/src/debug.c b/src/debug.c
index 1ec7c49..4f85e0c 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -62,6 +62,7 @@ typedef ucontext_t sigcontext_t;
  *
  * So digest(a,b,c,d) will be the same of digest(b,a,c,d) */
 void xorDigest(unsigned char *digest, void *ptr, size_t len) {
+    volatile int __A_VARIABLE;
     SHA1_CTX ctx;
     unsigned char hash[20], *s = ptr;
     int j;
@@ -72,12 +73,15 @@ void xorDigest(unsigned char *digest, void *ptr, size_t len) {
 
     for (j = 0; j < 20; j++)
         digest[j] ^= hash[j];
+    __A_VARIABLE = 1;
 }
 
 void xorStringObjectDigest(unsigned char *digest, robj *o) {
+    volatile int __A_VARIABLE;
     o = getDecodedObject(o);
     xorDigest(digest,o->ptr,sdslen(o->ptr));
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function instead of just computing the SHA1 and xoring it
@@ -95,6 +99,7 @@ void xorStringObjectDigest(unsigned char *digest, robj *o) {
  * will lead to a different digest compared to "fo", "obar".
  */
 void mixDigest(unsigned char *digest, void *ptr, size_t len) {
+    volatile int __A_VARIABLE;
     SHA1_CTX ctx;
     char *s = ptr;
 
@@ -102,12 +107,15 @@ void mixDigest(unsigned char *digest, void *ptr, size_t len) {
     SHA1Init(&ctx);
     SHA1Update(&ctx,digest,20);
     SHA1Final(digest,&ctx);
+    __A_VARIABLE = 1;
 }
 
 void mixStringObjectDigest(unsigned char *digest, robj *o) {
+    volatile int __A_VARIABLE;
     o = getDecodedObject(o);
     mixDigest(digest,o->ptr,sdslen(o->ptr));
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function computes the digest of a data structure stored in the
@@ -119,6 +127,7 @@ void mixStringObjectDigest(unsigned char *digest, robj *o) {
  * will continue mixing this object digest to anything that was already
  * present. */
 void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
+    volatile int __A_VARIABLE;
     uint32_t aux = htonl(o->type);
     mixDigest(digest,&aux,sizeof(aux));
     long long expiretime = getExpire(db,keyobj);
@@ -247,6 +256,7 @@ void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o)
     }
     /* If the key has an expire, add it to the mix */
     if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
+    __A_VARIABLE = 1;
 }
 
 /* Compute the dataset digest. Since keys, sets elements, hashes elements
@@ -256,6 +266,7 @@ void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o)
  * as input in order to ensure that a different ordered list will result in
  * a different digest. */
 void computeDatasetDigest(unsigned char *final) {
+    volatile int __A_VARIABLE;
     unsigned char digest[20];
     dictIterator *di = NULL;
     dictEntry *de;
@@ -295,6 +306,7 @@ void computeDatasetDigest(unsigned char *final) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 void debugCommand(client *c) {
@@ -633,6 +645,7 @@ NULL
 /* =========================== Crash handling  ============================== */
 
 void _serverAssert(const char *estr, const char *file, int line) {
+    volatile int __A_VARIABLE;
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED ===");
     serverLog(LL_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
@@ -643,9 +656,11 @@ void _serverAssert(const char *estr, const char *file, int line) {
     serverLog(LL_WARNING,"(forcing SIGSEGV to print the bug report.)");
 #endif
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertPrintClientInfo(const client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     bugReportStart();
@@ -667,9 +682,11 @@ void _serverAssertPrintClientInfo(const client *c) {
         serverLog(LL_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
             j, arg, c->argv[j]->refcount);
     }
+    __A_VARIABLE = 1;
 }
 
 void serverLogObjectDebugInfo(const robj *o) {
+    volatile int __A_VARIABLE;
     serverLog(LL_WARNING,"Object type: %d", o->type);
     serverLog(LL_WARNING,"Object encoding: %d", o->encoding);
     serverLog(LL_WARNING,"Object refcount: %d", o->refcount);
@@ -691,21 +708,27 @@ void serverLogObjectDebugInfo(const robj *o) {
         if (o->encoding == OBJ_ENCODING_SKIPLIST)
             serverLog(LL_WARNING,"Skiplist level: %d", (int) ((const zset*)o->ptr)->zsl->level);
     }
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertPrintObject(const robj *o) {
+    volatile int __A_VARIABLE;
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
     serverLogObjectDebugInfo(o);
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
+    volatile int __A_VARIABLE;
     if (c) _serverAssertPrintClientInfo(c);
     if (o) _serverAssertPrintObject(o);
     _serverAssert(estr,file,line);
+    __A_VARIABLE = 1;
 }
 
 void _serverPanic(const char *file, int line, const char *msg, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     va_start(ap,msg);
     char fmtmsg[256];
@@ -721,14 +744,17 @@ void _serverPanic(const char *file, int line, const char *msg, ...) {
 #endif
     serverLog(LL_WARNING,"------------------------------------------------");
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 
 void bugReportStart(void) {
+    volatile int __A_VARIABLE;
     if (server.bug_report_start == 0) {
         serverLogRaw(LL_WARNING|LL_RAW,
         "\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n");
         server.bug_report_start = 1;
     }
+    __A_VARIABLE = 1;
 }
 
 #ifdef HAVE_BACKTRACE
@@ -784,6 +810,7 @@ static void *getMcontextEip(ucontext_t *uc) {
 }
 
 void logStackContent(void **sp) {
+    volatile int __A_VARIABLE;
     int i;
     for (i = 15; i >= 0; i--) {
         unsigned long addr = (unsigned long) sp+i;
@@ -794,9 +821,11 @@ void logStackContent(void **sp) {
         else
             serverLog(LL_WARNING, "(%016lx) -> %016lx", addr, val);
     }
+    __A_VARIABLE = 1;
 }
 
 void logRegisters(ucontext_t *uc) {
+    volatile int __A_VARIABLE;
     serverLog(LL_WARNING|LL_RAW, "\n------ REGISTERS ------\n");
 
 /* OSX */
@@ -1062,6 +1091,7 @@ void logRegisters(ucontext_t *uc) {
     serverLog(LL_WARNING,
         "  Dumping of registers not supported for this OS/arch");
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Return a file descriptor to write directly to the Redis log with the
@@ -1071,26 +1101,34 @@ void logRegisters(ucontext_t *uc) {
  *
  * Close it with closeDirectLogFiledes(). */
 int openDirectLogFiledes(void) {
+    volatile int __A_VARIABLE;
     int log_to_stdout = server.logfile[0] == '\0';
     int fd = log_to_stdout ?
         STDOUT_FILENO :
         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
+    __A_VARIABLE = 1;
     return fd;
 }
 
 /* Used to close what closeDirectLogFiledes() returns. */
 void closeDirectLogFiledes(int fd) {
+    volatile int __A_VARIABLE;
     int log_to_stdout = server.logfile[0] == '\0';
     if (!log_to_stdout) close(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Logs the stack trace using the backtrace() call. This function is designed
  * to be called from signal handlers safely. */
 void logStackTrace(ucontext_t *uc) {
+    volatile int __A_VARIABLE;
     void *trace[101];
     int trace_size = 0, fd = openDirectLogFiledes();
 
-    if (fd == -1) return; /* If we can't log there is anything to do. */
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    } /* If we can't log there is anything to do. */
 
     /* Generate the stack trace */
     trace_size = backtrace(trace+1, 100);
@@ -1109,13 +1147,18 @@ void logStackTrace(ucontext_t *uc) {
 
     /* Cleanup */
     closeDirectLogFiledes(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Log information about the "current" client, that is, the client that is
  * currently being served by Redis. May be NULL if Redis is not serving a
  * client right now. */
 void logCurrentClient(void) {
-    if (server.current_client == NULL) return;
+    volatile int __A_VARIABLE;
+    if (server.current_client == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     client *cc = server.current_client;
     sds client;
@@ -1148,6 +1191,7 @@ void logCurrentClient(void) {
         }
         decrRefCount(key);
     }
+    __A_VARIABLE = 1;
 }
 
 #if defined(HAVE_PROC_MAPS)
@@ -1156,6 +1200,7 @@ void logCurrentClient(void) {
 
 /* A non destructive memory test executed during segfauls. */
 int memtest_test_linux_anonymous_maps(void) {
+    volatile int __A_VARIABLE;
     FILE *fp;
     char line[1024];
     char logbuf[1024];
@@ -1165,10 +1210,16 @@ int memtest_test_linux_anonymous_maps(void) {
     int regions = 0, j;
 
     int fd = openDirectLogFiledes();
-    if (!fd) return 0;
+    if (!fd) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     fp = fopen("/proc/self/maps","r");
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     while(fgets(line,sizeof(line),fp) != NULL) {
         char *start, *end, *p = line;
 
@@ -1213,6 +1264,7 @@ int memtest_test_linux_anonymous_maps(void) {
      * region that we are testing. */
     fclose(fp);
     closeDirectLogFiledes(fd);
+    __A_VARIABLE = 1;
     return errors;
 }
 #endif
@@ -1221,6 +1273,7 @@ int memtest_test_linux_anonymous_maps(void) {
  * bytes, searching for E8 (callq) opcodes, and dumping the symbols
  * and the call offset if they appear to be valid. */
 void dumpX86Calls(void *addr, size_t len) {
+    volatile int __A_VARIABLE;
     size_t j;
     unsigned char *p = addr;
     Dl_info info;
@@ -1228,7 +1281,10 @@ void dumpX86Calls(void *addr, size_t len) {
      * multiple times. */
     unsigned long ht[256] = {0};
 
-    if (len < 5) return;
+    if (len < 5) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (j = 0; j < len-4; j++) {
         if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */
         unsigned long target = (unsigned long)addr+j+5;
@@ -1241,9 +1297,11 @@ void dumpX86Calls(void *addr, size_t len) {
             j += 4; /* Skip the 32 bit immediate. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
+    volatile int __A_VARIABLE;
     ucontext_t *uc = (ucontext_t*) secret;
     void *eip = getMcontextEip(uc);
     sds infostring, clients;
@@ -1344,12 +1402,14 @@ void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
     act.sa_handler = SIG_DFL;
     sigaction (sig, &act, NULL);
     kill(getpid(),sig);
+    __A_VARIABLE = 1;
 }
 #endif /* HAVE_BACKTRACE */
 
 /* ==================== Logging functions for debugging ===================== */
 
 void serverLogHexDump(int level, char *descr, void *value, size_t len) {
+    volatile int __A_VARIABLE;
     char buf[65], *b;
     unsigned char *v = value;
     char charset[] = "0123456789abcdef";
@@ -1369,12 +1429,14 @@ void serverLogHexDump(int level, char *descr, void *value, size_t len) {
         }
     }
     serverLogRaw(level|LL_RAW,"\n");
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Software Watchdog ============================ */
 #include <sys/time.h>
 
 void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
+    volatile int __A_VARIABLE;
 #ifdef HAVE_BACKTRACE
     ucontext_t *uc = (ucontext_t*) secret;
 #else
@@ -1390,12 +1452,14 @@ void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
     serverLogFromHandler(LL_WARNING,"Sorry: no support for backtrace().");
 #endif
     serverLogFromHandler(LL_WARNING,"--------\n");
+    __A_VARIABLE = 1;
 }
 
 /* Schedule a SIGALRM delivery after the specified period in milliseconds.
  * If a timer is already scheduled, this function will re-schedule it to the
  * specified time. If period is 0 the current timer is disabled. */
 void watchdogScheduleSignal(int period) {
+    volatile int __A_VARIABLE;
     struct itimerval it;
 
     /* Will stop the timer if period is 0. */
@@ -1405,10 +1469,12 @@ void watchdogScheduleSignal(int period) {
     it.it_interval.tv_sec = 0;
     it.it_interval.tv_usec = 0;
     setitimer(ITIMER_REAL, &it, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Enable the software watchdog with the specified period in milliseconds. */
 void enableWatchdog(int period) {
+    volatile int __A_VARIABLE;
     int min_period;
 
     if (server.watchdog_period == 0) {
@@ -1428,12 +1494,17 @@ void enableWatchdog(int period) {
     if (period < min_period) period = min_period;
     watchdogScheduleSignal(period); /* Adjust the current timer. */
     server.watchdog_period = period;
+    __A_VARIABLE = 1;
 }
 
 /* Disable the software watchdog. */
 void disableWatchdog(void) {
+    volatile int __A_VARIABLE;
     struct sigaction act;
-    if (server.watchdog_period == 0) return; /* Already disabled. */
+    if (server.watchdog_period == 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Already disabled. */
     watchdogScheduleSignal(0); /* Stop the current timer. */
 
     /* Set the signal handler to SIG_IGN, this will also remove pending
@@ -1443,4 +1514,5 @@ void disableWatchdog(void) {
     act.sa_handler = SIG_IGN;
     sigaction(SIGALRM, &act, NULL);
     server.watchdog_period = 0;
+    __A_VARIABLE = 1;
 }
diff --git a/src/defrag.c b/src/defrag.c
index ecf0255..c1dcf6e 100644
--- a/src/defrag.c
+++ b/src/defrag.c
@@ -55,11 +55,13 @@ dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sd
  * when it returns a non-null value, the old pointer was already released
  * and should NOT be accessed. */
 void* activeDefragAlloc(void *ptr) {
+    volatile int __A_VARIABLE;
     int bin_util, run_util;
     size_t size;
     void *newptr;
     if(!je_get_defrag_hint(ptr, &bin_util, &run_util)) {
         server.stat_active_defrag_misses++;
+        __A_VARIABLE = 1;
         return NULL;
     }
     /* if this run is more utilized than the average utilization in this bin
@@ -67,6 +69,7 @@ void* activeDefragAlloc(void *ptr) {
      * from relatively empty runs into relatively full runs. */
     if (run_util > bin_util || run_util == 1<<16) {
         server.stat_active_defrag_misses++;
+        __A_VARIABLE = 1;
         return NULL;
     }
     /* move this allocation to a new allocation.
@@ -76,6 +79,7 @@ void* activeDefragAlloc(void *ptr) {
     newptr = zmalloc_no_tcache(size);
     memcpy(newptr, ptr, size);
     zfree_no_tcache(ptr);
+    __A_VARIABLE = 1;
     return newptr;
 }
 
@@ -85,13 +89,16 @@ void* activeDefragAlloc(void *ptr) {
  * when it returns a non-null value, the old pointer was already released
  * and should NOT be accessed. */
 sds activeDefragSds(sds sdsptr) {
+    volatile int __A_VARIABLE;
     void* ptr = sdsAllocPtr(sdsptr);
     void* newptr = activeDefragAlloc(ptr);
     if (newptr) {
         size_t offset = sdsptr - (char*)ptr;
         sdsptr = (char*)newptr + offset;
+        __A_VARIABLE = 1;
         return sdsptr;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -101,9 +108,12 @@ sds activeDefragSds(sds sdsptr) {
  * when it returns a non-null value, the old pointer was already released
  * and should NOT be accessed. */
 robj *activeDefragStringOb(robj* ob, long *defragged) {
+    volatile int __A_VARIABLE;
     robj *ret = NULL;
-    if (ob->refcount!=1)
+    if (ob->refcount!=1) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     /* try to defrag robj (only if not an EMBSTR type (handled below). */
     if (ob->type!=OBJ_STRING || ob->encoding!=OBJ_ENCODING_EMBSTR) {
@@ -133,12 +143,14 @@ robj *activeDefragStringOb(robj* ob, long *defragged) {
             serverPanic("Unknown string encoding");
         }
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 
 /* Defrag helper for dictEntries to be used during dict iteration (called on
  * each step). Teturns a stat of how many pointers were moved. */
 long dictIterDefragEntry(dictIterator *iter) {
+    volatile int __A_VARIABLE;
     /* This function is a little bit dirty since it messes with the internals
      * of the dict and it's iterator, but the benefit is that it is very easy
      * to use, and require no other chagnes in the dict. */
@@ -164,6 +176,7 @@ long dictIterDefragEntry(dictIterator *iter) {
             defragged++;
         }
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -171,6 +184,7 @@ long dictIterDefragEntry(dictIterator *iter) {
  * receives a pointer to the dict* and implicitly updates it when the dict
  * struct itself was moved. Returns a stat of how many pointers were moved. */
 long dictDefragTables(dict* d) {
+    volatile int __A_VARIABLE;
     dictEntry **newtable;
     long defragged = 0;
     /* handle the first hash table */
@@ -183,11 +197,13 @@ long dictDefragTables(dict* d) {
         if (newtable)
             defragged++, d->ht[1].table = newtable;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 /* Internal function used by zslDefrag */
 void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **update) {
+    volatile int __A_VARIABLE;
     int i;
     for (i = 0; i < zsl->level; i++) {
         if (update[i]->level[i].forward == oldnode)
@@ -201,6 +217,7 @@ void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnod
         serverAssert(zsl->tail==oldnode);
         zsl->tail = newnode;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Defrag helper for sorted set.
@@ -211,6 +228,7 @@ void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnod
  * When return value is non-NULL, it is the score reference that must be updated
  * in the dict record. */
 double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x, *newx;
     int i;
     sds ele = newele? newele: oldele;
@@ -240,14 +258,17 @@ double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {
     newx = activeDefragAlloc(x);
     if (newx) {
         zslUpdateNode(zsl, x, newx, update);
+        __A_VARIABLE = 1;
         return &newx->score;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Defrag helpler for sorted set.
  * Defrag a single dict entry key name, and corresponding skiplist struct */
 long activeDefragZsetEntry(zset *zs, dictEntry *de) {
+    volatile int __A_VARIABLE;
     sds newsds;
     double* newscore;
     long defragged = 0;
@@ -259,6 +280,7 @@ long activeDefragZsetEntry(zset *zs, dictEntry *de) {
         dictSetVal(zs->dict, de, newscore);
         defragged++;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -269,6 +291,7 @@ long activeDefragZsetEntry(zset *zs, dictEntry *de) {
 
 /* Defrag a dict with sds key and optional value (either ptr, sds or robj string) */
 long activeDefragSdsDict(dict* d, int val_type) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     long defragged = 0;
@@ -294,11 +317,13 @@ long activeDefragSdsDict(dict* d, int val_type) {
         defragged += dictIterDefragEntry(di);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 /* Defrag a list of ptr, sds or robj string values */
 long activeDefragList(list *l, int val_type) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     listNode *ln, *newln;
     for (ln = l->head; ln; ln = ln->next) {
@@ -328,11 +353,13 @@ long activeDefragList(list *l, int val_type) {
                 ln->value = newptr, defragged++;
         }
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 /* Defrag a list of sds values and a dict with the same sds keys */
 long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     sds newsds, sdsele;
     listNode *ln, *newln;
@@ -382,6 +409,7 @@ long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
     }
     dictReleaseIterator(di);
 
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -393,6 +421,7 @@ long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
  * NOTE: this is very ugly code, but it let's us avoid the complication of
  * doing a scan on another dict. */
 dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, long *defragged) {
+    volatile int __A_VARIABLE;
     dictEntry **deref = dictFindEntryRefByPtrAndHash(d, oldkey, hash);
     if (deref) {
         dictEntry *de = *deref;
@@ -403,12 +432,15 @@ dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sd
         }
         if (newkey)
             de->key = newkey;
+        __A_VARIABLE = 1;
         return de;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 long activeDefragQuickListNodes(quicklist *ql) {
+    volatile int __A_VARIABLE;
     quicklistNode *node = ql->head, *newnode;
     long defragged = 0;
     unsigned char *newzl;
@@ -429,6 +461,7 @@ long activeDefragQuickListNodes(quicklist *ql) {
             defragged++, node->zl = newzl;
         node = node->next;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -436,15 +469,21 @@ long activeDefragQuickListNodes(quicklist *ql) {
  * oart of the main dictionary scan. this is needed in order to prevent latency
  * spikes when handling large items */
 void defragLater(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     sds key = sdsdup(dictGetKey(kde));
     listAddNodeTail(db->defrag_later, key);
+    __A_VARIABLE = 1;
 }
 
 long scanLaterList(robj *ob) {
+    volatile int __A_VARIABLE;
     quicklist *ql = ob->ptr;
-    if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST)
+    if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     server.stat_active_defrag_scanned+=ql->len;
+    __A_VARIABLE = 1;
     return activeDefragQuickListNodes(ql);
 }
 
@@ -454,41 +493,54 @@ typedef struct {
 } scanLaterZsetData;
 
 void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {
+    volatile int __A_VARIABLE;
     dictEntry *de = (dictEntry*)_de;
     scanLaterZsetData *data = privdata;
     data->defragged += activeDefragZsetEntry(data->zs, de);
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterZset(robj *ob, unsigned long *cursor) {
-    if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST)
+    volatile int __A_VARIABLE;
+    if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     zset *zs = (zset*)ob->ptr;
     dict *d = zs->dict;
     scanLaterZsetData data = {zs, 0};
     *cursor = dictScan(d, *cursor, scanLaterZsetCallback, defragDictBucketCallback, &data);
+    __A_VARIABLE = 1;
     return data.defragged;
 }
 
 void scanLaterSetCallback(void *privdata, const dictEntry *_de) {
+    volatile int __A_VARIABLE;
     dictEntry *de = (dictEntry*)_de;
     long *defragged = privdata;
     sds sdsele = dictGetKey(de), newsds;
     if ((newsds = activeDefragSds(sdsele)))
         (*defragged)++, de->key = newsds;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterSet(robj *ob, unsigned long *cursor) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
-    if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT)
+    if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     dict *d = ob->ptr;
     *cursor = dictScan(d, *cursor, scanLaterSetCallback, defragDictBucketCallback, &defragged);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 void scanLaterHashCallback(void *privdata, const dictEntry *_de) {
+    volatile int __A_VARIABLE;
     dictEntry *de = (dictEntry*)_de;
     long *defragged = privdata;
     sds sdsele = dictGetKey(de), newsds;
@@ -498,18 +550,24 @@ void scanLaterHashCallback(void *privdata, const dictEntry *_de) {
     if ((newsds = activeDefragSds(sdsele)))
         (*defragged)++, de->v.val = newsds;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterHash(robj *ob, unsigned long *cursor) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
-    if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT)
+    if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     dict *d = ob->ptr;
     *cursor = dictScan(d, *cursor, scanLaterHashCallback, defragDictBucketCallback, &defragged);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 long defragQuicklist(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     robj *ob = dictGetVal(kde);
     long defragged = 0;
     quicklist *ql = ob->ptr, *newql;
@@ -520,10 +578,12 @@ long defragQuicklist(redisDb *db, dictEntry *kde) {
         defragLater(db, kde);
     else
         defragged += activeDefragQuickListNodes(ql);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 long defragZsetSkiplist(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     robj *ob = dictGetVal(kde);
     long defragged = 0;
     zset *zs = (zset*)ob->ptr;
@@ -553,10 +613,12 @@ long defragZsetSkiplist(redisDb *db, dictEntry *kde) {
         defragged++, zs->dict = newdict;
     /* defrag the dict tables */
     defragged += dictDefragTables(zs->dict);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 long defragHash(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     robj *ob = dictGetVal(kde);
     dict *d, *newd;
@@ -571,10 +633,12 @@ long defragHash(redisDb *db, dictEntry *kde) {
         defragged++, ob->ptr = newd;
     /* defrag the dict tables */
     defragged += dictDefragTables(ob->ptr);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 long defragSet(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     robj *ob = dictGetVal(kde);
     dict *d, *newd;
@@ -589,17 +653,21 @@ long defragSet(redisDb *db, dictEntry *kde) {
         defragged++, ob->ptr = newd;
     /* defrag the dict tables */
     defragged += dictDefragTables(ob->ptr);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 /* Defrag callback for radix tree iterator, called for each node,
  * used in order to defrag the nodes allocations. */
 int defragRaxNode(raxNode **noderef) {
+    volatile int __A_VARIABLE;
     raxNode *newnode = activeDefragAlloc(*noderef);
     if (newnode) {
         *noderef = newnode;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -662,6 +730,7 @@ typedef void *(raxDefragFunction)(raxIterator *ri, void *privdata, long *defragg
  * 3) rax entry data (only if defrag_data is specified)
  * 4) call a callback per element, and allow the callback to return a new pointer for the element */
 long defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_cb, void *element_cb_data) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     raxIterator ri;
     rax* rax;
@@ -682,6 +751,7 @@ long defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_c
             raxSetData(ri.node, ri.data=newdata), defragged++;
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -691,6 +761,7 @@ typedef struct {
 } PendingEntryContext;
 
 void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, long *defragged) {
+    volatile int __A_VARIABLE;
     UNUSED(defragged);
     PendingEntryContext *ctx = privdata;
     streamNACK *nack = ri->data, *newnack;
@@ -703,10 +774,12 @@ void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, long *de
         serverAssert(prev==nack);
         /* note: we don't increment 'defragged' that's done by the caller */
     }
+    __A_VARIABLE = 1;
     return newnack;
 }
 
 void* defragStreamConsumer(raxIterator *ri, void *privdata, long *defragged) {
+    volatile int __A_VARIABLE;
     streamConsumer *c = ri->data;
     streamCG *cg = privdata;
     void *newc = activeDefragAlloc(c);
@@ -721,20 +794,24 @@ void* defragStreamConsumer(raxIterator *ri, void *privdata, long *defragged) {
         PendingEntryContext pel_ctx = {cg, c};
         *defragged += defragRadixTree(&c->pel, 0, defragStreamConsumerPendingEntry, &pel_ctx);
     }
+    __A_VARIABLE = 1;
     return newc; /* returns NULL if c was not defragged */
 }
 
 void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, long *defragged) {
+    volatile int __A_VARIABLE;
     streamCG *cg = ri->data;
     UNUSED(privdata);
     if (cg->consumers)
         *defragged += defragRadixTree(&cg->consumers, 0, defragStreamConsumer, cg);
     if (cg->pel)
         *defragged += defragRadixTree(&cg->pel, 0, NULL, NULL);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 long defragStream(redisDb *db, dictEntry *kde) {
+    volatile int __A_VARIABLE;
     long defragged = 0;
     robj *ob = dictGetVal(kde);
     serverAssert(ob->type == OBJ_STREAM && ob->encoding == OBJ_ENCODING_STREAM);
@@ -754,6 +831,7 @@ long defragStream(redisDb *db, dictEntry *kde) {
 
     if (s->cgroups)
         defragged += defragRadixTree(&s->cgroups, 1, defragStreamConsumerGroup, NULL);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -761,6 +839,7 @@ long defragStream(redisDb *db, dictEntry *kde) {
  * all the various pointers it has. Returns a stat of how many pointers were
  * moved. */
 long defragKey(redisDb *db, dictEntry *de) {
+    volatile int __A_VARIABLE;
     sds keysds = dictGetKey(de);
     robj *newob, *ob;
     unsigned char *newzl;
@@ -833,11 +912,13 @@ long defragKey(redisDb *db, dictEntry *de) {
     } else {
         serverPanic("Unknown object type");
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
 /* Defrag scan callback for the main db dictionary. */
 void defragScanCallback(void *privdata, const dictEntry *de) {
+    volatile int __A_VARIABLE;
     long defragged = defragKey((redisDb*)privdata, (dictEntry*)de);
     server.stat_active_defrag_hits += defragged;
     if(defragged)
@@ -845,11 +926,13 @@ void defragScanCallback(void *privdata, const dictEntry *de) {
     else
         server.stat_active_defrag_key_misses++;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 /* Defrag scan callback for each hash table bicket,
  * used in order to defrag the dictEntry allocations. */
 void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
+    volatile int __A_VARIABLE;
     UNUSED(privdata); /* NOTE: this function is also used by both activeDefragCycle and scanLaterHash, etc. don't use privdata */
     while(*bucketref) {
         dictEntry *de = *bucketref, *newde;
@@ -858,6 +941,7 @@ void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
         }
         bucketref = &(*bucketref)->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Utility function to get the fragmentation ratio from jemalloc.
@@ -867,6 +951,7 @@ void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
  * or not, a false detection can cause the defragmenter to waste a lot of CPU
  * without the possibility of getting any results. */
 float getAllocatorFragmentation(size_t *out_frag_bytes) {
+    volatile int __A_VARIABLE;
     size_t resident, active, allocated;
     zmalloc_get_allocator_info(&allocated, &active, &resident);
     float frag_pct = ((float)active / allocated)*100 - 100;
@@ -878,12 +963,14 @@ float getAllocatorFragmentation(size_t *out_frag_bytes) {
     serverLog(LL_DEBUG,
         "allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag_bytes=%zu (%zu rss)",
         allocated, active, resident, frag_pct, rss_pct, frag_bytes, rss_bytes);
+    __A_VARIABLE = 1;
     return frag_pct;
 }
 
 /* We may need to defrag other globals, one small allcation can hold a full allocator run.
  * so although small, it is still important to defrag these */
 long defragOtherGlobals() {
+    volatile int __A_VARIABLE;
     long defragged = 0;
 
     /* there are many more pointers to defrag (e.g. client argv, output / aof buffers, etc.
@@ -891,6 +978,7 @@ long defragOtherGlobals() {
      * that remain static for a long time */
     defragged += activeDefragSdsDict(server.lua_scripts, DEFRAG_SDS_DICT_VAL_IS_STROB);
     defragged += activeDefragSdsListAndDict(server.repl_scriptcache_fifo, server.repl_scriptcache_dict, DEFRAG_SDS_DICT_NO_VAL);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -921,6 +1009,7 @@ int defragLaterItem(dictEntry *de, unsigned long *cursor, long long endtime) {
 
 /* returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed. */
 int defragLaterStep(redisDb *db, long long endtime) {
+    volatile int __A_VARIABLE;
     static sds current_key = NULL;
     static unsigned long cursor = 0;
     unsigned int iterations = 0;
@@ -944,8 +1033,10 @@ int defragLaterStep(redisDb *db, long long endtime) {
 
             /* stop if we reached the last one. */
             head = listFirst(db->defrag_later);
-            if (!head)
+            if (!head) {
+                __A_VARIABLE = 1;
                 return 0;
+            }
 
             /* start a new key */
             current_key = head->value;
@@ -976,6 +1067,7 @@ int defragLaterStep(redisDb *db, long long endtime) {
                         server.stat_active_defrag_key_hits++;
                     else
                         server.stat_active_defrag_key_misses++;
+                    __A_VARIABLE = 1;
                     return 1;
                 }
                 iterations = 0;
@@ -988,6 +1080,7 @@ int defragLaterStep(redisDb *db, long long endtime) {
         else
             server.stat_active_defrag_key_misses++;
     } while(1);
+    __A_VARIABLE = 1;
 }
 
 #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
@@ -995,12 +1088,15 @@ int defragLaterStep(redisDb *db, long long endtime) {
 
 /* decide if defrag is needed, and at what CPU effort to invest in it */
 void computeDefragCycles() {
+    volatile int __A_VARIABLE;
     size_t frag_bytes;
     float frag_pct = getAllocatorFragmentation(&frag_bytes);
     /* If we're not already running, and below the threshold, exit. */
     if (!server.active_defrag_running) {
-        if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes)
+        if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     /* Calculate the adaptive aggressiveness of the defrag */
@@ -1022,6 +1118,7 @@ void computeDefragCycles() {
             "Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%",
             frag_pct, frag_bytes, cpu_pct);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Perform incremental defragmentation work from the serverCron.
@@ -1134,7 +1231,9 @@ void activeDefragCycle(void) {
 #else /* HAVE_DEFRAG */
 
 void activeDefragCycle(void) {
+	volatile int __A_VARIABLE;
     /* Not implemented yet. */
+	__A_VARIABLE = 1;
 }
 
 #endif
diff --git a/src/dict.c b/src/dict.c
index 2cf9d48..b9ce0a1 100644
--- a/src/dict.c
+++ b/src/dict.c
@@ -74,10 +74,14 @@ static int _dictInit(dict *ht, dictType *type, void *privDataPtr);
 static uint8_t dict_hash_function_seed[16];
 
 void dictSetHashFunctionSeed(uint8_t *seed) {
+    volatile int __A_VARIABLE;
     memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
+    __A_VARIABLE = 1;
 }
 
 uint8_t *dictGetHashFunctionSeed(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dict_hash_function_seed;
 }
 
@@ -88,10 +92,14 @@ uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);
 uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);
 
 uint64_t dictGenHashFunction(const void *key, int len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return siphash(key,len,dict_hash_function_seed);
 }
 
 uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return siphash_nocase(buf,len,dict_hash_function_seed);
 }
 
@@ -101,19 +109,23 @@ uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {
  * NOTE: This function should only be called by ht_destroy(). */
 static void _dictReset(dictht *ht)
 {
+    volatile int __A_VARIABLE;
     ht->table = NULL;
     ht->size = 0;
     ht->sizemask = 0;
     ht->used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Create a new hash table */
 dict *dictCreate(dictType *type,
         void *privDataPtr)
 {
+    volatile int __A_VARIABLE;
     dict *d = zmalloc(sizeof(*d));
 
     _dictInit(d,type,privDataPtr);
+    __A_VARIABLE = 1;
     return d;
 }
 
@@ -121,12 +133,14 @@ dict *dictCreate(dictType *type,
 int _dictInit(dict *d, dictType *type,
         void *privDataPtr)
 {
+    volatile int __A_VARIABLE;
     _dictReset(&d->ht[0]);
     _dictReset(&d->ht[1]);
     d->type = type;
     d->privdata = privDataPtr;
     d->rehashidx = -1;
     d->iterators = 0;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -134,28 +148,39 @@ int _dictInit(dict *d, dictType *type,
  * but with the invariant of a USED/BUCKETS ratio near to <= 1 */
 int dictResize(dict *d)
 {
+    volatile int __A_VARIABLE;
     int minimal;
 
-    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
+    if (!dict_can_resize || dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
     minimal = d->ht[0].used;
     if (minimal < DICT_HT_INITIAL_SIZE)
         minimal = DICT_HT_INITIAL_SIZE;
+    __A_VARIABLE = 1;
     return dictExpand(d, minimal);
 }
 
 /* Expand or create the hash table */
 int dictExpand(dict *d, unsigned long size)
 {
+    volatile int __A_VARIABLE;
     /* the size is invalid if it is smaller than the number of
      * elements already inside the hash table */
-    if (dictIsRehashing(d) || d->ht[0].used > size)
+    if (dictIsRehashing(d) || d->ht[0].used > size) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     dictht n; /* the new hash table */
     unsigned long realsize = _dictNextPower(size);
 
     /* Rehashing to the same table size is not useful. */
-    if (realsize == d->ht[0].size) return DICT_ERR;
+    if (realsize == d->ht[0].size) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
 
     /* Allocate the new hash table and initialize all pointers to NULL */
     n.size = realsize;
@@ -167,12 +192,14 @@ int dictExpand(dict *d, unsigned long size)
      * we just set the first hash table so that it can accept keys. */
     if (d->ht[0].table == NULL) {
         d->ht[0] = n;
+        __A_VARIABLE = 1;
         return DICT_OK;
     }
 
     /* Prepare a second hash table for incremental rehashing */
     d->ht[1] = n;
     d->rehashidx = 0;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -186,8 +213,12 @@ int dictExpand(dict *d, unsigned long size)
  * will visit at max N*10 empty buckets in total, otherwise the amount of
  * work it does would be unbound and the function may block for a long time. */
 int dictRehash(dict *d, int n) {
+    volatile int __A_VARIABLE;
     int empty_visits = n*10; /* Max number of empty buckets to visit. */
-    if (!dictIsRehashing(d)) return 0;
+    if (!dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     while(n-- && d->ht[0].used != 0) {
         dictEntry *de, *nextde;
@@ -197,7 +228,10 @@ int dictRehash(dict *d, int n) {
         assert(d->ht[0].size > (unsigned long)d->rehashidx);
         while(d->ht[0].table[d->rehashidx] == NULL) {
             d->rehashidx++;
-            if (--empty_visits == 0) return 1;
+            if (--empty_visits == 0) {
+                __A_VARIABLE = 1;
+                return 1;
+            }
         }
         de = d->ht[0].table[d->rehashidx];
         /* Move all the keys in this bucket from the old to the new hash HT */
@@ -223,22 +257,27 @@ int dictRehash(dict *d, int n) {
         d->ht[0] = d->ht[1];
         _dictReset(&d->ht[1]);
         d->rehashidx = -1;
+        __A_VARIABLE = 1;
         return 0;
     }
 
     /* More to rehash... */
+    __A_VARIABLE = 1;
     return 1;
 }
 
 long long timeInMilliseconds(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
 
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
 }
 
 /* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */
 int dictRehashMilliseconds(dict *d, int ms) {
+    volatile int __A_VARIABLE;
     long long start = timeInMilliseconds();
     int rehashes = 0;
 
@@ -246,6 +285,7 @@ int dictRehashMilliseconds(dict *d, int ms) {
         rehashes += 100;
         if (timeInMilliseconds()-start > ms) break;
     }
+    __A_VARIABLE = 1;
     return rehashes;
 }
 
@@ -258,16 +298,23 @@ int dictRehashMilliseconds(dict *d, int ms) {
  * dictionary so that the hash table automatically migrates from H1 to H2
  * while it is actively used. */
 static void _dictRehashStep(dict *d) {
+    volatile int __A_VARIABLE;
     if (d->iterators == 0) dictRehash(d,1);
+    __A_VARIABLE = 1;
 }
 
 /* Add an element to the target hash table */
 int dictAdd(dict *d, void *key, void *val)
 {
+    volatile int __A_VARIABLE;
     dictEntry *entry = dictAddRaw(d,key,NULL);
 
-    if (!entry) return DICT_ERR;
+    if (!entry) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
     dictSetVal(d, entry, val);
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -291,6 +338,7 @@ int dictAdd(dict *d, void *key, void *val)
  */
 dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 {
+    volatile int __A_VARIABLE;
     long index;
     dictEntry *entry;
     dictht *ht;
@@ -299,8 +347,10 @@ dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
+    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     /* Allocate the memory and store the new entry.
      * Insert the element in top, with the assumption that in a database
@@ -314,6 +364,7 @@ dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 
     /* Set the hash entry fields. */
     dictSetKey(d, entry, key);
+    __A_VARIABLE = 1;
     return entry;
 }
 
@@ -324,6 +375,7 @@ dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
  * operation. */
 int dictReplace(dict *d, void *key, void *val)
 {
+    volatile int __A_VARIABLE;
     dictEntry *entry, *existing, auxentry;
 
     /* Try to add the element. If the key
@@ -331,6 +383,7 @@ int dictReplace(dict *d, void *key, void *val)
     entry = dictAddRaw(d,key,&existing);
     if (entry) {
         dictSetVal(d, entry, val);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -342,6 +395,7 @@ int dictReplace(dict *d, void *key, void *val)
     auxentry = *existing;
     dictSetVal(d, existing, val);
     dictFreeVal(d, &auxentry);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -353,8 +407,10 @@ int dictReplace(dict *d, void *key, void *val)
  *
  * See dictAddRaw() for more information. */
 dictEntry *dictAddOrFind(dict *d, void *key) {
+    volatile int __A_VARIABLE;
     dictEntry *entry, *existing;
     entry = dictAddRaw(d,key,&existing);
+    __A_VARIABLE = 1;
     return entry ? entry : existing;
 }
 
@@ -362,11 +418,15 @@ dictEntry *dictAddOrFind(dict *d, void *key) {
  * dictDelete() and dictUnlink(), please check the top comment
  * of those functions. */
 static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
+    volatile int __A_VARIABLE;
     uint64_t h, idx;
     dictEntry *he, *prevHe;
     int table;
 
-    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
+    if (d->ht[0].used == 0 && d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
@@ -388,6 +448,7 @@ static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
                     zfree(he);
                 }
                 d->ht[table].used--;
+                __A_VARIABLE = 1;
                 return he;
             }
             prevHe = he;
@@ -395,12 +456,15 @@ static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
         }
         if (!dictIsRehashing(d)) break;
     }
+    __A_VARIABLE = 1;
     return NULL; /* not found */
 }
 
 /* Remove an element, returning DICT_OK on success or DICT_ERR if the
  * element was not found. */
 int dictDelete(dict *ht, const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
 }
 
@@ -426,20 +490,28 @@ int dictDelete(dict *ht, const void *key) {
  * dictFreeUnlinkedEntry(entry); // <- This does not need to lookup again.
  */
 dictEntry *dictUnlink(dict *ht, const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenericDelete(ht,key,1);
 }
 
 /* You need to call this function to really free the entry after a call
  * to dictUnlink(). It's safe to call this function with 'he' = NULL. */
 void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
-    if (he == NULL) return;
+    volatile int __A_VARIABLE;
+    if (he == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     dictFreeKey(d, he);
     dictFreeVal(d, he);
     zfree(he);
+    __A_VARIABLE = 1;
 }
 
 /* Destroy an entire dictionary */
 int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {
+    volatile int __A_VARIABLE;
     unsigned long i;
 
     /* Free all the elements */
@@ -462,42 +534,57 @@ int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {
     zfree(ht->table);
     /* Re-initialize the table */
     _dictReset(ht);
+    __A_VARIABLE = 1;
     return DICT_OK; /* never fails */
 }
 
 /* Clear & Release the hash table */
 void dictRelease(dict *d)
 {
+    volatile int __A_VARIABLE;
     _dictClear(d,&d->ht[0],NULL);
     _dictClear(d,&d->ht[1],NULL);
     zfree(d);
+    __A_VARIABLE = 1;
 }
 
 dictEntry *dictFind(dict *d, const void *key)
 {
+    volatile int __A_VARIABLE;
     dictEntry *he;
     uint64_t h, idx, table;
 
-    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
+    if (d->ht[0].used + d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    } /* dict is empty */
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         he = d->ht[table].table[idx];
         while(he) {
-            if (key==he->key || dictCompareKeys(d, key, he->key))
+            if (key==he->key || dictCompareKeys(d, key, he->key)) {
+                __A_VARIABLE = 1;
                 return he;
+            }
             he = he->next;
         }
-        if (!dictIsRehashing(d)) return NULL;
+        if (!dictIsRehashing(d)) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 void *dictFetchValue(dict *d, const void *key) {
+    volatile int __A_VARIABLE;
     dictEntry *he;
 
     he = dictFind(d,key);
+    __A_VARIABLE = 1;
     return he ? dictGetVal(he) : NULL;
 }
 
@@ -508,6 +595,7 @@ void *dictFetchValue(dict *d, const void *key) {
  * If the two fingerprints are different it means that the user of the iterator
  * performed forbidden operations against the dictionary while iterating. */
 long long dictFingerprint(dict *d) {
+    volatile int __A_VARIABLE;
     long long integers[6], hash = 0;
     int j;
 
@@ -536,11 +624,13 @@ long long dictFingerprint(dict *d) {
         hash = hash ^ (hash >> 28);
         hash = hash + (hash << 31);
     }
+    __A_VARIABLE = 1;
     return hash;
 }
 
 dictIterator *dictGetIterator(dict *d)
 {
+    volatile int __A_VARIABLE;
     dictIterator *iter = zmalloc(sizeof(*iter));
 
     iter->d = d;
@@ -549,18 +639,22 @@ dictIterator *dictGetIterator(dict *d)
     iter->safe = 0;
     iter->entry = NULL;
     iter->nextEntry = NULL;
+    __A_VARIABLE = 1;
     return iter;
 }
 
 dictIterator *dictGetSafeIterator(dict *d) {
+    volatile int __A_VARIABLE;
     dictIterator *i = dictGetIterator(d);
 
     i->safe = 1;
+    __A_VARIABLE = 1;
     return i;
 }
 
 dictEntry *dictNext(dictIterator *iter)
 {
+    volatile int __A_VARIABLE;
     while (1) {
         if (iter->entry == NULL) {
             dictht *ht = &iter->d->ht[iter->table];
@@ -588,14 +682,17 @@ dictEntry *dictNext(dictIterator *iter)
             /* We need to save the 'next' here, the iterator user
              * may delete the entry we are returning. */
             iter->nextEntry = iter->entry->next;
+            __A_VARIABLE = 1;
             return iter->entry;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 void dictReleaseIterator(dictIterator *iter)
 {
+    volatile int __A_VARIABLE;
     if (!(iter->index == -1 && iter->table == 0)) {
         if (iter->safe)
             iter->d->iterators--;
@@ -603,17 +700,22 @@ void dictReleaseIterator(dictIterator *iter)
             assert(iter->fingerprint == dictFingerprint(iter->d));
     }
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Return a random entry from the hash table. Useful to
  * implement randomized algorithms */
 dictEntry *dictGetRandomKey(dict *d)
 {
+    volatile int __A_VARIABLE;
     dictEntry *he, *orighe;
     unsigned long h;
     int listlen, listele;
 
-    if (dictSize(d) == 0) return NULL;
+    if (dictSize(d) == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (dictIsRehashing(d)) _dictRehashStep(d);
     if (dictIsRehashing(d)) {
         do {
@@ -645,6 +747,7 @@ dictEntry *dictGetRandomKey(dict *d)
     listele = random() % listlen;
     he = orighe;
     while(listele--) he = he->next;
+    __A_VARIABLE = 1;
     return he;
 }
 
@@ -742,12 +845,14 @@ unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
 /* Function to reverse bits. Algorithm from:
  * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */
 static unsigned long rev(unsigned long v) {
+    volatile int __A_VARIABLE;
     unsigned long s = 8 * sizeof(v); // bit size; must be power of 2
     unsigned long mask = ~0;
     while ((s >>= 1) > 0) {
         mask ^= (mask << s);
         v = ((v >> s) & mask) | ((v << s) & ~mask);
     }
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -841,11 +946,15 @@ unsigned long dictScan(dict *d,
                        dictScanBucketFunction* bucketfn,
                        void *privdata)
 {
+    volatile int __A_VARIABLE;
     dictht *t0, *t1;
     const dictEntry *de, *next;
     unsigned long m0, m1;
 
-    if (dictSize(d) == 0) return 0;
+    if (dictSize(d) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     if (!dictIsRehashing(d)) {
         t0 = &(d->ht[0]);
@@ -913,6 +1022,7 @@ unsigned long dictScan(dict *d,
         } while (v & (m0 ^ m1));
     }
 
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -921,11 +1031,18 @@ unsigned long dictScan(dict *d,
 /* Expand the hash table if needed */
 static int _dictExpandIfNeeded(dict *d)
 {
+    volatile int __A_VARIABLE;
     /* Incremental rehashing already in progress. Return. */
-    if (dictIsRehashing(d)) return DICT_OK;
+    if (dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return DICT_OK;
+    }
 
     /* If the hash table is empty expand it to the initial size. */
-    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);
+    if (d->ht[0].size == 0) {
+        __A_VARIABLE = 1;
+        return dictExpand(d, DICT_HT_INITIAL_SIZE);
+    }
 
     /* If we reached the 1:1 ratio, and we are allowed to resize the hash
      * table (global setting) or we should avoid it but the ratio between
@@ -935,22 +1052,31 @@ static int _dictExpandIfNeeded(dict *d)
         (dict_can_resize ||
          d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
     {
+        __A_VARIABLE = 1;
         return dictExpand(d, d->ht[0].used*2);
     }
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
 /* Our hash table capability is a power of two */
 static unsigned long _dictNextPower(unsigned long size)
 {
+    volatile int __A_VARIABLE;
     unsigned long i = DICT_HT_INITIAL_SIZE;
 
-    if (size >= LONG_MAX) return LONG_MAX + 1LU;
+    if (size >= LONG_MAX) {
+        __A_VARIABLE = 1;
+        return LONG_MAX + 1LU;
+    }
     while(1) {
-        if (i >= size)
+        if (i >= size) {
+            __A_VARIABLE = 1;
             return i;
+        }
         i *= 2;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Returns the index of a free slot that can be populated with
@@ -962,13 +1088,16 @@ static unsigned long _dictNextPower(unsigned long size)
  * index is always returned in the context of the second (new) hash table. */
 static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)
 {
+    volatile int __A_VARIABLE;
     unsigned long idx, table;
     dictEntry *he;
     if (existing) *existing = NULL;
 
     /* Expand the hash table if needed */
-    if (_dictExpandIfNeeded(d) == DICT_ERR)
+    if (_dictExpandIfNeeded(d) == DICT_ERR) {
+        __A_VARIABLE = 1;
         return -1;
+    }
     for (table = 0; table <= 1; table++) {
         idx = hash & d->ht[table].sizemask;
         /* Search if this slot does not already contain the given key */
@@ -976,31 +1105,41 @@ static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **e
         while(he) {
             if (key==he->key || dictCompareKeys(d, key, he->key)) {
                 if (existing) *existing = he;
+                __A_VARIABLE = 1;
                 return -1;
             }
             he = he->next;
         }
         if (!dictIsRehashing(d)) break;
     }
+    __A_VARIABLE = 1;
     return idx;
 }
 
 void dictEmpty(dict *d, void(callback)(void*)) {
+    volatile int __A_VARIABLE;
     _dictClear(d,&d->ht[0],callback);
     _dictClear(d,&d->ht[1],callback);
     d->rehashidx = -1;
     d->iterators = 0;
+    __A_VARIABLE = 1;
 }
 
 void dictEnableResize(void) {
+    volatile int __A_VARIABLE;
     dict_can_resize = 1;
+    __A_VARIABLE = 1;
 }
 
 void dictDisableResize(void) {
+    volatile int __A_VARIABLE;
     dict_can_resize = 0;
+    __A_VARIABLE = 1;
 }
 
 uint64_t dictGetHash(dict *d, const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictHashKey(d, key);
 }
 
@@ -1010,22 +1149,32 @@ uint64_t dictGetHash(dict *d, const void *key) {
  * no string / key comparison is performed.
  * return value is the reference to the dictEntry if found, or NULL if not found. */
 dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {
+    volatile int __A_VARIABLE;
     dictEntry *he, **heref;
     unsigned long idx, table;
 
-    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
+    if (d->ht[0].used + d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    } /* dict is empty */
     for (table = 0; table <= 1; table++) {
         idx = hash & d->ht[table].sizemask;
         heref = &d->ht[table].table[idx];
         he = *heref;
         while(he) {
-            if (oldptr==he->key)
+            if (oldptr==he->key) {
+                __A_VARIABLE = 1;
                 return heref;
+            }
             heref = &he->next;
             he = *heref;
         }
-        if (!dictIsRehashing(d)) return NULL;
+        if (!dictIsRehashing(d)) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1033,12 +1182,14 @@ dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t h
 
 #define DICT_STATS_VECTLEN 50
 size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
+    volatile int __A_VARIABLE;
     unsigned long i, slots = 0, chainlen, maxchainlen = 0;
     unsigned long totchainlen = 0;
     unsigned long clvector[DICT_STATS_VECTLEN];
     size_t l = 0;
 
     if (ht->used == 0) {
+        __A_VARIABLE = 1;
         return snprintf(buf,bufsize,
             "No stats available for empty dictionaries\n");
     }
@@ -1090,10 +1241,12 @@ size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
 
     /* Unlike snprintf(), teturn the number of characters actually written. */
     if (bufsize) buf[bufsize-1] = '\0';
+    __A_VARIABLE = 1;
     return strlen(buf);
 }
 
 void dictGetStats(char *buf, size_t bufsize, dict *d) {
+    volatile int __A_VARIABLE;
     size_t l;
     char *orig_buf = buf;
     size_t orig_bufsize = bufsize;
@@ -1106,6 +1259,7 @@ void dictGetStats(char *buf, size_t bufsize, dict *d) {
     }
     /* Make sure there is a NULL term at the end. */
     if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------------- Benchmark ---------------------------------*/
@@ -1115,23 +1269,32 @@ void dictGetStats(char *buf, size_t bufsize, dict *d) {
 #include "sds.h"
 
 uint64_t hashCallback(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 int compareCallback(void *privdata, const void *key1, const void *key2) {
+    volatile int __A_VARIABLE;
     int l1,l2;
     DICT_NOTUSED(privdata);
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
 void freeCallback(void *privdata, void *val) {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
 
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 dictType BenchmarkDictType = {
@@ -1151,6 +1314,7 @@ dictType BenchmarkDictType = {
 
 /* dict-benchmark [count] */
 int main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     long j;
     long long start, elapsed;
     dict *dict = dictCreate(&BenchmarkDictType,NULL);
@@ -1222,5 +1386,6 @@ int main(int argc, char **argv) {
         assert(retval == DICT_OK);
     }
     end_benchmark("Removing and adding");
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/src/endianconv.c b/src/endianconv.c
index f3b0b47..5814ed9 100644
--- a/src/endianconv.c
+++ b/src/endianconv.c
@@ -47,16 +47,19 @@
 /* Toggle the 16 bit unsigned integer pointed by *p from little endian to
  * big endian */
 void memrev16(void *p) {
+    volatile int __A_VARIABLE;
     unsigned char *x = p, t;
 
     t = x[0];
     x[0] = x[1];
     x[1] = t;
+    __A_VARIABLE = 1;
 }
 
 /* Toggle the 32 bit unsigned integer pointed by *p from little endian to
  * big endian */
 void memrev32(void *p) {
+    volatile int __A_VARIABLE;
     unsigned char *x = p, t;
 
     t = x[0];
@@ -65,11 +68,13 @@ void memrev32(void *p) {
     t = x[1];
     x[1] = x[2];
     x[2] = t;
+    __A_VARIABLE = 1;
 }
 
 /* Toggle the 64 bit unsigned integer pointed by *p from little endian to
  * big endian */
 void memrev64(void *p) {
+    volatile int __A_VARIABLE;
     unsigned char *x = p, t;
 
     t = x[0];
@@ -84,20 +89,27 @@ void memrev64(void *p) {
     t = x[3];
     x[3] = x[4];
     x[4] = t;
+    __A_VARIABLE = 1;
 }
 
 uint16_t intrev16(uint16_t v) {
+    volatile int __A_VARIABLE;
     memrev16(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
 uint32_t intrev32(uint32_t v) {
+    volatile int __A_VARIABLE;
     memrev32(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
 uint64_t intrev64(uint64_t v) {
+    volatile int __A_VARIABLE;
     memrev64(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -106,6 +118,7 @@ uint64_t intrev64(uint64_t v) {
 
 #define UNUSED(x) (void)(x)
 int endianconvTest(int argc, char *argv[]) {
+    volatile int __A_VARIABLE;
     char buf[32];
 
     UNUSED(argc);
@@ -123,6 +136,7 @@ int endianconvTest(int argc, char *argv[]) {
     memrev64(buf);
     printf("%s\n", buf);
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/evict.c b/src/evict.c
index 773916c..8a7ba21 100644
--- a/src/evict.c
+++ b/src/evict.c
@@ -68,6 +68,8 @@ static struct evictionPoolEntry *EvictionPoolLRU;
  * in a reduced-bits format that can be used to set and check the
  * object->lru field of redisObject structures. */
 unsigned int getLRUClock(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
 }
 
@@ -76,12 +78,14 @@ unsigned int getLRUClock(void) {
  * LRU clock (as it should be in production servers) we return the
  * precomputed value, otherwise we need to resort to a system call. */
 unsigned int LRU_CLOCK(void) {
+    volatile int __A_VARIABLE;
     unsigned int lruclock;
     if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {
         atomicGet(server.lruclock,lruclock);
     } else {
         lruclock = getLRUClock();
     }
+    __A_VARIABLE = 1;
     return lruclock;
 }
 
@@ -137,6 +141,7 @@ unsigned long long estimateObjectIdleTime(robj *o) {
 
 /* Create a new eviction pool. */
 void evictionPoolAlloc(void) {
+    volatile int __A_VARIABLE;
     struct evictionPoolEntry *ep;
     int j;
 
@@ -148,6 +153,7 @@ void evictionPoolAlloc(void) {
         ep[j].dbid = 0;
     }
     EvictionPoolLRU = ep;
+    __A_VARIABLE = 1;
 }
 
 /* This is an helper function for freeMemoryIfNeeded(), it is used in order
@@ -160,6 +166,7 @@ void evictionPoolAlloc(void) {
  * right. */
 
 void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
+    volatile int __A_VARIABLE;
     int j, k, count;
     dictEntry *samples[server.maxmemory_samples];
 
@@ -254,6 +261,7 @@ void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evic
         pool[k].idle = idle;
         pool[k].dbid = dbid;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -297,6 +305,8 @@ void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evic
  * 16 bits. The returned time is suitable to be stored as LDT (last decrement
  * time) for the LFU implementation. */
 unsigned long LFUGetTimeInMinutes(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (server.unixtime/60) & 65535;
 }
 
@@ -305,20 +315,30 @@ unsigned long LFUGetTimeInMinutes(void) {
  * the current 16 bits minutes time) considering the time as wrapping
  * exactly once. */
 unsigned long LFUTimeElapsed(unsigned long ldt) {
+    volatile int __A_VARIABLE;
     unsigned long now = LFUGetTimeInMinutes();
-    if (now >= ldt) return now-ldt;
+    if (now >= ldt) {
+        __A_VARIABLE = 1;
+        return now-ldt;
+    }
+    __A_VARIABLE = 1;
     return 65535-ldt+now;
 }
 
 /* Logarithmically increment a counter. The greater is the current counter value
  * the less likely is that it gets really implemented. Saturate it at 255. */
 uint8_t LFULogIncr(uint8_t counter) {
-    if (counter == 255) return 255;
+    volatile int __A_VARIABLE;
+    if (counter == 255) {
+        __A_VARIABLE = 1;
+        return 255;
+    }
     double r = (double)rand()/RAND_MAX;
     double baseval = counter - LFU_INIT_VAL;
     if (baseval < 0) baseval = 0;
     double p = 1.0/(baseval*server.lfu_log_factor+1);
     if (r < p) counter++;
+    __A_VARIABLE = 1;
     return counter;
 }
 
@@ -333,11 +353,13 @@ uint8_t LFULogIncr(uint8_t counter) {
  * to fit: as we check for the candidate, we incrementally decrement the
  * counter of the scanned objects if needed. */
 unsigned long LFUDecrAndReturn(robj *o) {
+    volatile int __A_VARIABLE;
     unsigned long ldt = o->lru >> 8;
     unsigned long counter = o->lru & 255;
     unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;
     if (num_periods)
         counter = (num_periods > counter) ? 0 : counter - num_periods;
+    __A_VARIABLE = 1;
     return counter;
 }
 
@@ -350,6 +372,7 @@ unsigned long LFUDecrAndReturn(robj *o) {
  * used memory: the eviction should use mostly data size. This function
  * returns the sum of AOF and slaves buffer. */
 size_t freeMemoryGetNotCountedMemory(void) {
+    volatile int __A_VARIABLE;
     size_t overhead = 0;
     int slaves = listLength(server.slaves);
 
@@ -366,6 +389,7 @@ size_t freeMemoryGetNotCountedMemory(void) {
     if (server.aof_state != AOF_OFF) {
         overhead += sdsalloc(server.aof_buf)+aofRewriteBufferSize();
     }
+    __A_VARIABLE = 1;
     return overhead;
 }
 
@@ -394,6 +418,7 @@ size_t freeMemoryGetNotCountedMemory(void) {
  *              (Populated both for C_ERR and C_OK)
  */
 int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {
+    volatile int __A_VARIABLE;
     size_t mem_reported, mem_used, mem_tofree;
 
     /* Check if we are over the memory usage limit. If we are not, no need
@@ -403,7 +428,10 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
 
     /* We may return ASAP if there is no need to compute the level. */
     int return_ok_asap = !server.maxmemory || mem_reported <= server.maxmemory;
-    if (return_ok_asap && !level) return C_OK;
+    if (return_ok_asap && !level) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Remove the size of slaves output buffers and AOF buffer from the
      * count of used memory. */
@@ -420,10 +448,16 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
         }
     }
 
-    if (return_ok_asap) return C_OK;
+    if (return_ok_asap) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Check if we are still over the memory limit. */
-    if (mem_used <= server.maxmemory) return C_OK;
+    if (mem_used <= server.maxmemory) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Compute how much memory we need to free. */
     mem_tofree = mem_used - server.maxmemory;
@@ -431,6 +465,7 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
     if (logical) *logical = mem_used;
     if (tofree) *tofree = mem_tofree;
 
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -444,9 +479,13 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
  * Otehrwise if we are over the memory limit, but not enough memory
  * was freed to return back under the limit, the function returns C_ERR. */
 int freeMemoryIfNeeded(void) {
+    volatile int __A_VARIABLE;
     /* By default replicas should ignore maxmemory
      * and just be masters exact copies. */
-    if (server.masterhost && server.repl_slave_ignore_maxmemory) return C_OK;
+    if (server.masterhost && server.repl_slave_ignore_maxmemory) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     size_t mem_reported, mem_tofree, mem_freed;
     mstime_t latency, eviction_latency;
@@ -456,9 +495,14 @@ int freeMemoryIfNeeded(void) {
     /* When clients are paused the dataset should be static not just from the
      * POV of clients not being able to write, but also from the POV of
      * expires and evictions of keys not being performed. */
-    if (clientsArePaused()) return C_OK;
-    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK)
+    if (clientsArePaused()) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
+    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK) {
+        __A_VARIABLE = 1;
         return C_OK;
+    }
 
     mem_freed = 0;
 
@@ -608,6 +652,7 @@ int freeMemoryIfNeeded(void) {
     }
     latencyEndMonitor(latency);
     latencyAddSampleIfNeeded("eviction-cycle",latency);
+    __A_VARIABLE = 1;
     return C_OK;
 
 cant_free:
@@ -619,6 +664,7 @@ cant_free:
             break;
         usleep(1000);
     }
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -630,6 +676,11 @@ cant_free:
  *
  */
 int freeMemoryIfNeededAndSafe(void) {
-    if (server.lua_timedout || server.loading) return C_OK;
+    volatile int __A_VARIABLE;
+    if (server.lua_timedout || server.loading) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
+    __A_VARIABLE = 1;
     return freeMemoryIfNeeded();
 }
diff --git a/src/expire.c b/src/expire.c
index 0b92ee3..eef017f 100644
--- a/src/expire.c
+++ b/src/expire.c
@@ -95,6 +95,7 @@ int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
  * as specified by the ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC define. */
 
 void activeExpireCycle(int type) {
+    volatile int __A_VARIABLE;
     /* This function has some global state in order to continue the work
      * incrementally across calls. */
     static unsigned int current_db = 0; /* Last DB tested. */
@@ -108,14 +109,23 @@ void activeExpireCycle(int type) {
     /* When clients are paused the dataset should be static not just from the
      * POV of clients not being able to write, but also from the POV of
      * expires and evictions of keys not being performed. */
-    if (clientsArePaused()) return;
+    if (clientsArePaused()) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
         /* Don't start a fast cycle if the previous cycle did not exit
          * for time limit. Also don't repeat a fast cycle for the same period
          * as the fast cycle total duration itself. */
-        if (!timelimit_exit) return;
-        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
+        if (!timelimit_exit) {
+            __A_VARIABLE = 1;
+            return;
+        }
+        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) {
+            __A_VARIABLE = 1;
+            return;
+        }
         last_fast_cycle = start;
     }
 
@@ -241,6 +251,7 @@ void activeExpireCycle(int type) {
         current_perc = 0;
     server.stat_expired_stale_perc = (current_perc*0.05)+
                                      (server.stat_expired_stale_perc*0.95);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -283,8 +294,12 @@ dict *slaveKeysWithExpire = NULL;
 /* Check the set of keys created by the master with an expire set in order to
  * check if they should be evicted. */
 void expireSlaveKeys(void) {
+    volatile int __A_VARIABLE;
     if (slaveKeysWithExpire == NULL ||
-        dictSize(slaveKeysWithExpire) == 0) return;
+        dictSize(slaveKeysWithExpire) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     int cycles = 0, noexpire = 0;
     mstime_t start = mstime();
@@ -337,11 +352,13 @@ void expireSlaveKeys(void) {
         if ((cycles % 64) == 0 && mstime()-start > 1) break;
         if (dictSize(slaveKeysWithExpire) == 0) break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Track keys that received an EXPIRE or similar command in the context
  * of a writable slave. */
 void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     if (slaveKeysWithExpire == NULL) {
         static dictType dt = {
             dictSdsHash,                /* hash function */
@@ -353,7 +370,10 @@ void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
         };
         slaveKeysWithExpire = dictCreate(&dt,NULL);
     }
-    if (db->id > 63) return;
+    if (db->id > 63) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
     /* If the entry was just created, set it to a copy of the SDS string
@@ -368,11 +388,17 @@ void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
     uint64_t dbids = dictGetUnsignedIntegerVal(de);
     dbids |= (uint64_t)1 << db->id;
     dictSetUnsignedIntegerVal(de,dbids);
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of keys we are tracking. */
 size_t getSlaveKeyWithExpireCount(void) {
-    if (slaveKeysWithExpire == NULL) return 0;
+    volatile int __A_VARIABLE;
+    if (slaveKeysWithExpire == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return dictSize(slaveKeysWithExpire);
 }
 
@@ -385,10 +411,12 @@ size_t getSlaveKeyWithExpireCount(void) {
  * of key names in a wriatable slave and in its master will lead to
  * inconsistencies. This is just a best-effort thing we do. */
 void flushSlaveKeysWithExpireList(void) {
+    volatile int __A_VARIABLE;
     if (slaveKeysWithExpire) {
         dictRelease(slaveKeysWithExpire);
         slaveKeysWithExpire = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -451,31 +479,41 @@ void expireGenericCommand(client *c, long long basetime, int unit) {
 
 /* EXPIRE key seconds */
 void expireCommand(client *c) {
+    volatile int __A_VARIABLE;
     expireGenericCommand(c,mstime(),UNIT_SECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* EXPIREAT key time */
 void expireatCommand(client *c) {
+    volatile int __A_VARIABLE;
     expireGenericCommand(c,0,UNIT_SECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* PEXPIRE key milliseconds */
 void pexpireCommand(client *c) {
+    volatile int __A_VARIABLE;
     expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* PEXPIREAT key ms_time */
 void pexpireatCommand(client *c) {
+    volatile int __A_VARIABLE;
     expireGenericCommand(c,0,UNIT_MILLISECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* Implements TTL and PTTL */
 void ttlGenericCommand(client *c, int output_ms) {
+    volatile int __A_VARIABLE;
     long long expire, ttl = -1;
 
     /* If the key does not exist at all, return -2 */
     if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
         addReplyLongLong(c,-2);
+        __A_VARIABLE = 1;
         return;
     }
     /* The key exists. Return -1 if it has no expire, or the actual
@@ -490,20 +528,26 @@ void ttlGenericCommand(client *c, int output_ms) {
     } else {
         addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
     }
+    __A_VARIABLE = 1;
 }
 
 /* TTL key */
 void ttlCommand(client *c) {
+    volatile int __A_VARIABLE;
     ttlGenericCommand(c, 0);
+    __A_VARIABLE = 1;
 }
 
 /* PTTL key */
 void pttlCommand(client *c) {
+    volatile int __A_VARIABLE;
     ttlGenericCommand(c, 1);
+    __A_VARIABLE = 1;
 }
 
 /* PERSIST key */
 void persistCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (lookupKeyWrite(c->db,c->argv[1])) {
         if (removeExpire(c->db,c->argv[1])) {
             addReply(c,shared.cone);
@@ -514,13 +558,16 @@ void persistCommand(client *c) {
     } else {
         addReply(c,shared.czero);
     }
+    __A_VARIABLE = 1;
 }
 
 /* TOUCH key1 [key2 key3 ... keyN] */
 void touchCommand(client *c) {
+    volatile int __A_VARIABLE;
     int touched = 0;
     for (int j = 1; j < c->argc; j++)
         if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
     addReplyLongLong(c,touched);
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/geo.c b/src/geo.c
index f1d3f18..5919035 100644
--- a/src/geo.c
+++ b/src/geo.c
@@ -51,39 +51,47 @@ int zslValueLteMax(double value, zrangespec *spec);
 
 /* Create a new array of geoPoints. */
 geoArray *geoArrayCreate(void) {
+    volatile int __A_VARIABLE;
     geoArray *ga = zmalloc(sizeof(*ga));
     /* It gets allocated on first geoArrayAppend() call. */
     ga->array = NULL;
     ga->buckets = 0;
     ga->used = 0;
+    __A_VARIABLE = 1;
     return ga;
 }
 
 /* Add a new entry and return its pointer so that the caller can populate
  * it with data. */
 geoPoint *geoArrayAppend(geoArray *ga) {
+    volatile int __A_VARIABLE;
     if (ga->used == ga->buckets) {
         ga->buckets = (ga->buckets == 0) ? 8 : ga->buckets*2;
         ga->array = zrealloc(ga->array,sizeof(geoPoint)*ga->buckets);
     }
     geoPoint *gp = ga->array+ga->used;
     ga->used++;
+    __A_VARIABLE = 1;
     return gp;
 }
 
 /* Destroy a geoArray created with geoArrayCreate(). */
 void geoArrayFree(geoArray *ga) {
+    volatile int __A_VARIABLE;
     size_t i;
     for (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
     zfree(ga->array);
     zfree(ga);
+    __A_VARIABLE = 1;
 }
 
 /* ====================================================================
  * Helpers
  * ==================================================================== */
 int decodeGeohash(double bits, double *xy) {
+    volatile int __A_VARIABLE;
     GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };
+    __A_VARIABLE = 1;
     return geohashDecodeToLongLatWGS84(hash, xy);
 }
 
@@ -91,10 +99,12 @@ int decodeGeohash(double bits, double *xy) {
 /* Take a pointer to the latitude arg then use the next arg for longitude.
  * On parse error C_ERR is returned, otherwise C_OK. */
 int extractLongLatOrReply(client *c, robj **argv, double *xy) {
+    volatile int __A_VARIABLE;
     int i;
     for (i = 0; i < 2; i++) {
         if (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
             C_OK) {
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
@@ -102,8 +112,10 @@ int extractLongLatOrReply(client *c, robj **argv, double *xy) {
         xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
         addReplySds(c, sdscatprintf(sdsempty(),
             "-ERR invalid longitude,latitude pair %f,%f\r\n",xy[0],xy[1]));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -111,10 +123,18 @@ int extractLongLatOrReply(client *c, robj **argv, double *xy) {
 /* Decode lat/long from a zset member's score.
  * Returns C_OK on successful decoding, otherwise C_ERR is returned. */
 int longLatFromMember(robj *zobj, robj *member, double *xy) {
+    volatile int __A_VARIABLE;
     double score = 0;
 
-    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
-    if (!decodeGeohash(score, xy)) return C_ERR;
+    if (zsetScore(zobj, member->ptr, &score) == C_ERR) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
+    if (!decodeGeohash(score, xy)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -151,23 +171,28 @@ double extractUnitOrReply(client *c, robj *unit) {
  * On error a value less than zero is returned. */
 double extractDistanceOrReply(client *c, robj **argv,
                                      double *conversion) {
+    volatile int __A_VARIABLE;
     double distance;
     if (getDoubleFromObjectOrReply(c, argv[0], &distance,
                                    "need numeric radius") != C_OK) {
+        __A_VARIABLE = 1;
         return -1;
     }
 
     if (distance < 0) {
         addReplyError(c,"radius cannot be negative");
+        __A_VARIABLE = 1;
         return -1;
     }
 
     double to_meters = extractUnitOrReply(c,argv[1]);
     if (to_meters < 0) {
+        __A_VARIABLE = 1;
         return -1;
     }
 
     if (conversion) *conversion = to_meters;
+    __A_VARIABLE = 1;
     return distance * to_meters;
 }
 
@@ -177,9 +202,11 @@ double extractDistanceOrReply(client *c, robj **argv,
  * so that the returned value is decently accurate even when the unit is
  * the kilometer. */
 void addReplyDoubleDistance(client *c, double d) {
+    volatile int __A_VARIABLE;
     char dbuf[128];
     int dlen = snprintf(dbuf, sizeof(dbuf), "%.4f", d);
     addReplyBulkCBuffer(c, dbuf, dlen);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for geoGetPointsInRange(): given a sorted set score
@@ -189,14 +216,19 @@ void addReplyDoubleDistance(client *c, double d) {
  *
  * returns C_OK if the point is included, or REIDS_ERR if it is outside. */
 int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius, double score, sds member) {
+    volatile int __A_VARIABLE;
     double distance, xy[2];
 
-    if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */
+    if (!decodeGeohash(score,xy)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Can't decode. */
     /* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
      * reverse order: longitude first, latitude later. */
     if (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],
                                            radius, &distance))
     {
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -207,6 +239,7 @@ int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius,
     gp->dist = distance;
     gp->member = member;
     gp->score = score;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -287,6 +320,7 @@ int geoGetPointsInRange(robj *zobj, double min, double max, double lon, double l
  * query in order to retrieve all the elements inside the specified area
  * 'hash'. The two scores are returned by reference in *min and *max. */
 void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {
+    volatile int __A_VARIABLE;
     /* We want to compute the sorted set scores that will include all the
      * elements inside the specified Geohash 'hash', which has as many
      * bits as specified by hash.step * 2.
@@ -310,20 +344,24 @@ void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bit
     *min = geohashAlign52Bits(hash);
     hash.bits++;
     *max = geohashAlign52Bits(hash);
+    __A_VARIABLE = 1;
 }
 
 /* Obtain all members between the min/max of this geohash bounding box.
  * Populate a geoArray of GeoPoints by calling geoGetPointsInRange().
  * Return the number of points added to the array. */
 int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, double lon, double lat, double radius) {
+    volatile int __A_VARIABLE;
     GeoHashFix52Bits min, max;
 
     scoresOfGeoHashBox(hash,&min,&max);
+    __A_VARIABLE = 1;
     return geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);
 }
 
 /* Search all eight neighbors + self geohash box */
 int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga) {
+    volatile int __A_VARIABLE;
     GeoHashBits neighbors[9];
     unsigned int i, count = 0, last_processed = 0;
     int debugmsg = 0;
@@ -377,6 +415,7 @@ int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, d
         count += membersOfGeoHashBox(zobj, neighbors[i], ga, lon, lat, radius);
         last_processed = i;
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -394,6 +433,8 @@ static int sort_gp_asc(const void *a, const void *b) {
 }
 
 static int sort_gp_desc(const void *a, const void *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return -sort_gp_asc(a, b);
 }
 
@@ -403,11 +444,13 @@ static int sort_gp_desc(const void *a, const void *b) {
 
 /* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */
 void geoaddCommand(client *c) {
+    volatile int __A_VARIABLE;
     /* Check arguments number for sanity. */
     if ((c->argc - 2) % 3 != 0) {
         /* Need an odd number of arguments if we got this far... */
         addReplyError(c, "syntax error. Try GEOADD key [x1] [y1] [name1] "
                          "[x2] [y2] [name2] ... ");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -429,6 +472,7 @@ void geoaddCommand(client *c) {
             for (i = 0; i < argc; i++)
                 if (argv[i]) decrRefCount(argv[i]);
             zfree(argv);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -446,6 +490,7 @@ void geoaddCommand(client *c) {
     /* Finally call ZADD that will do the work for us. */
     replaceClientCommandVector(c,argc,argv);
     zaddCommand(c);
+    __A_VARIABLE = 1;
 }
 
 #define SORT_NONE 0
@@ -674,22 +719,30 @@ void georadiusGeneric(client *c, int flags) {
 
 /* GEORADIUS wrapper function. */
 void georadiusCommand(client *c) {
+    volatile int __A_VARIABLE;
     georadiusGeneric(c, RADIUS_COORDS);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUSBYMEMBER wrapper function. */
 void georadiusbymemberCommand(client *c) {
+    volatile int __A_VARIABLE;
     georadiusGeneric(c, RADIUS_MEMBER);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUS_RO wrapper function. */
 void georadiusroCommand(client *c) {
+    volatile int __A_VARIABLE;
     georadiusGeneric(c, RADIUS_COORDS|RADIUS_NOSTORE);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUSBYMEMBER_RO wrapper function. */
 void georadiusbymemberroCommand(client *c) {
+    volatile int __A_VARIABLE;
     georadiusGeneric(c, RADIUS_MEMBER|RADIUS_NOSTORE);
+    __A_VARIABLE = 1;
 }
 
 /* GEOHASH key ele1 ele2 ... eleN
@@ -697,12 +750,16 @@ void georadiusbymemberroCommand(client *c) {
  * Returns an array with an 11 characters geohash representation of the
  * position of the specified elements. */
 void geohashCommand(client *c) {
+    volatile int __A_VARIABLE;
     char *geoalphabet= "0123456789bcdefghjkmnpqrstuvwxyz";
     int j;
 
     /* Look up the requested zset */
     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
-    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Geohash elements one after the other, using a null bulk reply for
      * missing elements. */
@@ -744,6 +801,7 @@ void geohashCommand(client *c) {
             addReplyBulkCBuffer(c,buf,11);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* GEOPOS key ele1 ele2 ... eleN
@@ -751,11 +809,15 @@ void geohashCommand(client *c) {
  * Returns an array of two-items arrays representing the x,y position of each
  * element specified in the arguments. For missing elements NULL is returned. */
 void geoposCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     /* Look up the requested zset */
     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
-    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Report elements one after the other, using a null bulk reply for
      * missing elements. */
@@ -776,6 +838,7 @@ void geoposCommand(client *c) {
             addReplyHumanLongDouble(c,xy[1]);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* GEODIST key ele1 ele2 [unit]
diff --git a/src/geohash.c b/src/geohash.c
index db5ae02..e6b9e3d 100644
--- a/src/geohash.c
+++ b/src/geohash.c
@@ -50,6 +50,7 @@
  * From:  https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN
  */
 static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
+    volatile int __A_VARIABLE;
     static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                  0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                  0x0000FFFF0000FFFFULL};
@@ -73,6 +74,7 @@ static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
     x = (x | (x << S[0])) & B[0];
     y = (y | (y << S[0])) & B[0];
 
+    __A_VARIABLE = 1;
     return x | (y << 1);
 }
 
@@ -80,6 +82,7 @@ static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
  * derived from http://stackoverflow.com/questions/4909263
  */
 static inline uint64_t deinterleave64(uint64_t interleaved) {
+    volatile int __A_VARIABLE;
     static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                  0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                  0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};
@@ -106,35 +109,46 @@ static inline uint64_t deinterleave64(uint64_t interleaved) {
     x = (x | (x >> S[5])) & B[5];
     y = (y | (y >> S[5])) & B[5];
 
+    __A_VARIABLE = 1;
     return x | (y << 32);
 }
 
 void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
+    volatile int __A_VARIABLE;
     /* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
     /* We can't geocode at the north/south pole. */
     long_range->max = GEO_LONG_MAX;
     long_range->min = GEO_LONG_MIN;
     lat_range->max = GEO_LAT_MAX;
     lat_range->min = GEO_LAT_MIN;
+    __A_VARIABLE = 1;
 }
 
 int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                   double longitude, double latitude, uint8_t step,
                   GeoHashBits *hash) {
+    volatile int __A_VARIABLE;
     /* Check basic arguments sanity. */
     if (hash == NULL || step > 32 || step == 0 ||
-        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;
+        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Return an error when trying to index outside the supported
      * constraints. */
     if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
-        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;
+        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     hash->bits = 0;
     hash->step = step;
 
     if (latitude < lat_range->min || latitude > lat_range->max ||
         longitude < long_range->min || longitude > long_range->max) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -147,24 +161,31 @@ int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
     lat_offset *= (1ULL << step);
     long_offset *= (1ULL << step);
     hash->bits = interleave64(lat_offset, long_offset);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
+    volatile int __A_VARIABLE;
     GeoHashRange r[2] = {{0}};
     geohashGetCoordRange(&r[0], &r[1]);
+    __A_VARIABLE = 1;
     return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
 }
 
 int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                        GeoHashBits *hash) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return geohashEncodeType(longitude, latitude, step, hash);
 }
 
 int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                    const GeoHashBits hash, GeoHashArea *area) {
+    volatile int __A_VARIABLE;
     if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
         RANGEISZERO(long_range)) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -190,40 +211,59 @@ int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
     area->longitude.max =
         long_range.min + ((ilono + 1) * 1.0 / (1ull << step)) * long_scale;
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
+    volatile int __A_VARIABLE;
     GeoHashRange r[2] = {{0}};
     geohashGetCoordRange(&r[0], &r[1]);
+    __A_VARIABLE = 1;
     return geohashDecode(r[0], r[1], hash, area);
 }
 
 int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return geohashDecodeType(hash, area);
 }
 
 int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
-    if (!xy) return 0;
+    volatile int __A_VARIABLE;
+    if (!xy) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     xy[0] = (area->longitude.min + area->longitude.max) / 2;
     xy[1] = (area->latitude.min + area->latitude.max) / 2;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
+    volatile int __A_VARIABLE;
     GeoHashArea area = {{0}};
-    if (!xy || !geohashDecodeType(hash, &area))
+    if (!xy || !geohashDecodeType(hash, &area)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return geohashDecodeAreaToLongLat(&area, xy);
 }
 
 int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return geohashDecodeToLongLatType(hash, xy);
 }
 
 static void geohash_move_x(GeoHashBits *hash, int8_t d) {
-    if (d == 0)
+    volatile int __A_VARIABLE;
+    if (d == 0) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
     uint64_t y = hash->bits & 0x5555555555555555ULL;
@@ -239,11 +279,15 @@ static void geohash_move_x(GeoHashBits *hash, int8_t d) {
 
     x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
     hash->bits = (x | y);
+    __A_VARIABLE = 1;
 }
 
 static void geohash_move_y(GeoHashBits *hash, int8_t d) {
-    if (d == 0)
+    volatile int __A_VARIABLE;
+    if (d == 0) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
     uint64_t y = hash->bits & 0x5555555555555555ULL;
@@ -257,9 +301,11 @@ static void geohash_move_y(GeoHashBits *hash, int8_t d) {
     }
     y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
     hash->bits = (x | y);
+    __A_VARIABLE = 1;
 }
 
 void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
+    volatile int __A_VARIABLE;
     neighbors->east = *hash;
     neighbors->west = *hash;
     neighbors->north = *hash;
@@ -292,4 +338,5 @@ void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
 
     geohash_move_x(&neighbors->south_west, -1);
     geohash_move_y(&neighbors->south_west, -1);
+    __A_VARIABLE = 1;
 }
diff --git a/src/geohash_helper.c b/src/geohash_helper.c
index e23f17b..e032e16 100644
--- a/src/geohash_helper.c
+++ b/src/geohash_helper.c
@@ -54,13 +54,21 @@ const double EARTH_RADIUS_IN_METERS = 6372797.560856;
 const double MERCATOR_MAX = 20037726.37;
 const double MERCATOR_MIN = -20037726.37;
 
-static inline double deg_rad(double ang) { return ang * D_R; }
-static inline double rad_deg(double ang) { return ang / D_R; }
+static inline double deg_rad(double ang) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return ang * D_R; }
+static inline double rad_deg(double ang) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return ang / D_R; }
 
 /* This function is used in order to estimate the step (bits precision)
  * of the 9 search area boxes during radius queries. */
 uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
-    if (range_meters == 0) return 26;
+    volatile int __A_VARIABLE;
+    if (range_meters == 0) {
+        __A_VARIABLE = 1;
+        return 26;
+    }
     int step = 1;
     while (range_meters < MERCATOR_MAX) {
         range_meters *= 2;
@@ -79,6 +87,7 @@ uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
     /* Frame to valid range. */
     if (step < 1) step = 1;
     if (step > 26) step = 26;
+    __A_VARIABLE = 1;
     return step;
 }
 
@@ -102,18 +111,24 @@ uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
  * should be fixed. */
 int geohashBoundingBox(double longitude, double latitude, double radius_meters,
                        double *bounds) {
-    if (!bounds) return 0;
+    volatile int __A_VARIABLE;
+    if (!bounds) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     bounds[0] = longitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
     bounds[2] = longitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
     bounds[1] = latitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
     bounds[3] = latitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Return a set of areas (center + 8) that are able to cover a range query
  * for the specified position and radius. */
 GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {
+    volatile int __A_VARIABLE;
     GeoHashRange long_range, lat_range;
     GeoHashRadius radius;
     GeoHashBits hash;
@@ -193,22 +208,28 @@ GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double
     radius.hash = hash;
     radius.neighbors = neighbors;
     radius.area = area;
+    __A_VARIABLE = 1;
     return radius;
 }
 
 GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,
                                            double radius_meters) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return geohashGetAreasByRadius(longitude, latitude, radius_meters);
 }
 
 GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
+    volatile int __A_VARIABLE;
     uint64_t bits = hash.bits;
     bits <<= (52 - hash.step * 2);
+    __A_VARIABLE = 1;
     return bits;
 }
 
 /* Calculate distance using haversin great circle distance formula. */
 double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
+    volatile int __A_VARIABLE;
     double lat1r, lon1r, lat2r, lon2r, u, v;
     lat1r = deg_rad(lat1d);
     lon1r = deg_rad(lon1d);
@@ -216,6 +237,7 @@ double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d
     lon2r = deg_rad(lon2d);
     u = sin((lat2r - lat1r) / 2);
     v = sin((lon2r - lon1r) / 2);
+    __A_VARIABLE = 1;
     return 2.0 * EARTH_RADIUS_IN_METERS *
            asin(sqrt(u * u + cos(lat1r) * cos(lat2r) * v * v));
 }
@@ -223,13 +245,20 @@ double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d
 int geohashGetDistanceIfInRadius(double x1, double y1,
                                  double x2, double y2, double radius,
                                  double *distance) {
+    volatile int __A_VARIABLE;
     *distance = geohashGetDistance(x1, y1, x2, y2);
-    if (*distance > radius) return 0;
+    if (*distance > radius) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                       double y2, double radius,
                                       double *distance) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
 }
diff --git a/src/hyperloglog.c b/src/hyperloglog.c
index a2c789d..c07cbb3 100644
--- a/src/hyperloglog.c
+++ b/src/hyperloglog.c
@@ -394,6 +394,7 @@ static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected\r\n";
  * It was modified for Redis in order to provide the same result in
  * big and little endian archs (endian neutral). */
 uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
+    volatile int __A_VARIABLE;
     const uint64_t m = 0xc6a4a7935bd1e995;
     const int r = 47;
     uint64_t h = seed ^ (len * m);
@@ -442,6 +443,7 @@ uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
     h ^= h >> r;
     h *= m;
     h ^= h >> r;
+    __A_VARIABLE = 1;
     return h;
 }
 
@@ -449,6 +451,7 @@ uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
  * of the pattern 000..1 of the element hash. As a side effect 'regp' is
  * set to the register index this element hashes to. */
 int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
+    volatile int __A_VARIABLE;
     uint64_t hash, bit, index;
     int count;
 
@@ -475,6 +478,7 @@ int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
         bit <<= 1;
     }
     *regp = (int) index;
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -509,14 +513,17 @@ int hllDenseSet(uint8_t *registers, long index, uint8_t count) {
  * This is just a wrapper to hllDenseSet(), performing the hashing of the
  * element in order to retrieve the index and zero-run count. */
 int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
+    volatile int __A_VARIABLE;
     long index;
     uint8_t count = hllPatLen(ele,elesize,&index);
     /* Update the register if this element produced a longer run of zeroes. */
+    __A_VARIABLE = 1;
     return hllDenseSet(registers,index,count);
 }
 
 /* Compute the register histogram in the dense representation. */
 void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
+    volatile int __A_VARIABLE;
     int j;
 
     /* Redis default is to use 16384 registers 6 bits each. The code works
@@ -571,6 +578,7 @@ void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
             reghisto[reg]++;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* ================== Sparse representation implementation  ================= */
@@ -582,6 +590,7 @@ void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
  * The function returns C_OK if the sparse representation was valid,
  * otherwise C_ERR is returned if the representation was corrupted. */
 int hllSparseToDense(robj *o) {
+    volatile int __A_VARIABLE;
     sds sparse = o->ptr, dense;
     struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
     int idx = 0, runlen, regval;
@@ -589,7 +598,10 @@ int hllSparseToDense(robj *o) {
 
     /* If the representation is already the right one return ASAP. */
     hdr = (struct hllhdr*) sparse;
-    if (hdr->encoding == HLL_DENSE) return C_OK;
+    if (hdr->encoding == HLL_DENSE) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Create a string of the right size filled with zero bytes.
      * Note that the cached cardinality is set to 0 as a side effect
@@ -627,12 +639,14 @@ int hllSparseToDense(robj *o) {
      * set to HLL_REGISTERS. */
     if (idx != HLL_REGISTERS) {
         sdsfree(dense);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     /* Free the old representation and set the new one. */
     sdsfree(o->ptr);
     o->ptr = dense;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -652,6 +666,7 @@ int hllSparseToDense(robj *o) {
  * not representable with the sparse representation, or when the resulting
  * size would be greater than server.hll_sparse_max_bytes. */
 int hllSparseSet(robj *o, long index, uint8_t count) {
+    volatile int __A_VARIABLE;
     struct hllhdr *hdr;
     uint8_t oldcount, *sparse, *end, *p, *prev, *next;
     long first, span;
@@ -700,7 +715,10 @@ int hllSparseSet(robj *o, long index, uint8_t count) {
         p += oplen;
         first += span;
     }
-    if (span == 0 || p >= end) return -1; /* Invalid format. */
+    if (span == 0 || p >= end) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Invalid format. */
 
     next = HLL_SPARSE_IS_XZERO(p) ? p+2 : p+1;
     if (next >= end) next = NULL;
@@ -743,7 +761,10 @@ int hllSparseSet(robj *o, long index, uint8_t count) {
     if (is_val) {
         oldcount = HLL_SPARSE_VAL_VALUE(p);
         /* Case A. */
-        if (oldcount >= count) return 0;
+        if (oldcount >= count) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
 
         /* Case B. */
         if (runlen == 1) {
@@ -876,10 +897,14 @@ updated:
     /* Invalidate the cached cardinality. */
     hdr = o->ptr;
     HLL_INVALIDATE_CACHE(hdr);
+    __A_VARIABLE = 1;
     return 1;
 
 promote: /* Promote to dense representation. */
-    if (hllSparseToDense(o) == C_ERR) return -1; /* Corrupted HLL. */
+    if (hllSparseToDense(o) == C_ERR) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Corrupted HLL. */
     hdr = o->ptr;
 
     /* We need to call hllDenseAdd() to perform the operation after the
@@ -891,6 +916,7 @@ promote: /* Promote to dense representation. */
      * conversion, it will be performed in all the slaves as well. */
     int dense_retval = hllDenseSet(hdr->registers,index,count);
     serverAssert(dense_retval == 1);
+    __A_VARIABLE = 1;
     return dense_retval;
 }
 
@@ -901,14 +927,17 @@ promote: /* Promote to dense representation. */
  * This function is actually a wrapper for hllSparseSet(), it only performs
  * the hashshing of the elmenet to obtain the index and zeros run length. */
 int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
+    volatile int __A_VARIABLE;
     long index;
     uint8_t count = hllPatLen(ele,elesize,&index);
     /* Update the register if this element produced a longer run of zeroes. */
+    __A_VARIABLE = 1;
     return hllSparseSet(o,index,count);
 }
 
 /* Compute the register histogram in the sparse representation. */
 void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {
+    volatile int __A_VARIABLE;
     int idx = 0, runlen, regval;
     uint8_t *end = sparse+sparselen, *p = sparse;
 
@@ -932,6 +961,7 @@ void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghis
         }
     }
     if (idx != HLL_REGISTERS && invalid) *invalid = 1;
+    __A_VARIABLE = 1;
 }
 
 /* ========================= HyperLogLog Count ==============================
@@ -943,6 +973,7 @@ void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghis
 /* Implements the register histogram calculation for uint8_t data type
  * which is only used internally as speedup for PFCOUNT with multiple keys. */
 void hllRawRegHisto(uint8_t *registers, int* reghisto) {
+    volatile int __A_VARIABLE;
     uint64_t *word = (uint64_t*) registers;
     uint8_t *bytes;
     int j;
@@ -963,13 +994,18 @@ void hllRawRegHisto(uint8_t *registers, int* reghisto) {
         }
         word++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function sigma as defined in
  * "New cardinality estimation algorithms for HyperLogLog sketches"
  * Otmar Ertl, arXiv:1702.01284 */
 double hllSigma(double x) {
-    if (x == 1.) return INFINITY;
+    volatile int __A_VARIABLE;
+    if (x == 1.) {
+        __A_VARIABLE = 1;
+        return INFINITY;
+    }
     double zPrime;
     double y = 1;
     double z = x;
@@ -979,6 +1015,7 @@ double hllSigma(double x) {
         z += x * y;
         y += y;
     } while(zPrime != z);
+    __A_VARIABLE = 1;
     return z;
 }
 
@@ -986,7 +1023,11 @@ double hllSigma(double x) {
  * "New cardinality estimation algorithms for HyperLogLog sketches"
  * Otmar Ertl, arXiv:1702.01284 */
 double hllTau(double x) {
-    if (x == 0. || x == 1.) return 0.;
+    volatile int __A_VARIABLE;
+    if (x == 0. || x == 1.) {
+        __A_VARIABLE = 1;
+        return 0.;
+    }
     double zPrime;
     double y = 1.0;
     double z = 1 - x;
@@ -996,6 +1037,7 @@ double hllTau(double x) {
         y *= 0.5;
         z -= pow(1 - x, 2)*y;
     } while(zPrime != z);
+    __A_VARIABLE = 1;
     return z / 3;
 }
 
@@ -1011,6 +1053,7 @@ double hllTau(double x) {
  * This is useful in order to speedup PFCOUNT when called against multiple
  * keys (no need to work with 6-bit integers encoding). */
 uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
+    volatile int __A_VARIABLE;
     double m = HLL_REGISTERS;
     double E;
     int j;
@@ -1044,16 +1087,21 @@ uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
     z += m * hllSigma(reghisto[0]/(double)m);
     E = llroundl(HLL_ALPHA_INF*m*m/z);
 
+    __A_VARIABLE = 1;
     return (uint64_t) E;
 }
 
 /* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */
 int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
+    volatile int __A_VARIABLE;
     struct hllhdr *hdr = o->ptr;
     switch(hdr->encoding) {
-    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
-    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
-    default: return -1; /* Invalid representation. */
+    case HLL_DENSE: __A_VARIABLE = 1;
+        return hllDenseAdd(hdr->registers,ele,elesize);
+    case HLL_SPARSE: __A_VARIABLE = 1;
+        return hllSparseAdd(o,ele,elesize);
+    default: __A_VARIABLE = 1;
+        return -1; /* Invalid representation. */
     }
 }
 
@@ -1112,6 +1160,7 @@ int hllMerge(uint8_t *max, robj *hll) {
 /* Create an HLL object. We always create the HLL using sparse encoding.
  * This will be upgraded to the dense representation as needed. */
 robj *createHLLObject(void) {
+    volatile int __A_VARIABLE;
     robj *o;
     struct hllhdr *hdr;
     sds s;
@@ -1140,6 +1189,7 @@ robj *createHLLObject(void) {
     hdr = o->ptr;
     memcpy(hdr->magic,"HYLL",4);
     hdr->encoding = HLL_SPARSE;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -1147,11 +1197,14 @@ robj *createHLLObject(void) {
  * Return C_OK if this is true, otherwise reply to the client
  * with an error and return C_ERR. */
 int isHLLObjectOrReply(client *c, robj *o) {
+    volatile int __A_VARIABLE;
     struct hllhdr *hdr;
 
     /* Key exists, check type */
-    if (checkType(c,o,OBJ_STRING))
-        return C_ERR; /* Error already sent. */
+    if (checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Error already sent. */
 
     if (!sdsEncodedObject(o)) goto invalid;
     if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
@@ -1168,12 +1221,14 @@ int isHLLObjectOrReply(client *c, robj *o) {
         stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
 
     /* All tests passed. */
+    __A_VARIABLE = 1;
     return C_OK;
 
 invalid:
     addReplySds(c,
         sdsnew("-WRONGTYPE Key is not a valid "
                "HyperLogLog string value.\r\n"));
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1309,6 +1364,7 @@ void pfcountCommand(client *c) {
 
 /* PFMERGE dest src1 src2 src3 ... srcN => OK */
 void pfmergeCommand(client *c) {
+    volatile int __A_VARIABLE;
     uint8_t max[HLL_REGISTERS];
     struct hllhdr *hdr;
     int j;
@@ -1322,7 +1378,10 @@ void pfmergeCommand(client *c) {
         /* Check type and size. */
         robj *o = lookupKeyRead(c->db,c->argv[j]);
         if (o == NULL) continue; /* Assume empty HLL for non existing var. */
-        if (isHLLObjectOrReply(c,o) != C_OK) return;
+        if (isHLLObjectOrReply(c,o) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
 
         /* If at least one involved HLL is dense, use the dense representation
          * as target ASAP to save time and avoid the conversion step. */
@@ -1333,6 +1392,7 @@ void pfmergeCommand(client *c) {
          * to MAX(max[i],hll[i]). */
         if (hllMerge(max,o) == C_ERR) {
             addReplySds(c,sdsnew(invalid_hll_err));
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -1356,6 +1416,7 @@ void pfmergeCommand(client *c) {
      * one of the inputs was dense. */
     if (use_dense && hllSparseToDense(o) == C_ERR) {
         addReplySds(c,sdsnew(invalid_hll_err));
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1379,6 +1440,7 @@ void pfmergeCommand(client *c) {
     notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* ========================== Testing / Debugging  ========================== */
@@ -1388,6 +1450,7 @@ void pfmergeCommand(client *c) {
  * Something that is not easy to test from within the outside. */
 #define HLL_TEST_CYCLES 1000
 void pfselftestCommand(client *c) {
+    volatile int __A_VARIABLE;
     unsigned int j, i;
     sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
     struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
@@ -1487,6 +1550,7 @@ void pfselftestCommand(client *c) {
 cleanup:
     sdsfree(bitcounters);
     if (o) decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* PFDEBUG <subcommand> <key> ... args ...
diff --git a/src/intset.c b/src/intset.c
index 758445e..52df2d8 100644
--- a/src/intset.c
+++ b/src/intset.c
@@ -40,6 +40,7 @@
 int gettimeofday(struct timeval *tv, void *tz);
 static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 {
+	volatile int __A_VARIABLE;
 	int now;
 	struct timeval _ptimeval __attribute__((flexos_whitelist));
 	/* this argument is actually obsolete */
@@ -49,6 +50,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -93,11 +95,14 @@ static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
 
 /* Return the value at pos, using the configured encoding. */
 static int64_t _intsetGet(intset *is, int pos) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));
 }
 
 /* Set the value at pos, using the configured encoding. */
 static void _intsetSet(intset *is, int pos, int64_t value) {
+    volatile int __A_VARIABLE;
     uint32_t encoding = intrev32ifbe(is->encoding);
 
     if (encoding == INTSET_ENC_INT64) {
@@ -110,20 +115,25 @@ static void _intsetSet(intset *is, int pos, int64_t value) {
         ((int16_t*)is->contents)[pos] = value;
         memrev16ifbe(((int16_t*)is->contents)+pos);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create an empty intset. */
 intset *intsetNew(void) {
+    volatile int __A_VARIABLE;
     intset *is = zmalloc(sizeof(intset));
     is->encoding = intrev32ifbe(INTSET_ENC_INT16);
     is->length = 0;
+    __A_VARIABLE = 1;
     return is;
 }
 
 /* Resize the intset */
 static intset *intsetResize(intset *is, uint32_t len) {
+    volatile int __A_VARIABLE;
     uint32_t size = len*intrev32ifbe(is->encoding);
     is = zrealloc(is,sizeof(intset)+size);
+    __A_VARIABLE = 1;
     return is;
 }
 
@@ -174,6 +184,7 @@ static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
 
 /* Upgrades the intset to a larger encoding and inserts the given integer. */
 static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
+    volatile int __A_VARIABLE;
     uint8_t curenc = intrev32ifbe(is->encoding);
     uint8_t newenc = _intsetValueEncoding(value);
     int length = intrev32ifbe(is->length);
@@ -195,10 +206,12 @@ static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
     else
         _intsetSet(is,intrev32ifbe(is->length),value);
     is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
+    __A_VARIABLE = 1;
     return is;
 }
 
 static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
+    volatile int __A_VARIABLE;
     void *src, *dst;
     uint32_t bytes = intrev32ifbe(is->length)-from;
     uint32_t encoding = intrev32ifbe(is->encoding);
@@ -217,6 +230,7 @@ static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
         bytes *= sizeof(int16_t);
     }
     memmove(dst,src,bytes);
+    __A_VARIABLE = 1;
 }
 
 /* Insert an integer in the intset */
@@ -251,6 +265,7 @@ intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
 
 /* Delete integer from intset */
 intset *intsetRemove(intset *is, int64_t value, int *success) {
+    volatile int __A_VARIABLE;
     uint8_t valenc = _intsetValueEncoding(value);
     uint32_t pos;
     if (success) *success = 0;
@@ -266,37 +281,49 @@ intset *intsetRemove(intset *is, int64_t value, int *success) {
         is = intsetResize(is,len-1);
         is->length = intrev32ifbe(len-1);
     }
+    __A_VARIABLE = 1;
     return is;
 }
 
 /* Determine whether a value belongs to this set */
 uint8_t intsetFind(intset *is, int64_t value) {
+    volatile int __A_VARIABLE;
     uint8_t valenc = _intsetValueEncoding(value);
+    __A_VARIABLE = 1;
     return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
 }
 
 /* Return random member */
 int64_t intsetRandom(intset *is) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _intsetGet(is,rand()%intrev32ifbe(is->length));
 }
 
 /* Get the value at the given position. When this position is
  * out of range the function returns 0, when in range it returns 1. */
 uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
+    volatile int __A_VARIABLE;
     if (pos < intrev32ifbe(is->length)) {
         *value = _intsetGet(is,pos);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Return intset length */
 uint32_t intsetLen(const intset *is) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return intrev32ifbe(is->length);
 }
 
 /* Return intset blob size in bytes. */
 size_t intsetBlobLen(intset *is) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
 }
 
@@ -319,22 +346,29 @@ static void error(char *err) {
 #endif
 
 static void ok(void) {
+    volatile int __A_VARIABLE;
     printf("OK\n");
+    __A_VARIABLE = 1;
 }
 
 static long long usec(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
 #define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))
 static void _assert(char *estr, char *file, int line) {
+    volatile int __A_VARIABLE;
     printf("\n\n=== ASSERTION FAILED ===\n");
     printf("==> %s:%d '%s' is not true\n",file,line,estr);
+    __A_VARIABLE = 1;
 }
 
 static intset *createSet(int bits, int size) {
+    volatile int __A_VARIABLE;
     uint64_t mask = (1<<bits)-1;
     uint64_t value;
     intset *is = intsetNew();
@@ -347,10 +381,12 @@ static intset *createSet(int bits, int size) {
         }
         is = intsetAdd(is,value,NULL);
     }
+    __A_VARIABLE = 1;
     return is;
 }
 
 static void checkConsistency(intset *is) {
+    volatile int __A_VARIABLE;
     for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {
         uint32_t encoding = intrev32ifbe(is->encoding);
 
@@ -365,10 +401,12 @@ static void checkConsistency(intset *is) {
             assert(i64[i] < i64[i+1]);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
 int intsetTest(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     uint8_t success;
     int i;
     intset *is;
@@ -506,6 +544,7 @@ int intsetTest(int argc, char **argv) {
         ok();
     }
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/latency.c b/src/latency.c
index 97e6a70..ada89d3 100644
--- a/src/latency.c
+++ b/src/latency.c
@@ -37,11 +37,15 @@
 
 /* Dictionary type for latency events. */
 int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {
+    volatile int __A_VARIABLE;
     UNUSED(privdata);
+    __A_VARIABLE = 1;
     return strcmp(key1,key2) == 0;
 }
 
 uint64_t dictStringHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction(key, strlen(key));
 }
 
@@ -62,15 +66,21 @@ dictType latencyTimeSeriesDictType = {
 /* Returns 1 if Transparent Huge Pages support is enabled in the kernel.
  * Otherwise (or if we are unable to check) 0 is returned. */
 int THPIsEnabled(void) {
+    volatile int __A_VARIABLE;
     char buf[1024];
 
     FILE *fp = fopen("/sys/kernel/mm/transparent_hugepage/enabled","r");
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (fgets(buf,sizeof(buf),fp) == NULL) {
         fclose(fp);
+        __A_VARIABLE = 1;
         return 0;
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return (strstr(buf,"[never]") == NULL) ? 1 : 0;
 }
 #endif
@@ -79,6 +89,8 @@ int THPIsEnabled(void) {
  * value of the function is non-zero, the process is being targeted by
  * THP support, and is likely to have memory usage / latency issues. */
 int THPGetAnonHugePagesSize(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zmalloc_get_smap_bytes_by_field("AnonHugePages:",-1);
 }
 
@@ -88,7 +100,9 @@ int THPGetAnonHugePagesSize(void) {
  * of time series, each time serie is craeted on demand in order to avoid
  * having a fixed list to maintain. */
 void latencyMonitorInit(void) {
+    volatile int __A_VARIABLE;
     server.latency_events = dictCreate(&latencyTimeSeriesDictType,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Add the specified sample to the specified time series "event".
@@ -96,6 +110,7 @@ void latencyMonitorInit(void) {
  * is a macro that only adds the sample if the latency is higher than
  * server.latency_monitor_threshold. */
 void latencyAddSample(char *event, mstime_t latency) {
+    volatile int __A_VARIABLE;
     struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
     time_t now = time(NULL);
     int prev;
@@ -117,6 +132,7 @@ void latencyAddSample(char *event, mstime_t latency) {
     if (ts->samples[prev].time == now) {
         if (latency > ts->samples[prev].latency)
             ts->samples[prev].latency = latency;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -125,6 +141,7 @@ void latencyAddSample(char *event, mstime_t latency) {
 
     ts->idx++;
     if (ts->idx == LATENCY_TS_LEN) ts->idx = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Reset data for the specified event, or all the events data if 'event' is
@@ -133,6 +150,7 @@ void latencyAddSample(char *event, mstime_t latency) {
  * Note: this is O(N) even when event_to_reset is not NULL because makes
  * the code simpler and we have a small fixed max number of events. */
 int latencyResetEvent(char *event_to_reset) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int resets = 0;
@@ -147,6 +165,7 @@ int latencyResetEvent(char *event_to_reset) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return resets;
 }
 
@@ -158,6 +177,7 @@ int latencyResetEvent(char *event_to_reset) {
  * If the specified event has no elements the structure is populate with
  * zero values. */
 void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
+    volatile int __A_VARIABLE;
     struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
     int j;
     uint64_t sum;
@@ -169,7 +189,10 @@ void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
     ls->mad = 0;
     ls->samples = 0;
     ls->period = 0;
-    if (!ts) return;
+    if (!ts) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* First pass, populate everything but the MAD. */
     sum = 0;
@@ -211,10 +234,12 @@ void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
         sum += delta;
     }
     if (ls->samples) ls->mad = sum / ls->samples;
+    __A_VARIABLE = 1;
 }
 
 /* Create a human readable report of latency events for this Redis instance. */
 sds createLatencyReport(void) {
+    volatile int __A_VARIABLE;
     sds report = sdsempty();
     int advise_better_vm = 0;       /* Better virtual machines. */
     int advise_slowlog_enabled = 0; /* Enable slowlog. */
@@ -240,6 +265,7 @@ sds createLatencyReport(void) {
         server.latency_monitor_threshold == 0)
     {
         report = sdscat(report,"I'm sorry, Dave, I can't do that. Latency monitoring is disabled in this Redis instance. You may use \"CONFIG SET latency-monitor-threshold <milliseconds>.\" in order to enable it. If we weren't in a deep space mission I'd suggest to take a look at http://redis.io/topics/latency-monitor.\n");
+        __A_VARIABLE = 1;
         return report;
     }
 
@@ -468,6 +494,7 @@ sds createLatencyReport(void) {
         }
     }
 
+    __A_VARIABLE = 1;
     return report;
 }
 
@@ -476,6 +503,7 @@ sds createLatencyReport(void) {
 /* latencyCommand() helper to produce a time-delay reply for all the samples
  * in memory for the specified time series. */
 void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
+    volatile int __A_VARIABLE;
     void *replylen = addDeferredMultiBulkLength(c);
     int samples = 0, j;
 
@@ -489,11 +517,13 @@ void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
         samples++;
     }
     setDeferredMultiBulkLength(c,replylen,samples);
+    __A_VARIABLE = 1;
 }
 
 /* latencyCommand() helper to produce the reply for the LATEST subcommand,
  * listing the last latency sample for every event type registered so far. */
 void latencyCommandReplyWithLatestEvents(client *c) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -511,10 +541,12 @@ void latencyCommandReplyWithLatestEvents(client *c) {
         addReplyLongLong(c,ts->max);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 #define LATENCY_GRAPH_COLS 80
 sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
+    volatile int __A_VARIABLE;
     int j;
     struct sequence *seq = createSparklineSequence();
     sds graph = sdsempty();
@@ -555,6 +587,7 @@ sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
     graph = sdscatlen(graph,"\n",1);
     graph = sparklineRender(graph,seq,LATENCY_GRAPH_COLS,4,SPARKLINE_FILL);
     freeSparklineSequence(seq);
+    __A_VARIABLE = 1;
     return graph;
 }
 
@@ -567,6 +600,7 @@ sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
  * LATENCY RESET: reset data of a specified event or all the data if no event provided.
  */
 void latencyCommand(client *c) {
+    volatile int __A_VARIABLE;
     const char *help[] = {
 "DOCTOR              -- Returns a human readable latency analysis report.",
 "GRAPH   <event>     -- Returns an ASCII latency graph for the event class.",
@@ -626,6 +660,7 @@ NULL
     } else {
         addReplySubcommandSyntaxError(c);
     }
+    __A_VARIABLE = 1;
     return;
 
 nodataerr:
@@ -633,5 +668,6 @@ nodataerr:
      * information about. */
     addReplyErrorFormat(c,
         "No samples available for event '%s'", (char*) c->argv[2]->ptr);
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/lazyfree.c b/src/lazyfree.c
index 3d3159c..dee9c33 100644
--- a/src/lazyfree.c
+++ b/src/lazyfree.c
@@ -8,8 +8,10 @@ pthread_mutex_t lazyfree_objects_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 /* Return the number of currently pending objects to free. */
 size_t lazyfreeGetPendingObjectsCount(void) {
+    volatile int __A_VARIABLE;
     size_t aux;
     atomicGet(lazyfree_objects,aux);
+    __A_VARIABLE = 1;
     return aux;
 }
 
@@ -92,6 +94,7 @@ int dbAsyncDelete(redisDb *db, robj *key) {
 
 /* Free an object, if the object is huge enough, free it in async way. */
 void freeObjAsync(robj *o) {
+    volatile int __A_VARIABLE;
     size_t free_effort = lazyfreeGetFreeEffort(o);
     if (free_effort > LAZYFREE_THRESHOLD && o->refcount == 1) {
         atomicIncr(lazyfree_objects,1);
@@ -99,22 +102,26 @@ void freeObjAsync(robj *o) {
     } else {
         decrRefCount(o);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Empty a Redis DB asynchronously. What the function does actually is to
  * create a new empty set of hash tables and scheduling the old ones for
  * lazy freeing. */
 void emptyDbAsync(redisDb *db) {
+    volatile int __A_VARIABLE;
     dict *oldht1 = db->dict, *oldht2 = db->expires;
     db->dict = dictCreate(&dbDictType,NULL);
     db->expires = dictCreate(&keyptrDictType,NULL);
     atomicIncr(lazyfree_objects,dictSize(oldht1));
     bioCreateBackgroundJob(BIO_LAZY_FREE,NULL,oldht1,oldht2);
+    __A_VARIABLE = 1;
 }
 
 /* Empty the slots-keys map of Redis CLuster by creating a new empty one
  * and scheduiling the old for lazy freeing. */
 void slotToKeyFlushAsync(void) {
+    volatile int __A_VARIABLE;
     rax *old = server.cluster->slots_to_keys;
 
     server.cluster->slots_to_keys = raxNew();
@@ -122,13 +129,16 @@ void slotToKeyFlushAsync(void) {
            sizeof(server.cluster->slots_keys_count));
     atomicIncr(lazyfree_objects,old->numele);
     bioCreateBackgroundJob(BIO_LAZY_FREE,NULL,NULL,old);
+    __A_VARIABLE = 1;
 }
 
 /* Release objects from the lazyfree thread. It's just decrRefCount()
  * updating the count of objects to release. */
 void lazyfreeFreeObjectFromBioThread(robj *o) {
+    volatile int __A_VARIABLE;
     decrRefCount(o);
     atomicDecr(lazyfree_objects,1);
+    __A_VARIABLE = 1;
 }
 
 /* Release a database from the lazyfree thread. The 'db' pointer is the
@@ -137,16 +147,20 @@ void lazyfreeFreeObjectFromBioThread(robj *o) {
  * Redis Cluster in order to take the hash slots -> keys mapping. This
  * may be NULL if Redis Cluster is disabled. */
 void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2) {
+    volatile int __A_VARIABLE;
     size_t numkeys = dictSize(ht1);
     dictRelease(ht1);
     dictRelease(ht2);
     atomicDecr(lazyfree_objects,numkeys);
+    __A_VARIABLE = 1;
 }
 
 /* Release the skiplist mapping Redis Cluster keys to slots in the
  * lazyfree thread. */
 void lazyfreeFreeSlotsMapFromBioThread(rax *rt) {
+    volatile int __A_VARIABLE;
     size_t len = rt->numele;
     raxFree(rt);
     atomicDecr(lazyfree_objects,len);
+    __A_VARIABLE = 1;
 }
diff --git a/src/listpack.c b/src/listpack.c
index e1f4d9a..28b0266 100644
--- a/src/listpack.c
+++ b/src/listpack.c
@@ -204,17 +204,24 @@ int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
 /* Create a new, empty listpack.
  * On success the new listpack is returned, otherwise an error is returned. */
 unsigned char *lpNew(void) {
+    volatile int __A_VARIABLE;
     unsigned char *lp = lp_malloc(LP_HDR_SIZE+1);
-    if (lp == NULL) return NULL;
+    if (lp == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     lpSetTotalBytes(lp,LP_HDR_SIZE+1);
     lpSetNumElements(lp,0);
     lp[LP_HDR_SIZE] = LP_EOF;
+    __A_VARIABLE = 1;
     return lp;
 }
 
 /* Free the specified listpack. */
 void lpFree(unsigned char *lp) {
+    volatile int __A_VARIABLE;
     lp_free(lp);
+    __A_VARIABLE = 1;
 }
 
 /* Given an element 'ele' of size 'size', determine if the element can be
@@ -333,6 +340,7 @@ unsigned long lpEncodeBacklen(unsigned char *buf, uint64_t l) {
 /* Decode the backlen and returns it. If the encoding looks invalid (more than
  * 5 bytes are used), UINT64_MAX is returned to report the problem. */
 uint64_t lpDecodeBacklen(unsigned char *p) {
+    volatile int __A_VARIABLE;
     uint64_t val = 0;
     uint64_t shift = 0;
     do {
@@ -340,8 +348,12 @@ uint64_t lpDecodeBacklen(unsigned char *p) {
         if (!(p[0] & 128)) break;
         shift += 7;
         p--;
-        if (shift > 28) return UINT64_MAX;
+        if (shift > 28) {
+            __A_VARIABLE = 1;
+            return UINT64_MAX;
+        }
     } while(1);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -350,6 +362,7 @@ uint64_t lpDecodeBacklen(unsigned char *p) {
  * space for encoding the string. This is done by calling lpEncodeGetType()
  * before calling this function. */
 void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
+    volatile int __A_VARIABLE;
     if (len < 64) {
         buf[0] = len | LP_ENCODING_6BIT_STR;
         memcpy(buf+1,s,len);
@@ -365,21 +378,54 @@ void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
         buf[4] = (len >> 24) & 0xff;
         memcpy(buf+5,s,len);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the encoded length of the listpack element pointed by 'p'. If the
  * element encoding is wrong then 0 is returned. */
 uint32_t lpCurrentEncodedSize(unsigned char *p) {
-    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
-    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
-    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
-    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
-    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
-    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
-    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
-    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
-    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
-    if (p[0] == LP_EOF) return 1;
+    volatile int __A_VARIABLE;
+    if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (LP_ENCODING_IS_6BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 1+LP_ENCODING_6BIT_STR_LEN(p);
+    }
+    if (LP_ENCODING_IS_13BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 2;
+    }
+    if (LP_ENCODING_IS_16BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 3;
+    }
+    if (LP_ENCODING_IS_24BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 4;
+    }
+    if (LP_ENCODING_IS_32BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 5;
+    }
+    if (LP_ENCODING_IS_64BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 9;
+    }
+    if (LP_ENCODING_IS_12BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 2+LP_ENCODING_12BIT_STR_LEN(p);
+    }
+    if (LP_ENCODING_IS_32BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 5+LP_ENCODING_32BIT_STR_LEN(p);
+    }
+    if (p[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -388,9 +434,11 @@ uint32_t lpCurrentEncodedSize(unsigned char *p) {
  * listpack, however, while this function is used to implement lpNext(),
  * it does not return NULL when the EOF element is encountered. */
 unsigned char *lpSkip(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned long entrylen = lpCurrentEncodedSize(p);
     entrylen += lpEncodeBacklen(NULL,entrylen);
     p += entrylen;
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -398,9 +446,14 @@ unsigned char *lpSkip(unsigned char *p) {
  * the pointer to the next element (the one on the right), or NULL if 'p'
  * already pointed to the last element of the listpack. */
 unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
+    volatile int __A_VARIABLE;
     ((void) lp); /* lp is not used for now. However lpPrev() uses it. */
     p = lpSkip(p);
-    if (p[0] == LP_EOF) return NULL;
+    if (p[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -408,25 +461,37 @@ unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
  * the pointer to the preivous element (the one on the left), or NULL if 'p'
  * already pointed to the first element of the listpack. */
 unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
-    if (p-lp == LP_HDR_SIZE) return NULL;
+    volatile int __A_VARIABLE;
+    if (p-lp == LP_HDR_SIZE) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     p--; /* Seek the first backlen byte of the last element. */
     uint64_t prevlen = lpDecodeBacklen(p);
     prevlen += lpEncodeBacklen(NULL,prevlen);
+    __A_VARIABLE = 1;
     return p-prevlen+1; /* Seek the first byte of the previous entry. */
 }
 
 /* Return a pointer to the first element of the listpack, or NULL if the
  * listpack has no elements. */
 unsigned char *lpFirst(unsigned char *lp) {
+    volatile int __A_VARIABLE;
     lp += LP_HDR_SIZE; /* Skip the header. */
-    if (lp[0] == LP_EOF) return NULL;
+    if (lp[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return lp;
 }
 
 /* Return a pointer to the last element of the listpack, or NULL if the
  * listpack has no elements. */
 unsigned char *lpLast(unsigned char *lp) {
+    volatile int __A_VARIABLE;
     unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
+    __A_VARIABLE = 1;
     return lpPrev(lp,p); /* Will return NULL if EOF is the only element. */
 }
 
@@ -436,8 +501,12 @@ unsigned char *lpLast(unsigned char *lp) {
  * could be modified, because if the count is found to be already within
  * the 'numele' header field range, the new value is set. */
 uint32_t lpLength(unsigned char *lp) {
+    volatile int __A_VARIABLE;
     uint32_t numele = lpGetNumElements(lp);
-    if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;
+    if (numele != LP_HDR_NUMELE_UNKNOWN) {
+        __A_VARIABLE = 1;
+        return numele;
+    }
 
     /* Too many elements inside the listpack. We need to scan in order
      * to get the total number. */
@@ -451,6 +520,7 @@ uint32_t lpLength(unsigned char *lp) {
     /* If the count is again within range of the header numele field,
      * set it. */
     if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -593,6 +663,7 @@ unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
  * element, on the right of the deleted one, or to NULL if the deleted element
  * was the last one. */
 unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, unsigned char *p, int where, unsigned char **newp) {
+    volatile int __A_VARIABLE;
     unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
     unsigned char backlen[LP_MAX_BACKLEN_SIZE];
 
@@ -645,7 +716,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     uint64_t new_listpack_bytes = old_listpack_bytes + enclen + backlen_size
                                   - replaced_len;
-    if (new_listpack_bytes > UINT32_MAX) return NULL;
+    if (new_listpack_bytes > UINT32_MAX) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* We now need to reallocate in order to make space or shrink the
      * allocation (in case 'when' value is LP_REPLACE and the new element is
@@ -657,7 +731,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     /* Realloc before: we need more room. */
     if (new_listpack_bytes > old_listpack_bytes) {
-        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
+        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         dst = lp + poff;
     }
 
@@ -674,7 +751,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     /* Realloc after: we need to free space. */
     if (new_listpack_bytes < old_listpack_bytes) {
-        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
+        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         dst = lp + poff;
     }
 
@@ -727,6 +807,7 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
     lp_free(oldlp);
 #endif
 
+    __A_VARIABLE = 1;
     return lp;
 }
 
@@ -734,8 +815,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
  * listpack. It is implemented in terms of lpInsert(), so the return value is
  * the same as lpInsert(). */
 unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
+    volatile int __A_VARIABLE;
     uint64_t listpack_bytes = lpGetTotalBytes(lp);
     unsigned char *eofptr = lp + listpack_bytes - 1;
+    __A_VARIABLE = 1;
     return lpInsert(lp,ele,size,eofptr,LP_BEFORE,NULL);
 }
 
@@ -744,11 +827,15 @@ unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
  * deleted one) is returned by reference. If the deleted element was the
  * last one, '*newp' is set to NULL. */
 unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return lpInsert(lp,NULL,0,p,LP_REPLACE,newp);
 }
 
 /* Return the total number of bytes the listpack is composed of. */
 uint32_t lpBytes(unsigned char *lp) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return lpGetTotalBytes(lp);
 }
 
diff --git a/src/localtime.c b/src/localtime.c
index 3f59a33..38b74f1 100644
--- a/src/localtime.c
+++ b/src/localtime.c
@@ -57,6 +57,7 @@ static int is_leap_year(time_t year) {
 }
 
 void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
+    volatile int __A_VARIABLE;
     const time_t secs_min = 60;
     const time_t secs_hour = 3600;
     const time_t secs_day = 3600*24;
@@ -101,12 +102,14 @@ void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
 
     tmp->tm_mday = days+1;  /* Add 1 since our 'days' is zero-based. */
     tmp->tm_year -= 1900;   /* Surprisingly tm_year is year-1900. */
+    __A_VARIABLE = 1;
 }
 
 #ifdef LOCALTIME_TEST_MAIN
 #include <stdio.h>
 
 int main(void) {
+    volatile int __A_VARIABLE;
     /* Obtain timezone and daylight info. */
     tzset(); /* Now 'timezome' global is populated. */
     time_t t = time(NULL);
@@ -119,5 +122,6 @@ int main(void) {
     nolocks_localtime(&tm,t,timezone,daylight_active);
     strftime(buf,sizeof(buf),"%d %b %H:%M:%S",&tm);
     printf("[timezone: %d, dl: %d] %s\n", (int)timezone, (int)daylight_active, buf);
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/src/lolwut.c b/src/lolwut.c
index 19cbcf6..f457229 100644
--- a/src/lolwut.c
+++ b/src/lolwut.c
@@ -40,17 +40,21 @@ void lolwut5Command(client *c);
 /* The default target for LOLWUT if no matching version was found.
  * This is what unstable versions of Redis will display. */
 void lolwutUnstableCommand(client *c) {
+    volatile int __A_VARIABLE;
     sds rendered = sdsnew("Redis ver. ");
     rendered = sdscat(rendered,REDIS_VERSION);
     rendered = sdscatlen(rendered,"\n",1);
     addReplyBulkSds(c,rendered);
+    __A_VARIABLE = 1;
 }
 
 void lolwutCommand(client *c) {
+    volatile int __A_VARIABLE;
     char *v = REDIS_VERSION;
     if ((v[0] == '5' && v[1] == '.') ||
         (v[0] == '4' && v[1] == '.' && v[2] == '9'))
         lolwut5Command(c);
     else
         lolwutUnstableCommand(c);
+    __A_VARIABLE = 1;
 }
diff --git a/src/lolwut5.c b/src/lolwut5.c
index 8408b37..226a821 100644
--- a/src/lolwut5.c
+++ b/src/lolwut5.c
@@ -60,6 +60,7 @@ typedef struct lwCanvas {
  */
 #include <stdio.h>
 void lwTranslatePixelsGroup(int byte, char *output) {
+    volatile int __A_VARIABLE;
     int code = 0x2800 + byte;
     /* Convert to unicode. This is in the U0800-UFFFF range, so we need to
      * emit it like this in three bytes:
@@ -67,22 +68,27 @@ void lwTranslatePixelsGroup(int byte, char *output) {
     output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
     output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
     output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
+    __A_VARIABLE = 1;
 }
 
 /* Allocate and return a new canvas of the specified size. */
 lwCanvas *lwCreateCanvas(int width, int height) {
+    volatile int __A_VARIABLE;
     lwCanvas *canvas = zmalloc(sizeof(*canvas));
     canvas->width = width;
     canvas->height = height;
     canvas->pixels = zmalloc(width*height);
     memset(canvas->pixels,0,width*height);
+    __A_VARIABLE = 1;
     return canvas;
 }
 
 /* Free the canvas created by lwCreateCanvas(). */
 void lwFreeCanvas(lwCanvas *canvas) {
+    volatile int __A_VARIABLE;
     zfree(canvas->pixels);
     zfree(canvas);
+    __A_VARIABLE = 1;
 }
 
 /* Set a pixel to the specified color. Color is 0 or 1, where zero means no
@@ -90,20 +96,31 @@ void lwFreeCanvas(lwCanvas *canvas) {
  * Coordinates are arranged so that left-top corner is 0,0. You can write
  * out of the size of the canvas without issues. */
 void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {
+    volatile int __A_VARIABLE;
     if (x < 0 || x >= canvas->width ||
-        y < 0 || y >= canvas->height) return;
+        y < 0 || y >= canvas->height) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     canvas->pixels[x+y*canvas->width] = color;
+    __A_VARIABLE = 1;
 }
 
 /* Return the value of the specified pixel on the canvas. */
 int lwGetPixel(lwCanvas *canvas, int x, int y) {
+    volatile int __A_VARIABLE;
     if (x < 0 || x >= canvas->width ||
-        y < 0 || y >= canvas->height) return 0;
+        y < 0 || y >= canvas->height) {
+    	__A_VARIABLE = 1;
+    	return 0;
+    }
+    __A_VARIABLE = 1;
     return canvas->pixels[x+y*canvas->width];
 }
 
 /* Draw a line from x1,y1 to x2,y2 using the Bresenham algorithm. */
 void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
+    volatile int __A_VARIABLE;
     int dx = abs(x2-x1);
     int dy = abs(y2-y1);
     int sx = (x1 < x2) ? 1 : -1;
@@ -123,6 +140,7 @@ void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
             y1 += sy;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Draw a square centered at the specified x,y coordinates, with the specified
@@ -145,6 +163,7 @@ void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
  * performing the rotation/translation transformation, so for LOLWUT it's
  * a good approach. */
 void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle) {
+    volatile int __A_VARIABLE;
     int px[4], py[4];
 
     /* Adjust the desired size according to the fact that the square inscribed
@@ -165,6 +184,7 @@ void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle) {
     /* Draw the square. */
     for (int j = 0; j < 4; j++)
         lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],1);
+    __A_VARIABLE = 1;
 }
 
 /* Schotter, the output of LOLWUT of Redis 5, is a computer graphic art piece
@@ -175,6 +195,7 @@ void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle) {
  * in the output display and the number of squares per row and per column
  * requested by the caller. */
 lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_col) {
+    volatile int __A_VARIABLE;
     /* Calculate the canvas size. */
     int canvas_width = console_cols*2;
     int padding = canvas_width > 4 ? 2 : 0;
@@ -204,6 +225,7 @@ lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_
         }
     }
 
+    __A_VARIABLE = 1;
     return canvas;
 }
 
@@ -213,6 +235,7 @@ lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_
  * width/2 large and height/4 tall in order to hold the whole image without
  * overflowing or scrolling, since each Barille character is 2x4. */
 sds lwRenderCanvas(lwCanvas *canvas) {
+    volatile int __A_VARIABLE;
     sds text = sdsempty();
     for (int y = 0; y < canvas->height; y += 4) {
         for (int x = 0; x < canvas->width; x += 2) {
@@ -233,6 +256,7 @@ sds lwRenderCanvas(lwCanvas *canvas) {
         }
         if (y != canvas->height-1) text = sdscatlen(text,"\n",1);
     }
+    __A_VARIABLE = 1;
     return text;
 }
 
@@ -244,22 +268,29 @@ sds lwRenderCanvas(lwCanvas *canvas) {
  * per column.
  */
 void lolwut5Command(client *c) {
+    volatile int __A_VARIABLE;
     long cols = 66;
     long squares_per_row = 8;
     long squares_per_col = 12;
 
     /* Parse the optional arguments if any. */
     if (c->argc > 1 &&
-        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (c->argc > 2 &&
-        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (c->argc > 3 &&
-        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
      * so we have maximum number of columns, rows, and output resulution. */
@@ -279,4 +310,5 @@ void lolwut5Command(client *c) {
     rendered = sdscatlen(rendered,"\n",1);
     addReplyBulkSds(c,rendered);
     lwFreeCanvas(canvas);
+    __A_VARIABLE = 1;
 }
diff --git a/src/memtest.c b/src/memtest.c
index a455430..4a7972d 100644
--- a/src/memtest.c
+++ b/src/memtest.c
@@ -61,6 +61,7 @@ size_t progress_printed; /* Printed chars in screen-wide progress bar. */
 size_t progress_full; /* How many chars to write to fill the progress bar. */
 
 void memtest_progress_start(char *title, int pass) {
+    volatile int __A_VARIABLE;
     int j;
 
     printf("\x1b[H\x1b[2J");    /* Cursor home, clear screen. */
@@ -73,24 +74,30 @@ void memtest_progress_start(char *title, int pass) {
     progress_printed = 0;
     progress_full = ws.ws_col*(ws.ws_row-3);
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 void memtest_progress_end(void) {
+    volatile int __A_VARIABLE;
     printf("\x1b[H\x1b[2J");    /* Cursor home, clear screen. */
+    __A_VARIABLE = 1;
 }
 
 void memtest_progress_step(size_t curr, size_t size, char c) {
+    volatile int __A_VARIABLE;
     size_t chars = ((unsigned long long)curr*progress_full)/size, j;
 
     for (j = 0; j < chars-progress_printed; j++) printf("%c",c);
     progress_printed = chars;
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Test that addressing is fine. Every location is populated with its own
  * address, and finally verified. This test is very fast but may detect
  * ASAP big issues with the memory subsystem. */
 int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
+    volatile int __A_VARIABLE;
     unsigned long words = bytes/sizeof(unsigned long);
     unsigned long j, *p;
 
@@ -111,12 +118,14 @@ int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
                     (void*) p, *p);
                 exit(1);
             }
+            __A_VARIABLE = 1;
             return 1;
         }
         p++;
         if ((j & 0xffff) == 0 && interactive)
             memtest_progress_step(j+words,words*2,'A');
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -136,6 +145,7 @@ int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
 } while(0)
 
 void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
+    volatile int __A_VARIABLE;
     unsigned long step = 4096/sizeof(unsigned long);
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long iwords = words/step;  /* words per iteration */
@@ -156,6 +166,7 @@ void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
                 memtest_progress_step(w+iwords*off,words,'R');
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Like memtest_fill_random() but uses the two specified values to fill
@@ -163,6 +174,7 @@ void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
 void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                         unsigned long v2, char sym, int interactive)
 {
+    volatile int __A_VARIABLE;
     unsigned long step = 4096/sizeof(unsigned long);
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long iwords = words/step;  /* words per iteration */
@@ -189,9 +201,11 @@ void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                 memtest_progress_step(w+iwords*off,words,sym);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
+    volatile int __A_VARIABLE;
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long w, *l1, *l2;
 
@@ -205,6 +219,7 @@ int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
                     (void*)l1, (void*)l2, *l1, *l2);
                 exit(1);
             }
+            __A_VARIABLE = 1;
             return 1;
         }
         l1 ++;
@@ -212,12 +227,14 @@ int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
         if ((w & 0xffff) == 0 && interactive)
             memtest_progress_step(w,words,'=');
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
                           int interactive)
 {
+    volatile int __A_VARIABLE;
     int j;
     int errors = 0;
 
@@ -226,6 +243,7 @@ int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
         errors += memtest_compare(m,bytes,interactive);
         if (interactive) memtest_progress_end();
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -235,6 +253,7 @@ int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
  * be used as an API call, and returns 1 if memory errors were found or
  * 0 if there were no errors detected. */
 int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
+    volatile int __A_VARIABLE;
     int pass = 0;
     int errors = 0;
 
@@ -260,6 +279,7 @@ int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
         if (interactive) memtest_progress_end();
         errors += memtest_compare_times(m,bytes,pass,4,interactive);
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -278,14 +298,21 @@ int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
  * the cache. */
 #define MEMTEST_DECACHE_SIZE (1024*8)
 int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
+    volatile int __A_VARIABLE;
     unsigned long backup[MEMTEST_BACKUP_WORDS];
     unsigned long *p = m;
     unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));
     size_t left = bytes;
     int errors = 0;
 
-    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
-    if (bytes < 4096*2) return 0; /* Can't test a single page. */
+    if (bytes & 4095) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Can't test across 4k page boundaries. */
+    if (bytes < 4096*2) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Can't test a single page. */
 
     while(left) {
         /* If we have to test a single final page, go back a single page
@@ -329,11 +356,13 @@ int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
         left -= len;
         p += len/sizeof(unsigned long);
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
 /* Perform an interactive test allocating the specified number of megabytes. */
 void memtest_alloc_and_test(size_t megabytes, int passes) {
+    volatile int __A_VARIABLE;
     size_t bytes = megabytes*1024*1024;
     unsigned long *m = malloc(bytes);
 
@@ -344,9 +373,11 @@ void memtest_alloc_and_test(size_t megabytes, int passes) {
     }
     memtest_test(m,bytes,passes,1);
     free(m);
+    __A_VARIABLE = 1;
 }
 
 void memtest(size_t megabytes, int passes) {
+    volatile int __A_VARIABLE;
     if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
         ws.ws_col = 80;
         ws.ws_row = 20;
@@ -357,4 +388,5 @@ void memtest(size_t megabytes, int passes) {
     printf("1) memtest86: http://www.memtest86.com/\n");
     printf("2) memtester: http://pyropus.ca/software/memtester/\n");
     exit(0);
+    __A_VARIABLE = 1;
 }
diff --git a/src/module.c b/src/module.c
index d55bb4e..ba82bdf 100644
--- a/src/module.c
+++ b/src/module.c
@@ -314,6 +314,8 @@ void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);
  * and in general is taken into account as memory allocated by Redis.
  * You should avoid using malloc(). */
 void *RM_Alloc(size_t bytes) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zmalloc(bytes);
 }
 
@@ -322,11 +324,15 @@ void *RM_Alloc(size_t bytes) {
  * and in general is taken into account as memory allocated by Redis.
  * You should avoid using calloc() directly. */
 void *RM_Calloc(size_t nmemb, size_t size) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zcalloc(nmemb*size);
 }
 
 /* Use like realloc() for memory obtained with RedisModule_Alloc(). */
 void* RM_Realloc(void *ptr, size_t bytes) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zrealloc(ptr,bytes);
 }
 
@@ -334,11 +340,15 @@ void* RM_Realloc(void *ptr, size_t bytes) {
  * RedisModule_Realloc(). However you should never try to free with
  * RedisModule_Free() memory allocated with malloc() inside your module. */
 void RM_Free(void *ptr) {
+    volatile int __A_VARIABLE;
     zfree(ptr);
+    __A_VARIABLE = 1;
 }
 
 /* Like strdup() but returns memory allocated with RedisModule_Alloc(). */
 char *RM_Strdup(const char *str) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zstrdup(str);
 }
 
@@ -348,6 +358,7 @@ char *RM_Strdup(const char *str) {
 
 /* Release the chain of blocks used for pool allocations. */
 void poolAllocRelease(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     RedisModulePoolAllocBlock *head = ctx->pa_head, *next;
 
     while(head != NULL) {
@@ -356,6 +367,7 @@ void poolAllocRelease(RedisModuleCtx *ctx) {
         head = next;
     }
     ctx->pa_head = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Return heap allocated memory that will be freed automatically when the
@@ -371,7 +383,11 @@ void poolAllocRelease(RedisModuleCtx *ctx) {
  *
  * The function returns NULL if `bytes` is 0. */
 void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
-    if (bytes == 0) return NULL;
+    volatile int __A_VARIABLE;
+    if (bytes == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     RedisModulePoolAllocBlock *b = ctx->pa_head;
     size_t left = b ? b->size - b->used : 0;
 
@@ -397,6 +413,7 @@ void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
 
     char *retval = b->memory + b->used;
     b->used += bytes;
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -417,11 +434,14 @@ void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
  * 3) The specified type is unknown.
  */
 int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
+    volatile int __A_VARIABLE;
     robj *obj;
 
     /* The key must be open for writing and non existing to proceed. */
-    if (!(key->mode & REDISMODULE_WRITE) || key->value)
+    if (!(key->mode & REDISMODULE_WRITE) || key->value) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     switch(type) {
     case REDISMODULE_KEYTYPE_LIST:
@@ -435,10 +455,12 @@ int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
     case REDISMODULE_KEYTYPE_HASH:
         obj = createHashObject();
         break;
-    default: return REDISMODULE_ERR;
+    default: __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
     }
     dbAdd(key->db,key->key,obj);
     key->value = obj;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -491,14 +513,20 @@ int moduleDelKeyIfEmpty(RedisModuleKey *key) {
  * This function is not meant to be used by modules developer, it is only
  * used implicitly by including redismodule.h. */
 int RM_GetApi(const char *funcname, void **targetPtrPtr) {
+    volatile int __A_VARIABLE;
     dictEntry *he = dictFind(server.moduleapi, funcname);
-    if (!he) return REDISMODULE_ERR;
+    if (!he) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     *targetPtrPtr = dictGetVal(he);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* Free the context after the user function was called. */
 void moduleFreeContext(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     autoMemoryCollect(ctx);
     poolAllocRelease(ctx);
     if (ctx->postponed_arrays) {
@@ -512,14 +540,19 @@ void moduleFreeContext(RedisModuleCtx *ctx) {
             ctx->module->name);
     }
     if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx->client);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for when a command callback is called, in order to handle
  * details needed to correctly replicate commands. */
 void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     client *c = ctx->client;
 
-    if (c->flags & CLIENT_LUA) return;
+    if (c->flags & CLIENT_LUA) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Handle the replication of the final EXEC, since whatever a command
      * emits is always wrapped around MULTI/EXEC. */
@@ -530,11 +563,13 @@ void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
             PROPAGATE_AOF|PROPAGATE_REPL);
         decrRefCount(propargv[0]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This Redis command binds the normal Redis command invocation with commands
  * exported by modules. */
 void RedisModuleCommandDispatcher(client *c) {
+    volatile int __A_VARIABLE;
     RedisModuleCommandProxy *cp = (void*)(unsigned long)c->cmd->getkeys_proc;
     RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
 
@@ -559,6 +594,7 @@ void RedisModuleCommandDispatcher(client *c) {
         if (c->argv[i]->refcount > 1)
             trimStringObjectIfNeeded(c->argv[i]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the list of keys, with the same interface as the
@@ -571,6 +607,7 @@ void RedisModuleCommandDispatcher(client *c) {
  * the context in a way that the command can recognize this is a special
  * "get keys" call by calling RedisModule_IsKeysPositionRequest(ctx). */
 int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
+    volatile int __A_VARIABLE;
     RedisModuleCommandProxy *cp = (void*)(unsigned long)cmd->getkeys_proc;
     RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
 
@@ -581,6 +618,7 @@ int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc,
     int *res = ctx.keys_pos;
     if (numkeys) *numkeys = ctx.keys_count;
     moduleFreeContext(&ctx);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -588,6 +626,8 @@ int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc,
  * flag "getkeys-api", is called in a special way to get the keys positions
  * and not to get executed. Otherwise zero is returned. */
 int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
 }
 
@@ -606,10 +646,18 @@ int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
  *  keys are at fixed positions. This interface is only used for commands
  *  with a more complex structure. */
 void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
-    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) return;
-    if (pos <= 0) return;
+    volatile int __A_VARIABLE;
+    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
+    if (pos <= 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));
     ctx->keys_pos[ctx->keys_count++] = pos;
+    __A_VARIABLE = 1;
 }
 
 /* Helper for RM_CreateCommand(). Turns a string representing command
@@ -617,6 +665,7 @@ void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
  *
  * It returns the set of flags, or -1 if unknown flags are found. */
 int commandFlagsFromString(char *s) {
+    volatile int __A_VARIABLE;
     int count, j;
     int flags = 0;
     sds *tokens = sdssplitlen(s,strlen(s)," ",1,&count);
@@ -638,7 +687,11 @@ int commandFlagsFromString(char *s) {
         else break;
     }
     sdsfreesplitres(tokens,count);
-    if (j != count) return -1; /* Some token not processed correctly. */
+    if (j != count) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Some token not processed correctly. */
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -696,10 +749,16 @@ int commandFlagsFromString(char *s) {
  *                     other reason.
  */
 int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
+    volatile int __A_VARIABLE;
     int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
-    if (flags == -1) return REDISMODULE_ERR;
-    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
+    if (flags == -1) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     struct redisCommand *rediscmd;
     RedisModuleCommandProxy *cp;
@@ -708,6 +767,7 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
     /* Check if the command name is busy. */
     if (lookupCommand(cmdname) != NULL) {
         sdsfree(cmdname);
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
 
@@ -734,6 +794,7 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
     cp->rediscmd->calls = 0;
     dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);
     dictAdd(server.orig_commands,sdsdup(cmdname),cp->rediscmd);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -742,9 +803,13 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
  * This is an internal function, Redis modules developers don't need
  * to use it. */
 void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
+    volatile int __A_VARIABLE;
     RedisModule *module;
 
-    if (ctx->module != NULL) return;
+    if (ctx->module != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     module = zmalloc(sizeof(*module));
     module->name = sdsnew((char*)name);
     module->ver = ver;
@@ -755,19 +820,24 @@ void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int api
     module->filters = listCreate();
     module->in_call = 0;
     ctx->module = module;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if the module name is busy.
  * Otherwise zero is returned. */
 int RM_IsModuleNameBusy(const char *name) {
+    volatile int __A_VARIABLE;
     sds modulename = sdsnew(name);
     dictEntry *de = dictFind(modules,modulename);
     sdsfree(modulename);
+    __A_VARIABLE = 1;
     return de != NULL;
 }
 
 /* Return the current UNIX time in milliseconds. */
 long long RM_Milliseconds(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return mstime();
 }
 
@@ -780,12 +850,18 @@ long long RM_Milliseconds(void) {
  * The function must be called as the first function of a command implementation
  * that wants to use automatic memory. */
 void RM_AutoMemory(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
+    __A_VARIABLE = 1;
 }
 
 /* Add a new object to release automatically when the callback returns. */
 void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
+    volatile int __A_VARIABLE;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (ctx->amqueue_used == ctx->amqueue_len) {
         ctx->amqueue_len *= 2;
         if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
@@ -794,6 +870,7 @@ void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
     ctx->amqueue[ctx->amqueue_used].type = type;
     ctx->amqueue[ctx->amqueue_used].ptr = ptr;
     ctx->amqueue_used++;
+    __A_VARIABLE = 1;
 }
 
 /* Mark an object as freed in the auto release queue, so that users can still
@@ -802,7 +879,11 @@ void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
  * The function returns 1 if the object was actually found in the auto memory
  * pool, otherwise 0 is returned. */
 int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;
+    volatile int __A_VARIABLE;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     int count = (ctx->amqueue_used+1)/2;
     for (int j = 0; j < count; j++) {
@@ -824,16 +905,22 @@ int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
                 /* Reduce the size of the queue because we either moved the top
                  * element elsewhere or freed it */
                 ctx->amqueue_used--;
+                __A_VARIABLE = 1;
                 return 1;
             }
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Release all the objects in queue. */
 void autoMemoryCollect(RedisModuleCtx *ctx) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
+    volatile int __A_VARIABLE;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Clear the AUTO_MEMORY flag from the context, otherwise the functions
      * we call to free the resources, will try to scan the auto release
      * queue to mark the entries as freed. */
@@ -853,6 +940,7 @@ void autoMemoryCollect(RedisModuleCtx *ctx) {
     ctx->amqueue = NULL;
     ctx->amqueue_len = 0;
     ctx->amqueue_used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -870,8 +958,10 @@ void autoMemoryCollect(RedisModuleCtx *ctx) {
  * memory management will not be available, and the string memory must be
  * managed manually. */
 RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
+    volatile int __A_VARIABLE;
     RedisModuleString *o = createStringObject(ptr,len);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -884,6 +974,7 @@ RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t
  * The passed context 'ctx' may be NULL if necessary, see the
  * RedisModule_CreateString() documentation for more info. */
 RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     sds s = sdsempty();
 
     va_list ap;
@@ -894,6 +985,7 @@ RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, .
     RedisModuleString *o = createObject(OBJ_STRING, s);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
 
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -907,8 +999,10 @@ RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, .
  * The passed context 'ctx' may be NULL if necessary, see the
  * RedisModule_CreateString() documentation for more info. */
 RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {
+    volatile int __A_VARIABLE;
     char buf[LONG_STR_SIZE];
     size_t len = ll2string(buf,sizeof(buf),ll);
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,buf,len);
 }
 
@@ -921,8 +1015,10 @@ RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll
  * The passed context 'ctx' may be NULL if necessary, see the
  * RedisModule_CreateString() documentation for more info. */
 RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
+    volatile int __A_VARIABLE;
     RedisModuleString *o = dupStringObject(str);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -939,8 +1035,10 @@ RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisMod
  * the context, so if you want to free a string out of context later, make sure
  * to create it using a NULL context. */
 void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
+    volatile int __A_VARIABLE;
     decrRefCount(str);
     if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
+    __A_VARIABLE = 1;
 }
 
 /* Every call to this function, will make the string 'str' requiring
@@ -968,6 +1066,7 @@ void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
  *
  * It is possible to call this function with a NULL context. */
 void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
+    volatile int __A_VARIABLE;
     if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
         /* Increment the string reference counting only if we can't
          * just remove the object from the list of objects that should
@@ -980,18 +1079,22 @@ void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
          * like RedisModule_StringAppendBuffer() to work. */
         incrRefCount(str);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Given a string module object, this function returns the string pointer
  * and length of the string. The returned pointer and length should only
  * be used for read only accesses and never modified. */
 const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
+    volatile int __A_VARIABLE;
     if (str == NULL) {
         const char *errmsg = "(NULL string reply referenced in module)";
         if (len) *len = strlen(errmsg);
+        __A_VARIABLE = 1;
         return errmsg;
     }
     if (len) *len = sdslen(str->ptr);
+    __A_VARIABLE = 1;
     return str->ptr;
 }
 
@@ -1004,6 +1107,8 @@ const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
  * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR
  * is returned. */
 int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :
                                                      REDISMODULE_ERR;
 }
@@ -1012,7 +1117,9 @@ int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
  * Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is
  * not a valid string representation of a double value. */
 int RM_StringToDouble(const RedisModuleString *str, double *d) {
+    volatile int __A_VARIABLE;
     int retval = getDoubleFromObject(str,d);
+    __A_VARIABLE = 1;
     return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -1020,17 +1127,21 @@ int RM_StringToDouble(const RedisModuleString *str, double *d) {
  * a < b, a == b, a > b. Strings are compared byte by byte as two
  * binary blobs without any encoding care / collation attempt. */
 int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return compareStringObjects(a,b);
 }
 
 /* Return the (possibly modified in encoding) input 'str' object if
  * the string is unshared, otherwise NULL is returned. */
 RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
+    volatile int __A_VARIABLE;
     if (str->refcount != 1) {
         serverLog(LL_WARNING,
             "Module attempted to use an in-place string modify operation "
             "with a string referenced multiple times. Please check the code "
             "for API usage correctness.");
+        __A_VARIABLE = 1;
         return NULL;
     }
     if (str->encoding == OBJ_ENCODING_EMBSTR) {
@@ -1043,6 +1154,7 @@ RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
         str->ptr = sdsfromlonglong((long)str->ptr);
         str->encoding = OBJ_ENCODING_RAW;
     }
+    __A_VARIABLE = 1;
     return str;
 }
 
@@ -1050,10 +1162,15 @@ RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
  * string created by the user that is referenced only a single time, otherwise
  * REDISMODULE_ERR is returned and the operation is not performed. */
 int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
     str = moduleAssertUnsharedString(str);
-    if (str == NULL) return REDISMODULE_ERR;
+    if (str == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     str->ptr = sdscatlen(str->ptr,buf,len);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1075,9 +1192,11 @@ int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const cha
  *     if (argc != 3) return RedisModule_WrongArity(ctx);
  */
 int RM_WrongArity(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     addReplyErrorFormat(ctx->client,
         "wrong number of arguments for '%s' command",
         (char*)ctx->client->argv[0]->ptr);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1113,9 +1232,14 @@ client *moduleGetReplyClient(RedisModuleCtx *ctx) {
 /* Send an integer reply to the client, with the specified long long value.
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyLongLong(c,ll);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1123,12 +1247,17 @@ int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
  * ReplyWithSimpleString() and ReplyWithError().
  * The function always returns REDISMODULE_OK. */
 int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     sds strmsg = sdsnewlen(prefix,1);
     strmsg = sdscat(strmsg,msg);
     strmsg = sdscatlen(strmsg,"\r\n",2);
     addReplySds(c,strmsg);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1147,6 +1276,8 @@ int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
  * The function always returns REDISMODULE_OK.
  */
 int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return replyWithStatus(ctx,err,"-");
 }
 
@@ -1156,6 +1287,8 @@ int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return replyWithStatus(ctx,msg,"+");
 }
 
@@ -1171,8 +1304,12 @@ int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {
         ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*
                 (ctx->postponed_arrays_count+1));
@@ -1182,6 +1319,7 @@ int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
     } else {
         addReplyMultiBulkLen(c,len);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1212,14 +1350,19 @@ int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
  * that is not easy to calculate in advance the number of elements.
  */
 void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (ctx->postponed_arrays_count == 0) {
         serverLog(LL_WARNING,
             "API misuse detected in module %s: "
             "RedisModule_ReplySetArrayLength() called without previous "
             "RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) "
             "call.", ctx->module->name);
+            __A_VARIABLE = 1;
             return;
     }
     ctx->postponed_arrays_count--;
@@ -1230,15 +1373,21 @@ void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
         zfree(ctx->postponed_arrays);
         ctx->postponed_arrays = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Reply with a bulk string, taking in input a C buffer pointer and length.
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulkCBuffer(c,(char*)buf,len);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1247,9 +1396,14 @@ int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulkCString(c,(char*)buf);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1257,9 +1411,14 @@ int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulk(c,str);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1268,9 +1427,14 @@ int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithNull(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReply(c,shared.nullbulk);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1281,10 +1445,15 @@ int RM_ReplyWithNull(RedisModuleCtx *ctx) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     sds proto = sdsnewlen(reply->proto, reply->protolen);
     addReplySds(c,proto);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1295,9 +1464,14 @@ int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
+    volatile int __A_VARIABLE;
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyDouble(c,d);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1309,17 +1483,28 @@ int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
  * in the context of a command execution. EXEC will be handled by the
  * RedisModuleCommandDispatcher() function. */
 void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     /* Skip this if client explicitly wrap the command with MULTI, or if
      * the module command was called by a script. */
-    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) return;
+    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* If we already emitted MULTI return ASAP. */
-    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) return;
+    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* If this is a thread safe context, we do not want to wrap commands
      * executed into MUTLI/EXEC, they are executed as single commands
      * from an external client in essence. */
-    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) return;
+    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
+        __A_VARIABLE = 1;
+        return;
+    }
     execCommandPropagateMulti(ctx->client);
     ctx->flags |= REDISMODULE_CTX_MULTI_EMITTED;
+    __A_VARIABLE = 1;
 }
 
 /* Replicate the specified command and arguments to slaves and AOF, as effect
@@ -1342,19 +1527,26 @@ void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {
  * The command returns REDISMODULE_ERR if the format specifiers are invalid
  * or the command name does not belong to a known command. */
 int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     struct redisCommand *cmd;
     robj **argv = NULL;
     int argc = 0, flags = 0, j;
     va_list ap;
 
     cmd = lookupCommandByCString((char*)cmdname);
-    if (!cmd) return REDISMODULE_ERR;
+    if (!cmd) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Create the client and dispatch the command. */
     va_start(ap, fmt);
     argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
     va_end(ap);
-    if (argv == NULL) return REDISMODULE_ERR;
+    if (argv == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Replicate! */
     moduleReplicateMultiIfNeeded(ctx);
@@ -1365,6 +1557,7 @@ int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
     for (j = 0; j < argc; j++) decrRefCount(argv[j]);
     zfree(argv);
     server.dirty++;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1380,10 +1573,12 @@ int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     alsoPropagate(ctx->client->cmd,ctx->client->db->id,
         ctx->client->argv,ctx->client->argc,
         PROPAGATE_AOF|PROPAGATE_REPL);
     server.dirty++;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1403,12 +1598,19 @@ int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
  * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way
  * to fetch the ID in the context the function was currently called. */
 unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {
-    if (ctx->client == NULL) return 0;
+    volatile int __A_VARIABLE;
+    if (ctx->client == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return ctx->client->id;
 }
 
 /* Return the currently selected DB. */
 int RM_GetSelectedDb(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ctx->client->db->id;
 }
 
@@ -1450,6 +1652,7 @@ int RM_GetSelectedDb(RedisModuleCtx *ctx) {
  *                                       reaching the maxmemory level.
  */
 int RM_GetContextFlags(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
 
     int flags = 0;
     /* Client specific flags */
@@ -1498,6 +1701,7 @@ int RM_GetContextFlags(RedisModuleCtx *ctx) {
     if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;
     if (level > 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;
 
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -1512,7 +1716,9 @@ int RM_GetContextFlags(RedisModuleCtx *ctx) {
  * returns back to the original one, it should call RedisModule_GetSelectedDb()
  * before in order to restore the old DB number before returning. */
 int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
+    volatile int __A_VARIABLE;
     int retval = selectDb(ctx->client,newid);
+    __A_VARIABLE = 1;
     return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -1559,29 +1765,45 @@ void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
 
 /* Close a key handle. */
 void RM_CloseKey(RedisModuleKey *key) {
-    if (key == NULL) return;
+    volatile int __A_VARIABLE;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (key->mode & REDISMODULE_WRITE) signalModifiedKey(key->db,key->key);
     /* TODO: if (key->iter) RM_KeyIteratorStop(kp); */
     RM_ZsetRangeStop(key);
     decrRefCount(key->key);
     autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);
     zfree(key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the type of the key. If the key pointer is NULL then
  * REDISMODULE_KEYTYPE_EMPTY is returned. */
 int RM_KeyType(RedisModuleKey *key) {
-    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
+    volatile int __A_VARIABLE;
+    if (key == NULL || key->value ==  NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_EMPTY;
+    }
     /* We map between defines so that we are free to change the internal
      * defines as desired. */
     switch(key->value->type) {
-    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
-    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
-    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
-    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
-    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
-    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
-    default: return 0;
+    case OBJ_STRING: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_STRING;
+    case OBJ_LIST: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_LIST;
+    case OBJ_SET: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_SET;
+    case OBJ_ZSET: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_ZSET;
+    case OBJ_HASH: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_HASH;
+    case OBJ_MODULE: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_MODULE;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1591,14 +1813,24 @@ int RM_KeyType(RedisModuleKey *key) {
  *
  * If the key pointer is NULL or the key is empty, zero is returned. */
 size_t RM_ValueLength(RedisModuleKey *key) {
-    if (key == NULL || key->value == NULL) return 0;
+    volatile int __A_VARIABLE;
+    if (key == NULL || key->value == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     switch(key->value->type) {
-    case OBJ_STRING: return stringObjectLen(key->value);
-    case OBJ_LIST: return listTypeLength(key->value);
-    case OBJ_SET: return setTypeSize(key->value);
-    case OBJ_ZSET: return zsetLength(key->value);
-    case OBJ_HASH: return hashTypeLength(key->value);
-    default: return 0;
+    case OBJ_STRING: __A_VARIABLE = 1;
+        return stringObjectLen(key->value);
+    case OBJ_LIST: __A_VARIABLE = 1;
+        return listTypeLength(key->value);
+    case OBJ_SET: __A_VARIABLE = 1;
+        return setTypeSize(key->value);
+    case OBJ_ZSET: __A_VARIABLE = 1;
+        return zsetLength(key->value);
+    case OBJ_HASH: __A_VARIABLE = 1;
+        return hashTypeLength(key->value);
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1607,11 +1839,16 @@ size_t RM_ValueLength(RedisModuleKey *key) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing REDISMODULE_ERR is returned. */
 int RM_DeleteKey(RedisModuleKey *key) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value) {
         dbDelete(key->db,key->key);
         key->value = NULL;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1621,11 +1858,16 @@ int RM_DeleteKey(RedisModuleKey *key) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing REDISMODULE_ERR is returned. */
 int RM_UnlinkKey(RedisModuleKey *key) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value) {
         dbAsyncDelete(key->db,key->key);
         key->value = NULL;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1633,9 +1875,14 @@ int RM_UnlinkKey(RedisModuleKey *key) {
  * If no TTL is associated with the key or if the key is empty,
  * REDISMODULE_NO_EXPIRE is returned. */
 mstime_t RM_GetExpire(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
     mstime_t expire = getExpire(key->db,key->key);
-    if (expire == -1 || key->value == NULL) return -1;
+    if (expire == -1 || key->value == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     expire -= mstime();
+    __A_VARIABLE = 1;
     return expire >= 0 ? expire : 0;
 }
 
@@ -1649,14 +1896,18 @@ mstime_t RM_GetExpire(RedisModuleKey *key) {
  * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if
  * the key was not open for writing or is an empty key. */
 int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL)
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (expire != REDISMODULE_NO_EXPIRE) {
         expire += mstime();
         setExpire(key->ctx->client,key->db,key->key,expire);
     } else {
         removeExpire(key->db,key->key);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1669,10 +1920,15 @@ int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing or there is an active iterator, REDISMODULE_ERR is returned. */
 int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE) || key->iter) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     RM_DeleteKey(key);
     setKey(key->db,key->key,str);
     key->value = str;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1706,6 +1962,7 @@ int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
  * the string, and later call StringDMA() again to get the pointer.
  */
 char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
+    volatile int __A_VARIABLE;
     /* We need to return *some* pointer for empty keys, we just return
      * a string literal pointer, that is the advantage to be mapped into
      * a read only memory page, so the module will segfault if a write
@@ -1713,10 +1970,14 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
     char *emptystring = "<dma-empty-string>";
     if (key->value == NULL) {
         *len = 0;
+        __A_VARIABLE = 1;
         return emptystring;
     }
 
-    if (key->value->type != OBJ_STRING) return NULL;
+    if (key->value->type != OBJ_STRING) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* For write access, and even for read access if the object is encoded,
      * we unshare the string (that has the side effect of decoding it). */
@@ -1724,6 +1985,7 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
         key->value = dbUnshareStringValue(key->db, key->key, key->value);
 
     *len = sdslen(key->value->ptr);
+    __A_VARIABLE = 1;
     return key->value->ptr;
 }
 
@@ -1740,13 +2002,26 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
  * If the key is empty, a string key is created with the new string value
  * unless the new length value requested is zero. */
 int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;
-    if (newlen > 512*1024*1024) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_STRING) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (newlen > 512*1024*1024) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Empty key and new len set to 0. Just return REDISMODULE_OK without
      * doing anything. */
-    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;
+    if (key->value == NULL && newlen == 0) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
 
     if (key->value == NULL) {
         /* Empty key: create it with the new size. */
@@ -1767,6 +2042,7 @@ int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
                 key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);
         }
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1779,11 +2055,19 @@ int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
  * is created. On error (key opened for read-only operations or of the wrong
  * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */
 int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_LIST) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
     listTypePush(key->value, ele,
         (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1795,15 +2079,20 @@ int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
  * 2) The key was not open for writing.
  * 3) The key is not a list. */
 RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
+    volatile int __A_VARIABLE;
     if (!(key->mode & REDISMODULE_WRITE) ||
         key->value == NULL ||
-        key->value->type != OBJ_LIST) return NULL;
+        key->value->type != OBJ_LIST) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     robj *ele = listTypePop(key->value,
         (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
     robj *decoded = getDecodedObject(ele);
     decrRefCount(ele);
     moduleDelKeyIfEmpty(key);
     autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);
+    __A_VARIABLE = 1;
     return decoded;
 }
 
@@ -1814,18 +2103,22 @@ RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
 /* Conversion from/to public flags of the Modules API and our private flags,
  * so that we have everything decoupled. */
 int RM_ZsetAddFlagsToCoreFlags(int flags) {
+    volatile int __A_VARIABLE;
     int retflags = 0;
     if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_XX;
     if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_NX;
+    __A_VARIABLE = 1;
     return retflags;
 }
 
 /* See previous function comment. */
 int RM_ZsetAddFlagsFromCoreFlags(int flags) {
+    volatile int __A_VARIABLE;
     int retflags = 0;
     if (flags & ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
     if (flags & ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
     if (flags & ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;
+    __A_VARIABLE = 1;
     return retflags;
 }
 
@@ -1858,16 +2151,25 @@ int RM_ZsetAddFlagsFromCoreFlags(int flags) {
  * * 'score' double value is not a number (NaN).
  */
 int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
+    volatile int __A_VARIABLE;
     int flags = 0;
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
     if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
     if (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) {
         if (flagsptr) *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1885,22 +2187,32 @@ int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *f
  * with the new score of the element after the increment, if no error
  * is returned. */
 int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
+    volatile int __A_VARIABLE;
     int flags = 0;
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
     if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
     flags |= ZADD_INCR;
     if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) {
         if (flagsptr) *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     /* zsetAdd() may signal back that the resulting score is not a number. */
     if (flagsptr && (*flagsptr & ZADD_NAN)) {
         *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1923,13 +2235,21 @@ int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int
  *
  * Empty keys will be handled correctly by doing nothing. */
 int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value != NULL && zsetDel(key->value,ele->ptr)) {
         if (deleted) *deleted = 1;
     } else {
         if (deleted) *deleted = 0;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1942,9 +2262,20 @@ int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
  * * The key is an open empty key.
  */
 int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
-    if (key->value == NULL) return REDISMODULE_ERR;
-    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
-    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (key->value == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (zsetScore(key->value,ele->ptr,score) == C_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1953,13 +2284,16 @@ int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
  * -------------------------------------------------------------------------- */
 
 void zsetKeyReset(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
     key->ztype = REDISMODULE_ZSET_RANGE_NONE;
     key->zcurrent = NULL;
     key->zer = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Stop a sorted set iteration. */
 void RM_ZsetRangeStop(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
     /* Free resources if needed. */
     if (key->ztype == REDISMODULE_ZSET_RANGE_LEX)
         zslFreeLexRange(&key->zlrs);
@@ -1967,10 +2301,13 @@ void RM_ZsetRangeStop(RedisModuleKey *key) {
      * iterator is not active will result into something more sensible
      * than crashing. */
     zsetKeyReset(key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the "End of range" flag value to signal the end of the iteration. */
 int RM_ZsetRangeEndReached(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return key->zer;
 }
 
@@ -1981,7 +2318,11 @@ int RM_ZsetRangeEndReached(RedisModuleKey *key) {
  * otherwise the last. Return REDISMODULE_OK on success otherwise
  * REDISMODULE_ERR. */
 int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
-    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!key->value || key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RM_ZsetRangeStop(key);
     key->ztype = REDISMODULE_ZSET_RANGE_SCORE;
@@ -2007,6 +2348,7 @@ int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, i
         serverPanic("Unsupported zset encoding");
     }
     if (key->zcurrent == NULL) key->zer = 1;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2026,12 +2368,16 @@ int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, i
  * where the min and max value are exclusive (not included) instead of
  * inclusive. */
 int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zsetInitScoreRange(key,min,max,minex,maxex,1);
 }
 
 /* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of
  * the range is selected for the start of the iteration instead. */
 int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zsetInitScoreRange(key,min,max,minex,maxex,0);
 }
 
@@ -2045,7 +2391,11 @@ int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int min
  * Note that this function takes 'min' and 'max' in the same form of the
  * Redis ZRANGEBYLEX command. */
 int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
-    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!key->value || key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RM_ZsetRangeStop(key);
     key->zer = 0;
@@ -2053,7 +2403,10 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
     /* Setup the range structure used by the sorted set core implementation
      * in order to seek at the specified element. */
     zlexrangespec *zlrs = &key->zlrs;
-    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;
+    if (zslParseLexRange(min, max, zlrs) == C_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Set the range type to lex only after successfully parsing the range,
      * otherwise we don't want the zlexrangespec to be freed. */
@@ -2072,6 +2425,7 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
     }
     if (key->zcurrent == NULL) key->zer = 1;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2088,12 +2442,16 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
  * The function does not take ownership of the objects, so they can be released
  * ASAP after the iterator is setup. */
 int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zsetInitLexRange(key,min,max,1);
 }
 
 /* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of
  * the range is selected for the start of the iteration instead. */
 int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zsetInitLexRange(key,min,max,0);
 }
 
@@ -2101,9 +2459,13 @@ int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModu
  * or NULL if the range specified in the iterator does not include any
  * element. */
 RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
+    volatile int __A_VARIABLE;
     RedisModuleString *str;
 
-    if (key->zcurrent == NULL) return NULL;
+    if (key->zcurrent == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *eptr, *sptr;
         eptr = key->zcurrent;
@@ -2121,6 +2483,7 @@ RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score
         serverPanic("Unsupported zset encoding");
     }
     autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);
+    __A_VARIABLE = 1;
     return str;
 }
 
@@ -2307,9 +2670,16 @@ int RM_ZsetRangePrev(RedisModuleKey *key) {
  * * The key was associated with a non Hash value.
  */
 int RM_HashSet(RedisModuleKey *key, int flags, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
-    if (!(key->mode & REDISMODULE_WRITE)) return 0;
-    if (key->value && key->value->type != OBJ_HASH) return 0;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (key->value && key->value->type != OBJ_HASH) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);
 
     int updated = 0;
@@ -2365,6 +2735,7 @@ int RM_HashSet(RedisModuleKey *key, int flags, ...) {
     }
     va_end(ap);
     moduleDelKeyIfEmpty(key);
+    __A_VARIABLE = 1;
     return updated;
 }
 
@@ -2410,8 +2781,12 @@ int RM_HashSet(RedisModuleKey *key, int flags, ...) {
  * RedisModule_FreeString(), or by enabling automatic memory management.
  */
 int RM_HashGet(RedisModuleKey *key, int flags, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
-    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;
+    if (key->value && key->value->type != OBJ_HASH) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     va_start(ap, flags);
     while(1) {
@@ -2454,6 +2829,7 @@ int RM_HashGet(RedisModuleKey *key, int flags, ...) {
         if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);
     }
     va_end(ap);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2466,6 +2842,7 @@ int RM_HashGet(RedisModuleKey *key, int flags, ...) {
  * is processed as needed. Initially we just make sure to set the right
  * reply type, which is extremely cheap to do. */
 RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {
+    volatile int __A_VARIABLE;
     RedisModuleCallReply *reply = zmalloc(sizeof(*reply));
     reply->ctx = ctx;
     reply->proto = proto;
@@ -2481,6 +2858,7 @@ RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds pr
     }
     if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')
         reply->type = REDISMODULE_REPLY_NULL;
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -2493,7 +2871,11 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply);
  * use the protcol of the reply in reply->proto in order to fill the
  * reply with parsed data according to the reply type. */
 void moduleParseCallReply(RedisModuleCallReply *reply) {
-    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) return;
+    volatile int __A_VARIABLE;
+    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     reply->flags &= ~REDISMODULE_REPLYFLAG_TOPARSE;
 
     switch(reply->proto[0]) {
@@ -2503,18 +2885,22 @@ void moduleParseCallReply(RedisModuleCallReply *reply) {
     case '+': moduleParseCallReply_SimpleString(reply); break;
     case '*': moduleParseCallReply_Array(reply); break;
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_Int(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     char *proto = reply->proto;
     char *p = strchr(proto+1,'\r');
 
     string2ll(proto+1,p-proto-1,&reply->val.ll);
     reply->protolen = p-proto+2;
     reply->type = REDISMODULE_REPLY_INTEGER;
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     char *proto = reply->proto;
     char *p = strchr(proto+1,'\r');
     long long bulklen;
@@ -2529,9 +2915,11 @@ void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
         reply->protolen = p-proto+2+bulklen+2;
         reply->type = REDISMODULE_REPLY_STRING;
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     char *proto = reply->proto;
     char *p = strchr(proto+1,'\r');
 
@@ -2540,9 +2928,11 @@ void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
     reply->protolen = p-proto+2;
     reply->type = proto[0] == '+' ? REDISMODULE_REPLY_STRING :
                                     REDISMODULE_REPLY_ERROR;
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     char *proto = reply->proto;
     char *p = strchr(proto+1,'\r');
     long long arraylen, j;
@@ -2553,6 +2943,7 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
     if (arraylen == -1) {
         reply->protolen = p-proto;
         reply->type = REDISMODULE_REPLY_NULL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2569,15 +2960,20 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
     }
     reply->protolen = p-proto;
     reply->type = REDISMODULE_REPLY_ARRAY;
+    __A_VARIABLE = 1;
 }
 
 /* Free a Call reply and all the nested replies it contains if it's an
  * array. */
 void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
+    volatile int __A_VARIABLE;
     /* Don't free nested replies by default: the user must always free the
      * toplevel reply. However be gentle and don't crash if the module
      * misuses the API. */
-    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) return;
+    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {
         if (reply->type == REDISMODULE_REPLY_ARRAY) {
@@ -2596,33 +2992,44 @@ void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
         if (reply->proto) sdsfree(reply->proto);
         zfree(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for the recursive free reply function. This is needed in order
  * to have the first level function to return on nested replies, but only
  * if called by the module API. */
 void RM_FreeCallReply(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
 
     RedisModuleCtx *ctx = reply->ctx;
     RM_FreeCallReply_Rec(reply,0);
     autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
+    __A_VARIABLE = 1;
 }
 
 /* Return the reply type. */
 int RM_CallReplyType(RedisModuleCallReply *reply) {
-    if (!reply) return REDISMODULE_REPLY_UNKNOWN;
+    volatile int __A_VARIABLE;
+    if (!reply) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_REPLY_UNKNOWN;
+    }
+    __A_VARIABLE = 1;
     return reply->type;
 }
 
 /* Return the reply type length, where applicable. */
 size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     moduleParseCallReply(reply);
     switch(reply->type) {
     case REDISMODULE_REPLY_STRING:
     case REDISMODULE_REPLY_ERROR:
     case REDISMODULE_REPLY_ARRAY:
+        __A_VARIABLE = 1;
         return reply->len;
     default:
+        __A_VARIABLE = 1;
         return 0;
     }
 }
@@ -2630,42 +3037,64 @@ size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
 /* Return the 'idx'-th nested call reply element of an array reply, or NULL
  * if the reply type is wrong or the index is out of range. */
 RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
+    volatile int __A_VARIABLE;
     moduleParseCallReply(reply);
-    if (reply->type != REDISMODULE_REPLY_ARRAY) return NULL;
-    if (idx >= reply->len) return NULL;
+    if (reply->type != REDISMODULE_REPLY_ARRAY) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    if (idx >= reply->len) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return reply->val.array+idx;
 }
 
 /* Return the long long of an integer reply. */
 long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     moduleParseCallReply(reply);
-    if (reply->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
+    if (reply->type != REDISMODULE_REPLY_INTEGER) {
+        __A_VARIABLE = 1;
+        return LLONG_MIN;
+    }
+    __A_VARIABLE = 1;
     return reply->val.ll;
 }
 
 /* Return the pointer and length of a string or error reply. */
 const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
+    volatile int __A_VARIABLE;
     moduleParseCallReply(reply);
     if (reply->type != REDISMODULE_REPLY_STRING &&
-        reply->type != REDISMODULE_REPLY_ERROR) return NULL;
+        reply->type != REDISMODULE_REPLY_ERROR) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     if (len) *len = reply->len;
+    __A_VARIABLE = 1;
     return reply->val.str;
 }
 
 /* Return a new string object from a call reply of type string, error or
  * integer. Otherwise (wrong reply type) return NULL. */
 RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
+    volatile int __A_VARIABLE;
     moduleParseCallReply(reply);
     switch(reply->type) {
     case REDISMODULE_REPLY_STRING:
     case REDISMODULE_REPLY_ERROR:
+        __A_VARIABLE = 1;
         return RM_CreateString(reply->ctx,reply->val.str,reply->len);
     case REDISMODULE_REPLY_INTEGER: {
         char buf[64];
         int len = ll2string(buf,sizeof(buf),reply->val.ll);
+        __A_VARIABLE = 1;
         return RM_CreateString(reply->ctx,buf,len);
         }
-    default: return NULL;
+    default: __A_VARIABLE = 1;
+        return NULL;
     }
 }
 
@@ -2684,6 +3113,7 @@ RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
 #define REDISMODULE_ARGV_REPLICATE (1<<0)
 
 robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
+    volatile int __A_VARIABLE;
     int argc = 0, argv_size, j;
     robj **argv = NULL;
 
@@ -2737,12 +3167,14 @@ robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int
         p++;
     }
     *argcp = argc;
+    __A_VARIABLE = 1;
     return argv;
 
 fmterr:
     for (j = 0; j < argc; j++)
         decrRefCount(argv[j]);
     zfree(argv);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -2753,6 +3185,7 @@ fmterr:
  * EINVAL: command non existing, wrong arity, wrong format specifier.
  * EPERM:  operation in Cluster instance with key in non local slot. */
 RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     struct redisCommand *cmd;
     client *c = NULL;
     robj **argv = NULL;
@@ -2843,13 +3276,16 @@ RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const ch
 cleanup:
     if (ctx->module) ctx->module->in_call--;
     freeClient(c);
+    __A_VARIABLE = 1;
     return reply;
 }
 
 /* Return a pointer, and a length, to the protocol returned by the command
  * that returned the reply object. */
 const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
+    volatile int __A_VARIABLE;
     if (reply->proto) *len = sdslen(reply->proto);
+    __A_VARIABLE = 1;
     return reply->proto;
 }
 
@@ -2892,20 +3328,31 @@ const char *ModuleTypeNameCharSet =
              "0123456789-_";
 
 uint64_t moduleTypeEncodeId(const char *name, int encver) {
+    volatile int __A_VARIABLE;
     /* We use 64 symbols so that we can map each character into 6 bits
      * of the final output. */
     const char *cset = ModuleTypeNameCharSet;
-    if (strlen(name) != 9) return 0;
-    if (encver < 0 || encver > 1023) return 0;
+    if (strlen(name) != 9) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (encver < 0 || encver > 1023) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     uint64_t id = 0;
     for (int j = 0; j < 9; j++) {
         char *p = strchr(cset,name[j]);
-        if (!p) return 0;
+        if (!p) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         unsigned long pos = p-cset;
         id = (id << 6) | pos;
     }
     id = (id << 10) | encver;
+    __A_VARIABLE = 1;
     return id;
 }
 
@@ -2913,6 +3360,7 @@ uint64_t moduleTypeEncodeId(const char *name, int encver) {
  * a type with the same name as the one given. Returns the moduleType
  * structure pointer if such a module is found, or NULL otherwise. */
 moduleType *moduleTypeLookupModuleByName(const char *name) {
+    volatile int __A_VARIABLE;
     dictIterator *di = dictGetIterator(modules);
     dictEntry *de;
 
@@ -2926,11 +3374,13 @@ moduleType *moduleTypeLookupModuleByName(const char *name) {
             moduleType *mt = ln->value;
             if (memcmp(name,mt->name,sizeof(mt->name)) == 0) {
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return mt;
             }
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -2940,6 +3390,7 @@ moduleType *moduleTypeLookupModuleByName(const char *name) {
 #define MODULE_LOOKUP_CACHE_SIZE 3
 
 moduleType *moduleTypeLookupModuleByID(uint64_t id) {
+    volatile int __A_VARIABLE;
     static struct {
         uint64_t id;
         moduleType *mt;
@@ -2948,7 +3399,10 @@ moduleType *moduleTypeLookupModuleByID(uint64_t id) {
     /* Search in cache to start. */
     int j;
     for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)
-        if (cache[j].id == id) return cache[j].mt;
+        if (cache[j].id == id) {
+            __A_VARIABLE = 1;
+            return cache[j].mt;
+        }
 
     /* Slow module by module lookup. */
     moduleType *mt = NULL;
@@ -2978,6 +3432,7 @@ moduleType *moduleTypeLookupModuleByID(uint64_t id) {
         cache[j].id = id;
         cache[j].mt = mt;
     }
+    __A_VARIABLE = 1;
     return mt;
 }
 
@@ -2986,6 +3441,7 @@ moduleType *moduleTypeLookupModuleByID(uint64_t id) {
  * The buffer pointed by 'name' must be 10 bytes at least. The function will
  * fill it with a null terminated module name. */
 void moduleTypeNameByID(char *name, uint64_t moduleid) {
+    volatile int __A_VARIABLE;
     const char *cset = ModuleTypeNameCharSet;
 
     name[9] = '\0';
@@ -2995,6 +3451,7 @@ void moduleTypeNameByID(char *name, uint64_t moduleid) {
         *p-- = cset[moduleid & 63];
         moduleid >>= 6;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Register a new data type exported by the module. The parameters are the
@@ -3062,12 +3519,22 @@ void moduleTypeNameByID(char *name, uint64_t moduleid) {
  *      }
  */
 moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
+    volatile int __A_VARIABLE;
     uint64_t id = moduleTypeEncodeId(name,encver);
-    if (id == 0) return NULL;
-    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;
+    if (id == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    if (moduleTypeLookupModuleByName(name) != NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     long typemethods_version = ((long*)typemethods_ptr)[0];
-    if (typemethods_version == 0) return NULL;
+    if (typemethods_version == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     struct typemethods {
         uint64_t version;
@@ -3100,6 +3567,7 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
     }
     memcpy(mt->name,name,sizeof(mt->name));
     listAddNodeTail(ctx->module->types,mt);
+    __A_VARIABLE = 1;
     return mt;
 }
 
@@ -3108,12 +3576,17 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing or there is an active iterator, REDISMODULE_ERR is returned. */
 int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (!(key->mode & REDISMODULE_WRITE) || key->iter) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     RM_DeleteKey(key);
     robj *o = createModuleObject(mt,value);
     setKey(key->db,key->key,o);
     decrRefCount(o);
     key->value = o;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -3123,10 +3596,15 @@ int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
  * If the key is NULL, is not associated with a module type, or is empty,
  * then NULL is returned instead. */
 moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
     if (key == NULL ||
         key->value == NULL ||
-        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
+        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     moduleValue *mv = key->value->ptr;
+    __A_VARIABLE = 1;
     return mv->type;
 }
 
@@ -3137,10 +3615,15 @@ moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
  * If the key is NULL, is not associated with a module type, or is empty,
  * then NULL is returned instead. */
 void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
+    volatile int __A_VARIABLE;
     if (key == NULL ||
         key->value == NULL ||
-        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
+        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     moduleValue *mv = key->value->ptr;
+    __A_VARIABLE = 1;
     return mv->value;
 }
 
@@ -3151,6 +3634,7 @@ void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
 /* Called when there is a load error in the context of a module. This cannot
  * be recovered like for the built-in types. */
 void moduleRDBLoadError(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
     serverLog(LL_WARNING,
         "Error loading data from RDB (short read or EOF). "
         "Read performed by module '%s' about type '%s' "
@@ -3159,13 +3643,18 @@ void moduleRDBLoadError(RedisModuleIO *io) {
         io->type->name,
         (unsigned long long)io->bytes);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Save an unsigned 64 bit value into the RDB file. This function should only
  * be called in the context of the rdb_save method of modules implementing new
  * data types. */
 void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);
     if (retval == -1) goto saveerr;
@@ -3174,16 +3663,19 @@ void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
     retval = rdbSaveLen(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Load an unsigned 64 bit value from the RDB file. This function should only
  * be called in the context of the rdb_load method of modules implementing
  * new data types. */
 uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
     if (io->ver == 2) {
         uint64_t opcode = rdbLoadLen(io->rio,NULL);
         if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
@@ -3191,24 +3683,30 @@ uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
     uint64_t value;
     int retval = rdbLoadLenByRef(io->rio, NULL, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
 /* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */
 void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
+    volatile int __A_VARIABLE;
     union {uint64_t u; int64_t i;} conv;
     conv.i = value;
     RM_SaveUnsigned(io,conv.u);
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */
 int64_t RM_LoadSigned(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
     union {uint64_t u; int64_t i;} conv;
     conv.u = RM_LoadUnsigned(io);
+    __A_VARIABLE = 1;
     return conv.i;
 }
 
@@ -3219,7 +3717,11 @@ int64_t RM_LoadSigned(RedisModuleIO *io) {
  * other Load family functions expecting a serialized string inside
  * the RDB file. */
 void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
     if (retval == -1) goto saveerr;
@@ -3228,16 +3730,22 @@ void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
     retval = rdbSaveStringObject(io->rio, s);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_SaveString() but takes a raw C pointer and length
  * as input. */
 void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
     if (retval == -1) goto saveerr;
@@ -3246,14 +3754,17 @@ void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
     retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Implements RM_LoadString() and RM_LoadStringBuffer() */
 void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
+    volatile int __A_VARIABLE;
     if (io->ver == 2) {
         uint64_t opcode = rdbLoadLen(io->rio,NULL);
         if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
@@ -3261,10 +3772,12 @@ void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
     void *s = rdbGenericLoadStringObject(io->rio,
               plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
     if (s == NULL) goto loaderr;
+    __A_VARIABLE = 1;
     return s;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return NULL; /* Never reached. */
 }
 
@@ -3278,6 +3791,8 @@ loaderr:
  * If the data structure does not store strings as RedisModuleString objects,
  * the similar function RedisModule_LoadStringBuffer() could be used instead. */
 RedisModuleString *RM_LoadString(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return moduleLoadString(io,0,NULL);
 }
 
@@ -3289,6 +3804,8 @@ RedisModuleString *RM_LoadString(RedisModuleIO *io) {
  * The returned string is not automatically NULL termianted, it is loaded
  * exactly as it was stored inisde the RDB file. */
 char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return moduleLoadString(io,1,lenptr);
 }
 
@@ -3296,7 +3813,11 @@ char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
  * value to the RDB file. The double can be a valid number, a NaN or infinity.
  * It is possible to load back the value with RedisModule_LoadDouble(). */
 void RM_SaveDouble(RedisModuleIO *io, double value) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);
     if (retval == -1) goto saveerr;
@@ -3305,15 +3826,18 @@ void RM_SaveDouble(RedisModuleIO *io, double value) {
     retval = rdbSaveBinaryDoubleValue(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* In the context of the rdb_save method of a module data type, loads back the
  * double value saved by RedisModule_SaveDouble(). */
 double RM_LoadDouble(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
     if (io->ver == 2) {
         uint64_t opcode = rdbLoadLen(io->rio,NULL);
         if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
@@ -3321,10 +3845,12 @@ double RM_LoadDouble(RedisModuleIO *io) {
     double value;
     int retval = rdbLoadBinaryDoubleValue(io->rio, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
@@ -3332,7 +3858,11 @@ loaderr:
  * value to the RDB file. The float can be a valid number, a NaN or infinity.
  * It is possible to load back the value with RedisModule_LoadFloat(). */
 void RM_SaveFloat(RedisModuleIO *io, float value) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);
     if (retval == -1) goto saveerr;
@@ -3341,15 +3871,18 @@ void RM_SaveFloat(RedisModuleIO *io, float value) {
     retval = rdbSaveBinaryFloatValue(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* In the context of the rdb_save method of a module data type, loads back the
  * float value saved by RedisModule_SaveFloat(). */
 float RM_LoadFloat(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
     if (io->ver == 2) {
         uint64_t opcode = rdbLoadLen(io->rio,NULL);
         if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
@@ -3357,16 +3890,19 @@ float RM_LoadFloat(RedisModuleIO *io) {
     float value;
     int retval = rdbLoadBinaryFloatValue(io->rio, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
 /* Iterate over modules, and trigger rdb aux saving for the ones modules types
  * who asked for it. */
 ssize_t rdbSaveModulesAux(rio *rdb, int when) {
+    volatile int __A_VARIABLE;
     size_t total_written = 0;
     dictIterator *di = dictGetIterator(modules);
     dictEntry *de;
@@ -3384,6 +3920,7 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
             ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
             if (ret==-1) {
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return -1;
             }
             total_written += ret;
@@ -3391,6 +3928,7 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
     }
 
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return total_written;
 }
 
@@ -3437,21 +3975,27 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
  *
  */
 void RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {
+    volatile int __A_VARIABLE;
     mixDigest(md->o,ele,len);
+    __A_VARIABLE = 1;
 }
 
 /* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input
  * that gets converted into a string before adding it to the digest. */
 void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {
+    volatile int __A_VARIABLE;
     char buf[LONG_STR_SIZE];
     size_t len = ll2string(buf,sizeof(buf),ll);
     mixDigest(md->o,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* See the documentation for `RedisModule_DigestAddElement()`. */
 void RM_DigestEndSequence(RedisModuleDigest *md) {
+    volatile int __A_VARIABLE;
     xorDigest(md->x,md->o,sizeof(md->o));
     memset(md->o,0,sizeof(md->o));
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -3464,7 +4008,11 @@ void RM_DigestEndSequence(RedisModuleDigest *md) {
  * the parameters are passed, but it does not return anything as the error
  * handling is performed by Redis itself. */
 void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
-    if (io->error) return;
+    volatile int __A_VARIABLE;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     struct redisCommand *cmd;
     robj **argv = NULL;
     int argc = 0, flags = 0, j;
@@ -3478,6 +4026,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
             io->type->name, cmdname);
         io->error = 1;
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3492,6 +4041,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
             io->type->name, fmt);
         io->error = 1;
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3506,6 +4056,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
         decrRefCount(argv[j]);
     }
     zfree(argv);
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -3514,12 +4065,17 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
  * -------------------------------------------------------------------------- */
 
 RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
-    if (io->ctx) return io->ctx; /* Can't have more than one... */
+    volatile int __A_VARIABLE;
+    if (io->ctx) {
+        __A_VARIABLE = 1;
+        return io->ctx;
+    } /* Can't have more than one... */
     RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;
     io->ctx = zmalloc(sizeof(RedisModuleCtx));
     *(io->ctx) = ctxtemplate;
     io->ctx->module = io->type->module;
     io->ctx->client = NULL;
+    __A_VARIABLE = 1;
     return io->ctx;
 }
 
@@ -3528,6 +4084,8 @@ RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
  * that the key name is always available, so this may return NULL.
  */
 const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return io->key;
 }
 
@@ -3542,6 +4100,7 @@ const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
  *
  */
 void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
+    volatile int __A_VARIABLE;
     char msg[LOG_MAX_LEN];
     size_t name_len;
     int level;
@@ -3552,11 +4111,15 @@ void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_li
     else if (!strcasecmp(levelstr,"warning")) level = LL_WARNING;
     else level = LL_VERBOSE; /* Default. */
 
-    if (level < server.verbosity) return;
+    if (level < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     name_len = snprintf(msg, sizeof(msg),"<%s> ", module? module->name: "module");
     vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
     serverLogRaw(level,msg);
+    __A_VARIABLE = 1;
 }
 
 /* Produces a log message to the standard Redis log, the format accepts
@@ -3578,10 +4141,12 @@ void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_li
  * will be used instead of the module name.
  */
 void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     va_start(ap, fmt);
     RM_LogRaw(ctx? ctx->module: NULL,levelstr,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* Log errors from RDB / AOF serialization callbacks.
@@ -3590,10 +4155,12 @@ void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
  * error to the caller since cannot load or save the data for some
  * critical reason. */
 void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     va_start(ap, fmt);
     RM_LogRaw(io->type->module,levelstr,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -3605,10 +4172,12 @@ void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...
  * moduleHandleBlockedClients() function that is where clients are actually
  * served. */
 void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     UNUSED(el);
     UNUSED(fd);
     UNUSED(mask);
     UNUSED(privdata);
+    __A_VARIABLE = 1;
 }
 
 /* This is called from blocked.c in order to unblock a client: may be called
@@ -3624,6 +4193,7 @@ void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, in
  * The structure RedisModuleBlockedClient will be always deallocated when
  * running the list of clients blocked by a module that need to be unblocked. */
 void unblockClientFromModule(client *c) {
+    volatile int __A_VARIABLE;
     RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;
 
     /* Call the disconnection callback if any. */
@@ -3642,6 +4212,7 @@ void unblockClientFromModule(client *c) {
      * the client blocks) in order to be still able to access the argument
      * vector from callbacks. */
     resetClient(c);
+    __A_VARIABLE = 1;
 }
 
 /* Block a client in the context of a blocking command, returning an handle
@@ -3661,6 +4232,7 @@ void unblockClientFromModule(client *c) {
  *                      by RedisModule_UnblockClient() call.
  */
 RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) {
+    volatile int __A_VARIABLE;
     client *c = ctx->client;
     int islua = c->flags & CLIENT_LUA;
     int ismulti = c->flags & CLIENT_MULTI;
@@ -3692,6 +4264,7 @@ RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc
     } else {
         blockClient(c,BLOCKED_MODULE);
     }
+    __A_VARIABLE = 1;
     return bc;
 }
 
@@ -3707,6 +4280,7 @@ RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc
  *
  * Note: this function can be called from threads spawned by the module. */
 int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
+    volatile int __A_VARIABLE;
     pthread_mutex_lock(&moduleUnblockedClientsMutex);
     bc->privdata = privdata;
     listAddNodeTail(moduleUnblockedClients,bc);
@@ -3714,14 +4288,17 @@ int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
         /* Ignore the error, this is best-effort. */
     }
     pthread_mutex_unlock(&moduleUnblockedClientsMutex);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* Abort a blocked client blocking operation: the client will be unblocked
  * without firing any callback. */
 int RM_AbortBlock(RedisModuleBlockedClient *bc) {
+    volatile int __A_VARIABLE;
     bc->reply_callback = NULL;
     bc->disconnect_callback = NULL;
+    __A_VARIABLE = 1;
     return RM_UnblockClient(bc,NULL);
 }
 
@@ -3742,7 +4319,9 @@ int RM_AbortBlock(RedisModuleBlockedClient *bc) {
  *    and the timeout callback is called.
  */
 void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
+    volatile int __A_VARIABLE;
     bc->disconnect_callback = callback;
+    __A_VARIABLE = 1;
 }
 
 /* This function will check the moduleUnblockedClients queue in order to
@@ -3754,6 +4333,7 @@ void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnec
  * When this happens the RedisModuleBlockedClient structure in the queue
  * will have the 'client' field set to NULL. */
 void moduleHandleBlockedClients(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     RedisModuleBlockedClient *bc;
 
@@ -3831,6 +4411,7 @@ void moduleHandleBlockedClients(void) {
         pthread_mutex_lock(&moduleUnblockedClientsMutex);
     }
     pthread_mutex_unlock(&moduleUnblockedClientsMutex);
+    __A_VARIABLE = 1;
 }
 
 /* Called when our client timed out. After this function unblockClient()
@@ -3838,6 +4419,7 @@ void moduleHandleBlockedClients(void) {
  * does not need to do any cleanup. Eventually the module will call the
  * API to unblock the client and the memory will be released. */
 void moduleBlockedClientTimedOut(client *c) {
+    volatile int __A_VARIABLE;
     RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;
     RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
     ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;
@@ -3850,22 +4432,29 @@ void moduleBlockedClientTimedOut(client *c) {
      * because the blocked client will be automatically disconnected in
      * this case, and the user can still hook using the timeout callback. */
     bc->disconnect_callback = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if a module command was called in order to fill the
  * reply for a blocked client. */
 int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;
 }
 
 /* Return non-zero if a module command was called in order to fill the
  * reply for a blocked client that timed out. */
 int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
 }
 
 /* Get the private data set by RedisModule_UnblockClient() */
 void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ctx->blocked_privdata;
 }
 
@@ -3874,6 +4463,8 @@ void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
  * before sometimes the module has the blocked client handle references
  * around, and wants to cleanup it. */
 RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ctx->blocked_client;
 }
 
@@ -3881,6 +4472,8 @@ RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
  * the reason for the client to be unblocked is that it disconnected
  * while it was blocked. */
 int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
 }
 
@@ -3908,6 +4501,7 @@ int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
  * TODO: thread safe contexts do not inherit the blocked client
  * selected database. */
 RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
+    volatile int __A_VARIABLE;
     RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
     RedisModuleCtx empty = REDISMODULE_CTX_INIT;
     memcpy(ctx,&empty,sizeof(empty));
@@ -3925,35 +4519,46 @@ RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
         selectDb(ctx->client,bc->dbid);
         ctx->client->id = bc->client->id;
     }
+    __A_VARIABLE = 1;
     return ctx;
 }
 
 /* Release a thread safe context. */
 void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     moduleFreeContext(ctx);
     zfree(ctx);
+    __A_VARIABLE = 1;
 }
 
 /* Acquire the server lock before executing a thread safe API call.
  * This is not needed for `RedisModule_Reply*` calls when there is
  * a blocked client connected to the thread safe context. */
 void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
     moduleAcquireGIL();
+    __A_VARIABLE = 1;
 }
 
 /* Release the server lock after a thread safe API call was executed. */
 void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
     moduleReleaseGIL();
+    __A_VARIABLE = 1;
 }
 
 void moduleAcquireGIL(void) {
+    volatile int __A_VARIABLE;
     pthread_mutex_lock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 void moduleReleaseGIL(void) {
+    volatile int __A_VARIABLE;
     pthread_mutex_unlock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 
@@ -4011,6 +4616,7 @@ void moduleReleaseGIL(void) {
  * See https://redis.io/topics/notifications for more information.
  */
 int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
+    volatile int __A_VARIABLE;
     RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
     sub->module = ctx->module;
     sub->event_mask = types;
@@ -4018,6 +4624,7 @@ int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNoti
     sub->active = 0;
 
     listAddNodeTail(moduleKeyspaceSubscribers, sub);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4025,8 +4632,12 @@ int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNoti
  * This gets called  only if at least one module requested to be notified on
  * keyspace notifications */
 void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
+    volatile int __A_VARIABLE;
     /* Don't do anything if there aren't any subscribers */
-    if (listLength(moduleKeyspaceSubscribers) == 0) return;
+    if (listLength(moduleKeyspaceSubscribers) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listIter li;
     listNode *ln;
@@ -4054,10 +4665,12 @@ void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid)
             moduleFreeContext(&ctx);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Unsubscribe any notification subscribers this module has upon unloading */
 void moduleUnsubscribeNotifications(RedisModule *module) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(moduleKeyspaceSubscribers,&li);
@@ -4068,6 +4681,7 @@ void moduleUnsubscribeNotifications(RedisModule *module) {
             zfree(sub);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4100,6 +4714,7 @@ static moduleClusterReceiver *clusterReceivers[UINT8_MAX];
 
 /* Dispatch the message to the right module receiver. */
 void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {
+    volatile int __A_VARIABLE;
     moduleClusterReceiver *r = clusterReceivers[type];
     while(r) {
         if (r->module_id == module_id) {
@@ -4109,10 +4724,12 @@ void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8
             selectDb(ctx.client, 0);
             r->callback(&ctx,sender_id,type,payload,len);
             moduleFreeContext(&ctx);
+            __A_VARIABLE = 1;
             return;
         }
         r = r->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Register a callback receiver for cluster messages of type 'type'. If there
@@ -4121,7 +4738,11 @@ void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8
  * is already a callback for this function, the callback is unregistered
  * (so this API call is also used in order to delete the receiver). */
 void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
-    if (!server.cluster_enabled) return;
+    volatile int __A_VARIABLE;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
     moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
@@ -4140,6 +4761,7 @@ void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisM
                     clusterReceivers[type]->next = r->next;
                 zfree(r);
             }
+            __A_VARIABLE = 1;
             return;
         }
         prev = r;
@@ -4155,6 +4777,7 @@ void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisM
         r->next = clusterReceivers[type];
         clusterReceivers[type] = r;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send a message to all the nodes in the cluster if `target` is NULL, otherwise
@@ -4196,9 +4819,13 @@ int RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, un
  *     RedisModule_FreeClusterNodesList(ids);
  */
 char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
 
-    if (!server.cluster_enabled) return NULL;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     size_t count = dictSize(server.cluster->nodes);
     char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
     dictIterator *di = dictGetIterator(server.cluster->nodes);
@@ -4215,20 +4842,31 @@ char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
     ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need
                     * to also get the count argument. */
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return ids;
 }
 
 /* Free the node list obtained with RedisModule_GetClusterNodesList. */
 void RM_FreeClusterNodesList(char **ids) {
-    if (ids == NULL) return;
+    volatile int __A_VARIABLE;
+    if (ids == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (int j = 0; ids[j]; j++) zfree(ids[j]);
     zfree(ids);
+    __A_VARIABLE = 1;
 }
 
 /* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster
  * is disabled. */
 const char *RM_GetMyClusterID(void) {
-    if (!server.cluster_enabled) return NULL;
+    volatile int __A_VARIABLE;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return server.cluster->myself->name;
 }
 
@@ -4237,7 +4875,12 @@ const char *RM_GetMyClusterID(void) {
  * be smaller, but not greater than this number. If the instance is not in
  * cluster mode, zero is returned. */
 size_t RM_GetClusterSize(void) {
-    if (!server.cluster_enabled) return 0;
+    volatile int __A_VARIABLE;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return dictSize(server.cluster->nodes);
 }
 
@@ -4264,11 +4907,14 @@ size_t RM_GetClusterSize(void) {
 clusterNode *clusterLookupNode(const char *name); /* We need access to internals */
 
 int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
 
     clusterNode *node = clusterLookupNode(id);
-    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
+    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (ip) memcpy(ip,node->name,REDISMODULE_NODE_ID_LEN);
 
@@ -4294,6 +4940,7 @@ int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *m
         if (node->flags & CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;
         if (node->flags & CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4316,11 +4963,13 @@ int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *m
  *                  Slots informations will still be propagated across the
  *                  cluster, but without effects. */
 void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
+    volatile int __A_VARIABLE;
     UNUSED(ctx);
     if (flags & REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)
         server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
     if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
         server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4358,6 +5007,7 @@ typedef struct RedisModuleTimer {
 /* This is the timer handler that is called by the main event loop. We schedule
  * this timer to be called when the nearest of our module timers will expire. */
 int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+    volatile int __A_VARIABLE;
     UNUSED(eventLoop);
     UNUSED(id);
     UNUSED(clientData);
@@ -4393,6 +5043,7 @@ int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *client
 
     /* Reschedule the next timer or cancel it. */
     if (next_period <= 0) next_period = 1;
+    __A_VARIABLE = 1;
     return (raxSize(Timers) > 0) ? next_period : AE_NOMORE;
 }
 
@@ -4400,6 +5051,7 @@ int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *client
  * the specified function using `data` as argument. The returned timer ID can be
  * used to get information from the timer or to stop it before it fires. */
 RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
+    volatile int __A_VARIABLE;
     RedisModuleTimer *timer = zmalloc(sizeof(*timer));
     timer->module = ctx->module;
     timer->callback = callback;
@@ -4440,6 +5092,7 @@ RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisMod
     if (aeTimer == -1)
         aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);
 
+    __A_VARIABLE = 1;
     return key;
 }
 
@@ -4448,12 +5101,16 @@ RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisMod
  * If not NULL, the data pointer is set to the value of the data argument when
  * the timer was created. */
 int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
+    volatile int __A_VARIABLE;
     RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
-    if (timer == raxNotFound || timer->module != ctx->module)
+    if (timer == raxNotFound || timer->module != ctx->module) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (data) *data = timer->data;
     raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);
     zfree(timer);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4464,15 +5121,19 @@ int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
  * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if
  * the caller does not need certain information. */
 int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
+    volatile int __A_VARIABLE;
     RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
-    if (timer == raxNotFound || timer->module != ctx->module)
+    if (timer == raxNotFound || timer->module != ctx->module) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (remaining) {
         int64_t rem = ntohu64(id)-ustime();
         if (rem < 0) rem = 0;
         *remaining = rem/1000; /* Scale to milliseconds. */
     }
     if (data) *data = timer->data;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4498,9 +5159,11 @@ int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remain
  *    Next / Prev dictionary iterator calls.
  */
 RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
+    volatile int __A_VARIABLE;
     struct RedisModuleDict *d = zmalloc(sizeof(*d));
     d->rax = raxNew();
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
+    __A_VARIABLE = 1;
     return d;
 }
 
@@ -4508,13 +5171,17 @@ RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
  * context pointer 'ctx' only if the dictionary was created using the
  * context instead of passing NULL. */
 void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
+    volatile int __A_VARIABLE;
     if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
     raxFree(d->rax);
     zfree(d);
+    __A_VARIABLE = 1;
 }
 
 /* Return the size of the dictionary (number of keys). */
 uint64_t RM_DictSize(RedisModuleDict *d) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return raxSize(d->rax);
 }
 
@@ -4523,24 +5190,32 @@ uint64_t RM_DictSize(RedisModuleDict *d) {
  * already exist, REDISMODULE_OK is returned. Otherwise if the key already
  * exists the function returns REDISMODULE_ERR. */
 int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
+    volatile int __A_VARIABLE;
     int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);
+    __A_VARIABLE = 1;
     return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictSetC() but will replace the key with the new
  * value if the key already exists. */
 int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
+    volatile int __A_VARIABLE;
     int retval = raxInsert(d->rax,key,keylen,ptr,NULL);
+    __A_VARIABLE = 1;
     return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictSetC() but takes the key as a RedisModuleString. */
 int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);
 }
 
 /* Like RedisModule_DictReplaceC() but takes the key as a RedisModuleString. */
 int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);
 }
 
@@ -4550,13 +5225,17 @@ int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
  * be set by reference to 1 if the key does not exist, or to 0 if the key
  * exists. */
 void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
+    volatile int __A_VARIABLE;
     void *res = raxFind(d->rax,key,keylen);
     if (nokey) *nokey = (res == raxNotFound);
+    __A_VARIABLE = 1;
     return (res == raxNotFound) ? NULL : res;
 }
 
 /* Like RedisModule_DictGetC() but takes the key as a RedisModuleString. */
 void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);
 }
 
@@ -4568,12 +5247,16 @@ void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
  * a pointer to the value (for instance in order to release it), without
  * having to call RedisModule_DictGet() before deleting the key. */
 int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
+    volatile int __A_VARIABLE;
     int retval = raxRemove(d->rax,key,keylen,oldval);
+    __A_VARIABLE = 1;
     return retval ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictDelC() but gets the key as a RedisModuleString. */
 int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);
 }
 
@@ -4598,24 +5281,30 @@ int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
  * REDISMODULE_ERR at the first call, otherwise they'll produce elements.
  */
 RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
+    volatile int __A_VARIABLE;
     RedisModuleDictIter *di = zmalloc(sizeof(*di));
     di->dict = d;
     raxStart(&di->ri,d->rax);
     raxSeek(&di->ri,op,key,keylen);
+    __A_VARIABLE = 1;
     return di;
 }
 
 /* Exactly like RedisModule_DictIteratorStartC, but the key is passed as a
  * RedisModuleString. */
 RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));
 }
 
 /* Release the iterator created with RedisModule_DictIteratorStart(). This call
  * is mandatory otherwise a memory leak is introduced in the module. */
 void RM_DictIteratorStop(RedisModuleDictIter *di) {
+    volatile int __A_VARIABLE;
     raxStop(&di->ri);
     zfree(di);
+    __A_VARIABLE = 1;
 }
 
 /* After its creation with RedisModule_DictIteratorStart(), it is possible to
@@ -4626,12 +5315,16 @@ void RM_DictIteratorStop(RedisModuleDictIter *di) {
  * or REDISMODULE_ERR in case it was not possible to seek the specified
  * element. It is possible to reseek an iterator as many times as you want. */
 int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return raxSeek(&di->ri,op,key,keylen);
 }
 
 /* Like RedisModule_DictIteratorReseekC() but takes the key as as a
  * RedisModuleString. */
 int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));
 }
 
@@ -4661,9 +5354,14 @@ int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleSt
  * next/prev iterator step. Also the pointer is no longer valid once the
  * iterator is released. */
 void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
-    if (!raxNext(&di->ri)) return NULL;
+    volatile int __A_VARIABLE;
+    if (!raxNext(&di->ri)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (keylen) *keylen = di->ri.key_len;
     if (dataptr) *dataptr = di->ri.data;
+    __A_VARIABLE = 1;
     return di->ri.key;
 }
 
@@ -4671,9 +5369,14 @@ void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
  * the currently selected element in the iterator, it selects the previous
  * element (laxicographically smaller) instead of the next one. */
 void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
-    if (!raxPrev(&di->ri)) return NULL;
+    volatile int __A_VARIABLE;
+    if (!raxPrev(&di->ri)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (keylen) *keylen = di->ri.key_len;
     if (dataptr) *dataptr = di->ri.data;
+    __A_VARIABLE = 1;
     return di->ri.key;
 }
 
@@ -4685,9 +5388,14 @@ void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
  * The returned string object should be deallocated after use, either manually
  * or by using a context that has automatic memory management active. */
 RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
+    volatile int __A_VARIABLE;
     size_t keylen;
     void *key = RM_DictNextC(di,&keylen,dataptr);
-    if (key == NULL) return NULL;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,key,keylen);
 }
 
@@ -4695,9 +5403,14 @@ RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, voi
  * element in the iterator, it selects the previous element (laxicographically
  * smaller) instead of the next one. */
 RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
+    volatile int __A_VARIABLE;
     size_t keylen;
     void *key = RM_DictPrevC(di,&keylen,dataptr);
-    if (key == NULL) return NULL;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,key,keylen);
 }
 
@@ -4714,16 +5427,26 @@ RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, voi
  * The function returne REDISMODULE_ERR if the iterator reached the
  * end of elements condition as well. */
 int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
-    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (raxEOF(&di->ri)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     int res = raxCompare(&di->ri,op,key,keylen);
+    __A_VARIABLE = 1;
     return res ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictCompareC but gets the key to compare with the current
  * iterator key as a RedisModuleString. */
 int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
-    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (raxEOF(&di->ri)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));
+    __A_VARIABLE = 1;
     return res ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -4736,14 +5459,18 @@ int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *k
  * many bytes without any effect on the operating system entropy pool.
  * Currently this function is not thread safe. */
 void RM_GetRandomBytes(unsigned char *dst, size_t len) {
+    volatile int __A_VARIABLE;
     getRandomBytes(dst,len);
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_GetRandomBytes() but instead of setting the string to
  * random bytes the string is set to random characters in the in the
  * hex charset [0-9a-f]. */
 void RM_GetRandomHexChars(char *dst, size_t len) {
+    volatile int __A_VARIABLE;
     getRandomHexChars(dst,len);
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4763,13 +5490,16 @@ void RM_GetRandomHexChars(char *dst, size_t len) {
  * lifetime. The API relies on the fact that it will always be valid in
  * the future. */
 int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
+    volatile int __A_VARIABLE;
     RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
     sapi->module = ctx->module;
     sapi->func = func;
     if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
         zfree(sapi);
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4807,13 +5537,18 @@ int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
  *     }
  */
 void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
+    volatile int __A_VARIABLE;
     dictEntry *de = dictFind(server.sharedapi, apiname);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     RedisModuleSharedAPI *sapi = dictGetVal(de);
     if (listSearchKey(sapi->module->usedby,ctx->module) == NULL) {
         listAddNodeTail(sapi->module->usedby,ctx->module);
         listAddNodeTail(ctx->module->using,sapi->module);
     }
+    __A_VARIABLE = 1;
     return sapi->func;
 }
 
@@ -4824,6 +5559,7 @@ void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
  *
  * The number of unregistered APIs is returned. */
 int moduleUnregisterSharedAPI(RedisModule *module) {
+    volatile int __A_VARIABLE;
     int count = 0;
     dictIterator *di = dictGetSafeIterator(server.sharedapi);
     dictEntry *de;
@@ -4837,6 +5573,7 @@ int moduleUnregisterSharedAPI(RedisModule *module) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4845,6 +5582,7 @@ int moduleUnregisterSharedAPI(RedisModule *module) {
  *
  * Returns the number of modules this module was using APIs from. */
 int moduleUnregisterUsedAPI(RedisModule *module) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     int count = 0;
@@ -4858,6 +5596,7 @@ int moduleUnregisterUsedAPI(RedisModule *module) {
             count++;
         }
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4866,6 +5605,7 @@ int moduleUnregisterUsedAPI(RedisModule *module) {
  * 
  * Returns the number of filters unregistered. */
 int moduleUnregisterFilters(RedisModule *module) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     int count = 0;
@@ -4880,6 +5620,7 @@ int moduleUnregisterFilters(RedisModule *module) {
         }
         zfree(filter);
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4940,6 +5681,7 @@ int moduleUnregisterFilters(RedisModule *module) {
  */
 
 RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
+    volatile int __A_VARIABLE;
     RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
     filter->module = ctx->module;
     filter->callback = callback;
@@ -4947,30 +5689,46 @@ RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisMod
 
     listAddNodeTail(moduleCommandFilters, filter);
     listAddNodeTail(ctx->module->filters, filter);
+    __A_VARIABLE = 1;
     return filter;
 }
 
 /* Unregister a command filter.
  */
 int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
+    volatile int __A_VARIABLE;
     listNode *ln;
 
     /* A module can only remove its own filters */
-    if (filter->module != ctx->module) return REDISMODULE_ERR;
+    if (filter->module != ctx->module) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     ln = listSearchKey(moduleCommandFilters,filter);
-    if (!ln) return REDISMODULE_ERR;
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     listDelNode(moduleCommandFilters,ln);
     
     ln = listSearchKey(ctx->module->filters,filter);
-    if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }    /* Shouldn't happen */
     listDelNode(ctx->module->filters,ln);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void moduleCallCommandFilters(client *c) {
-    if (listLength(moduleCommandFilters) == 0) return;
+    volatile int __A_VARIABLE;
+    if (listLength(moduleCommandFilters) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listIter li;
     listNode *ln;
@@ -4995,6 +5753,7 @@ void moduleCallCommandFilters(client *c) {
 
     c->argv = filter.argv;
     c->argc = filter.argc;
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of arguments a filtered command has.  The number of
@@ -5002,6 +5761,8 @@ void moduleCallCommandFilters(client *c) {
  */
 int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
 {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return fctx->argc;
 }
 
@@ -5010,7 +5771,12 @@ int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
  */
 const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
 {
-    if (pos < 0 || pos >= fctx->argc) return NULL;
+    volatile int __A_VARIABLE;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return fctx->argv[pos];
 }
 
@@ -5022,9 +5788,13 @@ const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fct
 
 int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
 {
+    volatile int __A_VARIABLE;
     int i;
 
-    if (pos < 0 || pos > fctx->argc) return REDISMODULE_ERR;
+    if (pos < 0 || pos > fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     fctx->argv = zrealloc(fctx->argv, (fctx->argc+1)*sizeof(RedisModuleString *));
     for (i = fctx->argc; i > pos; i--) {
@@ -5033,6 +5803,7 @@ int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisM
     fctx->argv[pos] = arg;
     fctx->argc++;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5044,11 +5815,16 @@ int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisM
 
 int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
 {
-    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;
+    volatile int __A_VARIABLE;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     decrRefCount(fctx->argv[pos]);
     fctx->argv[pos] = arg;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5057,8 +5833,12 @@ int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, Redis
  */
 int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
 {
+    volatile int __A_VARIABLE;
     int i;
-    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     decrRefCount(fctx->argv[pos]);
     for (i = pos; i < fctx->argc-1; i++) {
@@ -5066,6 +5846,7 @@ int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
     }
     fctx->argc--;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5077,11 +5858,15 @@ int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
  * this gets queries from modules. */
 
 uint64_t dictCStringKeyHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
 }
 
 int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {
+    volatile int __A_VARIABLE;
     UNUSED(privdata);
+    __A_VARIABLE = 1;
     return strcmp(key1,key2) == 0;
 }
 
@@ -5095,6 +5880,8 @@ dictType moduleAPIDictType = {
 };
 
 int moduleRegisterApi(const char *funcname, void *funcptr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictAdd(server.moduleapi, (char*)funcname, funcptr);
 }
 
@@ -5105,6 +5892,7 @@ int moduleRegisterApi(const char *funcname, void *funcptr) {
 void moduleRegisterCoreAPI(void);
 
 void moduleInitModulesSystem(void) {
+    volatile int __A_VARIABLE;
     moduleUnblockedClients = listCreate();
     server.loadmodule_queue = listCreate();
     modules = dictCreate(&modulesDictType,NULL);
@@ -5135,6 +5923,7 @@ void moduleInitModulesSystem(void) {
     /* Our thread-safe contexts GIL must start with already locked:
      * it is just unlocked when it's safe. */
     pthread_mutex_lock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 /* Load all the modules in the server.loadmodule_queue list, which is
@@ -5147,6 +5936,7 @@ void moduleInitModulesSystem(void) {
  * given commands, loading AOF also may need some modules to exist, and
  * if this instance is a slave, it must understand commands from master. */
 void moduleLoadFromQueue(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
 
@@ -5162,16 +5952,20 @@ void moduleLoadFromQueue(void) {
             exit(1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleFreeModuleStructure(struct RedisModule *module) {
+    volatile int __A_VARIABLE;
     listRelease(module->types);
     listRelease(module->filters);
     sdsfree(module->name);
     zfree(module);
+    __A_VARIABLE = 1;
 }
 
 void moduleUnregisterCommands(struct RedisModule *module) {
+    volatile int __A_VARIABLE;
     /* Unregister all the commands registered by this module. */
     dictIterator *di = dictGetSafeIterator(server.commands);
     dictEntry *de;
@@ -5191,11 +5985,13 @@ void moduleUnregisterCommands(struct RedisModule *module) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Load a module and initialize it. On success C_OK is returned, otherwise
  * C_ERR is returned. */
 int moduleLoad(const char *path, void **module_argv, int module_argc) {
+    volatile int __A_VARIABLE;
     int (*onload)(void *, void **, int);
     void *handle;
     RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
@@ -5203,6 +5999,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
     handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
     if (handle == NULL) {
         serverLog(LL_WARNING, "Module %s failed to load: %s", path, dlerror());
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,"RedisModule_OnLoad");
@@ -5211,6 +6008,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
         serverLog(LL_WARNING,
             "Module %s does not export RedisModule_OnLoad() "
             "symbol. Module not loaded.",path);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     if (onload((void*)&ctx,module_argv,module_argc) == REDISMODULE_ERR) {
@@ -5223,6 +6021,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
         dlclose(handle);
         serverLog(LL_WARNING,
             "Module %s initialization failed. Module not loaded",path);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -5231,6 +6030,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
     ctx.module->handle = handle;
     serverLog(LL_NOTICE,"Module '%s' loaded from %s",ctx.module->name,path);
     moduleFreeContext(&ctx);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -5356,12 +6156,15 @@ NULL
 
 /* Return the number of registered modules. */
 size_t moduleCount(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictSize(modules);
 }
 
 /* Register all the APIs we export. Keep this function at the end of the
  * file so that's easy to seek it to add new entries. */
 void moduleRegisterCoreAPI(void) {
+    volatile int __A_VARIABLE;
     server.moduleapi = dictCreate(&moduleAPIDictType,NULL);
     server.sharedapi = dictCreate(&moduleAPIDictType,NULL);
     REGISTER_API(Alloc);
@@ -5525,4 +6328,5 @@ void moduleRegisterCoreAPI(void) {
     REGISTER_API(CommandFilterArgInsert);
     REGISTER_API(CommandFilterArgReplace);
     REGISTER_API(CommandFilterArgDelete);
+    __A_VARIABLE = 1;
 }
diff --git a/src/modules/helloblock.c b/src/modules/helloblock.c
index b90ccaa..68ee77c 100644
--- a/src/modules/helloblock.c
+++ b/src/modules/helloblock.c
@@ -40,28 +40,35 @@
 
 /* Reply callback for blocking command HELLO.BLOCK */
 int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
     int *myint = RedisModule_GetBlockedClientPrivateData(ctx);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithLongLong(ctx,*myint);
 }
 
 /* Timeout callback for blocking command HELLO.BLOCK */
 int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx,"Request timedout");
 }
 
 /* Private data freeing callback for HELLO.BLOCK command. */
 void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(ctx);
     RedisModule_Free(privdata);
+    __A_VARIABLE = 1;
 }
 
 /* The thread entry point that actually executes the blocking part
  * of the command HELLO.BLOCK. */
 void *HelloBlock_ThreadMain(void *arg) {
+    volatile int __A_VARIABLE;
     void **targ = arg;
     RedisModuleBlockedClient *bc = targ[0];
     long long delay = (unsigned long)targ[1];
@@ -71,6 +78,7 @@ void *HelloBlock_ThreadMain(void *arg) {
     int *r = RedisModule_Alloc(sizeof(int));
     *r = rand();
     RedisModule_UnblockClient(bc,r);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -83,27 +91,35 @@ void *HelloBlock_ThreadMain(void *arg) {
  * amount of seconds with a while loop calling sleep(1), so that once we
  * detect the client disconnection, we can terminate the thread ASAP. */
 void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc) {
+    volatile int __A_VARIABLE;
     RedisModule_Log(ctx,"warning","Blocked client %p disconnected!",
         (void*)bc);
 
     /* Here you should cleanup your state / threads, and if possible
      * call RedisModule_UnblockClient(), or notify the thread that will
      * call the function ASAP. */
+    __A_VARIABLE = 1;
 }
 
 /* HELLO.BLOCK <delay> <timeout> -- Block for <count> seconds, then reply with
  * a random number. Timeout is the command timeout, so that you can test
  * what happens when the delay is greater than the timeout. */
 int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    volatile int __A_VARIABLE;
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     long long delay;
     long long timeout;
 
     if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
     if (RedisModule_StringToLongLong(argv[2],&timeout) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
@@ -124,8 +140,10 @@ int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int a
 
     if (pthread_create(&tid,NULL,HelloBlock_ThreadMain,targ) != 0) {
         RedisModule_AbortBlock(bc);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"-ERR Can't start thread");
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -137,6 +155,7 @@ int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int a
  * would be trivial just using any data structure implementing a dictionary
  * in order to filter the duplicated items. */
 void *HelloKeys_ThreadMain(void *arg) {
+    volatile int __A_VARIABLE;
     RedisModuleBlockedClient *bc = arg;
     RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bc);
     long long cursor = 0;
@@ -171,6 +190,7 @@ void *HelloKeys_ThreadMain(void *arg) {
 
     RedisModule_FreeThreadSafeContext(ctx);
     RedisModule_UnblockClient(bc,NULL);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -179,8 +199,12 @@ void *HelloKeys_ThreadMain(void *arg) {
  * that were in the database from the start to the end are guaranteed to be
  * there. */
 int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
-    if (argc != 1) return RedisModule_WrongArity(ctx);
+    if (argc != 1) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
 
     pthread_t tid;
 
@@ -194,26 +218,37 @@ int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int ar
      * the reference to the blocked client handle. */
     if (pthread_create(&tid,NULL,HelloKeys_ThreadMain,bc) != 0) {
         RedisModule_AbortBlock(bc);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"-ERR Can't start thread");
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"helloblock",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hello.block",
-        HelloBlock_RedisCommand,"",0,0,0) == REDISMODULE_ERR)
+        HelloBlock_RedisCommand,"",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (RedisModule_CreateCommand(ctx,"hello.keys",
-        HelloKeys_RedisCommand,"",0,0,0) == REDISMODULE_ERR)
+        HelloKeys_RedisCommand,"",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellocluster.c b/src/modules/hellocluster.c
index cb78187..2b6b80b 100644
--- a/src/modules/hellocluster.c
+++ b/src/modules/hellocluster.c
@@ -42,21 +42,25 @@
 
 /* HELLOCLUSTER.PINGALL */
 int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PING,(unsigned char*)"Hey",3);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
 /* HELLOCLUSTER.LIST */
 int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     size_t numnodes;
     char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
     if (ids == NULL) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"Cluster not enabled");
     }
 
@@ -69,39 +73,52 @@ int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModule_ReplyWithLongLong(ctx,port);
     }
     RedisModule_FreeClusterNodesList(ids);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* Callback for message MSGTYPE_PING */
 void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
+    volatile int __A_VARIABLE;
     RedisModule_Log(ctx,"notice","PING (type %d) RECEIVED from %.*s: '%.*s'",
         type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
     RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,(unsigned char*)"Ohi!",4);
     RedisModule_Call(ctx, "INCR", "c", "pings_received");
+    __A_VARIABLE = 1;
 }
 
 /* Callback for message MSGTYPE_PONG. */
 void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
+    volatile int __A_VARIABLE;
     RedisModule_Log(ctx,"notice","PONG (type %d) RECEIVED from %.*s: '%.*s'",
         type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
+    __A_VARIABLE = 1;
 }
 
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellocluster",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellocluster.pingall",
-        PingallCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        PingallCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellocluster.list",
-        ListCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        ListCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     /* Disable Redis Cluster sharding and redirections. This way every node
      * will be able to access every possible key, regardless of the hash slot.
@@ -114,5 +131,6 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     /* Register our handlers for different message types. */
     RedisModule_RegisterClusterMessageReceiver(ctx,MSGTYPE_PING,PingReceiver);
     RedisModule_RegisterClusterMessageReceiver(ctx,MSGTYPE_PONG,PongReceiver);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellodict.c b/src/modules/hellodict.c
index 651615b..60341b0 100644
--- a/src/modules/hellodict.c
+++ b/src/modules/hellodict.c
@@ -46,11 +46,16 @@ static RedisModuleDict *Keyspace;
  *
  * Set the specified key to the specified value. */
 int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    volatile int __A_VARIABLE;
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModule_DictSet(Keyspace,argv[1],argv[2]);
     /* We need to keep a reference to the value stored at the key, otherwise
      * it would be freed when this callback returns. */
     RedisModule_RetainString(NULL,argv[2]);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -73,11 +78,16 @@ int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
  * Return a list of matching keys, lexicographically between startkey
  * and endkey. No more than 'count' items are emitted. */
 int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 4) return RedisModule_WrongArity(ctx);
+    volatile int __A_VARIABLE;
+    if (argc != 4) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
 
     /* Parse the count argument. */
     long long count;
     if (RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
@@ -101,32 +111,44 @@ int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     /* Cleanup. */
     RedisModule_DictIteratorStop(iter);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellodict",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.set",
-        cmd_SET,"write deny-oom",1,1,0) == REDISMODULE_ERR)
+        cmd_SET,"write deny-oom",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.get",
-        cmd_GET,"readonly",1,1,0) == REDISMODULE_ERR)
+        cmd_GET,"readonly",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.keyrange",
-        cmd_KEYRANGE,"readonly",1,1,0) == REDISMODULE_ERR)
+        cmd_KEYRANGE,"readonly",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     /* Create our global dictionray. Here we'll set our keys and values. */
     Keyspace = RedisModule_CreateDict(NULL);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellotimer.c b/src/modules/hellotimer.c
index 57b111b..b5dbaa7 100644
--- a/src/modules/hellotimer.c
+++ b/src/modules/hellotimer.c
@@ -39,13 +39,16 @@
 
 /* Timer callback. */
 void timerHandler(RedisModuleCtx *ctx, void *data) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(ctx);
     printf("Fired %s!\n", data);
     RedisModule_Free(data);
+    __A_VARIABLE = 1;
 }
 
 /* HELLOTIMER.TIMER*/
 int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -56,21 +59,29 @@ int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModuleTimerID tid = RedisModule_CreateTimer(ctx,delay,timerHandler,buf);
         REDISMODULE_NOT_USED(tid);
     }
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellotimer",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotimer.timer",
-        TimerCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        TimerCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellotype.c b/src/modules/hellotype.c
index ba634c4..8450d04 100644
--- a/src/modules/hellotype.c
+++ b/src/modules/hellotype.c
@@ -61,14 +61,17 @@ struct HelloTypeObject {
 };
 
 struct HelloTypeObject *createHelloTypeObject(void) {
+    volatile int __A_VARIABLE;
     struct HelloTypeObject *o;
     o = RedisModule_Alloc(sizeof(*o));
     o->head = NULL;
     o->len = 0;
+    __A_VARIABLE = 1;
     return o;
 }
 
 void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
+    volatile int __A_VARIABLE;
     struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;
 
     while(next && next->value < ele) {
@@ -84,9 +87,11 @@ void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
         o->head = newnode;
     }
     o->len++;
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeReleaseObject(struct HelloTypeObject *o) {
+    volatile int __A_VARIABLE;
     struct HelloTypeNode *cur, *next;
     cur = o->head;
     while(cur) {
@@ -95,26 +100,33 @@ void HelloTypeReleaseObject(struct HelloTypeObject *o) {
         cur = next;
     }
     RedisModule_Free(o);
+    __A_VARIABLE = 1;
 }
 
 /* ========================= "hellotype" type commands ======================= */
 
 /* HELLOTYPE.INSERT key value */
 int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
     long long value;
     if ((RedisModule_StringToLongLong(argv[2],&value) != REDISMODULE_OK)) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid value: must be a signed 64 bit integer");
     }
 
@@ -132,20 +144,26 @@ int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
 
     RedisModule_ReplyWithLongLong(ctx,hto->len);
     RedisModule_ReplicateVerbatim(ctx);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* HELLOTYPE.RANGE key first count */
 int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 4) return RedisModule_WrongArity(ctx);
+    if (argc != 4) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
@@ -154,6 +172,7 @@ int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
         RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK ||
         first < 0 || count < 0)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,
             "ERR invalid first or count parameters");
     }
@@ -168,25 +187,32 @@ int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
         node = node->next;
     }
     RedisModule_ReplySetArrayLength(ctx,arraylen);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* HELLOTYPE.LEN key */
 int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 2) return RedisModule_WrongArity(ctx);
+    if (argc != 2) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
     struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
     RedisModule_ReplyWithLongLong(ctx,hto ? hto->len : 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -194,8 +220,10 @@ int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
 /* ========================== "hellotype" type methods ======================= */
 
 void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
+    volatile int __A_VARIABLE;
     if (encver != 0) {
         /* RedisModule_Log("warning","Can't load data with version %d", encver);*/
+        __A_VARIABLE = 1;
         return NULL;
     }
     uint64_t elements = RedisModule_LoadUnsigned(rdb);
@@ -204,10 +232,12 @@ void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
         int64_t ele = RedisModule_LoadSigned(rdb);
         HelloTypeInsert(hto,ele);
     }
+    __A_VARIABLE = 1;
     return hto;
 }
 
 void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
+    volatile int __A_VARIABLE;
     struct HelloTypeObject *hto = value;
     struct HelloTypeNode *node = hto->head;
     RedisModule_SaveUnsigned(rdb,hto->len);
@@ -215,30 +245,38 @@ void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
         RedisModule_SaveSigned(rdb,node->value);
         node = node->next;
     }
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
+    volatile int __A_VARIABLE;
     struct HelloTypeObject *hto = value;
     struct HelloTypeNode *node = hto->head;
     while(node) {
         RedisModule_EmitAOF(aof,"HELLOTYPE.INSERT","sl",key,node->value);
         node = node->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* The goal of this function is to return the amount of memory used by
  * the HelloType value. */
 size_t HelloTypeMemUsage(const void *value) {
+    volatile int __A_VARIABLE;
     const struct HelloTypeObject *hto = value;
     struct HelloTypeNode *node = hto->head;
+    __A_VARIABLE = 1;
     return sizeof(*hto) + sizeof(*node)*hto->len;
 }
 
 void HelloTypeFree(void *value) {
+    volatile int __A_VARIABLE;
     HelloTypeReleaseObject(value);
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeDigest(RedisModuleDigest *md, void *value) {
+    volatile int __A_VARIABLE;
     struct HelloTypeObject *hto = value;
     struct HelloTypeNode *node = hto->head;
     while(node) {
@@ -246,16 +284,21 @@ void HelloTypeDigest(RedisModuleDigest *md, void *value) {
         node = node->next;
     }
     RedisModule_DigestEndSequence(md);
+    __A_VARIABLE = 1;
 }
 
 /* This function must be present on each Redis module. It is used in order to
  * register the commands into the Redis server. */
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellotype",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RedisModuleTypeMethods tm = {
         .version = REDISMODULE_TYPE_METHOD_VERSION,
@@ -268,19 +311,29 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     };
 
     HelloType = RedisModule_CreateDataType(ctx,"hellotype",0,&tm);
-    if (HelloType == NULL) return REDISMODULE_ERR;
+    if (HelloType == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.insert",
-        HelloTypeInsert_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        HelloTypeInsert_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.range",
-        HelloTypeRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
+        HelloTypeRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.len",
-        HelloTypeLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
+        HelloTypeLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/testmodule.c b/src/modules/testmodule.c
index 67a8617..c64384e 100644
--- a/src/modules/testmodule.c
+++ b/src/modules/testmodule.c
@@ -38,10 +38,15 @@
 
 /* Return true if the reply and the C null term string matches. */
 int TestMatchReply(RedisModuleCallReply *reply, char *str) {
+    volatile int __A_VARIABLE;
     RedisModuleString *mystr;
     mystr = RedisModule_CreateStringFromCallReply(reply);
-    if (!mystr) return 0;
+    if (!mystr) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     const char *ptr = RedisModule_StringPtrLen(mystr,NULL);
+    __A_VARIABLE = 1;
     return strcmp(ptr,str) == 0;
 }
 
@@ -49,6 +54,7 @@ int TestMatchReply(RedisModuleCallReply *reply, char *str) {
 
 /* TEST.CALL -- Test Call() API. */
 int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -70,15 +76,18 @@ int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     if (!TestMatchReply(item1,"1234")) goto fail;
 
     RedisModule_ReplyWithSimpleString(ctx,"OK");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 
 fail:
     RedisModule_ReplyWithSimpleString(ctx,"ERR");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* TEST.STRING.APPEND -- Test appending to an existing string object. */
 int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -86,11 +95,13 @@ int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_StringAppendBuffer(ctx,s,"bar",3);
     RedisModule_ReplyWithString(ctx,s);
     RedisModule_FreeString(ctx,s);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* TEST.STRING.APPEND.AM -- Test append with retain when auto memory is on. */
 int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -100,13 +111,16 @@ int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_StringAppendBuffer(ctx,s,"bar",3);
     RedisModule_ReplyWithString(ctx,s);
     RedisModule_FreeString(ctx,s);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 /* TEST.STRING.PRINTF -- Test string formatting. */
 int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     RedisModule_AutoMemory(ctx);
     if (argc < 3) {
+        __A_VARIABLE = 1;
         return RedisModule_WrongArity(ctx);
     }
     RedisModuleString *s = RedisModule_CreateStringPrintf(ctx, 
@@ -118,56 +132,71 @@ int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     RedisModule_ReplyWithString(ctx,s);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int failTest(RedisModuleCtx *ctx, const char *msg) {
+    volatile int __A_VARIABLE;
     RedisModule_ReplyWithError(ctx, msg);
+    __A_VARIABLE = 1;
     return REDISMODULE_ERR;
 }
 
 int TestUnlink(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     RedisModule_AutoMemory(ctx);
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     RedisModuleKey *k = RedisModule_OpenKey(ctx, RedisModule_CreateStringPrintf(ctx, "unlinked"), REDISMODULE_WRITE | REDISMODULE_READ);
-    if (!k) return failTest(ctx, "Could not create key");
+    if (!k) {
+        __A_VARIABLE = 1;
+        return failTest(ctx, "Could not create key");
+    }
     
     if (REDISMODULE_ERR == RedisModule_StringSet(k, RedisModule_CreateStringPrintf(ctx, "Foobar"))) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not set string value");
     }
 
     RedisModuleCallReply *rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
     if (!rep || RedisModule_CallReplyInteger(rep) != 1) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Key does not exist before unlink");
     }
 
     if (REDISMODULE_ERR == RedisModule_UnlinkKey(k)) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not unlink key");
     }
 
     rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
     if (!rep || RedisModule_CallReplyInteger(rep) != 0) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not verify key to be unlinked");
     }
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
     
 }
 
 int NotifyCallback(RedisModuleCtx *ctx, int type, const char *event,
                    RedisModuleString *key) {
+  volatile int __A_VARIABLE;
   /* Increment a counter on the notifications: for each key notified we
    * increment a counter */
   RedisModule_Log(ctx, "notice", "Got event type %d, event %s, key %s", type,
                   event, RedisModule_StringPtrLen(key, NULL));
 
   RedisModule_Call(ctx, "HINCRBY", "csc", "notifications", key, "1");
+  __A_VARIABLE = 1;
   return REDISMODULE_OK;
 }
 
 /* TEST.NOTIFICATIONS -- Test Keyspace Notifications. */
 int TestNotifications(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -227,6 +256,7 @@ int TestNotifications(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     RedisModule_Call(ctx, "FLUSHDB", "");
 
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 err:
     RedisModule_Call(ctx, "FLUSHDB", "");
@@ -236,6 +266,7 @@ err:
 
 /* TEST.CTXFLAGS -- Test GetContextFlags. */
 int TestCtxFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argc);
     REDISMODULE_NOT_USED(argv);
 
@@ -297,9 +328,11 @@ end:
 
     if (!ok) {
         RedisModule_Log(ctx, "warning", "Failed CTXFLAGS Test. Reason: %s", errString);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithSimpleString(ctx, "ERR");
     }
 
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -308,11 +341,13 @@ end:
 /* Return 1 if the reply matches the specified string, otherwise log errors
  * in the server log and return 0. */
 int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {
+    volatile int __A_VARIABLE;
     RedisModuleString *mystr, *expected;
 
     if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_STRING) {
         RedisModule_Log(ctx,"warning","Unexpected reply type %d",
             RedisModule_CallReplyType(reply));
+        __A_VARIABLE = 1;
         return 0;
     }
     mystr = RedisModule_CreateStringFromCallReply(reply);
@@ -323,17 +358,21 @@ int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char
         RedisModule_Log(ctx,"warning",
             "Unexpected string reply '%s' (instead of '%s')",
             mystr_ptr, expected_ptr);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Return 1 if the reply matches the specified integer, otherwise log errors
  * in the server log and return 0. */
 int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, long long expected) {
+    volatile int __A_VARIABLE;
     if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_INTEGER) {
         RedisModule_Log(ctx,"warning","Unexpected reply type %d",
             RedisModule_CallReplyType(reply));
+        __A_VARIABLE = 1;
         return 0;
     }
     long long val = RedisModule_CallReplyInteger(reply);
@@ -341,8 +380,10 @@ int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, lon
         RedisModule_Log(ctx,"warning",
             "Unexpected integer reply '%lld' (instead of '%lld')",
             val, expected);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -354,6 +395,7 @@ int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, lon
 
 /* TEST.IT -- Run all the tests. */
 int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
@@ -389,48 +431,68 @@ int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
 
     RedisModule_ReplyWithSimpleString(ctx,"ALL TESTS PASSED");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 
 fail:
     RedisModule_ReplyWithSimpleString(ctx,
         "SOME TEST NOT PASSED! Check server logs");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"test",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.call",
-        TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.append",
-        TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.append.am",
-        TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.printf",
-        TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.ctxflags",
-        TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR)
+        TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     
     if (RedisModule_CreateCommand(ctx,"test.unlink",
-        TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.it",
-        TestIt,"readonly",1,1,1) == REDISMODULE_ERR)
+        TestIt,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     RedisModule_SubscribeToKeyspaceEvents(ctx,
                                             REDISMODULE_NOTIFY_HASH |
@@ -438,8 +500,11 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
                                             REDISMODULE_NOTIFY_STRING,
                                         NotifyCallback);
     if (RedisModule_CreateCommand(ctx,"test.notify",
-        TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/multi.c b/src/multi.c
index 5971f46..eb88855 100644
--- a/src/multi.c
+++ b/src/multi.c
@@ -33,13 +33,16 @@
 
 /* Client state initialization for MULTI/EXEC */
 void initClientMultiState(client *c) {
+    volatile int __A_VARIABLE;
     c->mstate.commands = NULL;
     c->mstate.count = 0;
     c->mstate.cmd_flags = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Release all the resources associated with MULTI/EXEC state */
 void freeClientMultiState(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < c->mstate.count; j++) {
@@ -51,10 +54,12 @@ void freeClientMultiState(client *c) {
         zfree(mc->argv);
     }
     zfree(c->mstate.commands);
+    __A_VARIABLE = 1;
 }
 
 /* Add a new command into the MULTI commands queue */
 void queueMultiCommand(client *c) {
+    volatile int __A_VARIABLE;
     multiCmd *mc;
     int j;
 
@@ -69,51 +74,65 @@ void queueMultiCommand(client *c) {
         incrRefCount(mc->argv[j]);
     c->mstate.count++;
     c->mstate.cmd_flags |= c->cmd->flags;
+    __A_VARIABLE = 1;
 }
 
 void discardTransaction(client *c) {
+    volatile int __A_VARIABLE;
     freeClientMultiState(c);
     initClientMultiState(c);
     c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
     unwatchAllKeys(c);
+    __A_VARIABLE = 1;
 }
 
 /* Flag the transacation as DIRTY_EXEC so that EXEC will fail.
  * Should be called every time there is an error while queueing a command. */
 void flagTransaction(client *c) {
+    volatile int __A_VARIABLE;
     if (c->flags & CLIENT_MULTI)
         c->flags |= CLIENT_DIRTY_EXEC;
+    __A_VARIABLE = 1;
 }
 
 void multiCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"MULTI calls can not be nested");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_MULTI;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void discardCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"DISCARD without MULTI");
+        __A_VARIABLE = 1;
         return;
     }
     discardTransaction(c);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* Send a MULTI command to all the slaves and AOF file. Check the execCommand
  * implementation for more information. */
 void execCommandPropagateMulti(client *c) {
+    volatile int __A_VARIABLE;
     robj *multistring = createStringObject("MULTI",5);
 
     propagate(server.multiCommand,c->db->id,&multistring,1,
               PROPAGATE_AOF|PROPAGATE_REPL);
     decrRefCount(multistring);
+    __A_VARIABLE = 1;
 }
 
 void execCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
     robj **orig_argv;
     int orig_argc;
@@ -123,6 +142,7 @@ void execCommand(client *c) {
 
     if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"EXEC without MULTI");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -211,6 +231,7 @@ handle_monitor:
      * table, and we do it here with correct ordering. */
     if (listLength(server.monitors) && !server.loading)
         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
+    __A_VARIABLE = 1;
 }
 
 /* ===================== WATCH (CAS alike for MULTI/EXEC) ===================
@@ -232,6 +253,7 @@ typedef struct watchedKey {
 
 /* Watch for the specified key */
 void watchForKey(client *c, robj *key) {
+    volatile int __A_VARIABLE;
     list *clients = NULL;
     listIter li;
     listNode *ln;
@@ -241,8 +263,10 @@ void watchForKey(client *c, robj *key) {
     listRewind(c->watched_keys,&li);
     while((ln = listNext(&li))) {
         wk = listNodeValue(ln);
-        if (wk->db == c->db && equalStringObjects(key,wk->key))
-            return; /* Key already watched */
+        if (wk->db == c->db && equalStringObjects(key,wk->key)) {
+            __A_VARIABLE = 1;
+            return;
+        } /* Key already watched */
     }
     /* This key is not already watched in this DB. Let's add it */
     clients = dictFetchValue(c->db->watched_keys,key);
@@ -258,15 +282,20 @@ void watchForKey(client *c, robj *key) {
     wk->db = c->db;
     incrRefCount(key);
     listAddNodeTail(c->watched_keys,wk);
+    __A_VARIABLE = 1;
 }
 
 /* Unwatch all the keys watched by this client. To clean the EXEC dirty
  * flag is up to the caller. */
 void unwatchAllKeys(client *c) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
 
-    if (listLength(c->watched_keys) == 0) return;
+    if (listLength(c->watched_keys) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     listRewind(c->watched_keys,&li);
     while((ln = listNext(&li))) {
         list *clients;
@@ -286,18 +315,26 @@ void unwatchAllKeys(client *c) {
         decrRefCount(wk->key);
         zfree(wk);
     }
+    __A_VARIABLE = 1;
 }
 
 /* "Touch" a key, so that if this key is being WATCHed by some client the
  * next EXEC will fail. */
 void touchWatchedKey(redisDb *db, robj *key) {
+    volatile int __A_VARIABLE;
     list *clients;
     listIter li;
     listNode *ln;
 
-    if (dictSize(db->watched_keys) == 0) return;
+    if (dictSize(db->watched_keys) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clients = dictFetchValue(db->watched_keys, key);
-    if (!clients) return;
+    if (!clients) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
     /* Check if we are already watching for this key */
@@ -307,6 +344,7 @@ void touchWatchedKey(redisDb *db, robj *key) {
 
         c->flags |= CLIENT_DIRTY_CAS;
     }
+    __A_VARIABLE = 1;
 }
 
 /* On FLUSHDB or FLUSHALL all the watched keys that are present before the
@@ -314,6 +352,7 @@ void touchWatchedKey(redisDb *db, robj *key) {
  * be touched. "dbid" is the DB that's getting the flush. -1 if it is
  * a FLUSHALL operation (all the DBs flushed). */
 void touchWatchedKeysOnFlush(int dbid) {
+    volatile int __A_VARIABLE;
     listIter li1, li2;
     listNode *ln;
 
@@ -334,22 +373,28 @@ void touchWatchedKeysOnFlush(int dbid) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void watchCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"WATCH inside MULTI is not allowed");
+        __A_VARIABLE = 1;
         return;
     }
     for (j = 1; j < c->argc; j++)
         watchForKey(c,c->argv[j]);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void unwatchCommand(client *c) {
+    volatile int __A_VARIABLE;
     unwatchAllKeys(c);
     c->flags &= (~CLIENT_DIRTY_CAS);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
diff --git a/src/networking.c b/src/networking.c
index a30a447..a4bf048 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -42,40 +42,53 @@ static void setProtocolError(const char *errstr, client *c);
  * including internal fragmentation. This function is used in order to compute
  * the client output buffer size. */
 size_t sdsZmallocSize(sds s) {
+    volatile int __A_VARIABLE;
     void *sh = sdsAllocPtr(s);
+    __A_VARIABLE = 1;
     return zmalloc_size(sh);
 }
 
 /* Return the amount of memory used by the sds string at object->ptr
  * for a string object. */
 size_t getStringObjectSdsUsedMemory(robj *o) {
+    volatile int __A_VARIABLE;
     serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
     switch(o->encoding) {
-    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
-    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
-    default: return 0; /* Just integer encoding for now. */
+    case OBJ_ENCODING_RAW: __A_VARIABLE = 1;
+        return sdsZmallocSize(o->ptr);
+    case OBJ_ENCODING_EMBSTR: __A_VARIABLE = 1;
+        return zmalloc_size(o)-sizeof(robj);
+    default: __A_VARIABLE = 1;
+        return 0; /* Just integer encoding for now. */
     }
 }
 
 /* Client.reply list dup and free methods. */
 void *dupClientReplyValue(void *o) {
+    volatile int __A_VARIABLE;
     clientReplyBlock *old = o;
     clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
     memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
+    __A_VARIABLE = 1;
     return buf;
 }
 
 void freeClientReplyValue(void *o) {
+    volatile int __A_VARIABLE;
     zfree(o);
+    __A_VARIABLE = 1;
 }
 
 int listMatchObjects(void *a, void *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return equalStringObjects(a,b);
 }
 
 /* This function links the client to the global linked list of clients.
  * unlinkClient() does the opposite, among other things. */
 void linkClient(client *c) {
+    volatile int __A_VARIABLE;
     listAddNodeTail(server.clients,c);
     /* Note that we remember the linked list node where the client is stored,
      * this way removing the client in unlinkClient() will not require
@@ -83,9 +96,11 @@ void linkClient(client *c) {
     c->client_list_node = listLast(server.clients);
     uint64_t id = htonu64(c->id);
     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
+    __A_VARIABLE = 1;
 }
 
 client *createClient(int fd) {
+    volatile int __A_VARIABLE;
     /* FLEXOS NOTE: here we are sharing the entire client structure: this is
      * not needed! We should share the send buffer only. Come back and fix this
      * later. */
@@ -105,6 +120,7 @@ client *createClient(int fd) {
         {
             close(fd);
             zfree(c);
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -163,6 +179,7 @@ client *createClient(int fd) {
     listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
     if (fd != -1) linkClient(c);
     initClientMultiState(c);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -174,6 +191,7 @@ client *createClient(int fd) {
  * If we fail and there is more data to write, compared to what the socket
  * buffers can hold, then we'll really install the handler. */
 void clientInstallWriteHandler(client *c) {
+    volatile int __A_VARIABLE;
     /* Schedule the client to write the output buffers to the socket only
      * if not already done and, for slaves, if the slave can actually receive
      * writes at this stage. */
@@ -190,6 +208,7 @@ void clientInstallWriteHandler(client *c) {
         c->flags |= CLIENT_PENDING_WRITE;
         listAddNodeHead(server.clients_pending_write,c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called every time we are going to transmit new data
@@ -215,25 +234,39 @@ void clientInstallWriteHandler(client *c) {
  * data to the clients output buffers. If the function returns C_ERR no
  * data should be appended to the output buffers. */
 int prepareClientToWrite(client *c) {
+    volatile int __A_VARIABLE;
     /* If it's the Lua client we always return ok without installing any
      * handler since there is no socket at all. */
-    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
+    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* CLIENT REPLY OFF / SKIP handling: don't send replies. */
-    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
+    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
      * is set. */
     if ((c->flags & CLIENT_MASTER) &&
-        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
+        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    }
 
-    if (c->fd <= 0) return C_ERR; /* Fake client for AOF loading. */
+    if (c->fd <= 0) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    } /* Fake client for AOF loading. */
 
     /* Schedule the client to write the output buffers to the socket, unless
      * it should already be setup to do so (it has already pending data). */
     if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);
 
     /* Authorize the caller to queue in the output buffer of this client. */
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -242,24 +275,39 @@ int prepareClientToWrite(client *c) {
  * -------------------------------------------------------------------------- */
 
 int _addReplyToBuffer(client *c, const char *s, size_t len) {
+    volatile int __A_VARIABLE;
     size_t available = sizeof(c->buf)-c->bufpos;
 
-    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* If there already are entries in the reply list, we cannot
      * add anything more to the static buffer. */
-    if (listLength(c->reply) > 0) return C_ERR;
+    if (listLength(c->reply) > 0) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Check that the buffer has enough space available for this string. */
-    if (len > available) return C_ERR;
+    if (len > available) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     memcpy(c->buf+c->bufpos,s,len);
     c->bufpos+=len;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 void _addReplyStringToList(client *c, const char *s, size_t len) {
-    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
+    volatile int __A_VARIABLE;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listNode *ln = listLast(c->reply);
     clientReplyBlock *tail = ln? listNodeValue(ln): NULL;
@@ -292,6 +340,7 @@ void _addReplyStringToList(client *c, const char *s, size_t len) {
         c->reply_bytes += tail->size;
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -301,7 +350,11 @@ void _addReplyStringToList(client *c, const char *s, size_t len) {
 
 /* Add the object 'obj' string representation to the client output buffer. */
 void addReply(client *c, robj *obj) {
-    if (prepareClientToWrite(c) != C_OK) return;
+    volatile int __A_VARIABLE;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (sdsEncodedObject(obj)) {
         if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
@@ -317,19 +370,23 @@ void addReply(client *c, robj *obj) {
     } else {
         serverPanic("Wrong obj->encoding in addReply()");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add the SDS 's' string to the client output buffer, as a side effect
  * the SDS string is freed. */
 void addReplySds(client *c, sds s) {
+    volatile int __A_VARIABLE;
     if (prepareClientToWrite(c) != C_OK) {
         /* The caller expects the sds to be free'd. */
         sdsfree(s);
+        __A_VARIABLE = 1;
         return;
     }
     if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)
         _addReplyStringToList(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* This low level function just adds whatever protocol you send it to the
@@ -341,9 +398,14 @@ void addReplySds(client *c, sds s) {
  * _addReplyStringToList() if we fail to extend the existing tail object
  * in the list of objects. */
 void addReplyString(client *c, const char *s, size_t len) {
-    if (prepareClientToWrite(c) != C_OK) return;
+    volatile int __A_VARIABLE;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (_addReplyToBuffer(c,s,len) != C_OK)
         _addReplyStringToList(c,s,len);
+    __A_VARIABLE = 1;
 }
 
 /* Low level function called by the addReplyError...() functions.
@@ -355,6 +417,7 @@ void addReplyString(client *c, const char *s, size_t len) {
  * code provided is used, otherwise the string "-ERR " for the generic
  * error code is automatically added. */
 void addReplyErrorLength(client *c, const char *s, size_t len) {
+    volatile int __A_VARIABLE;
     /* If the string already starts with "-..." then the error code
      * is provided by the caller. Otherwise we use "-ERR". */
     if (!len || s[0] != '-') addReplyString(c,"-ERR ",5);
@@ -379,13 +442,17 @@ void addReplyErrorLength(client *c, const char *s, size_t len) {
                              "to its %s: '%s' after processing the command "
                              "'%s'", from, to, s, cmdname);
     }
+    __A_VARIABLE = 1;
 }
 
 void addReplyError(client *c, const char *err) {
+    volatile int __A_VARIABLE;
     addReplyErrorLength(c,err,strlen(err));
+    __A_VARIABLE = 1;
 }
 
 void addReplyErrorFormat(client *c, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     size_t l, j;
     va_list ap;
     va_start(ap,fmt);
@@ -399,40 +466,53 @@ void addReplyErrorFormat(client *c, const char *fmt, ...) {
     }
     addReplyErrorLength(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatusLength(client *c, const char *s, size_t len) {
+    volatile int __A_VARIABLE;
     addReplyString(c,"+",1);
     addReplyString(c,s,len);
     addReplyString(c,"\r\n",2);
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatus(client *c, const char *status) {
+    volatile int __A_VARIABLE;
     addReplyStatusLength(c,status,strlen(status));
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatusFormat(client *c, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     va_start(ap,fmt);
     sds s = sdscatvprintf(sdsempty(),fmt,ap);
     va_end(ap);
     addReplyStatusLength(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* Adds an empty object to the reply list that will contain the multi bulk
  * length, which is not known when this function is called. */
 void *addDeferredMultiBulkLength(client *c) {
+    volatile int __A_VARIABLE;
     /* Note that we install the write event here even if the object is not
      * ready to be sent, since we are sure that before returning to the
      * event loop setDeferredMultiBulkLength() will be called. */
-    if (prepareClientToWrite(c) != C_OK) return NULL;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     listAddNodeTail(c->reply,NULL); /* NULL is our placeholder. */
+    __A_VARIABLE = 1;
     return listLast(c->reply);
 }
 
 /* Populate the length object and try gluing it to the next chunk. */
 void setDeferredMultiBulkLength(client *c, void *node, long length) {
+    volatile int __A_VARIABLE;
     listNode *ln = (listNode*)node;
     clientReplyBlock *next;
     char lenstr[128];
@@ -440,7 +520,10 @@ void setDeferredMultiBulkLength(client *c, void *node, long length) {
 
     /* Abort when *node is NULL: when the client should not accept writes
      * we return NULL in addDeferredMultiBulkLength() */
-    if (node == NULL) return;
+    if (node == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     serverAssert(!listNodeValue(ln));
 
     /* Normally we fill this dummy NULL node, added by addDeferredMultiBulkLength(),
@@ -471,10 +554,12 @@ void setDeferredMultiBulkLength(client *c, void *node, long length) {
         c->reply_bytes += buf->size;
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
+    __A_VARIABLE = 1;
 }
 
 /* Add a double as a bulk reply */
 void addReplyDouble(client *c, double d) {
+    volatile int __A_VARIABLE;
     char dbuf[128], sbuf[128];
     int dlen, slen;
     if (isinf(d)) {
@@ -486,15 +571,18 @@ void addReplyDouble(client *c, double d) {
         slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
         addReplyString(c,sbuf,slen);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add a long double as a bulk reply, but uses a human readable formatting
  * of the double instead of exposing the crude behavior of doubles to the
  * dear user. */
 void addReplyHumanLongDouble(client *c, long double d) {
+    volatile int __A_VARIABLE;
     robj *o = createStringObjectFromLongDouble(d,1);
     addReplyBulk(c,o);
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* Add a long long as integer reply or bulk len / multi bulk count.
@@ -522,23 +610,28 @@ void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {
 }
 
 void addReplyLongLong(client *c, long long ll) {
+    volatile int __A_VARIABLE;
     if (ll == 0)
         addReply(c,shared.czero);
     else if (ll == 1)
         addReply(c,shared.cone);
     else
         addReplyLongLongWithPrefix(c,ll,':');
+    __A_VARIABLE = 1;
 }
 
 void addReplyMultiBulkLen(client *c, long length) {
+    volatile int __A_VARIABLE;
     if (length < OBJ_SHARED_BULKHDR_LEN)
         addReply(c,shared.mbulkhdr[length]);
     else
         addReplyLongLongWithPrefix(c,length,'*');
+    __A_VARIABLE = 1;
 }
 
 /* Create the length prefix of a bulk reply, example: $2234 */
 void addReplyBulkLen(client *c, robj *obj) {
+    volatile int __A_VARIABLE;
     size_t len;
 
     if (sdsEncodedObject(obj)) {
@@ -561,45 +654,56 @@ void addReplyBulkLen(client *c, robj *obj) {
         addReply(c,shared.bulkhdr[len]);
     else
         addReplyLongLongWithPrefix(c,len,'$');
+    __A_VARIABLE = 1;
 }
 
 /* Add a Redis Object as a bulk reply */
 void addReplyBulk(client *c, robj *obj) {
+    volatile int __A_VARIABLE;
     addReplyBulkLen(c,obj);
     addReply(c,obj);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add a C buffer as bulk reply */
 void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
+    volatile int __A_VARIABLE;
     addReplyLongLongWithPrefix(c,len,'$');
     addReplyString(c,p,len);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add sds to reply (takes ownership of sds and frees it) */
 void addReplyBulkSds(client *c, sds s)  {
+    volatile int __A_VARIABLE;
     addReplyLongLongWithPrefix(c,sdslen(s),'$');
     addReplySds(c,s);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add a C null term string as bulk reply */
 void addReplyBulkCString(client *c, const char *s) {
+    volatile int __A_VARIABLE;
     if (s == NULL) {
         addReply(c,shared.nullbulk);
     } else {
         addReplyBulkCBuffer(c,s,strlen(s));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add a long long as a bulk reply */
 void addReplyBulkLongLong(client *c, long long ll) {
+    volatile int __A_VARIABLE;
     char buf[64];
     int len;
 
     len = ll2string(buf,64,ll);
     addReplyBulkCBuffer(c,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* Add an array of C strings as status replies with a heading.
@@ -607,6 +711,7 @@ void addReplyBulkLongLong(client *c, long long ll) {
  * subcommands in response to the 'help' subcommand. The help array
  * is terminated by NULL sentinel. */
 void addReplyHelp(client *c, const char **help) {
+    volatile int __A_VARIABLE;
     sds cmd = sdsnew((char*) c->argv[0]->ptr);
     void *blenp = addDeferredMultiBulkLength(c);
     int blen = 0;
@@ -620,48 +725,59 @@ void addReplyHelp(client *c, const char **help) {
 
     blen++;  /* Account for the header line(s). */
     setDeferredMultiBulkLength(c,blenp,blen);
+    __A_VARIABLE = 1;
 }
 
 /* Add a suggestive error reply.
  * This function is typically invoked by from commands that support
  * subcommands in response to an unknown subcommand or argument error. */
 void addReplySubcommandSyntaxError(client *c) {
+    volatile int __A_VARIABLE;
     sds cmd = sdsnew((char*) c->argv[0]->ptr);
     sdstoupper(cmd);
     addReplyErrorFormat(c,
         "Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.",
         (char*)c->argv[1]->ptr,cmd);
     sdsfree(cmd);
+    __A_VARIABLE = 1;
 }
 
 /* Append 'src' client output buffers into 'dst' client output buffers. 
  * This function clears the output buffers of 'src' */
 void AddReplyFromClient(client *dst, client *src) {
-    if (prepareClientToWrite(dst) != C_OK)
+    volatile int __A_VARIABLE;
+    if (prepareClientToWrite(dst) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     addReplyString(dst,src->buf, src->bufpos);
     if (listLength(src->reply))
         listJoin(dst->reply,src->reply);
     dst->reply_bytes += src->reply_bytes;
     src->reply_bytes = 0;
     src->bufpos = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Copy 'src' client output buffers into 'dst' client output buffers.
  * The function takes care of freeing the old output buffers of the
  * destination client. */
 void copyClientOutputBuffer(client *dst, client *src) {
+    volatile int __A_VARIABLE;
     listRelease(dst->reply);
     dst->sentlen = 0;
     dst->reply = listDup(src->reply);
     memcpy(dst->buf,src->buf,src->bufpos);
     dst->bufpos = src->bufpos;
     dst->reply_bytes = src->reply_bytes;
+    __A_VARIABLE = 1;
 }
 
 /* Return true if the specified client has pending reply buffers to write to
  * the socket. */
 int clientHasPendingReplies(client *c) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return c->bufpos || listLength(c->reply);
 }
 
@@ -689,12 +805,14 @@ static char err[] __section(".data_shared") =
 
 #define MAX_ACCEPTS_PER_CALL 1000
 static void acceptCommonHandler(int fd, int flags, char *ip) {
+    volatile int __A_VARIABLE;
     client *c;
     if ((c = createClient(fd)) == NULL) {
         serverLog(LL_WARNING,
             "Error registering fd event for the new client: %s (fd=%d)",
             strerror(errno),fd);
         close(fd); /* May be already closed, just ignore errors */
+        __A_VARIABLE = 1;
         return;
     }
     /* If maxclient directive is set and this is one client more... close the
@@ -710,6 +828,7 @@ static void acceptCommonHandler(int fd, int flags, char *ip) {
         }
         server.stat_rejected_conn++;
         freeClient(c);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -729,15 +848,18 @@ static void acceptCommonHandler(int fd, int flags, char *ip) {
             }
             server.stat_rejected_conn++;
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
     }
 
     server.stat_numconnections++;
     c->flags |= flags;
+    __A_VARIABLE = 1;
 }
 
 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
     char cip[NET_IP_STR_LEN];
     UNUSED(el);
@@ -750,14 +872,17 @@ void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
         acceptCommonHandler(cfd,0,cip);
     }
+    __A_VARIABLE = 1;
 }
 
 void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     int cfd, max = MAX_ACCEPTS_PER_CALL;
     UNUSED(el);
     UNUSED(mask);
@@ -769,35 +894,42 @@ void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
         acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 static void freeClientArgv(client *c) {
+    volatile int __A_VARIABLE;
     int j;
     for (j = 0; j < c->argc; j++)
         decrRefCount(c->argv[j]);
     c->argc = 0;
     c->cmd = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Close all the slaves connections. This is useful in chained replication
  * when we resync with our own master and want to force all our slaves to
  * resync with us as well. */
 void disconnectSlaves(void) {
+    volatile int __A_VARIABLE;
     while (listLength(server.slaves)) {
         listNode *ln = listFirst(server.slaves);
         freeClient((client*)ln->value);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Remove the specified client from global lists where the client could
  * be referenced, not including the Pub/Sub channels.
  * This is used by freeClient() and replicationCacheMaster(). */
 void unlinkClient(client *c) {
+    volatile int __A_VARIABLE;
     listNode *ln;
 
     /* If this is marked as current client unset it. */
@@ -848,15 +980,18 @@ void unlinkClient(client *c) {
         listDelNode(server.unblocked_clients,ln);
         c->flags &= ~CLIENT_UNBLOCKED;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeClient(client *c) {
+    volatile int __A_VARIABLE;
     listNode *ln;
 
     /* If a client is protected, yet we need to free it right now, make sure
      * to at least use asynchronous freeing. */
     if (c->flags & CLIENT_PROTECTED) {
         freeClientAsync(c);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -872,6 +1007,7 @@ void freeClient(client *c) {
                           CLIENT_BLOCKED)))
         {
             replicationCacheMaster(c);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -948,6 +1084,7 @@ void freeClient(client *c) {
     freeClientMultiState(c);
     sdsfree(c->peerid);
     flexos_free_whitelist(c);
+    __A_VARIABLE = 1;
 }
 
 /* Schedule a client to free it at a safe time in the serverCron() function.
@@ -955,12 +1092,18 @@ void freeClient(client *c) {
  * a context where calling freeClient() is not possible, because the client
  * should be valid for the continuation of the flow of the program. */
 void freeClientAsync(client *c) {
-    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
+    volatile int __A_VARIABLE;
+    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) {
+        __A_VARIABLE = 1;
+        return;
+    }
     c->flags |= CLIENT_CLOSE_ASAP;
     listAddNodeTail(server.clients_to_close,c);
+    __A_VARIABLE = 1;
 }
 
 void freeClientsInAsyncFreeQueue(void) {
+    volatile int __A_VARIABLE;
     while (listLength(server.clients_to_close)) {
         listNode *ln = listFirst(server.clients_to_close);
         client *c = listNodeValue(ln);
@@ -969,14 +1112,17 @@ void freeClientsInAsyncFreeQueue(void) {
         freeClient(c);
         listDelNode(server.clients_to_close,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return a client by ID, or NULL if the client ID is not in the set
  * of registered clients. Note that "fake clients", created with -1 as FD,
  * are not registered clients. */
 client *lookupClientByID(uint64_t id) {
+    volatile int __A_VARIABLE;
     id = htonu64(id);
     client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
+    __A_VARIABLE = 1;
     return (c == raxNotFound) ? NULL : c;
 }
 
@@ -1076,9 +1222,11 @@ int writeToClient(int fd, client *c, int handler_installed) {
 
 /* Write event handler. Just send data to the client. */
 void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     UNUSED(el);
     UNUSED(mask);
     writeToClient(fd,privdata,1);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called just before entering the event loop, in the hope
@@ -1086,6 +1234,7 @@ void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
  * need to use a syscall in order to install the writable event handler,
  * get it called, and so forth. */
 int handleClientsWithPendingWrites(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     int processed = listLength(server.clients_pending_write);
@@ -1124,11 +1273,13 @@ int handleClientsWithPendingWrites(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return processed;
 }
 
 /* resetClient prepare the client to process the next command */
 void resetClient(client *c) {
+    volatile int __A_VARIABLE;
     redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
 
     freeClientArgv(c);
@@ -1149,6 +1300,7 @@ void resetClient(client *c) {
         c->flags |= CLIENT_REPLY_SKIP;
         c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This funciton is used when we want to re-enter the event loop but there
@@ -1165,18 +1317,22 @@ void resetClient(client *c) {
  * 2) Moreover it makes sure that if the client is freed in a different code
  *    path, it is not really released, but only marked for later release. */
 void protectClient(client *c) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_PROTECTED;
     aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
     aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    __A_VARIABLE = 1;
 }
 
 /* This will undo the client protection done by protectClient() */
 void unprotectClient(client *c) {
+    volatile int __A_VARIABLE;
     if (c->flags & CLIENT_PROTECTED) {
         c->flags &= ~CLIENT_PROTECTED;
         aeCreateFileEvent(server.el,c->fd,AE_READABLE,readQueryFromClient,c);
         if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,
@@ -1187,6 +1343,7 @@ void unprotectClient(client *c) {
  * a protocol error: in such a case the client structure is setup to reply
  * with the error and close the connection. */
 int processInlineBuffer(client *c) {
+    volatile int __A_VARIABLE;
     char *newline;
     int argc, j, linefeed_chars = 1;
     sds *argv, aux;
@@ -1201,6 +1358,7 @@ int processInlineBuffer(client *c) {
             addReplyError(c,"Protocol error: too big inline request");
             setProtocolError("too big inline request",c);
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1216,6 +1374,7 @@ int processInlineBuffer(client *c) {
     if (argv == NULL) {
         addReplyError(c,"Protocol error: unbalanced quotes in request");
         setProtocolError("unbalanced quotes in inline request",c);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1244,6 +1403,7 @@ int processInlineBuffer(client *c) {
         }
     }
     s_free(argv);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1251,6 +1411,7 @@ int processInlineBuffer(client *c) {
  * and set the client as CLIENT_CLOSE_AFTER_REPLY. */
 #define PROTO_DUMP_LEN 128
 static void setProtocolError(const char *errstr, client *c) {
+    volatile int __A_VARIABLE;
     if (server.verbosity <= LL_VERBOSE) {
         sds client = catClientInfoString(sdsempty(),c);
 
@@ -1275,6 +1436,7 @@ static void setProtocolError(const char *errstr, client *c) {
         sdsfree(client);
     }
     c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+    __A_VARIABLE = 1;
 }
 
 /* Process the query buffer for client 'c', setting up the client argument
@@ -1289,6 +1451,7 @@ static void setProtocolError(const char *errstr, client *c) {
  * command is in RESP format, so the first byte in the command is found
  * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */
 int processMultibulkBuffer(client *c) {
+    volatile int __A_VARIABLE;
     char *newline = NULL;
     int ok;
     long long ll;
@@ -1304,12 +1467,15 @@ int processMultibulkBuffer(client *c) {
                 addReplyError(c,"Protocol error: too big mbulk count string");
                 setProtocolError("too big mbulk count string",c);
             }
+            __A_VARIABLE = 1;
             return C_ERR;
         }
 
         /* Buffer should also contain \n */
-        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
+        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2)) {
+            __A_VARIABLE = 1;
             return C_ERR;
+        }
 
         /* We know for sure there is a whole line since newline != NULL,
          * so go ahead and find out the multi bulk length. */
@@ -1318,12 +1484,16 @@ int processMultibulkBuffer(client *c) {
         if (!ok || ll > 1024*1024) {
             addReplyError(c,"Protocol error: invalid multibulk length");
             setProtocolError("invalid mbulk count",c);
+            __A_VARIABLE = 1;
             return C_ERR;
         }
 
         c->qb_pos = (newline-c->querybuf)+2;
 
-        if (ll <= 0) return C_OK;
+        if (ll <= 0) {
+            __A_VARIABLE = 1;
+            return C_OK;
+        }
 
         c->multibulklen = ll;
 
@@ -1342,6 +1512,7 @@ int processMultibulkBuffer(client *c) {
                     addReplyError(c,
                         "Protocol error: too big bulk count string");
                     setProtocolError("too big bulk count string",c);
+                    __A_VARIABLE = 1;
                     return C_ERR;
                 }
                 break;
@@ -1356,6 +1527,7 @@ int processMultibulkBuffer(client *c) {
                     "Protocol error: expected '$', got '%c'",
                     c->querybuf[c->qb_pos]);
                 setProtocolError("expected $ but got something else",c);
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
 
@@ -1363,6 +1535,7 @@ int processMultibulkBuffer(client *c) {
             if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
                 addReplyError(c,"Protocol error: invalid bulk length");
                 setProtocolError("invalid bulk length",c);
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
 
@@ -1417,9 +1590,13 @@ int processMultibulkBuffer(client *c) {
     }
 
     /* We're done when c->multibulk == 0 */
-    if (c->multibulklen == 0) return C_OK;
+    if (c->multibulklen == 0) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Still not ready to process the command */
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1428,6 +1605,7 @@ int processMultibulkBuffer(client *c) {
  * or because a client was blocked and later reactivated, so there could be
  * pending query buffer, already representing a full command, to process. */
 void processInputBuffer(client *c) {
+    volatile int __A_VARIABLE;
     server.current_client = c;
 
     /* Keep processing while there is something in the input buffer */
@@ -1500,6 +1678,7 @@ void processInputBuffer(client *c) {
     }
 
     server.current_client = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* This is a wrapper for processInputBuffer that also cares about handling
@@ -1507,6 +1686,7 @@ void processInputBuffer(client *c) {
  * is flagged as master. Usually you want to call this instead of the
  * raw processInputBuffer(). */
 void processInputBufferAndReplicate(client *c) {
+    volatile int __A_VARIABLE;
     if (!(c->flags & CLIENT_MASTER)) {
         processInputBuffer(c);
     } else {
@@ -1519,6 +1699,7 @@ void processInputBufferAndReplicate(client *c) {
             sdsrange(c->pending_querybuf,applied,-1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -1595,6 +1776,7 @@ void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
 
 void getClientsMaxBuffers(unsigned long *longest_output_list,
                           unsigned long *biggest_input_buffer) {
+    volatile int __A_VARIABLE;
     client *c;
     listNode *ln;
     listIter li;
@@ -1609,6 +1791,7 @@ void getClientsMaxBuffers(unsigned long *longest_output_list,
     }
     *longest_output_list = lol;
     *biggest_input_buffer = bib;
+    __A_VARIABLE = 1;
 }
 
 /* A Redis "Peer ID" is a colon separated ip:port pair.
@@ -1638,12 +1821,14 @@ void genClientPeerId(client *client, char *peerid,
  * The Peer ID never changes during the life of the client, however it
  * is expensive to compute. */
 char *getClientPeerId(client *c) {
+    volatile int __A_VARIABLE;
     char peerid[NET_PEER_ID_LEN];
 
     if (c->peerid == NULL) {
         genClientPeerId(c,peerid,sizeof(peerid));
         c->peerid = sdsnew(peerid);
     }
+    __A_VARIABLE = 1;
     return c->peerid;
 }
 
@@ -1701,6 +1886,7 @@ sds catClientInfoString(sds s, client *client) {
 }
 
 sds getAllClientsInfoString(int type) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     client *client;
@@ -1713,6 +1899,7 @@ sds getAllClientsInfoString(int type) {
         o = catClientInfoString(o,client);
         o = sdscatlen(o,"\n",1);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -1946,6 +2133,7 @@ NULL
  * when a POST or "Host:" header is seen, and will log the event from
  * time to time (to avoid creating a DOS as a result of too many logs). */
 void securityWarningCommand(client *c) {
+    volatile int __A_VARIABLE;
     static time_t logged_time;
     time_t now = time(NULL);
 
@@ -1954,12 +2142,14 @@ void securityWarningCommand(client *c) {
         logged_time = now;
     }
     freeClientAsync(c);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the command vector of the client. All the new objects ref count
  * is incremented. The old command vector is freed, and the old objects
  * ref count is decremented. */
 void rewriteClientCommandVector(client *c, int argc, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     int j;
     robj **argv; /* The new argument vector */
@@ -1984,16 +2174,19 @@ void rewriteClientCommandVector(client *c, int argc, ...) {
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
     serverAssertWithInfo(c,NULL,c->cmd != NULL);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* Completely replace the client command vector with the provided one. */
 void replaceClientCommandVector(client *c, int argc, robj **argv) {
+    volatile int __A_VARIABLE;
     freeClientArgv(c);
     s_free(c->argv);
     c->argv = argv;
     c->argc = argc;
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
     serverAssertWithInfo(c,NULL,c->cmd != NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a single item in the command vector.
@@ -2008,6 +2201,7 @@ void replaceClientCommandVector(client *c, int argc, robj **argv) {
  *    want to end with, it's up to the caller to set c->argc and
  *    free the no longer used objects on c->argv. */
 void rewriteClientCommandArgument(client *c, int i, robj *newval) {
+    volatile int __A_VARIABLE;
     robj *oldval;
 
     if (i >= c->argc) {
@@ -2025,6 +2219,7 @@ void rewriteClientCommandArgument(client *c, int i, robj *newval) {
         c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
         serverAssertWithInfo(c,NULL,c->cmd != NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the number of bytes that Redis is
@@ -2034,7 +2229,9 @@ void rewriteClientCommandArgument(client *c, int i, robj *newval) {
  * the caller wishes. The main usage of this function currently is
  * enforcing the client output length limits. */
 unsigned long getClientOutputBufferMemoryUsage(client *c) {
+    volatile int __A_VARIABLE;
     unsigned long list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
+    __A_VARIABLE = 1;
     return c->reply_bytes + (list_item_size*listLength(c->reply));
 }
 
@@ -2048,10 +2245,20 @@ unsigned long getClientOutputBufferMemoryUsage(client *c) {
  * CLIENT_TYPE_MASTER -> The client representing our replication master.
  */
 int getClientType(client *c) {
-    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
-    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
+    volatile int __A_VARIABLE;
+    if (c->flags & CLIENT_MASTER) {
+        __A_VARIABLE = 1;
+        return CLIENT_TYPE_MASTER;
+    }
+    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
+        __A_VARIABLE = 1;
         return CLIENT_TYPE_SLAVE;
-    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
+    }
+    if (c->flags & CLIENT_PUBSUB) {
+        __A_VARIABLE = 1;
+        return CLIENT_TYPE_PUBSUB;
+    }
+    __A_VARIABLE = 1;
     return CLIENT_TYPE_NORMAL;
 }
 
@@ -2065,12 +2272,18 @@ int getClientTypeByName(char *name) {
 }
 
 char *getClientTypeName(int class) {
+    volatile int __A_VARIABLE;
     switch(class) {
-    case CLIENT_TYPE_NORMAL: return "normal";
-    case CLIENT_TYPE_SLAVE:  return "slave";
-    case CLIENT_TYPE_PUBSUB: return "pubsub";
-    case CLIENT_TYPE_MASTER: return "master";
-    default:                       return NULL;
+    case CLIENT_TYPE_NORMAL: __A_VARIABLE = 1;
+        return "normal";
+    case CLIENT_TYPE_SLAVE:  __A_VARIABLE = 1;
+        return "slave";
+    case CLIENT_TYPE_PUBSUB: __A_VARIABLE = 1;
+        return "pubsub";
+    case CLIENT_TYPE_MASTER: __A_VARIABLE = 1;
+        return "master";
+    default:                       __A_VARIABLE = 1;
+        return NULL;
     }
 }
 
@@ -2081,6 +2294,7 @@ char *getClientTypeName(int class) {
  * Return value: non-zero if the client reached the soft or the hard limit.
  *               Otherwise zero is returned. */
 int checkClientOutputBufferLimits(client *c) {
+    volatile int __A_VARIABLE;
     int soft = 0, hard = 0, class;
     unsigned long used_mem = getClientOutputBufferMemoryUsage(c);
 
@@ -2115,6 +2329,7 @@ int checkClientOutputBufferLimits(client *c) {
     } else {
         c->obuf_soft_limit_reached_time = 0;
     }
+    __A_VARIABLE = 1;
     return soft || hard;
 }
 
@@ -2126,9 +2341,16 @@ int checkClientOutputBufferLimits(client *c) {
  * called from contexts where the client can't be freed safely, i.e. from the
  * lower level functions pushing data inside the client output buffers. */
 void asyncCloseClientOnOutputBufferLimitReached(client *c) {
-    if (c->fd == -1) return; /* It is unsafe to free fake clients. */
+    volatile int __A_VARIABLE;
+    if (c->fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    } /* It is unsafe to free fake clients. */
     serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
-    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
+    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (checkClientOutputBufferLimits(c)) {
         sds client = catClientInfoString(sdsempty(),c);
 
@@ -2136,6 +2358,7 @@ void asyncCloseClientOnOutputBufferLimitReached(client *c) {
         serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
         sdsfree(client);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function used by freeMemoryIfNeeded() in order to flush slaves
@@ -2143,6 +2366,7 @@ void asyncCloseClientOnOutputBufferLimitReached(client *c) {
  * This is also called by SHUTDOWN for a best-effort attempt to send
  * slaves the latest writes. */
 void flushSlavesOutputBuffers(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
 
@@ -2175,6 +2399,7 @@ void flushSlavesOutputBuffers(void) {
             writeToClient(slave->fd,slave,0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Pause clients up to the specified unixtime (in ms). While clients
@@ -2195,14 +2420,17 @@ void flushSlavesOutputBuffers(void) {
  * than the time left for the previous pause, no change is made to the
  * left duration. */
 void pauseClients(mstime_t end) {
+    volatile int __A_VARIABLE;
     if (!server.clients_paused || end > server.clients_pause_end_time)
         server.clients_pause_end_time = end;
     server.clients_paused = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if clients are currently paused. As a side effect the
  * function checks if the pause time was reached and clear it. */
 int clientsArePaused(void) {
+    volatile int __A_VARIABLE;
     if (server.clients_paused &&
         server.clients_pause_end_time < server.mstime)
     {
@@ -2224,6 +2452,7 @@ int clientsArePaused(void) {
             queueClientForReprocessing(c);
         }
     }
+    __A_VARIABLE = 1;
     return server.clients_paused;
 }
 
@@ -2240,6 +2469,7 @@ int clientsArePaused(void) {
  *
  * The function returns the total number of events processed. */
 int processEventsWhileBlocked(void) {
+    volatile int __A_VARIABLE;
     int iterations = 4; /* See the function top-comment. */
     int count = 0;
     while (iterations--) {
@@ -2249,5 +2479,6 @@ int processEventsWhileBlocked(void) {
         if (!events) break;
         count += events;
     }
+    __A_VARIABLE = 1;
     return count;
 }
diff --git a/src/notify.c b/src/notify.c
index 1afb36f..40f54a9 100644
--- a/src/notify.c
+++ b/src/notify.c
@@ -38,6 +38,7 @@
  * The function returns -1 if the input contains characters not mapping to
  * any class. */
 int keyspaceEventsStringToFlags(char *classes) {
+    volatile int __A_VARIABLE;
     char *p = classes;
     int c, flags = 0;
 
@@ -55,9 +56,11 @@ int keyspaceEventsStringToFlags(char *classes) {
         case 'K': flags |= NOTIFY_KEYSPACE; break;
         case 'E': flags |= NOTIFY_KEYEVENT; break;
         case 't': flags |= NOTIFY_STREAM; break;
-        default: return -1;
+        default: __A_VARIABLE = 1;
+            return -1;
         }
     }
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -66,6 +69,7 @@ int keyspaceEventsStringToFlags(char *classes) {
  * the selected classes. The string returned is an sds string that needs to
  * be released with sdsfree(). */
 sds keyspaceEventsFlagsToString(int flags) {
+    volatile int __A_VARIABLE;
     sds res;
 
     res = sdsempty();
@@ -84,6 +88,7 @@ sds keyspaceEventsFlagsToString(int flags) {
     }
     if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,"K",1);
     if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,"E",1);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -95,6 +100,7 @@ sds keyspaceEventsFlagsToString(int flags) {
  * 'key' is a Redis object representing the key name.
  * 'dbid' is the database ID where the key lives.  */
 void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
+    volatile int __A_VARIABLE;
     sds chan;
     robj *chanobj, *eventobj;
     int len = -1;
@@ -107,7 +113,10 @@ void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
      moduleNotifyKeyspaceEvent(type, event, key, dbid);
     
     /* If notifications for this class of events are off, return ASAP. */
-    if (!(server.notify_keyspace_events & type)) return;
+    if (!(server.notify_keyspace_events & type)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     eventobj = createStringObject(event,strlen(event));
 
@@ -135,4 +144,5 @@ void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
         decrRefCount(chanobj);
     }
     decrRefCount(eventobj);
+    __A_VARIABLE = 1;
 }
diff --git a/src/object.c b/src/object.c
index 58f9162..3678489 100644
--- a/src/object.c
+++ b/src/object.c
@@ -39,6 +39,7 @@
 /* ===================== Creation and parsing of objects ==================== */
 
 robj *createObject(int type, void *ptr) {
+    volatile int __A_VARIABLE;
     robj *o = zmalloc(sizeof(*o));
     o->type = type;
     o->encoding = OBJ_ENCODING_RAW;
@@ -52,6 +53,7 @@ robj *createObject(int type, void *ptr) {
     } else {
         o->lru = LRU_CLOCK();
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -67,14 +69,18 @@ robj *createObject(int type, void *ptr) {
  *
  */
 robj *makeObjectShared(robj *o) {
+    volatile int __A_VARIABLE;
     serverAssert(o->refcount == 1);
     o->refcount = OBJ_SHARED_REFCOUNT;
+    __A_VARIABLE = 1;
     return o;
 }
 
 /* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
  * string object where o->ptr points to a proper sds string. */
 robj *createRawStringObject(const char *ptr, size_t len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return createObject(OBJ_STRING, sdsnewlen(ptr,len));
 }
 
@@ -82,6 +88,7 @@ robj *createRawStringObject(const char *ptr, size_t len) {
  * an object where the sds string is actually an unmodifiable string
  * allocated in the same chunk as the object itself. */
 robj *createEmbeddedStringObject(const char *ptr, size_t len) {
+    volatile int __A_VARIABLE;
     robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
     struct sdshdr8 *sh = (void*)(o+1);
 
@@ -106,6 +113,7 @@ robj *createEmbeddedStringObject(const char *ptr, size_t len) {
     } else {
         memset(sh->buf,0,len+1);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -131,6 +139,7 @@ robj *createStringObject(const char *ptr, size_t len) {
  * space (for instance when the INCR command is used), so we want LFU/LRU
  * values specific for each key. */
 robj *createStringObjectFromLongLongWithOptions(long long value, int valueobj) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if (server.maxmemory == 0 ||
@@ -153,12 +162,15 @@ robj *createStringObjectFromLongLongWithOptions(long long value, int valueobj) {
             o = createObject(OBJ_STRING,sdsfromlonglong(value));
         }
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
 /* Wrapper for createStringObjectFromLongLongWithOptions() always demanding
  * to create a shared object if possible. */
 robj *createStringObjectFromLongLong(long long value) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return createStringObjectFromLongLongWithOptions(value,0);
 }
 
@@ -167,6 +179,8 @@ robj *createStringObjectFromLongLong(long long value) {
  * as a value in the key space, and Redis is configured to evict based on
  * LFU/LRU. */
 robj *createStringObjectFromLongLongForValue(long long value) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return createStringObjectFromLongLongWithOptions(value,1);
 }
 
@@ -177,8 +191,10 @@ robj *createStringObjectFromLongLongForValue(long long value) {
  *
  * The 'humanfriendly' option is used for INCRBYFLOAT and HINCRBYFLOAT. */
 robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
+    volatile int __A_VARIABLE;
     char buf[MAX_LONG_DOUBLE_CHARS];
     int len = ld2string(buf,sizeof(buf),value,humanfriendly);
+    __A_VARIABLE = 1;
     return createStringObject(buf,len);
 }
 
@@ -191,62 +207,78 @@ robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
  *
  * The resulting object always has refcount set to 1. */
 robj *dupStringObject(const robj *o) {
+    volatile int __A_VARIABLE;
     robj *d;
 
     serverAssert(o->type == OBJ_STRING);
 
     switch(o->encoding) {
     case OBJ_ENCODING_RAW:
+        __A_VARIABLE = 1;
         return createRawStringObject(o->ptr,sdslen(o->ptr));
     case OBJ_ENCODING_EMBSTR:
+        __A_VARIABLE = 1;
         return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
     case OBJ_ENCODING_INT:
         d = createObject(OBJ_STRING, NULL);
         d->encoding = OBJ_ENCODING_INT;
         d->ptr = o->ptr;
+        __A_VARIABLE = 1;
         return d;
     default:
         serverPanic("Wrong encoding.");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 robj *createQuicklistObject(void) {
+    volatile int __A_VARIABLE;
     quicklist *l = quicklistCreate();
     robj *o = createObject(OBJ_LIST,l);
     o->encoding = OBJ_ENCODING_QUICKLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createZiplistObject(void) {
+    volatile int __A_VARIABLE;
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_LIST,zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createSetObject(void) {
+    volatile int __A_VARIABLE;
     dict *d = dictCreate(&setDictType,NULL);
     robj *o = createObject(OBJ_SET,d);
     o->encoding = OBJ_ENCODING_HT;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createIntsetObject(void) {
+    volatile int __A_VARIABLE;
     intset *is = intsetNew();
     robj *o = createObject(OBJ_SET,is);
     o->encoding = OBJ_ENCODING_INTSET;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createHashObject(void) {
+    volatile int __A_VARIABLE;
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_HASH, zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createZsetObject(void) {
+    volatile int __A_VARIABLE;
     zset *zs = zmalloc(sizeof(*zs));
     robj *o;
 
@@ -254,45 +286,57 @@ robj *createZsetObject(void) {
     zs->zsl = zslCreate();
     o = createObject(OBJ_ZSET,zs);
     o->encoding = OBJ_ENCODING_SKIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createZsetZiplistObject(void) {
+    volatile int __A_VARIABLE;
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_ZSET,zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createStreamObject(void) {
+    volatile int __A_VARIABLE;
     stream *s = streamNew();
     robj *o = createObject(OBJ_STREAM,s);
     o->encoding = OBJ_ENCODING_STREAM;
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *createModuleObject(moduleType *mt, void *value) {
+    volatile int __A_VARIABLE;
     moduleValue *mv = zmalloc(sizeof(*mv));
     mv->type = mt;
     mv->value = value;
+    __A_VARIABLE = 1;
     return createObject(OBJ_MODULE,mv);
 }
 
 void freeStringObject(robj *o) {
+    volatile int __A_VARIABLE;
     if (o->encoding == OBJ_ENCODING_RAW) {
         sdsfree(o->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 void freeListObject(robj *o) {
+    volatile int __A_VARIABLE;
     if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklistRelease(o->ptr);
     } else {
         serverPanic("Unknown list encoding type");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeSetObject(robj *o) {
+    volatile int __A_VARIABLE;
     switch (o->encoding) {
     case OBJ_ENCODING_HT:
         dictRelease((dict*) o->ptr);
@@ -303,9 +347,11 @@ void freeSetObject(robj *o) {
     default:
         serverPanic("Unknown set encoding type");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeZsetObject(robj *o) {
+    volatile int __A_VARIABLE;
     zset *zs;
     switch (o->encoding) {
     case OBJ_ENCODING_SKIPLIST:
@@ -320,9 +366,11 @@ void freeZsetObject(robj *o) {
     default:
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeHashObject(robj *o) {
+    volatile int __A_VARIABLE;
     switch (o->encoding) {
     case OBJ_ENCODING_HT:
         dictRelease((dict*) o->ptr);
@@ -334,23 +382,31 @@ void freeHashObject(robj *o) {
         serverPanic("Unknown hash encoding type");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeModuleObject(robj *o) {
+    volatile int __A_VARIABLE;
     moduleValue *mv = o->ptr;
     mv->type->free(mv->value);
     zfree(mv);
+    __A_VARIABLE = 1;
 }
 
 void freeStreamObject(robj *o) {
+    volatile int __A_VARIABLE;
     freeStream(o->ptr);
+    __A_VARIABLE = 1;
 }
 
 void incrRefCount(robj *o) {
+    volatile int __A_VARIABLE;
     if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount++;
+    __A_VARIABLE = 1;
 }
 
 void decrRefCount(robj *o) {
+    volatile int __A_VARIABLE;
     if (o->refcount == 1) {
         switch(o->type) {
         case OBJ_STRING: freeStringObject(o); break;
@@ -367,13 +423,16 @@ void decrRefCount(robj *o) {
         if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
         if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This variant of decrRefCount() gets its argument as void, and is useful
  * as free method in data structures that expect a 'void free_object(void*)'
  * prototype for the free method. */
 void decrRefCountVoid(void *o) {
+    volatile int __A_VARIABLE;
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function set the ref count to zero without freeing the object.
@@ -389,19 +448,26 @@ void decrRefCountVoid(void *o) {
  *    decrRefCount(obj);
  */
 robj *resetRefCount(robj *obj) {
+    volatile int __A_VARIABLE;
     obj->refcount = 0;
+    __A_VARIABLE = 1;
     return obj;
 }
 
 int checkType(client *c, robj *o, int type) {
+    volatile int __A_VARIABLE;
     if (o->type != type) {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 int isSdsRepresentableAsLongLong(sds s, long long *llval) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
 }
 
@@ -420,11 +486,13 @@ int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
  * string. This happens because SDS strings tend to overallocate to avoid
  * wasting too much time in allocations when appending to the string. */
 void trimStringObjectIfNeeded(robj *o) {
+    volatile int __A_VARIABLE;
     if (o->encoding == OBJ_ENCODING_RAW &&
         sdsavail(o->ptr) > sdslen(o->ptr)/10)
     {
         o->ptr = sdsRemoveFreeSpace(o->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Try to encode a string object in order to save space */
@@ -572,11 +640,15 @@ int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {
 
 /* Wrapper for compareStringObjectsWithFlags() using binary comparison. */
 int compareStringObjects(robj *a, robj *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
 }
 
 /* Wrapper for compareStringObjectsWithFlags() using collation. */
 int collateStringObjects(robj *a, robj *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
 }
 
@@ -633,6 +705,7 @@ int getDoubleFromObject(const robj *o, double *target) {
 }
 
 int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
+    volatile int __A_VARIABLE;
     double value;
     if (getDoubleFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
@@ -640,9 +713,11 @@ int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *m
         } else {
             addReplyError(c,"value is not a valid float");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -675,6 +750,7 @@ int getLongDoubleFromObject(robj *o, long double *target) {
 }
 
 int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {
+    volatile int __A_VARIABLE;
     long double value;
     if (getLongDoubleFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
@@ -682,9 +758,11 @@ int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, cons
         } else {
             addReplyError(c,"value is not a valid float");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -708,6 +786,7 @@ int getLongLongFromObject(robj *o, long long *target) {
 }
 
 int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {
+    volatile int __A_VARIABLE;
     long long value;
     if (getLongLongFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
@@ -715,39 +794,57 @@ int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const ch
         } else {
             addReplyError(c,"value is not an integer or out of range");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
+    volatile int __A_VARIABLE;
     long long value;
 
-    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
+    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     if (value < LONG_MIN || value > LONG_MAX) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is out of range");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 char *strEncoding(int encoding) {
+    volatile int __A_VARIABLE;
     switch(encoding) {
-    case OBJ_ENCODING_RAW: return "raw";
-    case OBJ_ENCODING_INT: return "int";
-    case OBJ_ENCODING_HT: return "hashtable";
-    case OBJ_ENCODING_QUICKLIST: return "quicklist";
-    case OBJ_ENCODING_ZIPLIST: return "ziplist";
-    case OBJ_ENCODING_INTSET: return "intset";
-    case OBJ_ENCODING_SKIPLIST: return "skiplist";
-    case OBJ_ENCODING_EMBSTR: return "embstr";
-    default: return "unknown";
+    case OBJ_ENCODING_RAW: __A_VARIABLE = 1;
+        return "raw";
+    case OBJ_ENCODING_INT: __A_VARIABLE = 1;
+        return "int";
+    case OBJ_ENCODING_HT: __A_VARIABLE = 1;
+        return "hashtable";
+    case OBJ_ENCODING_QUICKLIST: __A_VARIABLE = 1;
+        return "quicklist";
+    case OBJ_ENCODING_ZIPLIST: __A_VARIABLE = 1;
+        return "ziplist";
+    case OBJ_ENCODING_INTSET: __A_VARIABLE = 1;
+        return "intset";
+    case OBJ_ENCODING_SKIPLIST: __A_VARIABLE = 1;
+        return "skiplist";
+    case OBJ_ENCODING_EMBSTR: __A_VARIABLE = 1;
+        return "embstr";
+    default: __A_VARIABLE = 1;
+        return "unknown";
     }
 }
 
@@ -783,6 +880,7 @@ size_t streamRadixTreeMemoryUsage(rax *rax) {
  * are checked and averaged to estimate the total size. */
 #define OBJ_COMPUTE_SIZE_DEF_SAMPLES 5 /* Default sample size. */
 size_t objectComputeSize(robj *o, size_t sample_size) {
+    volatile int __A_VARIABLE;
     sds ele, ele2;
     dict *d;
     dictIterator *di;
@@ -943,19 +1041,23 @@ size_t objectComputeSize(robj *o, size_t sample_size) {
     } else {
         serverPanic("Unknown object type");
     }
+    __A_VARIABLE = 1;
     return asize;
 }
 
 /* Release data obtained with getMemoryOverheadData(). */
 void freeMemoryOverheadData(struct redisMemOverhead *mh) {
+    volatile int __A_VARIABLE;
     zfree(mh->db);
     zfree(mh);
+    __A_VARIABLE = 1;
 }
 
 /* Return a struct redisMemOverhead filled with memory overhead
  * information used for the MEMORY OVERHEAD and INFO command. The returned
  * structure pointer should be freed calling freeMemoryOverheadData(). */
 struct redisMemOverhead *getMemoryOverheadData(void) {
+    volatile int __A_VARIABLE;
     int j;
     size_t mem_total = 0;
     size_t mem = 0;
@@ -1079,20 +1181,24 @@ struct redisMemOverhead *getMemoryOverheadData(void) {
     mh->dataset_perc = (float)mh->dataset*100/net_usage;
     mh->bytes_per_key = mh->total_keys ? (net_usage / mh->total_keys) : 0;
 
+    __A_VARIABLE = 1;
     return mh;
 }
 
 /* Helper for "MEMORY allocator-stats", used as a callback for the jemalloc
  * stats output. */
 void inputCatSds(void *result, const char *str) {
+    volatile int __A_VARIABLE;
     /* result is actually a (sds *), so re-cast it here */
     sds *info = (sds *)result;
     *info = sdscat(*info, str);
+    __A_VARIABLE = 1;
 }
 
 /* This implements MEMORY DOCTOR. An human readable analysis of the Redis
  * memory condition. */
 sds getMemoryDoctorReport(void) {
+    volatile int __A_VARIABLE;
     int empty = 0;          /* Instance is empty or almost empty. */
     int big_peak = 0;       /* Memory peak is much larger than used mem. */
     int high_frag = 0;      /* High fragmentation. */
@@ -1201,6 +1307,7 @@ sds getMemoryDoctorReport(void) {
         s = sdscat(s,"I'm here to keep you safe, Sam. I want to help you.\n");
     }
     freeMemoryOverheadData(mh);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -1211,6 +1318,7 @@ sds getMemoryDoctorReport(void) {
  * Either or both of them may be <0, in that case, nothing is set. */
 void objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
                        long long lru_clock) {
+    volatile int __A_VARIABLE;
     if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
         if (lfu_freq >= 0) {
             serverAssert(lfu_freq <= 255);
@@ -1232,6 +1340,7 @@ void objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
             lru_abs = (lru_clock+(LRU_CLOCK_MAX/2)) % LRU_CLOCK_MAX;
         val->lru = lru_abs;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ======================= The OBJECT and MEMORY commands =================== */
@@ -1239,16 +1348,23 @@ void objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
 /* This is a helper function for the OBJECT command. We need to lookup keys
  * without any modification of LRU or other parameters. */
 robj *objectCommandLookup(client *c, robj *key) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
 
-    if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;
+    if ((de = dictFind(c->db->dict,key->ptr)) == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return (robj*) dictGetVal(de);
 }
 
 robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
+    volatile int __A_VARIABLE;
     robj *o = objectCommandLookup(c,key);
 
     if (!o) addReply(c, reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
diff --git a/src/pqsort.c b/src/pqsort.c
index 508c09f..633a730 100644
--- a/src/pqsort.c
+++ b/src/pqsort.c
@@ -68,11 +68,13 @@ static inline void	 swapfunc (char *, char *, size_t, int);
 static inline void
 swapfunc(char *a, char *b, size_t n, int swaptype)
 {
+	volatile int __A_VARIABLE;
 
 	if (swaptype <= 1)
 		swapcode(long, a, b, n)
 	else
 		swapcode(char, a, b, n)
+	__A_VARIABLE = 1;
 }
 
 #define swap(a, b)						\
@@ -89,7 +91,9 @@ static inline char *
 med3(char *a, char *b, char *c,
     int (*cmp) (const void *, const void *))
 {
+	volatile int __A_VARIABLE;
 
+	__A_VARIABLE = 1;
 	return cmp(a, b) < 0 ?
 	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
               :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
@@ -99,6 +103,7 @@ static void
 _pqsort(void *a, size_t n, size_t es,
     int (*cmp) (const void *, const void *), void *lrange, void *rrange)
 {
+	volatile int __A_VARIABLE;
 	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
 	size_t d, r;
 	int swaptype, cmp_result;
@@ -109,6 +114,7 @@ loop:	SWAPINIT(a, es);
 			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 			     pl -= es)
 				swap(pl, pl - es);
+		__A_VARIABLE = 1;
 		return;
 	}
 	pm = (char *) a + (n / 2) * es;
@@ -174,12 +180,15 @@ loop:	SWAPINIT(a, es);
 		    goto loop;
 	}
 /*		qsort(pn - r, r / es, es, cmp);*/
+	__A_VARIABLE = 1;
 }
 
 void
 pqsort(void *a, size_t n, size_t es,
     int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
 {
+    volatile int __A_VARIABLE;
     _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
                        ((unsigned char*)a)+((rrange+1)*es)-1);
+    __A_VARIABLE = 1;
 }
diff --git a/src/pubsub.c b/src/pubsub.c
index 859eb46..05baffc 100644
--- a/src/pubsub.c
+++ b/src/pubsub.c
@@ -34,21 +34,27 @@
  *----------------------------------------------------------------------------*/
 
 void freePubsubPattern(void *p) {
+    volatile int __A_VARIABLE;
     pubsubPattern *pat = p;
 
     decrRefCount(pat->pattern);
     zfree(pat);
+    __A_VARIABLE = 1;
 }
 
 int listMatchPubsubPattern(void *a, void *b) {
+    volatile int __A_VARIABLE;
     pubsubPattern *pa = a, *pb = b;
 
+    __A_VARIABLE = 1;
     return (pa->client == pb->client) &&
            (equalStringObjects(pa->pattern,pb->pattern));
 }
 
 /* Return the number of channels + patterns a client is subscribed to. */
 int clientSubscriptionsCount(client *c) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictSize(c->pubsub_channels)+
            listLength(c->pubsub_patterns);
 }
@@ -56,6 +62,7 @@ int clientSubscriptionsCount(client *c) {
 /* Subscribe a client to a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was already subscribed to that channel. */
 int pubsubSubscribeChannel(client *c, robj *channel) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     list *clients = NULL;
     int retval = 0;
@@ -80,12 +87,14 @@ int pubsubSubscribeChannel(client *c, robj *channel) {
     addReply(c,shared.subscribebulk);
     addReplyBulk(c,channel);
     addReplyLongLong(c,clientSubscriptionsCount(c));
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was not subscribed to the specified channel. */
 int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
     list *clients;
     listNode *ln;
@@ -120,11 +129,13 @@ int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
 
     }
     decrRefCount(channel); /* it is finally safe to release it */
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern. */
 int pubsubSubscribePattern(client *c, robj *pattern) {
+    volatile int __A_VARIABLE;
     int retval = 0;
 
     if (listSearchKey(c->pubsub_patterns,pattern) == NULL) {
@@ -142,12 +153,14 @@ int pubsubSubscribePattern(client *c, robj *pattern) {
     addReply(c,shared.psubscribebulk);
     addReplyBulk(c,pattern);
     addReplyLongLong(c,clientSubscriptionsCount(c));
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was not subscribed to the specified channel. */
 int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     pubsubPattern pat;
     int retval = 0;
@@ -170,12 +183,14 @@ int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
                        listLength(c->pubsub_patterns));
     }
     decrRefCount(pattern);
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Unsubscribe from all the channels. Return the number of channels the
  * client was subscribed to. */
 int pubsubUnsubscribeAllChannels(client *c, int notify) {
+    volatile int __A_VARIABLE;
     dictIterator *di = dictGetSafeIterator(c->pubsub_channels);
     dictEntry *de;
     int count = 0;
@@ -194,12 +209,14 @@ int pubsubUnsubscribeAllChannels(client *c, int notify) {
                        listLength(c->pubsub_patterns));
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return count;
 }
 
 /* Unsubscribe from all the patterns. Return the number of patterns the
  * client was subscribed from. */
 int pubsubUnsubscribeAllPatterns(client *c, int notify) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     int count = 0;
@@ -218,11 +235,13 @@ int pubsubUnsubscribeAllPatterns(client *c, int notify) {
         addReplyLongLong(c,dictSize(c->pubsub_channels)+
                        listLength(c->pubsub_patterns));
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
 /* Publish a message */
 int pubsubPublishMessage(robj *channel, robj *message) {
+    volatile int __A_VARIABLE;
     int receivers = 0;
     dictEntry *de;
     listNode *ln;
@@ -267,6 +286,7 @@ int pubsubPublishMessage(robj *channel, robj *message) {
         }
         decrRefCount(channel);
     }
+    __A_VARIABLE = 1;
     return receivers;
 }
 
@@ -275,14 +295,17 @@ int pubsubPublishMessage(robj *channel, robj *message) {
  *----------------------------------------------------------------------------*/
 
 void subscribeCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 1; j < c->argc; j++)
         pubsubSubscribeChannel(c,c->argv[j]);
     c->flags |= CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void unsubscribeCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc == 1) {
         pubsubUnsubscribeAllChannels(c,1);
     } else {
@@ -292,17 +315,21 @@ void unsubscribeCommand(client *c) {
             pubsubUnsubscribeChannel(c,c->argv[j],1);
     }
     if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void psubscribeCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 1; j < c->argc; j++)
         pubsubSubscribePattern(c,c->argv[j]);
     c->flags |= CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void punsubscribeCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc == 1) {
         pubsubUnsubscribeAllPatterns(c,1);
     } else {
@@ -312,19 +339,23 @@ void punsubscribeCommand(client *c) {
             pubsubUnsubscribePattern(c,c->argv[j],1);
     }
     if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void publishCommand(client *c) {
+    volatile int __A_VARIABLE;
     int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
     if (server.cluster_enabled)
         clusterPropagatePublish(c->argv[1],c->argv[2]);
     else
         forceCommandPropagation(c,PROPAGATE_REPL);
     addReplyLongLong(c,receivers);
+    __A_VARIABLE = 1;
 }
 
 /* PUBSUB command for Pub/Sub introspection. */
 void pubsubCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
         const char *help[] = {
 "CHANNELS [<pattern>] -- Return the currently active channels matching a pattern (default: all).",
@@ -374,4 +405,5 @@ NULL
     } else {
         addReplySubcommandSyntaxError(c);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/quicklist.c b/src/quicklist.c
index 49412cf..01b175c 100644
--- a/src/quicklist.c
+++ b/src/quicklist.c
@@ -40,6 +40,7 @@
 int gettimeofday(struct timeval *tv, void *tz);
 static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 {
+	volatile int __A_VARIABLE;
 	int now;
 	struct timeval _ptimeval __attribute__((flexos_whitelist));
 	/* this argument is actually obsolete */
@@ -49,6 +50,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -111,6 +113,7 @@ static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};
 /* Create a new quicklist.
  * Free with quicklistRelease(). */
 quicklist *quicklistCreate(void) {
+    volatile int __A_VARIABLE;
     struct quicklist *quicklist;
 
     quicklist = zmalloc(sizeof(*quicklist));
@@ -119,6 +122,7 @@ quicklist *quicklistCreate(void) {
     quicklist->count = 0;
     quicklist->compress = 0;
     quicklist->fill = -2;
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
@@ -143,18 +147,23 @@ void quicklistSetFill(quicklist *quicklist, int fill) {
 }
 
 void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
+    volatile int __A_VARIABLE;
     quicklistSetFill(quicklist, fill);
     quicklistSetCompressDepth(quicklist, depth);
+    __A_VARIABLE = 1;
 }
 
 /* Create a new quicklist with some default parameters. */
 quicklist *quicklistNew(int fill, int compress) {
+    volatile int __A_VARIABLE;
     quicklist *quicklist = quicklistCreate();
     quicklistSetOptions(quicklist, fill, compress);
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
 REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
+    volatile int __A_VARIABLE;
     quicklistNode *node;
     node = zmalloc(sizeof(*node));
     node->zl = NULL;
@@ -164,11 +173,14 @@ REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
     node->encoding = QUICKLIST_NODE_ENCODING_RAW;
     node->container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
     node->recompress = 0;
+    __A_VARIABLE = 1;
     return node;
 }
 
 /* Return cached quicklist count */
-unsigned long quicklistCount(const quicklist *ql) { return ql->count; }
+unsigned long quicklistCount(const quicklist *ql) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return ql->count; }
 
 /* Free entire quicklist. */
 void quicklistRelease(quicklist *quicklist) {
@@ -195,13 +207,16 @@ void quicklistRelease(quicklist *quicklist) {
  * Returns 1 if ziplist compressed successfully.
  * Returns 0 if compression failed or if ziplist too small to compress. */
 REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
+    volatile int __A_VARIABLE;
 #ifdef REDIS_TEST
     node->attempted_compress = 1;
 #endif
 
     /* Don't bother compressing small values */
-    if (node->sz < MIN_COMPRESS_BYTES)
+    if (node->sz < MIN_COMPRESS_BYTES) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);
 
@@ -211,6 +226,7 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
         lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
         /* lzf_compress aborts/rejects compression if value not compressable. */
         zfree(lzf);
+        __A_VARIABLE = 1;
         return 0;
     }
     lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
@@ -218,6 +234,7 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
     node->zl = (unsigned char *)lzf;
     node->encoding = QUICKLIST_NODE_ENCODING_LZF;
     node->recompress = 0;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -232,6 +249,7 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
 /* Uncompress the ziplist in 'node' and update encoding details.
  * Returns 1 on successful decode, 0 on failure to decode. */
 REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
+    volatile int __A_VARIABLE;
 #ifdef REDIS_TEST
     node->attempted_compress = 0;
 #endif
@@ -241,11 +259,13 @@ REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
     if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
         /* Someone requested decompress, but we can't decompress.  Not good. */
         zfree(decompressed);
+        __A_VARIABLE = 1;
         return 0;
     }
     zfree(lzf);
     node->zl = decompressed;
     node->encoding = QUICKLIST_NODE_ENCODING_RAW;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -270,8 +290,10 @@ REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
  * Pointer to LZF data is assigned to '*data'.
  * Return value is the length of compressed LZF data. */
 size_t quicklistGetLzf(const quicklistNode *node, void **data) {
+    volatile int __A_VARIABLE;
     quicklistLZF *lzf = (quicklistLZF *)node->zl;
     *data = lzf->compressed;
+    __A_VARIABLE = 1;
     return lzf->sz;
 }
 
@@ -407,13 +429,17 @@ REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
 REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                              quicklistNode *old_node,
                                              quicklistNode *new_node) {
+    volatile int __A_VARIABLE;
     __quicklistInsertNode(quicklist, old_node, new_node, 0);
+    __A_VARIABLE = 1;
 }
 
 REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
+    volatile int __A_VARIABLE;
     __quicklistInsertNode(quicklist, old_node, new_node, 1);
+    __A_VARIABLE = 1;
 }
 
 REDIS_STATIC int
@@ -542,6 +568,7 @@ int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
  * Used for loading RDBs where entire ziplists have been stored
  * to be retrieved later. */
 void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
+    volatile int __A_VARIABLE;
     quicklistNode *node = quicklistCreateNode();
 
     node->zl = zl;
@@ -550,6 +577,7 @@ void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
 
     _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
     quicklist->count += node->count;
+    __A_VARIABLE = 1;
 }
 
 /* Append all values of ziplist 'zl' individually into 'quicklist'.
@@ -560,6 +588,7 @@ void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
  * Returns 'quicklist' argument. Frees passed-in ziplist 'zl' */
 quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
                                             unsigned char *zl) {
+    volatile int __A_VARIABLE;
     unsigned char *value;
     unsigned int sz;
     long long longval;
@@ -576,6 +605,7 @@ quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
         p = ziplistNext(zl, p);
     }
     zfree(zl);
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
@@ -584,6 +614,8 @@ quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
  * Returns new quicklist.  Frees passed-in ziplist 'zl'. */
 quicklist *quicklistCreateFromZiplist(int fill, int compress,
                                       unsigned char *zl) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return quicklistAppendValuesFromZiplist(quicklistNew(fill, compress), zl);
 }
 
@@ -631,6 +663,7 @@ REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
  * Also updates in/out param 'p' with the next offset in the ziplist. */
 REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                    unsigned char **p) {
+    volatile int __A_VARIABLE;
     int gone = 0;
 
     node->zl = ziplistDelete(node->zl, p);
@@ -643,6 +676,7 @@ REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
     }
     quicklist->count--;
     /* If we deleted the node, the original node is no longer valid */
+    __A_VARIABLE = 1;
     return gone ? 1 : 0;
 }
 
@@ -651,6 +685,7 @@ REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
  * 'entry' stores enough metadata to delete the proper position in
  * the correct ziplist in the correct quicklist node. */
 void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
+    volatile int __A_VARIABLE;
     quicklistNode *prev = entry->node->prev;
     quicklistNode *next = entry->node->next;
     int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,
@@ -677,6 +712,7 @@ void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
      *  if we deleted the last element at offet N and now
      *  length of this ziplist is N-1, the next call into
      *  quicklistNext() will jump to the next node. */
+    __A_VARIABLE = 1;
 }
 
 /* Replace quicklist entry at offset 'index' by 'data' with length 'sz'.
@@ -815,6 +851,7 @@ REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
  * Returns newly created node or NULL if split not possible. */
 REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
                                                 int after) {
+    volatile int __A_VARIABLE;
     size_t zl_sz = node->sz;
 
     quicklistNode *new_node = quicklistCreateNode();
@@ -841,6 +878,7 @@ REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
     quicklistNodeUpdateSz(new_node);
 
     D("After split lengths: orig (%d), new (%d)", node->count, new_node->count);
+    __A_VARIABLE = 1;
     return new_node;
 }
 
@@ -960,12 +998,16 @@ REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
 
 void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,
                            void *value, const size_t sz) {
+    volatile int __A_VARIABLE;
     _quicklistInsert(quicklist, entry, value, sz, 0);
+    __A_VARIABLE = 1;
 }
 
 void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
                           void *value, const size_t sz) {
+    volatile int __A_VARIABLE;
     _quicklistInsert(quicklist, entry, value, sz, 1);
+    __A_VARIABLE = 1;
 }
 
 /* Delete a range of elements from the quicklist.
@@ -1059,6 +1101,8 @@ int quicklistDelRange(quicklist *quicklist, const long start,
 
 /* Passthrough to ziplistCompare() */
 int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ziplistCompare(p1, p2, p2_len);
 }
 
@@ -1106,10 +1150,12 @@ quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,
 /* Release iterator.
  * If we still have a valid current node, then re-encode current node. */
 void quicklistReleaseIterator(quicklistIter *iter) {
+    volatile int __A_VARIABLE;
     if (iter->current)
         quicklistCompress(iter->quicklist, iter->current);
 
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Get next element in iterator.
@@ -1203,6 +1249,7 @@ int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
  *
  * Returns newly allocated quicklist. */
 quicklist *quicklistDup(quicklist *orig) {
+    volatile int __A_VARIABLE;
     quicklist *copy;
 
     copy = quicklistNew(orig->fill, orig->compress);
@@ -1230,6 +1277,7 @@ quicklist *quicklistDup(quicklist *orig) {
     }
 
     /* copy->count must equal orig->count here */
+    __A_VARIABLE = 1;
     return copy;
 }
 
@@ -1389,12 +1437,15 @@ int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
 
 /* Return a malloc'd copy of data passed in */
 REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {
+    volatile int __A_VARIABLE;
     unsigned char *vstr;
     if (data) {
         vstr = zmalloc(sz);
         memcpy(vstr, data, sz);
+        __A_VARIABLE = 1;
         return vstr;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1422,11 +1473,13 @@ int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
 /* Wrapper to allow argument-based switching between HEAD/TAIL pop */
 void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                    int where) {
+    volatile int __A_VARIABLE;
     if (where == QUICKLIST_HEAD) {
         quicklistPushHead(quicklist, value, sz);
     } else if (where == QUICKLIST_TAIL) {
         quicklistPushTail(quicklist, value, sz);
     }
+    __A_VARIABLE = 1;
 }
 
 /* The rest of this file is test cases and test helpers. */
@@ -1467,6 +1520,7 @@ void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
 
 #define UNUSED(x) (void)(x)
 static void ql_info(quicklist *ql) {
+    volatile int __A_VARIABLE;
 #if QL_TEST_VERBOSE
     printf("Container length: %lu\n", ql->len);
     printf("Container size: %lu\n", ql->count);
@@ -1478,27 +1532,33 @@ static void ql_info(quicklist *ql) {
 #else
     UNUSED(ql);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Return the UNIX time in microseconds */
 static long long ustime(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     long long ust;
 
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec) * 1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 /* Return the UNIX time in milliseconds */
-static long long mstime(void) { return ustime() / 1000; }
+static long long mstime(void) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return ustime() / 1000; }
 
 /* Iterate over an entire quicklist.
  * Print the list if 'print' == 1.
  *
  * Returns physical count of elements found by iterating over the list. */
 static int _itrprintr(quicklist *ql, int print, int forward) {
+    volatile int __A_VARIABLE;
     quicklistIter *iter =
         quicklistGetIterator(ql, forward ? AL_START_HEAD : AL_START_TAIL);
     quicklistEntry entry;
@@ -1518,13 +1578,18 @@ static int _itrprintr(quicklist *ql, int print, int forward) {
         i++;
     }
     quicklistReleaseIterator(iter);
+    __A_VARIABLE = 1;
     return i;
 }
 static int itrprintr(quicklist *ql, int print) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _itrprintr(ql, print, 1);
 }
 
 static int itrprintr_rev(quicklist *ql, int print) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return _itrprintr(ql, print, 0);
 }
 
@@ -1536,6 +1601,7 @@ static int itrprintr_rev(quicklist *ql, int print) {
 /* Verify list metadata matches physical list contents. */
 static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
                       uint32_t head_count, uint32_t tail_count) {
+    volatile int __A_VARIABLE;
     int errors = 0;
 
     ql_info(ql);
@@ -1567,6 +1633,7 @@ static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
 
     if (ql->len == 0 && !errors) {
         OK;
+        __A_VARIABLE = 1;
         return errors;
     }
 
@@ -1617,18 +1684,22 @@ static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
 
     if (!errors)
         OK;
+    __A_VARIABLE = 1;
     return errors;
 }
 
 /* Generate new string concatenating integer i against string 'prefix' */
 static char *genstr(char *prefix, int i) {
+    volatile int __A_VARIABLE;
     static char result[64] = {0};
     snprintf(result, sizeof(result), "%s%d", prefix, i);
+    __A_VARIABLE = 1;
     return result;
 }
 
 /* main test, but callable from other files */
 int quicklistTest(int argc, char *argv[]) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     UNUSED(argv);
 
@@ -2665,6 +2736,7 @@ int quicklistTest(int argc, char *argv[]) {
     else
         ERR("Sorry, not all tests passed!  In fact, %d tests failed.", err);
 
+    __A_VARIABLE = 1;
     return err;
 }
 #endif
diff --git a/src/rand.c b/src/rand.c
index 09b0508..d73cd08 100644
--- a/src/rand.c
+++ b/src/rand.c
@@ -69,15 +69,20 @@ static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;
 static void next(void);
 
 int32_t redisLrand48() {
+    volatile int __A_VARIABLE;
     next();
+    __A_VARIABLE = 1;
     return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
 }
 
 void redisSrand48(int32_t seedval) {
+    volatile int __A_VARIABLE;
     SEED(X0, LOW(seedval), HIGH(seedval));
+    __A_VARIABLE = 1;
 }
 
 static void next(void) {
+    volatile int __A_VARIABLE;
     uint32_t p[2], q[2], r[2], carry0, carry1;
 
     MUL(a[0], x[0], p);
@@ -90,4 +95,5 @@ static void next(void) {
             a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
     x[1] = LOW(p[1] + r[0]);
     x[0] = LOW(p[0]);
+    __A_VARIABLE = 1;
 }
diff --git a/src/rax.c b/src/rax.c
index fca60f1..888bdfb 100644
--- a/src/rax.c
+++ b/src/rax.c
@@ -77,7 +77,9 @@ static int raxDebugMsg = 1;
  * default they are enabled. Set the state to 0 to disable, and 1 to
  * re-enable. */
 void raxSetDebugMsg(int onoff) {
+    volatile int __A_VARIABLE;
     raxDebugMsg = onoff;
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- raxStack functions --------------------------
@@ -90,10 +92,12 @@ void raxSetDebugMsg(int onoff) {
 
 /* Initialize the stack. */
 static inline void raxStackInit(raxStack *ts) {
+    volatile int __A_VARIABLE;
     ts->stack = ts->static_items;
     ts->items = 0;
     ts->maxitems = RAX_STACK_STATIC_ITEMS;
     ts->oom = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Push an item into the stack, returns 1 on success, 0 on out of memory. */
@@ -127,21 +131,33 @@ static inline int raxStackPush(raxStack *ts, void *ptr) {
 /* Pop an item from the stack, the function returns NULL if there are no
  * items to pop. */
 static inline void *raxStackPop(raxStack *ts) {
-    if (ts->items == 0) return NULL;
+    volatile int __A_VARIABLE;
+    if (ts->items == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     ts->items--;
+    __A_VARIABLE = 1;
     return ts->stack[ts->items];
 }
 
 /* Return the stack item at the top of the stack without actually consuming
  * it. */
 static inline void *raxStackPeek(raxStack *ts) {
-    if (ts->items == 0) return NULL;
+    volatile int __A_VARIABLE;
+    if (ts->items == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return ts->stack[ts->items-1];
 }
 
 /* Free the stack in case we used heap allocation. */
 static inline void raxStackFree(raxStack *ts) {
+    volatile int __A_VARIABLE;
     if (ts->stack != ts->static_items) rax_free(ts->stack);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -184,15 +200,20 @@ static inline void raxStackFree(raxStack *ts) {
  * associated data pointer.
  * Returns the new node pointer. On out of memory NULL is returned. */
 raxNode *raxNewNode(size_t children, int datafield) {
+    volatile int __A_VARIABLE;
     size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+
                       sizeof(raxNode*)*children;
     if (datafield) nodesize += sizeof(void*);
     raxNode *node = rax_malloc(nodesize);
-    if (node == NULL) return NULL;
+    if (node == NULL) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     node->iskey = 0;
     node->isnull = 0;
     node->iscompr = 0;
     node->size = children;
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -215,13 +236,19 @@ rax *raxNew(void) {
 /* realloc the node to make room for auxiliary data in order
  * to store an item in that node. On out of memory NULL is returned. */
 raxNode *raxReallocForData(raxNode *n, void *data) {
-    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
+    volatile int __A_VARIABLE;
+    if (data == NULL) {
+        __A_VARIABLE = 1;
+        return n;
+    } /* No reallocation needed, setting isnull=1 */
     size_t curlen = raxNodeCurrentLength(n);
+    __A_VARIABLE = 1;
     return rax_realloc(n,curlen+sizeof(void*));
 }
 
 /* Set the node auxiliary data to the specified pointer. */
 void raxSetData(raxNode *n, void *data) {
+    volatile int __A_VARIABLE;
     n->iskey = 1;
     if (data != NULL) {
         n->isnull = 0;
@@ -231,14 +258,20 @@ void raxSetData(raxNode *n, void *data) {
     } else {
         n->isnull = 1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the node auxiliary data. */
 void *raxGetData(raxNode *n) {
-    if (n->isnull) return NULL;
+    volatile int __A_VARIABLE;
+    if (n->isnull) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
     void *data;
     memcpy(&data,ndata,sizeof(data));
+    __A_VARIABLE = 1;
     return data;
 }
 
@@ -252,6 +285,7 @@ void *raxGetData(raxNode *n) {
  * of the realloc, so the caller should discard 'n' and use the new value).
  * On out of memory NULL is returned, and the old node is still valid. */
 raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {
+    volatile int __A_VARIABLE;
     assert(n->iscompr == 0);
 
     size_t curlen = raxNodeCurrentLength(n);
@@ -262,12 +296,16 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
 
     /* Alloc the new child we will link to 'n'. */
     raxNode *child = raxNewNode(0,0);
-    if (child == NULL) return NULL;
+    if (child == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make space in the original node. */
     raxNode *newn = rax_realloc(n,newlen);
     if (newn == NULL) {
         rax_free(child);
+        __A_VARIABLE = 1;
         return NULL;
     }
     n = newn;
@@ -381,6 +419,7 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
     memcpy(childfield,&child,sizeof(child));
     *childptr = child;
     *parentlink = childfield;
+    __A_VARIABLE = 1;
     return n;
 }
 
@@ -393,6 +432,7 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
  * compressed chain cannot be part of the chain: it has zero children while
  * we can only compress inner nodes with exactly one child each. */
 raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {
+    volatile int __A_VARIABLE;
     assert(n->size == 0 && n->iscompr == 0);
     void *data = NULL; /* Initialized only to avoid warnings. */
     size_t newsize;
@@ -401,7 +441,10 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
 
     /* Allocate the child to link to this node. */
     *child = raxNewNode(0,0);
-    if (*child == NULL) return NULL;
+    if (*child == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make space in the parent node. */
     newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
@@ -412,6 +455,7 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
     raxNode *newn = rax_realloc(n,newsize);
     if (newn == NULL) {
         rax_free(*child);
+        __A_VARIABLE = 1;
         return NULL;
     }
     n = newn;
@@ -422,6 +466,7 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
     if (n->iskey) raxSetData(n,data);
     raxNode **childfield = raxNodeLastChildPtr(n);
     memcpy(childfield,child,sizeof(*child));
+    __A_VARIABLE = 1;
     return n;
 }
 
@@ -900,6 +945,8 @@ oom:
 /* Overwriting insert. Just a wrapper for raxGenericInsert() that will
  * update the element if there is already one for the same key. */
 int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return raxGenericInsert(rax,s,len,data,old,1);
 }
 
@@ -907,6 +954,8 @@ int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
  * exists, the value is not updated and the function returns 0.
  * This is a just a wrapper for raxGenericInsert(). */
 int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return raxGenericInsert(rax,s,len,data,old,0);
 }
 
@@ -914,13 +963,17 @@ int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old)
  * if the item was not found, otherwise the value associated with the
  * item is returned. */
 void *raxFind(rax *rax, unsigned char *s, size_t len) {
+    volatile int __A_VARIABLE;
     raxNode *h;
 
     debugf("### Lookup: %.*s\n", (int)len, s);
     int splitpos = 0;
     size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
-    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
+    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
+        __A_VARIABLE = 1;
         return raxNotFound;
+    }
+    __A_VARIABLE = 1;
     return raxGetData(h);
 }
 
@@ -930,6 +983,7 @@ void *raxFind(rax *rax, unsigned char *s, size_t len) {
  * operation is an undefined behavior (it will continue scanning the
  * memory without any bound checking). */
 raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
+    volatile int __A_VARIABLE;
     raxNode **cp = raxNodeFirstChildPtr(parent);
     raxNode *c;
     while(1) {
@@ -937,6 +991,7 @@ raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
         if (c == child) break;
         cp++;
     }
+    __A_VARIABLE = 1;
     return cp;
 }
 
@@ -945,6 +1000,7 @@ raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
  * of the parent node in its parent, so this task is up to the caller.
  * The function never fails for out of memory. */
 raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
+    volatile int __A_VARIABLE;
     debugnode("raxRemoveChild before", parent);
     /* If parent is a compressed node (having a single child, as for definition
      * of the data structure), the removal of the child consists into turning
@@ -957,6 +1013,7 @@ raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
         parent->size = 0;
         if (parent->iskey) raxSetData(parent,data);
         debugnode("raxRemoveChild after", parent);
+        __A_VARIABLE = 1;
         return parent;
     }
 
@@ -1012,6 +1069,7 @@ raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
     }
     /* Note: if rax_realloc() fails we just return the old address, which
      * is valid. */
+    __A_VARIABLE = 1;
     return newnode ? newnode : parent;
 }
 
@@ -1219,6 +1277,7 @@ int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {
 /* This is the core of raxFree(): performs a depth-first scan of the
  * tree and releases all the nodes found. */
 void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
+    volatile int __A_VARIABLE;
     debugnode("free traversing",n);
     int numchildren = n->iscompr ? 1 : n->size;
     raxNode **cp = raxNodeLastChildPtr(n);
@@ -1233,19 +1292,24 @@ void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
         free_callback(raxGetData(n));
     rax_free(n);
     rax->numnodes--;
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole radix tree, calling the specified callback in order to
  * free the auxiliary data. */
 void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
+    volatile int __A_VARIABLE;
     raxRecursiveFree(rax,rax->head,free_callback);
     assert(rax->numnodes == 0);
     rax_free(rax);
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole radix tree. */
 void raxFree(rax *rax) {
+    volatile int __A_VARIABLE;
     raxFreeWithCallback(rax,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------------- Iterator --------------------------------- */
@@ -1254,6 +1318,7 @@ void raxFree(rax *rax) {
  * to initialize the iterator, and must be followed by a raxSeek() call,
  * otherwise the raxPrev()/raxNext() functions will just return EOF. */
 void raxStart(raxIterator *it, rax *rt) {
+    volatile int __A_VARIABLE;
     it->flags = RAX_ITER_EOF; /* No crash if the iterator is not seeked. */
     it->rt = rt;
     it->key_len = 0;
@@ -1262,12 +1327,14 @@ void raxStart(raxIterator *it, rax *rt) {
     it->data = NULL;
     it->node_cb = NULL;
     raxStackInit(&it->stack);
+    __A_VARIABLE = 1;
 }
 
 /* Append characters at the current key string of the iterator 'it'. This
  * is a low level function used to implement the iterator, not callable by
  * the user. Returns 0 on out of memory, otherwise 1 is returned. */
 int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
+    volatile int __A_VARIABLE;
     if (it->key_max < it->key_len+len) {
         unsigned char *old = (it->key == it->key_static_string) ? NULL :
                                                                   it->key;
@@ -1276,6 +1343,7 @@ int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
         if (it->key == NULL) {
             it->key = (!old) ? it->key_static_string : old;
             errno = ENOMEM;
+            __A_VARIABLE = 1;
             return 0;
         }
         if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
@@ -1285,13 +1353,16 @@ int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
      * it->key when we use the current key in order to re-seek. */
     memmove(it->key+it->key_len,s,len);
     it->key_len += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Remove the specified number of chars from the right of the current
  * iterator key. */
 void raxIteratorDelChars(raxIterator *it, size_t count) {
+    volatile int __A_VARIABLE;
     it->key_len -= count;
+    __A_VARIABLE = 1;
 }
 
 /* Do an iteration step towards the next element. At the end of the step the
@@ -1691,14 +1762,18 @@ int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
  * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
  * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */
 int raxNext(raxIterator *it) {
+    volatile int __A_VARIABLE;
     if (!raxIteratorNextStep(it,0)) {
         errno = ENOMEM;
+        __A_VARIABLE = 1;
         return 0;
     }
     if (it->flags & RAX_ITER_EOF) {
         errno = 0;
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1706,14 +1781,18 @@ int raxNext(raxIterator *it) {
  * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is
  * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */
 int raxPrev(raxIterator *it) {
+    volatile int __A_VARIABLE;
     if (!raxIteratorPrevStep(it,0)) {
         errno = ENOMEM;
+        __A_VARIABLE = 1;
         return 0;
     }
     if (it->flags & RAX_ITER_EOF) {
         errno = 0;
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1800,8 +1879,10 @@ int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key
 
 /* Free the iterator. */
 void raxStop(raxIterator *it) {
+    volatile int __A_VARIABLE;
     if (it->key != it->key_static_string) rax_free(it->key);
     raxStackFree(&it->stack);
+    __A_VARIABLE = 1;
 }
 
 /* Return if the iterator is in an EOF state. This happens when raxSeek()
@@ -1809,6 +1890,8 @@ void raxStop(raxIterator *it) {
  * will return zero, or when an EOF condition was reached while iterating
  * with raxNext() and raxPrev(). */
 int raxEOF(raxIterator *it) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return it->flags & RAX_ITER_EOF;
 }
 
@@ -1846,6 +1929,7 @@ uint64_t raxSize(rax *rax) {
 
 /* The actual implementation of raxShow(). */
 void raxRecursiveShow(int level, int lpad, raxNode *n) {
+    volatile int __A_VARIABLE;
     char s = n->iscompr ? '"' : '[';
     char e = n->iscompr ? '"' : ']';
 
@@ -1876,17 +1960,24 @@ void raxRecursiveShow(int level, int lpad, raxNode *n) {
         raxRecursiveShow(level+1,lpad,child);
         cp++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Show a tree, as outlined in the comment above. */
 void raxShow(rax *rax) {
+    volatile int __A_VARIABLE;
     raxRecursiveShow(0,0,rax->head);
     putchar('\n');
+    __A_VARIABLE = 1;
 }
 
 /* Used by debugnode() macro to show info about a given node. */
 void raxDebugShowNode(const char *msg, raxNode *n) {
-    if (raxDebugMsg == 0) return;
+    volatile int __A_VARIABLE;
+    if (raxDebugMsg == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("%s: %p [%.*s] key:%d size:%d children:",
         msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
     int numcld = n->iscompr ? 1 : n->size;
@@ -1899,6 +1990,7 @@ void raxDebugShowNode(const char *msg, raxNode *n) {
     }
     printf("\n");
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Touch all the nodes of a tree returning a check sum. This is useful
@@ -1919,6 +2011,7 @@ void raxDebugShowNode(const char *msg, raxNode *n) {
  *    before the moment the tree is corrupted, to see what happens.
  */
 unsigned long raxTouch(raxNode *n) {
+    volatile int __A_VARIABLE;
     debugf("Touching %p\n", (void*)n);
     unsigned long sum = 0;
     if (n->iskey) {
@@ -1939,5 +2032,6 @@ unsigned long raxTouch(raxNode *n) {
         sum += raxTouch(child);
         cp++;
     }
+    __A_VARIABLE = 1;
     return sum;
 }
diff --git a/src/rdb.c b/src/rdb.c
index acbba4b..fe2f8c6 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -49,6 +49,7 @@ void rdbCheckError(const char *fmt, ...);
 void rdbCheckSetError(const char *fmt, ...);
 
 void rdbCheckThenExit(int linenum, char *reason, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char msg[1024];
     int len;
@@ -67,11 +68,16 @@ void rdbCheckThenExit(int linenum, char *reason, ...) {
         rdbCheckError("%s",msg);
     }
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
-    if (rdb && rioWrite(rdb,p,len) == 0)
+    volatile int __A_VARIABLE;
+    if (rdb && rioWrite(rdb,p,len) == 0) {
+        __A_VARIABLE = 1;
         return -1;
+    }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -79,15 +85,20 @@ static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
  * automatically abort if it is not possible to read the specified amount
  * of bytes. */
 void rdbLoadRaw(rio *rdb, void *buf, uint64_t len) {
+    volatile int __A_VARIABLE;
     if (rioRead(rdb,buf,len) == 0) {
         rdbExitReportCorruptRDB(
             "Impossible to read %llu bytes in rdbLoadRaw()",
             (unsigned long long) len);
+        __A_VARIABLE = 1;
         return; /* Not reached. */
     }
+    __A_VARIABLE = 1;
 }
 
 int rdbSaveType(rio *rdb, unsigned char type) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&type,1);
 }
 
@@ -95,8 +106,13 @@ int rdbSaveType(rio *rdb, unsigned char type) {
  * This function is not only used to load object types, but also special
  * "types" like the end-of-file type, the EXPIRE type, and so forth. */
 int rdbLoadType(rio *rdb) {
+    volatile int __A_VARIABLE;
     unsigned char type;
-    if (rioRead(rdb,&type,1) == 0) return -1;
+    if (rioRead(rdb,&type,1) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return type;
 }
 
@@ -104,14 +120,18 @@ int rdbLoadType(rio *rdb) {
  * opcode. New versions of Redis store using the RDB_OPCODE_EXPIRETIME_MS
  * opcode. */
 time_t rdbLoadTime(rio *rdb) {
+    volatile int __A_VARIABLE;
     int32_t t32;
     rdbLoadRaw(rdb,&t32,4);
+    __A_VARIABLE = 1;
     return (time_t)t32;
 }
 
 int rdbSaveMillisecondTime(rio *rdb, long long t) {
+    volatile int __A_VARIABLE;
     int64_t t64 = (int64_t) t;
     memrev64ifbe(&t64); /* Store in little endian. */
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&t64,8);
 }
 
@@ -127,10 +147,12 @@ int rdbSaveMillisecondTime(rio *rdb, long long t) {
  * RDB versions, and load older RDB versions as we used to do in the past,
  * allowing big endian systems to load their own old RDB files. */
 long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
+    volatile int __A_VARIABLE;
     int64_t t64;
     rdbLoadRaw(rdb,&t64,8);
     if (rdbver >= 9) /* Check the top comment of this function. */
         memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
+    __A_VARIABLE = 1;
     return (long long)t64;
 }
 
@@ -221,9 +243,14 @@ int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
  * (since it is a too large count to be applicable in any Redis data
  * structure). */
 uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
+    volatile int __A_VARIABLE;
     uint64_t len;
 
-    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
+    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) {
+        __A_VARIABLE = 1;
+        return RDB_LENERR;
+    }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -298,23 +325,32 @@ void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
  * range of values that can fit in an 8, 16 or 32 bit signed value can be
  * encoded as integers to save space */
 int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
+    volatile int __A_VARIABLE;
     long long value;
     char *endptr, buf[32];
 
     /* Check if it's possible to encode this value as a number */
     value = strtoll(s, &endptr, 10);
-    if (endptr[0] != '\0') return 0;
+    if (endptr[0] != '\0') {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     ll2string(buf,32,value);
 
     /* If the number converted back into a string is not identical
      * then it's not possible to encode the string as integer */
-    if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
+    if (strlen(buf) != len || memcmp(buf,s,len)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
+    __A_VARIABLE = 1;
     return rdbEncodeInteger(value,enc);
 }
 
 ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
                        size_t original_len) {
+    volatile int __A_VARIABLE;
     unsigned char byte;
     ssize_t n, nwritten = 0;
 
@@ -332,27 +368,38 @@ ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
     if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
     nwritten += n;
 
+    __A_VARIABLE = 1;
     return nwritten;
 
 writeerr:
+    __A_VARIABLE = 1;
     return -1;
 }
 
 ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
+    volatile int __A_VARIABLE;
     size_t comprlen, outlen;
     void *out;
 
     /* We require at least four bytes compression for this to be worth it */
-    if (len <= 4) return 0;
+    if (len <= 4) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     outlen = len-4;
-    if ((out = zmalloc(outlen+1)) == NULL) return 0;
+    if ((out = zmalloc(outlen+1)) == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     comprlen = lzf_compress(s, len, out, outlen);
     if (comprlen == 0) {
         zfree(out);
+        __A_VARIABLE = 1;
         return 0;
     }
     ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
     zfree(out);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -403,6 +450,7 @@ err:
 /* Save a string object as [len][data] on disk. If the object is a string
  * representation of an integer value we try to save it in a special form */
 ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
+    volatile int __A_VARIABLE;
     int enclen;
     ssize_t n, nwritten = 0;
 
@@ -410,7 +458,11 @@ ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
     if (len <= 11) {
         unsigned char buf[5];
         if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
-            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
+            if (rdbWriteRaw(rdb,buf,enclen) == -1) {
+                __A_VARIABLE = 1;
+                return -1;
+            }
+            __A_VARIABLE = 1;
             return enclen;
         }
     }
@@ -419,18 +471,31 @@ ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
      * aaaaaaaaaaaaaaaaaa so skip it */
     if (server.rdb_compression && len > 20) {
         n = rdbSaveLzfStringObject(rdb,s,len);
-        if (n == -1) return -1;
-        if (n > 0) return n;
+        if (n == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (n > 0) {
+            __A_VARIABLE = 1;
+            return n;
+        }
         /* Return value of 0 means data can't be compressed, save the old way */
     }
 
     /* Store verbatim */
-    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,len)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
     if (len > 0) {
-        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
+        if (rdbWriteRaw(rdb,s,len) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += len;
     }
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -523,10 +588,14 @@ void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
 }
 
 robj *rdbLoadStringObject(rio *rdb) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
 }
 
 robj *rdbLoadEncodedStringObject(rio *rdb) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
 }
 
@@ -539,6 +608,7 @@ robj *rdbLoadEncodedStringObject(rio *rdb) {
  * 255: - inf
  */
 int rdbSaveDoubleValue(rio *rdb, double val) {
+    volatile int __A_VARIABLE;
     unsigned char buf[128];
     int len;
 
@@ -569,23 +639,35 @@ int rdbSaveDoubleValue(rio *rdb, double val) {
         buf[0] = strlen((char*)buf+1);
         len = buf[0]+1;
     }
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,buf,len);
 }
 
 /* For information about double serialization check rdbSaveDoubleValue() */
 int rdbLoadDoubleValue(rio *rdb, double *val) {
+    volatile int __A_VARIABLE;
     char buf[256];
     unsigned char len;
 
-    if (rioRead(rdb,&len,1) == 0) return -1;
+    if (rioRead(rdb,&len,1) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     switch(len) {
-    case 255: *val = R_NegInf; return 0;
-    case 254: *val = R_PosInf; return 0;
-    case 253: *val = R_Nan; return 0;
+    case 255: *val = R_NegInf; __A_VARIABLE = 1;
+        return 0;
+    case 254: *val = R_PosInf; __A_VARIABLE = 1;
+        return 0;
+    case 253: *val = R_Nan; __A_VARIABLE = 1;
+        return 0;
     default:
-        if (rioRead(rdb,buf,len) == 0) return -1;
+        if (rioRead(rdb,buf,len) == 0) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         buf[len] = '\0';
         sscanf(buf, "%lg", val);
+        __A_VARIABLE = 1;
         return 0;
     }
 }
@@ -596,28 +678,42 @@ int rdbLoadDoubleValue(rio *rdb, double *val) {
  *
  * Return -1 on error, the size of the serialized value on success. */
 int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
+    volatile int __A_VARIABLE;
     memrev64ifbe(&val);
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&val,sizeof(val));
 }
 
 /* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for
  * more info. On error -1 is returned, otherwise 0. */
 int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
-    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    volatile int __A_VARIABLE;
+    if (rioRead(rdb,val,sizeof(*val)) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     memrev64ifbe(val);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Like rdbSaveBinaryDoubleValue() but single precision. */
 int rdbSaveBinaryFloatValue(rio *rdb, float val) {
+    volatile int __A_VARIABLE;
     memrev32ifbe(&val);
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&val,sizeof(val));
 }
 
 /* Like rdbLoadBinaryDoubleValue() but single precision. */
 int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
-    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    volatile int __A_VARIABLE;
+    if (rioRead(rdb,val,sizeof(*val)) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     memrev32ifbe(val);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -665,9 +761,17 @@ int rdbSaveObjectType(rio *rdb, robj *o) {
 /* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the
  * type is not specifically a valid Object Type. */
 int rdbLoadObjectType(rio *rdb) {
+    volatile int __A_VARIABLE;
     int type;
-    if ((type = rdbLoadType(rdb)) == -1) return -1;
-    if (!rdbIsObjectType(type)) return -1;
+    if ((type = rdbLoadType(rdb)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (!rdbIsObjectType(type)) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return type;
 }
 
@@ -679,10 +783,14 @@ int rdbLoadObjectType(rio *rdb) {
  * PELs we just add the ID, that will be resolved inside the global PEL to
  * put a reference to the same structure. */
 ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
+    volatile int __A_VARIABLE;
     ssize_t n, nwritten = 0;
 
     /* Number of entries in the PEL. */
-    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
 
     /* Save each entry. */
@@ -692,15 +800,23 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
     while(raxNext(&ri)) {
         /* We store IDs in raw form as 128 big big endian numbers, like
          * they are inside the radix tree key. */
-        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
+        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += n;
 
         if (nacks) {
             streamNACK *nack = ri.data;
-            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
+            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {
+                __A_VARIABLE = 1;
                 return -1;
+            }
             nwritten += n;
-            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
+            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {
+                __A_VARIABLE = 1;
+                return -1;
+            }
             nwritten += n;
             /* We don't save the consumer name: we'll save the pending IDs
              * for each consumer in the consumer PEL, and resolve the consumer
@@ -708,6 +824,7 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
         }
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -715,10 +832,14 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
  * function for the stream data type serialization. What we do here is to
  * persist the consumer metadata, and it's PEL, for each consumer. */
 size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
+    volatile int __A_VARIABLE;
     ssize_t n, nwritten = 0;
 
     /* Number of consumers in this consumer group. */
-    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
 
     /* Save each consumer. */
@@ -729,23 +850,31 @@ size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
         streamConsumer *consumer = ri.data;
 
         /* Consumer name. */
-        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
+        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += n;
 
         /* Last seen time. */
-        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
+        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         nwritten += n;
 
         /* Consumer PEL, without the ACKs (see last parameter of the function
          * passed with value of 0), at loading time we'll lookup the ID
          * in the consumer group global PEL and will put a reference in the
          * consumer local PEL. */
-        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
+        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         nwritten += n;
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -998,8 +1127,10 @@ ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
  * this length with very little changes to the code. In the future
  * we could switch to a faster solution. */
 size_t rdbSavedObjectLen(robj *o) {
+    volatile int __A_VARIABLE;
     ssize_t len = rdbSaveObject(NULL,o,NULL);
     serverAssertWithInfo(NULL,o,len != -1);
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -1008,21 +1139,34 @@ size_t rdbSavedObjectLen(robj *o) {
  * On success if the key was actually saved 1 is returned, otherwise 0
  * is returned (the key was already expired). */
 int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {
+    volatile int __A_VARIABLE;
     int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
     int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;
 
     /* Save the expire time */
     if (expiretime != -1) {
-        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
-        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save the LRU info. */
     if (savelru) {
         uint64_t idletime = estimateObjectIdleTime(val);
         idletime /= 1000; /* Using seconds is enough and requires less space.*/
-        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
-        if (rdbSaveLen(rdb,idletime) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbSaveLen(rdb,idletime) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save the LFU info. */
@@ -1033,67 +1177,125 @@ int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {
          * bit counter, since the frequency is logarithmic with a 0-255 range.
          * Note that we do not store the halving time because to reset it
          * a single time when loading does not affect the frequency much. */
-        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
-        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbWriteRaw(rdb,buf,1) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save type, key, value */
-    if (rdbSaveObjectType(rdb,val) == -1) return -1;
-    if (rdbSaveStringObject(rdb,key) == -1) return -1;
-    if (rdbSaveObject(rdb,val,key) == -1) return -1;
+    if (rdbSaveObjectType(rdb,val) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveStringObject(rdb,key) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveObject(rdb,val,key) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Save an AUX field. */
 ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
+    volatile int __A_VARIABLE;
     ssize_t ret, len = 0;
-    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
+    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
-    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
+    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
-    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
+    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
+    __A_VARIABLE = 1;
     return len;
 }
 
 /* Wrapper for rdbSaveAuxField() used when key/val length can be obtained
  * with strlen(). */
 ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
 }
 
 /* Wrapper for strlen(key) + integer type (up to long long range). */
 ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
+    volatile int __A_VARIABLE;
     char buf[LONG_STR_SIZE];
     int vlen = ll2string(buf,sizeof(buf),val);
+    __A_VARIABLE = 1;
     return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
 }
 
 /* Save a few default AUX fields with information about the RDB generated. */
 int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
     int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
 
     /* Add a few fields about the state when the RDB was created. */
-    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
+    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Handle saving options that generate aux fields. */
     if (rsi) {
         if (rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
         if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
         if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
     }
-    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
+    volatile int __A_VARIABLE;
     /* Save a module-specific aux value. */
     RedisModuleIO io;
     int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);
@@ -1101,17 +1303,26 @@ ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
     /* Write the "module" identifier as prefix, so that we'll be able
      * to call the right module during loading. */
     retval = rdbSaveLen(rdb,mt->id);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
 
     /* write the 'when' so that we can provide it on loading. add a UINT opcode
      * for backwards compatibility, everything after the MT needs to be prefixed
      * by an opcode. */
     retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
     retval = rdbSaveLen(rdb,when);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
 
     /* Then write the module-specific representation + EOF marker. */
@@ -1127,8 +1338,11 @@ ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
         moduleFreeContext(io.ctx);
         zfree(io.ctx);
     }
-    if (io.error)
+    if (io.error) {
+        __A_VARIABLE = 1;
         return -1;
+    }
+    __A_VARIABLE = 1;
     return io.bytes;
 }
 
@@ -1141,6 +1355,7 @@ ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
  * integer pointed by 'error' is set to the value of errno just after the I/O
  * error. */
 int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     dictIterator *di = NULL;
     dictEntry *de;
     char magic[10];
@@ -1225,11 +1440,13 @@ int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
     cksum = rdb->cksum;
     memrev64ifbe(&cksum);
     if (rioWrite(rdb,&cksum,8) == 0) goto werr;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     if (error) *error = errno;
     if (di) dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1242,6 +1459,7 @@ werr:
  * This way processes receiving the payload can understand when it ends
  * without doing any processing of the content. */
 int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     char eofmark[RDB_EOF_MARK_SIZE];
 
     getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
@@ -1251,16 +1469,19 @@ int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
     if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
     if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
     if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr: /* Write error. */
     /* Set 'error' only if not already set by rdbSaveRio() call. */
     if (error && *error == 0) *error = errno;
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
 /* Save the DB on disk. Return C_ERR on error, C_OK on success. */
 int rdbSave(char *filename, rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     char tmpfile[256];
     char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
     FILE *fp;
@@ -1277,6 +1498,7 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
             filename,
             cwdp ? cwdp : "unknown",
             strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1307,6 +1529,7 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
             cwdp ? cwdp : "unknown",
             strerror(errno));
         unlink(tmpfile);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1314,12 +1537,14 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
     server.dirty = 0;
     server.lastsave = time(NULL);
     server.lastbgsave_status = C_OK;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     serverLog(LL_WARNING,"Write error saving DB on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1377,10 +1602,12 @@ int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
 }
 
 void rdbRemoveTempFile(pid_t childpid) {
+    volatile int __A_VARIABLE;
     char tmpfile[256];
 
     snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by rdbLoadObject() when the code is in RDB-check
@@ -1388,6 +1615,7 @@ void rdbRemoveTempFile(pid_t childpid) {
  * the need of the actual module. The value is parsed for errors, finally
  * a dummy redis object is returned just to conform to the API. */
 robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
+    volatile int __A_VARIABLE;
     uint64_t opcode;
     while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
         if (opcode == RDB_MODULE_OPCODE_SINT ||
@@ -1419,6 +1647,7 @@ robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return createStringObject("module-dummy-value",18);
 }
 
@@ -1845,6 +2074,7 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, robj *key) {
 /* Mark that we are loading in the global state and setup the fields
  * needed to provide loading stats. */
 void startLoading(FILE *fp) {
+    volatile int __A_VARIABLE;
     struct stat sb;
 
     /* Load the DB */
@@ -1856,23 +2086,29 @@ void startLoading(FILE *fp) {
     } else {
         server.loading_total_bytes = sb.st_size;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Refresh the loading progress info */
 void loadingProgress(off_t pos) {
+    volatile int __A_VARIABLE;
     server.loading_loaded_bytes = pos;
     if (server.stat_peak_memory < zmalloc_used_memory())
         server.stat_peak_memory = zmalloc_used_memory();
+    __A_VARIABLE = 1;
 }
 
 /* Loading finished */
 void stopLoading(void) {
+    volatile int __A_VARIABLE;
     server.loading = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Track loading progress in order to serve client's from time to time
    and if needed calculate rdb checksum  */
 void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     if (server.rdb_checksum)
         rioGenericUpdateChecksum(r, buf, len);
     if (server.loading_process_events_interval_bytes &&
@@ -1887,11 +2123,13 @@ void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
         loadingProgress(r->processed_bytes);
         processEventsWhileBlocked();
     }
+    __A_VARIABLE = 1;
 }
 
 /* Load an RDB file from the rio stream 'rdb'. On success C_OK is returned,
  * otherwise C_ERR is returned and 'errno' is set accordingly. */
 int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
+    volatile int __A_VARIABLE;
     uint64_t dbid;
     int type, rdbver;
     redisDb *db = server.db+0;
@@ -1904,12 +2142,14 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
     if (memcmp(buf,"REDIS",5) != 0) {
         serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     rdbver = atoi(buf+5);
     if (rdbver < 1 || rdbver > RDB_VERSION) {
         serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -2117,11 +2357,13 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return C_OK;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
     serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
     rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
+    __A_VARIABLE = 1;
     return C_ERR; /* Just to avoid warning */
 }
 
@@ -2133,22 +2375,28 @@ eoferr: /* unexpected end of file is handled here with a fatal exit */
  * If you pass an 'rsi' structure initialied with RDB_SAVE_OPTION_INIT, the
  * loading code will fiil the information fields in the structure. */
 int rdbLoad(char *filename, rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     FILE *fp;
     rio rdb;
     int retval;
 
-    if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
+    if ((fp = fopen(filename,"r")) == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     startLoading(fp);
     rioInitWithFile(&rdb,fp);
     retval = rdbLoadRio(&rdb,rsi,0);
     fclose(fp);
     stopLoading();
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* A background saving child (BGSAVE) terminated its work. Handle this.
  * This function covers the case of actual BGSAVEs. */
 void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
+    volatile int __A_VARIABLE;
     if (!bysignal && exitcode == 0) {
         serverLog(LL_NOTICE,
             "Background saving terminated with success");
@@ -2179,12 +2427,14 @@ void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
     /* Possibly there are slaves waiting for a BGSAVE in order to be served
      * (the first stage of SYNC is a bulk transfer of dump.rdb) */
     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
+    __A_VARIABLE = 1;
 }
 
 /* A background saving child (BGSAVE) terminated its work. Handle this.
  * This function covers the case of RDB -> Salves socket transfers for
  * diskless replication. */
 void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
+    volatile int __A_VARIABLE;
     uint64_t *ok_slaves;
 
     if (!bysignal && exitcode == 0) {
@@ -2274,10 +2524,12 @@ void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
     zfree(ok_slaves);
 
     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
+    __A_VARIABLE = 1;
 }
 
 /* When a background RDB saving/transfer terminates, call the right handler. */
 void backgroundSaveDoneHandler(int exitcode, int bysignal) {
+    volatile int __A_VARIABLE;
     switch(server.rdb_child_type) {
     case RDB_CHILD_TYPE_DISK:
         backgroundSaveDoneHandlerDisk(exitcode,bysignal);
@@ -2289,6 +2541,7 @@ void backgroundSaveDoneHandler(int exitcode, int bysignal) {
         serverPanic("Unknown RDB child type.");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Spawn an RDB child that writes the RDB to the sockets of the slaves
@@ -2453,8 +2706,10 @@ int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
 }
 
 void saveCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (server.rdb_child_pid != -1) {
         addReplyError(c,"Background save already in progress");
+        __A_VARIABLE = 1;
         return;
     }
     rdbSaveInfo rsi, *rsiptr;
@@ -2464,6 +2719,7 @@ void saveCommand(client *c) {
     } else {
         addReply(c,shared.err);
     }
+    __A_VARIABLE = 1;
 }
 
 /* BGSAVE [SCHEDULE] */
@@ -2513,6 +2769,7 @@ void bgsaveCommand(client *c) {
  * is returned, and the RDB saving will not persist any replication related
  * information. */
 rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
+    volatile int __A_VARIABLE;
     rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
     *rsi = rsi_init;
 
@@ -2530,6 +2787,7 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
          * to reload replication ID/offset, it's safe because the next write
          * command must generate a SELECT statement. */
         rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
+        __A_VARIABLE = 1;
         return rsi;
     }
 
@@ -2537,6 +2795,7 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
      * in order to fetch the currently selected DB. */
     if (server.master) {
         rsi->repl_stream_db = server.master->db->id;
+        __A_VARIABLE = 1;
         return rsi;
     }
 
@@ -2547,7 +2806,9 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
      * is valid. */
     if (server.cached_master) {
         rsi->repl_stream_db = server.cached_master->db->id;
+        __A_VARIABLE = 1;
         return rsi;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
diff --git a/src/redis-benchmark.c b/src/redis-benchmark.c
index d30879d..50812ff 100644
--- a/src/redis-benchmark.c
+++ b/src/redis-benchmark.c
@@ -103,26 +103,31 @@ static void createMissingClients(client c);
 
 /* Implementation */
 static long long ustime(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     long long ust;
 
     gettimeofday(&tv, NULL);
     ust = ((long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 static long long mstime(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     long long mst;
 
     gettimeofday(&tv, NULL);
     mst = ((long long)tv.tv_sec)*1000;
     mst += tv.tv_usec/1000;
+    __A_VARIABLE = 1;
     return mst;
 }
 
 static void freeClient(client c) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     aeDeleteFileEvent(config.el,c->context->fd,AE_WRITABLE);
     aeDeleteFileEvent(config.el,c->context->fd,AE_READABLE);
@@ -134,9 +139,11 @@ static void freeClient(client c) {
     ln = listSearchKey(config.clients,c);
     assert(ln != NULL);
     listDelNode(config.clients,ln);
+    __A_VARIABLE = 1;
 }
 
 static void freeAllClients(void) {
+    volatile int __A_VARIABLE;
     listNode *ln = config.clients->head, *next;
 
     while(ln) {
@@ -144,17 +151,21 @@ static void freeAllClients(void) {
         freeClient(ln->value);
         ln = next;
     }
+    __A_VARIABLE = 1;
 }
 
 static void resetClient(client c) {
+    volatile int __A_VARIABLE;
     aeDeleteFileEvent(config.el,c->context->fd,AE_WRITABLE);
     aeDeleteFileEvent(config.el,c->context->fd,AE_READABLE);
     aeCreateFileEvent(config.el,c->context->fd,AE_WRITABLE,writeHandler,c);
     c->written = 0;
     c->pending = config.pipeline;
+    __A_VARIABLE = 1;
 }
 
 static void randomizeClientKey(client c) {
+    volatile int __A_VARIABLE;
     size_t i;
 
     for (i = 0; i < c->randlen; i++) {
@@ -168,12 +179,15 @@ static void randomizeClientKey(client c) {
             p--;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static void clientDone(client c) {
+    volatile int __A_VARIABLE;
     if (config.requests_finished == config.requests) {
         freeClient(c);
         aeStop(config.el);
+        __A_VARIABLE = 1;
         return;
     }
     if (config.keepalive) {
@@ -184,9 +198,11 @@ static void clientDone(client c) {
         config.liveclients++;
         freeClient(c);
     }
+    __A_VARIABLE = 1;
 }
 
 static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     client c = privdata;
     void *reply = NULL;
     UNUSED(el);
@@ -253,9 +269,11 @@ static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     client c = privdata;
     UNUSED(el);
     UNUSED(fd);
@@ -266,6 +284,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         /* Enforce upper bound to number of requests. */
         if (config.requests_issued++ >= config.requests) {
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -282,6 +301,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EPIPE)
                 fprintf(stderr, "Writing to socket: %s\n", strerror(errno));
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
         c->written += nwritten;
@@ -290,6 +310,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             aeCreateFileEvent(config.el,c->context->fd,AE_READABLE,readHandler,c);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create a benchmark client, configured to send the command passed as 'cmd' of
@@ -314,6 +335,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
  *
  * Even when cloning another client, prefix commands are applied if needed.*/
 static client createClient(char *cmd, size_t len, client from) {
+    volatile int __A_VARIABLE;
     int j;
     client c = zmalloc(sizeof(struct _client));
 
@@ -407,10 +429,12 @@ static client createClient(char *cmd, size_t len, client from) {
         aeCreateFileEvent(config.el,c->context->fd,AE_WRITABLE,writeHandler,c);
     listAddNodeTail(config.clients,c);
     config.liveclients++;
+    __A_VARIABLE = 1;
     return c;
 }
 
 static void createMissingClients(client c) {
+    volatile int __A_VARIABLE;
     int n = 0;
 
     while(config.liveclients < config.numclients) {
@@ -422,13 +446,17 @@ static void createMissingClients(client c) {
             n = 0;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static int compareLatency(const void *a, const void *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (*(long long*)a)-(*(long long*)b);
 }
 
 static void showLatencyReport(void) {
+    volatile int __A_VARIABLE;
     int i, curlat = 0;
     float perc, reqpersec;
 
@@ -456,9 +484,11 @@ static void showLatencyReport(void) {
     } else {
         printf("%s: %.2f requests per second\n", config.title, reqpersec);
     }
+    __A_VARIABLE = 1;
 }
 
 static void benchmark(char *title, char *cmd, int len) {
+    volatile int __A_VARIABLE;
     client c;
 
     config.title = title;
@@ -474,6 +504,7 @@ static void benchmark(char *title, char *cmd, int len) {
 
     showLatencyReport();
     freeAllClients();
+    __A_VARIABLE = 1;
 }
 
 /* Returns number of consumed options. */
@@ -610,6 +641,7 @@ usage:
 }
 
 int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+    volatile int __A_VARIABLE;
     UNUSED(eventLoop);
     UNUSED(id);
     UNUSED(clientData);
@@ -618,34 +650,45 @@ int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData
         fprintf(stderr,"All clients disconnected... aborting.\n");
         exit(1);
     }
-    if (config.csv) return 250;
+    if (config.csv) {
+        __A_VARIABLE = 1;
+        return 250;
+    }
     if (config.idlemode == 1) {
         printf("clients: %d\r", config.liveclients);
         fflush(stdout);
+	__A_VARIABLE = 1;
 	return 250;
     }
     float dt = (float)(mstime()-config.start)/1000.0;
     float rps = (float)config.requests_finished/dt;
     printf("%s: %.2f\r", config.title, rps);
     fflush(stdout);
+    __A_VARIABLE = 1;
     return 250; /* every 250ms */
 }
 
 /* Return true if the named test was selected using the -t command line
  * switch, or if all the tests are selected (no -t passed by user). */
 int test_is_selected(char *name) {
+    volatile int __A_VARIABLE;
     char buf[256];
     int l = strlen(name);
 
-    if (config.tests == NULL) return 1;
+    if (config.tests == NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     buf[0] = ',';
     memcpy(buf+1,name,l);
     buf[l+1] = ',';
     buf[l+2] = '\0';
+    __A_VARIABLE = 1;
     return strstr(config.tests,buf) != NULL;
 }
 
 int main(int argc, const char **argv) {
+    volatile int __A_VARIABLE;
     int i;
     char *data, *cmd;
     int len;
@@ -712,6 +755,7 @@ int main(int argc, const char **argv) {
             free(cmd);
         } while(config.loop);
 
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -842,5 +886,6 @@ int main(int argc, const char **argv) {
         if (!config.csv) printf("\n");
     } while(config.loop);
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/src/redis-check-aof.c b/src/redis-check-aof.c
index eedb09d..b449903 100644
--- a/src/redis-check-aof.c
+++ b/src/redis-check-aof.c
@@ -41,42 +41,54 @@ static char error[1044];
 static off_t epos;
 
 int consumeNewline(char *buf) {
+    volatile int __A_VARIABLE;
     if (strncmp(buf,"\r\n",2) != 0) {
         ERROR("Expected \\r\\n, got: %02x%02x",buf[0],buf[1]);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int readLong(FILE *fp, char prefix, long *target) {
+    volatile int __A_VARIABLE;
     char buf[128], *eptr;
     epos = ftello(fp);
     if (fgets(buf,sizeof(buf),fp) == NULL) {
+        __A_VARIABLE = 1;
         return 0;
     }
     if (buf[0] != prefix) {
         ERROR("Expected prefix '%c', got: '%c'",prefix,buf[0]);
+        __A_VARIABLE = 1;
         return 0;
     }
     *target = strtol(buf+1,&eptr,10);
+    __A_VARIABLE = 1;
     return consumeNewline(eptr);
 }
 
 int readBytes(FILE *fp, char *target, long length) {
+    volatile int __A_VARIABLE;
     long real;
     epos = ftello(fp);
     real = fread(target,1,length,fp);
     if (real != length) {
         ERROR("Expected to read %ld bytes, got %ld bytes",length,real);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int readString(FILE *fp, char** target) {
+    volatile int __A_VARIABLE;
     long len;
     *target = NULL;
     if (!readLong(fp,'$',&len)) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -84,20 +96,26 @@ int readString(FILE *fp, char** target) {
     len += 2;
     *target = (char*)zmalloc(len);
     if (!readBytes(fp,*target,len)) {
+        __A_VARIABLE = 1;
         return 0;
     }
     if (!consumeNewline(*target+len-2)) {
+        __A_VARIABLE = 1;
         return 0;
     }
     (*target)[len-2] = '\0';
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int readArgc(FILE *fp, long *target) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return readLong(fp,'*',target);
 }
 
 off_t process(FILE *fp) {
+    volatile int __A_VARIABLE;
     long argc;
     off_t pos = 0;
     int i, multi = 0;
@@ -138,10 +156,12 @@ off_t process(FILE *fp) {
     if (strlen(error) > 0) {
         printf("%s\n", error);
     }
+    __A_VARIABLE = 1;
     return pos;
 }
 
 int redis_check_aof_main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     char *filename;
     int fix = 0;
 
@@ -230,4 +250,5 @@ int redis_check_aof_main(int argc, char **argv) {
 
     fclose(fp);
     exit(0);
+    __A_VARIABLE = 1;
 }
diff --git a/src/redis-check-rdb.c b/src/redis-check-rdb.c
index ec00ee7..ddc47b1 100644
--- a/src/redis-check-rdb.c
+++ b/src/redis-check-rdb.c
@@ -90,14 +90,17 @@ char *rdb_type_string[] = {
 
 /* Show a few stats collected into 'rdbstate' */
 void rdbShowGenericInfo(void) {
+    volatile int __A_VARIABLE;
     printf("[info] %lu keys read\n", rdbstate.keys);
     printf("[info] %lu expires\n", rdbstate.expires);
     printf("[info] %lu already expired\n", rdbstate.already_expired);
+    __A_VARIABLE = 1;
 }
 
 /* Called on RDB errors. Provides details about the RDB and the offset
  * we were when the error was detected. */
 void rdbCheckError(const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     char msg[1024];
     va_list ap;
 
@@ -121,10 +124,12 @@ void rdbCheckError(const char *fmt, ...) {
              sizeof(rdb_type_string)/sizeof(char*)) ?
                 rdb_type_string[rdbstate.key_type] : "unknown");
     rdbShowGenericInfo();
+    __A_VARIABLE = 1;
 }
 
 /* Print informations during RDB checking. */
 void rdbCheckInfo(const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     char msg[1024];
     va_list ap;
 
@@ -135,32 +140,38 @@ void rdbCheckInfo(const char *fmt, ...) {
     printf("[offset %llu] %s\n",
         (unsigned long long) (rdbstate.rio ?
             rdbstate.rio->processed_bytes : 0), msg);
+    __A_VARIABLE = 1;
 }
 
 /* Used inside rdb.c in order to log specific errors happening inside
  * the RDB loading internals. */
 void rdbCheckSetError(const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
 
     va_start(ap, fmt);
     vsnprintf(rdbstate.error, sizeof(rdbstate.error), fmt, ap);
     va_end(ap);
     rdbstate.error_set = 1;
+    __A_VARIABLE = 1;
 }
 
 /* During RDB check we setup a special signal handler for memory violations
  * and similar conditions, so that we can log the offending part of the RDB
  * if the crash is due to broken content. */
 void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {
+    volatile int __A_VARIABLE;
     UNUSED(sig);
     UNUSED(info);
     UNUSED(secret);
 
     rdbCheckError("Server crash checking the specified RDB file!");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 void rdbCheckSetupSignals(void) {
+    volatile int __A_VARIABLE;
     struct sigaction act;
 
     sigemptyset(&act.sa_mask);
@@ -170,6 +181,7 @@ void rdbCheckSetupSignals(void) {
     sigaction(SIGBUS, &act, NULL);
     sigaction(SIGFPE, &act, NULL);
     sigaction(SIGILL, &act, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Check the specified RDB file. Return 0 if the RDB looks sane, otherwise
@@ -177,6 +189,7 @@ void rdbCheckSetupSignals(void) {
  * The file is specified as a filename in 'rdbfilename' if 'fp' is not NULL,
  * otherwise the already open file 'fp' is checked. */
 int redis_check_rdb(char *rdbfilename, FILE *fp) {
+    volatile int __A_VARIABLE;
     uint64_t dbid;
     int type, rdbver;
     char buf[1024];
@@ -184,7 +197,10 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
     static rio rdb; /* Pointed by global struct riostate. */
 
     int closefile = (fp == NULL);
-    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) return 1;
+    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
 
     rioInitWithFile(&rdb,fp);
     rdbstate.rio = &rdb;
@@ -314,6 +330,7 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
     }
 
     if (closefile) fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
@@ -324,6 +341,7 @@ eoferr: /* unexpected end of file is handled here with a fatal exit */
     }
 err:
     if (closefile) fclose(fp);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -340,6 +358,7 @@ err:
  * Otherwise if called with a non NULL fp, the function returns C_OK or
  * C_ERR depending on the success or failure. */
 int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
+    volatile int __A_VARIABLE;
     if (argc != 2 && fp == NULL) {
         fprintf(stderr, "Usage: %s <rdb-file-name>\n", argv[0]);
         exit(1);
@@ -358,6 +377,10 @@ int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
         rdbCheckInfo("\\o/ RDB looks OK! \\o/");
         rdbShowGenericInfo();
     }
-    if (fp) return (retval == 0) ? C_OK : C_ERR;
+    if (fp) {
+        __A_VARIABLE = 1;
+        return (retval == 0) ? C_OK : C_ERR;
+    }
     exit(retval);
+    __A_VARIABLE = 1;
 }
diff --git a/src/redis-cli.c b/src/redis-cli.c
index ed9355c..014b11d 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -255,21 +255,29 @@ static long getLongInfoField(char *info, char *field);
 uint16_t crc16(const char *buf, int len);
 
 static long long ustime(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     long long ust;
 
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 static long long mstime(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ustime()/1000;
 }
 
 static void cliRefreshPrompt(void) {
-    if (config.eval_ldb) return;
+    volatile int __A_VARIABLE;
+    if (config.eval_ldb) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     sds prompt = sdsempty();
     if (config.hostsocket != NULL) {
@@ -288,6 +296,7 @@ static void cliRefreshPrompt(void) {
     prompt = sdscatlen(prompt,"> ",2);
     snprintf(config.prompt,sizeof(config.prompt),"%s",prompt);
     sdsfree(prompt);
+    __A_VARIABLE = 1;
 }
 
 /* Return the name of the dotfile for the specified 'dotfilename'.
@@ -327,6 +336,7 @@ static sds getDotfilePath(char *envoverride, char *dotfilename) {
 #define decodeHex(h, l) ((decodeHexChar(h) << 4) + decodeHexChar(l))
 
 static sds percentDecode(const char *pe, size_t len) {
+    volatile int __A_VARIABLE;
     const char *end = pe + len;
     sds ret = sdsempty();
     const char *curr = pe;
@@ -352,6 +362,7 @@ static sds percentDecode(const char *pe, size_t len) {
         }
     }
 
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -364,6 +375,7 @@ static sds percentDecode(const char *pe, size_t len) {
  *
  *  [1]: https://www.iana.org/assignments/uri-schemes/prov/redis */
 static void parseRedisUri(const char *uri) {
+    volatile int __A_VARIABLE;
 
     const char *scheme = "redis://";
     const char *curr = uri;
@@ -376,7 +388,10 @@ static void parseRedisUri(const char *uri) {
         exit(1);
     }
     curr += strlen(scheme);
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract user info. */
     if ((userinfo = strchr(curr,'@'))) {
@@ -388,7 +403,10 @@ static void parseRedisUri(const char *uri) {
         config.auth = percentDecode(curr, userinfo - curr);
         curr = userinfo + 1;
     }
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract host and port. */
     path = strchr(curr, '/');
@@ -401,46 +419,63 @@ static void parseRedisUri(const char *uri) {
         config.hostip = sdsnewlen(curr, host - curr + 1);
     }
     curr = path ? path + 1 : end;
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract database number. */
     config.dbnum = atoi(curr);
+    __A_VARIABLE = 1;
 }
 
 static uint64_t dictSdsHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 static int dictSdsKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
+    volatile int __A_VARIABLE;
     int l1,l2;
     DICT_NOTUSED(privdata);
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
 static void dictSdsDestructor(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 void dictListDestructor(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
     listRelease((list*)val);
+    __A_VARIABLE = 1;
 }
 
 #ifndef CONFIG_LIBREDIS_SERVER
 /* _serverAssert is needed by dict */
 void _serverAssert(const char *estr, const char *file, int line) {
+    volatile int __A_VARIABLE;
     fprintf(stderr, "=== ASSERTION FAILED ===");
     fprintf(stderr, "==> %s:%d '%s' is not true",file,line,estr);
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -465,6 +500,7 @@ static helpEntry *helpEntries;
 static int helpEntriesLen;
 
 static sds cliVersion(void) {
+    volatile int __A_VARIABLE;
     sds version;
     version = sdscatprintf(sdsempty(), "%s", REDIS_VERSION);
 
@@ -475,10 +511,12 @@ static sds cliVersion(void) {
             version = sdscatprintf(version, "-dirty");
         version = sdscat(version, ")");
     }
+    __A_VARIABLE = 1;
     return version;
 }
 
 static void cliInitHelp(void) {
+    volatile int __A_VARIABLE;
     int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);
     int groupslen = sizeof(commandGroups)/sizeof(char*);
     int i, len, pos = 0;
@@ -504,6 +542,7 @@ static void cliInitHelp(void) {
         tmp.org = &commandHelp[i];
         helpEntries[pos++] = tmp;
     }
+    __A_VARIABLE = 1;
 }
 
 /* cliInitHelp() setups the helpEntries array with the command and group
@@ -512,10 +551,17 @@ static void cliInitHelp(void) {
  * entries with additional entries obtained using the COMMAND command
  * available in recent versions of Redis. */
 static void cliIntegrateHelp(void) {
-    if (cliConnect(CC_QUIET) == REDIS_ERR) return;
+    volatile int __A_VARIABLE;
+    if (cliConnect(CC_QUIET) == REDIS_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     redisReply *reply = redisCommand(context, "COMMAND");
-    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;
+    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Scan the array reported by COMMAND and fill only the entries that
      * don't already match what we have. */
@@ -524,7 +570,10 @@ static void cliIntegrateHelp(void) {
         if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
             entry->element[0]->type != REDIS_REPLY_STRING ||
             entry->element[1]->type != REDIS_REPLY_INTEGER ||
-            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
+            entry->element[3]->type != REDIS_REPLY_INTEGER) {
+            __A_VARIABLE = 1;
+            return;
+        }
         char *cmdname = entry->element[0]->str;
         int i;
 
@@ -564,20 +613,24 @@ static void cliIntegrateHelp(void) {
         new->org = ch;
     }
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
 }
 
 /* Output command help to stdout. */
 static void cliOutputCommandHelp(struct commandHelp *help, int group) {
+    volatile int __A_VARIABLE;
     printf("\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n", help->name, help->params);
     printf("  \x1b[33msummary:\x1b[0m %s\r\n", help->summary);
     printf("  \x1b[33msince:\x1b[0m %s\r\n", help->since);
     if (group) {
         printf("  \x1b[33mgroup:\x1b[0m %s\r\n", commandGroups[help->group]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Print generic help. */
 static void cliOutputGenericHelp(void) {
+    volatile int __A_VARIABLE;
     sds version = cliVersion();
     printf(
         "redis-cli %s\n"
@@ -594,6 +647,7 @@ static void cliOutputGenericHelp(void) {
         version
     );
     sdsfree(version);
+    __A_VARIABLE = 1;
 }
 
 /* Output all command help, filtering by group or command name. */
@@ -643,6 +697,7 @@ static void cliOutputHelp(int argc, char **argv) {
 
 /* Linenoise completion callback. */
 static void completionCallback(const char *buf, linenoiseCompletions *lc) {
+    volatile int __A_VARIABLE;
     size_t startpos = 0;
     int mask;
     int i;
@@ -668,11 +723,16 @@ static void completionCallback(const char *buf, linenoiseCompletions *lc) {
             sdsfree(tmp);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Linenoise hints callback. */
 static char *hintsCallback(const char *buf, int *color, int *bold) {
-    if (!pref.hints) return NULL;
+    volatile int __A_VARIABLE;
+    if (!pref.hints) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     int i, argc, buflen = strlen(buf);
     sds *argv = sdssplitargs(buf,&argc);
@@ -681,6 +741,7 @@ static char *hintsCallback(const char *buf, int *color, int *bold) {
     /* Check if the argument list is empty and return ASAP. */
     if (argc == 0) {
         sdsfreesplitres(argv,argc);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -711,15 +772,19 @@ static char *hintsCallback(const char *buf, int *color, int *bold) {
             }
 
             sdsfreesplitres(argv,argc);
+            __A_VARIABLE = 1;
             return hint;
         }
     }
     sdsfreesplitres(argv,argc);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static void freeHintsCallback(void *ptr) {
+    volatile int __A_VARIABLE;
     sdsfree(ptr);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -728,29 +793,41 @@ static void freeHintsCallback(void *ptr) {
 
 /* Send AUTH command to the server */
 static int cliAuth(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
-    if (config.auth == NULL) return REDIS_OK;
+    if (config.auth == NULL) {
+        __A_VARIABLE = 1;
+        return REDIS_OK;
+    }
 
     reply = redisCommand(context,"AUTH %s",config.auth);
     if (reply != NULL) {
         freeReplyObject(reply);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 /* Send SELECT dbnum to the server */
 static int cliSelect(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
-    if (config.dbnum == 0) return REDIS_OK;
+    if (config.dbnum == 0) {
+        __A_VARIABLE = 1;
+        return REDIS_OK;
+    }
 
     reply = redisCommand(context,"SELECT %d",config.dbnum);
     if (reply != NULL) {
         int result = REDIS_OK;
         if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;
         freeReplyObject(reply);
+        __A_VARIABLE = 1;
         return result;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -759,6 +836,7 @@ static int cliSelect(void) {
  *                a connected socket.
  *      CC_QUIET: Don't print errors if connection fails. */
 static int cliConnect(int flags) {
+    volatile int __A_VARIABLE;
     if (context == NULL || flags & CC_FORCE) {
         if (context != NULL) {
             redisFree(context);
@@ -782,6 +860,7 @@ static int cliConnect(int flags) {
             }
             redisFree(context);
             context = NULL;
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -792,20 +871,31 @@ static int cliConnect(int flags) {
         anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
 
         /* Do AUTH and select the right DB. */
-        if (cliAuth() != REDIS_OK)
+        if (cliAuth() != REDIS_OK) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
-        if (cliSelect() != REDIS_OK)
+        }
+        if (cliSelect() != REDIS_OK) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
+        }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static void cliPrintContextError(void) {
-    if (context == NULL) return;
+    volatile int __A_VARIABLE;
+    if (context == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     fprintf(stderr,"Error: %s\n",context->errstr);
+    __A_VARIABLE = 1;
 }
 
 static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
+    volatile int __A_VARIABLE;
     sds out = sdsempty();
     switch (r->type) {
     case REDIS_REPLY_ERROR:
@@ -869,18 +959,25 @@ static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
 int isColorTerm(void) {
+    volatile int __A_VARIABLE;
     char *t = getenv("TERM");
+    __A_VARIABLE = 1;
     return t != NULL && strstr(t,"xterm") != NULL;
 }
 
 /* Helper  function for sdsCatColorizedLdbReply() appending colorize strings
  * to an SDS string. */
 sds sdscatcolor(sds o, char *s, size_t len, char *color) {
-    if (!isColorTerm()) return sdscatlen(o,s,len);
+    volatile int __A_VARIABLE;
+    if (!isColorTerm()) {
+        __A_VARIABLE = 1;
+        return sdscatlen(o,s,len);
+    }
 
     int bold = strstr(color,"bold") != NULL;
     int ccode = 37; /* Defaults to white. */
@@ -895,12 +992,14 @@ sds sdscatcolor(sds o, char *s, size_t len, char *color) {
     o = sdscatfmt(o,"\033[%i;%i;49m",bold,ccode);
     o = sdscatlen(o,s,len);
     o = sdscat(o,"\033[0m");
+    __A_VARIABLE = 1;
     return o;
 }
 
 /* Colorize Lua debugger status replies according to the prefix they
  * have. */
 sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
+    volatile int __A_VARIABLE;
     char *color = "white";
 
     if (strstr(s,"<debug>")) color = "bold";
@@ -913,10 +1012,12 @@ sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
         if (s[1] == '>') color = "yellow"; /* Current line. */
         else if (s[2] == '#') color = "bold"; /* Break point. */
     }
+    __A_VARIABLE = 1;
     return sdscatcolor(o,s,len,color);
 }
 
 static sds cliFormatReplyRaw(redisReply *r) {
+    volatile int __A_VARIABLE;
     sds out = sdsempty(), tmp;
     size_t i;
 
@@ -964,10 +1065,12 @@ static sds cliFormatReplyRaw(redisReply *r) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
 static sds cliFormatReplyCSV(redisReply *r) {
+    volatile int __A_VARIABLE;
     unsigned int i;
 
     sds out = sdsempty();
@@ -1000,10 +1103,12 @@ static sds cliFormatReplyCSV(redisReply *r) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
 static int cliReadReply(int output_raw_strings) {
+    volatile int __A_VARIABLE;
     void *_reply;
     redisReply *reply;
     sds out = NULL;
@@ -1013,18 +1118,24 @@ static int cliReadReply(int output_raw_strings) {
         if (config.shutdown) {
             redisFree(context);
             context = NULL;
+            __A_VARIABLE = 1;
             return REDIS_OK;
         }
         if (config.interactive) {
             /* Filter cases where we should reconnect */
             if (context->err == REDIS_ERR_IO &&
-                (errno == ECONNRESET || errno == EPIPE))
+                (errno == ECONNRESET || errno == EPIPE)) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
-            if (context->err == REDIS_ERR_EOF)
+            }
+            if (context->err == REDIS_ERR_EOF) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         }
         cliPrintContextError();
         exit(1);
+        __A_VARIABLE = 1;
         return REDIS_ERR; /* avoid compiler warning */
     }
 
@@ -1080,6 +1191,7 @@ static int cliReadReply(int output_raw_strings) {
         sdsfree(out);
     }
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -1194,6 +1306,7 @@ static int cliSendCommand(int argc, char **argv, long repeat) {
 
 /* Send a command reconnecting the link if needed. */
 static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     redisReply *reply = NULL;
     int tries = 0;
     va_list ap;
@@ -1223,6 +1336,7 @@ static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ..
     }
 
     context = c;
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -1231,6 +1345,7 @@ static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ..
  *--------------------------------------------------------------------------- */
 
 static int parseOptions(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int i;
 
     for (i = 1; i < argc; i++) {
@@ -1435,10 +1550,12 @@ static int parseOptions(int argc, char **argv) {
               " line interface may not be safe.\n", stderr);
     }
 
+    __A_VARIABLE = 1;
     return i;
 }
 
 static void parseEnv() {
+    volatile int __A_VARIABLE;
     /* Set auth from env, but do not overwrite CLI arguments if passed */
     char *auth = getenv(REDIS_CLI_AUTH_ENV);
     if (auth != NULL && config.auth == NULL) {
@@ -1449,9 +1566,11 @@ static void parseEnv() {
     if (cluster_yes != NULL && !strcmp(cluster_yes, "1")) {
         config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
     }
+    __A_VARIABLE = 1;
 }
 
 static sds readArgFromStdin(void) {
+    volatile int __A_VARIABLE;
     char buf[1024];
     sds arg = sdsempty();
 
@@ -1465,10 +1584,12 @@ static sds readArgFromStdin(void) {
         }
         arg = sdscatlen(arg,buf,nread);
     }
+    __A_VARIABLE = 1;
     return arg;
 }
 
 static void usage(void) {
+    volatile int __A_VARIABLE;
     sds version = cliVersion();
     fprintf(stderr,
 "redis-cli %s\n"
@@ -1557,10 +1678,13 @@ static void usage(void) {
 "\n");
     sdsfree(version);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 static int confirmWithYes(char *msg) {
+    volatile int __A_VARIABLE;
     if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES) {
+        __A_VARIABLE = 1;
         return 1;
     }
     printf("%s (type 'yes' to accept): ", msg);
@@ -1568,21 +1692,25 @@ static int confirmWithYes(char *msg) {
     char buf[4];
     int nread = read(fileno(stdin),buf,4);
     buf[3] = '\0';
+    __A_VARIABLE = 1;
     return (nread != 0 && !strcmp("yes", buf));
 }
 
 /* Turn the plain C strings into Sds strings */
 static char **convertToSds(int count, char** args) {
+  volatile int __A_VARIABLE;
   int j;
   char **sds = zmalloc(sizeof(char*)*count);
 
   for(j = 0; j < count; j++)
     sds[j] = sdsnew(args[j]);
 
+  __A_VARIABLE = 1;
   return sds;
 }
 
 static int issueCommandRepeat(int argc, char **argv, long repeat) {
+    volatile int __A_VARIABLE;
     while (1) {
         config.cluster_reissue_command = 0;
         if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {
@@ -1592,6 +1720,7 @@ static int issueCommandRepeat(int argc, char **argv, long repeat) {
              * We'll try to reconnect the next time. */
             if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {
                 cliPrintContextError();
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
             }
          }
@@ -1602,10 +1731,13 @@ static int issueCommandRepeat(int argc, char **argv, long repeat) {
              break;
         }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int issueCommand(int argc, char **argv) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return issueCommandRepeat(argc, argv, config.repeat);
 }
 
@@ -1635,6 +1767,7 @@ static sds *cliSplitArgs(char *line, int *argc) {
  * ":command" is called, or when reading ~/.redisclirc file, in order to
  * set user preferences. */
 void cliSetPreferences(char **argv, int argc, int interactive) {
+    volatile int __A_VARIABLE;
     if (!strcasecmp(argv[0],":set") && argc >= 2) {
         if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
         else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
@@ -1648,12 +1781,17 @@ void cliSetPreferences(char **argv, int argc, int interactive) {
             interactive ? "" : ".redisclirc: ",
             argv[0]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Load the ~/.redisclirc file if any. */
 void cliLoadPreferences(void) {
+    volatile int __A_VARIABLE;
     sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
-    if (rcfile == NULL) return;
+    if (rcfile == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     FILE *fp = fopen(rcfile,"r");
     char buf[1024];
 
@@ -1669,6 +1807,7 @@ void cliLoadPreferences(void) {
         fclose(fp);
     }
     sdsfree(rcfile);
+    __A_VARIABLE = 1;
 }
 
 static void repl(void) {
@@ -1796,6 +1935,7 @@ static void repl(void) {
 }
 
 static int noninteractive(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int retval = 0;
     if (config.stdinarg) {
         argv = zrealloc(argv, (argc+1)*sizeof(char*));
@@ -1804,6 +1944,7 @@ static int noninteractive(int argc, char **argv) {
     } else {
         retval = issueCommand(argc, argv);
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1812,6 +1953,7 @@ static int noninteractive(int argc, char **argv) {
  *--------------------------------------------------------------------------- */
 
 static int evalMode(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     sds script = NULL;
     FILE *fp;
     char buf[1024];
@@ -1891,6 +2033,7 @@ static int evalMode(int argc, char **argv) {
             break; /* Return to the caller. */
         }
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -2044,15 +2187,18 @@ clusterManagerCommandDef clusterManagerCommands[] = {
 
 
 static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
+    volatile int __A_VARIABLE;
     clusterManagerCommand *cmd = &config.cluster_manager_command;
     cmd->name = cmdname;
     cmd->argc = argc;
     cmd->argv = argc ? argv : NULL;
     if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
+    __A_VARIABLE = 1;
 }
 
 
 static clusterManagerCommandProc *validateClusterManagerCommand(void) {
+    volatile int __A_VARIABLE;
     int i, commands_count = sizeof(clusterManagerCommands) /
                             sizeof(clusterManagerCommandDef);
     clusterManagerCommandProc *proc = NULL;
@@ -2065,12 +2211,14 @@ static clusterManagerCommandProc *validateClusterManagerCommand(void) {
                 (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
                 fprintf(stderr, "[ERR] Wrong number of arguments for "
                                 "specified --cluster sub command\n");
+                __A_VARIABLE = 1;
                 return NULL;
             }
             proc = cmddef.proc;
         }
     }
     if (!proc) fprintf(stderr, "Unknown --cluster subcommand\n");
+    __A_VARIABLE = 1;
     return proc;
 }
 
@@ -2107,6 +2255,7 @@ static int getClusterHostFromCmdArgs(int argc, char **argv,
 }
 
 static void freeClusterManagerNodeFlags(list *flags) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(flags, &li);
@@ -2115,9 +2264,11 @@ static void freeClusterManagerNodeFlags(list *flags) {
         sdsfree(flag);
     }
     listRelease(flags);
+    __A_VARIABLE = 1;
 }
 
 static void freeClusterManagerNode(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     if (node->context != NULL) redisFree(node->context);
     if (node->friends != NULL) {
         listIter li;
@@ -2148,9 +2299,11 @@ static void freeClusterManagerNode(clusterManagerNode *node) {
         node->flags_str = NULL;
     }
     zfree(node);
+    __A_VARIABLE = 1;
 }
 
 static void freeClusterManager(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     if (cluster_manager.nodes != NULL) {
@@ -2173,9 +2326,11 @@ static void freeClusterManager(void) {
     }
     if (clusterManagerUncoveredSlots != NULL)
         dictRelease(clusterManagerUncoveredSlots);
+    __A_VARIABLE = 1;
 }
 
 static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
+    volatile int __A_VARIABLE;
     clusterManagerNode *node = zmalloc(sizeof(*node));
     node->context = NULL;
     node->name = NULL;
@@ -2197,6 +2352,7 @@ static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
     node->weight = 1.0f;
     node->balance = 0;
     clusterManagerNodeResetSlots(node);
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -2207,6 +2363,7 @@ static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
 static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                                          redisReply *r, char **err)
 {
+    volatile int __A_VARIABLE;
     int is_err = 0;
     if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
         if (is_err) {
@@ -2215,16 +2372,20 @@ static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                 strcpy(*err, r->str);
             } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
         }
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Execute MULTI command on a cluster node. */
 static int clusterManagerStartTransaction(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "MULTI");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2232,6 +2393,7 @@ static int clusterManagerStartTransaction(clusterManagerNode *node) {
 static int clusterManagerExecTransaction(clusterManagerNode *node,
                                          clusterManagerOnReplyError onerror)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "EXEC");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (success) {
@@ -2255,10 +2417,12 @@ static int clusterManagerExecTransaction(clusterManagerNode *node,
     }
 cleanup:
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerNodeConnect(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     if (node->context) redisFree(node->context);
     node->context = redisConnect(node->ip, node->port);
     if (node->context->err) {
@@ -2267,6 +2431,7 @@ static int clusterManagerNodeConnect(clusterManagerNode *node) {
                 node->context->errstr);
         redisFree(node->context);
         node->context = NULL;
+        __A_VARIABLE = 1;
         return 0;
     }
     /* Set aggressive KEEP_ALIVE socket option in the Redis context socket
@@ -2278,13 +2443,18 @@ static int clusterManagerNodeConnect(clusterManagerNode *node) {
         redisReply *reply = redisCommand(node->context,"AUTH %s",config.auth);
         int ok = clusterManagerCheckRedisReply(node, reply, NULL);
         if (reply != NULL) freeReplyObject(reply);
-        if (!ok) return 0;
+        if (!ok) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 static void clusterManagerRemoveNodeFromList(list *nodelist,
                                              clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(nodelist, &li);
@@ -2294,11 +2464,16 @@ static void clusterManagerRemoveNodeFromList(list *nodelist,
             break;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the node with the specified name (ID) or NULL. */
 static clusterManagerNode *clusterManagerNodeByName(const char *name) {
-    if (cluster_manager.nodes == NULL) return NULL;
+    volatile int __A_VARIABLE;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     clusterManagerNode *found = NULL;
     sds lcname = sdsempty();
     lcname = sdscpy(lcname, name);
@@ -2314,6 +2489,7 @@ static clusterManagerNode *clusterManagerNodeByName(const char *name) {
         }
     }
     sdsfree(lcname);
+    __A_VARIABLE = 1;
     return found;
 }
 
@@ -2323,7 +2499,11 @@ static clusterManagerNode *clusterManagerNodeByName(const char *name) {
  */
 static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
 {
-    if (cluster_manager.nodes == NULL) return NULL;
+    volatile int __A_VARIABLE;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     clusterManagerNode *found = NULL;
     sds lcname = sdsempty();
     lcname = sdscpy(lcname, name);
@@ -2340,46 +2520,64 @@ static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
         }
     }
     sdsfree(lcname);
+    __A_VARIABLE = 1;
     return found;
 }
 
 static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     memset(node->slots, 0, sizeof(node->slots));
     node->slots_count = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Call "INFO" redis command on the specified node and return the reply. */
 static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
                                                   char **err)
 {
+    volatile int __A_VARIABLE;
     redisReply *info = CLUSTER_MANAGER_COMMAND(node, "INFO");
     if (err != NULL) *err = NULL;
-    if (info == NULL) return NULL;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (info->type == REDIS_REPLY_ERROR) {
         if (err != NULL) {
             *err = zmalloc((info->len + 1) * sizeof(char));
             strcpy(*err, info->str);
         }
         freeReplyObject(info);
+        __A_VARIABLE = 1;
         return  NULL;
     }
+    __A_VARIABLE = 1;
     return info;
 }
 
 static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
+    volatile int __A_VARIABLE;
     redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
-    if (info == NULL) return 0;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int is_cluster = (int) getLongInfoField(info->str, "cluster_enabled");
     freeReplyObject(info);
+    __A_VARIABLE = 1;
     return is_cluster;
 }
 
 /* Checks whether the node is empty. Node is considered not-empty if it has
  * some key or if it already knows other nodes */
 static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
+    volatile int __A_VARIABLE;
     redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
     int is_empty = 1;
-    if (info == NULL) return 0;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (strstr(info->str, "db0:") != NULL) {
         is_empty = 0;
         goto result;
@@ -2395,6 +2593,7 @@ static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
     is_empty = (known_nodes == 1);
 result:
     freeReplyObject(info);
+    __A_VARIABLE = 1;
     return is_empty;
 }
 
@@ -2430,6 +2629,7 @@ result:
 static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
     int ip_count, clusterManagerNode ***offending, int *offending_len)
 {
+    volatile int __A_VARIABLE;
     int score = 0, i, j;
     int node_len = cluster_manager.nodes->len;
     clusterManagerNode **offending_p = NULL;
@@ -2491,12 +2691,14 @@ static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
         dictReleaseIterator(iter);
         dictRelease(related);
     }
+    __A_VARIABLE = 1;
     return score;
 }
 
 static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
     int ip_count)
 {
+    volatile int __A_VARIABLE;
     clusterManagerNode **offenders = NULL;
     int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
                                                    NULL, NULL);
@@ -2570,12 +2772,17 @@ static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
     clusterManagerLog(log_level, "%s\n", msg);
 cleanup:
     zfree(offenders);
+    __A_VARIABLE = 1;
 }
 
 /* Return a representable string of the node's flags */
 static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     sds flags = sdsempty();
-    if (!node->flags_str) return flags;
+    if (!node->flags_str) {
+        __A_VARIABLE = 1;
+        return flags;
+    }
     int empty = 1;
     listIter li;
     listNode *ln;
@@ -2587,11 +2794,13 @@ static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
         flags = sdscatfmt(flags, "%S", flag);
         empty = 0;
     }
+    __A_VARIABLE = 1;
     return flags;
 }
 
 /* Return a representable string of the node's slots */
 static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     sds slots = sdsempty();
     int first_range_idx = -1, last_slot_idx = -1, i;
     for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
@@ -2617,6 +2826,7 @@ static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
         if (first_range_idx == last_slot_idx) slots = sdscat(slots, "]");
         else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
     }
+    __A_VARIABLE = 1;
     return slots;
 }
 
@@ -2631,28 +2841,37 @@ static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
  * { and } is hashed. This may be useful in the future to force certain
  * keys to be in the same node (assuming no resharding is in progress). */
 static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
+    volatile int __A_VARIABLE;
     int s, e; /* start-end indexes of { and } */
 
     for (s = 0; s < keylen; s++)
         if (key[s] == '{') break;
 
     /* No '{' ? Hash the whole key. This is the base case. */
-    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
+    if (s == keylen) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* '{' found? Check if we have the corresponding '}'. */
     for (e = s+1; e < keylen; e++)
         if (key[e] == '}') break;
 
     /* No '}' or nothing between {} ? Hash the whole key. */
-    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
+    if (e == keylen || e == s+1) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* If we are here there is both a { and a } on its right. Hash
      * what is in the middle between { and }. */
+    __A_VARIABLE = 1;
     return crc16(key+s+1,e-s-1) & 0x3FFF;
 }
 
 /* Return a string representation of the cluster node. */
 static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
+    volatile int __A_VARIABLE;
     sds info = sdsempty();
     sds spaces = sdsempty();
     int i;
@@ -2680,10 +2899,12 @@ static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
         info = sdscatfmt(info, "\n%s   %U additional replica(s)",
                          spaces, node->replicas_count);
     sdsfree(spaces);
+    __A_VARIABLE = 1;
     return info;
 }
 
 static void clusterManagerShowNodes(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(cluster_manager.nodes, &li);
@@ -2693,9 +2914,11 @@ static void clusterManagerShowNodes(void) {
         printf("%s\n", (char *) info);
         sdsfree(info);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerShowClusterInfo(void) {
+    volatile int __A_VARIABLE;
     int masters = 0;
     int keys = 0;
     listIter li;
@@ -2729,6 +2952,7 @@ static void clusterManagerShowClusterInfo(void) {
                     err = reply->str;
                 CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
                 if (reply != NULL) freeReplyObject(reply);
+                __A_VARIABLE = 1;
                 return;
             };
             if (reply != NULL) freeReplyObject(reply);
@@ -2742,11 +2966,13 @@ static void clusterManagerShowClusterInfo(void) {
     clusterManagerLogOk("[OK] %d keys in %d masters.\n", keys, masters);
     float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
     printf("%.2f keys per slot on average.\n", keys_per_slot);
+    __A_VARIABLE = 1;
 }
 
 /* Flush dirty slots configuration of the node by calling CLUSTER ADDSLOTS */
 static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = NULL;
     void *_reply = NULL;
     int success = 1;
@@ -2786,6 +3012,7 @@ cleanup:
         zfree(argv);
     }
     if (reply != NULL) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2793,12 +3020,16 @@ cleanup:
 static int clusterManagerSetSlot(clusterManagerNode *node1,
                                  clusterManagerNode *node2,
                                  int slot, const char *status, char **err) {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, "CLUSTER "
                                                 "SETSLOT %d %s %s",
                                                 slot, status,
                                                 (char *) node2->name);
     if (err != NULL) *err = NULL;
-    if (!reply) return 0;
+    if (!reply) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int success = 1;
     if (reply->type == REDIS_REPLY_ERROR) {
         success = 0;
@@ -2810,20 +3041,24 @@ static int clusterManagerSetSlot(clusterManagerNode *node1,
     }
 cleanup:
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
         "CLUSTER SETSLOT %d %s", slot, "STABLE");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
                                  int ignore_unassigned_err)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
         "CLUSTER DELSLOTS %d", slot);
     char *err = NULL;
@@ -2836,41 +3071,52 @@ static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
         zfree(err);
     }
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
         "CLUSTER ADDSLOTS %d", slot);
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
                                                 int slot)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
         "CLUSTER COUNTKEYSINSLOT %d", slot);
     int count = -1;
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return count;
 }
 
 static int clusterManagerBumpEpoch(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER BUMPEPOCH");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
+    volatile int __A_VARIABLE;
     if (bulk_idx == 0 && reply) {
-        if (reply->type == REDIS_REPLY_ERROR)
+        if (reply->type == REDIS_REPLY_ERROR) {
+            __A_VARIABLE = 1;
             return strstr(reply->str, "already unassigned") != NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -2878,8 +3124,12 @@ static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
                                       int slot,
                                       int do_clear)
 {
+    volatile int __A_VARIABLE;
     int success = clusterManagerStartTransaction(owner);
-    if (!success) return 0;
+    if (!success) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     /* Ensure the slot is not already assigned. */
     clusterManagerDelSlot(owner, slot, 1);
     /* Add the slot and bump epoch. */
@@ -2888,6 +3138,7 @@ static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
     clusterManagerBumpEpoch(owner);
     success = clusterManagerExecTransaction(owner,
         clusterManagerIgnoreUnassignedErr);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2900,6 +3151,7 @@ static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
                                                     int replace, int timeout,
                                                     char *dots)
 {
+    volatile int __A_VARIABLE;
     redisReply *migrate_reply = NULL;
     char **argv = NULL;
     size_t *argv_len = NULL;
@@ -2960,6 +3212,7 @@ static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
 cleanup:
     zfree(argv);
     zfree(argv_len);
+    __A_VARIABLE = 1;
     return migrate_reply;
 }
 
@@ -2970,6 +3223,7 @@ static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                            int pipeline, int verbose,
                                            char **err)
 {
+    volatile int __A_VARIABLE;
     int success = 1;
     int replace_existing_keys = (config.cluster_manager_command.flags &
             (CLUSTER_MANAGER_CMD_FLAG_FIX | CLUSTER_MANAGER_CMD_FLAG_REPLACE));
@@ -2980,7 +3234,10 @@ static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                         "GETKEYSINSLOT %d %d", slot,
                                         pipeline);
         success = (reply != NULL);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (reply->type == REDIS_REPLY_ERROR) {
             success = 0;
             if (err != NULL) {
@@ -3047,6 +3304,7 @@ next:
         if (dots) zfree(dots);
         if (!success) break;
     }
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -3063,6 +3321,7 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                                   clusterManagerNode *target,
                                   int slot, int opts,  char**err)
 {
+    volatile int __A_VARIABLE;
     if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
         printf("Moving slot %d from %s:%d to %s:%d: ", slot, source->ip,
                source->port, target->ip, target->port);
@@ -3077,15 +3336,24 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
     if (!option_cold) {
         success = clusterManagerSetSlot(target, source, slot,
                                         "importing", err);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         success = clusterManagerSetSlot(source, target, slot,
                                         "migrating", err);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
     success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
                                               pipeline, print_dots, err);
     if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) printf("\n");
-    if (!success) return 0;
+    if (!success) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     /* Set the new node as the owner of the slot in all the known nodes. */
     if (!option_cold) {
         listIter li;
@@ -3099,7 +3367,10 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                                                     slot, "node",
                                                     target->name);
             success = (r != NULL);
-            if (!success) return 0;
+            if (!success) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
             if (r->type == REDIS_REPLY_ERROR) {
                 success = 0;
                 if (err != NULL) {
@@ -3109,7 +3380,10 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                 }
             }
             freeReplyObject(r);
-            if (!success) return 0;
+            if (!success) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
         }
     }
     /* Update the node logical config */
@@ -3117,13 +3391,18 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
         source->slots[slot] = 0;
         target->slots[slot] = 1;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Flush the dirty node configuration by calling replicate for slaves or
  * adding the slots defined in the masters. */
 static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
-    if (!node->dirty) return 0;
+    volatile int __A_VARIABLE;
+    if (!node->dirty) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     redisReply *reply = NULL;
     int is_err = 0, success = 1;
     if (err != NULL) *err = NULL;
@@ -3149,11 +3428,13 @@ static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
     node->dirty = 0;
 cleanup:
     if (reply != NULL) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 /* Wait until the cluster configuration is consistent. */
 static void clusterManagerWaitForClusterJoin(void) {
+    volatile int __A_VARIABLE;
     printf("Waiting for the cluster to join\n");
     while(!clusterManagerIsConfigConsistent()) {
         printf(".");
@@ -3161,6 +3442,7 @@ static void clusterManagerWaitForClusterJoin(void) {
         sleep(1);
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* Load node's cluster configuration by calling "CLUSTER NODES" command.
@@ -3171,6 +3453,7 @@ static void clusterManagerWaitForClusterJoin(void) {
 static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
                                       char **err)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
     int success = 1;
     *err = NULL;
@@ -3341,6 +3624,7 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
     }
 cleanup:
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -3349,8 +3633,10 @@ cleanup:
  * Warning: if something goes wrong, it will free the starting node before
  * returning 0. */
 static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
+    volatile int __A_VARIABLE;
     if (node->context == NULL && !clusterManagerNodeConnect(node)) {
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
@@ -3359,6 +3645,7 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
         clusterManagerPrintNotClusterNodeError(node, e);
         if (e) zfree(e);
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     e = NULL;
@@ -3368,6 +3655,7 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
             zfree(e);
         }
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     listIter li;
@@ -3420,29 +3708,37 @@ invalid_friend:
             } else master->replicas_count++;
         }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Compare functions used by various sorting operations. */
 int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
+    volatile int __A_VARIABLE;
     const char **i1 = (const char **)slot1;
     const char **i2 = (const char **)slot2;
+    __A_VARIABLE = 1;
     return strcmp(*i1, *i2);
 }
 
 int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
+    volatile int __A_VARIABLE;
     clusterManagerNode *node1 = *((clusterManagerNode **) n1);
     clusterManagerNode *node2 = *((clusterManagerNode **) n2);
+    __A_VARIABLE = 1;
     return node2->slots_count - node1->slots_count;
 }
 
 int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
+    volatile int __A_VARIABLE;
     clusterManagerNode *node1 = *((clusterManagerNode **) n1);
     clusterManagerNode *node2 = *((clusterManagerNode **) n2);
+    __A_VARIABLE = 1;
     return node1->balance - node2->balance;
 }
 
 static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
+    volatile int __A_VARIABLE;
     sds signature = NULL;
     int node_count = 0, i = 0, name_len = 0;
     char **node_configs = NULL;
@@ -3532,14 +3828,22 @@ cleanup:
         for (i = 0; i < node_count; i++) zfree(node_configs[i]);
         zfree(node_configs);
     }
+    __A_VARIABLE = 1;
     return signature;
 }
 
 static int clusterManagerIsConfigConsistent(void) {
-    if (cluster_manager.nodes == NULL) return 0;
+    volatile int __A_VARIABLE;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int consistent = (listLength(cluster_manager.nodes) <= 1);
     // If the Cluster has only one node, it's always consistent
-    if (consistent) return 1;
+    if (consistent) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     sds first_cfg = NULL;
     listIter li;
     listNode *ln;
@@ -3559,22 +3863,29 @@ static int clusterManagerIsConfigConsistent(void) {
         }
     }
     if (first_cfg != NULL) sdsfree(first_cfg);
+    __A_VARIABLE = 1;
     return consistent;
 }
 
 /* Add the error string to cluster_manager.errors and print it. */
 static void clusterManagerOnError(sds err) {
+    volatile int __A_VARIABLE;
     if (cluster_manager.errors == NULL)
         cluster_manager.errors = listCreate();
     listAddNodeTail(cluster_manager.errors, err);
     clusterManagerLogErr("%s\n", (char *) err);
+    __A_VARIABLE = 1;
 }
 
 /* Check the slots coverage of the cluster. The 'all_slots' argument must be
  * and array of 16384 bytes. Every covered slot will be set to 1 in the
  * 'all_slots' array. The function returns the total number if covered slots.*/
 static int clusterManagerGetCoveredSlots(char *all_slots) {
-    if (cluster_manager.nodes == NULL) return 0;
+    volatile int __A_VARIABLE;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     listIter li;
     listNode *ln;
     listRewind(cluster_manager.nodes, &li);
@@ -3588,10 +3899,12 @@ static int clusterManagerGetCoveredSlots(char *all_slots) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return totslots;
 }
 
 static void clusterManagerPrintSlotsList(list *slots) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(slots, &li);
@@ -3603,6 +3916,7 @@ static void clusterManagerPrintSlotsList(list *slots) {
         printf("%s", slot);
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* Return the node, among 'nodes' with the greatest number of keys
@@ -3611,6 +3925,7 @@ static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
                                                                     int slot,
                                                                     char **err)
 {
+    volatile int __A_VARIABLE;
     clusterManagerNode *node = NULL;
     int numkeys = 0;
     listIter li;
@@ -3639,6 +3954,7 @@ static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
             break;
         }
     }
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -3647,6 +3963,7 @@ static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
  * number of replicas, one at random is returned. */
 
 static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
+    volatile int __A_VARIABLE;
     clusterManagerNode *node = NULL;
     int lowest_count = 0;
     listIter li;
@@ -3660,12 +3977,14 @@ static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
             lowest_count = n->replicas_count;
         }
     }
+    __A_VARIABLE = 1;
     return node;
 }
 
 /* This fucntion returns a random master node, return NULL if none */
 
 static clusterManagerNode *clusterManagerNodeMasterRandom() {
+    volatile int __A_VARIABLE;
     int master_count = 0;
     int idx;
     listIter li;
@@ -3684,14 +4003,17 @@ static clusterManagerNode *clusterManagerNodeMasterRandom() {
         clusterManagerNode *n = ln->value;
         if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
         if (!idx--) {
+            __A_VARIABLE = 1;
             return n;
         }
     }
     /* Can not be reached */
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static int clusterManagerFixSlotsCoverage(char *all_slots) {
+    volatile int __A_VARIABLE;
     int i, fixed = 0;
     list *none = NULL, *single = NULL, *multi = NULL;
     clusterManagerLogInfo(">>> Fixing slots coverage...\n");
@@ -3882,6 +4204,7 @@ cleanup:
     if (none) listRelease(none);
     if (single) listRelease(single);
     if (multi) listRelease(multi);
+    __A_VARIABLE = 1;
     return fixed;
 }
 
@@ -3889,6 +4212,7 @@ cleanup:
  * more nodes. This function fixes this condition by migrating keys where
  * it seems more sensible. */
 static int clusterManagerFixOpenSlot(int slot) {
+    volatile int __A_VARIABLE;
     clusterManagerLogInfo(">>> Fixing open slot %d\n", slot);
     /* Try to obtain the current slot owner, according to the current
      * nodes configuration. */
@@ -4195,10 +4519,12 @@ cleanup:
     listRelease(importing);
     sdsfree(migrating_str);
     sdsfree(importing_str);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
+    volatile int __A_VARIABLE;
     clusterManagerLogInfo(">>> Fixing multiple owners for slot %d...\n", slot);
     int success = 0;
     assert(listLength(owners) > 1);
@@ -4209,7 +4535,10 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
     clusterManagerLogInfo(">>> Setting slot %d owner: %s:%d\n",
                           slot, owner->ip, owner->port);
     /* Set the slot owner. */
-    if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
+    if (!clusterManagerSetSlotOwner(owner, slot, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     listIter li;
     listNode *ln;
     listRewind(cluster_manager.nodes, &li);
@@ -4224,7 +4553,10 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
         success = (count >= 0);
         if (!success) break;
         clusterManagerDelSlot(n, slot, 1);
-        if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) return 0;
+        if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (count > 0) {
             int opts = CLUSTER_MANAGER_OPT_VERBOSE |
                        CLUSTER_MANAGER_OPT_COLD;
@@ -4232,12 +4564,17 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
             if (!success) break;
         }
     }
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerCheckCluster(int quiet) {
+    volatile int __A_VARIABLE;
     listNode *ln = listFirst(cluster_manager.nodes);
-    if (!ln) return 0;
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerNode *node = ln->value;
     clusterManagerLogInfo(">>> Performing Cluster Check (using node %s:%d)\n",
                           node->ip, node->port);
@@ -4393,6 +4730,7 @@ static int clusterManagerCheckCluster(int quiet) {
             listRelease(owners);
         }
     }
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -4421,6 +4759,7 @@ static clusterManagerNode *clusterNodeForResharding(char *id,
 }
 
 static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
+    volatile int __A_VARIABLE;
     list *moved = listCreate();
     int src_count = listLength(sources), i = 0, tot_slots = 0, j;
     clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
@@ -4452,10 +4791,12 @@ static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
         }
     }
     zfree(sorted);
+    __A_VARIABLE = 1;
     return moved;
 }
 
 static void clusterManagerShowReshardTable(list *table) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     listRewind(table, &li);
@@ -4464,9 +4805,11 @@ static void clusterManagerShowReshardTable(list *table) {
         clusterManagerNode *n = item->source;
         printf("    Moving slot %d from %s\n", item->slot, (char *) n->name);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerReleaseReshardTable(list *table) {
+    volatile int __A_VARIABLE;
     if (table != NULL) {
         listIter li;
         listNode *ln;
@@ -4477,9 +4820,11 @@ static void clusterManagerReleaseReshardTable(list *table) {
         }
         listRelease(table);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerLog(int level, const char* fmt, ...) {
+    volatile int __A_VARIABLE;
     int use_colors =
         (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
     if (use_colors) {
@@ -4497,20 +4842,24 @@ static void clusterManagerLog(int level, const char* fmt, ...) {
     vprintf(fmt, ap);
     va_end(ap);
     if (use_colors) printf("\033[" LOG_COLOR_RESET);
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
                                         int alloc_len)
 {
+    volatile int __A_VARIABLE;
     array->nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
     array->alloc = array->nodes;
     array->len = alloc_len;
     array->count = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Reset array->nodes to the original array allocation and re-count non-NULL
  * nodes. */
 static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
+    volatile int __A_VARIABLE;
     if (array->nodes > array->alloc) {
         array->len = array->nodes - array->alloc;
         array->nodes = array->alloc;
@@ -4520,12 +4869,14 @@ static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
             if (array->nodes[i] != NULL) array->count++;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Shift array->nodes and store the shifted node into 'nodeptr'. */
 static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
                                          clusterManagerNode **nodeptr)
 {
+    volatile int __A_VARIABLE;
     assert(array->nodes < (array->nodes + array->len));
     /* If the first node to be shifted is not NULL, decrement count. */
     if (*array->nodes != NULL) array->count--;
@@ -4534,20 +4885,24 @@ static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
     /* Shift the nodes array and decrement length. */
     array->nodes++;
     array->len--;
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
                                        clusterManagerNode *node)
 {
+    volatile int __A_VARIABLE;
     assert(array->nodes < (array->nodes + array->len));
     assert(node != NULL);
     assert(array->count < array->len);
     array->nodes[array->count++] = node;
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
                                                  char *err)
 {
+    volatile int __A_VARIABLE;
     char *msg;
     if (err) msg = err;
     else {
@@ -4556,17 +4911,21 @@ static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
               "key in database 0.";
     }
     clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
                                                    char *err)
 {
+    volatile int __A_VARIABLE;
     char *msg = (err ? err : "is not configured as a cluster node.");
     clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
+    __A_VARIABLE = 1;
 }
 
 /* Execute redis-cli in Cluster Manager mode */
 static void clusterManagerMode(clusterManagerCommandProc *proc) {
+    volatile int __A_VARIABLE;
     int argc = config.cluster_manager_command.argc;
     char **argv = config.cluster_manager_command.argv;
     cluster_manager.nodes = NULL;
@@ -4578,11 +4937,13 @@ cluster_manager_err:
     sdsfree(config.hostip);
     sdsfree(config.mb_delim);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Cluster Manager Commands */
 
 static int clusterManagerCommandCreate(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int i, j, success = 1;
     cluster_manager.nodes = listCreate();
     for (i = 0; i < argc; i++) {
@@ -4592,6 +4953,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
         c = strrchr(addr, ':');
         if (c == NULL) {
             fprintf(stderr, "Invalid address format: %s\n", addr);
+            __A_VARIABLE = 1;
             return 0;
         }
         *c = '\0';
@@ -4600,6 +4962,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
         clusterManagerNode *node = clusterManagerNewNode(ip, port);
         if (!clusterManagerNodeConnect(node)) {
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         char *err = NULL;
@@ -4607,6 +4970,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             clusterManagerPrintNotClusterNodeError(node, err);
             if (err) zfree(err);
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         err = NULL;
@@ -4616,6 +4980,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
                 zfree(err);
             }
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         err = NULL;
@@ -4623,6 +4988,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             clusterManagerPrintNotEmptyNodeError(node, err);
             if (err) zfree(err);
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         listAddNodeTail(cluster_manager.nodes, node);
@@ -4638,6 +5004,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             node_len, replicas);
         clusterManagerLogErr("\n*** At least %d nodes are required.\n",
                              3 * (replicas + 1));
+        __A_VARIABLE = 1;
         return 0;
     }
     clusterManagerLogInfo(">>> Performing hash slots allocation "
@@ -4854,6 +5221,7 @@ cleanup:
         CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
     }
     zfree(ip_nodes);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -4955,6 +5323,7 @@ invalid_args:
 }
 
 static int clusterManagerCommandDeleteNode(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     int success = 1;
     int port = 0;
@@ -4967,17 +5336,22 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
     clusterManagerNode *node = NULL;
 
     // Load cluster information
-    if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(ref_node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     // Check if the node exists and is not empty
     node = clusterManagerNodeByName(node_id);
     if (node == NULL) {
         clusterManagerLogErr("[ERR] No such node ID %s\n", node_id);
+        __A_VARIABLE = 1;
         return 0;
     }
     if (node->slots_count != 0) {
         clusterManagerLogErr("[ERR] Node %s:%d is not empty! Reshard data "
                              "away and try again.\n", node->ip, node->port);
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -5000,13 +5374,19 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
                                                     master->name);
             success = clusterManagerCheckRedisReply(n, r, NULL);
             if (r) freeReplyObject(r);
-            if (!success) return 0;
+            if (!success) {
+            	__A_VARIABLE = 1;
+            	return 0;
+            }
         }
         redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER FORGET %s",
                                                 node_id);
         success = clusterManagerCheckRedisReply(n, r, NULL);
         if (r) freeReplyObject(r);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
 
     // Finally shutdown the node
@@ -5014,54 +5394,75 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
     redisReply *r = redisCommand(node->context, "SHUTDOWN");
     success = clusterManagerCheckRedisReply(node, r, NULL);
     if (r) freeReplyObject(r);
+    __A_VARIABLE = 1;
     return success;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandInfo(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int port = 0;
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerShowClusterInfo();
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandCheck(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int port = 0;
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerShowClusterInfo();
+    __A_VARIABLE = 1;
     return clusterManagerCheckCluster(0);
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandFix(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
+    __A_VARIABLE = 1;
     return clusterManagerCommandCheck(argc, argv);
 }
 
 static int clusterManagerCommandReshard(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int port = 0;
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerCheckCluster(0);
     if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
         fflush(stdout);
         fprintf(stderr,
                 "*** Please fix your cluster problems before resharding\n");
+        __A_VARIABLE = 1;
         return 0;
     }
     int slots = config.cluster_manager_command.slots;
@@ -5100,7 +5501,10 @@ static int clusterManagerCommandReshard(int argc, char **argv) {
     }
     int raise_err = 0;
     clusterManagerNode *target = clusterNodeForResharding(to, NULL, &raise_err);
-    if (target == NULL) return 0;
+    if (target == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     list *sources = listCreate();
     list *table = NULL;
     int all = 0, result = 1;
@@ -5232,20 +5636,26 @@ static int clusterManagerCommandReshard(int argc, char **argv) {
 cleanup:
     listRelease(sources);
     clusterManagerReleaseReshardTable(table);
+    __A_VARIABLE = 1;
     return result;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandRebalance(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int port = 0;
     char *ip = NULL;
     clusterManagerNode **weightedNodes = NULL;
     list *involved = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int result = 1, i;
     if (config.cluster_manager_command.weight != NULL) {
         for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
@@ -5421,13 +5831,16 @@ end_move:
 cleanup:
     if (involved != NULL) listRelease(involved);
     if (weightedNodes != NULL) zfree(weightedNodes);
+    __A_VARIABLE = 1;
     return result;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandSetTimeout(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     int port = 0;
     char *ip = NULL;
@@ -5436,11 +5849,15 @@ static int clusterManagerCommandSetTimeout(int argc, char **argv) {
     if (timeout < 100) {
         fprintf(stderr, "Setting a node timeout of less than 100 "
                 "milliseconds is a bad idea.\n");
+        __A_VARIABLE = 1;
         return 0;
     }
     // Load cluster information
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int ok_count = 0, err_count = 0;
 
     clusterManagerLogInfo(">>> Reconfiguring node timeout in every "
@@ -5479,13 +5896,16 @@ reply_err:;
     }
     clusterManagerLogInfo(">>> New node timeout set. %d OK, %d ERR.\n",
                           ok_count, err_count);
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandImport(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int success = 1;
     int port = 0, src_port = 0;
     char *ip = NULL, *src_ip = NULL;
@@ -5509,8 +5929,14 @@ static int clusterManagerCommandImport(int argc, char **argv) {
                           src_ip, src_port, ip, port);
 
     clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
-    if (!clusterManagerCheckCluster(0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(refnode, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (!clusterManagerCheckCluster(0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     char *reply_err = NULL;
     redisReply *src_reply = NULL;
     // Connect to the source node.
@@ -5618,18 +6044,24 @@ cleanup:
                              src_ip, src_port, reply_err);
     if (src_ctx) redisFree(src_ctx);
     if (src_reply) freeReplyObject(src_reply);
+    __A_VARIABLE = 1;
     return success;
 invalid_args:
     fprintf(stderr, "%s", invalid_args_msg);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandCall(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int port = 0, i;
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(refnode, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     argc--;
     argv++;
     size_t *argvlen = zmalloc(argc*sizeof(size_t));
@@ -5658,13 +6090,16 @@ static int clusterManagerCommandCall(int argc, char **argv) {
         if (reply != NULL) freeReplyObject(reply);
     }
     zfree(argvlen);
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandHelp(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     UNUSED(argv);
     int commands_count = sizeof(clusterManagerCommands) /
@@ -5701,6 +6136,7 @@ static int clusterManagerCommandHelp(int argc, char **argv) {
     fprintf(stderr, "\nFor check, fix, reshard, del-node, set-timeout you "
                     "can specify the host and port of any working node in "
                     "the cluster.\n\n");
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5709,6 +6145,7 @@ static int clusterManagerCommandHelp(int argc, char **argv) {
  *--------------------------------------------------------------------------- */
 
 static void latencyModePrint(long long min, long long max, double avg, long long count) {
+    volatile int __A_VARIABLE;
     if (config.output == OUTPUT_STANDARD) {
         printf("min: %lld, max: %lld, avg: %.2f (%lld samples)",
                 min, max, avg, count);
@@ -5718,11 +6155,13 @@ static void latencyModePrint(long long min, long long max, double avg, long long
     } else if (config.output == OUTPUT_RAW) {
         printf("%lld %lld %.2f %lld\n", min, max, avg, count);
     }
+    __A_VARIABLE = 1;
 }
 
 #define LATENCY_SAMPLE_RATE 10 /* milliseconds. */
 #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 /* milliseconds. */
 static void latencyMode(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     long long start, latency, min = 0, max = 0, tot = 0, count = 0;
     long long history_interval =
@@ -5780,6 +6219,7 @@ static void latencyMode(void) {
         }
         usleep(LATENCY_SAMPLE_RATE * 1000);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -5807,6 +6247,7 @@ struct distsamples {
  *
  * As a side effect the function sets all the buckets count to 0. */
 void showLatencyDistSamples(struct distsamples *samples, long long tot) {
+    volatile int __A_VARIABLE;
     int j;
 
      /* We convert samples into a index inside the palette
@@ -5825,11 +6266,13 @@ void showLatencyDistSamples(struct distsamples *samples, long long tot) {
     }
     printf("\033[0m\n");
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Show the legend: different buckets values and colors meaning, so
  * that the spectrum is more easily readable. */
 void showLatencyDistLegend(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     printf("---------------------------------------------\n");
@@ -5844,9 +6287,11 @@ void showLatencyDistLegend(void) {
     }
     printf("\033[0m\n");
     printf("---------------------------------------------\n");
+    __A_VARIABLE = 1;
 }
 
 static void latencyDistMode(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     long long start, latency, count = 0;
     long long history_interval =
@@ -5922,6 +6367,7 @@ static void latencyDistMode(void) {
         }
         usleep(LATENCY_SAMPLE_RATE * 1000);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -5931,6 +6377,7 @@ static void latencyDistMode(void) {
 /* Sends SYNC and reads the number of bytes in the payload. Used both by
  * slaveMode() and getRDB(). */
 unsigned long long sendSync(int fd) {
+    volatile int __A_VARIABLE;
     /* To start we need to send the SYNC command and return the payload.
      * The hiredis client lib does not understand this part of the protocol
      * and we don't want to mess with its buffers, so everything is performed
@@ -5960,10 +6407,12 @@ unsigned long long sendSync(int fd) {
         printf("SYNC with master failed: %s\n", buf);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return strtoull(buf+1,NULL,10);
 }
 
 static void slaveMode(void) {
+    volatile int __A_VARIABLE;
     int fd = context->fd;
     unsigned long long payload = sendSync(fd);
     char buf[1024];
@@ -5989,6 +6438,7 @@ static void slaveMode(void) {
     config.output = OUTPUT_CSV;
     while (cliReadReply(0) == REDIS_OK);
     config.output = original_output;
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -5998,6 +6448,7 @@ static void slaveMode(void) {
 /* This function implements --rdb, so it uses the replication protocol in order
  * to fetch the RDB file from a remote server. */
 static void getRDB(void) {
+    volatile int __A_VARIABLE;
     int s = context->fd;
     int fd;
     unsigned long long payload = sendSync(s);
@@ -6039,6 +6490,7 @@ static void getRDB(void) {
     close(fd);
     fprintf(stderr,"Transfer finished with success.\n");
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6047,6 +6499,7 @@ static void getRDB(void) {
 
 #define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
 static void pipeMode(void) {
+    volatile int __A_VARIABLE;
     int fd = context->fd;
     long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
     char ibuf[1024*16], obuf[1024*16]; /* Input and output buffers */
@@ -6206,6 +6659,7 @@ static void pipeMode(void) {
         exit(1);
     else
         exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6213,6 +6667,7 @@ static void pipeMode(void) {
  *--------------------------------------------------------------------------- */
 
 static redisReply *sendScan(unsigned long long *it) {
+    volatile int __A_VARIABLE;
     redisReply *reply = redisCommand(context, "SCAN %llu", *it);
 
     /* Handle any error conditions */
@@ -6237,10 +6692,12 @@ static redisReply *sendScan(unsigned long long *it) {
     /* Update iterator */
     *it = strtoull(reply->element[0]->str, NULL, 10);
 
+    __A_VARIABLE = 1;
     return reply;
 }
 
 static int getDbSize(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     int size;
 
@@ -6255,6 +6712,7 @@ static int getDbSize(void) {
     size = reply->integer;
     freeReplyObject(reply);
 
+    __A_VARIABLE = 1;
     return size;
 }
 
@@ -6277,20 +6735,24 @@ typeinfo type_stream = { "stream", "XLEN", "entries" };
 typeinfo type_other = { "other", NULL, "?" };
 
 static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
+    volatile int __A_VARIABLE;
     typeinfo *info = zmalloc(sizeof(typeinfo));
     *info = *type_template;
     info->name = sdsnew(name);
     dictAdd(types, info->name, info);
+    __A_VARIABLE = 1;
     return info;
 }
 
 void type_free(void* priv_data, void* val) {
+    volatile int __A_VARIABLE;
     typeinfo *info = val;
     UNUSED(priv_data);
     if (info->biggest_key)
         sdsfree(info->biggest_key);
     sdsfree(info->name);
     zfree(info);
+    __A_VARIABLE = 1;
 }
 
 static dictType typeinfoDictType = {
@@ -6303,6 +6765,7 @@ static dictType typeinfoDictType = {
 };
 
 static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     unsigned int i;
 
@@ -6339,12 +6802,14 @@ static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
         types[i] = type;
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 static void getKeySizes(redisReply *keys, typeinfo **types,
                         unsigned long long *sizes, int memkeys,
                         unsigned memkeys_samples)
 {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     unsigned int i;
 
@@ -6392,9 +6857,11 @@ static void getKeySizes(redisReply *keys, typeinfo **types,
 
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 static void findBigKeys(int memkeys, unsigned memkeys_samples) {
+    volatile int __A_VARIABLE;
     unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;
     redisReply *reply, *keys;
     unsigned int arrsize=0, i;
@@ -6527,9 +6994,11 @@ static void findBigKeys(int memkeys, unsigned memkeys_samples) {
 
     /* Success! */
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     unsigned int i;
 
@@ -6557,10 +7026,12 @@ static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
         }
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 #define HOTKEYS_SAMPLE 16
 static void findHotKeys(void) {
+    volatile int __A_VARIABLE;
     redisReply *keys, *reply;
     unsigned long long counters[HOTKEYS_SAMPLE] = {0};
     sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
@@ -6650,6 +7121,7 @@ static void findHotKeys(void) {
     }
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6660,11 +7132,15 @@ static void findHotKeys(void) {
  * A new buffer is allocated for the result, that needs to be free'd.
  * If the field is not found NULL is returned. */
 static char *getInfoField(char *info, char *field) {
+    volatile int __A_VARIABLE;
     char *p = strstr(info,field);
     char *n1, *n2;
     char *result;
 
-    if (!p) return NULL;
+    if (!p) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     p += strlen(field)+1;
     n1 = strchr(p,'\r');
     n2 = strchr(p,',');
@@ -6672,18 +7148,24 @@ static char *getInfoField(char *info, char *field) {
     result = zmalloc(sizeof(char)*(n1-p)+1);
     memcpy(result,p,(n1-p));
     result[n1-p] = '\0';
+    __A_VARIABLE = 1;
     return result;
 }
 
 /* Like the above function but automatically convert the result into
  * a long. On error (missing field) LONG_MIN is returned. */
 static long getLongInfoField(char *info, char *field) {
+    volatile int __A_VARIABLE;
     char *value = getInfoField(info,field);
     long l;
 
-    if (!value) return LONG_MIN;
+    if (!value) {
+        __A_VARIABLE = 1;
+        return LONG_MIN;
+    }
     l = strtol(value,NULL,10);
     zfree(value);
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -6714,6 +7196,7 @@ static void bytesToHuman(char *s, long long n) {
 }
 
 static void statMode(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     long aux, requests = 0;
     int i = 0;
@@ -6797,6 +7280,7 @@ static void statMode(void) {
         freeReplyObject(reply);
         usleep(config.interval);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6804,6 +7288,7 @@ static void statMode(void) {
  *--------------------------------------------------------------------------- */
 
 static void scanMode(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     unsigned long long cur = 0;
 
@@ -6830,6 +7315,7 @@ static void scanMode(void) {
     } while(cur != 0);
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6843,6 +7329,7 @@ static void scanMode(void) {
  * With alpha = 6.2 the output follows the 80-20 rule where 20% of
  * the returned numbers will account for 80% of the frequency. */
 long long powerLawRand(long long min, long long max, double alpha) {
+    volatile int __A_VARIABLE;
     double pl, r;
 
     max += 1;
@@ -6850,19 +7337,23 @@ long long powerLawRand(long long min, long long max, double alpha) {
     pl = pow(
         ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
         (1.0/(alpha+1)));
+    __A_VARIABLE = 1;
     return (max-1-(long long)pl)+min;
 }
 
 /* Generates a key name among a set of lru_test_sample_size keys, using
  * an 80-20 distribution. */
 void LRUTestGenKey(char *buf, size_t buflen) {
+    volatile int __A_VARIABLE;
     snprintf(buf, buflen, "lru:%lld",
         powerLawRand(1, config.lru_test_sample_size, 6.2));
+    __A_VARIABLE = 1;
 }
 
 #define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */
 #define LRU_CYCLE_PIPELINE_SIZE 250
 static void LRUTestMode(void) {
+    volatile int __A_VARIABLE;
     redisReply *reply;
     char key[128];
     long long start_cycle;
@@ -6921,6 +7412,7 @@ static void LRUTestMode(void) {
             misses, (double)misses/(hits+misses)*100);
     }
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6935,6 +7427,7 @@ static void LRUTestMode(void) {
  * Should run in less than 100-200 microseconds even using very
  * slow hardware. Runs in less than 10 microseconds in modern HW. */
 unsigned long compute_something_fast(void) {
+    volatile int __A_VARIABLE;
     unsigned char s[256], i, j, t;
     int count = 1000, k;
     unsigned long output = 0;
@@ -6951,15 +7444,19 @@ unsigned long compute_something_fast(void) {
         s[j] = t;
         output += s[(s[i]+s[j])&255];
     }
+    __A_VARIABLE = 1;
     return output;
 }
 
 static void intrinsicLatencyModeStop(int s) {
+    volatile int __A_VARIABLE;
     UNUSED(s);
     force_cancel_loop = 1;
+    __A_VARIABLE = 1;
 }
 
 static void intrinsicLatencyMode(void) {
+    volatile int __A_VARIABLE;
     long long test_end, run_time, max_latency = 0, runs = 0;
 
     run_time = config.intrinsic_latency_duration*1000000;
@@ -6994,6 +7491,7 @@ static void intrinsicLatencyMode(void) {
             exit(0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
diff --git a/src/release.c b/src/release.c
index 4e59c74..2adfcc9 100644
--- a/src/release.c
+++ b/src/release.c
@@ -38,10 +38,14 @@
 #include "crc64.h"
 
 char *redisGitSHA1(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return REDIS_GIT_SHA1;
 }
 
 char *redisGitDirty(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return REDIS_GIT_DIRTY;
 }
 
diff --git a/src/replication.c b/src/replication.c
index f8951ad..22c87cd 100644
--- a/src/replication.c
+++ b/src/replication.c
@@ -51,6 +51,7 @@ int cancelReplicationHandshake(void);
  * IP address and its listening port which is more clear for the user, for
  * example: "Closing connection with replica 10.1.2.3:6380". */
 char *replicationGetSlaveName(client *c) {
+    volatile int __A_VARIABLE;
     static char buf[NET_PEER_ID_LEN];
     char ip[NET_IP_STR_LEN];
 
@@ -70,12 +71,14 @@ char *replicationGetSlaveName(client *c) {
         snprintf(buf,sizeof(buf),"client id #%llu",
             (unsigned long long) c->id);
     }
+    __A_VARIABLE = 1;
     return buf;
 }
 
 /* ---------------------------------- MASTER -------------------------------- */
 
 void createReplicationBacklog(void) {
+    volatile int __A_VARIABLE;
     serverAssert(server.repl_backlog == NULL);
     server.repl_backlog = zmalloc(server.repl_backlog_size);
     server.repl_backlog_histlen = 0;
@@ -85,6 +88,7 @@ void createReplicationBacklog(void) {
      * byte we have is the next byte that will be generated for the
      * replication stream. */
     server.repl_backlog_off = server.master_repl_offset+1;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the user modifies the replication backlog
@@ -94,9 +98,13 @@ void createReplicationBacklog(void) {
  * the most recent bytes, or the same data and more free space in case the
  * buffer is enlarged). */
 void resizeReplicationBacklog(long long newsize) {
+    volatile int __A_VARIABLE;
     if (newsize < CONFIG_REPL_BACKLOG_MIN_SIZE)
         newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
-    if (server.repl_backlog_size == newsize) return;
+    if (server.repl_backlog_size == newsize) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     server.repl_backlog_size = newsize;
     if (server.repl_backlog != NULL) {
@@ -112,12 +120,15 @@ void resizeReplicationBacklog(long long newsize) {
         /* Next byte we have is... the next since the buffer is empty. */
         server.repl_backlog_off = server.master_repl_offset+1;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeReplicationBacklog(void) {
+    volatile int __A_VARIABLE;
     serverAssert(listLength(server.slaves) == 0);
     zfree(server.repl_backlog);
     server.repl_backlog = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Add data to the replication backlog.
@@ -125,6 +136,7 @@ void freeReplicationBacklog(void) {
  * server.master_repl_offset, because there is no case where we want to feed
  * the backlog without incrementing the offset. */
 void feedReplicationBacklog(void *ptr, size_t len) {
+    volatile int __A_VARIABLE;
     unsigned char *p = ptr;
 
     server.master_repl_offset += len;
@@ -147,11 +159,13 @@ void feedReplicationBacklog(void *ptr, size_t len) {
     /* Set the offset of the first byte we have in the backlog. */
     server.repl_backlog_off = server.master_repl_offset -
                               server.repl_backlog_histlen + 1;
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for feedReplicationBacklog() that takes Redis string objects
  * as input. */
 void feedReplicationBacklogWithObject(robj *o) {
+    volatile int __A_VARIABLE;
     char llstr[LONG_STR_SIZE];
     void *p;
     size_t len;
@@ -164,6 +178,7 @@ void feedReplicationBacklogWithObject(robj *o) {
         p = o->ptr;
     }
     feedReplicationBacklog(p,len);
+    __A_VARIABLE = 1;
 }
 
 /* Propagate write commands to slaves, and populate the replication backlog
@@ -172,6 +187,7 @@ void feedReplicationBacklogWithObject(robj *o) {
  * stream. Instead if the instance is a slave and has sub-slaves attached,
  * we use replicationFeedSlavesFromMaster() */
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     int j, len;
@@ -182,11 +198,17 @@ void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
      * propagate *identical* replication stream. In this way this slave can
      * advertise the same replication ID as the master (since it shares the
      * master replication history and has the same backlog and offsets). */
-    if (server.masterhost != NULL) return;
+    if (server.masterhost != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If there aren't slaves, and there is no backlog buffer to populate,
      * we can return ASAP. */
-    if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
+    if (server.repl_backlog == NULL && listLength(slaves) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* We can't have slaves attached and no backlog. */
     serverAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
@@ -271,12 +293,14 @@ void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
         for (j = 0; j < argc; j++)
             addReplyBulk(slave,argv[j]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is used in order to proxy what we receive from our master
  * to our sub-slaves. */
 #include <ctype.h>
 void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
 
@@ -299,9 +323,11 @@ void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t bufle
         if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
         addReplyString(slave,buf,buflen);
     }
+    __A_VARIABLE = 1;
 }
 
 void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     int j;
@@ -338,17 +364,20 @@ void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv,
         addReply(monitor,cmdobj);
     }
     decrRefCount(cmdobj);
+    __A_VARIABLE = 1;
 }
 
 /* Feed the slave 'c' with the replication backlog starting from the
  * specified 'offset' up to the end of the backlog. */
 long long addReplyReplicationBacklog(client *c, long long offset) {
+    volatile int __A_VARIABLE;
     long long j, skip, len;
 
     serverLog(LL_DEBUG, "[PSYNC] Replica request offset: %lld", offset);
 
     if (server.repl_backlog_histlen == 0) {
         serverLog(LL_DEBUG, "[PSYNC] Backlog history len is zero");
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -389,6 +418,7 @@ long long addReplyReplicationBacklog(client *c, long long offset) {
         len -= thislen;
         j = 0;
     }
+    __A_VARIABLE = 1;
     return server.repl_backlog_histlen - skip;
 }
 
@@ -397,6 +427,8 @@ long long addReplyReplicationBacklog(client *c, long long offset) {
  * the BGSAVE process started and before executing any other command
  * from clients. */
 long long getPsyncInitialOffset(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return server.master_repl_offset;
 }
 
@@ -417,6 +449,7 @@ long long getPsyncInitialOffset(void) {
  * BGSAVE for replication was started, or when there is one already in
  * progress that we attached our slave to. */
 int replicationSetupSlaveForFullResync(client *slave, long long offset) {
+    volatile int __A_VARIABLE;
     char buf[128];
     int buflen;
 
@@ -434,9 +467,11 @@ int replicationSetupSlaveForFullResync(client *slave, long long offset) {
                           server.replid,offset);
         if (write(slave->fd,buf,buflen) != buflen) {
             freeClientAsync(slave);
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -446,6 +481,7 @@ int replicationSetupSlaveForFullResync(client *slave, long long offset) {
  * On success return C_OK, otherwise C_ERR is returned and we proceed
  * with the usual full resync. */
 int masterTryPartialResynchronization(client *c) {
+    volatile int __A_VARIABLE;
     long long psync_offset, psync_len;
     char *master_replid = c->argv[1]->ptr;
     char buf[128];
@@ -521,6 +557,7 @@ int masterTryPartialResynchronization(client *c) {
     }
     if (write(c->fd,buf,buflen) != buflen) {
         freeClientAsync(c);
+        __A_VARIABLE = 1;
         return C_OK;
     }
     psync_len = addReplyReplicationBacklog(c,psync_offset);
@@ -533,6 +570,7 @@ int masterTryPartialResynchronization(client *c) {
      * has this state from the previous connection with the master. */
 
     refreshGoodSlavesCount();
+    __A_VARIABLE = 1;
     return C_OK; /* The caller can return, no full resync needed. */
 
 need_full_resync:
@@ -540,6 +578,7 @@ need_full_resync:
      * reply to PSYNC right now if a full SYNC is needed. The reply
      * must include the master offset at the time the RDB file we transfer
      * is generated, so we need to delay the reply to that moment. */
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -562,6 +601,7 @@ need_full_resync:
  *
  * Returns C_OK on success or C_ERR otherwise. */
 int startBgsaveForReplication(int mincapa) {
+    volatile int __A_VARIABLE;
     int retval;
     int socket_target = server.repl_diskless_sync && (mincapa & SLAVE_CAPA_EOF);
     listIter li;
@@ -602,6 +642,7 @@ int startBgsaveForReplication(int mincapa) {
                 slave->flags |= CLIENT_CLOSE_AFTER_REPLY;
             }
         }
+        __A_VARIABLE = 1;
         return retval;
     }
 
@@ -622,6 +663,7 @@ int startBgsaveForReplication(int mincapa) {
     /* Flush the script cache, since we need that slave differences are
      * accumulated without requiring slaves to match our cached scripts. */
     if (retval == C_OK) replicationScriptCacheFlush();
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -859,6 +901,7 @@ void replconfCommand(client *c) {
  *    sending it to the replica.
  * 3) Update the count of "good replicas". */
 void putSlaveOnline(client *slave) {
+    volatile int __A_VARIABLE;
     slave->replstate = SLAVE_STATE_ONLINE;
     slave->repl_put_online_on_ack = 0;
     slave->repl_ack_time = server.unixtime; /* Prevent false timeout. */
@@ -866,11 +909,13 @@ void putSlaveOnline(client *slave) {
         sendReplyToClient, slave) == AE_ERR) {
         serverLog(LL_WARNING,"Unable to register writable event for replica bulk transfer: %s", strerror(errno));
         freeClient(slave);
+        __A_VARIABLE = 1;
         return;
     }
     refreshGoodSlavesCount();
     serverLog(LL_NOTICE,"Synchronization with replica %s succeeded",
         replicationGetSlaveName(slave));
+    __A_VARIABLE = 1;
 }
 
 void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -944,6 +989,7 @@ void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
  * The 'type' argument is the type of the child that terminated
  * (if it had a disk or socket target). */
 void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     int startbgsave = 0;
     int mincapa = -1;
@@ -1024,6 +1070,7 @@ void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
         }
     }
     if (startbgsave) startBgsaveForReplication(mincapa);
+    __A_VARIABLE = 1;
 }
 
 /* Change the current instance replication ID with a new, random one.
@@ -1031,17 +1078,21 @@ void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
  * slaves, so the command should be called when something happens that
  * alters the current story of the dataset. */
 void changeReplicationId(void) {
+    volatile int __A_VARIABLE;
     getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
     server.replid[CONFIG_RUN_ID_SIZE] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Clear (invalidate) the secondary replication ID. This happens, for
  * example, after a full resynchronization, when we start a new replication
  * history. */
 void clearReplicationId2(void) {
+    volatile int __A_VARIABLE;
     memset(server.replid2,'0',sizeof(server.replid));
     server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
     server.second_replid_offset = -1;
+    __A_VARIABLE = 1;
 }
 
 /* Use the current replication ID / offset as secondary replication
@@ -1050,6 +1101,7 @@ void clearReplicationId2(void) {
  * so that it can serve PSYNC requests performed using the master
  * replication ID. */
 void shiftReplicationId(void) {
+    volatile int __A_VARIABLE;
     memcpy(server.replid2,server.replid,sizeof(server.replid));
     /* We set the second replid offset to the master offset + 1, since
      * the slave will ask for the first byte it has not yet received, so
@@ -1061,6 +1113,7 @@ void shiftReplicationId(void) {
     server.second_replid_offset = server.master_repl_offset+1;
     changeReplicationId();
     serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------- SLAVE -------------------------------- */
@@ -1068,6 +1121,8 @@ void shiftReplicationId(void) {
 /* Returns 1 if the given replication state is a handshake state,
  * 0 otherwise. */
 int slaveIsInHandshakeState(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return server.repl_state >= REPL_STATE_RECEIVE_PONG &&
            server.repl_state <= REPL_STATE_RECEIVE_PSYNC;
 }
@@ -1081,6 +1136,7 @@ int slaveIsInHandshakeState(void) {
  * data with emptyDb(), and while we load the new data received as an
  * RDB file from the master. */
 void replicationSendNewlineToMaster(void) {
+    volatile int __A_VARIABLE;
     static time_t newline_sent;
     if (time(NULL) != newline_sent) {
         newline_sent = time(NULL);
@@ -1088,19 +1144,23 @@ void replicationSendNewlineToMaster(void) {
             /* Pinging back in this stage is best-effort. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Callback used by emptyDb() while flushing away old data to load
  * the new dataset received by the master. */
 void replicationEmptyDbCallback(void *privdata) {
+    volatile int __A_VARIABLE;
     UNUSED(privdata);
     replicationSendNewlineToMaster();
+    __A_VARIABLE = 1;
 }
 
 /* Once we have a link with the master and the synchroniziation was
  * performed, this function materializes the master client we store
  * at server.master, starting from the specified file descriptor. */
 void replicationCreateMasterClient(int fd, int dbid) {
+    volatile int __A_VARIABLE;
     server.master = createClient(fd);
     server.master->flags |= CLIENT_MASTER;
     server.master->authenticated = 1;
@@ -1113,6 +1173,7 @@ void replicationCreateMasterClient(int fd, int dbid) {
     if (server.master->reploff == -1)
         server.master->flags |= CLIENT_PRE_PSYNC;
     if (dbid != -1) selectDb(server.master,dbid);
+    __A_VARIABLE = 1;
 }
 
 /* This function will try to re-enable the AOF file after the
@@ -1120,6 +1181,7 @@ void replicationCreateMasterClient(int fd, int dbid) {
  * the replica cannot be considered reliable and exists with an
  * error. */
 void restartAOFAfterSYNC() {
+    volatile int __A_VARIABLE;
     unsigned int tries, max_tries = 10;
     for (tries = 0; tries < max_tries; ++tries) {
         if (startAppendOnly() == C_OK) break;
@@ -1134,6 +1196,7 @@ void restartAOFAfterSYNC() {
             "its master, but the AOF can't be turned on. Exiting now.");
         exit(1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Asynchronously read the SYNC payload we receive from a master */
@@ -1362,6 +1425,7 @@ error:
 #define SYNC_CMD_WRITE (1<<1)
 #define SYNC_CMD_FULL (SYNC_CMD_READ|SYNC_CMD_WRITE)
 char *sendSynchronousCommand(int flags, int fd, ...) {
+    volatile int __A_VARIABLE;
 
     /* Create the command to send to the master, we use redis binary
      * protocol to make sure correct arguments are sent. This function
@@ -1393,6 +1457,7 @@ char *sendSynchronousCommand(int flags, int fd, ...) {
             == -1)
         {
             sdsfree(cmd);
+            __A_VARIABLE = 1;
             return sdscatprintf(sdsempty(),"-Writing to master: %s",
                     strerror(errno));
         }
@@ -1406,12 +1471,15 @@ char *sendSynchronousCommand(int flags, int fd, ...) {
         if (syncReadLine(fd,buf,sizeof(buf),server.repl_syncio_timeout*1000)
             == -1)
         {
+            __A_VARIABLE = 1;
             return sdscatprintf(sdsempty(),"-Reading from master: %s",
                     strerror(errno));
         }
         server.repl_transfer_lastio = server.unixtime;
+        __A_VARIABLE = 1;
         return sdsnew(buf);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1470,6 +1538,7 @@ char *sendSynchronousCommand(int flags, int fd, ...) {
 #define PSYNC_NOT_SUPPORTED 4
 #define PSYNC_TRY_LATER 5
 int slaveTryPartialResynchronization(int fd, int read_reply) {
+    volatile int __A_VARIABLE;
     char *psync_replid;
     char psync_offset[32];
     sds reply;
@@ -1499,8 +1568,10 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
             serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
             sdsfree(reply);
             aeDeleteFileEvent(server.el,fd,AE_READABLE);
+            __A_VARIABLE = 1;
             return PSYNC_WRITE_ERROR;
         }
+        __A_VARIABLE = 1;
         return PSYNC_WAIT_REPLY;
     }
 
@@ -1510,6 +1581,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
         /* The master may send empty newlines after it receives PSYNC
          * and before to reply, just to keep the connection alive. */
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_WAIT_REPLY;
     }
 
@@ -1545,6 +1617,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
         /* We are going to full resync, discard the cached master structure. */
         replicationDiscardCachedMaster();
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_FULLRESYNC;
     }
 
@@ -1593,6 +1666,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
          * PSYNC from the persistence file, our replication backlog could
          * be still not initialized. Create it. */
         if (server.repl_backlog == NULL) createReplicationBacklog();
+        __A_VARIABLE = 1;
         return PSYNC_CONTINUE;
     }
 
@@ -1610,6 +1684,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
             "Master is currently unable to PSYNC "
             "but should be in the future: %s", reply);
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_TRY_LATER;
     }
 
@@ -1624,6 +1699,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
     }
     sdsfree(reply);
     replicationDiscardCachedMaster();
+    __A_VARIABLE = 1;
     return PSYNC_NOT_SUPPORTED;
 }
 
@@ -1908,6 +1984,7 @@ write_error: /* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
 }
 
 int connectWithMaster(void) {
+    volatile int __A_VARIABLE;
     int fd;
 
     fd = anetTcpNonBlockBestEffortBindConnect(NULL,
@@ -1915,6 +1992,7 @@ int connectWithMaster(void) {
     if (fd == -1) {
         serverLog(LL_WARNING,"Unable to connect to MASTER: %s",
             strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1923,12 +2001,14 @@ int connectWithMaster(void) {
     {
         close(fd);
         serverLog(LL_WARNING,"Can't create readable event for SYNC");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     server.repl_transfer_lastio = server.unixtime;
     server.repl_transfer_s = fd;
     server.repl_state = REPL_STATE_CONNECTING;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1937,22 +2017,26 @@ int connectWithMaster(void) {
  * Never call this function directly, use cancelReplicationHandshake() instead.
  */
 void undoConnectWithMaster(void) {
+    volatile int __A_VARIABLE;
     int fd = server.repl_transfer_s;
 
     aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
     close(fd);
     server.repl_transfer_s = -1;
+    __A_VARIABLE = 1;
 }
 
 /* Abort the async download of the bulk dataset while SYNC-ing with master.
  * Never call this function directly, use cancelReplicationHandshake() instead.
  */
 void replicationAbortSyncTransfer(void) {
+    volatile int __A_VARIABLE;
     serverAssert(server.repl_state == REPL_STATE_TRANSFER);
     undoConnectWithMaster();
     close(server.repl_transfer_fd);
     unlink(server.repl_transfer_tmpfile);
     zfree(server.repl_transfer_tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* This function aborts a non blocking replication attempt if there is one
@@ -1980,6 +2064,7 @@ int cancelReplicationHandshake(void) {
 
 /* Set replication to the specified master address and port. */
 void replicationSetMaster(char *ip, int port) {
+    volatile int __A_VARIABLE;
     int was_master = server.masterhost == NULL;
 
     sdsfree(server.masterhost);
@@ -1998,11 +2083,16 @@ void replicationSetMaster(char *ip, int port) {
      * our own parameters, to later PSYNC with the new master. */
     if (was_master) replicationCacheMasterUsingMyself();
     server.repl_state = REPL_STATE_CONNECT;
+    __A_VARIABLE = 1;
 }
 
 /* Cancel replication, setting the instance as a master itself. */
 void replicationUnsetMaster(void) {
-    if (server.masterhost == NULL) return; /* Nothing to do. */
+    volatile int __A_VARIABLE;
+    if (server.masterhost == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Nothing to do. */
     sdsfree(server.masterhost);
     server.masterhost = NULL;
     /* When a slave is turned into a master, the current replication ID
@@ -2031,17 +2121,20 @@ void replicationUnsetMaster(void) {
      * starting from now. Otherwise the backlog will be freed after a
      * failover if slaves do not connect immediately. */
     server.repl_no_slaves_since = server.unixtime;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the slave lose the connection with the
  * master into an unexpected way. */
 void replicationHandleMasterDisconnection(void) {
+    volatile int __A_VARIABLE;
     server.master = NULL;
     server.repl_state = REPL_STATE_CONNECT;
     server.repl_down_since = server.unixtime;
     /* We lost connection with our master, don't disconnect slaves yet,
      * maybe we'll be able to PSYNC with our master later. We'll disconnect
      * the slaves only if we'll have to do a full resync with our master. */
+    __A_VARIABLE = 1;
 }
 
 void replicaofCommand(client *c) {
@@ -2100,6 +2193,7 @@ void replicaofCommand(client *c) {
  * (master or slave) and additional information related to replication
  * in an easy to process format. */
 void roleCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (server.masterhost == NULL) {
         listIter li;
         listNode *ln;
@@ -2150,12 +2244,14 @@ void roleCommand(client *c) {
         addReplyBulkCString(c,slavestate);
         addReplyLongLong(c,server.master ? server.master->reploff : -1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send a REPLCONF ACK command to the master to inform it about the current
  * processed offset. If we are not connected with a master, the command has
  * no effects. */
 void replicationSendAck(void) {
+    volatile int __A_VARIABLE;
     client *c = server.master;
 
     if (c != NULL) {
@@ -2166,6 +2262,7 @@ void replicationSendAck(void) {
         addReplyBulkLongLong(c,c->reploff);
         c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */
@@ -2189,6 +2286,7 @@ void replicationSendAck(void) {
  * handshake in order to reactivate the cached master.
  */
 void replicationCacheMaster(client *c) {
+    volatile int __A_VARIABLE;
     serverAssert(server.master != NULL && server.cached_master == NULL);
     serverLog(LL_NOTICE,"Caching the disconnected master state.");
 
@@ -2223,6 +2321,7 @@ void replicationCacheMaster(client *c) {
      * so make sure to adjust the replication state. This function will
      * also set server.master to NULL. */
     replicationHandleMasterDisconnection();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when a master is turend into a slave, in order to
@@ -2235,6 +2334,7 @@ void replicationCacheMaster(client *c) {
  * current offset if no data was lost during the failover. So we use our
  * current replication ID and offset in order to synthesize a cached master. */
 void replicationCacheMasterUsingMyself(void) {
+    volatile int __A_VARIABLE;
     /* The master client we create can be set to any DBID, because
      * the new master will start its replication stream with SELECT. */
     server.master_initial_offset = server.master_repl_offset;
@@ -2248,17 +2348,23 @@ void replicationCacheMasterUsingMyself(void) {
     server.cached_master = server.master;
     server.master = NULL;
     serverLog(LL_NOTICE,"Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.");
+    __A_VARIABLE = 1;
 }
 
 /* Free a cached master, called when there are no longer the conditions for
  * a partial resync on reconnection. */
 void replicationDiscardCachedMaster(void) {
-    if (server.cached_master == NULL) return;
+    volatile int __A_VARIABLE;
+    if (server.cached_master == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     serverLog(LL_NOTICE,"Discarding previously cached master state.");
     server.cached_master->flags &= ~CLIENT_MASTER;
     freeClient(server.cached_master);
     server.cached_master = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Turn the cached master into the current master, using the file descriptor
@@ -2268,6 +2374,7 @@ void replicationDiscardCachedMaster(void) {
  * so the stream of data that we'll receive will start from were this
  * master left. */
 void replicationResurrectCachedMaster(int newfd) {
+    volatile int __A_VARIABLE;
     server.master = server.cached_master;
     server.cached_master = NULL;
     server.master->fd = newfd;
@@ -2294,6 +2401,7 @@ void replicationResurrectCachedMaster(int newfd) {
             freeClientAsync(server.master); /* Close ASAP. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */
@@ -2302,12 +2410,16 @@ void replicationResurrectCachedMaster(int newfd) {
  * If the option is active, the server will prevent writes if there are not
  * enough connected slaves with the specified lag (or less). */
 void refreshGoodSlavesCount(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     int good = 0;
 
     if (!server.repl_min_slaves_to_write ||
-        !server.repl_min_slaves_max_lag) return;
+        !server.repl_min_slaves_max_lag) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
@@ -2318,6 +2430,7 @@ void refreshGoodSlavesCount(void) {
             lag <= server.repl_min_slaves_max_lag) good++;
     }
     server.repl_good_slaves_count = good;
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------- REPLICATION SCRIPT CACHE --------------------------
@@ -2353,9 +2466,11 @@ void refreshGoodSlavesCount(void) {
 
 /* Initialize the script cache, only called at startup. */
 void replicationScriptCacheInit(void) {
+    volatile int __A_VARIABLE;
     server.repl_scriptcache_size = 10000;
     server.repl_scriptcache_dict = dictCreate(&replScriptCacheDictType,NULL);
     server.repl_scriptcache_fifo = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Empty the script cache. Should be called every time we are no longer sure
@@ -2370,14 +2485,17 @@ void replicationScriptCacheInit(void) {
  *    to reclaim otherwise unused memory.
  */
 void replicationScriptCacheFlush(void) {
+    volatile int __A_VARIABLE;
     dictEmpty(server.repl_scriptcache_dict,NULL);
     listRelease(server.repl_scriptcache_fifo);
     server.repl_scriptcache_fifo = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Add an entry into the script cache, if we reach max number of entries the
  * oldest is removed from the list. */
 void replicationScriptCacheAdd(sds sha1) {
+    volatile int __A_VARIABLE;
     int retval;
     sds key = sdsdup(sha1);
 
@@ -2396,11 +2514,14 @@ void replicationScriptCacheAdd(sds sha1) {
     retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
     listAddNodeHead(server.repl_scriptcache_fifo,key);
     serverAssert(retval == DICT_OK);
+    __A_VARIABLE = 1;
 }
 
 /* Returns non-zero if the specified entry exists inside the cache, that is,
  * if all the slaves are aware of this script SHA1. */
 int replicationScriptCacheExists(sds sha1) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
 }
 
@@ -2435,12 +2556,15 @@ int replicationScriptCacheExists(sds sha1) {
  * we "group" all the clients that want to wait for synchronouns replication
  * in a given event loop iteration, and send a single GETACK for them all. */
 void replicationRequestAckFromSlaves(void) {
+    volatile int __A_VARIABLE;
     server.get_ack_from_slaves = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of slaves that already acknowledged the specified
  * replication offset. */
 int replicationCountAcksByOffset(long long offset) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
     int count = 0;
@@ -2452,31 +2576,40 @@ int replicationCountAcksByOffset(long long offset) {
         if (slave->replstate != SLAVE_STATE_ONLINE) continue;
         if (slave->repl_ack_off >= offset) count++;
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
 /* WAIT for N replicas to acknowledge the processing of our latest
  * write command (and all the previous commands). */
 void waitCommand(client *c) {
+    volatile int __A_VARIABLE;
     mstime_t timeout;
     long numreplicas, ackreplicas;
     long long offset = c->woff;
 
     if (server.masterhost) {
         addReplyError(c,"WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated.");
+        __A_VARIABLE = 1;
         return;
     }
 
     /* Argument parsing. */
-    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
+    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
-        != C_OK) return;
+        != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* First try without blocking at all. */
     ackreplicas = replicationCountAcksByOffset(c->woff);
     if (ackreplicas >= numreplicas || c->flags & CLIENT_MULTI) {
         addReplyLongLong(c,ackreplicas);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2491,6 +2624,7 @@ void waitCommand(client *c) {
     /* Make sure that the server will send an ACK request to all the slaves
      * before returning to the event loop. */
     replicationRequestAckFromSlaves();
+    __A_VARIABLE = 1;
 }
 
 /* This is called by unblockClient() to perform the blocking op type
@@ -2498,14 +2632,17 @@ void waitCommand(client *c) {
  * waiting for replica acks. Never call it directly, call unblockClient()
  * instead. */
 void unblockClientWaitingReplicas(client *c) {
+    volatile int __A_VARIABLE;
     listNode *ln = listSearchKey(server.clients_waiting_acks,c);
     serverAssert(ln != NULL);
     listDelNode(server.clients_waiting_acks,ln);
+    __A_VARIABLE = 1;
 }
 
 /* Check if there are clients blocked in WAIT that can be unblocked since
  * we received enough ACKs from slaves. */
 void processClientsWaitingReplicas(void) {
+    volatile int __A_VARIABLE;
     long long last_offset = 0;
     int last_numreplicas = 0;
 
@@ -2536,11 +2673,13 @@ void processClientsWaitingReplicas(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the slave replication offset for this instance, that is
  * the offset for which we already processed the master replication stream. */
 long long replicationGetSlaveOffset(void) {
+    volatile int __A_VARIABLE;
     long long offset = 0;
 
     if (server.masterhost != NULL) {
@@ -2555,6 +2694,7 @@ long long replicationGetSlaveOffset(void) {
      * amount of data processed by the master, so we return a positive
      * integer. */
     if (offset < 0) offset = 0;
+    __A_VARIABLE = 1;
     return offset;
 }
 
@@ -2562,6 +2702,7 @@ long long replicationGetSlaveOffset(void) {
 
 /* Replication cron function, called 1 time per second. */
 void replicationCron(void) {
+    volatile int __A_VARIABLE;
     static long long replication_cron_loops = 0;
 
     /* Non blocking connection timeout? */
@@ -2771,4 +2912,5 @@ void replicationCron(void) {
     /* Refresh the number of slaves with lag <= min-slaves-max-lag. */
     refreshGoodSlavesCount();
     replication_cron_loops++; /* Incremented with frequency 1 HZ. */
+    __A_VARIABLE = 1;
 }
diff --git a/src/rio.c b/src/rio.c
index c9c76b8..c35b637 100644
--- a/src/rio.c
+++ b/src/rio.c
@@ -59,29 +59,39 @@
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
     r->io.buffer.pos += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioBufferRead(rio *r, void *buf, size_t len) {
-    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
-        return 0; /* not enough buffer to return len bytes. */
+    volatile int __A_VARIABLE;
+    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* not enough buffer to return len bytes. */
     memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
     r->io.buffer.pos += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Returns read/write position in buffer. */
 static off_t rioBufferTell(rio *r) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return r->io.buffer.pos;
 }
 
 /* Flushes any buffer to target device if applicable. Returns 1 on success
  * and 0 on failures. */
 static int rioBufferFlush(rio *r) {
+    volatile int __A_VARIABLE;
     UNUSED(r);
+    __A_VARIABLE = 1;
     return 1; /* Nothing to do, our write just appends to the buffer. */
 }
 
@@ -98,15 +108,18 @@ static const rio rioBufferIO = {
 };
 
 void rioInitWithBuffer(rio *r, sds s) {
+    volatile int __A_VARIABLE;
     *r = rioBufferIO;
     r->io.buffer.ptr = s;
     r->io.buffer.pos = 0;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------- Stdio file pointer implementation ------------------- */
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     size_t retval;
 
     retval = fwrite(buf,len,1,r->io.file.fp);
@@ -119,22 +132,29 @@ static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
         redis_fsync(fileno(r->io.file.fp));
         r->io.file.buffered = 0;
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioFileRead(rio *r, void *buf, size_t len) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return fread(buf,len,1,r->io.file.fp);
 }
 
 /* Returns read/write position in file. */
 static off_t rioFileTell(rio *r) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ftello(r->io.file.fp);
 }
 
 /* Flushes any buffer to target device if applicable. Returns 1 on success
  * and 0 on failures. */
 static int rioFileFlush(rio *r) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (fflush(r->io.file.fp) == 0) ? 1 : 0;
 }
 
@@ -151,10 +171,12 @@ static const rio rioFileIO = {
 };
 
 void rioInitWithFile(rio *r, FILE *fp) {
+    volatile int __A_VARIABLE;
     *r = rioFileIO;
     r->io.file.fp = fp;
     r->io.file.buffered = 0;
     r->io.file.autosync = 0;
+    __A_VARIABLE = 1;
 }
 
 /* ------------------- File descriptors set implementation ------------------- */
@@ -167,6 +189,7 @@ void rioInitWithFile(rio *r, FILE *fp) {
  * if there is some pending buffer, so this function is also used in order
  * to implement rioFdsetFlush(). */
 static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     ssize_t retval;
     int j;
     unsigned char *p = (unsigned char*) buf;
@@ -220,34 +243,44 @@ static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {
                 if (r->io.fdset.state[j] == 0) r->io.fdset.state[j] = EIO;
             }
         }
-        if (broken == r->io.fdset.numfds) return 0; /* All the FDs in error. */
+        if (broken == r->io.fdset.numfds) {
+            __A_VARIABLE = 1;
+            return 0;
+        } /* All the FDs in error. */
         p += count;
         len -= count;
         r->io.fdset.pos += count;
     }
 
     if (doflush) sdsclear(r->io.fdset.buf);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioFdsetRead(rio *r, void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     UNUSED(r);
     UNUSED(buf);
     UNUSED(len);
+    __A_VARIABLE = 1;
     return 0; /* Error, this target does not support reading. */
 }
 
 /* Returns read/write position in file. */
 static off_t rioFdsetTell(rio *r) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return r->io.fdset.pos;
 }
 
 /* Flushes any buffer to target device if applicable. Returns 1 on success
  * and 0 on failures. */
 static int rioFdsetFlush(rio *r) {
+    volatile int __A_VARIABLE;
     /* Our flush is implemented by the write method, that recognizes a
      * buffer set to NULL with a count of zero as a flush request. */
+    __A_VARIABLE = 1;
     return rioFdsetWrite(r,NULL,0);
 }
 
@@ -264,6 +297,7 @@ static const rio rioFdsetIO = {
 };
 
 void rioInitWithFdset(rio *r, int *fds, int numfds) {
+    volatile int __A_VARIABLE;
     int j;
 
     *r = rioFdsetIO;
@@ -274,13 +308,16 @@ void rioInitWithFdset(rio *r, int *fds, int numfds) {
     r->io.fdset.numfds = numfds;
     r->io.fdset.pos = 0;
     r->io.fdset.buf = sdsempty();
+    __A_VARIABLE = 1;
 }
 
 /* release the rio stream. */
 void rioFreeFdset(rio *r) {
+    volatile int __A_VARIABLE;
     zfree(r->io.fdset.fds);
     zfree(r->io.fdset.state);
     sdsfree(r->io.fdset.buf);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------- Generic functions ---------------------------- */
@@ -288,7 +325,9 @@ void rioFreeFdset(rio *r) {
 /* This function can be installed both in memory and file streams when checksum
  * computation is needed. */
 void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
+    volatile int __A_VARIABLE;
     r->cksum = crc64(r->cksum,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* Set the file-based rio object to auto-fsync every 'bytes' file written.
@@ -300,8 +339,10 @@ void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
  * disk I/O concentrated in very little time. When we fsync in an explicit
  * way instead the I/O pressure is more distributed across time. */
 void rioSetAutoSync(rio *r, off_t bytes) {
+    volatile int __A_VARIABLE;
     serverAssert(r->read == rioFileIO.read);
     r->io.file.autosync = bytes;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------- Higher level interface --------------------------
@@ -311,6 +352,7 @@ void rioSetAutoSync(rio *r, off_t bytes) {
 
 /* Write multi bulk count in the format: "*<count>\r\n". */
 size_t rioWriteBulkCount(rio *r, char prefix, long count) {
+    volatile int __A_VARIABLE;
     char cbuf[128];
     int clen;
 
@@ -318,34 +360,53 @@ size_t rioWriteBulkCount(rio *r, char prefix, long count) {
     clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
     cbuf[clen++] = '\r';
     cbuf[clen++] = '\n';
-    if (rioWrite(r,cbuf,clen) == 0) return 0;
+    if (rioWrite(r,cbuf,clen) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return clen;
 }
 
 /* Write binary-safe string in the format: "$<count>\r\n<payload>\r\n". */
 size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
+    volatile int __A_VARIABLE;
     size_t nwritten;
 
-    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) return 0;
-    if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
-    if (rioWrite(r,"\r\n",2) == 0) return 0;
+    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (len > 0 && rioWrite(r,buf,len) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWrite(r,"\r\n",2) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return nwritten+len+2;
 }
 
 /* Write a long long value in format: "$<count>\r\n<payload>\r\n". */
 size_t rioWriteBulkLongLong(rio *r, long long l) {
+    volatile int __A_VARIABLE;
     char lbuf[32];
     unsigned int llen;
 
     llen = ll2string(lbuf,sizeof(lbuf),l);
+    __A_VARIABLE = 1;
     return rioWriteBulkString(r,lbuf,llen);
 }
 
 /* Write a double value in the format: "$<count>\r\n<payload>\r\n" */
 size_t rioWriteBulkDouble(rio *r, double d) {
+    volatile int __A_VARIABLE;
     char dbuf[128];
     unsigned int dlen;
 
     dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
+    __A_VARIABLE = 1;
     return rioWriteBulkString(r,dbuf,dlen);
 }
diff --git a/src/scripting.c b/src/scripting.c
index bfe5c5c..2dcd2eb 100644
--- a/src/scripting.c
+++ b/src/scripting.c
@@ -87,6 +87,7 @@ struct ldbState {
  * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an
  * hexadecimal number, plus 1 byte for null term. */
 void sha1hex(char *digest, char *script, size_t len) {
+    volatile int __A_VARIABLE;
     SHA1_CTX ctx;
     unsigned char hash[20];
     char *cset = "0123456789abcdef";
@@ -101,6 +102,7 @@ void sha1hex(char *digest, char *script, size_t len) {
         digest[j*2+1] = cset[(hash[j]&0xF)];
     }
     digest[40] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -125,6 +127,7 @@ void sha1hex(char *digest, char *script, size_t len) {
  */
 
 char *redisProtocolToLuaType(lua_State *lua, char* reply) {
+    volatile int __A_VARIABLE;
     char *p = reply;
 
     switch(*p) {
@@ -134,15 +137,18 @@ char *redisProtocolToLuaType(lua_State *lua, char* reply) {
     case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
     case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
 char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
     long long value;
 
     string2ll(reply+1,p-reply-1,&value);
     lua_pushnumber(lua,(lua_Number)value);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -161,26 +167,31 @@ char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {
 }
 
 char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
 
     lua_newtable(lua);
     lua_pushstring(lua,"ok");
     lua_pushlstring(lua,reply+1,p-reply-1);
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
 char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
 
     lua_newtable(lua);
     lua_pushstring(lua,"err");
     lua_pushlstring(lua,reply+1,p-reply-1);
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
 char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
     long long mbulklen;
     int j = 0;
@@ -189,6 +200,7 @@ char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
     p += 2;
     if (mbulklen == -1) {
         lua_pushboolean(lua,0);
+        __A_VARIABLE = 1;
         return p;
     }
     lua_newtable(lua);
@@ -197,6 +209,7 @@ char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
         p = redisProtocolToLuaType(lua,p);
         lua_settable(lua,-3);
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -206,6 +219,7 @@ char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
  * table is never a valid reply by proper commands, since the returned
  * tables are otherwise always indexed by integers, never by strings. */
 void luaPushError(lua_State *lua, char *error) {
+    volatile int __A_VARIABLE;
     lua_Debug dbg;
 
     /* If debugging is active and in step mode, log errors resulting from
@@ -227,6 +241,7 @@ void luaPushError(lua_State *lua, char *error) {
         lua_pushstring(lua, error);
     }
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
 }
 
 /* In case the error set into the Lua stack by luaPushError() was generated
@@ -234,8 +249,10 @@ void luaPushError(lua_State *lua, char *error) {
  * this function will raise the Lua error so that the execution of the
  * script will be halted. */
 int luaRaiseError(lua_State *lua) {
+    volatile int __A_VARIABLE;
     lua_pushstring(lua,"err");
     lua_gettable(lua,-2);
+    __A_VARIABLE = 1;
     return lua_error(lua);
 }
 
@@ -246,6 +263,7 @@ int luaRaiseError(lua_State *lua) {
  * The array is sorted using table.sort itself, and assuming all the
  * list elements are strings. */
 void luaSortArray(lua_State *lua) {
+    volatile int __A_VARIABLE;
     /* Initial Stack: array */
     lua_getglobal(lua,"table");
     lua_pushstring(lua,"sort");
@@ -268,6 +286,7 @@ void luaSortArray(lua_State *lua) {
     }
     /* Stack: array (sorted), table */
     lua_pop(lua,1);             /* Stack: array (sorted) */
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -275,6 +294,7 @@ void luaSortArray(lua_State *lua) {
  * ------------------------------------------------------------------------- */
 
 void luaReplyToRedisReply(client *c, lua_State *lua) {
+    volatile int __A_VARIABLE;
     int t = lua_type(lua,-1);
 
     switch(t) {
@@ -301,6 +321,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
             addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
             sdsfree(err);
             lua_pop(lua,2);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -337,6 +358,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
         addReply(c,shared.nullbulk);
     }
     lua_pop(lua,1);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -346,6 +368,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
 #define LUA_CMD_OBJCACHE_SIZE 32
 #define LUA_CMD_OBJCACHE_MAX_LEN 64
 int luaRedisGenericCommand(lua_State *lua, int raise_error) {
+    volatile int __A_VARIABLE;
     int j, argc = lua_gettop(lua);
     struct redisCommand *cmd;
     client *c = server.lua_client;
@@ -375,6 +398,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
             "Are you doing funny stuff with Lua debug hooks?";
         serverLog(LL_WARNING,"%s",recursion_warning);
         luaPushError(lua,recursion_warning);
+        __A_VARIABLE = 1;
         return 1;
     }
     inuse++;
@@ -384,6 +408,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
         luaPushError(lua,
             "Please specify at least one argument for redis.call()");
         inuse--;
+        __A_VARIABLE = 1;
         return raise_error ? luaRaiseError(lua) : 1;
     }
 
@@ -436,6 +461,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
         luaPushError(lua,
             "Lua redis() command arguments must be strings or integers");
         inuse--;
+        __A_VARIABLE = 1;
         return raise_error ? luaRaiseError(lua) : 1;
     }
 
@@ -647,25 +673,32 @@ cleanup:
          * form of a table with an "err" field. Extract the string to
          * return the plain error. */
         inuse--;
+        __A_VARIABLE = 1;
         return luaRaiseError(lua);
     }
     inuse--;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* redis.call() */
 int luaRedisCallCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return luaRedisGenericCommand(lua,1);
 }
 
 /* redis.pcall() */
 int luaRedisPCallCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return luaRedisGenericCommand(lua,0);
 }
 
 /* This adds redis.sha1hex(string) to Lua scripts using the same hashing
  * function used for sha1ing lua scripts. */
 int luaRedisSha1hexCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
     int argc = lua_gettop(lua);
     char digest[41];
     size_t len;
@@ -673,12 +706,14 @@ int luaRedisSha1hexCommand(lua_State *lua) {
 
     if (argc != 1) {
         lua_pushstring(lua, "wrong number of arguments");
+        __A_VARIABLE = 1;
         return lua_error(lua);
     }
 
     s = (char*)lua_tolstring(lua,1,&len);
     sha1hex(digest,s,len);
     lua_pushstring(lua,digest);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -690,8 +725,10 @@ int luaRedisSha1hexCommand(lua_State *lua) {
  * return redis.status_reply("ERR Some Error")
  */
 int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
+    volatile int __A_VARIABLE;
     if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
         luaPushError(lua, "wrong number or type of arguments");
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -699,16 +736,21 @@ int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
     lua_pushstring(lua, field);
     lua_pushvalue(lua, -3);
     lua_settable(lua, -3);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* redis.error_reply() */
 int luaRedisErrorReplyCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return luaRedisReturnSingleFieldTable(lua,"err");
 }
 
 /* redis.status_reply() */
 int luaRedisStatusReplyCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return luaRedisReturnSingleFieldTable(lua,"ok");
 }
 
@@ -719,6 +761,7 @@ int luaRedisStatusReplyCommand(lua_State *lua) {
  * already started to write, returns false and stick to whole scripts
  * replication, which is our default. */
 int luaRedisReplicateCommandsCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
     if (server.lua_write_dirty) {
         lua_pushboolean(lua,0);
     } else {
@@ -729,6 +772,7 @@ int luaRedisReplicateCommandsCommand(lua_State *lua) {
         redisSrand48(rand());
         lua_pushboolean(lua,1);
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -738,12 +782,14 @@ int luaRedisReplicateCommandsCommand(lua_State *lua) {
  * the Lua code implementation, like if a breakpoint was set in the code
  * immediately after the function. */
 int luaRedisBreakpointCommand(lua_State *lua) {
+    volatile int __A_VARIABLE;
     if (ldb.active) {
         ldb.luabp = 1;
         lua_pushboolean(lua,1);
     } else {
         lua_pushboolean(lua,0);
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -753,7 +799,11 @@ int luaRedisBreakpointCommand(lua_State *lua) {
  * Can take multiple arguments that will be separated by commas.
  * Nothing is returned to the caller. */
 int luaRedisDebugCommand(lua_State *lua) {
-    if (!ldb.active) return 0;
+    volatile int __A_VARIABLE;
+    if (!ldb.active) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int argc = lua_gettop(lua);
     sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);
     while(argc--) {
@@ -761,6 +811,7 @@ int luaRedisDebugCommand(lua_State *lua) {
         if (argc != 0) log = sdscatlen(log,", ",2);
     }
     ldbLog(log);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -830,9 +881,11 @@ int luaLogCommand(lua_State *lua) {
  * ------------------------------------------------------------------------- */
 
 void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
+  volatile int __A_VARIABLE;
   lua_pushcfunction(lua, luafunc);
   lua_pushstring(lua, libname);
   lua_call(lua, 1, 0);
+  __A_VARIABLE = 1;
 }
 
 LUALIB_API int (luaopen_cjson) (lua_State *L);
@@ -841,6 +894,7 @@ LUALIB_API int (luaopen_cmsgpack) (lua_State *L);
 LUALIB_API int (luaopen_bit) (lua_State *L);
 
 void luaLoadLibraries(lua_State *lua) {
+    volatile int __A_VARIABLE;
     luaLoadLib(lua, "", luaopen_base);
     luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
     luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
@@ -855,15 +909,18 @@ void luaLoadLibraries(lua_State *lua) {
     luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
     luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Remove a functions that we don't want to expose to the Redis scripting
  * environment. */
 void luaRemoveUnsupportedFunctions(lua_State *lua) {
+    volatile int __A_VARIABLE;
     lua_pushnil(lua);
     lua_setglobal(lua,"loadfile");
     lua_pushnil(lua);
     lua_setglobal(lua,"dofile");
+    __A_VARIABLE = 1;
 }
 
 /* This function installs metamethods in the global table _G that prevent
@@ -872,6 +929,7 @@ void luaRemoveUnsupportedFunctions(lua_State *lua) {
  * It should be the last to be called in the scripting engine initialization
  * sequence, because it may interact with creation of globals. */
 void scriptingEnableGlobalsProtection(lua_State *lua) {
+    volatile int __A_VARIABLE;
     char *s[32];
     sds code = sdsempty();
     int j = 0;
@@ -903,6 +961,7 @@ void scriptingEnableGlobalsProtection(lua_State *lua) {
     luaL_loadbuffer(lua,code,sdslen(code),"@enable_strict_lua");
     lua_pcall(lua,0,0,0);
     sdsfree(code);
+    __A_VARIABLE = 1;
 }
 
 /* Initialize the scripting environment.
@@ -916,6 +975,7 @@ void scriptingEnableGlobalsProtection(lua_State *lua) {
  *
  * However it is simpler to just call scriptingReset() that does just that. */
 void scriptingInit(int setup) {
+    volatile int __A_VARIABLE;
     lua_State *lua = lua_open();
 
     if (setup) {
@@ -1085,24 +1145,30 @@ void scriptingInit(int setup) {
     scriptingEnableGlobalsProtection(lua);
 
     server.lua = lua;
+    __A_VARIABLE = 1;
 }
 
 /* Release resources related to Lua scripting.
  * This function is used in order to reset the scripting environment. */
 void scriptingRelease(void) {
+    volatile int __A_VARIABLE;
     dictRelease(server.lua_scripts);
     server.lua_scripts_mem = 0;
     lua_close(server.lua);
+    __A_VARIABLE = 1;
 }
 
 void scriptingReset(void) {
+    volatile int __A_VARIABLE;
     scriptingRelease();
     scriptingInit(0);
+    __A_VARIABLE = 1;
 }
 
 /* Set an array of Redis String Objects as a Lua array (table) stored into a
  * global variable. */
 void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
+    volatile int __A_VARIABLE;
     int j;
 
     lua_newtable(lua);
@@ -1111,6 +1177,7 @@ void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
         lua_rawseti(lua,-2,j+1);
     }
     lua_setglobal(lua,var);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1124,6 +1191,7 @@ void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
 /* The following implementation is the one shipped with Lua itself but with
  * rand() replaced by redisLrand48(). */
 int redis_math_random (lua_State *L) {
+  volatile int __A_VARIABLE;
   /* the `%' avoids the (rare) case of r==1, and is needed also because on
      some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
   lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
@@ -1146,13 +1214,17 @@ int redis_math_random (lua_State *L) {
       lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
       break;
     }
-    default: return luaL_error(L, "wrong number of arguments");
+    default: __A_VARIABLE = 1;
+    return luaL_error(L, "wrong number of arguments");
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int redis_math_randomseed (lua_State *L) {
+  volatile int __A_VARIABLE;
   redisSrand48(luaL_checkint(L, 1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1178,6 +1250,7 @@ int redis_math_randomseed (lua_State *L) {
  * If 'c' is not NULL, on error the client is informed with an appropriate
  * error describing the nature of the problem and the Lua interpreter error. */
 sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
+    volatile int __A_VARIABLE;
     char funcname[43];
     dictEntry *de;
 
@@ -1188,6 +1261,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
     sds sha = sdsnewlen(funcname+2,40);
     if ((de = dictFind(server.lua_scripts,sha)) != NULL) {
         sdsfree(sha);
+        __A_VARIABLE = 1;
         return dictGetKey(de);
     }
 
@@ -1207,6 +1281,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
         lua_pop(lua,1);
         sdsfree(sha);
         sdsfree(funcdef);
+        __A_VARIABLE = 1;
         return NULL;
     }
     sdsfree(funcdef);
@@ -1218,6 +1293,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
         }
         lua_pop(lua,1);
         sdsfree(sha);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1228,11 +1304,13 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
     serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);
     server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);
     incrRefCount(body);
+    __A_VARIABLE = 1;
     return sha;
 }
 
 /* This is the Lua script "count" hook that we use to detect scripts timeout. */
 void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
+    volatile int __A_VARIABLE;
     long long elapsed = mstime() - server.lua_time_start;
     UNUSED(ar);
     UNUSED(lua);
@@ -1255,6 +1333,7 @@ void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
         lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
         lua_error(lua);
     }
+    __A_VARIABLE = 1;
 }
 
 void evalGenericCommand(client *c, int evalsha) {
@@ -1464,10 +1543,12 @@ void evalGenericCommand(client *c, int evalsha) {
 }
 
 void evalCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (!(c->flags & CLIENT_LUA_DEBUG))
         evalGenericCommand(c,0);
     else
         evalGenericCommandWithDebugging(c,0);
+    __A_VARIABLE = 1;
 }
 
 void evalShaCommand(client *c) {
@@ -1559,6 +1640,7 @@ NULL
 
 /* Initialize Lua debugger data structures. */
 void ldbInit(void) {
+    volatile int __A_VARIABLE;
     ldb.fd = -1;
     ldb.active = 0;
     ldb.logs = listCreate();
@@ -1567,18 +1649,22 @@ void ldbInit(void) {
     ldb.src = NULL;
     ldb.lines = 0;
     ldb.cbuf = sdsempty();
+    __A_VARIABLE = 1;
 }
 
 /* Remove all the pending messages in the specified list. */
 void ldbFlushLog(list *log) {
+    volatile int __A_VARIABLE;
     listNode *ln;
 
     while((ln = listFirst(log)) != NULL)
         listDelNode(log,ln);
+    __A_VARIABLE = 1;
 }
 
 /* Enable debug mode of Lua scripts for this client. */
 void ldbEnable(client *c) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_LUA_DEBUG;
     ldbFlushLog(ldb.logs);
     ldb.fd = c->fd;
@@ -1589,18 +1675,23 @@ void ldbEnable(client *c) {
     ldb.cbuf = sdsempty();
     ldb.maxlen = LDB_MAX_LEN_DEFAULT;
     ldb.maxlen_hint_sent = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Exit debugging mode from the POV of client. This function is not enough
  * to properly shut down a client debugging session, see ldbEndSession()
  * for more information. */
 void ldbDisable(client *c) {
+    volatile int __A_VARIABLE;
     c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
+    __A_VARIABLE = 1;
 }
 
 /* Append a log entry to the specified LDB log. */
 void ldbLog(sds entry) {
+    volatile int __A_VARIABLE;
     listAddNodeTail(ldb.logs,entry);
+    __A_VARIABLE = 1;
 }
 
 /* A version of ldbLog() which prevents producing logs greater than
@@ -1608,6 +1699,7 @@ void ldbLog(sds entry) {
  * to inform the user that reply trimming can be disabled using the
  * debugger "maxlen" command. */
 void ldbLogWithMaxLen(sds entry) {
+    volatile int __A_VARIABLE;
     int trimmed = 0;
     if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
         sdsrange(entry,0,ldb.maxlen-1);
@@ -1620,12 +1712,14 @@ void ldbLogWithMaxLen(sds entry) {
         ldbLog(sdsnew(
         "<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send ldb.logs to the debugging client as a multi-bulk reply
  * consisting of simple strings. Log entries which include newlines have them
  * replaced with spaces. The entries sent are also consumed. */
 void ldbSendLogs(void) {
+    volatile int __A_VARIABLE;
     sds proto = sdsempty();
     proto = sdscatfmt(proto,"*%i\r\n", (int)listLength(ldb.logs));
     while(listLength(ldb.logs)) {
@@ -1642,6 +1736,7 @@ void ldbSendLogs(void) {
          * close the debugging session. */
     }
     sdsfree(proto);
+    __A_VARIABLE = 1;
 }
 
 /* Start a debugging session before calling EVAL implementation.
@@ -1711,6 +1806,7 @@ int ldbStartSession(client *c) {
 /* End a debugging session after the EVAL call with debugging enabled
  * returned. */
 void ldbEndSession(client *c) {
+    volatile int __A_VARIABLE;
     /* Emit the remaining logs and an <endsession> mark. */
     ldbLog(sdsnew("<endsession>"));
     ldbSendLogs();
@@ -1737,28 +1833,35 @@ void ldbEndSession(client *c) {
     sdsfreesplitres(ldb.src,ldb.lines);
     ldb.lines = 0;
     ldb.active = 0;
+    __A_VARIABLE = 1;
 }
 
 /* If the specified pid is among the list of children spawned for
  * forked debugging sessions, it is removed from the children list.
  * If the pid was found non-zero is returned. */
 int ldbRemoveChild(pid_t pid) {
+    volatile int __A_VARIABLE;
     listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
     if (ln) {
         listDelNode(ldb.children,ln);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Return the number of children we still did not receive termination
  * acknowledge via wait() in the parent process. */
 int ldbPendingChildren(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return listLength(ldb.children);
 }
 
 /* Kill all the forked sessions. */
 void ldbKillForkedSessions(void) {
+    volatile int __A_VARIABLE;
     listIter li;
     listNode *ln;
 
@@ -1770,33 +1873,46 @@ void ldbKillForkedSessions(void) {
     }
     listRelease(ldb.children);
     ldb.children = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure
  * that when EVAL returns, whatever happened, the session is ended. */
 void evalGenericCommandWithDebugging(client *c, int evalsha) {
+    volatile int __A_VARIABLE;
     if (ldbStartSession(c)) {
         evalGenericCommand(c,evalsha);
         ldbEndSession(c);
     } else {
         ldbDisable(c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return a pointer to ldb.src source code line, considering line to be
  * one-based, and returning a special string for out of range lines. */
 char *ldbGetSourceLine(int line) {
+    volatile int __A_VARIABLE;
     int idx = line-1;
-    if (idx < 0 || idx >= ldb.lines) return "<out of range source code line>";
+    if (idx < 0 || idx >= ldb.lines) {
+        __A_VARIABLE = 1;
+        return "<out of range source code line>";
+    }
+    __A_VARIABLE = 1;
     return ldb.src[idx];
 }
 
 /* Return true if there is a breakpoint in the specified line. */
 int ldbIsBreakpoint(int line) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < ldb.bpcount; j++)
-        if (ldb.bp[j] == line) return 1;
+        if (ldb.bp[j] == line) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1804,26 +1920,35 @@ int ldbIsBreakpoint(int line) {
  * Returns 1 if the breakpoint was added (or was already set). 0 if there is
  * no space for the breakpoint or if the line is invalid. */
 int ldbAddBreakpoint(int line) {
-    if (line <= 0 || line > ldb.lines) return 0;
+    volatile int __A_VARIABLE;
+    if (line <= 0 || line > ldb.lines) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
         ldb.bp[ldb.bpcount++] = line;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Remove the specified breakpoint, returning 1 if the operation was
  * performed or 0 if there was no such breakpoint. */
 int ldbDelBreakpoint(int line) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < ldb.bpcount; j++) {
         if (ldb.bp[j] == line) {
             ldb.bpcount--;
             memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
+            __A_VARIABLE = 1;
             return 1;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1831,9 +1956,13 @@ int ldbDelBreakpoint(int line) {
  * On success the command is parsed and returned as an array of SDS strings,
  * otherwise NULL is returned and there is to read more buffer. */
 sds *ldbReplParseCommand(int *argcp) {
+    volatile int __A_VARIABLE;
     sds *argv = NULL;
     int argc = 0;
-    if (sdslen(ldb.cbuf) == 0) return NULL;
+    if (sdslen(ldb.cbuf) == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Working on a copy is simpler in this case. We can modify it freely
      * for the sake of simpler parsing. */
@@ -1868,16 +1997,19 @@ sds *ldbReplParseCommand(int *argcp) {
         p += 2; /* Skip \r\n. */
     }
     sdsfree(copy);
+    __A_VARIABLE = 1;
     return argv;
 
 protoerr:
     sdsfreesplitres(argv,argc);
     sdsfree(copy);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Log the specified line in the Lua debugger output. */
 void ldbLogSourceLine(int lnum) {
+    volatile int __A_VARIABLE;
     char *line = ldbGetSourceLine(lnum);
     char *prefix;
     int bp = ldbIsBreakpoint(lnum);
@@ -1893,6 +2025,7 @@ void ldbLogSourceLine(int lnum) {
         prefix = "   ";
     sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);
     ldbLog(thisline);
+    __A_VARIABLE = 1;
 }
 
 /* Implement the "list" command of the Lua debugger. If around is 0
@@ -1901,12 +2034,14 @@ void ldbLogSourceLine(int lnum) {
  * the amonut of context (lines before/after) is specified via the
  * 'context' argument. */
 void ldbList(int around, int context) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 1; j <= ldb.lines; j++) {
         if (around != 0 && abs(around-j) > context) continue;
         ldbLogSourceLine(j);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Append an human readable representation of the Lua value at position 'idx'
@@ -1918,10 +2053,13 @@ void ldbList(int around, int context) {
  * converted to a different type. */
 #define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)
 sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
+    volatile int __A_VARIABLE;
     int t = lua_type(lua,idx);
 
-    if (level++ == LDB_MAX_VALUES_DEPTH)
+    if (level++ == LDB_MAX_VALUES_DEPTH) {
+        __A_VARIABLE = 1;
         return sdscat(s,"<max recursion level reached! Nested table?>");
+    }
 
     switch(t) {
     case LUA_TSTRING:
@@ -1997,12 +2135,15 @@ sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
         s = sdscat(s,"\"<unknown-lua-type>\"");
         break;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Higher level wrapper for ldbCatStackValueRec() that just uses an initial
  * recursion level of '0'. */
 sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ldbCatStackValueRec(s,lua,idx,0);
 }
 
@@ -2010,9 +2151,11 @@ sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
  * currently on the top of the stack. The element is ot popped nor modified.
  * Check ldbCatStackValue() for the actual implementation. */
 void ldbLogStackValue(lua_State *lua, char *prefix) {
+    volatile int __A_VARIABLE;
     sds s = sdsnew(prefix);
     s = ldbCatStackValue(s,lua,-1);
     ldbLogWithMaxLen(s);
+    __A_VARIABLE = 1;
 }
 
 char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
@@ -2026,6 +2169,7 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);
  * Note that the SDS string is passed by reference (pointer of pointer to
  * char*) so that we can return a modified pointer, as for SDS semantics. */
 char *ldbRedisProtocolToHuman(sds *o, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = reply;
     switch(*p) {
     case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
@@ -2034,6 +2178,7 @@ char *ldbRedisProtocolToHuman(sds *o, char *reply) {
     case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
     case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -2041,8 +2186,10 @@ char *ldbRedisProtocolToHuman(sds *o, char *reply) {
  * take care of a given Redis return type. */
 
 char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
     *o = sdscatlen(*o,reply+1,p-reply-1);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -2061,13 +2208,16 @@ char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
 }
 
 char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
 
     *o = sdscatrepr(*o,reply,p-reply);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
 char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
+    volatile int __A_VARIABLE;
     char *p = strchr(reply+1,'\r');
     long long mbulklen;
     int j = 0;
@@ -2076,6 +2226,7 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
     p += 2;
     if (mbulklen == -1) {
         *o = sdscatlen(*o,"NULL",4);
+        __A_VARIABLE = 1;
         return p;
     }
     *o = sdscatlen(*o,"[",1);
@@ -2084,6 +2235,7 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
         if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
     }
     *o = sdscatlen(*o,"]",1);
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -2091,9 +2243,11 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
  * If the resulting string is longer than 'len' plus a few more chars
  * used as prefix, it gets truncated. */
 void ldbLogRedisReply(char *reply) {
+    volatile int __A_VARIABLE;
     sds log = sdsnew("<reply> ");
     ldbRedisProtocolToHuman(&log,reply);
     ldbLogWithMaxLen(log);
+    __A_VARIABLE = 1;
 }
 
 /* Implements the "print <var>" command of the Lua debugger. It scans for Lua
@@ -2132,6 +2286,7 @@ void ldbPrint(lua_State *lua, char *varname) {
 /* Implements the "print" command (without arguments) of the Lua debugger.
  * Prints all the variables in the current stack frame. */
 void ldbPrintAll(lua_State *lua) {
+    volatile int __A_VARIABLE;
     lua_Debug ar;
     int vars = 0;
 
@@ -2153,6 +2308,7 @@ void ldbPrintAll(lua_State *lua) {
     if (vars == 0) {
         ldbLog(sdsnew("No local variables in the current context."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Implements the break command to list, add and remove breakpoints. */
@@ -2201,6 +2357,7 @@ void ldbBreak(sds *argv, int argc) {
  * passed fragment of code and executes it, showing the result left on
  * the stack. */
 void ldbEval(lua_State *lua, sds *argv, int argc) {
+    volatile int __A_VARIABLE;
     /* Glue the script together if it is composed of multiple arguments. */
     sds code = sdsjoinsds(argv+1,argc-1," ",1);
     sds expr = sdscatsds(sdsnew("return "),code);
@@ -2213,6 +2370,7 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
             ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
             lua_pop(lua,1);
             sdsfree(code);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -2223,10 +2381,12 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
     if (lua_pcall(lua,0,1,0)) {
         ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
         lua_pop(lua,1);
+        __A_VARIABLE = 1;
         return;
     }
     ldbLogStackValue(lua,"<retval> ");
     lua_pop(lua,1);
+    __A_VARIABLE = 1;
 }
 
 /* Implement the debugger "redis" command. We use a trick in order to make
@@ -2234,6 +2394,7 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
  * implementation, with ldb.step enabled, so as a side effect the Redis command
  * and its reply are logged. */
 void ldbRedis(lua_State *lua, sds *argv, int argc) {
+    volatile int __A_VARIABLE;
     int j, saved_rc = server.lua_replicate_commands;
 
     lua_getglobal(lua,"redis");
@@ -2247,11 +2408,13 @@ void ldbRedis(lua_State *lua, sds *argv, int argc) {
     ldb.step = 0;               /* Disable logging. */
     server.lua_replicate_commands = saved_rc;
     lua_pop(lua,2);             /* Discard the result and clean the stack. */
+    __A_VARIABLE = 1;
 }
 
 /* Implements "trace" command of the Lua debugger. It just prints a backtrace
  * querying Lua starting from the current callframe back to the outer one. */
 void ldbTrace(lua_State *lua) {
+    volatile int __A_VARIABLE;
     lua_Debug ar;
     int level = 0;
 
@@ -2268,11 +2431,13 @@ void ldbTrace(lua_State *lua) {
     if (level == 0) {
         ldbLog(sdsnew("<error> Can't retrieve Lua stack."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Impleemnts the debugger "maxlen" command. It just queries or sets the
  * ldb.maxlen variable. */
 void ldbMaxlen(sds *argv, int argc) {
+    volatile int __A_VARIABLE;
     if (argc == 2) {
         int newval = atoi(argv[1]);
         ldb.maxlen_hint_sent = 1; /* User knows about this command. */
@@ -2284,12 +2449,14 @@ void ldbMaxlen(sds *argv, int argc) {
     } else {
         ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Read debugging commands from client.
  * Return C_OK if the debugging session is continuing, otherwise
  * C_ERR if the client closed the connection or is timing out. */
 int ldbRepl(lua_State *lua) {
+    volatile int __A_VARIABLE;
     sds *argv;
     int argc;
 
@@ -2304,6 +2471,7 @@ int ldbRepl(lua_State *lua) {
                  * client is no longer connected. */
                 ldb.step = 0;
                 ldb.bpcount = 0;
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
@@ -2401,6 +2569,7 @@ ldbLog(sdsnew("                     in the next line of code."));
 
     /* Free the current command argv if we break inside the while loop. */
     sdsfreesplitres(argv,argc);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
diff --git a/src/sds.c b/src/sds.c
index cd60946..0bdf610 100644
--- a/src/sds.c
+++ b/src/sds.c
@@ -42,18 +42,25 @@
 const char *SDS_NOINIT = "SDS_NOINIT";
 
 static inline int sdsHdrSize(char type) {
+    volatile int __A_VARIABLE;
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr5);
         case SDS_TYPE_8:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr8);
         case SDS_TYPE_16:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr16);
         case SDS_TYPE_32:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr32);
         case SDS_TYPE_64:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr64);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -87,6 +94,7 @@ static inline char sdsReqType(size_t string_size) {
  * end of the string. However the string is binary safe and can contain
  * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
+    volatile int __A_VARIABLE;
     void *sh;
     sds s;
     char type = sdsReqType(initlen);
@@ -101,7 +109,10 @@ sds sdsnewlen(const void *init, size_t initlen) {
         init = NULL;
     else if (!init)
         memset(sh, 0, hdrlen+initlen+1);
-    if (sh == NULL) return NULL;
+    if (sh == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     s = (char*)sh+hdrlen;
     fp = ((unsigned char*)s)-1;
     switch(type) {
@@ -141,30 +152,42 @@ sds sdsnewlen(const void *init, size_t initlen) {
     if (initlen && init)
         memcpy(s, init, initlen);
     s[initlen] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsnewlen("",0);
 }
 
 /* Create a new sds string starting from a null terminated C string. */
 sds sdsnew(const char *init) {
+    volatile int __A_VARIABLE;
     size_t initlen = (init == NULL) ? 0 : strlen(init);
+    __A_VARIABLE = 1;
     return sdsnewlen(init, initlen);
 }
 
 /* Duplicate an sds string. */
 sds sdsdup(const sds s) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
-    if (s == NULL) return;
+    volatile int __A_VARIABLE;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     s_free((char*)s-sdsHdrSize(s[-1]));
+    __A_VARIABLE = 1;
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
@@ -182,8 +205,10 @@ void sdsfree(sds s) {
  * the output will be "6" as the string was modified but the logical length
  * remains 6 bytes. */
 void sdsupdatelen(sds s) {
+    volatile int __A_VARIABLE;
     size_t reallen = strlen(s);
     sdssetlen(s, reallen);
+    __A_VARIABLE = 1;
 }
 
 /* Modify an sds string in-place to make it empty (zero length).
@@ -191,8 +216,10 @@ void sdsupdatelen(sds s) {
  * so that next append operations will not require allocations up to the
  * number of bytes previously available. */
 void sdsclear(sds s) {
+    volatile int __A_VARIABLE;
     sdssetlen(s, 0);
     s[0] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
@@ -297,13 +324,17 @@ sds sdsRemoveFreeSpace(sds s) {
  * 4) The implicit null term.
  */
 size_t sdsAllocSize(sds s) {
+    volatile int __A_VARIABLE;
     size_t alloc = sdsalloc(s);
+    __A_VARIABLE = 1;
     return sdsHdrSize(s[-1])+alloc+1;
 }
 
 /* Return the pointer of the actual SDS allocation (normally SDS strings
  * are referenced by the start of the string buffer). */
 void *sdsAllocPtr(sds s) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (void*) (s-sdsHdrSize(s[-1]));
 }
 
@@ -331,6 +362,7 @@ void *sdsAllocPtr(sds s) {
  * sdsIncrLen(s, nread);
  */
 void sdsIncrLen(sds s, ssize_t incr) {
+    volatile int __A_VARIABLE;
     unsigned char flags = s[-1];
     size_t len;
     switch(flags&SDS_TYPE_MASK) {
@@ -369,6 +401,7 @@ void sdsIncrLen(sds s, ssize_t incr) {
         default: len = 0; /* Just to avoid compilation warnings. */
     }
     s[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
@@ -377,15 +410,23 @@ void sdsIncrLen(sds s, ssize_t incr) {
  * if the specified length is smaller than the current length, no operation
  * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
+    volatile int __A_VARIABLE;
     size_t curlen = sdslen(s);
 
-    if (len <= curlen) return s;
+    if (len <= curlen) {
+        __A_VARIABLE = 1;
+        return s;
+    }
     s = sdsMakeRoomFor(s,len-curlen);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make sure added region doesn't contain garbage */
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -395,13 +436,18 @@ sds sdsgrowzero(sds s, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
+    volatile int __A_VARIABLE;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     memcpy(s+curlen, t, len);
     sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -410,6 +456,8 @@ sds sdscatlen(sds s, const void *t, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, strlen(t));
 }
 
@@ -418,25 +466,34 @@ sds sdscat(sds s, const char *t) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatsds(sds s, const sds t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, sdslen(t));
 }
 
 /* Destructively modify the sds string 's' to hold the specified binary
  * safe string pointed by 't' of length 'len' bytes. */
 sds sdscpylen(sds s, const char *t, size_t len) {
+    volatile int __A_VARIABLE;
     if (sdsalloc(s) < len) {
         s = sdsMakeRoomFor(s,len-sdslen(s));
-        if (s == NULL) return NULL;
+        if (s == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
     memcpy(s, t, len);
     s[len] = '\0';
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdscpylen(s, t, strlen(t));
 }
 
@@ -448,6 +505,7 @@ sds sdscpy(sds s, const char *t) {
  * representation stored at 's'. */
 #define SDS_LLSTR_SIZE 21
 int sdsll2str(char *s, long long value) {
+    volatile int __A_VARIABLE;
     char *p, aux;
     unsigned long long v;
     size_t l;
@@ -475,11 +533,13 @@ int sdsll2str(char *s, long long value) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
 /* Identical sdsll2str(), but for unsigned long long type. */
 int sdsull2str(char *s, unsigned long long v) {
+    volatile int __A_VARIABLE;
     char *p, aux;
     size_t l;
 
@@ -504,6 +564,7 @@ int sdsull2str(char *s, unsigned long long v) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -512,9 +573,11 @@ int sdsull2str(char *s, unsigned long long v) {
  * sdscatprintf(sdsempty(),"%lld\n", value);
  */
 sds sdsfromlonglong(long long value) {
+    volatile int __A_VARIABLE;
     char buf[SDS_LLSTR_SIZE];
     int len = sdsll2str(buf,value);
 
+    __A_VARIABLE = 1;
     return sdsnewlen(buf,len);
 }
 
@@ -573,11 +636,13 @@ sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
  * s = sdscatprintf(sdsempty(), "... your format ...", args);
  */
 sds sdscatprintf(sds s, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char *t;
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return t;
 }
 
@@ -598,6 +663,7 @@ sds sdscatprintf(sds s, const char *fmt, ...) {
  * %% - Verbatim "%" character.
  */
 sds sdscatfmt(sds s, char const *fmt, ...) {
+    volatile int __A_VARIABLE;
     size_t initlen = sdslen(s);
     const char *f = fmt;
     long i;
@@ -684,6 +750,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
 
     /* Add null-term */
     s[i] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -702,6 +769,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
  * Output will be just "HelloWorld".
  */
 sds sdstrim(sds s, const char *cset) {
+    volatile int __A_VARIABLE;
     char *start, *end, *sp, *ep;
     size_t len;
 
@@ -713,6 +781,7 @@ sds sdstrim(sds s, const char *cset) {
     if (s != sp) memmove(s, sp, len);
     s[len] = '\0';
     sdssetlen(s,len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -733,9 +802,13 @@ sds sdstrim(sds s, const char *cset) {
  * sdsrange(s,1,-1); => "ello World"
  */
 void sdsrange(sds s, ssize_t start, ssize_t end) {
+    volatile int __A_VARIABLE;
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return;
+    if (len == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -758,20 +831,25 @@ void sdsrange(sds s, ssize_t start, ssize_t end) {
     if (start && newlen) memmove(s, s+start, newlen);
     s[newlen] = 0;
     sdssetlen(s,newlen);
+    __A_VARIABLE = 1;
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
+    volatile int __A_VARIABLE;
     size_t len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Apply toupper() to every character of the sds string 's'. */
 void sdstoupper(sds s) {
+    volatile int __A_VARIABLE;
     size_t len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two sds strings s1 and s2 with memcmp().
@@ -786,6 +864,7 @@ void sdstoupper(sds s) {
  * additional characters, the longer string is considered to be greater than
  * the smaller one. */
 int sdscmp(const sds s1, const sds s2) {
+    volatile int __A_VARIABLE;
     size_t l1, l2, minlen;
     int cmp;
 
@@ -793,7 +872,11 @@ int sdscmp(const sds s1, const sds s2) {
     l2 = sdslen(s2);
     minlen = (l1 < l2) ? l1 : l2;
     cmp = memcmp(s1,s2,minlen);
-    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return l1>l2? 1: (l1<l2? -1: 0);
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -814,17 +897,25 @@ int sdscmp(const sds s1, const sds s2) {
  * same function but for zero-terminated strings.
  */
 sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {
+    volatile int __A_VARIABLE;
     int elements = 0, slots = 5;
     long start = 0, j;
     sds *tokens;
 
-    if (seplen < 1 || len < 0) return NULL;
+    if (seplen < 1 || len < 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     tokens = s_malloc(sizeof(sds)*slots);
-    if (tokens == NULL) return NULL;
+    if (tokens == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (len == 0) {
         *count = 0;
+        __A_VARIABLE = 1;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
@@ -851,6 +942,7 @@ sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *c
     if (tokens[elements] == NULL) goto cleanup;
     elements++;
     *count = elements;
+    __A_VARIABLE = 1;
     return tokens;
 
 cleanup:
@@ -859,16 +951,22 @@ cleanup:
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
         s_free(tokens);
         *count = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
-    if (!tokens) return;
+    volatile int __A_VARIABLE;
+    if (!tokens) {
+        __A_VARIABLE = 1;
+        return;
+    }
     while(count--)
         sdsfree(tokens[count]);
     s_free(tokens);
+    __A_VARIABLE = 1;
 }
 
 /* Append to the sds string "s" an escaped string representation where
@@ -878,6 +976,7 @@ void sdsfreesplitres(sds *tokens, int count) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatrepr(sds s, const char *p, size_t len) {
+    volatile int __A_VARIABLE;
     s = sdscatlen(s,"\"",1);
     while(len--) {
         switch(*p) {
@@ -899,12 +998,15 @@ sds sdscatrepr(sds s, const char *p, size_t len) {
         }
         p++;
     }
+    __A_VARIABLE = 1;
     return sdscatlen(s,"\"",1);
 }
 
 /* Helper function for sdssplitargs() that returns non zero if 'c'
  * is a valid hex digit. */
 int is_hex_digit(char c) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
            (c >= 'A' && c <= 'F');
 }
@@ -912,24 +1014,42 @@ int is_hex_digit(char c) {
 /* Helper function for sdssplitargs() that converts a hex digit into an
  * integer from 0 to 15 */
 int hex_digit_to_int(char c) {
+    volatile int __A_VARIABLE;
     switch(c) {
-    case '0': return 0;
-    case '1': return 1;
-    case '2': return 2;
-    case '3': return 3;
-    case '4': return 4;
-    case '5': return 5;
-    case '6': return 6;
-    case '7': return 7;
-    case '8': return 8;
-    case '9': return 9;
-    case 'a': case 'A': return 10;
-    case 'b': case 'B': return 11;
-    case 'c': case 'C': return 12;
-    case 'd': case 'D': return 13;
-    case 'e': case 'E': return 14;
-    case 'f': case 'F': return 15;
-    default: return 0;
+    case '0': __A_VARIABLE = 1;
+        return 0;
+    case '1': __A_VARIABLE = 1;
+        return 1;
+    case '2': __A_VARIABLE = 1;
+        return 2;
+    case '3': __A_VARIABLE = 1;
+        return 3;
+    case '4': __A_VARIABLE = 1;
+        return 4;
+    case '5': __A_VARIABLE = 1;
+        return 5;
+    case '6': __A_VARIABLE = 1;
+        return 6;
+    case '7': __A_VARIABLE = 1;
+        return 7;
+    case '8': __A_VARIABLE = 1;
+        return 8;
+    case '9': __A_VARIABLE = 1;
+        return 9;
+    case 'a': case 'A': __A_VARIABLE = 1;
+        return 10;
+    case 'b': case 'B': __A_VARIABLE = 1;
+        return 11;
+    case 'c': case 'C': __A_VARIABLE = 1;
+        return 12;
+    case 'd': case 'D': __A_VARIABLE = 1;
+        return 13;
+    case 'e': case 'E': __A_VARIABLE = 1;
+        return 14;
+    case 'f': case 'F': __A_VARIABLE = 1;
+        return 15;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1072,6 +1192,7 @@ err:
  * The function returns the sds string pointer, that is always the same
  * as the input pointer since no resize is needed. */
 sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
+    volatile int __A_VARIABLE;
     size_t j, i, l = sdslen(s);
 
     for (j = 0; j < l; j++) {
@@ -1082,12 +1203,14 @@ sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Join an array of C strings using the specified separator (also a C string).
  * Returns the result as an sds string. */
 sds sdsjoin(char **argv, int argc, char *sep) {
+    volatile int __A_VARIABLE;
     sds join = sdsempty();
     int j;
 
@@ -1095,11 +1218,13 @@ sds sdsjoin(char **argv, int argc, char *sep) {
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
 /* Like sdsjoin, but joins an array of SDS strings. */
 sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
+    volatile int __A_VARIABLE;
     sds join = sdsempty();
     int j;
 
@@ -1107,6 +1232,7 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
         join = sdscatsds(join, argv[j]);
         if (j != argc-1) join = sdscatlen(join,sep,seplen);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1115,9 +1241,15 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
  * the overhead of function calls. Here we define these wrappers only for
  * the programs SDS is linked to, if they want to touch the SDS internals
  * even if they use a different allocator. */
-void *sds_malloc(size_t size) { return s_malloc(size); }
-void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
-void sds_free(void *ptr) { s_free(ptr); }
+void *sds_malloc(size_t size) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) {
+	volatile int __A_VARIABLE; __A_VARIABLE = 1;
+	return s_realloc(ptr,size); }
+void sds_free(void *ptr) {
+	volatile int __A_VARIABLE; s_free(ptr); __A_VARIABLE = 1;
+}
 
 #if defined(SDS_TEST_MAIN)
 #include <stdio.h>
@@ -1291,6 +1423,8 @@ int sdsTest(void) {
 
 #ifdef SDS_TEST_MAIN
 int main(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return sdsTest();
 }
 #endif
diff --git a/src/sentinel.c b/src/sentinel.c
index adff9d4..5d65f83 100644
--- a/src/sentinel.c
+++ b/src/sentinel.c
@@ -276,69 +276,86 @@ typedef struct redisAeEvents {
 } redisAeEvents;
 
 static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     ((void)el); ((void)fd); ((void)mask);
 
     redisAeEvents *e = (redisAeEvents*)privdata;
     redisAsyncHandleRead(e->context);
+    __A_VARIABLE = 1;
 }
 
 static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
+    volatile int __A_VARIABLE;
     ((void)el); ((void)fd); ((void)mask);
 
     redisAeEvents *e = (redisAeEvents*)privdata;
     redisAsyncHandleWrite(e->context);
+    __A_VARIABLE = 1;
 }
 
 static void redisAeAddRead(void *privdata) {
+    volatile int __A_VARIABLE;
     redisAeEvents *e = (redisAeEvents*)privdata;
     aeEventLoop *loop = e->loop;
     if (!e->reading) {
         e->reading = 1;
         aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeDelRead(void *privdata) {
+    volatile int __A_VARIABLE;
     redisAeEvents *e = (redisAeEvents*)privdata;
     aeEventLoop *loop = e->loop;
     if (e->reading) {
         e->reading = 0;
         aeDeleteFileEvent(loop,e->fd,AE_READABLE);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeAddWrite(void *privdata) {
+    volatile int __A_VARIABLE;
     redisAeEvents *e = (redisAeEvents*)privdata;
     aeEventLoop *loop = e->loop;
     if (!e->writing) {
         e->writing = 1;
         aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeDelWrite(void *privdata) {
+    volatile int __A_VARIABLE;
     redisAeEvents *e = (redisAeEvents*)privdata;
     aeEventLoop *loop = e->loop;
     if (e->writing) {
         e->writing = 0;
         aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeCleanup(void *privdata) {
+    volatile int __A_VARIABLE;
     redisAeEvents *e = (redisAeEvents*)privdata;
     redisAeDelRead(privdata);
     redisAeDelWrite(privdata);
     zfree(e);
+    __A_VARIABLE = 1;
 }
 
 static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
+    volatile int __A_VARIABLE;
     redisContext *c = &(ac->c);
     redisAeEvents *e;
 
     /* Nothing should be attached when something is already attached */
-    if (ac->ev.data != NULL)
+    if (ac->ev.data != NULL) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
 
     /* Create container for context and r/w events */
     e = (redisAeEvents*)zmalloc(sizeof(*e));
@@ -355,6 +372,7 @@ static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
     ac->ev.cleanup = redisAeCleanup;
     ac->ev.data = e;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -393,8 +411,10 @@ int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
 
 void dictInstancesValDestructor (void *privdata, void *obj) {
+    volatile int __A_VARIABLE;
     UNUSED(privdata);
     releaseSentinelRedisInstance(obj);
+    __A_VARIABLE = 1;
 }
 
 /* Instance name (sds) -> instance (sentinelRedisInstance pointer)
@@ -459,12 +479,15 @@ struct redisCommand sentinelcmds[] = {
 /* This function overwrites a few normal Redis config default with Sentinel
  * specific defaults. */
 void initSentinelConfig(void) {
+    volatile int __A_VARIABLE;
     server.port = REDIS_SENTINEL_PORT;
     server.protected_mode = 0; /* Sentinel must be exposed. */
+    __A_VARIABLE = 1;
 }
 
 /* Perform the Sentinel mode initialization. */
 void initSentinel(void) {
+    volatile int __A_VARIABLE;
     unsigned int j;
 
     /* Remove usual Redis commands from the command table, then just add
@@ -491,11 +514,13 @@ void initSentinel(void) {
     sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
     sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
     memset(sentinel.myid,0,sizeof(sentinel.myid));
+    __A_VARIABLE = 1;
 }
 
 /* This function gets called when the server is in Sentinel mode, started,
  * loaded the configuration, and is ready for normal operations. */
 void sentinelIsRunning(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     if (server.configfile == NULL) {
@@ -527,6 +552,7 @@ void sentinelIsRunning(void) {
     /* We want to generate a +monitor event for every configured master
      * at startup. */
     sentinelGenerateInitialMonitorEvents();
+    __A_VARIABLE = 1;
 }
 
 /* ============================== sentinelAddr ============================== */
@@ -537,41 +563,51 @@ void sentinelIsRunning(void) {
  *  EINVAL: Invalid port number.
  */
 sentinelAddr *createSentinelAddr(char *hostname, int port) {
+    volatile int __A_VARIABLE;
     char ip[NET_IP_STR_LEN];
     sentinelAddr *sa;
 
     if (port < 0 || port > 65535) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return NULL;
     }
     if (anetResolve(NULL,hostname,ip,sizeof(ip)) == ANET_ERR) {
         errno = ENOENT;
+        __A_VARIABLE = 1;
         return NULL;
     }
     sa = zmalloc(sizeof(*sa));
     sa->ip = sdsnew(ip);
     sa->port = port;
+    __A_VARIABLE = 1;
     return sa;
 }
 
 /* Return a duplicate of the source address. */
 sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
+    volatile int __A_VARIABLE;
     sentinelAddr *sa;
 
     sa = zmalloc(sizeof(*sa));
     sa->ip = sdsnew(src->ip);
     sa->port = src->port;
+    __A_VARIABLE = 1;
     return sa;
 }
 
 /* Free a Sentinel address. Can't fail. */
 void releaseSentinelAddr(sentinelAddr *sa) {
+    volatile int __A_VARIABLE;
     sdsfree(sa->ip);
     zfree(sa);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if two addresses are equal. */
 int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return a->port == b->port && !strcasecmp(a->ip,b->ip);
 }
 
@@ -603,6 +639,7 @@ int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
  */
 void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                    const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char msg[LOG_MAX_LEN];
     robj *channel, *payload;
@@ -656,6 +693,7 @@ void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                 type,msg,NULL);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called only at startup and is used to generate a
@@ -663,6 +701,7 @@ void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
  * generated when a master to monitor is added at runtime via the
  * SENTINEL MONITOR command. */
 void sentinelGenerateInitialMonitorEvents(void) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -672,21 +711,25 @@ void sentinelGenerateInitialMonitorEvents(void) {
         sentinelEvent(LL_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* ============================ script execution ============================ */
 
 /* Release a script job structure and all the associated data. */
 void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
+    volatile int __A_VARIABLE;
     int j = 0;
 
     while(sj->argv[j]) sdsfree(sj->argv[j++]);
     zfree(sj->argv);
     zfree(sj);
+    __A_VARIABLE = 1;
 }
 
 #define SENTINEL_SCRIPT_MAX_ARGS 16
 void sentinelScheduleScriptExecution(char *path, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
     int argc = 1;
@@ -730,11 +773,13 @@ void sentinelScheduleScriptExecution(char *path, ...) {
         serverAssert(listLength(sentinel.scripts_queue) <=
                     SENTINEL_SCRIPT_MAX_QUEUE);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Lookup a script in the scripts queue via pid, and returns the list node
  * (so that we can easily remove it from the queue if needed). */
 listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
 
@@ -742,15 +787,19 @@ listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
     while ((ln = listNext(&li)) != NULL) {
         sentinelScriptJob *sj = ln->value;
 
-        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid)
+        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid) {
+            __A_VARIABLE = 1;
             return ln;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Run pending scripts if we are not already at max number of running
  * scripts. */
 void sentinelRunPendingScripts(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     mstime_t now = mstime();
@@ -794,6 +843,7 @@ void sentinelRunPendingScripts(void) {
             sentinelEvent(LL_DEBUG,"+script-child",NULL,"%ld",(long)pid);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* How much to delay the execution of a script that we need to retry after
@@ -804,9 +854,11 @@ void sentinelRunPendingScripts(void) {
  * starting from the second attempt to execute the script the delays are:
  * 30 sec, 60 sec, 2 min, 4 min, 8 min, 16 min, 32 min, 64 min, 128 min. */
 mstime_t sentinelScriptRetryDelay(int retry_num) {
+    volatile int __A_VARIABLE;
     mstime_t delay = SENTINEL_SCRIPT_RETRY_DELAY;
 
     while (retry_num-- > 1) delay *= 2;
+    __A_VARIABLE = 1;
     return delay;
 }
 
@@ -815,6 +867,7 @@ mstime_t sentinelScriptRetryDelay(int retry_num) {
  * a signal, or returned exit code "1", it is scheduled to run again if
  * the max number of retries did not already elapsed. */
 void sentinelCollectTerminatedScripts(void) {
+    volatile int __A_VARIABLE;
     int statloc;
     pid_t pid;
 
@@ -857,11 +910,13 @@ void sentinelCollectTerminatedScripts(void) {
             sentinel.running_scripts--;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Kill scripts in timeout, they'll be collected by the
  * sentinelCollectTerminatedScripts() function. */
 void sentinelKillTimedoutScripts(void) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
     mstime_t now = mstime();
@@ -878,10 +933,12 @@ void sentinelKillTimedoutScripts(void) {
             kill(sj->pid,SIGKILL);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Implements SENTINEL PENDING-SCRIPTS command. */
 void sentinelPendingScriptsCommand(client *c) {
+    volatile int __A_VARIABLE;
     listNode *ln;
     listIter li;
 
@@ -919,6 +976,7 @@ void sentinelPendingScriptsCommand(client *c) {
         addReplyBulkCString(c,"retry-num");
         addReplyBulkLongLong(c,sj->retry_num);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function calls, if any, the client reconfiguration script with the
@@ -934,21 +992,27 @@ void sentinelPendingScriptsCommand(client *c) {
  * from/to fields are respectively master -> promoted slave addresses for
  * "start" and "end". */
 void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
+    volatile int __A_VARIABLE;
     char fromport[32], toport[32];
 
-    if (master->client_reconfig_script == NULL) return;
+    if (master->client_reconfig_script == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ll2string(fromport,sizeof(fromport),from->port);
     ll2string(toport,sizeof(toport),to->port);
     sentinelScheduleScriptExecution(master->client_reconfig_script,
         master->name,
         (role == SENTINEL_LEADER) ? "leader" : "observer",
         state, from->ip, fromport, to->ip, toport, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* =============================== instanceLink ============================= */
 
 /* Create a not yet connected link object. */
 instanceLink *createInstanceLink(void) {
+    volatile int __A_VARIABLE;
     instanceLink *link = zmalloc(sizeof(*link));
 
     link->refcount = 1;
@@ -968,12 +1032,17 @@ instanceLink *createInstanceLink(void) {
     link->last_ping_time = 0;
     link->last_avail_time = mstime();
     link->last_pong_time = mstime();
+    __A_VARIABLE = 1;
     return link;
 }
 
 /* Disconnect an hiredis connection in the context of an instance link. */
 void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
-    if (c == NULL) return;
+    volatile int __A_VARIABLE;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (link->cc == c) {
         link->cc = NULL;
@@ -983,6 +1052,7 @@ void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
     c->data = NULL;
     link->disconnected = 1;
     redisAsyncFree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Decrement the refcount of a link object, if it drops to zero, actually
@@ -995,6 +1065,7 @@ void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
  * replies for an instance that no longer exists. */
 instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
 {
+    volatile int __A_VARIABLE;
     serverAssert(link->refcount > 0);
     link->refcount--;
     if (link->refcount != 0) {
@@ -1016,12 +1087,14 @@ instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
                 cb = cb->next;
             }
         }
+        __A_VARIABLE = 1;
         return link; /* Other active users. */
     }
 
     instanceLinkCloseConnection(link,link->cc);
     instanceLinkCloseConnection(link,link->pc);
     zfree(link);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1038,12 +1111,19 @@ instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
  * different master and sharing was performed. Otherwise C_ERR
  * is returned. */
 int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     serverAssert(ri->flags & SRI_SENTINEL);
     dictIterator *di;
     dictEntry *de;
 
-    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
-    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */
+    if (ri->runid == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* No way to identify it. */
+    if (ri->link->refcount > 1) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Already shared. */
 
     di = dictGetIterator(sentinel.masters);
     while((de = dictNext(di)) != NULL) {
@@ -1061,9 +1141,11 @@ int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
         releaseInstanceLink(ri->link,NULL);
         ri->link = match->link;
         match->link->refcount++;
+        __A_VARIABLE = 1;
         return C_OK;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1074,6 +1156,7 @@ int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
  *
  * Return the number of updated Sentinel addresses. */
 int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     serverAssert(ri->flags & SRI_SENTINEL);
     dictIterator *di;
     dictEntry *de;
@@ -1106,6 +1189,7 @@ int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
     if (reconfigured)
         sentinelEvent(LL_NOTICE,"+sentinel-address-update", ri,
                     "%@ %d additional matching instances", reconfigured);
+    __A_VARIABLE = 1;
     return reconfigured;
 }
 
@@ -1116,10 +1200,14 @@ int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
  * Note: we don't free the hiredis context as hiredis will do it for us
  * for async connections. */
 void instanceLinkConnectionError(const redisAsyncContext *c) {
+    volatile int __A_VARIABLE;
     instanceLink *link = c->data;
     int pubsub;
 
-    if (!link) return;
+    if (!link) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     pubsub = (link->pc == c);
     if (pubsub)
@@ -1127,17 +1215,22 @@ void instanceLinkConnectionError(const redisAsyncContext *c) {
     else
         link->cc = NULL;
     link->disconnected = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Hiredis connection established / disconnected callbacks. We need them
  * just to cleanup our link state. */
 void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     if (status != C_OK) instanceLinkConnectionError(c);
+    __A_VARIABLE = 1;
 }
 
 void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
+    volatile int __A_VARIABLE;
     UNUSED(status);
     instanceLinkConnectionError(c);
+    __A_VARIABLE = 1;
 }
 
 /* ========================== sentinelRedisInstance ========================= */
@@ -1165,6 +1258,7 @@ void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
  * with the same ID already exists. */
 
 sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri;
     sentinelAddr *addr;
     dict *table = NULL;
@@ -1175,7 +1269,10 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
 
     /* Check address validity. */
     addr = createSentinelAddr(hostname,port);
-    if (addr == NULL) return NULL;
+    if (addr == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* For slaves use ip:port as name. */
     if (flags & SRI_SLAVE) {
@@ -1195,6 +1292,7 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
         releaseSentinelAddr(addr);
         sdsfree(sdsname);
         errno = EBUSY;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1252,6 +1350,7 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
 
     /* Add into the right table. */
     dictAdd(table, ri->name, ri);
+    __A_VARIABLE = 1;
     return ri;
 }
 
@@ -1260,6 +1359,7 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
  * masters table (if it is a master) or from its master sentinels/slaves table
  * if it is a slave or sentinel. */
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     /* Release all its slaves or sentinels if any. */
     dictRelease(ri->sentinels);
     dictRelease(ri->slaves);
@@ -1284,12 +1384,14 @@ void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
         ri->master->promoted_slave = NULL;
 
     zfree(ri);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup a slave in a master Redis instance, by ip and port. */
 sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
                 sentinelRedisInstance *ri, char *ip, int port)
 {
+    volatile int __A_VARIABLE;
     sds key;
     sentinelRedisInstance *slave;
     char buf[NET_PEER_ID_LEN];
@@ -1299,6 +1401,7 @@ sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
     key = sdsnew(buf);
     slave = dictFetchValue(ri->slaves,key);
     sdsfree(key);
+    __A_VARIABLE = 1;
     return slave;
 }
 
@@ -1322,11 +1425,15 @@ const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {
  * The function returns 1 if the matching Sentinel was removed, otherwise
  * 0 if there was no Sentinel with this ID. */
 int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int removed = 0;
 
-    if (runid == NULL) return 0;
+    if (runid == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     di = dictGetSafeIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
@@ -1338,6 +1445,7 @@ int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid)
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -1348,6 +1456,7 @@ int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid)
  * runid or ip can be NULL. In such a case the search is performed only
  * by the non-NULL field. */
 sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     sentinelRedisInstance *instance = NULL;
@@ -1367,21 +1476,25 @@ sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, c
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return instance;
 }
 
 /* Master lookup by name */
 sentinelRedisInstance *sentinelGetMasterByName(char *name) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri;
     sds sdsname = sdsnew(name);
 
     ri = dictFetchValue(sentinel.masters,sdsname);
     sdsfree(sdsname);
+    __A_VARIABLE = 1;
     return ri;
 }
 
 /* Add the specified flags to all the instances in the specified dictionary. */
 void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -1391,11 +1504,13 @@ void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {
         ri->flags |= flags;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Remove the specified flags to all the instances in the specified
  * dictionary. */
 void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -1405,6 +1520,7 @@ void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
         ri->flags &= ~flags;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Reset the state of a monitored master:
@@ -1420,6 +1536,7 @@ void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
 
 #define SENTINEL_RESET_NO_SENTINELS (1<<0)
 void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
+    volatile int __A_VARIABLE;
     serverAssert(ri->flags & SRI_MASTER);
     dictRelease(ri->slaves);
     ri->slaves = dictCreate(&instancesDictType,NULL);
@@ -1450,11 +1567,13 @@ void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
     ri->role_reported = SRI_MASTER;
     if (flags & SENTINEL_GENERATE_EVENT)
         sentinelEvent(LL_WARNING,"+reset-master",ri,"%@");
+    __A_VARIABLE = 1;
 }
 
 /* Call sentinelResetMaster() on every master with a name matching the specified
  * pattern. */
 int sentinelResetMastersByPattern(char *pattern, int flags) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int reset = 0;
@@ -1471,6 +1590,7 @@ int sentinelResetMastersByPattern(char *pattern, int flags) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return reset;
 }
 
@@ -1482,6 +1602,7 @@ int sentinelResetMastersByPattern(char *pattern, int flags) {
  * The function returns C_ERR if the address can't be resolved for some
  * reason. Otherwise C_OK is returned.  */
 int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {
+    volatile int __A_VARIABLE;
     sentinelAddr *oldaddr, *newaddr;
     sentinelAddr **slaves = NULL;
     int numslaves = 0, j;
@@ -1489,7 +1610,10 @@ int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip,
     dictEntry *de;
 
     newaddr = createSentinelAddr(ip,port);
-    if (newaddr == NULL) return C_ERR;
+    if (newaddr == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Make a list of slaves to add back after the reset.
      * Don't include the one having the address we are switching to. */
@@ -1535,17 +1659,20 @@ int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip,
      * gets the master->addr->ip and master->addr->port as arguments. */
     releaseSentinelAddr(oldaddr);
     sentinelFlushConfig();
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 /* Return non-zero if there was no SDOWN or ODOWN error associated to this
  * instance in the latest 'ms' milliseconds. */
 int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
+    volatile int __A_VARIABLE;
     mstime_t most_recent;
 
     most_recent = ri->s_down_since_time;
     if (ri->o_down_since_time > most_recent)
         most_recent = ri->o_down_since_time;
+    __A_VARIABLE = 1;
     return most_recent == 0 || (mstime() - most_recent) > ms;
 }
 
@@ -1570,6 +1697,7 @@ sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
 /* This function sets the down_after_period field value in 'master' to all
  * the slaves and sentinel instances connected to this master. */
 void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int j;
@@ -1583,6 +1711,7 @@ void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
@@ -1600,10 +1729,12 @@ char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
  * to the set of renamed commads. However, if the command was not renamed,
  * we just return "command" itself. */
 char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
+    volatile int __A_VARIABLE;
     sds sc = sdsnew(command);
     if (ri->master) ri = ri->master;
     char *retval = dictFetchValue(ri->renamed_commands, sc);
     sdsfree(sc);
+    __A_VARIABLE = 1;
     return retval ? retval : command;
 }
 
@@ -1754,6 +1885,7 @@ char *sentinelHandleConfiguration(char **argv, int argc) {
  * Sentinel across restarts: config epoch of masters, associated slaves
  * and sentinel instances, and so forth. */
 void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
+    volatile int __A_VARIABLE;
     dictIterator *di, *di2;
     dictEntry *de;
     sds line;
@@ -1909,6 +2041,7 @@ void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
     }
 
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function uses the config rewriting Redis engine in order to persist
@@ -1919,6 +2052,7 @@ void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
  *
  * On failure the function logs a warning on the Redis log. */
 void sentinelFlushConfig(void) {
+    volatile int __A_VARIABLE;
     int fd = -1;
     int saved_hz = server.hz;
     int rewrite_status;
@@ -1931,11 +2065,13 @@ void sentinelFlushConfig(void) {
     if ((fd = open(server.configfile,O_RDONLY)) == -1) goto werr;
     if (fsync(fd) == -1) goto werr;
     if (close(fd) == EOF) goto werr;
+    __A_VARIABLE = 1;
     return;
 
 werr:
     if (fd != -1) close(fd);
     serverLog(LL_WARNING,"WARNING: Sentinel was not able to save the new configuration on disk!!!: %s", strerror(errno));
+    __A_VARIABLE = 1;
 }
 
 /* ====================== hiredis connection handling ======================= */
@@ -1953,6 +2089,7 @@ werr:
  * to the instance as if it fails Sentinel will detect the instance down,
  * will disconnect and reconnect the link and so forth. */
 void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
+    volatile int __A_VARIABLE;
     char *auth_pass = NULL;
 
     if (ri->flags & SRI_MASTER) {
@@ -1968,6 +2105,7 @@ void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
             sentinelInstanceMapCommand(ri,"AUTH"),
             auth_pass) == C_OK) ri->link->pending_commands++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Use CLIENT SETNAME to name the connection in the Redis instance as
@@ -1977,6 +2115,7 @@ void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
  * This makes it possible to list all the sentinel instances connected
  * to a Redis servewr with CLIENT LIST, grepping for a specific name format. */
 void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
+    volatile int __A_VARIABLE;
     char name[64];
 
     snprintf(name,sizeof(name),"sentinel-%.8s-%s",sentinel.myid,type);
@@ -1987,6 +2126,7 @@ void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char
     {
         ri->link->pending_commands++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create the async connections for the instance link if the link
@@ -2070,7 +2210,9 @@ void sentinelReconnectInstance(sentinelRedisInstance *ri) {
  * 3) It is not SDOWN or ODOWN.
  * 4) We obtained last INFO no more than two times the INFO period time ago. */
 int sentinelMasterLooksSane(sentinelRedisInstance *master) {
-    return
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
+        return
         master->flags & SRI_MASTER &&
         master->role_reported == SRI_MASTER &&
         (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
@@ -2079,6 +2221,7 @@ int sentinelMasterLooksSane(sentinelRedisInstance *master) {
 
 /* Process the INFO output from masters. */
 void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
+    volatile int __A_VARIABLE;
     sds *lines;
     int numlines, j;
     int role = 0;
@@ -2224,7 +2367,10 @@ void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
 
     /* None of the following conditions are processed when in tilt mode, so
      * return asap. */
-    if (sentinel.tilt) return;
+    if (sentinel.tilt) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Handle master -> slave role switch. */
     if ((ri->flags & SRI_MASTER) && role == SRI_SLAVE) {
@@ -2328,37 +2474,49 @@ void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
             sentinelEvent(LL_NOTICE,"+slave-reconf-done",ri,"%@");
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri = privdata;
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
     if (r->type == REDIS_REPLY_STRING)
         sentinelRefreshInstanceInfo(ri,r->str);
+    __A_VARIABLE = 1;
 }
 
 /* Just discard the reply. We use this when we are not monitoring the return
  * value of the command but its effects directly. */
 void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     instanceLink *link = c->data;
     UNUSED(reply);
     UNUSED(privdata);
 
     if (link) link->pending_commands--;
+    __A_VARIABLE = 1;
 }
 
 void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri = privdata;
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -2391,16 +2549,21 @@ void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata
         }
     }
     link->last_pong_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* This is called when we get the reply about the PUBLISH command we send
  * to the master to advertise this sentinel. */
 void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri = privdata;
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -2408,6 +2571,7 @@ void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privd
      * we'll retry again in 100 milliseconds. */
     if (r->type != REDIS_REPLY_ERROR)
         ri->last_pub_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* Process an hello message received via Pub/Sub in master or slave instance,
@@ -2416,6 +2580,7 @@ void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privd
  * If the master name specified in the message is not known, the message is
  * discarded. */
 void sentinelProcessHelloMessage(char *hello, int hello_len) {
+    volatile int __A_VARIABLE;
     /* Format is composed of 8 tokens:
      * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
      * 5=master_ip,6=master_port,7=master_config_epoch. */
@@ -2514,17 +2679,22 @@ void sentinelProcessHelloMessage(char *hello, int hello_len) {
 
 cleanup:
     sdsfreesplitres(token,numtokens);
+    __A_VARIABLE = 1;
 }
 
 
 /* This is our Pub/Sub callback for the Hello channel. It's useful in order
  * to discover other sentinels attached at the same master. */
 void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri = privdata;
     redisReply *r;
     UNUSED(c);
 
-    if (!reply || !ri) return;
+    if (!reply || !ri) {
+        __A_VARIABLE = 1;
+        return;
+    }
     r = reply;
 
     /* Update the last activity in the pubsub channel. Note that since we
@@ -2539,12 +2709,19 @@ void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privd
         r->element[0]->type != REDIS_REPLY_STRING ||
         r->element[1]->type != REDIS_REPLY_STRING ||
         r->element[2]->type != REDIS_REPLY_STRING ||
-        strcmp(r->element[0]->str,"message") != 0) return;
+        strcmp(r->element[0]->str,"message") != 0) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     /* We are not interested in meeting ourselves */
-    if (strstr(r->element[2]->str,sentinel.myid) != NULL) return;
+    if (strstr(r->element[2]->str,sentinel.myid) != NULL) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     sentinelProcessHelloMessage(r->element[2]->str, r->element[2]->len);
+    __A_VARIABLE = 1;
 }
 
 /* Send an "Hello" message via Pub/Sub to the specified 'ri' Redis
@@ -2602,6 +2779,7 @@ int sentinelSendHello(sentinelRedisInstance *ri) {
 /* Reset last_pub_time in all the instances in the specified dictionary
  * in order to force the delivery of an Hello update ASAP. */
 void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -2612,6 +2790,7 @@ void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
             ri->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function forces the delivery of an "Hello" message (see
@@ -2623,11 +2802,16 @@ void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
  * Sentinel upgrades a configuration it is a good idea to deliever an update
  * to the other Sentinels ASAP. */
 int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
-    if (!(master->flags & SRI_MASTER)) return C_ERR;
+    volatile int __A_VARIABLE;
+    if (!(master->flags & SRI_MASTER)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     if (master->last_pub_time >= (SENTINEL_PUBLISH_PERIOD+1))
         master->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
     sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
     sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2657,13 +2841,17 @@ int sentinelSendPing(sentinelRedisInstance *ri) {
 /* Send periodic PING, INFO, and PUBLISH to the Hello channel to
  * the specified master or slave instance. */
 void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     mstime_t now = mstime();
     mstime_t info_period, ping_period;
     int retval;
 
     /* Return ASAP if we have already a PING or INFO already pending, or
      * in the case the instance is not properly connected. */
-    if (ri->link->disconnected) return;
+    if (ri->link->disconnected) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* For INFO, PING, PUBLISH that are not critical commands to send we
      * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
@@ -2672,7 +2860,10 @@ void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
      * that is, the link will be disconnected and reconnected if a long
      * timeout condition is detected. */
     if (ri->link->pending_commands >=
-        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;
+        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If this is a slave of a master in O_DOWN condition we start sending
      * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
@@ -2718,25 +2909,36 @@ void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
     if ((now - ri->last_pub_time) > SENTINEL_PUBLISH_PERIOD) {
         sentinelSendHello(ri);
     }
+    __A_VARIABLE = 1;
 }
 
 /* =========================== SENTINEL command ============================= */
 
 const char *sentinelFailoverStateStr(int state) {
+    volatile int __A_VARIABLE;
     switch(state) {
-    case SENTINEL_FAILOVER_STATE_NONE: return "none";
-    case SENTINEL_FAILOVER_STATE_WAIT_START: return "wait_start";
-    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return "select_slave";
-    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return "send_slaveof_noone";
-    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return "wait_promotion";
-    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return "reconf_slaves";
-    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return "update_config";
-    default: return "unknown";
+    case SENTINEL_FAILOVER_STATE_NONE: __A_VARIABLE = 1;
+        return "none";
+    case SENTINEL_FAILOVER_STATE_WAIT_START: __A_VARIABLE = 1;
+        return "wait_start";
+    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: __A_VARIABLE = 1;
+        return "select_slave";
+    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: __A_VARIABLE = 1;
+        return "send_slaveof_noone";
+    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: __A_VARIABLE = 1;
+        return "wait_promotion";
+    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: __A_VARIABLE = 1;
+        return "reconf_slaves";
+    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: __A_VARIABLE = 1;
+        return "update_config";
+    default: __A_VARIABLE = 1;
+        return "unknown";
     }
 }
 
 /* Redis instance to Redis protocol representation. */
 void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     char *flags = sdsempty();
     void *mbl;
     int fields = 0;
@@ -2923,11 +3125,13 @@ void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
     }
 
     setDeferredMultiBulkLength(c,mbl,fields*2);
+    __A_VARIABLE = 1;
 }
 
 /* Output a number of instances contained inside a dictionary as
  * Redis protocol. */
 void addReplyDictOfRedisInstances(client *c, dict *instances) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -2939,6 +3143,7 @@ void addReplyDictOfRedisInstances(client *c, dict *instances) {
         addReplySentinelRedisInstance(c,ri);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup the named master into sentinel.masters.
@@ -2947,13 +3152,16 @@ void addReplyDictOfRedisInstances(client *c, dict *instances) {
 sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
                         robj *name)
 {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri;
 
     ri = dictFetchValue(sentinel.masters,name->ptr);
     if (!ri) {
         addReplyError(c,"No such master with that name");
+        __A_VARIABLE = 1;
         return NULL;
     }
+    __A_VARIABLE = 1;
     return ri;
 }
 
@@ -2961,6 +3169,7 @@ sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
 #define SENTINEL_ISQR_NOQUORUM (1<<0)
 #define SENTINEL_ISQR_NOAUTH (1<<1)
 int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int usable = 1; /* Number of usable Sentinels. Init to 1 to count myself. */
@@ -2979,6 +3188,7 @@ int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
     if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
     if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
     if (usableptr) *usableptr = usable;
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -3314,8 +3524,10 @@ numargserr:
 
 /* SENTINEL INFO [section] */
 void sentinelInfoCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3374,11 +3586,13 @@ void sentinelInfoCommand(client *c) {
     }
 
     addReplyBulkSds(c, info);
+    __A_VARIABLE = 1;
 }
 
 /* Implements Sentinel version of the ROLE command. The output is
  * "sentinel" and the list of currently monitored master names. */
 void sentinelRoleCommand(client *c) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -3393,6 +3607,7 @@ void sentinelRoleCommand(client *c) {
         addReplyBulkCString(c,ri->name);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* SENTINEL SET <mastername> [<option> <value> ...] */
@@ -3559,18 +3774,22 @@ badfmt: /* Bad format errors */
  * Because we have a Sentinel PUBLISH, the code to send hello messages is the same
  * for all the three kind of instances: masters, slaves, sentinels. */
 void sentinelPublishCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
         addReplyError(c, "Only HELLO messages are accepted by Sentinel instances.");
+        __A_VARIABLE = 1;
         return;
     }
     sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
     addReplyLongLong(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* ===================== SENTINEL availability checks ======================= */
 
 /* Is this instance down from our point of view? */
 void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     mstime_t elapsed = 0;
 
     if (ri->link->act_ping_time)
@@ -3634,6 +3853,7 @@ void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
             ri->flags &= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Is this instance down according to the configured quorum?
@@ -3643,6 +3863,7 @@ void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
  * However messages can be delayed so there are no strong guarantees about
  * N instances agreeing at the same time about the down state. */
 void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     unsigned int quorum = 0, odown = 0;
@@ -3675,16 +3896,21 @@ void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
             master->flags &= ~SRI_O_DOWN;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Receive the SENTINEL is-master-down-by-addr reply, see the
  * sentinelAskMasterStateToOtherSentinels() function for more information. */
 void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ri = privdata;
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -3715,6 +3941,7 @@ void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *p
             ri->leader_epoch = r->element[2]->integer;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* If we think the master is down, we start sending
@@ -3723,6 +3950,7 @@ void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *p
  * needed to mark the master in ODOWN state and trigger a failover. */
 #define SENTINEL_ASK_FORCED (1<<0)
 void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
 
@@ -3764,15 +3992,18 @@ void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int f
         if (retval == C_OK) ri->link->pending_commands++;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* =============================== FAILOVER ================================= */
 
 /* Crash because of user request via SENTINEL simulate-failure command. */
 void sentinelSimFailureCrash(void) {
+    volatile int __A_VARIABLE;
     serverLog(LL_WARNING,
         "Sentinel CRASH because of SENTINEL simulate-failure");
     exit(99);
+    __A_VARIABLE = 1;
 }
 
 /* Vote for the sentinel with 'req_runid' or return the old vote if already
@@ -3781,6 +4012,7 @@ void sentinelSimFailureCrash(void) {
  * If a vote is not available returns NULL, otherwise return the Sentinel
  * runid and populate the leader_epoch with the epoch of the vote. */
 char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
+    volatile int __A_VARIABLE;
     if (req_epoch > sentinel.current_epoch) {
         sentinel.current_epoch = req_epoch;
         sentinelFlushConfig();
@@ -3804,6 +4036,7 @@ char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char
     }
 
     *leader_epoch = master->leader_epoch;
+    __A_VARIABLE = 1;
     return master->leader ? sdsnew(master->leader) : NULL;
 }
 
@@ -3837,6 +4070,7 @@ int sentinelLeaderIncr(dict *counters, char *runid) {
  * the Sentinels we know (ever seen since the last SENTINEL RESET) that
  * reported the same instance as leader for the same epoch. */
 char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
+    volatile int __A_VARIABLE;
     dict *counters;
     dictIterator *di;
     dictEntry *de;
@@ -3898,6 +4132,7 @@ char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
     winner = winner ? sdsnew(winner) : NULL;
     sdsfree(myvote);
     dictRelease(counters);
+    __A_VARIABLE = 1;
     return winner;
 }
 
@@ -3912,6 +4147,7 @@ char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
  * (later) delivery otherwise C_ERR. The command replies are just
  * discarded. */
 int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
+    volatile int __A_VARIABLE;
     char portstr[32];
     int retval;
 
@@ -3937,20 +4173,29 @@ int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s",
         sentinelInstanceMapCommand(ri,"MULTI"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s %s %s",
         sentinelInstanceMapCommand(ri,"SLAVEOF"),
         host, portstr);
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s REWRITE",
         sentinelInstanceMapCommand(ri,"CONFIG"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     /* CLIENT KILL TYPE <type> is only supported starting from Redis 2.8.12,
@@ -3961,20 +4206,28 @@ int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s KILL TYPE normal",
         sentinelInstanceMapCommand(ri,"CLIENT"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s",
         sentinelInstanceMapCommand(ri,"EXEC"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 /* Setup the master state to start a failover. */
 void sentinelStartFailover(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     serverAssert(master->flags & SRI_MASTER);
 
     master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
@@ -3985,6 +4238,7 @@ void sentinelStartFailover(sentinelRedisInstance *master) {
     sentinelEvent(LL_WARNING,"+try-failover",master,"%@");
     master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
     master->failover_state_change_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* This function checks if there are the conditions to start the failover,
@@ -3999,11 +4253,18 @@ void sentinelStartFailover(sentinelRedisInstance *master) {
  *
  * Return non-zero if a failover was started. */
 int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     /* We can't failover if the master is not in O_DOWN state. */
-    if (!(master->flags & SRI_O_DOWN)) return 0;
+    if (!(master->flags & SRI_O_DOWN)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Failover already in progress? */
-    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;
+    if (master->flags & SRI_FAILOVER_IN_PROGRESS) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Last failover attempt started too little time ago? */
     if (mstime() - master->failover_start_time <
@@ -4021,10 +4282,12 @@ int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
                 "Next failover delay: I will not start a failover before %s",
                 ctimebuf);
         }
+        __A_VARIABLE = 1;
         return 0;
     }
 
     sentinelStartFailover(master);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -4089,6 +4352,7 @@ int compareSlavesForPromotion(const void *a, const void *b) {
 }
 
 sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance **instance =
         zmalloc(sizeof(instance[0])*dictSize(master->slaves));
     sentinelRedisInstance *selected = NULL;
@@ -4129,11 +4393,13 @@ sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
         selected = instance[0];
     }
     zfree(instance);
+    __A_VARIABLE = 1;
     return selected;
 }
 
 /* ---------------- Failover state machine implementation ------------------- */
 void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     char *leader;
     int isleader;
 
@@ -4156,6 +4422,7 @@ void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
             sentinelEvent(LL_WARNING,"-failover-abort-not-elected",ri,"%@");
             sentinelAbortFailover(ri);
         }
+        __A_VARIABLE = 1;
         return;
     }
     sentinelEvent(LL_WARNING,"+elected-leader",ri,"%@");
@@ -4164,9 +4431,11 @@ void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
     ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
     ri->failover_state_change_time = mstime();
     sentinelEvent(LL_WARNING,"+failover-state-select-slave",ri,"%@");
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *slave = sentinelSelectSlave(ri);
 
     /* We don't handle the timeout in this state as the function aborts
@@ -4183,9 +4452,11 @@ void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
         sentinelEvent(LL_NOTICE,"+failover-state-send-slaveof-noone",
             slave, "%@");
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     int retval;
 
     /* We can't send the command to the promoted slave if it is now
@@ -4196,6 +4467,7 @@ void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
             sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
             sentinelAbortFailover(ri);
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -4204,25 +4476,32 @@ void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
      * really care about the reply. We check if it worked indirectly observing
      * if INFO returns a different role (master instead of slave). */
     retval = sentinelSendSlaveOf(ri->promoted_slave,NULL,0);
-    if (retval != C_OK) return;
+    if (retval != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     sentinelEvent(LL_NOTICE, "+failover-state-wait-promotion",
         ri->promoted_slave,"%@");
     ri->failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
     ri->failover_state_change_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* We actually wait for promotion indirectly checking with INFO when the
  * slave turns into a master. */
 void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     /* Just handle the timeout. Switching to the next state is handled
      * by the function parsing the INFO command of the promoted slave. */
     if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
         sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
         sentinelAbortFailover(ri);
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     int not_reconfigured = 0, timeout = 0;
     dictIterator *di;
     dictEntry *de;
@@ -4231,7 +4510,10 @@ void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
     /* We can't consider failover finished if the promoted slave is
      * not reachable. */
     if (master->promoted_slave == NULL ||
-        master->promoted_slave->flags & SRI_S_DOWN) return;
+        master->promoted_slave->flags & SRI_S_DOWN) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* The failover terminates once all the reachable slaves are properly
      * configured. */
@@ -4283,11 +4565,13 @@ void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send SLAVE OF <new master address> to all the remaining slaves that
  * still don't appear to have the configuration updated. */
 void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     int in_progress = 0;
@@ -4344,12 +4628,14 @@ void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
 
     /* Check if all the slaves are reconfigured and handle timeout. */
     sentinelFailoverDetectEnd(master);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the slave is in
  * SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state. In this state we need
  * to remove it from the master table and add the promoted slave instead. */
 void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
+    volatile int __A_VARIABLE;
     sentinelRedisInstance *ref = master->promoted_slave ?
                                  master->promoted_slave : master;
 
@@ -4358,12 +4644,17 @@ void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
         ref->addr->ip, ref->addr->port);
 
     sentinelResetMasterAndChangeAddress(master,ref->addr->ip,ref->addr->port);
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     serverAssert(ri->flags & SRI_MASTER);
 
-    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;
+    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) {
+            __A_VARIABLE = 1;
+            return;
+    }
 
     switch(ri->failover_state) {
         case SENTINEL_FAILOVER_STATE_WAIT_START:
@@ -4382,6 +4673,7 @@ void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
             sentinelFailoverReconfNextSlave(ri);
             break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Abort a failover in progress:
@@ -4390,6 +4682,7 @@ void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
  * the slave -> master switch. Otherwise the failover can't be aborted and
  * will reach its end (possibly by timeout). */
 void sentinelAbortFailover(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     serverAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
     serverAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
 
@@ -4400,6 +4693,7 @@ void sentinelAbortFailover(sentinelRedisInstance *ri) {
         ri->promoted_slave->flags &= ~SRI_PROMOTED;
         ri->promoted_slave = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ======================== SENTINEL timer handler ==========================
@@ -4409,6 +4703,7 @@ void sentinelAbortFailover(sentinelRedisInstance *ri) {
 
 /* Perform scheduled operations for the specified Redis instance. */
 void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
+    volatile int __A_VARIABLE;
     /* ========== MONITORING HALF ============ */
     /* Every kind of instance */
     sentinelReconnectInstance(ri);
@@ -4419,7 +4714,10 @@ void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
      * TILT happens when we find something odd with the time, like a
      * sudden change in the clock. */
     if (sentinel.tilt) {
-        if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) return;
+        if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) {
+            __A_VARIABLE = 1;
+            return;
+        }
         sentinel.tilt = 0;
         sentinelEvent(LL_WARNING,"-tilt",NULL,"#tilt mode exited");
     }
@@ -4440,11 +4738,13 @@ void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
         sentinelFailoverStateMachine(ri);
         sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Perform scheduled operations for all the instances in the dictionary.
  * Recursively call the function against dictionaries of slaves. */
 void sentinelHandleDictOfRedisInstances(dict *instances) {
+    volatile int __A_VARIABLE;
     dictIterator *di;
     dictEntry *de;
     sentinelRedisInstance *switch_to_promoted = NULL;
@@ -4466,6 +4766,7 @@ void sentinelHandleDictOfRedisInstances(dict *instances) {
     if (switch_to_promoted)
         sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function checks if we need to enter the TITL mode.
@@ -4488,6 +4789,7 @@ void sentinelHandleDictOfRedisInstances(dict *instances) {
  *
  * During TILT time we still collect information, we just do not act. */
 void sentinelCheckTiltCondition(void) {
+    volatile int __A_VARIABLE;
     mstime_t now = mstime();
     mstime_t delta = now - sentinel.previous_time;
 
@@ -4497,9 +4799,11 @@ void sentinelCheckTiltCondition(void) {
         sentinelEvent(LL_WARNING,"+tilt",NULL,"#tilt mode entered");
     }
     sentinel.previous_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 void sentinelTimer(void) {
+    volatile int __A_VARIABLE;
     sentinelCheckTiltCondition();
     sentinelHandleDictOfRedisInstances(sentinel.masters);
     sentinelRunPendingScripts();
@@ -4513,5 +4817,6 @@ void sentinelTimer(void) {
      * same time again and again (resulting in nobody likely winning the
      * election because of split brain voting). */
     server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/server.c b/src/server.c
index ecc7325..e241066 100644
--- a/src/server.c
+++ b/src/server.c
@@ -61,6 +61,7 @@
 int gettimeofday(struct timeval *tv, void *tz);
 static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 {
+	volatile int __A_VARIABLE;
 	int now;
 	struct timeval _ptimeval __attribute__((flexos_whitelist));
 	/* this argument is actually obsolete */
@@ -70,6 +71,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -355,6 +357,7 @@ void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);
 /* Low level logging. To use only for very big messages, otherwise
  * serverLog() is to prefer. */
 void serverLogRaw(int level, const char *msg) {
+    volatile int __A_VARIABLE;
     const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
     const char *c = ".-*#";
     FILE *fp;
@@ -363,10 +366,16 @@ void serverLogRaw(int level, const char *msg) {
     int log_to_stdout = server.logfile[0] == '\0';
 
     level &= 0xff; /* clear flags */
-    if (level < server.verbosity) return;
+    if (level < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     fp = log_to_stdout ? stdout : fopen(server.logfile,"a");
-    if (!fp) return;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (rawmode) {
         fprintf(fp,"%s",msg);
@@ -395,22 +404,28 @@ void serverLogRaw(int level, const char *msg) {
 
     if (!log_to_stdout) fclose(fp);
     if (server.syslog_enabled) syslog(syslogLevelMap[level], "%s", msg);
+    __A_VARIABLE = 1;
 }
 
 /* Like serverLogRaw() but with printf-alike support. This is the function that
  * is used across the code. The raw version is only used in order to dump
  * the INFO output on crash. */
 void serverLog(int level, const char *fmt, ...) {
+    volatile int __A_VARIABLE;
     va_list ap;
     char msg[LOG_MAX_LEN];
 
-    if ((level&0xff) < server.verbosity) return;
+    if ((level&0xff) < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     va_start(ap, fmt);
     vsnprintf(msg, sizeof(msg), fmt, ap);
     va_end(ap);
 
     serverLogRaw(level,msg);
+    __A_VARIABLE = 1;
 }
 
 /* Log a fixed message without printf-alike capabilities, in a way that is
@@ -420,15 +435,21 @@ void serverLog(int level, const char *fmt, ...) {
  * of view of Redis. Signals that are going to kill the server anyway and
  * where we need printf-alike features are served by serverLog(). */
 void serverLogFromHandler(int level, const char *msg) {
+    volatile int __A_VARIABLE;
     int fd;
     int log_to_stdout = server.logfile[0] == '\0';
     char buf[64];
 
-    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
+    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize)) {
+        __A_VARIABLE = 1;
         return;
+    }
     fd = log_to_stdout ? STDOUT_FILENO :
                          open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
-    if (fd == -1) return;
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ll2string(buf,sizeof(buf),getpid());
     if (write(fd,buf,strlen(buf)) == -1) goto err;
     if (write(fd,":signal-handler (",17) == -1) goto err;
@@ -439,21 +460,26 @@ void serverLogFromHandler(int level, const char *msg) {
     if (write(fd,"\n",1) == -1) goto err;
 err:
     if (!log_to_stdout) close(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Return the UNIX time in microseconds */
 long long ustime(void) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
     long long ust;
 
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 /* Return the UNIX time in milliseconds */
 mstime_t mstime(void) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ustime()/1000;
 }
 
@@ -462,11 +488,13 @@ mstime_t mstime(void) {
  * the parent process. However if we are testing the coverage normal exit() is
  * used in order to obtain the right coverage information. */
 void exitFromChild(int retcode) {
+    volatile int __A_VARIABLE;
 #ifdef COVERAGE_TEST
     exit(retcode);
 #else
     _exit(retcode);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /*====================== Hash table type implementation  ==================== */
@@ -477,25 +505,34 @@ void exitFromChild(int retcode) {
 
 void dictVanillaFree(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
     zfree(val);
+    __A_VARIABLE = 1;
 }
 
 void dictListDestructor(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
     listRelease((list*)val);
+    __A_VARIABLE = 1;
 }
 
 int dictSdsKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
+    volatile int __A_VARIABLE;
     int l1,l2;
     DICT_NOTUSED(privdata);
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
@@ -504,61 +541,82 @@ int dictSdsKeyCompare(void *privdata, const void *key1,
 int dictSdsKeyCaseCompare(void *privdata, const void *key1,
         const void *key2)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
 
+    __A_VARIABLE = 1;
     return strcasecmp(key1, key2) == 0;
 }
 
 void dictObjectDestructor(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
 
-    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
+    if (val == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Lazy freeing will set value to NULL. */
     decrRefCount(val);
+    __A_VARIABLE = 1;
 }
 
 void dictSdsDestructor(void *privdata, void *val)
 {
+    volatile int __A_VARIABLE;
     DICT_NOTUSED(privdata);
 
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 int dictObjKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
+    volatile int __A_VARIABLE;
     const robj *o1 = key1, *o2 = key2;
+    __A_VARIABLE = 1;
     return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
 }
 
 uint64_t dictObjHash(const void *key) {
+    volatile int __A_VARIABLE;
     const robj *o = key;
+    __A_VARIABLE = 1;
     return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
 }
 
 uint64_t dictSdsHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 uint64_t dictSdsCaseHash(const void *key) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 int dictEncObjKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
+    volatile int __A_VARIABLE;
     robj *o1 = (robj*) key1, *o2 = (robj*) key2;
     int cmp;
 
     if (o1->encoding == OBJ_ENCODING_INT &&
-        o2->encoding == OBJ_ENCODING_INT)
+        o2->encoding == OBJ_ENCODING_INT) {
+            __A_VARIABLE = 1;
             return o1->ptr == o2->ptr;
+    }
 
     o1 = getDecodedObject(o1);
     o2 = getDecodedObject(o2);
     cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
     decrRefCount(o1);
     decrRefCount(o2);
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -747,10 +805,12 @@ dictType replScriptCacheDictType = {
 };
 
 int htNeedsResize(dict *dict) {
+    volatile int __A_VARIABLE;
     long long size, used;
 
     size = dictSlots(dict);
     used = dictSize(dict);
+    __A_VARIABLE = 1;
     return (size > DICT_HT_INITIAL_SIZE &&
             (used*100/size < HASHTABLE_MIN_FILL));
 }
@@ -758,10 +818,12 @@ int htNeedsResize(dict *dict) {
 /* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL
  * we resize the hash table to save memory */
 void tryResizeHashTables(int dbid) {
+    volatile int __A_VARIABLE;
     if (htNeedsResize(server.db[dbid].dict))
         dictResize(server.db[dbid].dict);
     if (htNeedsResize(server.db[dbid].expires))
         dictResize(server.db[dbid].expires);
+    __A_VARIABLE = 1;
 }
 
 /* Our hash table implementation performs rehashing incrementally while
@@ -772,16 +834,20 @@ void tryResizeHashTables(int dbid) {
  * The function returns 1 if some rehashing was performed, otherwise 0
  * is returned. */
 int incrementallyRehash(int dbid) {
+    volatile int __A_VARIABLE;
     /* Keys dictionary */
     if (dictIsRehashing(server.db[dbid].dict)) {
         dictRehashMilliseconds(server.db[dbid].dict,1);
+        __A_VARIABLE = 1;
         return 1; /* already used our millisecond for this loop... */
     }
     /* Expires */
     if (dictIsRehashing(server.db[dbid].expires)) {
         dictRehashMilliseconds(server.db[dbid].expires,1);
+        __A_VARIABLE = 1;
         return 1; /* already used our millisecond for this loop... */
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -792,16 +858,19 @@ int incrementallyRehash(int dbid) {
  * for dict.c to resize the hash tables accordingly to the fact we have o not
  * running childs. */
 void updateDictResizePolicy(void) {
+    volatile int __A_VARIABLE;
     if (server.rdb_child_pid == -1 && server.aof_child_pid == -1)
         dictEnableResize();
     else
         dictDisableResize();
+    __A_VARIABLE = 1;
 }
 
 /* ======================= Cron: called every 100 ms ======================== */
 
 /* Add a sample to the operations per second array of samples. */
 void trackInstantaneousMetric(int metric, long long current_reading) {
+    volatile int __A_VARIABLE;
     long long t = mstime() - server.inst_metric[metric].last_sample_time;
     long long ops = current_reading -
                     server.inst_metric[metric].last_sample_count;
@@ -815,15 +884,18 @@ void trackInstantaneousMetric(int metric, long long current_reading) {
     server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
     server.inst_metric[metric].last_sample_time = mstime();
     server.inst_metric[metric].last_sample_count = current_reading;
+    __A_VARIABLE = 1;
 }
 
 /* Return the mean of all the samples. */
 long long getInstantaneousMetric(int metric) {
+    volatile int __A_VARIABLE;
     int j;
     long long sum = 0;
 
     for (j = 0; j < STATS_METRIC_SAMPLES; j++)
         sum += server.inst_metric[metric].samples[j];
+    __A_VARIABLE = 1;
     return sum / STATS_METRIC_SAMPLES;
 }
 
@@ -868,6 +940,7 @@ int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
  *
  * The function always returns 0 as it never terminates the client. */
 int clientsCronResizeQueryBuffer(client *c) {
+    volatile int __A_VARIABLE;
     size_t querybuf_size = sdsAllocSize(c->querybuf);
     time_t idletime = server.unixtime - c->lastinteraction;
 
@@ -904,6 +977,7 @@ int clientsCronResizeQueryBuffer(client *c) {
             c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -924,6 +998,7 @@ size_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
 size_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
 
 int clientsCronTrackExpansiveClients(client *c) {
+    volatile int __A_VARIABLE;
     size_t in_usage = sdsAllocSize(c->querybuf);
     size_t out_usage = getClientOutputBufferMemoryUsage(c);
     int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
@@ -947,12 +1022,14 @@ int clientsCronTrackExpansiveClients(client *c) {
     if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;
     if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;
 
+    __A_VARIABLE = 1;
     return 0; /* This function never terminates the client. */
 }
 
 /* Return the max samples in the memory usage of clients tracked by
  * the function clientsCronTrackExpansiveClients(). */
 void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
+    volatile int __A_VARIABLE;
     size_t i = 0, o = 0;
     for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
         if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
@@ -960,6 +1037,7 @@ void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
     }
     *in_usage = i;
     *out_usage = o;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by serverCron() and is used in order to perform
@@ -979,6 +1057,7 @@ void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
  */
 #define CLIENTS_CRON_MIN_ITERATIONS 5
 void clientsCron(void) {
+    volatile int __A_VARIABLE;
     /* Try to process at least numclients/server.hz of clients
      * per call. Since normally (if there are no big latency events) this
      * function is called server.hz times per second, in the average case we
@@ -1011,12 +1090,14 @@ void clientsCron(void) {
         if (clientsCronResizeQueryBuffer(c)) continue;
         if (clientsCronTrackExpansiveClients(c)) continue;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function handles 'background' operations we are required to do
  * incrementally in Redis databases, such as active key expiring, resizing,
  * rehashing. */
 void databasesCron(void) {
+    volatile int __A_VARIABLE;
     /* Expire keys by random sampling. Not required for slaves
      * as master will synthesize DELs for us. */
     if (server.active_expire_enabled) {
@@ -1068,6 +1149,7 @@ void databasesCron(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* We take a cached value of the unix time in the global state because with
@@ -1075,6 +1157,7 @@ void databasesCron(void) {
  * every object access, and accuracy is not needed. To access a global var is
  * a lot faster than calling time(NULL) */
 void updateCachedTime(void) {
+    volatile int __A_VARIABLE;
     time_t unixtime = time(NULL);
     atomicSet(server.unixtime,unixtime);
     server.mstime = mstime();
@@ -1086,6 +1169,7 @@ void updateCachedTime(void) {
     struct tm tm;
     localtime_r(&server.unixtime,&tm);
     server.daylight_active = tm.tm_isdst;
+    __A_VARIABLE = 1;
 }
 
 /* This is our timer interrupt, called server.hz times per second.
@@ -1377,6 +1461,7 @@ int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
  * main loop of the event driven library, that is, before to sleep
  * for ready file descriptors. */
 void beforeSleep(struct aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     UNUSED(eventLoop);
 
     /* Call the Redis Cluster before sleep function. Note that this function
@@ -1428,19 +1513,23 @@ void beforeSleep(struct aeEventLoop *eventLoop) {
      * releasing the GIL. Redis main thread will not touch anything at this
      * time. */
     if (moduleCount()) moduleReleaseGIL();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called immadiately after the event loop multiplexing
  * API returned, and the control is going to soon return to Redis by invoking
  * the different events callbacks. */
 void afterSleep(struct aeEventLoop *eventLoop) {
+    volatile int __A_VARIABLE;
     UNUSED(eventLoop);
     if (moduleCount()) moduleAcquireGIL();
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Server initialization ======================== */
 
 void createSharedObjects(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     shared.crlf = createObject(OBJ_STRING,sdsnew("\r\n"));
@@ -1533,9 +1622,11 @@ void createSharedObjects(void) {
      * string in string comparisons for the ZRANGEBYLEX command. */
     shared.minstring = sdsnew("minstring");
     shared.maxstring = sdsnew("maxstring");
+    __A_VARIABLE = 1;
 }
 
 void initServerConfig(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     pthread_mutex_init(&server.next_client_id_mutex,NULL);
@@ -1745,6 +1836,7 @@ void initServerConfig(void) {
      * script to the slave / AOF. This is the new way starting from
      * Redis 5. However it is possible to revert it via redis.conf. */
     server.lua_always_replicate_commands = 1;
+    __A_VARIABLE = 1;
 }
 
 extern char **environ;
@@ -1765,6 +1857,7 @@ extern char **environ;
  * On success the function does not return, because the process turns into
  * a different process. On error C_ERR is returned. */
 int restartServer(int flags, mstime_t delay) {
+    volatile int __A_VARIABLE;
     int j;
 
     /* Check if we still have accesses to the executable that started this
@@ -1772,6 +1865,7 @@ int restartServer(int flags, mstime_t delay) {
     if (access(server.executable,X_OK) == -1) {
         serverLog(LL_WARNING,"Can't restart: this process has no "
                              "permissions to execute %s", server.executable);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1782,6 +1876,7 @@ int restartServer(int flags, mstime_t delay) {
     {
         serverLog(LL_WARNING,"Can't restart: configuration rewrite process "
                              "failed");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1790,6 +1885,7 @@ int restartServer(int flags, mstime_t delay) {
         prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)
     {
         serverLog(LL_WARNING,"Can't restart: error preparing for shutdown");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1810,6 +1906,7 @@ int restartServer(int flags, mstime_t delay) {
     /* If an error occurred here, there is nothing we can do, but exit. */
     _exit(1);
 
+    __A_VARIABLE = 1;
     return C_ERR; /* Never reached. */
 }
 
@@ -1822,6 +1919,7 @@ int restartServer(int flags, mstime_t delay) {
  * max number of clients, the function will do the reverse setting
  * server.maxclients to the value that we can actually handle. */
 void adjustOpenFilesLimit(void) {
+    volatile int __A_VARIABLE;
     rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
     struct rlimit limit;
 
@@ -1894,6 +1992,7 @@ void adjustOpenFilesLimit(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Check that server.tcp_backlog can be actually enforced in Linux according
@@ -1932,6 +2031,7 @@ void checkTcpBacklogSettings(void) {
  * configuration but the function is not able to bind * for at least
  * one of the IPv4 or IPv6 protocols. */
 int listenToPort(int port, int *fds, int *count) {
+    volatile int __A_VARIABLE;
     int j;
 
     /* Force binding of 0.0.0.0 if no bind address is specified, always
@@ -1986,11 +2086,13 @@ int listenToPort(int port, int *fds, int *count) {
                     errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||
                     errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)
                     continue;
+            __A_VARIABLE = 1;
             return C_ERR;
         }
         anetNonBlock(NULL,fds[*count]);
         (*count)++;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1998,6 +2100,7 @@ int listenToPort(int port, int *fds, int *count) {
  * to reset via CONFIG RESETSTAT. The function is also used in order to
  * initialize these fields in initServer() at server startup. */
 void resetServerStats(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     server.stat_numcommands = 0;
@@ -2029,9 +2132,11 @@ void resetServerStats(void) {
     server.stat_net_input_bytes = 0;
     server.stat_net_output_bytes = 0;
     server.aof_delayed_fsync = 0;
+    __A_VARIABLE = 1;
 }
 
 void initServer(void) {
+    volatile int __A_VARIABLE;
     int j;
 
     signal(SIGHUP, SIG_IGN);
@@ -2200,11 +2305,13 @@ void initServer(void) {
     latencyMonitorInit();
     bioInit();
     server.initial_memory_usage = zmalloc_used_memory();
+    __A_VARIABLE = 1;
 }
 
 /* Populates the Redis Command Table starting from the hard coded list
  * we have on top of redis.c file. */
 void populateCommandTable(void) {
+    volatile int __A_VARIABLE;
     int j;
     int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);
 
@@ -2239,9 +2346,11 @@ void populateCommandTable(void) {
         retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);
         serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
     }
+    __A_VARIABLE = 1;
 }
 
 void resetCommandTableStats(void) {
+    volatile int __A_VARIABLE;
     struct redisCommand *c;
     dictEntry *de;
     dictIterator *di;
@@ -2254,18 +2363,22 @@ void resetCommandTableStats(void) {
     }
     dictReleaseIterator(di);
 
+    __A_VARIABLE = 1;
 }
 
 /* ========================== Redis OP Array API ============================ */
 
 void redisOpArrayInit(redisOpArray *oa) {
+    volatile int __A_VARIABLE;
     oa->ops = NULL;
     oa->numops = 0;
+    __A_VARIABLE = 1;
 }
 
 int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
                        robj **argv, int argc, int target)
 {
+    volatile int __A_VARIABLE;
     redisOp *op;
 
     oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));
@@ -2276,10 +2389,12 @@ int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
     op->argc = argc;
     op->target = target;
     oa->numops++;
+    __A_VARIABLE = 1;
     return oa->numops;
 }
 
 void redisOpArrayFree(redisOpArray *oa) {
+    volatile int __A_VARIABLE;
     while(oa->numops) {
         int j;
         redisOp *op;
@@ -2291,20 +2406,25 @@ void redisOpArrayFree(redisOpArray *oa) {
         zfree(op->argv);
     }
     zfree(oa->ops);
+    __A_VARIABLE = 1;
 }
 
 /* ====================== Commands lookup and execution ===================== */
 
 struct redisCommand *lookupCommand(sds name) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return dictFetchValue(server.commands, name);
 }
 
 struct redisCommand *lookupCommandByCString(char *s) {
+    volatile int __A_VARIABLE;
     struct redisCommand *cmd;
     sds name = sdsnew(s);
 
     cmd = dictFetchValue(server.commands, name);
     sdsfree(name);
+    __A_VARIABLE = 1;
     return cmd;
 }
 
@@ -2316,9 +2436,11 @@ struct redisCommand *lookupCommandByCString(char *s) {
  * rewriteClientCommandVector() in order to set client->cmd pointer
  * correctly even if the command was renamed. */
 struct redisCommand *lookupCommandOrOriginal(sds name) {
+    volatile int __A_VARIABLE;
     struct redisCommand *cmd = dictFetchValue(server.commands, name);
 
     if (!cmd) cmd = dictFetchValue(server.orig_commands,name);
+    __A_VARIABLE = 1;
     return cmd;
 }
 
@@ -2336,10 +2458,12 @@ struct redisCommand *lookupCommandOrOriginal(sds name) {
 void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
                int flags)
 {
+    volatile int __A_VARIABLE;
     if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)
         feedAppendOnlyFile(cmd,dbid,argv,argc);
     if (flags & PROPAGATE_REPL)
         replicationFeedSlaves(server.slaves,dbid,argv,argc);
+    __A_VARIABLE = 1;
 }
 
 /* Used inside commands to schedule the propagation of additional commands
@@ -2357,10 +2481,14 @@ void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
 void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
                    int target)
 {
+    volatile int __A_VARIABLE;
     robj **argvcopy;
     int j;
 
-    if (server.loading) return; /* No propagation during loading. */
+    if (server.loading) {
+        __A_VARIABLE = 1;
+        return;
+    } /* No propagation during loading. */
 
     argvcopy = zmalloc(sizeof(robj*)*argc);
     for (j = 0; j < argc; j++) {
@@ -2368,31 +2496,40 @@ void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
         incrRefCount(argv[j]);
     }
     redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);
+    __A_VARIABLE = 1;
 }
 
 /* It is possible to call the function forceCommandPropagation() inside a
  * Redis command implementation in order to to force the propagation of a
  * specific command execution into AOF / Replication. */
 void forceCommandPropagation(client *c, int flags) {
+    volatile int __A_VARIABLE;
     if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
     if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
+    __A_VARIABLE = 1;
 }
 
 /* Avoid that the executed command is propagated at all. This way we
  * are free to just propagate what we want using the alsoPropagate()
  * API. */
 void preventCommandPropagation(client *c) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_PREVENT_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* AOF specific version of preventCommandPropagation(). */
 void preventCommandAOF(client *c) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_PREVENT_AOF_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* Replication specific version of preventCommandPropagation(). */
 void preventCommandReplication(client *c) {
+    volatile int __A_VARIABLE;
     c->flags |= CLIENT_PREVENT_REPL_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* Call() is the core of Redis execution of a command.
@@ -2433,6 +2570,7 @@ void preventCommandReplication(client *c) {
  *
  */
 void call(client *c, int flags) {
+    volatile int __A_VARIABLE;
     long long dirty, start, duration;
     int client_old_flags = c->flags;
     struct redisCommand *real_cmd = c->cmd;
@@ -2551,6 +2689,7 @@ void call(client *c, int flags) {
     }
     server.also_propagate = prev_also_propagate;
     server.stat_numcommands++;
+    __A_VARIABLE = 1;
 }
 
 /* If this function gets called we already read a whole
@@ -2762,6 +2901,7 @@ int processCommand(client *c) {
 /* Close listening sockets. Also unlink the unix domain socket if
  * unlink_unix_socket is non-zero. */
 void closeListeningSockets(int unlink_unix_socket) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);
@@ -2772,9 +2912,11 @@ void closeListeningSockets(int unlink_unix_socket) {
         serverLog(LL_NOTICE,"Removing the unix socket file.");
         unlink(server.unixsocket); /* don't care if this fails */
     }
+    __A_VARIABLE = 1;
 }
 
 int prepareForShutdown(int flags) {
+    volatile int __A_VARIABLE;
     int save = flags & SHUTDOWN_SAVE;
     int nosave = flags & SHUTDOWN_NOSAVE;
 
@@ -2800,6 +2942,7 @@ int prepareForShutdown(int flags) {
              * shutdown or else the dataset will be lost. */
             if (server.aof_state == AOF_WAIT_REWRITE) {
                 serverLog(LL_WARNING, "Writing initial AOF, can't exit.");
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
             serverLog(LL_WARNING,
@@ -2825,6 +2968,7 @@ int prepareForShutdown(int flags) {
              * saving aborted, handling special stuff like slaves pending for
              * synchronization... */
             serverLog(LL_WARNING,"Error trying to save the DB, can't exit.");
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
@@ -2843,6 +2987,7 @@ int prepareForShutdown(int flags) {
     closeListeningSockets(1);
     serverLog(LL_WARNING,"%s is now ready to exit, bye bye...",
         server.sentinel_mode ? "Sentinel" : "Redis");
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2884,6 +3029,7 @@ int writeCommandsDeniedByDiskError(void) {
  * possible branch misprediction related leak.
  */
 int time_independent_strcmp(char *a, char *b) {
+    volatile int __A_VARIABLE;
     char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];
     /* The above two strlen perform len(a) + len(b) operations where either
      * a or b are fixed (our password) length, and the difference is only
@@ -2897,7 +3043,10 @@ int time_independent_strcmp(char *a, char *b) {
     /* We can't compare strings longer than our static buffers.
      * Note that this will never pass the first test in practical circumstances
      * so there is no info leak. */
-    if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;
+    if (alen > sizeof(bufa) || blen > sizeof(bufb)) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
 
     memset(bufa,0,sizeof(bufa));        /* Constant time. */
     memset(bufb,0,sizeof(bufb));        /* Constant time. */
@@ -2913,10 +3062,12 @@ int time_independent_strcmp(char *a, char *b) {
     }
     /* Length must be equal as well. */
     diff |= alen ^ blen;
+    __A_VARIABLE = 1;
     return diff; /* If zero strings are the same. */
 }
 
 void authCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (!server.requirepass) {
         addReplyError(c,"Client sent AUTH, but no password is set");
     } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
@@ -2926,15 +3077,18 @@ void authCommand(client *c) {
       c->authenticated = 0;
       addReplyError(c,"invalid password");
     }
+    __A_VARIABLE = 1;
 }
 
 /* The PING command. It works in a different way if the client is in
  * in Pub/Sub mode. */
 void pingCommand(client *c) {
+    volatile int __A_VARIABLE;
     /* The command takes zero or one arguments. */
     if (c->argc > 2) {
         addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
             c->cmd->name);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2951,13 +3105,17 @@ void pingCommand(client *c) {
         else
             addReplyBulk(c,c->argv[1]);
     }
+    __A_VARIABLE = 1;
 }
 
 void echoCommand(client *c) {
+    volatile int __A_VARIABLE;
     addReplyBulk(c,c->argv[1]);
+    __A_VARIABLE = 1;
 }
 
 void timeCommand(client *c) {
+    volatile int __A_VARIABLE;
     struct timeval tv;
 
     /* gettimeofday() can only fail if &tv is a bad address so we
@@ -2966,19 +3124,24 @@ void timeCommand(client *c) {
     addReplyMultiBulkLen(c,2);
     addReplyBulkLongLong(c,tv.tv_sec);
     addReplyBulkLongLong(c,tv.tv_usec);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for addReplyCommand() to output flags. */
 int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {
+    volatile int __A_VARIABLE;
     if (cmd->flags & f) {
         addReplyStatus(c, reply);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Output the representation of a Redis command. Used by the COMMAND command. */
 void addReplyCommand(client *c, struct redisCommand *cmd) {
+    volatile int __A_VARIABLE;
     if (!cmd) {
         addReply(c, shared.nullbulk);
     } else {
@@ -3014,6 +3177,7 @@ void addReplyCommand(client *c, struct redisCommand *cmd) {
         addReplyLongLong(c, cmd->lastkey);
         addReplyLongLong(c, cmd->keystep);
     }
+    __A_VARIABLE = 1;
 }
 
 /* COMMAND <subcommand> <args> */
@@ -3078,6 +3242,7 @@ NULL
 /* Convert an amount of bytes into a human readable string in the form
  * of 100B, 2G, 100M, 4K, and so forth. */
 static void bytesToHuman(char *s, unsigned long long n) {
+    volatile int __A_VARIABLE;
     double d;
 
     if (n < 1024) {
@@ -3102,12 +3267,14 @@ static void bytesToHuman(char *s, unsigned long long n) {
         /* Let's hope we never need this */
         sprintf(s,"%lluB",n);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create the string returned by the INFO command. This is decoupled
  * by the INFO command itself as we need to report the same information
  * on memory corruption problems. */
 sds genRedisInfoString(char *section) {
+    volatile int __A_VARIABLE;
     sds info = sdsempty();
     time_t uptime = server.unixtime-server.stat_starttime;
     int j;
@@ -3660,56 +3827,74 @@ sds genRedisInfoString(char *section) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return info;
 }
 
 void infoCommand(client *c) {
+    volatile int __A_VARIABLE;
     char *section = c->argc == 2 ? c->argv[1]->ptr : "default";
 
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     addReplyBulkSds(c, genRedisInfoString(section));
+    __A_VARIABLE = 1;
 }
 
 void monitorCommand(client *c) {
+    volatile int __A_VARIABLE;
     /* ignore MONITOR if already slave or in monitor mode */
-    if (c->flags & CLIENT_SLAVE) return;
+    if (c->flags & CLIENT_SLAVE) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
     listAddNodeTail(server.monitors,c);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* =================================== Main! ================================ */
 
 #ifdef __linux__
 int linuxOvercommitMemoryValue(void) {
+    volatile int __A_VARIABLE;
     FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
     char buf[64];
 
-    if (!fp) return -1;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     if (fgets(buf,64,fp) == NULL) {
         fclose(fp);
+        __A_VARIABLE = 1;
         return -1;
     }
     fclose(fp);
 
+    __A_VARIABLE = 1;
     return atoi(buf);
 }
 
 void linuxMemoryWarnings(void) {
+    volatile int __A_VARIABLE;
     if (linuxOvercommitMemoryValue() == 0) {
         serverLog(LL_WARNING,"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.");
     }
     if (THPIsEnabled()) {
         serverLog(LL_WARNING,"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.");
     }
+    __A_VARIABLE = 1;
 }
 #endif /* __linux__ */
 
 void createPidFile(void) {
+    volatile int __A_VARIABLE;
     /* If pidfile requested, but no pidfile defined, use
      * default pidfile path */
     if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);
@@ -3720,9 +3905,11 @@ void createPidFile(void) {
         fprintf(fp,"%d\n",(int)getpid());
         fclose(fp);
     }
+    __A_VARIABLE = 1;
 }
 
 void daemonize(void) {
+    volatile int __A_VARIABLE;
     int fd;
 
     if (fork() != 0) exit(0); /* parent exits */
@@ -3737,9 +3924,11 @@ void daemonize(void) {
         dup2(fd, STDERR_FILENO);
         if (fd > STDERR_FILENO) close(fd);
     }
+    __A_VARIABLE = 1;
 }
 
 void version(void) {
+    volatile int __A_VARIABLE;
     printf("Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n",
         REDIS_VERSION,
         redisGitSHA1(),
@@ -3748,9 +3937,11 @@ void version(void) {
         sizeof(long) == 4 ? 32 : 64,
         (unsigned long long) redisBuildId());
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 void usage(void) {
+    volatile int __A_VARIABLE;
     fprintf(stderr,"Usage: ./redis-server [/path/to/redis.conf] [options]\n");
     fprintf(stderr,"       ./redis-server - (read config from stdin)\n");
     fprintf(stderr,"       ./redis-server -v or --version\n");
@@ -3765,9 +3956,11 @@ void usage(void) {
     fprintf(stderr,"Sentinel mode:\n");
     fprintf(stderr,"       ./redis-server /etc/sentinel.conf --sentinel\n");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 void redisAsciiArt(void) {
+    volatile int __A_VARIABLE;
 #include "asciilogo.h"
     char *buf = zmalloc(1024*16);
     char *mode;
@@ -3801,9 +3994,11 @@ void redisAsciiArt(void) {
         serverLogRaw(LL_NOTICE|LL_RAW,buf);
     }
     zfree(buf);
+    __A_VARIABLE = 1;
 }
 
 static void sigShutdownHandler(int sig) {
+    volatile int __A_VARIABLE;
     char *msg;
 
     switch (sig) {
@@ -3832,9 +4027,11 @@ static void sigShutdownHandler(int sig) {
 
     serverLogFromHandler(LL_WARNING, msg);
     server.shutdown_asap = 1;
+    __A_VARIABLE = 1;
 }
 
 void setupSignalHandlers(void) {
+    volatile int __A_VARIABLE;
     struct sigaction act;
 
     /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
@@ -3854,6 +4051,7 @@ void setupSignalHandlers(void) {
     sigaction(SIGFPE, &act, NULL);
     sigaction(SIGILL, &act, NULL);
 #endif
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -3862,16 +4060,25 @@ void memtest(size_t megabytes, int passes);
 /* Returns 1 if there is --sentinel among the arguments or if
  * argv[0] contains "redis-sentinel". */
 int checkForSentinelMode(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     int j;
 
-    if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
+    if (strstr(argv[0],"redis-sentinel") != NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     for (j = 1; j < argc; j++)
-        if (!strcmp(argv[j],"--sentinel")) return 1;
+        if (!strcmp(argv[j],"--sentinel")) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Function called at startup to load RDB or AOF file in memory. */
 void loadDataFromDisk(void) {
+    volatile int __A_VARIABLE;
     long long start = ustime();
     if (server.aof_state == AOF_ON) {
         if (loadAppendOnlyFile(server.aof_filename) == C_OK)
@@ -3904,15 +4111,19 @@ void loadDataFromDisk(void) {
             exit(1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void redisOutOfMemoryHandler(size_t allocation_size) {
+    volatile int __A_VARIABLE;
     serverLog(LL_WARNING,"Out Of Memory allocating %zu bytes!",
         allocation_size);
     serverPanic("Redis aborting for OUT OF MEMORY");
+    __A_VARIABLE = 1;
 }
 
 void redisSetProcTitle(char *title) {
+    volatile int __A_VARIABLE;
 #ifdef USE_SETPROCTITLE
     char *server_mode = "";
     if (server.cluster_enabled) server_mode = " [cluster]";
@@ -3926,6 +4137,7 @@ void redisSetProcTitle(char *title) {
 #else
     UNUSED(title);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -3933,21 +4145,25 @@ void redisSetProcTitle(char *title) {
  */
 
 int redisSupervisedUpstart(void) {
+    volatile int __A_VARIABLE;
     const char *upstart_job = getenv("UPSTART_JOB");
 
     if (!upstart_job) {
         serverLog(LL_WARNING,
                 "upstart supervision requested, but UPSTART_JOB not found");
+        __A_VARIABLE = 1;
         return 0;
     }
 
     serverLog(LL_NOTICE, "supervised by upstart, will stop to signal readiness");
     raise(SIGSTOP);
     unsetenv("UPSTART_JOB");
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int redisSupervisedSystemd(void) {
+    volatile int __A_VARIABLE;
     const char *notify_socket = getenv("NOTIFY_SOCKET");
     int fd = 1;
     struct sockaddr_un su;
@@ -3958,10 +4174,12 @@ int redisSupervisedSystemd(void) {
     if (!notify_socket) {
         serverLog(LL_WARNING,
                 "systemd supervision requested, but NOTIFY_SOCKET not found");
+        __A_VARIABLE = 1;
         return 0;
     }
 
     if ((strchr("@/", notify_socket[0])) == NULL || strlen(notify_socket) < 2) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -3969,6 +4187,7 @@ int redisSupervisedSystemd(void) {
     if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
         serverLog(LL_WARNING,
                 "Can't connect to systemd socket %s", notify_socket);
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -4000,9 +4219,11 @@ int redisSupervisedSystemd(void) {
     if (ret < 0) {
         serverLog(LL_WARNING, "Can't send notification to systemd");
         close(fd);
+        __A_VARIABLE = 1;
         return 0;
     }
     close(fd);
+    __A_VARIABLE = 1;
     return 1;
 }
 
diff --git a/src/setproctitle.c b/src/setproctitle.c
index 5f91d7b..0b59d23 100644
--- a/src/setproctitle.c
+++ b/src/setproctitle.c
@@ -72,6 +72,8 @@ static struct {
 #endif
 
 static inline size_t spt_min(size_t a, size_t b) {
+	volatile int __A_VARIABLE;
+	__A_VARIABLE = 1;
 	return SPT_MIN(a, b);
 } /* spt_min() */
 
@@ -101,12 +103,15 @@ static int spt_clearenv(void) {
 
 
 static int spt_copyenv(char *oldenv[]) {
+	volatile int __A_VARIABLE;
 	extern char **environ;
 	char *eq;
 	int i, error;
 
-	if (environ != oldenv)
+	if (environ != oldenv) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
 	if ((error = spt_clearenv()))
 		goto error;
@@ -123,15 +128,18 @@ static int spt_copyenv(char *oldenv[]) {
 			goto error;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 error:
 	environ = oldenv;
 
+	__A_VARIABLE = 1;
 	return error;
 } /* spt_copyenv() */
 
 
 static int spt_copyargs(int argc, char *argv[]) {
+	volatile int __A_VARIABLE;
 	char *tmp;
 	int i;
 
@@ -139,23 +147,29 @@ static int spt_copyargs(int argc, char *argv[]) {
 		if (!argv[i])
 			continue;
 
-		if (!(tmp = strdup(argv[i])))
+		if (!(tmp = strdup(argv[i]))) {
+			__A_VARIABLE = 1;
 			return errno;
+		}
 
 		argv[i] = tmp;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 } /* spt_copyargs() */
 
 
 void spt_init(int argc, char *argv[]) {
+        volatile int __A_VARIABLE;
         char **envp = environ;
 	char *base, *end, *nul, *tmp;
 	int i, error;
 
-	if (!(base = argv[0]))
+	if (!(base = argv[0])) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	nul = &base[strlen(base)];
 	end = nul + 1;
@@ -205,11 +219,13 @@ void spt_init(int argc, char *argv[]) {
 	SPT.base = base;
 	SPT.end  = end;
 
+	__A_VARIABLE = 1;
 	return;
 syerr:
 	error = errno;
 error:
 	SPT.error = error;
+	__A_VARIABLE = 1;
 } /* spt_init() */
 
 
@@ -218,13 +234,16 @@ error:
 #endif
 
 void setproctitle(const char *fmt, ...) {
+	volatile int __A_VARIABLE;
 	char buf[SPT_MAXTITLE + 1]; /* use buffer in case argv[0] is passed */
 	va_list ap;
 	char *nul;
 	int len, error;
 
-	if (!SPT.base)
+	if (!SPT.base) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	if (fmt) {
 		va_start(ap, fmt);
@@ -255,9 +274,11 @@ void setproctitle(const char *fmt, ...) {
 		*++nul = '\0';
 	}
 
+	__A_VARIABLE = 1;
 	return;
 error:
 	SPT.error = error;
+	__A_VARIABLE = 1;
 } /* setproctitle() */
 
 
diff --git a/src/sha1.c b/src/sha1.c
index ce487e3..0efe1b7 100644
--- a/src/sha1.c
+++ b/src/sha1.c
@@ -55,6 +55,7 @@ A million repetitions of "a"
 
 void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
 {
+    volatile int __A_VARIABLE;
     uint32_t a, b, c, d, e;
     typedef union {
         unsigned char c[64];
@@ -109,6 +110,7 @@ void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
 #ifdef SHA1HANDSOFF
     memset(block, '\0', sizeof(block));
 #endif
+    __A_VARIABLE = 1;
 }
 
 
@@ -116,6 +118,7 @@ void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
 
 void SHA1Init(SHA1_CTX* context)
 {
+    volatile int __A_VARIABLE;
     /* SHA1 initialization constants */
     context->state[0] = 0x67452301;
     context->state[1] = 0xEFCDAB89;
@@ -123,6 +126,7 @@ void SHA1Init(SHA1_CTX* context)
     context->state[3] = 0x10325476;
     context->state[4] = 0xC3D2E1F0;
     context->count[0] = context->count[1] = 0;
+    __A_VARIABLE = 1;
 }
 
 
@@ -130,6 +134,7 @@ void SHA1Init(SHA1_CTX* context)
 
 void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
 {
+    volatile int __A_VARIABLE;
     uint32_t i, j;
 
     j = context->count[0];
@@ -147,6 +152,7 @@ void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
     }
     else i = 0;
     memcpy(&context->buffer[j], &data[i], len - i);
+    __A_VARIABLE = 1;
 }
 
 
@@ -154,6 +160,7 @@ void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
 
 void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
 {
+    volatile int __A_VARIABLE;
     unsigned i;
     unsigned char finalcount[8];
     unsigned char c;
@@ -194,6 +201,7 @@ void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
     /* Wipe variables */
     memset(context, '\0', sizeof(*context));
     memset(&finalcount, '\0', sizeof(finalcount));
+    __A_VARIABLE = 1;
 }
 /* ================ end of sha1.c ================ */
 
@@ -203,6 +211,7 @@ void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
 #define UNUSED(x) (void)(x)
 int sha1Test(int argc, char **argv)
 {
+    volatile int __A_VARIABLE;
     SHA1_CTX ctx;
     unsigned char hash[20], buf[BUFSIZE];
     int i;
@@ -222,6 +231,7 @@ int sha1Test(int argc, char **argv)
     for(i=0;i<20;i++)
         printf("%02x", hash[i]);
     printf("\n");
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/siphash.c b/src/siphash.c
index 6b94190..a4752a7 100644
--- a/src/siphash.c
+++ b/src/siphash.c
@@ -311,6 +311,7 @@ const uint8_t vectors_sip64[64][8] = {
  * the test revert back the siphash() function to 2-4 rounds since
  * now it uses 1-2 rounds. */
 int siphash_test(void) {
+    volatile int __A_VARIABLE;
     uint8_t in[64], k[16];
     int i;
     int fails = 0;
@@ -343,7 +344,11 @@ int siphash_test(void) {
     h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
     if (h1 == h2) fails++;
 
-    if (!fails) return 0;
+    if (!fails) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
diff --git a/src/slowlog.c b/src/slowlog.c
index 8e183fc..3309022 100644
--- a/src/slowlog.c
+++ b/src/slowlog.c
@@ -46,6 +46,7 @@
  * Incrementing the ref count of all the objects retained is up to
  * this function. */
 slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
+    volatile int __A_VARIABLE;
     slowlogEntry *se = zmalloc(sizeof(*se));
     int j, slargc = argc;
 
@@ -90,6 +91,7 @@ slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long dur
     se->id = server.slowlog_entry_id++;
     se->peerid = sdsnew(getClientPeerId(c));
     se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();
+    __A_VARIABLE = 1;
     return se;
 }
 
@@ -98,6 +100,7 @@ slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long dur
  *
  * This function will take care to release all the retained object. */
 void slowlogFreeEntry(void *septr) {
+    volatile int __A_VARIABLE;
     slowlogEntry *se = septr;
     int j;
 
@@ -107,21 +110,28 @@ void slowlogFreeEntry(void *septr) {
     sdsfree(se->peerid);
     sdsfree(se->cname);
     zfree(se);
+    __A_VARIABLE = 1;
 }
 
 /* Initialize the slow log. This function should be called a single time
  * at server startup. */
 void slowlogInit(void) {
+    volatile int __A_VARIABLE;
     server.slowlog = listCreate();
     server.slowlog_entry_id = 0;
     listSetFreeMethod(server.slowlog,slowlogFreeEntry);
+    __A_VARIABLE = 1;
 }
 
 /* Push a new entry into the slow log.
  * This function will make sure to trim the slow log accordingly to the
  * configured max length. */
 void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
-    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
+    volatile int __A_VARIABLE;
+    if (server.slowlog_log_slower_than < 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Slowlog disabled */
     if (duration >= server.slowlog_log_slower_than)
         listAddNodeHead(server.slowlog,
                         slowlogCreateEntry(c,argv,argc,duration));
@@ -129,12 +139,15 @@ void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long durati
     /* Remove old entries if needed. */
     while (listLength(server.slowlog) > server.slowlog_max_len)
         listDelNode(server.slowlog,listLast(server.slowlog));
+    __A_VARIABLE = 1;
 }
 
 /* Remove all the entries from the current slow log. */
 void slowlogReset(void) {
+    volatile int __A_VARIABLE;
     while (listLength(server.slowlog) > 0)
         listDelNode(server.slowlog,listLast(server.slowlog));
+    __A_VARIABLE = 1;
 }
 
 /* The SLOWLOG command. Implements all the subcommands needed to handle the
diff --git a/src/sort.c b/src/sort.c
index 4b300d8..0e777f0 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -36,9 +36,11 @@
 zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);
 
 redisSortOperation *createSortOperation(int type, robj *pattern) {
+    volatile int __A_VARIABLE;
     redisSortOperation *so = zmalloc(sizeof(*so));
     so->type = type;
     so->pattern = pattern;
+    __A_VARIABLE = 1;
     return so;
 }
 
@@ -59,6 +61,7 @@ redisSortOperation *createSortOperation(int type, robj *pattern) {
  * The returned object will always have its refcount increased by 1
  * when it is non-NULL. */
 robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
+    volatile int __A_VARIABLE;
     char *p, *f, *k;
     sds spat, ssub;
     robj *keyobj, *fieldobj = NULL, *o;
@@ -69,6 +72,7 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     spat = pattern->ptr;
     if (spat[0] == '#' && spat[1] == '\0') {
         incrRefCount(subst);
+        __A_VARIABLE = 1;
         return subst;
     }
 
@@ -83,6 +87,7 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     p = strchr(spat,'*');
     if (!p) {
         decrRefCount(subst);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -124,11 +129,13 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     }
     decrRefCount(keyobj);
     if (fieldobj) decrRefCount(fieldobj);
+    __A_VARIABLE = 1;
     return o;
 
 noobj:
     decrRefCount(keyobj);
     if (fieldlen) decrRefCount(fieldobj);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -136,6 +143,7 @@ noobj:
  * the additional parameter is not standard but a BSD-specific we have to
  * pass sorting parameters via the global 'server' structure */
 int sortCompare(const void *s1, const void *s2) {
+    volatile int __A_VARIABLE;
     const redisSortObject *so1 = s1, *so2 = s2;
     int cmp;
 
@@ -181,12 +189,14 @@ int sortCompare(const void *s1, const void *s2) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return server.sort_desc ? -cmp : cmp;
 }
 
 /* The SORT command is the most complex command in Redis. Warning: this code
  * is optimized for speed and a bit less for readability */
 void sortCommand(client *c) {
+    volatile int __A_VARIABLE;
     list *operations;
     unsigned int outputlen = 0;
     int desc = 0, alpha = 0;
@@ -205,6 +215,7 @@ void sortCommand(client *c) {
                    sortval->type != OBJ_ZSET)
     {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -282,6 +293,7 @@ void sortCommand(client *c) {
     if (syntax_error) {
         decrRefCount(sortval);
         listRelease(operations);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -587,4 +599,5 @@ void sortCommand(client *c) {
             decrRefCount(vector[j].u.cmpobj);
     }
     zfree(vector);
+    __A_VARIABLE = 1;
 }
diff --git a/src/sparkline.c b/src/sparkline.c
index 0a98688..233b1c3 100644
--- a/src/sparkline.c
+++ b/src/sparkline.c
@@ -55,14 +55,17 @@ static int label_margin_top = 1;
 
 /* Create a new sequence. */
 struct sequence *createSparklineSequence(void) {
+    volatile int __A_VARIABLE;
     struct sequence *seq = zmalloc(sizeof(*seq));
     seq->length = 0;
     seq->samples = NULL;
+    __A_VARIABLE = 1;
     return seq;
 }
 
 /* Add a new sample into a sequence. */
 void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {
+    volatile int __A_VARIABLE;
     label = (label == NULL || label[0] == '\0') ? NULL : zstrdup(label);
     if (seq->length == 0) {
         seq->min = seq->max = value;
@@ -75,16 +78,19 @@ void sparklineSequenceAddSample(struct sequence *seq, double value, char *label)
     seq->samples[seq->length].label = label;
     seq->length++;
     if (label) seq->labels++;
+    __A_VARIABLE = 1;
 }
 
 /* Free a sequence. */
 void freeSparklineSequence(struct sequence *seq) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < seq->length; j++)
         zfree(seq->samples[j].label);
     zfree(seq->samples);
     zfree(seq);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -95,6 +101,7 @@ void freeSparklineSequence(struct sequence *seq) {
  * with differnent parts in order to create the full output without overflowing
  * the current terminal columns. */
 sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {
+    volatile int __A_VARIABLE;
     int j;
     double relmax = seq->max - seq->min;
     int steps = charset_len*rows;
@@ -158,11 +165,13 @@ sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset,
         }
     }
     zfree(chars);
+    __A_VARIABLE = 1;
     return output;
 }
 
 /* Turn a sequence into its ASCII representation */
 sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {
+    volatile int __A_VARIABLE;
     int j;
 
     for (j = 0; j < seq->length; j += columns) {
@@ -171,6 +180,7 @@ sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int
         if (j != 0) output = sdscatlen(output,"\n",1);
         output = sparklineRenderRange(output, seq, rows, j, sublen, flags);
     }
+    __A_VARIABLE = 1;
     return output;
 }
 
diff --git a/src/t_hash.c b/src/t_hash.c
index 0ca152d..2581d1c 100644
--- a/src/t_hash.c
+++ b/src/t_hash.c
@@ -38,9 +38,13 @@
  * ziplist to a real hash. Note that we only check string encoded objects
  * as their string length can be queried in constant time. */
 void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
+    volatile int __A_VARIABLE;
     int i;
 
-    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;
+    if (o->encoding != OBJ_ENCODING_ZIPLIST) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (i = start; i <= end; i++) {
         if (sdsEncodedObject(argv[i]) &&
@@ -50,6 +54,7 @@ void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
             break;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the value from a ziplist encoded hash, identified by field.
@@ -59,6 +64,7 @@ int hashTypeGetFromZiplist(robj *o, sds field,
                            unsigned int *vlen,
                            long long *vll)
 {
+    volatile int __A_VARIABLE;
     unsigned char *zl, *fptr = NULL, *vptr = NULL;
     int ret;
 
@@ -78,9 +84,11 @@ int hashTypeGetFromZiplist(robj *o, sds field,
     if (vptr != NULL) {
         ret = ziplistGet(vptr, vstr, vlen, vll);
         serverAssert(ret);
+        __A_VARIABLE = 1;
         return 0;
     }
 
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -88,12 +96,17 @@ int hashTypeGetFromZiplist(robj *o, sds field,
  * Returns NULL when the field cannot be found, otherwise the SDS value
  * is returned. */
 sds hashTypeGetFromHashTable(robj *o, sds field) {
+    volatile int __A_VARIABLE;
     dictEntry *de;
 
     serverAssert(o->encoding == OBJ_ENCODING_HT);
 
     de = dictFind(o->ptr, field);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return dictGetVal(de);
 }
 
@@ -142,6 +155,7 @@ robj *hashTypeGetValueObject(robj *o, sds field) {
  * object associated with the requested field, or 0 if the field does not
  * exist. */
 size_t hashTypeGetValueLength(robj *o, sds field) {
+    volatile int __A_VARIABLE;
     size_t len = 0;
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
@@ -158,6 +172,7 @@ size_t hashTypeGetValueLength(robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -200,6 +215,7 @@ int hashTypeExists(robj *o, sds field) {
 #define HASH_SET_TAKE_VALUE (1<<1)
 #define HASH_SET_COPY 0
 int hashTypeSet(robj *o, sds field, sds value, int flags) {
+    volatile int __A_VARIABLE;
     int update = 0;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
@@ -271,12 +287,14 @@ int hashTypeSet(robj *o, sds field, sds value, int flags) {
      * want this function to be responsible. */
     if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);
     if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);
+    __A_VARIABLE = 1;
     return update;
 }
 
 /* Delete an element from a hash.
  * Return 1 on deleted and 0 on not found. */
 int hashTypeDelete(robj *o, sds field) {
+    volatile int __A_VARIABLE;
     int deleted = 0;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
@@ -304,11 +322,13 @@ int hashTypeDelete(robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return deleted;
 }
 
 /* Return the number of elements in a hash. */
 unsigned long hashTypeLength(const robj *o) {
+    volatile int __A_VARIABLE;
     unsigned long length = ULONG_MAX;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
@@ -318,10 +338,12 @@ unsigned long hashTypeLength(const robj *o) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return length;
 }
 
 hashTypeIterator *hashTypeInitIterator(robj *subject) {
+    volatile int __A_VARIABLE;
     hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
     hi->subject = subject;
     hi->encoding = subject->encoding;
@@ -334,13 +356,16 @@ hashTypeIterator *hashTypeInitIterator(robj *subject) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return hi;
 }
 
 void hashTypeReleaseIterator(hashTypeIterator *hi) {
+    volatile int __A_VARIABLE;
     if (hi->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(hi->di);
     zfree(hi);
+    __A_VARIABLE = 1;
 }
 
 /* Move to the next entry in the hash. Return C_OK when the next entry
@@ -387,6 +412,7 @@ void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
                                 unsigned int *vlen,
                                 long long *vll)
 {
+    volatile int __A_VARIABLE;
     int ret;
 
     serverAssert(hi->encoding == OBJ_ENCODING_ZIPLIST);
@@ -398,6 +424,7 @@ void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
         ret = ziplistGet(hi->vptr, vstr, vlen, vll);
         serverAssert(ret);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the field or value at iterator cursor, for an iterator on a hash value
@@ -424,6 +451,7 @@ sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {
  * can always check the function return by checking the return value
  * type checking if vstr == NULL. */
 void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {
+    volatile int __A_VARIABLE;
     if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         *vstr = NULL;
         hashTypeCurrentFromZiplist(hi, what, vstr, vlen, vll);
@@ -434,17 +462,23 @@ void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr,
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the key or value at the current iterator position as a new
  * SDS string. */
 sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
+    volatile int __A_VARIABLE;
     unsigned char *vstr;
     unsigned int vlen;
     long long vll;
 
     hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
-    if (vstr) return sdsnewlen(vstr,vlen);
+    if (vstr) {
+        __A_VARIABLE = 1;
+        return sdsnewlen(vstr,vlen);
+    }
+    __A_VARIABLE = 1;
     return sdsfromlonglong(vll);
 }
 
@@ -463,6 +497,7 @@ robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {
 }
 
 void hashTypeConvertZiplist(robj *o, int enc) {
+    volatile int __A_VARIABLE;
     serverAssert(o->encoding == OBJ_ENCODING_ZIPLIST);
 
     if (enc == OBJ_ENCODING_ZIPLIST) {
@@ -495,9 +530,11 @@ void hashTypeConvertZiplist(robj *o, int enc) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void hashTypeConvert(robj *o, int enc) {
+    volatile int __A_VARIABLE;
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         hashTypeConvertZiplist(o, enc);
     } else if (o->encoding == OBJ_ENCODING_HT) {
@@ -505,6 +542,7 @@ void hashTypeConvert(robj *o, int enc) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -512,8 +550,12 @@ void hashTypeConvert(robj *o, int enc) {
  *----------------------------------------------------------------------------*/
 
 void hsetnxCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
-    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     hashTypeTryConversion(o,c->argv,2,3);
 
     if (hashTypeExists(o, c->argv[2]->ptr)) {
@@ -525,18 +567,24 @@ void hsetnxCommand(client *c) {
         notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
         server.dirty++;
     }
+    __A_VARIABLE = 1;
 }
 
 void hsetCommand(client *c) {
+    volatile int __A_VARIABLE;
     int i, created = 0;
     robj *o;
 
     if ((c->argc % 2) == 1) {
         addReplyError(c,"wrong number of arguments for HMSET");
+        __A_VARIABLE = 1;
         return;
     }
 
-    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     hashTypeTryConversion(o,c->argv,2,c->argc-1);
 
     for (i = 2; i < c->argc; i += 2)
@@ -554,6 +602,7 @@ void hsetCommand(client *c) {
     signalModifiedKey(c->db,c->argv[1]);
     notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 void hincrbyCommand(client *c) {
@@ -642,10 +691,12 @@ void hincrbyfloatCommand(client *c) {
 }
 
 static void addHashFieldToReply(client *c, robj *o, sds field) {
+    volatile int __A_VARIABLE;
     int ret;
 
     if (o == NULL) {
         addReply(c, shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -674,18 +725,25 @@ static void addHashFieldToReply(client *c, robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void hgetCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addHashFieldToReply(c, o, c->argv[2]->ptr);
+    __A_VARIABLE = 1;
 }
 
 void hmgetCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     int i;
 
@@ -694,6 +752,7 @@ void hmgetCommand(client *c) {
     o = lookupKeyRead(c->db, c->argv[1]);
     if (o != NULL && o->type != OBJ_HASH) {
         addReply(c, shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -701,14 +760,19 @@ void hmgetCommand(client *c) {
     for (i = 2; i < c->argc; i++) {
         addHashFieldToReply(c, o, c->argv[i]->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 void hdelCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     int j, deleted = 0, keyremoved = 0;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (hashTypeDelete(o,c->argv[j]->ptr)) {
@@ -729,26 +793,38 @@ void hdelCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 void hlenCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,hashTypeLength(o));
+    __A_VARIABLE = 1;
 }
 
 void hstrlenCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
+    __A_VARIABLE = 1;
 }
 
 static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
+    volatile int __A_VARIABLE;
     if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
@@ -765,16 +841,21 @@ static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int wh
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void genericHgetallCommand(client *c, int flags) {
+    volatile int __A_VARIABLE;
     robj *o;
     hashTypeIterator *hi;
     int multiplier = 0;
     int length, count = 0;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-        || checkType(c,o,OBJ_HASH)) return;
+        || checkType(c,o,OBJ_HASH)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (flags & OBJ_HASH_KEY) multiplier++;
     if (flags & OBJ_HASH_VALUE) multiplier++;
@@ -796,34 +877,54 @@ void genericHgetallCommand(client *c, int flags) {
 
     hashTypeReleaseIterator(hi);
     serverAssert(count == length);
+    __A_VARIABLE = 1;
 }
 
 void hkeysCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericHgetallCommand(c,OBJ_HASH_KEY);
+    __A_VARIABLE = 1;
 }
 
 void hvalsCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericHgetallCommand(c,OBJ_HASH_VALUE);
+    __A_VARIABLE = 1;
 }
 
 void hgetallCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);
+    __A_VARIABLE = 1;
 }
 
 void hexistsCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void hscanCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,o,cursor);
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_list.c b/src/t_list.c
index de417f4..e111fe0 100644
--- a/src/t_list.c
+++ b/src/t_list.c
@@ -39,6 +39,7 @@
  * There is no need for the caller to increment the refcount of 'value' as
  * the function takes care of it if needed. */
 void listTypePush(robj *subject, robj *value, int where) {
+    volatile int __A_VARIABLE;
     if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
         int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
         value = getDecodedObject(value);
@@ -48,13 +49,17 @@ void listTypePush(robj *subject, robj *value, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void *listPopSaver(unsigned char *data, unsigned int sz) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return createStringObject((char*)data,sz);
 }
 
 robj *listTypePop(robj *subject, int where) {
+    volatile int __A_VARIABLE;
     long long vlong;
     robj *value = NULL;
 
@@ -68,6 +73,7 @@ robj *listTypePop(robj *subject, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -82,6 +88,7 @@ unsigned long listTypeLength(const robj *subject) {
 /* Initialize an iterator at the specified index. */
 listTypeIterator *listTypeInitIterator(robj *subject, long index,
                                        unsigned char direction) {
+    volatile int __A_VARIABLE;
     listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
     li->subject = subject;
     li->encoding = subject->encoding;
@@ -97,13 +104,16 @@ listTypeIterator *listTypeInitIterator(robj *subject, long index,
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return li;
 }
 
 /* Clean up the iterator. */
 void listTypeReleaseIterator(listTypeIterator *li) {
+    volatile int __A_VARIABLE;
     zfree(li->iter);
     zfree(li);
+    __A_VARIABLE = 1;
 }
 
 /* Stores pointer to current the entry in the provided entry structure
@@ -124,6 +134,7 @@ int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
 
 /* Return entry or NULL at the current position of the iterator. */
 robj *listTypeGet(listTypeEntry *entry) {
+    volatile int __A_VARIABLE;
     robj *value = NULL;
     if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
         if (entry->entry.value) {
@@ -135,10 +146,12 @@ robj *listTypeGet(listTypeEntry *entry) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
 void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
+    volatile int __A_VARIABLE;
     if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
         value = getDecodedObject(value);
         sds str = value->ptr;
@@ -154,6 +167,7 @@ void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Compare the given object with the entry at the current position. */
@@ -168,15 +182,18 @@ int listTypeEqual(listTypeEntry *entry, robj *o) {
 
 /* Delete the element pointed to. */
 void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
+    volatile int __A_VARIABLE;
     if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklistDelEntry(iter->iter, &entry->entry);
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create a quicklist from a single ziplist */
 void listTypeConvert(robj *subject, int enc) {
+    volatile int __A_VARIABLE;
     serverAssertWithInfo(NULL,subject,subject->type==OBJ_LIST);
     serverAssertWithInfo(NULL,subject,subject->encoding==OBJ_ENCODING_ZIPLIST);
 
@@ -188,6 +205,7 @@ void listTypeConvert(robj *subject, int enc) {
     } else {
         serverPanic("Unsupported list conversion");
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -195,11 +213,13 @@ void listTypeConvert(robj *subject, int enc) {
  *----------------------------------------------------------------------------*/
 
 void pushGenericCommand(client *c, int where) {
+    volatile int __A_VARIABLE;
     int j, pushed = 0;
     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);
 
     if (lobj && lobj->type != OBJ_LIST) {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -221,22 +241,31 @@ void pushGenericCommand(client *c, int where) {
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
     server.dirty += pushed;
+    __A_VARIABLE = 1;
 }
 
 void lpushCommand(client *c) {
+    volatile int __A_VARIABLE;
     pushGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpushCommand(client *c) {
+    volatile int __A_VARIABLE;
     pushGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void pushxGenericCommand(client *c, int where) {
+    volatile int __A_VARIABLE;
     int j, pushed = 0;
     robj *subject;
 
     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,subject,OBJ_LIST)) return;
+        checkType(c,subject,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         listTypePush(subject,c->argv[j],where);
@@ -251,14 +280,19 @@ void pushxGenericCommand(client *c, int where) {
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
     server.dirty += pushed;
+    __A_VARIABLE = 1;
 }
 
 void lpushxCommand(client *c) {
+    volatile int __A_VARIABLE;
     pushxGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpushxCommand(client *c) {
+    volatile int __A_VARIABLE;
     pushxGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void linsertCommand(client *c) {
@@ -306,19 +340,30 @@ void linsertCommand(client *c) {
 }
 
 void llenCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     addReplyLongLong(c,listTypeLength(o));
+    __A_VARIABLE = 1;
 }
 
 void lindexCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     long index;
     robj *value = NULL;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklistEntry entry;
@@ -336,16 +381,23 @@ void lindexCommand(client *c) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void lsetCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     long index;
     robj *value = c->argv[3];
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklist *ql = o->ptr;
@@ -362,11 +414,16 @@ void lsetCommand(client *c) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void popGenericCommand(client *c, int where) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     robj *value = listTypePop(o,where);
     if (value == NULL) {
@@ -385,25 +442,37 @@ void popGenericCommand(client *c, int where) {
         signalModifiedKey(c->db,c->argv[1]);
         server.dirty++;
     }
+    __A_VARIABLE = 1;
 }
 
 void lpopCommand(client *c) {
+    volatile int __A_VARIABLE;
     popGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpopCommand(client *c) {
+    volatile int __A_VARIABLE;
     popGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void lrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     long start, end, llen, rangelen;
 
     if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-         || checkType(c,o,OBJ_LIST)) return;
+         || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     llen = listTypeLength(o);
 
     /* convert negative indexes */
@@ -415,6 +484,7 @@ void lrangeCommand(client *c) {
      * The range is empty when start > end or start >= length. */
     if (start > end || start >= llen) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
     if (end >= llen) end = llen-1;
@@ -439,17 +509,25 @@ void lrangeCommand(client *c) {
     } else {
         serverPanic("List encoding is not QUICKLIST!");
     }
+    __A_VARIABLE = 1;
 }
 
 void ltrimCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     long start, end, llen, ltrim, rtrim;
 
     if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
-        checkType(c,o,OBJ_LIST)) return;
+        checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     llen = listTypeLength(o);
 
     /* convert negative indexes */
@@ -485,19 +563,26 @@ void ltrimCommand(client *c) {
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void lremCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *subject, *obj;
     obj = c->argv[3];
     long toremove;
     long removed = 0;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
-    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;
+    if (subject == NULL || checkType(c,subject,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listTypeIterator *li;
     if (toremove < 0) {
@@ -529,6 +614,7 @@ void lremCommand(client *c) {
     }
 
     addReplyLongLong(c,removed);
+    __A_VARIABLE = 1;
 }
 
 /* This is the semantic of this command:
@@ -548,6 +634,7 @@ void lremCommand(client *c) {
  */
 
 void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {
+    volatile int __A_VARIABLE;
     /* Create the list if the key does not exist */
     if (!dstobj) {
         dstobj = createQuicklistObject();
@@ -560,6 +647,7 @@ void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {
     notifyKeyspaceEvent(NOTIFY_LIST,"lpush",dstkey,c->db->id);
     /* Always send the pushed value to the client. */
     addReplyBulk(c,value);
+    __A_VARIABLE = 1;
 }
 
 void rpoplpushCommand(client *c) {
@@ -740,18 +828,26 @@ void blockingPopGenericCommand(client *c, int where) {
 }
 
 void blpopCommand(client *c) {
+    volatile int __A_VARIABLE;
     blockingPopGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void brpopCommand(client *c) {
+    volatile int __A_VARIABLE;
     blockingPopGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void brpoplpushCommand(client *c) {
+    volatile int __A_VARIABLE;
     mstime_t timeout;
 
     if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
-        != C_OK) return;
+        != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     robj *key = lookupKeyWrite(c->db, c->argv[1]);
 
@@ -774,4 +870,5 @@ void brpoplpushCommand(client *c) {
             rpoplpushCommand(c);
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_set.c b/src/t_set.c
index f67073f..8f7025e 100644
--- a/src/t_set.c
+++ b/src/t_set.c
@@ -40,8 +40,12 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
  * an integer-encodable value, an intset will be returned. Otherwise a regular
  * hash table. */
 robj *setTypeCreate(sds value) {
-    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
+    volatile int __A_VARIABLE;
+    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK) {
+        __A_VARIABLE = 1;
         return createIntsetObject();
+    }
+    __A_VARIABLE = 1;
     return createSetObject();
 }
 
@@ -119,6 +123,7 @@ int setTypeIsMember(robj *subject, sds value) {
 }
 
 setTypeIterator *setTypeInitIterator(robj *subject) {
+    volatile int __A_VARIABLE;
     setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
     si->subject = subject;
     si->encoding = subject->encoding;
@@ -129,13 +134,16 @@ setTypeIterator *setTypeInitIterator(robj *subject) {
     } else {
         serverPanic("Unknown set encoding");
     }
+    __A_VARIABLE = 1;
     return si;
 }
 
 void setTypeReleaseIterator(setTypeIterator *si) {
+    volatile int __A_VARIABLE;
     if (si->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(si->di);
     zfree(si);
+    __A_VARIABLE = 1;
 }
 
 /* Move to the next entry in the set. Returns the object at the current
@@ -175,20 +183,25 @@ int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {
  * This function is the way to go for write operations where COW is not
  * an issue. */
 sds setTypeNextObject(setTypeIterator *si) {
+    volatile int __A_VARIABLE;
     int64_t intele;
     sds sdsele;
     int encoding;
 
     encoding = setTypeNext(si,&sdsele,&intele);
     switch(encoding) {
-        case -1:    return NULL;
+        case -1:    __A_VARIABLE = 1;
+            return NULL;
         case OBJ_ENCODING_INTSET:
+            __A_VARIABLE = 1;
             return sdsfromlonglong(intele);
         case OBJ_ENCODING_HT:
+            __A_VARIABLE = 1;
             return sdsdup(sdsele);
         default:
             serverPanic("Unsupported encoding");
     }
+    __A_VARIABLE = 1;
     return NULL; /* just to suppress warnings */
 }
 
@@ -206,6 +219,7 @@ sds setTypeNextObject(setTypeIterator *si) {
  * be NULL since the function will try to defensively populate the non
  * used field with values which are easy to trap if misused. */
 int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
+    volatile int __A_VARIABLE;
     if (setobj->encoding == OBJ_ENCODING_HT) {
         dictEntry *de = dictGetRandomKey(setobj->ptr);
         *sdsele = dictGetKey(de);
@@ -216,6 +230,7 @@ int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
     } else {
         serverPanic("Unknown set encoding");
     }
+    __A_VARIABLE = 1;
     return setobj->encoding;
 }
 
@@ -233,6 +248,7 @@ unsigned long setTypeSize(const robj *subject) {
  * to a hash table) is presized to hold the number of elements in the original
  * set. */
 void setTypeConvert(robj *setobj, int enc) {
+    volatile int __A_VARIABLE;
     setTypeIterator *si;
     serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
                              setobj->encoding == OBJ_ENCODING_INTSET);
@@ -259,6 +275,7 @@ void setTypeConvert(robj *setobj, int enc) {
     } else {
         serverPanic("Unsupported set conversion");
     }
+    __A_VARIABLE = 1;
 }
 
 void saddCommand(client *c) {
@@ -288,11 +305,15 @@ void saddCommand(client *c) {
 }
 
 void sremCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *set;
     int j, deleted = 0, keyremoved = 0;
 
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (setTypeRemove(set,c->argv[j]->ptr)) {
@@ -313,9 +334,11 @@ void sremCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 void smoveCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *srcset, *dstset, *ele;
     srcset = lookupKeyWrite(c->db,c->argv[1]);
     dstset = lookupKeyWrite(c->db,c->argv[2]);
@@ -324,24 +347,30 @@ void smoveCommand(client *c) {
     /* If the source key does not exist return 0 */
     if (srcset == NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* If the source key has the wrong type, or the destination key
      * is set and has the wrong type, return with an error. */
     if (checkType(c,srcset,OBJ_SET) ||
-        (dstset && checkType(c,dstset,OBJ_SET))) return;
+        (dstset && checkType(c,dstset,OBJ_SET))) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If srcset and dstset are equal, SMOVE is a no-op */
     if (srcset == dstset) {
         addReply(c,setTypeIsMember(srcset,ele->ptr) ?
             shared.cone : shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* If the element cannot be removed from the src set, return 0. */
     if (!setTypeRemove(srcset,ele->ptr)) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
@@ -368,27 +397,38 @@ void smoveCommand(client *c) {
         notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
     }
     addReply(c,shared.cone);
+    __A_VARIABLE = 1;
 }
 
 void sismemberCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *set;
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (setTypeIsMember(set,c->argv[2]->ptr))
         addReply(c,shared.cone);
     else
         addReply(c,shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void scardCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_SET)) return;
+        checkType(c,o,OBJ_SET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,setTypeSize(o));
+    __A_VARIABLE = 1;
 }
 
 /* Handle the "SPOP key <count>" variant. The normal version of the
@@ -612,6 +652,7 @@ void spopCommand(client *c) {
 #define SRANDMEMBER_SUB_STRATEGY_MUL 3
 
 void srandmemberWithCountCommand(client *c) {
+    volatile int __A_VARIABLE;
     long l;
     unsigned long count, size;
     int uniq = 1;
@@ -622,7 +663,10 @@ void srandmemberWithCountCommand(client *c) {
 
     dict *d;
 
-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
+    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (l >= 0) {
         count = (unsigned long) l;
     } else {
@@ -633,12 +677,16 @@ void srandmemberWithCountCommand(client *c) {
     }
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
-        == NULL || checkType(c,set,OBJ_SET)) return;
+        == NULL || checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     size = setTypeSize(set);
 
     /* If count is zero, serve it ASAP to avoid special cases later. */
     if (count == 0) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -656,6 +704,7 @@ void srandmemberWithCountCommand(client *c) {
                 addReplyBulkCBuffer(c,ele,sdslen(ele));
             }
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -664,6 +713,7 @@ void srandmemberWithCountCommand(client *c) {
      * elements inside the set: simply return the whole set. */
     if (count >= size) {
         sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -743,6 +793,7 @@ void srandmemberWithCountCommand(client *c) {
             addReplyBulk(c,dictGetKey(de));
         dictReleaseIterator(di);
         dictRelease(d);
+        __A_VARIABLE = 1;
     }
 }
 
@@ -772,25 +823,42 @@ void srandmemberCommand(client *c) {
 }
 
 int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
-    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
-    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
+    volatile int __A_VARIABLE;
+    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* This is used by SDIFF and in this case we can receive NULL that should
  * be handled as empty sets. */
 int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
+    volatile int __A_VARIABLE;
     robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
     unsigned long first = o1 ? setTypeSize(o1) : 0;
     unsigned long second = o2 ? setTypeSize(o2) : 0;
 
-    if (first < second) return 1;
-    if (first > second) return -1;
+    if (first < second) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (first > second) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 void sinterGenericCommand(client *c, robj **setkeys,
                           unsigned long setnum, robj *dstkey) {
+    volatile int __A_VARIABLE;
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *dstset = NULL;
@@ -815,10 +883,12 @@ void sinterGenericCommand(client *c, robj **setkeys,
             } else {
                 addReply(c,shared.emptymultibulk);
             }
+            __A_VARIABLE = 1;
             return;
         }
         if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
+            __A_VARIABLE = 1;
             return;
         }
         sets[j] = setobj;
@@ -914,14 +984,19 @@ void sinterGenericCommand(client *c, robj **setkeys,
         setDeferredMultiBulkLength(c,replylen,cardinality);
     }
     zfree(sets);
+    __A_VARIABLE = 1;
 }
 
 void sinterCommand(client *c) {
+    volatile int __A_VARIABLE;
     sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
+    __A_VARIABLE = 1;
 }
 
 void sinterstoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
+    __A_VARIABLE = 1;
 }
 
 #define SET_OP_UNION 0
@@ -930,6 +1005,7 @@ void sinterstoreCommand(client *c) {
 
 void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                               robj *dstkey, int op) {
+    volatile int __A_VARIABLE;
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *dstset = NULL;
@@ -947,6 +1023,7 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
         }
         if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
+            __A_VARIABLE = 1;
             return;
         }
         sets[j] = setobj;
@@ -1086,30 +1163,47 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
         server.dirty++;
     }
     zfree(sets);
+    __A_VARIABLE = 1;
 }
 
 void sunionCommand(client *c) {
+    volatile int __A_VARIABLE;
     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void sunionstoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void sdiffCommand(client *c) {
+    volatile int __A_VARIABLE;
     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
+    __A_VARIABLE = 1;
 }
 
 void sdiffstoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
+    __A_VARIABLE = 1;
 }
 
 void sscanCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *set;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,set,cursor);
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_stream.c b/src/t_stream.c
index d3d7006..17b74c0 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -50,21 +50,25 @@ size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start
 
 /* Create a new stream data structure. */
 stream *streamNew(void) {
+    volatile int __A_VARIABLE;
     stream *s = zmalloc(sizeof(*s));
     s->rax = raxNew();
     s->length = 0;
     s->last_id.ms = 0;
     s->last_id.seq = 0;
     s->cgroups = NULL; /* Created on demand to save memory when not used. */
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Free a stream, including the listpacks stored inside the radix tree. */
 void freeStream(stream *s) {
+    volatile int __A_VARIABLE;
     raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);
     if (s->cgroups)
         raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
     zfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* Generate the next stream item ID given the previous one. If the current
@@ -72,6 +76,7 @@ void freeStream(stream *s) {
  * as time part and start with sequence part of zero. Otherwise we use the
  * previous time (and never go backward) and increment the sequence. */
 void streamNextID(streamID *last_id, streamID *new_id) {
+    volatile int __A_VARIABLE;
     uint64_t ms = mstime();
     if (ms > last_id->ms) {
         new_id->ms = ms;
@@ -80,13 +85,16 @@ void streamNextID(streamID *last_id, streamID *new_id) {
         new_id->ms = last_id->ms;
         new_id->seq = last_id->seq+1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This is just a wrapper for lpAppend() to directly use a 64 bit integer
  * instead of a string. */
 unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
+    volatile int __A_VARIABLE;
     char buf[LONG_STR_SIZE];
     int slen = ll2string(buf,sizeof(buf),value);
+    __A_VARIABLE = 1;
     return lpAppend(lp,(unsigned char*)buf,slen);
 }
 
@@ -95,8 +103,10 @@ unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
  * the new listpack as return value, and also updates the current cursor
  * by updating '*pos'. */
 unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {
+    volatile int __A_VARIABLE;
     char buf[LONG_STR_SIZE];
     int slen = ll2string(buf,sizeof(buf),value);
+    __A_VARIABLE = 1;
     return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);
 }
 
@@ -104,9 +114,13 @@ unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t
  * from the listpack (that may store numbers as a string), converting
  * the string if needed. */
 int64_t lpGetInteger(unsigned char *ele) {
+    volatile int __A_VARIABLE;
     int64_t v;
     unsigned char *e = lpGet(ele,&v,NULL);
-    if (e == NULL) return v;
+    if (e == NULL) {
+        __A_VARIABLE = 1;
+        return v;
+    }
     /* The following code path should never be used for how listpacks work:
      * they should always be able to store an int64_t value in integer
      * encoded form. However the implementation may change. */
@@ -114,12 +128,14 @@ int64_t lpGetInteger(unsigned char *ele) {
     int retval = string2ll((char*)e,v,&ll);
     serverAssert(retval != 0);
     v = ll;
+    __A_VARIABLE = 1;
     return v;
 }
 
 /* Debugging function to log the full content of a listpack. Useful
  * for development and debugging. */
 void streamLogListpackContent(unsigned char *lp) {
+    volatile int __A_VARIABLE;
     unsigned char *p = lpFirst(lp);
     while(p) {
         unsigned char buf[LP_INTBUF_SIZE];
@@ -128,25 +144,30 @@ void streamLogListpackContent(unsigned char *lp) {
         serverLog(LL_WARNING,"- [%d] '%.*s'", (int)v, (int)v, ele);
         p = lpNext(lp,p);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Convert the specified stream entry ID as a 128 bit big endian number, so
  * that the IDs can be sorted lexicographically. */
 void streamEncodeID(void *buf, streamID *id) {
+    volatile int __A_VARIABLE;
     uint64_t e[2];
     e[0] = htonu64(id->ms);
     e[1] = htonu64(id->seq);
     memcpy(buf,e,sizeof(e));
+    __A_VARIABLE = 1;
 }
 
 /* This is the reverse of streamEncodeID(): the decoded ID will be stored
  * in the 'id' structure passed by reference. The buffer 'buf' must point
  * to a 128 bit big-endian encoded ID. */
 void streamDecodeID(void *buf, streamID *id) {
+    volatile int __A_VARIABLE;
     uint64_t e[2];
     memcpy(e,buf,sizeof(e));
     id->ms = ntohu64(e[0]);
     id->seq = ntohu64(e[1]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */
@@ -173,9 +194,13 @@ int streamCompareID(streamID *a, streamID *b) {
  * C_ERR if an ID was given via 'use_id', but adding it failed since the
  * current top ID is greater or equal. */
 int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {
+    volatile int __A_VARIABLE;
     /* If an ID was given, check that it's greater than the last entry ID
      * or return an error. */
-    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) return C_ERR;
+    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Add the new entry. */
     raxIterator ri;
@@ -354,6 +379,7 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_
     s->length++;
     s->last_id = id;
     if (added_id) *added_id = id;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -372,7 +398,11 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_
  *    to be deleted, leaving the stream with a number of elements >= maxlen.
  */
 int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
-    if (s->length <= maxlen) return 0;
+    volatile int __A_VARIABLE;
+    if (s->length <= maxlen) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     raxIterator ri;
     raxStart(&ri,s->rax);
@@ -461,6 +491,7 @@ int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
     }
 
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -486,6 +517,7 @@ int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
  *  }
  *  streamIteratorStop(&myiterator); */
 void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
+    volatile int __A_VARIABLE;
     /* Intialize the iterator and translates the iteration start/stop
      * elements into a 128 big big-endian number. */
     if (start) {
@@ -525,6 +557,7 @@ void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamI
     si->lp = NULL; /* There is no current listpack right now. */
     si->lp_ele = NULL; /* Current listpack cursor. */
     si->rev = rev;  /* Direction, if non-zero reversed, from end to start. */
+    __A_VARIABLE = 1;
 }
 
 /* Return 1 and store the current item ID at 'id' if there are still
@@ -676,6 +709,7 @@ int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
  * lengths by reference, that are valid until the next iterator call, assuming
  * no one touches the stream meanwhile. */
 void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
+    volatile int __A_VARIABLE;
     if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
         *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);
         si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);
@@ -685,6 +719,7 @@ void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsign
     }
     *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
     si->lp_ele = lpNext(si->lp,si->lp_ele);
+    __A_VARIABLE = 1;
 }
 
 /* Remove the current entry from the stream: can be called after the
@@ -698,6 +733,7 @@ void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsign
  * automatically re-seek to the next entry, so the caller should continue
  * with GetID(). */
 void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
+    volatile int __A_VARIABLE;
     unsigned char *lp = si->lp;
     int64_t aux;
 
@@ -748,18 +784,22 @@ void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
 
     /* TODO: perform a garbage collection here if the ration between
      * deleted and valid goes over a certain limit. */
+    __A_VARIABLE = 1;
 }
 
 /* Stop the stream iterator. The only cleanup we need is to free the rax
  * itereator, since the stream iterator itself is supposed to be stack
  * allocated. */
 void streamIteratorStop(streamIterator *si) {
+    volatile int __A_VARIABLE;
     raxStop(&si->ri);
+    __A_VARIABLE = 1;
 }
 
 /* Delete the specified item ID from the stream, returning 1 if the item
  * was deleted 0 otherwise (if it does not exist). */
 int streamDeleteItem(stream *s, streamID *id) {
+    volatile int __A_VARIABLE;
     int deleted = 0;
     streamIterator si;
     streamIteratorStart(&si,s,id,id,0);
@@ -770,6 +810,7 @@ int streamDeleteItem(stream *s, streamID *id) {
         deleted = 1;
     }
     streamIteratorStop(&si);
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -777,13 +818,17 @@ int streamDeleteItem(stream *s, streamID *id) {
  * in the standard <ms>-<seq> format, using the simple string protocol
  * of REPL. */
 void addReplyStreamID(client *c, streamID *id) {
+    volatile int __A_VARIABLE;
     sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
     addReplyBulkSds(c,replyid);
+    __A_VARIABLE = 1;
 }
 
 /* Similar to the above function, but just creates an object, usually useful
  * for replication purposes to create arguments. */
 robj *createObjectFromStreamID(streamID *id) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return createObject(OBJ_STRING, sdscatfmt(sdsempty(),"%U-%U",
                         id->ms,id->seq));
 }
@@ -792,6 +837,7 @@ robj *createObjectFromStreamID(streamID *id) {
  * are created in the pending list of the stream and consumers. We need
  * to propagate this changes in the form of XCLAIM commands. */
 void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
+    volatile int __A_VARIABLE;
     /* We need to generate an XCLAIM that will work in a idempotent fashion:
      *
      * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
@@ -826,6 +872,7 @@ void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupnam
     decrRefCount(argv[11]);
     decrRefCount(argv[12]);
     decrRefCount(argv[13]);
+    __A_VARIABLE = 1;
 }
 
 /* We need this when we want to propoagate the new last-id of a consumer group
@@ -835,6 +882,7 @@ void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupnam
  *  XGROUP SETID <key> <groupname> <id>
  */
 void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
+    volatile int __A_VARIABLE;
     robj *argv[5];
     argv[0] = createStringObject("XGROUP",6);
     argv[1] = createStringObject("SETID",5);
@@ -845,6 +893,7 @@ void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupna
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
     decrRefCount(argv[4]);
+    __A_VARIABLE = 1;
 }
 
 /* Send the stream items in the specified range to the client 'c'. The range
@@ -896,6 +945,7 @@ void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupna
                                            boundaries, just the entries. */
 #define STREAM_RWR_HISTORY (1<<2)       /* Only serve consumer local PEL. */
 size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
+    volatile int __A_VARIABLE;
     void *arraylen_ptr = NULL;
     size_t arraylen = 0;
     streamIterator si;
@@ -909,6 +959,7 @@ size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end
      * the history of messages delivered to it and not yet confirmed
      * as delivered. */
     if (group && (flags & STREAM_RWR_HISTORY)) {
+        __A_VARIABLE = 1;
         return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
                                                    consumer);
     }
@@ -994,6 +1045,7 @@ size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end
     }
     streamIteratorStop(&si);
     if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
+    __A_VARIABLE = 1;
     return arraylen;
 }
 
@@ -1011,6 +1063,7 @@ size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end
  * to the client. However clients only reach this code path when they are
  * fetching the history of already retrieved messages, which is rare. */
 size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {
+    volatile int __A_VARIABLE;
     raxIterator ri;
     unsigned char startkey[sizeof(streamID)];
     unsigned char endkey[sizeof(streamID)];
@@ -1046,6 +1099,7 @@ size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start
     }
     raxStop(&ri);
     setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
+    __A_VARIABLE = 1;
     return arraylen;
 }
 
@@ -1075,17 +1129,25 @@ robj *streamTypeLookupWriteOrCreate(client *c, robj *key) {
  * 1 if the conversion happened successfully or 0 if the number is
  * invalid or out of range. */
 int string2ull(const char *s, unsigned long long *value) {
+    volatile int __A_VARIABLE;
     long long ll;
     if (string2ll(s,strlen(s),&ll)) {
-        if (ll < 0) return 0; /* Negative values are out of range. */
+        if (ll < 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        } /* Negative values are out of range. */
         *value = ll;
+        __A_VARIABLE = 1;
         return 1;
     }
     errno = 0;
     char *endptr = NULL;
     *value = strtoull(s,&endptr,10);
-    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
-        return 0; /* strtoull() failed. */
+    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0')) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* strtoull() failed. */
+    __A_VARIABLE = 1;
     return 1; /* Conversion done! */
 }
 
@@ -1140,6 +1202,8 @@ invalid:
 /* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to
  * 0, to be used when - and + are accetable IDs. */
 int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return streamGenericParseIDOrReply(c,o,id,missing_seq,0);
 }
 
@@ -1147,12 +1211,15 @@ int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq)
  * 1, to be used when we want to return an error if the special IDs + or -
  * are provided. */
 int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return streamGenericParseIDOrReply(c,o,id,missing_seq,1);
 }
 
 /* We propagate MAXLEN ~ <count> as MAXLEN = <resulting-len-of-stream>
  * otherwise trimming is no longer determinsitic on replicas / AOF. */
 void streamRewriteApproxMaxlen(client *c, stream *s, int maxlen_arg_idx) {
+    volatile int __A_VARIABLE;
     robj *maxlen_obj = createStringObjectFromLongLong(s->length);
     robj *equal_obj = createStringObject("=",1);
 
@@ -1161,6 +1228,7 @@ void streamRewriteApproxMaxlen(client *c, stream *s, int maxlen_arg_idx) {
 
     decrRefCount(equal_obj);
     decrRefCount(maxlen_obj);
+    __A_VARIABLE = 1;
 }
 
 /* XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ... */
@@ -1300,21 +1368,30 @@ void xrangeGenericCommand(client *c, int rev) {
 
 /* XRANGE key start end [COUNT <n>] */
 void xrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     xrangeGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 /* XREVRANGE key end start [COUNT <n>] */
 void xrevrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     xrangeGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* XLEN */
 void xlenCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
-        || checkType(c,o,OBJ_STREAM)) return;
+        || checkType(c,o,OBJ_STREAM)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     stream *s = o->ptr;
     addReplyLongLong(c,s->length);
+    __A_VARIABLE = 1;
 }
 
 /* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N
@@ -1590,16 +1667,20 @@ cleanup: /* Cleanup. */
  * time to the current time. The NACK consumer will be set to the one
  * specified as argument of the function. */
 streamNACK *streamCreateNACK(streamConsumer *consumer) {
+    volatile int __A_VARIABLE;
     streamNACK *nack = zmalloc(sizeof(*nack));
     nack->delivery_time = mstime();
     nack->delivery_count = 1;
     nack->consumer = consumer;
+    __A_VARIABLE = 1;
     return nack;
 }
 
 /* Free a NACK entry. */
 void streamFreeNACK(streamNACK *na) {
+    volatile int __A_VARIABLE;
     zfree(na);
+    __A_VARIABLE = 1;
 }
 
 /* Free a consumer and associated data structures. Note that this function
@@ -1608,10 +1689,12 @@ void streamFreeNACK(streamNACK *na) {
  * to delete a consumer, and not when the whole stream is destroyed, the caller
  * should do some work before. */
 void streamFreeConsumer(streamConsumer *sc) {
+    volatile int __A_VARIABLE;
     raxFree(sc->pel); /* No value free callback: the PEL entries are shared
                          between the consumer and the main stream PEL. */
     sdsfree(sc->name);
     zfree(sc);
+    __A_VARIABLE = 1;
 }
 
 /* Create a new consumer group in the context of the stream 's', having the
@@ -1619,31 +1702,42 @@ void streamFreeConsumer(streamConsumer *sc) {
  * already existed NULL is returned, otherwise the pointer to the consumer
  * group is returned. */
 streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {
+    volatile int __A_VARIABLE;
     if (s->cgroups == NULL) s->cgroups = raxNew();
-    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)
+    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     streamCG *cg = zmalloc(sizeof(*cg));
     cg->pel = raxNew();
     cg->consumers = raxNew();
     cg->last_id = *id;
     raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);
+    __A_VARIABLE = 1;
     return cg;
 }
 
 /* Free a consumer group and all its associated data. */
 void streamFreeCG(streamCG *cg) {
+    volatile int __A_VARIABLE;
     raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
     raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
     zfree(cg);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup the consumer group in the specified stream and returns its
  * pointer, otherwise if there is no such group, NULL is returned. */
 streamCG *streamLookupCG(stream *s, sds groupname) {
-    if (s->cgroups == NULL) return NULL;
+    volatile int __A_VARIABLE;
+    if (s->cgroups == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,
                            sdslen(groupname));
+    __A_VARIABLE = 1;
     return (cg == raxNotFound) ? NULL : cg;
 }
 
@@ -1652,10 +1746,14 @@ streamCG *streamLookupCG(stream *s, sds groupname) {
  * of calling this function, otherwise its last seen time is updated and
  * the existing consumer reference returned. */
 streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
+    volatile int __A_VARIABLE;
     streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,
                                sdslen(name));
     if (consumer == raxNotFound) {
-        if (!create) return NULL;
+        if (!create) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         consumer = zmalloc(sizeof(*consumer));
         consumer->name = sdsdup(name);
         consumer->pel = raxNew();
@@ -1663,6 +1761,7 @@ streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
                   consumer,NULL);
     }
     consumer->seen_time = mstime();
+    __A_VARIABLE = 1;
     return consumer;
 }
 
@@ -1670,8 +1769,12 @@ streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
  * may have pending messages: they are removed from the PEL, and the number
  * of pending messages "lost" is returned. */
 uint64_t streamDelConsumer(streamCG *cg, sds name) {
+    volatile int __A_VARIABLE;
     streamConsumer *consumer = streamLookupConsumer(cg,name,0);
-    if (consumer == NULL) return 0;
+    if (consumer == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     uint64_t retval = raxSize(consumer->pel);
 
@@ -1690,6 +1793,7 @@ uint64_t streamDelConsumer(streamCG *cg, sds name) {
     /* Deallocate the consumer. */
     raxRemove(cg->consumers,(unsigned char*)name,sdslen(name),NULL);
     streamFreeConsumer(consumer);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1835,12 +1939,19 @@ NULL
  *
  * Set the internal "last ID" of a stream. */
 void xsetidCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
-    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
+    if (o == NULL || checkType(c,o,OBJ_STREAM)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     stream *s = o->ptr;
     streamID id;
-    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0) != C_OK) return;
+    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If the stream has at least one item, we want to check that the user
      * is setting a last ID that is equal or greater than the current top
@@ -1856,6 +1967,7 @@ void xsetidCommand(client *c) {
         if (streamCompareID(&id,&maxid) < 0) {
             addReplyError(c,"The ID specified in XSETID is smaller than the "
                             "target stream top item");
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -1863,6 +1975,7 @@ void xsetidCommand(client *c) {
     addReply(c,shared.ok);
     server.dirty++;
     notifyKeyspaceEvent(NOTIFY_STREAM,"xsetid",c->argv[1],c->db->id);
+    __A_VARIABLE = 1;
 }
 
 /* XACK <key> <group> <id> <id> ... <id>
@@ -1875,16 +1988,21 @@ void xsetidCommand(client *c) {
  * acknowledged, that is, the IDs we were actually able to resolve in the PEL.
  */
 void xackCommand(client *c) {
+    volatile int __A_VARIABLE;
     streamCG *group = NULL;
     robj *o = lookupKeyRead(c->db,c->argv[1]);
     if (o) {
-        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
+        if (checkType(c,o,OBJ_STREAM)) {
+            __A_VARIABLE = 1;
+            return;
+        } /* Type error. */
         group = streamLookupCG(o->ptr,c->argv[2]->ptr);
     }
 
     /* No key or group? Nothing to ack. */
     if (o == NULL || group == NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1892,7 +2010,10 @@ void xackCommand(client *c) {
     for (int j = 3; j < c->argc; j++) {
         streamID id;
         unsigned char buf[sizeof(streamID)];
-        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
+        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
         streamEncodeID(buf,&id);
 
         /* Lookup the ID in the group PEL: it will have a reference to the
@@ -1908,6 +2029,7 @@ void xackCommand(client *c) {
         }
     }
     addReplyLongLong(c,acknowledged);
+    __A_VARIABLE = 1;
 }
 
 /* XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]
@@ -2316,10 +2438,14 @@ void xclaimCommand(client *c) {
  * of items actually deleted, that may be different from the number
  * of IDs passed in case certain IDs do not exist. */
 void xdelCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
-        || checkType(c,o,OBJ_STREAM)) return;
+        || checkType(c,o,OBJ_STREAM)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     stream *s = o->ptr;
 
     /* We need to sanity check the IDs passed to start. Even if not
@@ -2327,7 +2453,10 @@ void xdelCommand(client *c) {
      * executed because at some point an invalid ID is parsed. */
     streamID id;
     for (int j = 2; j < c->argc; j++) {
-        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
+        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
     }
 
     /* Actually apply the command. */
@@ -2344,6 +2473,7 @@ void xdelCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 /* General form: XTRIM <key> [... options ...]
diff --git a/src/t_string.c b/src/t_string.c
index db6f7aa..3e95ff7 100644
--- a/src/t_string.c
+++ b/src/t_string.c
@@ -35,10 +35,13 @@
  *----------------------------------------------------------------------------*/
 
 static int checkStringLength(client *c, long long size) {
+    volatile int __A_VARIABLE;
     if (size > 512*1024*1024) {
         addReplyError(c,"string exceeds maximum allowed size (512MB)");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -65,13 +68,17 @@ static int checkStringLength(client *c, long long size) {
 #define OBJ_SET_PX (1<<3)     /* Set if time in ms in given */
 
 void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
+    volatile int __A_VARIABLE;
     long long milliseconds = 0; /* initialized to avoid any harmness warning */
 
     if (expire) {
-        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)
+        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         if (milliseconds <= 0) {
             addReplyErrorFormat(c,"invalid expire time in %s",c->cmd->name);
+            __A_VARIABLE = 1;
             return;
         }
         if (unit == UNIT_SECONDS) milliseconds *= 1000;
@@ -81,6 +88,7 @@ void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire,
         (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))
     {
         addReply(c, abort_reply ? abort_reply : shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
     setKey(c->db,key,val);
@@ -90,6 +98,7 @@ void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire,
     if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
         "expire",key,c->db->id);
     addReply(c, ok_reply ? ok_reply : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */
@@ -140,18 +149,24 @@ void setCommand(client *c) {
 }
 
 void setnxCommand(client *c) {
+    volatile int __A_VARIABLE;
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void setexCommand(client *c) {
+    volatile int __A_VARIABLE;
     c->argv[3] = tryObjectEncoding(c->argv[3]);
     setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 void psetexCommand(client *c) {
+    volatile int __A_VARIABLE;
     c->argv[3] = tryObjectEncoding(c->argv[3]);
     setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 int getGenericCommand(client *c) {
@@ -170,15 +185,22 @@ int getGenericCommand(client *c) {
 }
 
 void getCommand(client *c) {
+    volatile int __A_VARIABLE;
     getGenericCommand(c);
+    __A_VARIABLE = 1;
 }
 
 void getsetCommand(client *c) {
-    if (getGenericCommand(c) == C_ERR) return;
+    volatile int __A_VARIABLE;
+    if (getGenericCommand(c) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setKey(c->db,c->argv[1],c->argv[2]);
     notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 void setrangeCommand(client *c) {
@@ -242,17 +264,25 @@ void setrangeCommand(client *c) {
 }
 
 void getrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     long long start, end;
     char *str, llbuf[32];
     size_t strlen;
 
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
-    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
+    }
+    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (o->encoding == OBJ_ENCODING_INT) {
         str = llbuf;
@@ -265,6 +295,7 @@ void getrangeCommand(client *c) {
     /* Convert negative indexes */
     if (start < 0 && end < 0 && start > end) {
         addReply(c,shared.emptybulk);
+        __A_VARIABLE = 1;
         return;
     }
     if (start < 0) start = strlen+start;
@@ -280,9 +311,11 @@ void getrangeCommand(client *c) {
     } else {
         addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
     }
+    __A_VARIABLE = 1;
 }
 
 void mgetCommand(client *c) {
+    volatile int __A_VARIABLE;
     int j;
 
     addReplyMultiBulkLen(c,c->argc-1);
@@ -298,13 +331,16 @@ void mgetCommand(client *c) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void msetGenericCommand(client *c, int nx) {
+    volatile int __A_VARIABLE;
     int j;
 
     if ((c->argc % 2) == 0) {
         addReplyError(c,"wrong number of arguments for MSET");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -314,6 +350,7 @@ void msetGenericCommand(client *c, int nx) {
         for (j = 1; j < c->argc; j += 2) {
             if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
                 addReply(c, shared.czero);
+                __A_VARIABLE = 1;
                 return;
             }
         }
@@ -326,28 +363,41 @@ void msetGenericCommand(client *c, int nx) {
     }
     server.dirty += (c->argc-1)/2;
     addReply(c, nx ? shared.cone : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void msetCommand(client *c) {
+    volatile int __A_VARIABLE;
     msetGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void msetnxCommand(client *c) {
+    volatile int __A_VARIABLE;
     msetGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void incrDecrCommand(client *c, long long incr) {
+    volatile int __A_VARIABLE;
     long long value, oldvalue;
     robj *o, *new;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
-    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;
+    if (o != NULL && checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
+    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     oldvalue = value;
     if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
         (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
         addReplyError(c,"increment or decrement would overflow");
+        __A_VARIABLE = 1;
         return;
     }
     value += incr;
@@ -372,43 +422,65 @@ void incrDecrCommand(client *c, long long incr) {
     addReply(c,shared.colon);
     addReply(c,new);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 void incrCommand(client *c) {
+    volatile int __A_VARIABLE;
     incrDecrCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void decrCommand(client *c) {
+    volatile int __A_VARIABLE;
     incrDecrCommand(c,-1);
+    __A_VARIABLE = 1;
 }
 
 void incrbyCommand(client *c) {
+    volatile int __A_VARIABLE;
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     incrDecrCommand(c,incr);
+    __A_VARIABLE = 1;
 }
 
 void decrbyCommand(client *c) {
+    volatile int __A_VARIABLE;
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     incrDecrCommand(c,-incr);
+    __A_VARIABLE = 1;
 }
 
 void incrbyfloatCommand(client *c) {
+    volatile int __A_VARIABLE;
     long double incr, value;
     robj *o, *new, *aux;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
+    if (o != NULL && checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
-        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
+        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     value += incr;
     if (isnan(value) || isinf(value)) {
         addReplyError(c,"increment would produce NaN or Infinity");
+        __A_VARIABLE = 1;
         return;
     }
     new = createStringObjectFromLongDouble(value,1);
@@ -428,6 +500,7 @@ void incrbyfloatCommand(client *c) {
     rewriteClientCommandArgument(c,0,aux);
     decrRefCount(aux);
     rewriteClientCommandArgument(c,2,new);
+    __A_VARIABLE = 1;
 }
 
 void appendCommand(client *c) {
@@ -464,8 +537,13 @@ void appendCommand(client *c) {
 }
 
 void strlenCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     addReplyLongLong(c,stringObjectLen(o));
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_zset.c b/src/t_zset.c
index 56ea396..63ade2f 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -69,15 +69,18 @@ int zslLexValueLteMax(sds value, zlexrangespec *spec);
 /* Create a skiplist node with the specified number of levels.
  * The SDS string 'ele' is referenced by the node after the call. */
 zskiplistNode *zslCreateNode(int level, double score, sds ele) {
+    volatile int __A_VARIABLE;
     zskiplistNode *zn =
         zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
     zn->score = score;
     zn->ele = ele;
+    __A_VARIABLE = 1;
     return zn;
 }
 
 /* Create a new skiplist. */
 zskiplist *zslCreate(void) {
+    volatile int __A_VARIABLE;
     int j;
     zskiplist *zsl;
 
@@ -91,6 +94,7 @@ zskiplist *zslCreate(void) {
     }
     zsl->header->backward = NULL;
     zsl->tail = NULL;
+    __A_VARIABLE = 1;
     return zsl;
 }
 
@@ -98,12 +102,15 @@ zskiplist *zslCreate(void) {
  * of the element is freed too, unless node->ele is set to NULL before calling
  * this function. */
 void zslFreeNode(zskiplistNode *node) {
+    volatile int __A_VARIABLE;
     sdsfree(node->ele);
     zfree(node);
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole skiplist. */
 void zslFree(zskiplist *zsl) {
+    volatile int __A_VARIABLE;
     zskiplistNode *node = zsl->header->level[0].forward, *next;
 
     zfree(zsl->header);
@@ -113,6 +120,7 @@ void zslFree(zskiplist *zsl) {
         node = next;
     }
     zfree(zsl);
+    __A_VARIABLE = 1;
 }
 
 /* Returns a random level for the new skiplist node we are going to create.
@@ -120,9 +128,11 @@ void zslFree(zskiplist *zsl) {
  * (both inclusive), with a powerlaw-alike distribution where higher
  * levels are less likely to be returned. */
 int zslRandomLevel(void) {
+    volatile int __A_VARIABLE;
     int level = 1;
     while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
         level += 1;
+    __A_VARIABLE = 1;
     return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
 }
 
@@ -130,6 +140,7 @@ int zslRandomLevel(void) {
  * exist (up to the caller to enforce that). The skiplist takes ownership
  * of the passed SDS string 'ele'. */
 zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned int rank[ZSKIPLIST_MAXLEVEL];
     int i, level;
@@ -183,11 +194,13 @@ zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
     else
         zsl->tail = x;
     zsl->length++;
+    __A_VARIABLE = 1;
     return x;
 }
 
 /* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */
 void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
+    volatile int __A_VARIABLE;
     int i;
     for (i = 0; i < zsl->level; i++) {
         if (update[i]->level[i].forward == x) {
@@ -205,6 +218,7 @@ void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
     while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
         zsl->level--;
     zsl->length--;
+    __A_VARIABLE = 1;
 }
 
 /* Delete an element with matching score/element from the skiplist.
@@ -216,6 +230,7 @@ void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
  * so that it is possible for the caller to reuse the node (including the
  * referenced SDS string at node->ele). */
 int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     int i;
 
@@ -239,8 +254,10 @@ int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
             zslFreeNode(x);
         else
             *node = x;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0; /* not found */
 }
 
@@ -256,6 +273,7 @@ int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
  *
  * The function returns the updated element skiplist node pointer. */
 zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     int i;
 
@@ -285,6 +303,7 @@ zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double n
         (x->level[0].forward == NULL || x->level[0].forward->score > newscore))
     {
         x->score = newscore;
+        __A_VARIABLE = 1;
         return x;
     }
 
@@ -296,42 +315,59 @@ zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double n
      * since zslInsert created a new one. */
     x->ele = NULL;
     zslFreeNode(x);
+    __A_VARIABLE = 1;
     return newnode;
 }
 
 int zslValueGteMin(double value, zrangespec *spec) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return spec->minex ? (value > spec->min) : (value >= spec->min);
 }
 
 int zslValueLteMax(double value, zrangespec *spec) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return spec->maxex ? (value < spec->max) : (value <= spec->max);
 }
 
 /* Returns if there is a part of the zset is in range. */
 int zslIsInRange(zskiplist *zsl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
 
     /* Test for ranges that will always be empty. */
     if (range->min > range->max ||
-            (range->min == range->max && (range->minex || range->maxex)))
+            (range->min == range->max && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->tail;
-    if (x == NULL || !zslValueGteMin(x->score,range))
+    if (x == NULL || !zslValueGteMin(x->score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->header->level[0].forward;
-    if (x == NULL || !zslValueLteMax(x->score,range))
+    if (x == NULL || !zslValueLteMax(x->score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Find the first node that is contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInRange(zsl,range)) return NULL;
+    if (!zslIsInRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -346,18 +382,26 @@ zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score <= max. */
-    if (!zslValueLteMax(x->score,range)) return NULL;
+    if (!zslValueLteMax(x->score,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
 /* Find the last node that is contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInRange(zsl,range)) return NULL;
+    if (!zslIsInRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -371,7 +415,11 @@ zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score >= min. */
-    if (!zslValueGteMin(x->score,range)) return NULL;
+    if (!zslValueGteMin(x->score,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -380,6 +428,7 @@ zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
  * Note that this function takes the reference to the hash table view of the
  * sorted set, in order to remove the elements from the hash table too. */
 unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned long removed = 0;
     int i;
@@ -407,10 +456,12 @@ unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dic
         removed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
 unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned long removed = 0;
     int i;
@@ -436,12 +487,14 @@ unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *di
         removed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
 /* Delete all the elements with rank between start and end from the skiplist.
  * Start and end are inclusive. Note that start and end need to be 1-based */
 unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
+    volatile int __A_VARIABLE;
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned long traversed = 0, removed = 0;
     int i;
@@ -466,6 +519,7 @@ unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned
         traversed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -474,6 +528,7 @@ unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned
  * Note that the rank is 1-based due to the span of zsl->header to the
  * first element. */
 unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     unsigned long rank = 0;
     int i;
@@ -490,14 +545,17 @@ unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
 
         /* x might be equal to zsl->header, so test if obj is non-NULL */
         if (x->ele && sdscmp(x->ele,ele) == 0) {
+            __A_VARIABLE = 1;
             return rank;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Finds an element by its rank. The rank argument needs to be 1-based. */
 zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     unsigned long traversed = 0;
     int i;
@@ -510,9 +568,11 @@ zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
             x = x->level[i].forward;
         }
         if (traversed == rank) {
+            __A_VARIABLE = 1;
             return x;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -569,28 +629,40 @@ static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
   * If the string is not a valid range C_ERR is returned, and the value
   * of *dest and *ex is undefined. */
 int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
+    volatile int __A_VARIABLE;
     char *c = item->ptr;
 
     switch(c[0]) {
     case '+':
-        if (c[1] != '\0') return C_ERR;
+        if (c[1] != '\0') {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
         *ex = 1;
         *dest = shared.maxstring;
+        __A_VARIABLE = 1;
         return C_OK;
     case '-':
-        if (c[1] != '\0') return C_ERR;
+        if (c[1] != '\0') {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
         *ex = 1;
         *dest = shared.minstring;
+        __A_VARIABLE = 1;
         return C_OK;
     case '(':
         *ex = 1;
         *dest = sdsnewlen(c+1,sdslen(c)-1);
+        __A_VARIABLE = 1;
         return C_OK;
     case '[':
         *ex = 0;
         *dest = sdsnewlen(c+1,sdslen(c)-1);
+        __A_VARIABLE = 1;
         return C_OK;
     default:
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 }
@@ -598,10 +670,12 @@ int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
 /* Free a lex range structure, must be called only after zelParseLexRange()
  * populated the structure with success (C_OK returned). */
 void zslFreeLexRange(zlexrangespec *spec) {
+    volatile int __A_VARIABLE;
     if (spec->min != shared.minstring &&
         spec->min != shared.maxstring) sdsfree(spec->min);
     if (spec->max != shared.minstring &&
         spec->max != shared.maxstring) sdsfree(spec->max);
+    __A_VARIABLE = 1;
 }
 
 /* Populate the lex rangespec according to the objects min and max.
@@ -629,19 +703,34 @@ int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
  * handle shared.minstring and shared.maxstring as the equivalent of
  * -inf and +inf for strings */
 int sdscmplex(sds a, sds b) {
-    if (a == b) return 0;
-    if (a == shared.minstring || b == shared.maxstring) return -1;
-    if (a == shared.maxstring || b == shared.minstring) return 1;
+    volatile int __A_VARIABLE;
+    if (a == b) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (a == shared.minstring || b == shared.maxstring) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (a == shared.maxstring || b == shared.minstring) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    __A_VARIABLE = 1;
     return sdscmp(a,b);
 }
 
 int zslLexValueGteMin(sds value, zlexrangespec *spec) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return spec->minex ?
         (sdscmplex(value,spec->min) > 0) :
         (sdscmplex(value,spec->min) >= 0);
 }
 
 int zslLexValueLteMax(sds value, zlexrangespec *spec) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return spec->maxex ?
         (sdscmplex(value,spec->max) < 0) :
         (sdscmplex(value,spec->max) <= 0);
@@ -649,29 +738,41 @@ int zslLexValueLteMax(sds value, zlexrangespec *spec) {
 
 /* Returns if there is a part of the zset is in the lex range. */
 int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
 
     /* Test for ranges that will always be empty. */
     int cmp = sdscmplex(range->min,range->max);
-    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
+    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->tail;
-    if (x == NULL || !zslLexValueGteMin(x->ele,range))
+    if (x == NULL || !zslLexValueGteMin(x->ele,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->header->level[0].forward;
-    if (x == NULL || !zslLexValueLteMax(x->ele,range))
+    if (x == NULL || !zslLexValueLteMax(x->ele,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Find the first node that is contained in the specified lex range.
  * Returns NULL when no element is contained in the range. */
 zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInLexRange(zsl,range)) return NULL;
+    if (!zslIsInLexRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -686,18 +787,26 @@ zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score <= max. */
-    if (!zslLexValueLteMax(x->ele,range)) return NULL;
+    if (!zslLexValueLteMax(x->ele,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
 /* Find the last node that is contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     zskiplistNode *x;
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInLexRange(zsl,range)) return NULL;
+    if (!zslIsInLexRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -711,7 +820,11 @@ zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score >= min. */
-    if (!zslLexValueGteMin(x->ele,range)) return NULL;
+    if (!zslLexValueGteMin(x->ele,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -720,6 +833,7 @@ zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
  *----------------------------------------------------------------------------*/
 
 double zzlGetScore(unsigned char *sptr) {
+    volatile int __A_VARIABLE;
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
@@ -737,6 +851,7 @@ double zzlGetScore(unsigned char *sptr) {
         score = vlong;
     }
 
+    __A_VARIABLE = 1;
     return score;
 }
 
@@ -758,6 +873,7 @@ sds ziplistGetObject(unsigned char *sptr) {
 
 /* Compare element in sorted set with given element. */
 int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
+    volatile int __A_VARIABLE;
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
@@ -773,17 +889,24 @@ int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int cl
 
     minlen = (vlen < clen) ? vlen : clen;
     cmp = memcmp(vstr,cstr,minlen);
-    if (cmp == 0) return vlen-clen;
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return vlen-clen;
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
 unsigned int zzlLength(unsigned char *zl) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return ziplistLen(zl)/2;
 }
 
 /* Move to next entry based on the values in eptr and sptr. Both are set to
  * NULL when there is no next entry. */
 void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
+    volatile int __A_VARIABLE;
     unsigned char *_eptr, *_sptr;
     serverAssert(*eptr != NULL && *sptr != NULL);
 
@@ -798,11 +921,13 @@ void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
 
     *eptr = _eptr;
     *sptr = _sptr;
+    __A_VARIABLE = 1;
 }
 
 /* Move to the previous entry based on the values in eptr and sptr. Both are
  * set to NULL when there is no next entry. */
 void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
+    volatile int __A_VARIABLE;
     unsigned char *_eptr, *_sptr;
     serverAssert(*eptr != NULL && *sptr != NULL);
 
@@ -817,42 +942,58 @@ void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
 
     *eptr = _eptr;
     *sptr = _sptr;
+    __A_VARIABLE = 1;
 }
 
 /* Returns if there is a part of the zset is in range. Should only be used
  * internally by zzlFirstInRange and zzlLastInRange. */
 int zzlIsInRange(unsigned char *zl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *p;
     double score;
 
     /* Test for ranges that will always be empty. */
     if (range->min > range->max ||
-            (range->min == range->max && (range->minex || range->maxex)))
+            (range->min == range->max && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,-1); /* Last score. */
-    if (p == NULL) return 0; /* Empty sorted set */
+    if (p == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Empty sorted set */
     score = zzlGetScore(p);
-    if (!zslValueGteMin(score,range))
+    if (!zslValueGteMin(score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,1); /* First score. */
     serverAssert(p != NULL);
     score = zzlGetScore(p);
-    if (!zslValueLteMax(score,range))
+    if (!zslValueLteMax(score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Find pointer to the first element contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
     double score;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInRange(zl,range)) return NULL;
+    if (!zzlIsInRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
@@ -861,8 +1002,11 @@ unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
         score = zzlGetScore(sptr);
         if (zslValueGteMin(score,range)) {
             /* Check if score <= max. */
-            if (zslValueLteMax(score,range))
+            if (zslValueLteMax(score,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -870,17 +1014,22 @@ unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
         eptr = ziplistNext(zl,sptr);
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Find pointer to the last element contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
     double score;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInRange(zl,range)) return NULL;
+    if (!zzlIsInRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
@@ -889,8 +1038,11 @@ unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
         score = zzlGetScore(sptr);
         if (zslValueLteMax(score,range)) {
             /* Check if score >= min. */
-            if (zslValueGteMin(score,range))
+            if (zslValueGteMin(score,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -903,59 +1055,82 @@ unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
             eptr = NULL;
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
+    volatile int __A_VARIABLE;
     sds value = ziplistGetObject(p);
     int res = zslLexValueGteMin(value,spec);
     sdsfree(value);
+    __A_VARIABLE = 1;
     return res;
 }
 
 int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
+    volatile int __A_VARIABLE;
     sds value = ziplistGetObject(p);
     int res = zslLexValueLteMax(value,spec);
     sdsfree(value);
+    __A_VARIABLE = 1;
     return res;
 }
 
 /* Returns if there is a part of the zset is in range. Should only be used
  * internally by zzlFirstInRange and zzlLastInRange. */
 int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *p;
 
     /* Test for ranges that will always be empty. */
     int cmp = sdscmplex(range->min,range->max);
-    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
+    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,-2); /* Last element. */
-    if (p == NULL) return 0;
-    if (!zzlLexValueGteMin(p,range))
+    if (p == NULL) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    if (!zzlLexValueGteMin(p,range)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     p = ziplistIndex(zl,0); /* First element. */
     serverAssert(p != NULL);
-    if (!zzlLexValueLteMax(p,range))
+    if (!zzlLexValueLteMax(p,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Find pointer to the first element contained in the specified lex range.
  * Returns NULL when no element is contained in the range. */
 unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInLexRange(zl,range)) return NULL;
+    if (!zzlIsInLexRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         if (zzlLexValueGteMin(eptr,range)) {
             /* Check if score <= max. */
-            if (zzlLexValueLteMax(eptr,range))
+            if (zzlLexValueLteMax(eptr,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -965,22 +1140,30 @@ unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
         eptr = ziplistNext(zl,sptr); /* Next element. */
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Find pointer to the last element contained in the specified lex range.
  * Returns NULL when no element is contained in the range. */
 unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInLexRange(zl,range)) return NULL;
+    if (!zzlIsInLexRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         if (zzlLexValueLteMax(eptr,range)) {
             /* Check if score >= min. */
-            if (zzlLexValueGteMin(eptr,range))
+            if (zzlLexValueGteMin(eptr,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -993,10 +1176,12 @@ unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
             eptr = NULL;
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
 
     while (eptr != NULL) {
@@ -1006,27 +1191,32 @@ unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
         if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele))) {
             /* Matching element, pull out score. */
             if (score != NULL) *score = zzlGetScore(sptr);
+            __A_VARIABLE = 1;
             return eptr;
         }
 
         /* Move to next element. */
         eptr = ziplistNext(zl,sptr);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Delete (element,score) pair from ziplist. Use local copy of eptr because we
  * don't want to modify the one given as argument. */
 unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
+    volatile int __A_VARIABLE;
     unsigned char *p = eptr;
 
     /* TODO: add function to ziplist API to delete N elements from offset. */
     zl = ziplistDelete(zl,&p);
     zl = ziplistDelete(zl,&p);
+    __A_VARIABLE = 1;
     return zl;
 }
 
 unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
+    volatile int __A_VARIABLE;
     unsigned char *sptr;
     char scorebuf[128];
     int scorelen;
@@ -1046,12 +1236,14 @@ unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, doub
         serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
         zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
     }
+    __A_VARIABLE = 1;
     return zl;
 }
 
 /* Insert (element,score) pair in ziplist. This function assumes the element is
  * not yet present in the list. */
 unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
     double s;
 
@@ -1081,10 +1273,12 @@ unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
     /* Push on tail of list when it was not yet inserted. */
     if (eptr == NULL)
         zl = zzlInsertAt(zl,NULL,ele,score);
+    __A_VARIABLE = 1;
     return zl;
 }
 
 unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr, *sptr;
     double score;
     unsigned long num = 0;
@@ -1092,7 +1286,10 @@ unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsig
     if (deleted != NULL) *deleted = 0;
 
     eptr = zzlFirstInRange(zl,range);
-    if (eptr == NULL) return zl;
+    if (eptr == NULL) {
+        __A_VARIABLE = 1;
+        return zl;
+    }
 
     /* When the tail of the ziplist is deleted, eptr will point to the sentinel
      * byte and ziplistNext will return NULL. */
@@ -1110,17 +1307,22 @@ unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsig
     }
 
     if (deleted != NULL) *deleted = num;
+    __A_VARIABLE = 1;
     return zl;
 }
 
 unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {
+    volatile int __A_VARIABLE;
     unsigned char *eptr, *sptr;
     unsigned long num = 0;
 
     if (deleted != NULL) *deleted = 0;
 
     eptr = zzlFirstInLexRange(zl,range);
-    if (eptr == NULL) return zl;
+    if (eptr == NULL) {
+        __A_VARIABLE = 1;
+        return zl;
+    }
 
     /* When the tail of the ziplist is deleted, eptr will point to the sentinel
      * byte and ziplistNext will return NULL. */
@@ -1137,15 +1339,18 @@ unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsi
     }
 
     if (deleted != NULL) *deleted = num;
+    __A_VARIABLE = 1;
     return zl;
 }
 
 /* Delete all the elements with rank between start and end from the skiplist.
  * Start and end are inclusive. Note that start and end need to be 1-based */
 unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {
+    volatile int __A_VARIABLE;
     unsigned int num = (end-start)+1;
     if (deleted) *deleted = num;
     zl = ziplistDeleteRange(zl,2*(start-1),2*num);
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1154,6 +1359,7 @@ unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsig
  *----------------------------------------------------------------------------*/
 
 unsigned long zsetLength(const robj *zobj) {
+    volatile int __A_VARIABLE;
     unsigned long length = 0;
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         length = zzlLength(zobj->ptr);
@@ -1162,16 +1368,21 @@ unsigned long zsetLength(const robj *zobj) {
     } else {
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
     return length;
 }
 
 void zsetConvert(robj *zobj, int encoding) {
+    volatile int __A_VARIABLE;
     zset *zs;
     zskiplistNode *node, *next;
     sds ele;
     double score;
 
-    if (zobj->encoding == encoding) return;
+    if (zobj->encoding == encoding) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
@@ -1234,18 +1445,24 @@ void zsetConvert(robj *zobj, int encoding) {
     } else {
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Convert the sorted set object into a ziplist if it is not already a ziplist
  * and if the number of elements and the maximum element size is within the
  * expected ranges. */
 void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
-    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;
+    volatile int __A_VARIABLE;
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+            __A_VARIABLE = 1;
+            return;
+    }
     zset *zset = zobj->ptr;
 
     if (zset->zsl->length <= server.zset_max_ziplist_entries &&
         maxelelen <= server.zset_max_ziplist_value)
             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
+    __A_VARIABLE = 1;
 }
 
 /* Return (by reference) the score of the specified member of the sorted set
@@ -1530,6 +1747,7 @@ long zsetRank(robj *zobj, sds ele, int reverse) {
 
 /* This generic command implements both ZADD and ZINCRBY. */
 void zaddGenericCommand(client *c, int flags) {
+    volatile int __A_VARIABLE;
     static char *nanerr = "resulting score is not a number (NaN)";
     robj *key = c->argv[1];
     robj *zobj;
@@ -1569,6 +1787,7 @@ void zaddGenericCommand(client *c, int flags) {
     elements = c->argc-scoreidx;
     if (elements % 2 || !elements) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     elements /= 2; /* Now this holds the number of score-element pairs. */
@@ -1577,12 +1796,14 @@ void zaddGenericCommand(client *c, int flags) {
     if (nx && xx) {
         addReplyError(c,
             "XX and NX options at the same time are not compatible");
+        __A_VARIABLE = 1;
         return;
     }
 
     if (incr && elements > 1) {
         addReplyError(c,
             "INCR option supports a single increment-element pair");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1649,23 +1870,32 @@ cleanup:
         notifyKeyspaceEvent(NOTIFY_ZSET,
             incr ? "zincr" : "zadd", key, c->db->id);
     }
+    __A_VARIABLE = 1;
 }
 
 void zaddCommand(client *c) {
+    volatile int __A_VARIABLE;
     zaddGenericCommand(c,ZADD_NONE);
+    __A_VARIABLE = 1;
 }
 
 void zincrbyCommand(client *c) {
+    volatile int __A_VARIABLE;
     zaddGenericCommand(c,ZADD_INCR);
+    __A_VARIABLE = 1;
 }
 
 void zremCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *key = c->argv[1];
     robj *zobj;
     int deleted = 0, keyremoved = 0, j;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
@@ -1684,6 +1914,7 @@ void zremCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 /* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */
@@ -1791,15 +2022,21 @@ cleanup:
 }
 
 void zremrangebyrankCommand(client *c) {
+    volatile int __A_VARIABLE;
     zremrangeGenericCommand(c,ZRANGE_RANK);
+    __A_VARIABLE = 1;
 }
 
 void zremrangebyscoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     zremrangeGenericCommand(c,ZRANGE_SCORE);
+    __A_VARIABLE = 1;
 }
 
 void zremrangebylexCommand(client *c) {
+    volatile int __A_VARIABLE;
     zremrangeGenericCommand(c,ZRANGE_LEX);
+    __A_VARIABLE = 1;
 }
 
 typedef struct {
@@ -1862,8 +2099,11 @@ typedef union _iterset iterset;
 typedef union _iterzset iterzset;
 
 void zuiInitIterator(zsetopsrc *op) {
-    if (op->subject == NULL)
+    volatile int __A_VARIABLE;
+    if (op->subject == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
@@ -1895,11 +2135,15 @@ void zuiInitIterator(zsetopsrc *op) {
     } else {
         serverPanic("Unsupported type");
     }
+    __A_VARIABLE = 1;
 }
 
 void zuiClearIterator(zsetopsrc *op) {
-    if (op->subject == NULL)
+    volatile int __A_VARIABLE;
+    if (op->subject == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
@@ -1922,6 +2166,7 @@ void zuiClearIterator(zsetopsrc *op) {
     } else {
         serverPanic("Unsupported type");
     }
+    __A_VARIABLE = 1;
 }
 
 unsigned long zuiLength(zsetopsrc *op) {
@@ -2015,6 +2260,7 @@ int zuiNext(zsetopsrc *op, zsetopval *val) {
 }
 
 int zuiLongLongFromValue(zsetopval *val) {
+    volatile int __A_VARIABLE;
     if (!(val->flags & OPVAL_DIRTY_LL)) {
         val->flags |= OPVAL_DIRTY_LL;
 
@@ -2029,10 +2275,12 @@ int zuiLongLongFromValue(zsetopval *val) {
             val->flags |= OPVAL_VALID_LL;
         }
     }
+    __A_VARIABLE = 1;
     return val->flags & OPVAL_VALID_LL;
 }
 
 sds zuiSdsFromValue(zsetopval *val) {
+    volatile int __A_VARIABLE;
     if (val->ele == NULL) {
         if (val->estr != NULL) {
             val->ele = sdsnewlen((char*)val->estr,val->elen);
@@ -2041,6 +2289,7 @@ sds zuiSdsFromValue(zsetopval *val) {
         }
         val->flags |= OPVAL_DIRTY_SDS;
     }
+    __A_VARIABLE = 1;
     return val->ele;
 }
 
@@ -2063,6 +2312,7 @@ sds zuiNewSdsFromValue(zsetopval *val) {
 }
 
 int zuiBufferFromValue(zsetopval *val) {
+    volatile int __A_VARIABLE;
     if (val->estr == NULL) {
         if (val->ele != NULL) {
             val->elen = sdslen(val->ele);
@@ -2072,6 +2322,7 @@ int zuiBufferFromValue(zsetopval *val) {
             val->estr = val->_buf;
         }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -2131,10 +2382,18 @@ int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
 }
 
 int zuiCompareByCardinality(const void *s1, const void *s2) {
+    volatile int __A_VARIABLE;
     unsigned long first = zuiLength((zsetopsrc*)s1);
     unsigned long second = zuiLength((zsetopsrc*)s2);
-    if (first > second) return 1;
-    if (first < second) return -1;
+    if (first > second) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (first < second) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -2144,6 +2403,7 @@ int zuiCompareByCardinality(const void *s1, const void *s2) {
 #define zunionInterDictValue(_e) (dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))
 
 inline static void zunionInterAggregate(double *target, double val, int aggregate) {
+    volatile int __A_VARIABLE;
     if (aggregate == REDIS_AGGR_SUM) {
         *target = *target + val;
         /* The result of adding two doubles is NaN when one variable
@@ -2158,6 +2418,7 @@ inline static void zunionInterAggregate(double *target, double val, int aggregat
         /* safety net */
         serverPanic("Unknown ZUNION/INTER aggregate type");
     }
+    __A_VARIABLE = 1;
 }
 
 uint64_t dictSdsHash(const void *key);
@@ -2400,11 +2661,15 @@ void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
 }
 
 void zunionstoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void zinterstoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
+    __A_VARIABLE = 1;
 }
 
 void zrangeGenericCommand(client *c, int reverse) {
@@ -2510,11 +2775,15 @@ void zrangeGenericCommand(client *c, int reverse) {
 }
 
 void zrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     zrangeGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangeCommand(client *c) {
+    volatile int __A_VARIABLE;
     zrangeGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */
@@ -2710,11 +2979,15 @@ void genericZrangebyscoreCommand(client *c, int reverse) {
 }
 
 void zrangebyscoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericZrangebyscoreCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangebyscoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericZrangebyscoreCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void zcountCommand(client *c) {
@@ -3054,46 +3327,64 @@ void genericZrangebylexCommand(client *c, int reverse) {
 }
 
 void zrangebylexCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericZrangebylexCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangebylexCommand(client *c) {
+    volatile int __A_VARIABLE;
     genericZrangebylexCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void zcardCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *key = c->argv[1];
     robj *zobj;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,zsetLength(zobj));
+    __A_VARIABLE = 1;
 }
 
 void zscoreCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *key = c->argv[1];
     robj *zobj;
     double score;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
         addReply(c,shared.nullbulk);
     } else {
         addReplyDouble(c,score);
     }
+    __A_VARIABLE = 1;
 }
 
 void zrankGenericCommand(client *c, int reverse) {
+    volatile int __A_VARIABLE;
     robj *key = c->argv[1];
     robj *ele = c->argv[2];
     robj *zobj;
     long rank;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
     rank = zsetRank(zobj,ele->ptr,reverse);
@@ -3102,24 +3393,37 @@ void zrankGenericCommand(client *c, int reverse) {
     } else {
         addReply(c,shared.nullbulk);
     }
+    __A_VARIABLE = 1;
 }
 
 void zrankCommand(client *c) {
+    volatile int __A_VARIABLE;
     zrankGenericCommand(c, 0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrankCommand(client *c) {
+    volatile int __A_VARIABLE;
     zrankGenericCommand(c, 1);
+    __A_VARIABLE = 1;
 }
 
 void zscanCommand(client *c) {
+    volatile int __A_VARIABLE;
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,OBJ_ZSET)) return;
+        checkType(c,o,OBJ_ZSET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,o,cursor);
+    __A_VARIABLE = 1;
 }
 
 /* This command implements the generic zpop operation, used by:
@@ -3132,6 +3436,7 @@ void zscanCommand(client *c) {
  * The synchronous version instead does not need to emit the key, but may
  * use the 'count' argument to return multiple items if available. */
 void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg) {
+    volatile int __A_VARIABLE;
     int idx;
     robj *key = NULL;
     robj *zobj = NULL;
@@ -3141,10 +3446,13 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
 
     /* If a count argument as passed, parse it or return an error. */
     if (countarg) {
-        if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK)
+        if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         if (count <= 0) {
             addReply(c,shared.emptymultibulk);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -3155,13 +3463,17 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
         key = keyv[idx++];
         zobj = lookupKeyWrite(c->db,key);
         if (!zobj) continue;
-        if (checkType(c,zobj,OBJ_ZSET)) return;
+        if (checkType(c,zobj,OBJ_ZSET)) {
+            __A_VARIABLE = 1;
+            return;
+        }
         break;
     }
 
     /* No candidate for zpopping, return empty. */
     if (!zobj) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3233,26 +3545,33 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
     } while(--count);
 
     setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
+    __A_VARIABLE = 1;
 }
 
 /* ZPOPMIN key [<count>] */
 void zpopminCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc > 3) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     genericZpopCommand(c,&c->argv[1],1,ZSET_MIN,0,
         c->argc == 3 ? c->argv[2] : NULL);
+    __A_VARIABLE = 1;
 }
 
 /* ZMAXPOP key [<count>] */
 void zpopmaxCommand(client *c) {
+    volatile int __A_VARIABLE;
     if (c->argc > 3) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     genericZpopCommand(c,&c->argv[1],1,ZSET_MAX,0,
         c->argc == 3 ? c->argv[2] : NULL);
+    __A_VARIABLE = 1;
 }
 
 /* BZPOPMIN / BZPOPMAX actual implementation. */
@@ -3297,10 +3616,14 @@ void blockingGenericZpopCommand(client *c, int where) {
 
 // BZPOPMIN key [key ...] timeout
 void bzpopminCommand(client *c) {
+    volatile int __A_VARIABLE;
     blockingGenericZpopCommand(c,ZSET_MIN);
+    __A_VARIABLE = 1;
 }
 
 // BZPOPMAX key [key ...] timeout
 void bzpopmaxCommand(client *c) {
+    volatile int __A_VARIABLE;
     blockingGenericZpopCommand(c,ZSET_MAX);
+    __A_VARIABLE = 1;
 }
diff --git a/src/util.c b/src/util.c
index 0854254..cb3bfce 100644
--- a/src/util.c
+++ b/src/util.c
@@ -49,6 +49,7 @@
 int gettimeofday(struct timeval *tv, void *tz);
 static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 {
+	volatile int __A_VARIABLE;
 	int now;
 	struct timeval _ptimeval __attribute__((flexos_whitelist));
 	/* this argument is actually obsolete */
@@ -58,6 +59,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -187,11 +189,14 @@ int stringmatchlen(const char *pattern, int patternLen,
 }
 
 int stringmatch(const char *pattern, const char *string, int nocase) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
 }
 
 /* Fuzz stringmatchlen() trying to crash it with bad input. */
 int stringmatchlen_fuzz_test(void) {
+    volatile int __A_VARIABLE;
     char str[32];
     char pat[32];
     int cycles = 10000000;
@@ -203,6 +208,7 @@ int stringmatchlen_fuzz_test(void) {
         for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
         total_matches += stringmatchlen(pat, patlen, str, strlen, 0);
     }
+    __A_VARIABLE = 1;
     return total_matches;
 }
 
@@ -268,22 +274,40 @@ long long memtoll(const char *p, int *err) {
 /* Return the number of digits of 'v' when converted to string in radix 10.
  * See ll2string() for more information. */
 uint32_t digits10(uint64_t v) {
-    if (v < 10) return 1;
-    if (v < 100) return 2;
-    if (v < 1000) return 3;
+    volatile int __A_VARIABLE;
+    if (v < 10) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (v < 100) {
+        __A_VARIABLE = 1;
+        return 2;
+    }
+    if (v < 1000) {
+        __A_VARIABLE = 1;
+        return 3;
+    }
     if (v < 1000000000000UL) {
         if (v < 100000000UL) {
             if (v < 1000000) {
-                if (v < 10000) return 4;
+                if (v < 10000) {
+                    __A_VARIABLE = 1;
+                    return 4;
+                }
+                __A_VARIABLE = 1;
                 return 5 + (v >= 100000);
             }
+            __A_VARIABLE = 1;
             return 7 + (v >= 10000000UL);
         }
         if (v < 10000000000UL) {
+            __A_VARIABLE = 1;
             return 9 + (v >= 1000000000UL);
         }
+        __A_VARIABLE = 1;
         return 11 + (v >= 100000000000UL);
     }
+    __A_VARIABLE = 1;
     return 12 + digits10(v / 1000000000000UL);
 }
 
@@ -311,6 +335,7 @@ uint32_t sdigits10(int64_t v) {
  * Modified in order to handle signed integers since the original code was
  * designed for unsigned integers. */
 int ll2string(char *dst, size_t dstlen, long long svalue) {
+    volatile int __A_VARIABLE;
     static const char digits[201] =
         "0001020304050607080910111213141516171819"
         "2021222324252627282930313233343536373839"
@@ -336,7 +361,10 @@ int ll2string(char *dst, size_t dstlen, long long svalue) {
 
     /* Check length. */
     uint32_t const length = digits10(value)+negative;
-    if (length >= dstlen) return 0;
+    if (length >= dstlen) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Null term. */
     uint32_t next = length;
@@ -361,6 +389,7 @@ int ll2string(char *dst, size_t dstlen, long long svalue) {
 
     /* Add sign. */
     if (negative) dst[0] = '-';
+    __A_VARIABLE = 1;
     return length;
 }
 
@@ -446,15 +475,21 @@ int string2ll(const char *s, size_t slen, long long *value) {
  * (non-overflowing) long, 0 otherwise. The value will be set to the parsed
  * value when appropriate. */
 int string2l(const char *s, size_t slen, long *lval) {
+    volatile int __A_VARIABLE;
     long long llval;
 
-    if (!string2ll(s,slen,&llval))
+    if (!string2ll(s,slen,&llval)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
-    if (llval < LONG_MIN || llval > LONG_MAX)
+    if (llval < LONG_MIN || llval > LONG_MAX) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     *lval = (long)llval;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -466,11 +501,15 @@ int string2l(const char *s, size_t slen, long *lval) {
  * a double: no spaces or other characters before or after the string
  * representing the number are accepted. */
 int string2ld(const char *s, size_t slen, long double *dp) {
+    volatile int __A_VARIABLE;
     char buf[MAX_LONG_DOUBLE_CHARS];
     long double value;
     char *eptr;
 
-    if (slen >= sizeof(buf)) return 0;
+    if (slen >= sizeof(buf)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     memcpy(buf,s,slen);
     buf[slen] = '\0';
 
@@ -480,10 +519,13 @@ int string2ld(const char *s, size_t slen, long double *dp) {
         (errno == ERANGE &&
             (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
         errno == EINVAL ||
-        isnan(value))
+        isnan(value)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     if (dp) *dp = value;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -493,6 +535,7 @@ int string2ld(const char *s, size_t slen, long double *dp) {
  * does. It is intended mainly to be used inside t_zset.c when writing scores
  * into a ziplist representing a sorted set. */
 int d2string(char *buf, size_t len, double value) {
+    volatile int __A_VARIABLE;
     if (isnan(value)) {
         len = snprintf(buf,len,"nan");
     } else if (isinf(value)) {
@@ -526,6 +569,7 @@ int d2string(char *buf, size_t len, double value) {
             len = snprintf(buf,len,"%.17g",value);
     }
 
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -581,6 +625,7 @@ int ld2string(char *buf, size_t len, long double value, int humanfriendly) {
  *
  * This function is not thread safe, since the state is global. */
 void getRandomBytes(unsigned char *p, size_t len) {
+    volatile int __A_VARIABLE;
     /* Global state. */
     static int seed_initialized = 0;
     static unsigned char seed[20]; /* The SHA1 seed, from /dev/urandom. */
@@ -622,6 +667,7 @@ void getRandomBytes(unsigned char *p, size_t len) {
         len -= copylen;
         p += copylen;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Generate the Redis "Run ID", a SHA1-sized random number that identifies a
@@ -629,11 +675,13 @@ void getRandomBytes(unsigned char *p, size_t len) {
  * having run_id == A, and you reconnect and it has run_id == B, you can be
  * sure that it is either a different instance or it was restarted. */
 void getRandomHexChars(char *p, size_t len) {
+    volatile int __A_VARIABLE;
     char *charset = "0123456789abcdef";
     size_t j;
 
     getRandomBytes((unsigned char*)p,len);
     for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];
+    __A_VARIABLE = 1;
 }
 
 /* Given the filename, return the absolute path as an SDS string, or NULL
@@ -644,16 +692,21 @@ void getRandomHexChars(char *p, size_t len) {
  * case of one or more "../" appearing at the start of "filename"
  * relative path. */
 sds getAbsolutePath(char *filename) {
+    volatile int __A_VARIABLE;
     char cwd[1024];
     sds abspath;
     sds relpath = sdsnew(filename);
 
     relpath = sdstrim(relpath," \r\n\t");
-    if (relpath[0] == '/') return relpath; /* Path is already absolute. */
+    if (relpath[0] == '/') {
+        __A_VARIABLE = 1;
+        return relpath;
+    } /* Path is already absolute. */
 
     /* If path is relative, join cwd and relative path. */
     if (getcwd(cwd,sizeof(cwd)) == NULL) {
         sdsfree(relpath);
+        __A_VARIABLE = 1;
         return NULL;
     }
     abspath = sdsnew(cwd);
@@ -685,6 +738,7 @@ sds getAbsolutePath(char *filename) {
     /* Finally glue the two parts together. */
     abspath = sdscatsds(abspath,relpath);
     sdsfree(relpath);
+    __A_VARIABLE = 1;
     return abspath;
 }
 
@@ -711,6 +765,8 @@ unsigned long getTimeZone(void) {
  * character exists inside the specified path, that's enough in the
  * environments where Redis runs. */
 int pathIsBaseName(char *path) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
 }
 
@@ -718,6 +774,7 @@ int pathIsBaseName(char *path) {
 #include <assert.h>
 
 static void test_string2ll(void) {
+    volatile int __A_VARIABLE;
     char buf[32];
     long long v;
 
@@ -770,9 +827,11 @@ static void test_string2ll(void) {
 
     strcpy(buf,"9223372036854775808"); /* overflow */
     assert(string2ll(buf,strlen(buf),&v) == 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_string2l(void) {
+    volatile int __A_VARIABLE;
     char buf[32];
     long v;
 
@@ -819,9 +878,11 @@ static void test_string2l(void) {
     strcpy(buf,"2147483648"); /* overflow */
     assert(string2l(buf,strlen(buf),&v) == 0);
 #endif
+    __A_VARIABLE = 1;
 }
 
 static void test_ll2string(void) {
+    volatile int __A_VARIABLE;
     char buf[32];
     long long v;
     int sz;
@@ -860,16 +921,19 @@ static void test_ll2string(void) {
     sz = ll2string(buf, sizeof buf, v);
     assert(sz == 19);
     assert(!strcmp(buf, "9223372036854775807"));
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
 int utilTest(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     UNUSED(argc);
     UNUSED(argv);
 
     test_string2ll();
     test_string2l();
     test_ll2string();
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/zipmap.c b/src/zipmap.c
index 22bfa1a..665aef5 100644
--- a/src/zipmap.c
+++ b/src/zipmap.c
@@ -94,20 +94,27 @@
 
 /* Create a new empty zipmap. */
 unsigned char *zipmapNew(void) {
+    volatile int __A_VARIABLE;
     unsigned char *zm = zmalloc(2);
 
     zm[0] = 0; /* Length */
     zm[1] = ZIPMAP_END;
+    __A_VARIABLE = 1;
     return zm;
 }
 
 /* Decode the encoded length pointed by 'p' */
 static unsigned int zipmapDecodeLength(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned int len = *p;
 
-    if (len < ZIPMAP_BIGLEN) return len;
+    if (len < ZIPMAP_BIGLEN) {
+        __A_VARIABLE = 1;
+        return len;
+    }
     memcpy(&len,p+1,sizeof(unsigned int));
     memrev32ifbe(&len);
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -166,28 +173,34 @@ static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, uns
 }
 
 static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {
+    volatile int __A_VARIABLE;
     unsigned int l;
 
     l = klen+vlen+3;
     if (klen >= ZIPMAP_BIGLEN) l += 4;
     if (vlen >= ZIPMAP_BIGLEN) l += 4;
+    __A_VARIABLE = 1;
     return l;
 }
 
 /* Return the total amount used by a key (encoded length + payload) */
 static unsigned int zipmapRawKeyLength(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned int l = zipmapDecodeLength(p);
+    __A_VARIABLE = 1;
     return zipmapEncodeLength(NULL,l) + l;
 }
 
 /* Return the total amount used by a value
  * (encoded length + single byte free count + payload) */
 static unsigned int zipmapRawValueLength(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned int l = zipmapDecodeLength(p);
     unsigned int used;
 
     used = zipmapEncodeLength(NULL,l);
     used += p[used] + 1 + l;
+    __A_VARIABLE = 1;
     return used;
 }
 
@@ -195,13 +208,17 @@ static unsigned int zipmapRawValueLength(unsigned char *p) {
  * bytes used to store this entry (entry = key + associated value + trailing
  * free space if any). */
 static unsigned int zipmapRawEntryLength(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned int l = zipmapRawKeyLength(p);
+    __A_VARIABLE = 1;
     return l + zipmapRawValueLength(p+l);
 }
 
 static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
+    volatile int __A_VARIABLE;
     zm = zrealloc(zm, len);
     zm[len-1] = ZIPMAP_END;
+    __A_VARIABLE = 1;
     return zm;
 }
 
@@ -209,6 +226,7 @@ static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
  * If 'update' is not NULL, *update is set to 1 if the key was
  * already preset, otherwise to 0. */
 unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {
+    volatile int __A_VARIABLE;
     unsigned int zmlen, offset;
     unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);
     unsigned int empty, vempty;
@@ -273,12 +291,14 @@ unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int kle
     p += zipmapEncodeLength(p,vlen);
     *p++ = vempty;
     memcpy(p,val,vlen);
+    __A_VARIABLE = 1;
     return zm;
 }
 
 /* Remove the specified key. If 'deleted' is not NULL the pointed integer is
  * set to 0 if the key was not found, to 1 if it was found and deleted. */
 unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {
+    volatile int __A_VARIABLE;
     unsigned int zmlen, freelen;
     unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);
     if (p) {
@@ -293,11 +313,14 @@ unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int kle
     } else {
         if (deleted) *deleted = 0;
     }
+    __A_VARIABLE = 1;
     return zm;
 }
 
 /* Call before iterating through elements via zipmapNext() */
 unsigned char *zipmapRewind(unsigned char *zm) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zm+1;
 }
 
@@ -313,7 +336,11 @@ unsigned char *zipmapRewind(unsigned char *zm) {
  * }
  */
 unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
-    if (zm[0] == ZIPMAP_END) return NULL;
+    volatile int __A_VARIABLE;
+    if (zm[0] == ZIPMAP_END) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (key) {
         *key = zm;
         *klen = zipmapDecodeLength(zm);
@@ -326,28 +353,37 @@ unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *
         *value += ZIPMAP_LEN_BYTES(*vlen);
     }
     zm += zipmapRawValueLength(zm);
+    __A_VARIABLE = 1;
     return zm;
 }
 
 /* Search a key and retrieve the pointer and len of the associated value.
  * If the key is found the function returns 1, otherwise 0. */
 int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
+    volatile int __A_VARIABLE;
     unsigned char *p;
 
-    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
+    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     p += zipmapRawKeyLength(p);
     *vlen = zipmapDecodeLength(p);
     *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Return 1 if the key exists, otherwise 0 is returned. */
 int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
 }
 
 /* Return the number of entries inside a zipmap */
 unsigned int zipmapLen(unsigned char *zm) {
+    volatile int __A_VARIABLE;
     unsigned int len = 0;
     if (zm[0] < ZIPMAP_BIGLEN) {
         len = zm[0];
@@ -358,6 +394,7 @@ unsigned int zipmapLen(unsigned char *zm) {
         /* Re-store length if small enough */
         if (len < ZIPMAP_BIGLEN) zm[0] = len;
     }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -365,13 +402,16 @@ unsigned int zipmapLen(unsigned char *zm) {
  * the zipmap on disk (or everywhere is needed) just writing the returned
  * amount of bytes of the C array starting at the zipmap pointer. */
 size_t zipmapBlobLen(unsigned char *zm) {
+    volatile int __A_VARIABLE;
     unsigned int totlen;
     zipmapLookupRaw(zm,NULL,0,&totlen);
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 #ifdef REDIS_TEST
 static void zipmapRepr(unsigned char *p) {
+    volatile int __A_VARIABLE;
     unsigned int l;
 
     printf("{status %u}",*p++);
@@ -402,10 +442,12 @@ static void zipmapRepr(unsigned char *p) {
         }
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
 int zipmapTest(int argc, char *argv[]) {
+    volatile int __A_VARIABLE;
     unsigned char *zm;
 
     UNUSED(argc);
@@ -464,6 +506,7 @@ int zipmapTest(int argc, char *argv[]) {
             printf("  %d:%.*s => %d:%.*s\n", klen, klen, key, vlen, vlen, value);
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/zmalloc.c b/src/zmalloc.c
index 2482f51..1b3beaa 100644
--- a/src/zmalloc.c
+++ b/src/zmalloc.c
@@ -37,7 +37,9 @@
  * to define this function before including zmalloc.h that may shadow the
  * free implementation if we use jemalloc or another non standard allocator. */
 void zlibc_free(void *ptr) {
+    volatile int __A_VARIABLE;
     free(ptr);
+    __A_VARIABLE = 1;
 }
 
 #include <string.h>
@@ -87,10 +89,12 @@ static size_t used_memory = 0;
 pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void zmalloc_default_oom(size_t size) {
+    volatile int __A_VARIABLE;
     fprintf(stderr, "zmalloc: Out of memory trying to allocate %zu bytes\n",
         size);
     fflush(stderr);
     abort();
+    __A_VARIABLE = 1;
 }
 
 static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;
@@ -114,16 +118,23 @@ void *zmalloc(size_t size) {
  * Currently implemented only for jemalloc. Used for online defragmentation. */
 #ifdef HAVE_DEFRAG
 void *zmalloc_no_tcache(size_t size) {
+    volatile int __A_VARIABLE;
     void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);
     if (!ptr) zmalloc_oom_handler(size);
     update_zmalloc_stat_alloc(zmalloc_size(ptr));
+    __A_VARIABLE = 1;
     return ptr;
 }
 
 void zfree_no_tcache(void *ptr) {
-    if (ptr == NULL) return;
+    volatile int __A_VARIABLE;
+    if (ptr == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     update_zmalloc_stat_free(zmalloc_size(ptr));
     dallocx(ptr, MALLOCX_TCACHE_NONE);
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -175,25 +186,33 @@ void *zrealloc(void *ptr, size_t size) {
  * information as the first bytes of every allocation. */
 #ifndef HAVE_MALLOC_SIZE
 size_t zmalloc_size(void *ptr) {
+    volatile int __A_VARIABLE;
     void *realptr = (char*)ptr-PREFIX_SIZE;
     size_t size = *((size_t*)realptr);
     /* Assume at least that all the allocations are padded at sizeof(long) by
      * the underlying allocator. */
     if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));
+    __A_VARIABLE = 1;
     return size+PREFIX_SIZE;
 }
 size_t zmalloc_usable(void *ptr) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zmalloc_size(ptr)-PREFIX_SIZE;
 }
 #endif
 
 void zfree(void *ptr) {
+    volatile int __A_VARIABLE;
 #ifndef HAVE_MALLOC_SIZE
     void *realptr;
     size_t oldsize;
 #endif
 
-    if (ptr == NULL) return;
+    if (ptr == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 #ifdef HAVE_MALLOC_SIZE
     update_zmalloc_stat_free(zmalloc_size(ptr));
     free(ptr);
@@ -203,24 +222,31 @@ void zfree(void *ptr) {
     update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
     free(realptr);
 #endif
+    __A_VARIABLE = 1;
 }
 
 char *zstrdup(const char *s) {
+    volatile int __A_VARIABLE;
     size_t l = strlen(s)+1;
     char *p = zmalloc(l);
 
     memcpy(p,s,l);
+    __A_VARIABLE = 1;
     return p;
 }
 
 size_t zmalloc_used_memory(void) {
+    volatile int __A_VARIABLE;
     size_t um;
     atomicGet(used_memory,um);
+    __A_VARIABLE = 1;
     return um;
 }
 
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
+    volatile int __A_VARIABLE;
     zmalloc_oom_handler = oom_handler;
+    __A_VARIABLE = 1;
 }
 
 /* Get the RSS information in an OS-specific way.
@@ -240,6 +266,7 @@ void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
 #include <fcntl.h>
 
 size_t zmalloc_get_rss(void) {
+    volatile int __A_VARIABLE;
     int page = sysconf(_SC_PAGESIZE);
     size_t rss;
     char buf[4096];
@@ -248,9 +275,13 @@ size_t zmalloc_get_rss(void) {
     char *p, *x;
 
     snprintf(filename,256,"/proc/%d/stat",getpid());
-    if ((fd = open(filename,O_RDONLY)) == -1) return 0;
+    if ((fd = open(filename,O_RDONLY)) == -1) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (read(fd,buf,4096) <= 0) {
         close(fd);
+        __A_VARIABLE = 1;
         return 0;
     }
     close(fd);
@@ -261,13 +292,20 @@ size_t zmalloc_get_rss(void) {
         p = strchr(p,' ');
         if (p) p++;
     }
-    if (!p) return 0;
+    if (!p) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     x = strchr(p,' ');
-    if (!x) return 0;
+    if (!x) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     *x = '\0';
 
     rss = strtoll(p,NULL,10);
     rss *= page;
+    __A_VARIABLE = 1;
     return rss;
 }
 #elif defined(HAVE_TASKINFO)
@@ -280,23 +318,29 @@ size_t zmalloc_get_rss(void) {
 #include <mach/mach_init.h>
 
 size_t zmalloc_get_rss(void) {
+    volatile int __A_VARIABLE;
     task_t task = MACH_PORT_NULL;
     struct task_basic_info t_info;
     mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;
 
-    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)
+    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);
 
+    __A_VARIABLE = 1;
     return t_info.resident_size;
 }
 #else
 size_t zmalloc_get_rss(void) {
+    volatile int __A_VARIABLE;
     /* If we can't get the RSS in an OS-specific way for this system just
      * return the memory usage we estimated in zmalloc()..
      *
      * Fragmentation will appear to be always 1 (no fragmentation)
      * of course... */
+    __A_VARIABLE = 1;
     return zmalloc_used_memory();
 }
 #endif
@@ -305,6 +349,7 @@ size_t zmalloc_get_rss(void) {
 int zmalloc_get_allocator_info(size_t *allocated,
                                size_t *active,
                                size_t *resident) {
+    volatile int __A_VARIABLE;
     uint64_t epoch = 1;
     size_t sz;
     *allocated = *resident = *active = 0;
@@ -321,13 +366,16 @@ int zmalloc_get_allocator_info(size_t *allocated,
     /* Unlike zmalloc_used_memory, this matches the stats.resident by taking
      * into account all allocations done by this process (not only zmalloc). */
     je_mallctl("stats.allocated", allocated, &sz, NULL, 0);
+    __A_VARIABLE = 1;
     return 1;
 }
 #else
 int zmalloc_get_allocator_info(size_t *allocated,
                                size_t *active,
                                size_t *resident) {
+    volatile int __A_VARIABLE;
     *allocated = *resident = *active = 0;
+    __A_VARIABLE = 1;
     return 1;
 }
 #endif
@@ -344,6 +392,7 @@ int zmalloc_get_allocator_info(size_t *allocated,
  */
 #if defined(HAVE_PROC_SMAPS)
 size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
+    volatile int __A_VARIABLE;
     char line[1024];
     size_t bytes = 0;
     int flen = strlen(field);
@@ -357,7 +406,10 @@ size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
         fp = fopen(filename,"r");
     }
 
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     while(fgets(line,sizeof(line),fp) != NULL) {
         if (strncmp(line,field,flen) == 0) {
             char *p = strchr(line,'k');
@@ -368,17 +420,22 @@ size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
         }
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return bytes;
 }
 #else
 size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
+    volatile int __A_VARIABLE;
     ((void) field);
     ((void) pid);
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
 
 size_t zmalloc_get_private_dirty(long pid) {
+    volatile int __A_VARIABLE;
+    __A_VARIABLE = 1;
     return zmalloc_get_smap_bytes_by_field("Private_Dirty:",pid);
 }
 
@@ -441,6 +498,7 @@ size_t zmalloc_get_memory_size(void) {
 #ifdef REDIS_TEST
 #define UNUSED(x) ((void)(x))
 int zmalloc_test(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     void *ptr;
 
     UNUSED(argc);
@@ -452,6 +510,7 @@ int zmalloc_test(int argc, char **argv) {
     printf("Reallocated to 456 bytes; used: %zu\n", zmalloc_used_memory());
     zfree(ptr);
     printf("Freed pointer; used: %zu\n", zmalloc_used_memory());
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/tests/modules/commandfilter.c b/tests/modules/commandfilter.c
index d25d49c..f1f15b0 100644
--- a/tests/modules/commandfilter.c
+++ b/tests/modules/commandfilter.c
@@ -14,17 +14,20 @@ static RedisModuleCommandFilter *filter = NULL;
 
 int CommandFilter_UnregisterCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     (void) argc;
     (void) argv;
 
     RedisModule_ReplyWithLongLong(ctx,
             RedisModule_UnregisterCommandFilter(ctx, filter));
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int CommandFilter_PingCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     (void) argc;
     (void) argv;
 
@@ -36,11 +39,13 @@ int CommandFilter_PingCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModule_ReplyWithSimpleString(ctx, "Unknown command or invalid arguments");
     }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int CommandFilter_LogCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     RedisModuleString *s = RedisModule_CreateString(ctx, "", 0);
 
     int i;
@@ -71,12 +76,17 @@ int CommandFilter_LogCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
 
     in_log_command = 0;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void CommandFilter_CommandFilter(RedisModuleCommandFilterCtx *filter)
 {
-    if (in_log_command) return;  /* don't process our own RM_Call() from CommandFilter_LogCommand() */
+    volatile int __A_VARIABLE;
+    if (in_log_command) {
+        __A_VARIABLE = 1;
+        return;
+    }  /* don't process our own RM_Call() from CommandFilter_LogCommand() */
 
     /* Fun manipulations:
      * - Remove @delme
@@ -114,14 +124,20 @@ void CommandFilter_CommandFilter(RedisModuleCommandFilterCtx *filter)
 
     if (log) RedisModule_CommandFilterArgInsert(filter, 0,
             RedisModule_CreateString(NULL, log_command_name, sizeof(log_command_name)-1));
+    __A_VARIABLE = 1;
 }
 
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    volatile int __A_VARIABLE;
     if (RedisModule_Init(ctx,"commandfilter",1,REDISMODULE_APIVER_1)
-            == REDISMODULE_ERR) return REDISMODULE_ERR;
+            == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (argc != 2) {
         RedisModule_Log(ctx, "warning", "Log key name not specified");
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
 
@@ -130,20 +146,30 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_StringToLongLong(argv[1], &noself);
 
     if (RedisModule_CreateCommand(ctx,log_command_name,
-                CommandFilter_LogCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_LogCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,ping_command_name,
-                CommandFilter_PingCommand,"deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_PingCommand,"deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,unregister_command_name,
-                CommandFilter_UnregisterCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_UnregisterCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if ((filter = RedisModule_RegisterCommandFilter(ctx, CommandFilter_CommandFilter, 
                     noself ? REDISMODULE_CMDFILTER_NOSELF : 0))
-            == NULL) return REDISMODULE_ERR;
+            == NULL) {
+            __A_VARIABLE = 1;
+            return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/tests/modules/testrdb.c b/tests/modules/testrdb.c
index 415497a..3601358 100644
--- a/tests/modules/testrdb.c
+++ b/tests/modules/testrdb.c
@@ -14,20 +14,25 @@ RedisModuleString *before_str = NULL;
 RedisModuleString *after_str = NULL;
 
 void *testrdb_type_load(RedisModuleIO *rdb, int encver) {
+    volatile int __A_VARIABLE;
     int count = RedisModule_LoadSigned(rdb);
     assert(count==1);
     assert(encver==1);
     RedisModuleString *str = RedisModule_LoadString(rdb);
+    __A_VARIABLE = 1;
     return str;
 }
 
 void testrdb_type_save(RedisModuleIO *rdb, void *value) {
+    volatile int __A_VARIABLE;
     RedisModuleString *str = (RedisModuleString*)value;
     RedisModule_SaveSigned(rdb, 1);
     RedisModule_SaveString(rdb, str);
+    __A_VARIABLE = 1;
 }
 
 void testrdb_aux_save(RedisModuleIO *rdb, int when) {
+    volatile int __A_VARIABLE;
     if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
     if (conf_aux_count==0) assert(0);
     if (when == REDISMODULE_AUX_BEFORE_RDB) {
@@ -45,9 +50,11 @@ void testrdb_aux_save(RedisModuleIO *rdb, int when) {
             RedisModule_SaveSigned(rdb, 0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
+    volatile int __A_VARIABLE;
     assert(encver == 1);
     if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
     if (conf_aux_count==0) assert(0);
@@ -67,17 +74,22 @@ int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
         if (count)
             after_str = RedisModule_LoadString(rdb);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void testrdb_type_free(void *value) {
+    volatile int __A_VARIABLE;
     RedisModule_FreeString(NULL, (RedisModuleString*)value);
+    __A_VARIABLE = 1;
 }
 
 int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     if (argc != 2) {
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -86,27 +98,33 @@ int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     before_str = argv[1];
     RedisModule_RetainString(ctx, argv[1]);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int testrdb_get_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     if (argc != 1){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
     if (before_str)
         RedisModule_ReplyWithString(ctx, before_str);
     else
         RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     if (argc != 2){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -115,27 +133,33 @@ int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     after_str = argv[1];
     RedisModule_RetainString(ctx, argv[1]);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int testrdb_get_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     REDISMODULE_NOT_USED(argv);
     if (argc != 1){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
     if (after_str)
         RedisModule_ReplyWithString(ctx, after_str);
     else
         RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     if (argc != 3){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -147,13 +171,16 @@ int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_RetainString(ctx, argv[2]);
     RedisModule_CloseKey(key);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
+    volatile int __A_VARIABLE;
     if (argc != 2){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -161,6 +188,7 @@ int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
     RedisModule_CloseKey(key);
     RedisModule_ReplyWithString(ctx, str);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
diff --git a/utils/corrupt_rdb.c b/utils/corrupt_rdb.c
index df9c93e..6985838 100644
--- a/utils/corrupt_rdb.c
+++ b/utils/corrupt_rdb.c
@@ -12,6 +12,7 @@
 #include <time.h>
 
 int main(int argc, char **argv) {
+    volatile int __A_VARIABLE;
     struct stat stat;
     int fd, cycles;
 
@@ -41,5 +42,6 @@ int main(int argc, char **argv) {
         printf("Writing %d bytes at offset %lu\n", writelen, offset);
         write(fd,buf,writelen);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/utils/hashtable/rehashing.c b/utils/hashtable/rehashing.c
index b57a904..4e5cc43 100644
--- a/utils/hashtable/rehashing.c
+++ b/utils/hashtable/rehashing.c
@@ -2,11 +2,14 @@
 #include "dict.h"
 
 void _redisAssert(char *x, char *y, int l) {
+    volatile int __A_VARIABLE;
     printf("ASSERT: %s %s %d\n",x,y,l);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 unsigned int dictKeyHash(const void *keyp) {
+    volatile int __A_VARIABLE;
     unsigned long key = (unsigned long)keyp;
     key = dictGenHashFunction(&key,sizeof(key));
     key += ~(key << 15);
@@ -15,12 +18,15 @@ unsigned int dictKeyHash(const void *keyp) {
     key ^=  (key >> 6);
     key += ~(key << 11);
     key ^=  (key >> 16);
+    __A_VARIABLE = 1;
     return key;
 }
 
 int dictKeyCompare(void *privdata, const void *key1, const void *key2) {
+    volatile int __A_VARIABLE;
     unsigned long k1 = (unsigned long)key1;
     unsigned long k2 = (unsigned long)key2;
+    __A_VARIABLE = 1;
     return k1 == k2;
 }
 
@@ -34,6 +40,7 @@ dictType dictTypeTest = {
 };
 
 void showBuckets(dictht ht) {
+    volatile int __A_VARIABLE;
     if (ht.table == NULL) {
         printf("NULL\n");
     } else {
@@ -43,9 +50,11 @@ void showBuckets(dictht ht) {
         }
         printf("\n");
     }
+    __A_VARIABLE = 1;
 }
 
 void show(dict *d) {
+    volatile int __A_VARIABLE;
     int j;
     if (d->rehashidx != -1) {
         printf("rhidx: ");
@@ -58,17 +67,21 @@ void show(dict *d) {
     printf("ht[1]: ");
     showBuckets(d->ht[1]);
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 int sortPointers(const void *a, const void *b) {
+    volatile int __A_VARIABLE;
     unsigned long la, lb;
 
     la = (long) (*((dictEntry**)a));
     lb = (long) (*((dictEntry**)b));
+    __A_VARIABLE = 1;
     return la-lb;
 }
 
 void stressGetKeys(dict *d, int times, int *perfect_run, int *approx_run) {
+    volatile int __A_VARIABLE;
     int j;
 
     dictEntry **des = zmalloc(sizeof(dictEntry*)*dictSize(d));
@@ -94,11 +107,13 @@ void stressGetKeys(dict *d, int times, int *perfect_run, int *approx_run) {
         }
     }
     zfree(des);
+    __A_VARIABLE = 1;
 }
 
 #define MAX1 120
 #define MAX2 1000
 int main(void) {
+    volatile int __A_VARIABLE;
     dict *d = dictCreate(&dictTypeTest,NULL);
     unsigned long i;
     srand(time(NULL));
@@ -138,5 +153,6 @@ int main(void) {
     dictRelease(d);
 
     printf("TEST PASSED!\n");
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/utils/lru/lfu-simulation.c b/utils/lru/lfu-simulation.c
index 6aa5911..bb7a97d 100644
--- a/utils/lru/lfu-simulation.c
+++ b/utils/lru/lfu-simulation.c
@@ -26,7 +26,12 @@ struct entry {
  * we detect the overflow we account for it as if the counter wrapped
  * a single time. */
 uint16_t minutes_diff(uint16_t now, uint16_t prev) {
-    if (now >= prev) return now-prev;
+    volatile int __A_VARIABLE;
+    if (now >= prev) {
+        __A_VARIABLE = 1;
+        return now-prev;
+    }
+    __A_VARIABLE = 1;
     return 65535-prev+now;
 }
 
@@ -34,24 +39,32 @@ uint16_t minutes_diff(uint16_t now, uint16_t prev) {
  * less likely is that the counter is really incremented.
  * The maximum value of the counter is saturated at 255. */
 uint8_t log_incr(uint8_t counter) {
-    if (counter == 255) return counter;
+    volatile int __A_VARIABLE;
+    if (counter == 255) {
+        __A_VARIABLE = 1;
+        return counter;
+    }
     double r = (double)rand()/RAND_MAX;
     double baseval = counter-COUNTER_INIT_VAL;
     if (baseval < 0) baseval = 0;
     double limit = 1.0/(baseval*10+1);
     if (r < limit) counter++;
+    __A_VARIABLE = 1;
     return counter;
 }
 
 /* Simulate an access to an entry. */
 void access_entry(struct entry *e) {
+    volatile int __A_VARIABLE;
     e->counter = log_incr(e->counter);
     e->hits++;
+    __A_VARIABLE = 1;
 }
 
 /* Return the entry LFU value and as a side effect decrement the
  * entry value if the decrement time was reached. */
 uint8_t scan_entry(struct entry *e) {
+    volatile int __A_VARIABLE;
     if (minutes_diff(to_16bit_minutes(time(NULL)),e->decrtime)
         >= decr_every)
     {
@@ -64,11 +77,13 @@ uint8_t scan_entry(struct entry *e) {
         }
         e->decrtime = to_16bit_minutes(time(NULL));
     }
+    __A_VARIABLE = 1;
     return e->counter;
 }
 
 /* Print the entry info. */
 void show_entry(long pos, struct entry *e) {
+    volatile int __A_VARIABLE;
     char *tag = "normal       ";
 
     if (pos >= 10 && pos <= 14) tag = "new no access";
@@ -78,9 +93,11 @@ void show_entry(long pos, struct entry *e) {
     printf("%ld] <%s> frequency:%d decrtime:%d [%lu hits | age:%ld sec]\n",
         pos, tag, e->counter, e->decrtime, (unsigned long)e->hits,
             time(NULL) - e->ctime);
+    __A_VARIABLE = 1;
 }
 
 int main(void) {
+    volatile int __A_VARIABLE;
     time_t start = time(NULL);
     time_t new_entry_time = start;
     time_t display_time = start;
@@ -153,6 +170,7 @@ int main(void) {
             display_time = now;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
-- 
2.34.1

