From 24f102d20d63830563f802a4f6d1461b2f85eccf Mon Sep 17 00:00:00 2001
From: Mateusz Krajewski <mkrajewski413@gmail.com>
Date: Sun, 12 Feb 2023 12:10:30 +0000
Subject: [PATCH 1/1] Some changes

Signed-off-by: Mateusz Krajewski <mkrajewski413@gmail.com>
---
 deps/hiredis/async.c                          |  90 +-
 deps/hiredis/dict.c                           |  70 +-
 deps/hiredis/examples/example-ae.c            |  13 +-
 deps/hiredis/examples/example-glib.c          |   5 +
 deps/hiredis/examples/example-ivykis.c        |  13 +-
 deps/hiredis/examples/example-libev.c         |  13 +-
 deps/hiredis/examples/example-libevent.c      |  13 +-
 deps/hiredis/examples/example-libuv.c         |  13 +-
 deps/hiredis/examples/example-macosx.c        |  14 +-
 deps/hiredis/examples/example.c               |   2 +
 deps/hiredis/hiredis.c                        | 195 +++-
 deps/hiredis/net.c                            |  25 +
 deps/hiredis/read.c                           |  41 +-
 deps/hiredis/sds.c                            | 175 +++-
 deps/hiredis/test.c                           |  21 +-
 deps/jemalloc/src/arena.c                     | 127 +++
 deps/jemalloc/src/background_thread.c         |  43 +
 deps/jemalloc/src/base.c                      |  32 +
 deps/jemalloc/src/bin.c                       |   6 +
 deps/jemalloc/src/bitmap.c                    |  10 +
 deps/jemalloc/src/ckh.c                       |  34 +
 deps/jemalloc/src/ctl.c                       |   1 +
 deps/jemalloc/src/div.c                       |   2 +
 deps/jemalloc/src/extent.c                    | 130 +++
 deps/jemalloc/src/extent_dss.c                |  19 +
 deps/jemalloc/src/extent_mmap.c               |   4 +
 deps/jemalloc/src/hash.c                      |   1 +
 deps/jemalloc/src/hooks.c                     |   1 +
 deps/jemalloc/src/jemalloc.c                  | 104 +++
 deps/jemalloc/src/large.c                     |  21 +
 deps/jemalloc/src/log.c                       |   6 +
 deps/jemalloc/src/malloc_io.c                 |  12 +
 deps/jemalloc/src/mutex.c                     |  11 +
 deps/jemalloc/src/mutex_pool.c                |   3 +
 deps/jemalloc/src/nstime.c                    |  24 +
 deps/jemalloc/src/pages.c                     |  26 +
 deps/jemalloc/src/prng.c                      |   1 +
 deps/jemalloc/src/prof.c                      | 156 ++++
 deps/jemalloc/src/rtree.c                     |   1 +
 deps/jemalloc/src/stats.c                     |  15 +
 deps/jemalloc/src/sz.c                        |   1 +
 deps/jemalloc/src/tcache.c                    |  33 +
 deps/jemalloc/src/ticker.c                    |   1 +
 deps/jemalloc/src/tsd.c                       |  18 +
 deps/jemalloc/src/witness.c                   |  13 +
 deps/jemalloc/src/zone.c                      |  32 +
 .../jemalloc/test/integration/MALLOCX_ARENA.c |   4 +
 .../jemalloc/test/integration/aligned_alloc.c |   6 +
 deps/jemalloc/test/integration/allocated.c    |   6 +
 deps/jemalloc/test/integration/extent.c       |  10 +
 deps/jemalloc/test/integration/mallocx.c      |  11 +
 deps/jemalloc/test/integration/overflow.c     |   3 +
 .../test/integration/posix_memalign.c         |   6 +
 deps/jemalloc/test/integration/rallocx.c      |  11 +
 deps/jemalloc/test/integration/sdallocx.c     |   4 +
 deps/jemalloc/test/integration/thread_arena.c |   5 +
 .../test/integration/thread_tcache_enabled.c  |   5 +
 deps/jemalloc/test/integration/xallocx.c      |  19 +
 deps/jemalloc/test/src/SFMT.c                 |  30 +
 deps/jemalloc/test/src/btalloc.c              |   2 +
 deps/jemalloc/test/src/btalloc_0.c            |   1 +
 deps/jemalloc/test/src/btalloc_1.c            |   1 +
 deps/jemalloc/test/src/math.c                 |   1 +
 deps/jemalloc/test/src/mq.c                   |   2 +
 deps/jemalloc/test/src/mtx.c                  |   4 +
 deps/jemalloc/test/src/test.c                 |  29 +-
 deps/jemalloc/test/src/thd.c                  |   5 +
 deps/jemalloc/test/src/timer.c                |   6 +
 deps/jemalloc/test/stress/microbench.c        |  22 +
 deps/jemalloc/test/unit/SFMT.c                |   2 +
 deps/jemalloc/test/unit/a0.c                  |   3 +
 deps/jemalloc/test/unit/arena_reset.c         |  25 +
 deps/jemalloc/test/unit/arena_reset_prof.c    |   1 +
 deps/jemalloc/test/unit/atomic.c              |   8 +
 deps/jemalloc/test/unit/background_thread.c   |   6 +
 .../test/unit/background_thread_enable.c      |   4 +
 deps/jemalloc/test/unit/base.c                |   5 +
 deps/jemalloc/test/unit/bit_util.c            |   5 +
 deps/jemalloc/test/unit/bitmap.c              |   1 +
 deps/jemalloc/test/unit/ckh.c                 |   5 +
 deps/jemalloc/test/unit/decay.c               |  24 +
 deps/jemalloc/test/unit/div.c                 |   3 +
 deps/jemalloc/test/unit/emitter.c             |  12 +
 deps/jemalloc/test/unit/extent_quantize.c     |   5 +
 deps/jemalloc/test/unit/fork.c                |   6 +
 deps/jemalloc/test/unit/hash.c                |   1 +
 deps/jemalloc/test/unit/hooks.c               |   6 +
 deps/jemalloc/test/unit/junk.c                |   9 +
 deps/jemalloc/test/unit/junk_alloc.c          |   1 +
 deps/jemalloc/test/unit/junk_free.c           |   1 +
 deps/jemalloc/test/unit/log.c                 |   4 +
 deps/jemalloc/test/unit/mallctl.c             |  28 +
 deps/jemalloc/test/unit/malloc_io.c           |   6 +
 deps/jemalloc/test/unit/math.c                |  11 +
 deps/jemalloc/test/unit/mq.c                  |   5 +
 deps/jemalloc/test/unit/mtx.c                 |   5 +
 deps/jemalloc/test/unit/nstime.c              |  15 +
 deps/jemalloc/test/unit/pack.c                |   8 +
 deps/jemalloc/test/unit/pages.c               |   3 +
 deps/jemalloc/test/unit/ph.c                  |  14 +
 deps/jemalloc/test/unit/prng.c                |  18 +
 deps/jemalloc/test/unit/prof_accum.c          |   6 +
 deps/jemalloc/test/unit/prof_active.c         |  10 +
 deps/jemalloc/test/unit/prof_gdump.c          |   4 +
 deps/jemalloc/test/unit/prof_idump.c          |   4 +
 deps/jemalloc/test/unit/prof_reset.c          |  11 +
 deps/jemalloc/test/unit/prof_tctx.c           |   3 +
 deps/jemalloc/test/unit/prof_thread_name.c    |   6 +
 deps/jemalloc/test/unit/ql.c                  |  10 +
 deps/jemalloc/test/unit/qr.c                  |  10 +
 deps/jemalloc/test/unit/rb.c                  |  11 +
 deps/jemalloc/test/unit/retained.c            |  10 +
 deps/jemalloc/test/unit/rtree.c               |  13 +
 deps/jemalloc/test/unit/size_classes.c        |   6 +
 deps/jemalloc/test/unit/slab.c                |   3 +
 deps/jemalloc/test/unit/smoothstep.c          |   5 +
 deps/jemalloc/test/unit/spin.c                |   3 +
 deps/jemalloc/test/unit/stats.c               |  12 +
 deps/jemalloc/test/unit/stats_print.c         |   1 +
 deps/jemalloc/test/unit/ticker.c              |   5 +
 deps/jemalloc/test/unit/tsd.c                 |  10 +
 deps/jemalloc/test/unit/witness.c             |  14 +
 deps/jemalloc/test/unit/zero.c                |   5 +
 deps/linenoise/example.c                      |   5 +
 deps/linenoise/linenoise.c                    | 124 ++-
 deps/lua/etc/all.c                            |   1 +
 deps/lua/etc/min.c                            |   3 +
 deps/lua/etc/noparser.c                       |   4 +
 deps/lua/src/fpconv.c                         |  29 +-
 deps/lua/src/lapi.c                           | 108 ++-
 deps/lua/src/lauxlib.c                        |  86 +-
 deps/lua/src/lbaselib.c                       |  60 +-
 deps/lua/src/lcode.c                          |  93 +-
 deps/lua/src/ldblib.c                         |  39 +-
 deps/lua/src/ldebug.c                         |  57 +-
 deps/lua/src/ldo.c                            |  31 +-
 deps/lua/src/ldump.c                          |  12 +
 deps/lua/src/lfunc.c                          |  17 +-
 deps/lua/src/lgc.c                            |  56 +-
 deps/lua/src/linit.c                          |   2 +
 deps/lua/src/liolib.c                         |  35 +
 deps/lua/src/llex.c                           |   1 +
 deps/lua/src/lmathlib.c                       |  33 +-
 deps/lua/src/lmem.c                           |   4 +
 deps/lua/src/loadlib.c                        |  85 +-
 deps/lua/src/lobject.c                        |  22 +-
 deps/lua/src/lopcodes.c                       |   1 +
 deps/lua/src/loslib.c                         |  26 +-
 deps/lua/src/lparser.c                        | 161 +++-
 deps/lua/src/lstate.c                         |  16 +-
 deps/lua/src/lstring.c                        |  12 +-
 deps/lua/src/lstrlib.c                        |  72 +-
 deps/lua/src/ltable.c                         |  42 +-
 deps/lua/src/ltablib.c                        |  29 +-
 deps/lua/src/ltm.c                            |   3 +
 deps/lua/src/lua.c                            |  89 +-
 deps/lua/src/lua_bit.c                        |   1 +
 deps/lua/src/lua_cjson.c                      |   1 +
 deps/lua/src/lua_cmsgpack.c                   |   1 +
 deps/lua/src/lua_struct.c                     |  52 +-
 deps/lua/src/luac.c                           |   8 +
 deps/lua/src/lundump.c                        |  13 +
 deps/lua/src/lvm.c                            |  73 +-
 deps/lua/src/lzio.c                           |  16 +-
 deps/lua/src/print.c                          |  14 +-
 deps/lua/src/strbuf.c                         |  17 +-
 src/adlist.c                                  |  10 +-
 src/ae.c                                      |  68 +-
 src/ae_epoll.c                                |  20 +-
 src/ae_evport.c                               |  26 +-
 src/ae_kqueue.c                               |  25 +-
 src/ae_select.c                               |  18 +-
 src/anet.c                                    | 105 ++-
 src/aof.c                                     | 147 ++-
 src/bio.c                                     |   8 +
 src/bitops.c                                  |  47 +-
 src/blocked.c                                 |  27 +-
 src/childinfo.c                               |  15 +-
 src/cluster.c                                 | 344 ++++++-
 src/config.c                                  |  71 +-
 src/crc16.c                                   |   2 +
 src/crc64.c                                   |   3 +
 src/db.c                                      | 145 ++-
 src/debug.c                                   |  58 +-
 src/defrag.c                                  |  75 +-
 src/dict.c                                    | 165 +++-
 src/endianconv.c                              |   8 +
 src/evict.c                                   |  58 +-
 src/expire.c                                  |  46 +-
 src/geo.c                                     |  54 +-
 src/geohash.c                                 |  45 +-
 src/geohash_helper.c                          |  30 +-
 src/hyperloglog.c                             |  72 +-
 src/intset.c                                  |  21 +
 src/latency.c                                 |  28 +-
 src/lazyfree.c                                |   8 +
 src/listpack.c                                | 111 ++-
 src/localtime.c                               |   3 +
 src/lolwut.c                                  |   3 +
 src/lolwut5.c                                 |  33 +-
 src/lzf_c.c                                   |   1 +
 src/lzf_d.c                                   |   1 +
 src/memtest.c                                 |  25 +-
 src/module.c                                  | 841 +++++++++++++++---
 src/modules/helloblock.c                      |  37 +-
 src/modules/hellocluster.c                    |  20 +-
 src/modules/hellodict.c                       |  32 +-
 src/modules/hellotimer.c                      |  13 +-
 src/modules/hellotype.c                       |  57 +-
 src/modules/helloworld.c                      |   1 +
 src/modules/testmodule.c                      |  74 +-
 src/multi.c                                   |  41 +-
 src/networking.c                              | 219 ++++-
 src/notify.c                                  |  12 +-
 src/object.c                                  |  92 +-
 src/pqsort.c                                  |   6 +
 src/pubsub.c                                  |  17 +
 src/quicklist.c                               |  46 +-
 src/rand.c                                    |   4 +
 src/rax.c                                     |  83 +-
 src/rdb.c                                     | 323 +++++--
 src/redis-benchmark.c                         |  33 +-
 src/redis-check-aof.c                         |  15 +
 src/redis-check-rdb.c                         |  20 +-
 src/redis-cli.c                               | 465 ++++++++--
 src/release.c                                 |   3 +
 src/replication.c                             | 109 ++-
 src/rio.c                                     |  54 +-
 src/scripting.c                               | 118 ++-
 src/sds.c                                     | 158 +++-
 src/sentinel.c                                | 292 +++++-
 src/server.c                                  | 168 +++-
 src/setproctitle.c                            |  25 +-
 src/sha1.c                                    |   6 +
 src/siphash.c                                 |   7 +-
 src/slowlog.c                                 |  11 +-
 src/sort.c                                    |  10 +
 src/sparkline.c                               |   6 +
 src/syncio.c                                  |   1 +
 src/t_hash.c                                  |  99 ++-
 src/t_list.c                                  |  98 +-
 src/t_set.c                                   | 101 ++-
 src/t_stream.c                                | 125 ++-
 src/t_string.c                                |  84 +-
 src/t_zset.c                                  | 345 +++++--
 src/util.c                                    |  69 +-
 src/ziplist.c                                 |   1 +
 src/zipmap.c                                  |  33 +-
 src/zmalloc.c                                 |  55 +-
 tests/modules/commandfilter.c                 |  34 +-
 tests/modules/testrdb.c                       |  18 +
 utils/corrupt_rdb.c                           |   2 +
 utils/hashtable/rehashing.c                   |   9 +
 utils/lru/lfu-simulation.c                    |  17 +-
 254 files changed, 9048 insertions(+), 1137 deletions(-)

diff --git a/deps/hiredis/async.c b/deps/hiredis/async.c
index d955203..7fac9f8 100644
--- a/deps/hiredis/async.c
+++ b/deps/hiredis/async.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
  * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
@@ -62,6 +63,7 @@ int __redisAppendCommand(redisContext *c, const char *cmd, size_t len);
 
 /* Functions managing dictionary of callbacks for pub/sub. */
 static unsigned int callbackHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction((const unsigned char *)key,
                                sdslen((const sds)key));
 }
@@ -70,6 +72,7 @@ static void *callbackValDup(void *privdata, const void *src) {
     ((void) privdata);
     redisCallback *dup = malloc(sizeof(*dup));
     memcpy(dup,src,sizeof(*dup));
+    __A_VARIABLE = 1;
     return dup;
 }
 
@@ -79,18 +82,24 @@ static int callbackKeyCompare(void *privdata, const void *key1, const void *key2
 
     l1 = sdslen((const sds)key1);
     l2 = sdslen((const sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1,key2,l1) == 0;
 }
 
 static void callbackKeyDestructor(void *privdata, void *key) {
     ((void) privdata);
     sdsfree((sds)key);
+    __A_VARIABLE = 1;
 }
 
 static void callbackValDestructor(void *privdata, void *val) {
     ((void) privdata);
     free(val);
+    __A_VARIABLE = 1;
 }
 
 static dictType callbackDict = {
@@ -106,8 +115,10 @@ static redisAsyncContext *redisAsyncInitialize(redisContext *c) {
     redisAsyncContext *ac;
 
     ac = realloc(c,sizeof(redisAsyncContext));
-    if (ac == NULL)
+    if (ac == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c = &(ac->c);
 
@@ -136,18 +147,22 @@ static redisAsyncContext *redisAsyncInitialize(redisContext *c) {
     ac->sub.invalid.tail = NULL;
     ac->sub.channels = dictCreate(&callbackDict,NULL);
     ac->sub.patterns = dictCreate(&callbackDict,NULL);
+    __A_VARIABLE = 1;
     return ac;
 }
 
 /* We want the error field to be accessible directly instead of requiring
  * an indirection to the redisContext struct. */
 static void __redisAsyncCopyError(redisAsyncContext *ac) {
-    if (!ac)
+    if (!ac) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     redisContext *c = &(ac->c);
     ac->err = c->err;
     ac->errstr = c->errstr;
+    __A_VARIABLE = 1;
 }
 
 redisAsyncContext *redisAsyncConnect(const char *ip, int port) {
@@ -155,16 +170,20 @@ redisAsyncContext *redisAsyncConnect(const char *ip, int port) {
     redisAsyncContext *ac;
 
     c = redisConnectNonBlock(ip,port);
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     ac = redisAsyncInitialize(c);
     if (ac == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
@@ -173,6 +192,7 @@ redisAsyncContext *redisAsyncConnectBind(const char *ip, int port,
     redisContext *c = redisConnectBindNonBlock(ip,port,source_addr);
     redisAsyncContext *ac = redisAsyncInitialize(c);
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
@@ -181,6 +201,7 @@ redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
     redisContext *c = redisConnectBindNonBlockWithReuse(ip,port,source_addr);
     redisAsyncContext *ac = redisAsyncInitialize(c);
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
@@ -189,16 +210,20 @@ redisAsyncContext *redisAsyncConnectUnix(const char *path) {
     redisAsyncContext *ac;
 
     c = redisConnectUnixNonBlock(path);
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     ac = redisAsyncInitialize(c);
     if (ac == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     __redisAsyncCopyError(ac);
+    __A_VARIABLE = 1;
     return ac;
 }
 
@@ -210,16 +235,20 @@ int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn
          * the first write event to be fired. This assumes the related event
          * library functions are already set. */
         _EL_ADD_WRITE(ac);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn) {
     if (ac->onDisconnect == NULL) {
         ac->onDisconnect = fn;
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -229,8 +258,10 @@ static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {
 
     /* Copy callback from stack to heap */
     cb = malloc(sizeof(*cb));
-    if (cb == NULL)
+    if (cb == NULL) {
+        __A_VARIABLE = 1;
         return REDIS_ERR_OOM;
+    }
 
     if (source != NULL) {
         memcpy(cb,source,sizeof(*cb));
@@ -243,6 +274,7 @@ static int __redisPushCallback(redisCallbackList *list, redisCallback *source) {
     if (list->tail != NULL)
         list->tail->next = cb;
     list->tail = cb;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -257,8 +289,10 @@ static int __redisShiftCallback(redisCallbackList *list, redisCallback *target)
         if (target != NULL)
             memcpy(target,cb,sizeof(*cb));
         free(cb);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -269,6 +303,7 @@ static void __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisRe
         cb->fn(ac,reply,cb->privdata);
         c->flags &= ~REDIS_IN_CALLBACK;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to free the context. */
@@ -314,6 +349,7 @@ static void __redisAsyncFree(redisAsyncContext *ac) {
 
     /* Cleanup self */
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Free the async context. When this function is called from a callback,
@@ -325,6 +361,7 @@ void redisAsyncFree(redisAsyncContext *ac) {
     c->flags |= REDIS_FREEING;
     if (!(c->flags & REDIS_IN_CALLBACK))
         __redisAsyncFree(ac);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to make the disconnect happen and clean up. */
@@ -346,6 +383,7 @@ static void __redisAsyncDisconnect(redisAsyncContext *ac) {
     /* For non-clean disconnects, __redisAsyncFree() will execute pending
      * callbacks with a NULL-reply. */
     __redisAsyncFree(ac);
+    __A_VARIABLE = 1;
 }
 
 /* Tries to do a clean disconnect from Redis, meaning it stops new commands
@@ -359,6 +397,7 @@ void redisAsyncDisconnect(redisAsyncContext *ac) {
     c->flags |= REDIS_DISCONNECTING;
     if (!(c->flags & REDIS_IN_CALLBACK) && ac->replies.head == NULL)
         __redisAsyncDisconnect(ac);
+    __A_VARIABLE = 1;
 }
 
 static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply, redisCallback *dstcb) {
@@ -405,6 +444,7 @@ static int __redisGetSubscribeCallback(redisAsyncContext *ac, redisReply *reply,
         /* Shift callback for invalid commands. */
         __redisShiftCallback(&ac->sub.invalid,dstcb);
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -496,17 +536,21 @@ static int __redisAsyncHandleConnect(redisAsyncContext *ac) {
 
     if (redisCheckSocketError(c) == REDIS_ERR) {
         /* Try again later when connect(2) is still in progress. */
-        if (errno == EINPROGRESS)
+        if (errno == EINPROGRESS) {
+            __A_VARIABLE = 1;
             return REDIS_OK;
+        }
 
         if (ac->onConnect) ac->onConnect(ac,REDIS_ERR);
         __redisAsyncDisconnect(ac);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     /* Mark context as connected. */
     c->flags |= REDIS_CONNECTED;
     if (ac->onConnect) ac->onConnect(ac,REDIS_OK);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -518,11 +562,15 @@ void redisAsyncHandleRead(redisAsyncContext *ac) {
 
     if (!(c->flags & REDIS_CONNECTED)) {
         /* Abort connect was not successful. */
-        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
+        if (__redisAsyncHandleConnect(ac) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         /* Try again later when the context is still not connected. */
-        if (!(c->flags & REDIS_CONNECTED))
+        if (!(c->flags & REDIS_CONNECTED)) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     if (redisBufferRead(c) == REDIS_ERR) {
@@ -532,6 +580,7 @@ void redisAsyncHandleRead(redisAsyncContext *ac) {
         _EL_ADD_READ(ac);
         redisProcessCallbacks(ac);
     }
+    __A_VARIABLE = 1;
 }
 
 void redisAsyncHandleWrite(redisAsyncContext *ac) {
@@ -540,11 +589,15 @@ void redisAsyncHandleWrite(redisAsyncContext *ac) {
 
     if (!(c->flags & REDIS_CONNECTED)) {
         /* Abort connect was not successful. */
-        if (__redisAsyncHandleConnect(ac) != REDIS_OK)
+        if (__redisAsyncHandleConnect(ac) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         /* Try again later when the context is still not connected. */
-        if (!(c->flags & REDIS_CONNECTED))
+        if (!(c->flags & REDIS_CONNECTED)) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     if (redisBufferWrite(c,&done) == REDIS_ERR) {
@@ -559,6 +612,7 @@ void redisAsyncHandleWrite(redisAsyncContext *ac) {
         /* Always schedule reads after writes */
         _EL_ADD_READ(ac);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Sets a pointer to the first argument and its length starting at p. Returns
@@ -567,13 +621,17 @@ static const char *nextArgument(const char *start, const char **str, size_t *len
     const char *p = start;
     if (p[0] != '$') {
         p = strchr(p,'$');
-        if (p == NULL) return NULL;
+        if (p == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
 
     *len = (int)strtol(p+1,NULL,10);
     p = strchr(p,'\r');
     assert(p);
     *str = p+2;
+    __A_VARIABLE = 1;
     return p+2+(*len)+2;
 }
 
@@ -654,11 +712,14 @@ int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdat
     len = redisvFormatCommand(&cmd,format,ap);
 
     /* We don't want to pass -1 or -2 to future functions as a length. */
-    if (len < 0)
+    if (len < 0) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     free(cmd);
+    __A_VARIABLE = 1;
     return status;
 }
 
@@ -668,6 +729,7 @@ int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata
     va_start(ap,format);
     status = redisvAsyncCommand(ac,fn,privdata,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return status;
 }
 
@@ -678,10 +740,12 @@ int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *priv
     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     sdsfree(cmd);
+    __A_VARIABLE = 1;
     return status;
 }
 
 int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
     int status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
+    __A_VARIABLE = 1;
     return status;
 }
diff --git a/deps/hiredis/dict.c b/deps/hiredis/dict.c
index e17a625..d055daf 100644
--- a/deps/hiredis/dict.c
+++ b/deps/hiredis/dict.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Hash table implementation.
  *
  * This file implements in memory hash tables with insert/del/replace/find/
@@ -55,6 +56,7 @@ static unsigned int dictGenHashFunction(const unsigned char *buf, int len) {
 
     while (len--)
         hash = ((hash << 5) + hash) + (*buf++); /* hash * 33 + c */
+    __A_VARIABLE = 1;
     return hash;
 }
 
@@ -67,12 +69,14 @@ static void _dictReset(dict *ht) {
     ht->size = 0;
     ht->sizemask = 0;
     ht->used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Create a new hash table */
 static dict *dictCreate(dictType *type, void *privDataPtr) {
     dict *ht = malloc(sizeof(*ht));
     _dictInit(ht,type,privDataPtr);
+    __A_VARIABLE = 1;
     return ht;
 }
 
@@ -81,6 +85,7 @@ static int _dictInit(dict *ht, dictType *type, void *privDataPtr) {
     _dictReset(ht);
     ht->type = type;
     ht->privdata = privDataPtr;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -91,8 +96,10 @@ static int dictExpand(dict *ht, unsigned long size) {
 
     /* the size is invalid if it is smaller than the number of
      * elements already inside the hashtable */
-    if (ht->used > size)
+    if (ht->used > size) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     _dictInit(&n, ht->type, ht->privdata);
     n.size = realsize;
@@ -128,6 +135,7 @@ static int dictExpand(dict *ht, unsigned long size) {
 
     /* Remap the new hashtable in the old */
     *ht = n;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -138,8 +146,10 @@ static int dictAdd(dict *ht, void *key, void *val) {
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = _dictKeyIndex(ht, key)) == -1)
+    if ((index = _dictKeyIndex(ht, key)) == -1) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     /* Allocates the memory and stores key */
     entry = malloc(sizeof(*entry));
@@ -150,6 +160,7 @@ static int dictAdd(dict *ht, void *key, void *val) {
     dictSetHashKey(ht, entry, key);
     dictSetHashVal(ht, entry, val);
     ht->used++;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -162,8 +173,10 @@ static int dictReplace(dict *ht, void *key, void *val) {
 
     /* Try to add the element. If the key
      * does not exists dictAdd will succeed. */
-    if (dictAdd(ht, key, val) == DICT_OK)
+    if (dictAdd(ht, key, val) == DICT_OK) {
+        __A_VARIABLE = 1;
         return 1;
+    }
     /* It already exists, get the entry */
     entry = dictFind(ht, key);
     /* Free the old value and set the new one */
@@ -175,6 +188,7 @@ static int dictReplace(dict *ht, void *key, void *val) {
     auxentry = *entry;
     dictSetHashVal(ht, entry, val);
     dictFreeEntryVal(ht, &auxentry);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -183,8 +197,10 @@ static int dictDelete(dict *ht, const void *key) {
     unsigned int h;
     dictEntry *de, *prevde;
 
-    if (ht->size == 0)
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
     h = dictHashKey(ht, key) & ht->sizemask;
     de = ht->table[h];
 
@@ -201,11 +217,13 @@ static int dictDelete(dict *ht, const void *key) {
             dictFreeEntryVal(ht,de);
             free(de);
             ht->used--;
+            __A_VARIABLE = 1;
             return DICT_OK;
         }
         prevde = de;
         de = de->next;
     }
+    __A_VARIABLE = 1;
     return DICT_ERR; /* not found */
 }
 
@@ -231,6 +249,7 @@ static int _dictClear(dict *ht) {
     free(ht->table);
     /* Re-initialize the table */
     _dictReset(ht);
+    __A_VARIABLE = 1;
     return DICT_OK; /* never fails */
 }
 
@@ -238,20 +257,27 @@ static int _dictClear(dict *ht) {
 static void dictRelease(dict *ht) {
     _dictClear(ht);
     free(ht);
+    __A_VARIABLE = 1;
 }
 
 static dictEntry *dictFind(dict *ht, const void *key) {
     dictEntry *he;
     unsigned int h;
 
-    if (ht->size == 0) return NULL;
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     h = dictHashKey(ht, key) & ht->sizemask;
     he = ht->table[h];
     while(he) {
-        if (dictCompareHashKeys(ht, key, he->key))
+        if (dictCompareHashKeys(ht, key, he->key)) {
+            __A_VARIABLE = 1;
             return he;
+        }
         he = he->next;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -262,6 +288,7 @@ static dictIterator *dictGetIterator(dict *ht) {
     iter->index = -1;
     iter->entry = NULL;
     iter->nextEntry = NULL;
+    __A_VARIABLE = 1;
     return iter;
 }
 
@@ -279,14 +306,17 @@ static dictEntry *dictNext(dictIterator *iter) {
             /* We need to save the 'next' here, the iterator user
              * may delete the entry we are returning. */
             iter->nextEntry = iter->entry->next;
+            __A_VARIABLE = 1;
             return iter->entry;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static void dictReleaseIterator(dictIterator *iter) {
     free(iter);
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- private functions ------------------------------ */
@@ -295,10 +325,15 @@ static void dictReleaseIterator(dictIterator *iter) {
 static int _dictExpandIfNeeded(dict *ht) {
     /* If the hash table is empty expand it to the initial size,
      * if the table is "full" dobule its size. */
-    if (ht->size == 0)
+    if (ht->size == 0) {
+        __A_VARIABLE = 1;
         return dictExpand(ht, DICT_HT_INITIAL_SIZE);
-    if (ht->used == ht->size)
+    }
+    if (ht->used == ht->size) {
+        __A_VARIABLE = 1;
         return dictExpand(ht, ht->size*2);
+    }
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -306,12 +341,18 @@ static int _dictExpandIfNeeded(dict *ht) {
 static unsigned long _dictNextPower(unsigned long size) {
     unsigned long i = DICT_HT_INITIAL_SIZE;
 
-    if (size >= LONG_MAX) return LONG_MAX;
+    if (size >= LONG_MAX) {
+        __A_VARIABLE = 1;
+        return LONG_MAX;
+    }
     while(1) {
-        if (i >= size)
+        if (i >= size) {
+            __A_VARIABLE = 1;
             return i;
+        }
         i *= 2;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Returns the index of a free slot that can be populated with
@@ -322,17 +363,22 @@ static int _dictKeyIndex(dict *ht, const void *key) {
     dictEntry *he;
 
     /* Expand the hashtable if needed */
-    if (_dictExpandIfNeeded(ht) == DICT_ERR)
+    if (_dictExpandIfNeeded(ht) == DICT_ERR) {
+        __A_VARIABLE = 1;
         return -1;
+    }
     /* Compute the key hash value */
     h = dictHashKey(ht, key) & ht->sizemask;
     /* Search if this slot does not already contain the given key */
     he = ht->table[h];
     while(he) {
-        if (dictCompareHashKeys(ht, key, he->key))
+        if (dictCompareHashKeys(ht, key, he->key)) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         he = he->next;
     }
+    __A_VARIABLE = 1;
     return h;
 }
 
diff --git a/deps/hiredis/examples/example-ae.c b/deps/hiredis/examples/example-ae.c
index 8efa730..b400a78 100644
--- a/deps/hiredis/examples/example-ae.c
+++ b/deps/hiredis/examples/example-ae.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -12,32 +13,40 @@ static aeEventLoop *loop;
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
         aeStop(loop);
+        __A_VARIABLE = 1;
         return;
     }
 
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
         aeStop(loop);
+        __A_VARIABLE = 1;
         return;
     }
 
     printf("Disconnected...\n");
     aeStop(loop);
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -47,6 +56,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -57,6 +67,7 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     aeMain(loop);
+    __A_VARIABLE = 1;
     return 0;
 }
 
diff --git a/deps/hiredis/examples/example-glib.c b/deps/hiredis/examples/example-glib.c
index d6e10f8..8888cd6 100644
--- a/deps/hiredis/examples/example-glib.c
+++ b/deps/hiredis/examples/example-glib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdlib.h>
 
 #include <hiredis.h>
@@ -16,6 +17,7 @@ connect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
     } else {
         g_printerr("Connected...\n");
     }
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -28,6 +30,7 @@ disconnect_cb (const redisAsyncContext *ac G_GNUC_UNUSED,
         g_printerr("Disconnected...\n");
         g_main_loop_quit(mainloop);
     }
+    __A_VARIABLE = 1;
 }
 
 static void
@@ -42,6 +45,7 @@ command_cb(redisAsyncContext *ac,
     }
 
     redisAsyncDisconnect(ac);
+    __A_VARIABLE = 1;
 }
 
 gint
@@ -69,5 +73,6 @@ main (gint argc     G_GNUC_UNUSED,
 
     g_main_loop_run(mainloop);
 
+    __A_VARIABLE = 1;
     return EXIT_SUCCESS;
 }
diff --git a/deps/hiredis/examples/example-ivykis.c b/deps/hiredis/examples/example-ivykis.c
index 67affce..22c93e1 100644
--- a/deps/hiredis/examples/example-ivykis.c
+++ b/deps/hiredis/examples/example-ivykis.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -9,27 +10,35 @@
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -41,6 +50,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -54,5 +64,6 @@ int main (int argc, char **argv) {
 
     iv_deinit();
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libev.c b/deps/hiredis/examples/example-libev.c
index cc8b166..61d00ef 100644
--- a/deps/hiredis/examples/example-libev.c
+++ b/deps/hiredis/examples/example-libev.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -9,27 +10,35 @@
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -39,6 +48,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -48,5 +58,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     ev_loop(EV_DEFAULT_ 0);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libevent.c b/deps/hiredis/examples/example-libevent.c
index d333c22..e0fc8f7 100644
--- a/deps/hiredis/examples/example-libevent.c
+++ b/deps/hiredis/examples/example-libevent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -9,27 +10,35 @@
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -40,6 +49,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -49,5 +59,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     event_base_dispatch(base);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-libuv.c b/deps/hiredis/examples/example-libuv.c
index a5462d4..b27f2ff 100644
--- a/deps/hiredis/examples/example-libuv.c
+++ b/deps/hiredis/examples/example-libuv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -9,27 +10,35 @@
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -40,6 +49,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -49,5 +59,6 @@ int main (int argc, char **argv) {
     redisAsyncCommand(c, NULL, NULL, "SET key %b", argv[argc-1], strlen(argv[argc-1]));
     redisAsyncCommand(c, getCallback, (char*)"end-1", "GET key");
     uv_run(loop, UV_RUN_DEFAULT);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/examples/example-macosx.c b/deps/hiredis/examples/example-macosx.c
index bc84ed5..5345f6e 100644
--- a/deps/hiredis/examples/example-macosx.c
+++ b/deps/hiredis/examples/example-macosx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 //
 //  Created by Дмитрий Бахвалов on 13.07.15.
 //  Copyright (c) 2015 Dmitry Bakhvalov. All rights reserved.
@@ -11,28 +12,36 @@
 
 void getCallback(redisAsyncContext *c, void *r, void *privdata) {
     redisReply *reply = r;
-    if (reply == NULL) return;
+    if (reply == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("argv[%s]: %s\n", (char*)privdata, reply->str);
 
     /* Disconnect after receiving the reply to GET */
     redisAsyncDisconnect(c);
+    __A_VARIABLE = 1;
 }
 
 void connectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     printf("Connected...\n");
+    __A_VARIABLE = 1;
 }
 
 void disconnectCallback(const redisAsyncContext *c, int status) {
     if (status != REDIS_OK) {
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return;
     }
     CFRunLoopStop(CFRunLoopGetCurrent());
     printf("Disconnected...\n");
+    __A_VARIABLE = 1;
 }
 
 int main (int argc, char **argv) {
@@ -41,6 +50,7 @@ int main (int argc, char **argv) {
     CFRunLoopRef loop = CFRunLoopGetCurrent();
     if( !loop ) {
         printf("Error: Cannot get current run loop\n");
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -48,6 +58,7 @@ int main (int argc, char **argv) {
     if (c->err) {
         /* Let *c leak for now... */
         printf("Error: %s\n", c->errstr);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -61,6 +72,7 @@ int main (int argc, char **argv) {
 
     CFRunLoopRun();
 
+    __A_VARIABLE = 1;
     return 0;
 }
 
diff --git a/deps/hiredis/examples/example.c b/deps/hiredis/examples/example.c
index 4d494c5..39fcb83 100644
--- a/deps/hiredis/examples/example.c
+++ b/deps/hiredis/examples/example.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -74,5 +75,6 @@ int main(int argc, char **argv) {
     /* Disconnects and frees the context */
     redisFree(c);
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/hiredis/hiredis.c b/deps/hiredis/hiredis.c
index 18bdfc9..a09089a 100644
--- a/deps/hiredis/hiredis.c
+++ b/deps/hiredis/hiredis.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
  * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>
@@ -63,10 +64,13 @@ static redisReplyObjectFunctions defaultFunctions = {
 static redisReply *createReplyObject(int type) {
     redisReply *r = calloc(1,sizeof(*r));
 
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->type = type;
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -75,8 +79,10 @@ void freeReplyObject(void *reply) {
     redisReply *r = reply;
     size_t j;
 
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     switch(r->type) {
     case REDIS_REPLY_INTEGER:
@@ -97,6 +103,7 @@ void freeReplyObject(void *reply) {
         break;
     }
     free(r);
+    __A_VARIABLE = 1;
 }
 
 static void *createStringObject(const redisReadTask *task, char *str, size_t len) {
@@ -104,12 +111,15 @@ static void *createStringObject(const redisReadTask *task, char *str, size_t len
     char *buf;
 
     r = createReplyObject(task->type);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     buf = malloc(len+1);
     if (buf == NULL) {
         freeReplyObject(r);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -128,6 +138,7 @@ static void *createStringObject(const redisReadTask *task, char *str, size_t len
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -135,13 +146,16 @@ static void *createArrayObject(const redisReadTask *task, int elements) {
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_ARRAY);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     if (elements > 0) {
         r->element = calloc(elements,sizeof(redisReply*));
         if (r->element == NULL) {
             freeReplyObject(r);
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -153,6 +167,7 @@ static void *createArrayObject(const redisReadTask *task, int elements) {
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -160,8 +175,10 @@ static void *createIntegerObject(const redisReadTask *task, long long value) {
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_INTEGER);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->integer = value;
 
@@ -170,6 +187,7 @@ static void *createIntegerObject(const redisReadTask *task, long long value) {
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -177,14 +195,17 @@ static void *createNilObject(const redisReadTask *task) {
     redisReply *r, *parent;
 
     r = createReplyObject(REDIS_REPLY_NIL);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     if (task->parent) {
         parent = task->parent->obj;
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -193,17 +214,31 @@ static void *createNilObject(const redisReadTask *task) {
 static uint32_t countDigits(uint64_t v) {
   uint32_t result = 1;
   for (;;) {
-    if (v < 10) return result;
-    if (v < 100) return result + 1;
-    if (v < 1000) return result + 2;
-    if (v < 10000) return result + 3;
+    if (v < 10) {
+      __A_VARIABLE = 1;
+      return result;
+    }
+    if (v < 100) {
+      __A_VARIABLE = 1;
+      return result + 1;
+    }
+    if (v < 1000) {
+      __A_VARIABLE = 1;
+      return result + 2;
+    }
+    if (v < 10000) {
+      __A_VARIABLE = 1;
+      return result + 3;
+    }
     v /= 10000U;
     result += 4;
   }
+  __A_VARIABLE = 1;
 }
 
 /* Helper that calculates the bulk length given a certain string length. */
 static size_t bulklen(size_t len) {
+    __A_VARIABLE = 1;
     return 1+countDigits(len)+2+len+2;
 }
 
@@ -220,13 +255,17 @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {
     int j;
 
     /* Abort if there is not target to set */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Build the command string accordingly to protocol */
     curarg = sdsempty();
-    if (curarg == NULL)
+    if (curarg == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     while(*c != '\0') {
         if (*c != '%' || c[1] == '\0') {
@@ -414,6 +453,7 @@ int redisvFormatCommand(char **target, const char *format, va_list ap) {
 
     free(curargv);
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 
 format_err:
@@ -438,6 +478,7 @@ cleanup:
     if (cmd != NULL)
         free(cmd);
 
+    __A_VARIABLE = 1;
     return error_type;
 }
 
@@ -465,6 +506,7 @@ int redisFormatCommand(char **target, const char *format, ...) {
     if (len < 0)
         len = -1;
 
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -483,8 +525,10 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
     size_t len;
 
     /* Abort on a NULL target */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Calculate our total size */
     totlen = 1+countDigits(argc)+2;
@@ -495,13 +539,17 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
 
     /* Use an SDS string for command construction */
     cmd = sdsempty();
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* We already know how much storage we need */
     cmd = sdsMakeRoomFor(cmd, totlen);
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Construct command */
     cmd = sdscatfmt(cmd, "*%i\r\n", argc);
@@ -515,11 +563,13 @@ int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
     assert(sdslen(cmd)==totlen);
 
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 void redisFreeSdsCommand(sds cmd) {
     sdsfree(cmd);
+    __A_VARIABLE = 1;
 }
 
 /* Format a command according to the Redis protocol. This function takes the
@@ -534,8 +584,10 @@ int redisFormatCommandArgv(char **target, int argc, const char **argv, const siz
     int totlen, j;
 
     /* Abort on a NULL target */
-    if (target == NULL)
+    if (target == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     /* Calculate number of bytes needed for the command */
     totlen = 1+countDigits(argc)+2;
@@ -546,8 +598,10 @@ int redisFormatCommandArgv(char **target, int argc, const char **argv, const siz
 
     /* Build the command at protocol level */
     cmd = malloc(totlen+1);
-    if (cmd == NULL)
+    if (cmd == NULL) {
+        __A_VARIABLE = 1;
         return -1;
+    }
 
     pos = sprintf(cmd,"*%d\r\n",argc);
     for (j = 0; j < argc; j++) {
@@ -562,11 +616,13 @@ int redisFormatCommandArgv(char **target, int argc, const char **argv, const siz
     cmd[pos] = '\0';
 
     *target = cmd;
+    __A_VARIABLE = 1;
     return totlen;
 }
 
 void redisFreeCommand(char *cmd) {
     free(cmd);
+    __A_VARIABLE = 1;
 }
 
 void __redisSetError(redisContext *c, int type, const char *str) {
@@ -583,9 +639,11 @@ void __redisSetError(redisContext *c, int type, const char *str) {
         assert(type == REDIS_ERR_IO);
         __redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
     }
+    __A_VARIABLE = 1;
 }
 
 redisReader *redisReaderCreate(void) {
+    __A_VARIABLE = 1;
     return redisReaderCreateWithFunctions(&defaultFunctions);
 }
 
@@ -593,8 +651,10 @@ static redisContext *redisContextInit(void) {
     redisContext *c;
 
     c = calloc(1,sizeof(redisContext));
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->err = 0;
     c->errstr[0] = '\0';
@@ -607,15 +667,19 @@ static redisContext *redisContextInit(void) {
 
     if (c->obuf == NULL || c->reader == NULL) {
         redisFree(c);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
+    __A_VARIABLE = 1;
     return c;
 }
 
 void redisFree(redisContext *c) {
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
     if (c->fd > 0)
         close(c->fd);
     if (c->obuf != NULL)
@@ -631,12 +695,14 @@ void redisFree(redisContext *c) {
     if (c->timeout)
         free(c->timeout);
     free(c);
+    __A_VARIABLE = 1;
 }
 
 int redisFreeKeepFd(redisContext *c) {
     int fd = c->fd;
     c->fd = -1;
     redisFree(c);
+    __A_VARIABLE = 1;
     return fd;
 }
 
@@ -675,11 +741,14 @@ redisContext *redisConnect(const char *ip, int port) {
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -687,11 +756,14 @@ redisContext *redisConnectWithTimeout(const char *ip, int port, const struct tim
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,&tv);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -699,11 +771,14 @@ redisContext *redisConnectNonBlock(const char *ip, int port) {
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectTcp(c,ip,port,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -712,6 +787,7 @@ redisContext *redisConnectBindNonBlock(const char *ip, int port,
     redisContext *c = redisContextInit();
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -721,6 +797,7 @@ redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
     c->flags &= ~REDIS_BLOCK;
     c->flags |= REDIS_REUSEADDR;
     redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -728,11 +805,14 @@ redisContext *redisConnectUnix(const char *path) {
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectUnix(c,path,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -740,11 +820,14 @@ redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags |= REDIS_BLOCK;
     redisContextConnectUnix(c,path,&tv);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -752,11 +835,14 @@ redisContext *redisConnectUnixNonBlock(const char *path) {
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectUnix(c,path,NULL);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -764,25 +850,34 @@ redisContext *redisConnectFd(int fd) {
     redisContext *c;
 
     c = redisContextInit();
-    if (c == NULL)
+    if (c == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     c->fd = fd;
     c->flags |= REDIS_BLOCK | REDIS_CONNECTED;
+    __A_VARIABLE = 1;
     return c;
 }
 
 /* Set read/write timeout on a blocking socket. */
 int redisSetTimeout(redisContext *c, const struct timeval tv) {
-    if (c->flags & REDIS_BLOCK)
+    if (c->flags & REDIS_BLOCK) {
+        __A_VARIABLE = 1;
         return redisContextSetTimeout(c,tv);
+    }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 /* Enable connection KeepAlive. */
 int redisEnableKeepAlive(redisContext *c) {
-    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK)
+    if (redisKeepAlive(c, REDIS_KEEPALIVE_INTERVAL) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -862,8 +957,10 @@ int redisBufferWrite(redisContext *c, int *done) {
 int redisGetReplyFromReader(redisContext *c, void **reply) {
     if (redisReaderGetReply(c->reader,reply) == REDIS_ERR) {
         __redisSetError(c,c->reader->err,c->reader->errstr);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -872,28 +969,37 @@ int redisGetReply(redisContext *c, void **reply) {
     void *aux = NULL;
 
     /* Try to read pending replies */
-    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)
+    if (redisGetReplyFromReader(c,&aux) == REDIS_ERR) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* For the blocking context, flush output buffer and read reply */
     if (aux == NULL && c->flags & REDIS_BLOCK) {
         /* Write until done */
         do {
-            if (redisBufferWrite(c,&wdone) == REDIS_ERR)
+            if (redisBufferWrite(c,&wdone) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         } while (!wdone);
 
         /* Read until there is a reply */
         do {
-            if (redisBufferRead(c) == REDIS_ERR)
+            if (redisBufferRead(c) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
-            if (redisGetReplyFromReader(c,&aux) == REDIS_ERR)
+            }
+            if (redisGetReplyFromReader(c,&aux) == REDIS_ERR) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         } while (aux == NULL);
     }
 
     /* Set reply object */
     if (reply != NULL) *reply = aux;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -910,19 +1016,23 @@ int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {
     newbuf = sdscatlen(c->obuf,cmd,len);
     if (newbuf == NULL) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     c->obuf = newbuf;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {
 
     if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -955,6 +1065,7 @@ int redisAppendCommand(redisContext *c, const char *format, ...) {
     va_start(ap,format);
     ret = redisvAppendCommand(c,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -965,15 +1076,18 @@ int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const s
     len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     if (len == -1) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
         sdsfree(cmd);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     sdsfree(cmd);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -992,16 +1106,23 @@ static void *__redisBlockForReply(redisContext *c) {
     void *reply;
 
     if (c->flags & REDIS_BLOCK) {
-        if (redisGetReply(c,&reply) != REDIS_OK)
+        if (redisGetReply(c,&reply) != REDIS_OK) {
+            __A_VARIABLE = 1;
             return NULL;
+        }
+        __A_VARIABLE = 1;
         return reply;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 void *redisvCommand(redisContext *c, const char *format, va_list ap) {
-    if (redisvAppendCommand(c,format,ap) != REDIS_OK)
+    if (redisvAppendCommand(c,format,ap) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
+    __A_VARIABLE = 1;
     return __redisBlockForReply(c);
 }
 
@@ -1011,11 +1132,15 @@ void *redisCommand(redisContext *c, const char *format, ...) {
     va_start(ap,format);
     reply = redisvCommand(c,format,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return reply;
 }
 
 void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
-    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK)
+    if (redisAppendCommandArgv(c,argc,argv,argvlen) != REDIS_OK) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
+    __A_VARIABLE = 1;
     return __redisBlockForReply(c);
 }
diff --git a/deps/hiredis/net.c b/deps/hiredis/net.c
index bfc3b9f..9bc8b0b 100644
--- a/deps/hiredis/net.c
+++ b/deps/hiredis/net.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Extracted from anet.c to work properly with Hiredis error reporting.
  *
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -63,6 +64,7 @@ static void redisContextCloseFd(redisContext *c) {
         close(c->fd);
         c->fd = -1;
     }
+    __A_VARIABLE = 1;
 }
 
 static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
@@ -73,6 +75,7 @@ static void __redisSetErrorFromErrno(redisContext *c, int type, const char *pref
         len = snprintf(buf,sizeof(buf),"%s: ",prefix);
     __redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
     __redisSetError(c,type,buf);
+    __A_VARIABLE = 1;
 }
 
 static int redisSetReuseAddr(redisContext *c) {
@@ -81,8 +84,10 @@ static int redisSetReuseAddr(redisContext *c) {
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -91,14 +96,17 @@ static int redisCreateSocket(redisContext *c, int type) {
     flexos_gate_r(liblwip, s, socket, type, SOCK_STREAM, 0);
     if (s == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
     c->fd = s;
     if (type == AF_INET) {
         if (redisSetReuseAddr(c) == REDIS_ERR) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -111,6 +119,7 @@ static int redisSetBlocking(redisContext *c, int blocking) {
     if ((flags = fcntl(c->fd, F_GETFL)) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_GETFL)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
@@ -122,8 +131,10 @@ static int redisSetBlocking(redisContext *c, int blocking) {
     if (fcntl(c->fd, F_SETFL, flags) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"fcntl(F_SETFL)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -180,8 +191,10 @@ static int redisSetTcpNoDelay(redisContext *c) {
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(TCP_NODELAY)");
         redisContextCloseFd(c);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -196,6 +209,7 @@ static int redisContextTimeoutMsec(redisContext *c, long *result)
     if (timeout != NULL) {
         if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
             *result = msec;
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -207,6 +221,7 @@ static int redisContextTimeoutMsec(redisContext *c, long *result)
     }
 
     *result = msec;
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -247,15 +262,18 @@ int redisCheckSocketError(redisContext *c) {
 
     if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"getsockopt(SO_ERROR)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
     if (err) {
         errno = err;
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,NULL);
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -264,13 +282,16 @@ int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
     flexos_gate_r(liblwip, ret, setsockopt, c->fd,SOL_SOCKET,SO_RCVTIMEO,&tv,sizeof(tv));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_RCVTIMEO)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
     flexos_gate_r(liblwip, ret, setsockopt, c->fd,SOL_SOCKET,SO_SNDTIMEO,&tv,sizeof(tv));
     if (ret == -1) {
         __redisSetErrorFromErrno(c,REDIS_ERR_IO,"setsockopt(SO_SNDTIMEO)");
+        __A_VARIABLE = 1;
         return REDIS_ERR;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -345,6 +366,7 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
          flexos_gate_r(liblwip, rv, getaddrinfo, addr,_port,&hints,&servinfo);
          if (rv != 0) {
             __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
     }
@@ -430,17 +452,20 @@ error:
     rv = REDIS_ERR;
 end:
     freeaddrinfo(servinfo);
+    __A_VARIABLE = 1;
     return rv;  // Need to return REDIS_OK if alright
 }
 
 int redisContextConnectTcp(redisContext *c, const char *addr, int port,
                            const struct timeval *timeout) {
+    __A_VARIABLE = 1;
     return _redisContextConnectTcp(c, addr, port, timeout, NULL);
 }
 
 int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
                                const struct timeval *timeout,
                                const char *source_addr) {
+    __A_VARIABLE = 1;
     return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
 }
 
diff --git a/deps/hiredis/read.c b/deps/hiredis/read.c
index 50333b5..45c30ca 100644
--- a/deps/hiredis/read.c
+++ b/deps/hiredis/read.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
  * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
@@ -67,6 +68,7 @@ static void __redisReaderSetError(redisReader *r, int type, const char *str) {
     len = len < (sizeof(r->errstr)-1) ? len : (sizeof(r->errstr)-1);
     memcpy(r->errstr,str,len);
     r->errstr[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 static size_t chrtos(char *buf, size_t size, char byte) {
@@ -90,6 +92,7 @@ static size_t chrtos(char *buf, size_t size, char byte) {
         break;
     }
 
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -100,10 +103,12 @@ static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {
     snprintf(sbuf,sizeof(sbuf),
         "Protocol error, got %s as reply type byte", cbuf);
     __redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);
+    __A_VARIABLE = 1;
 }
 
 static void __redisReaderSetErrorOOM(redisReader *r) {
     __redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");
+    __A_VARIABLE = 1;
 }
 
 static char *readBytes(redisReader *r, unsigned int bytes) {
@@ -111,8 +116,10 @@ static char *readBytes(redisReader *r, unsigned int bytes) {
     if (r->len-r->pos >= bytes) {
         p = r->buf+r->pos;
         r->pos += bytes;
+        __A_VARIABLE = 1;
         return p;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -182,8 +189,10 @@ static char *readLine(redisReader *r, int *_len) {
         len = s-(r->buf+r->pos);
         r->pos += len+2; /* skip \r\n */
         if (_len) *_len = len;
+        __A_VARIABLE = 1;
         return p;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -234,15 +243,18 @@ static int processLineItem(redisReader *r) {
 
         if (obj == NULL) {
             __redisReaderSetErrorOOM(r);
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
         /* Set reply if this is the root object. */
         if (r->ridx == 0) r->reply = obj;
         moveToNextTask(r);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
 
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -284,6 +296,7 @@ static int processBulkItem(redisReader *r) {
         if (success) {
             if (obj == NULL) {
                 __redisReaderSetErrorOOM(r);
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
             }
 
@@ -292,10 +305,12 @@ static int processBulkItem(redisReader *r) {
             /* Set reply if this is the root object. */
             if (r->ridx == 0) r->reply = obj;
             moveToNextTask(r);
+            __A_VARIABLE = 1;
             return REDIS_OK;
         }
     }
 
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -417,8 +432,10 @@ redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
     redisReader *r;
 
     r = calloc(sizeof(redisReader),1);
-    if (r == NULL)
+    if (r == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     r->err = 0;
     r->errstr[0] = '\0';
@@ -427,10 +444,12 @@ redisReader *redisReaderCreateWithFunctions(redisReplyObjectFunctions *fn) {
     r->maxbuf = REDIS_READER_MAX_BUF;
     if (r->buf == NULL) {
         free(r);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
     r->ridx = -1;
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -440,14 +459,17 @@ void redisReaderFree(redisReader *r) {
     if (r->buf != NULL)
         sdsfree(r->buf);
     free(r);
+    __A_VARIABLE = 1;
 }
 
 int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
     sds newbuf;
 
     /* Return early when this reader is in an erroneous state. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* Copy the provided buffer. */
     if (buf != NULL && len >= 1) {
@@ -464,6 +486,7 @@ int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
         newbuf = sdscatlen(r->buf,buf,len);
         if (newbuf == NULL) {
             __redisReaderSetErrorOOM(r);
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -471,6 +494,7 @@ int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
         r->len = sdslen(r->buf);
     }
 
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -480,12 +504,16 @@ int redisReaderGetReply(redisReader *r, void **reply) {
         *reply = NULL;
 
     /* Return early when this reader is in an erroneous state. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* When the buffer is empty, there will never be a reply. */
-    if (r->len == 0)
+    if (r->len == 0) {
+        __A_VARIABLE = 1;
         return REDIS_OK;
+    }
 
     /* Set first item to process when the stack is empty. */
     if (r->ridx == -1) {
@@ -504,8 +532,10 @@ int redisReaderGetReply(redisReader *r, void **reply) {
             break;
 
     /* Return ASAP when an error occurred. */
-    if (r->err)
+    if (r->err) {
+        __A_VARIABLE = 1;
         return REDIS_ERR;
+    }
 
     /* Discard part of the buffer when we've consumed at least 1k, to avoid
      * doing unnecessary calls to memmove() in sds.c. */
@@ -521,5 +551,6 @@ int redisReaderGetReply(redisReader *r, void **reply) {
             *reply = r->reply;
         r->reply = NULL;
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
diff --git a/deps/hiredis/sds.c b/deps/hiredis/sds.c
index 923ffd8..c04b83b 100644
--- a/deps/hiredis/sds.c
+++ b/deps/hiredis/sds.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* SDSLib 2.0 -- A C dynamic strings library
  *
  * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -41,28 +42,43 @@
 static inline int sdsHdrSize(char type) {
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr5);
         case SDS_TYPE_8:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr8);
         case SDS_TYPE_16:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr16);
         case SDS_TYPE_32:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr32);
         case SDS_TYPE_64:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr64);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static inline char sdsReqType(size_t string_size) {
-    if (string_size < 32)
+    if (string_size < 32) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_5;
-    if (string_size < 0xff)
+    }
+    if (string_size < 0xff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_8;
-    if (string_size < 0xffff)
+    }
+    if (string_size < 0xffff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_16;
-    if (string_size < 0xffffffff)
+    }
+    if (string_size < 0xffffffff) {
+        __A_VARIABLE = 1;
         return SDS_TYPE_32;
+    }
+    __A_VARIABLE = 1;
     return SDS_TYPE_64;
 }
 
@@ -89,7 +105,10 @@ sds sdsnewlen(const void *init, size_t initlen) {
     unsigned char *fp; /* flags pointer. */
 
     sh = s_malloc(hdrlen+initlen+1);
-    if (sh == NULL) return NULL;
+    if (sh == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (!init)
         memset(sh, 0, hdrlen+initlen+1);
     s = (char*)sh+hdrlen;
@@ -131,30 +150,38 @@ sds sdsnewlen(const void *init, size_t initlen) {
     if (initlen && init)
         memcpy(s, init, initlen);
     s[initlen] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
+    __A_VARIABLE = 1;
     return sdsnewlen("",0);
 }
 
 /* Create a new sds string starting from a null terminated C string. */
 sds sdsnew(const char *init) {
     size_t initlen = (init == NULL) ? 0 : strlen(init);
+    __A_VARIABLE = 1;
     return sdsnewlen(init, initlen);
 }
 
 /* Duplicate an sds string. */
 sds sdsdup(const sds s) {
+    __A_VARIABLE = 1;
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
-    if (s == NULL) return;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     s_free((char*)s-sdsHdrSize(s[-1]));
+    __A_VARIABLE = 1;
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
@@ -174,6 +201,7 @@ void sdsfree(sds s) {
 void sdsupdatelen(sds s) {
     int reallen = strlen(s);
     sdssetlen(s, reallen);
+    __A_VARIABLE = 1;
 }
 
 /* Modify an sds string in-place to make it empty (zero length).
@@ -183,6 +211,7 @@ void sdsupdatelen(sds s) {
 void sdsclear(sds s) {
     sdssetlen(s, 0);
     s[0] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
@@ -277,12 +306,14 @@ sds sdsRemoveFreeSpace(sds s) {
  */
 size_t sdsAllocSize(sds s) {
     size_t alloc = sdsalloc(s);
+    __A_VARIABLE = 1;
     return sdsHdrSize(s[-1])+alloc+1;
 }
 
 /* Return the pointer of the actual SDS allocation (normally SDS strings
  * are referenced by the start of the string buffer). */
 void *sdsAllocPtr(sds s) {
+    __A_VARIABLE = 1;
     return (void*) (s-sdsHdrSize(s[-1]));
 }
 
@@ -348,6 +379,7 @@ void sdsIncrLen(sds s, int incr) {
         default: len = 0; /* Just to avoid compilation warnings. */
     }
     s[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
@@ -358,13 +390,20 @@ void sdsIncrLen(sds s, int incr) {
 sds sdsgrowzero(sds s, size_t len) {
     size_t curlen = sdslen(s);
 
-    if (len <= curlen) return s;
+    if (len <= curlen) {
+        __A_VARIABLE = 1;
+        return s;
+    }
     s = sdsMakeRoomFor(s,len-curlen);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make sure added region doesn't contain garbage */
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -377,10 +416,14 @@ sds sdscatlen(sds s, const void *t, size_t len) {
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     memcpy(s+curlen, t, len);
     sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -389,6 +432,7 @@ sds sdscatlen(sds s, const void *t, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, strlen(t));
 }
 
@@ -397,6 +441,7 @@ sds sdscat(sds s, const char *t) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatsds(sds s, const sds t) {
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, sdslen(t));
 }
 
@@ -405,17 +450,22 @@ sds sdscatsds(sds s, const sds t) {
 sds sdscpylen(sds s, const char *t, size_t len) {
     if (sdsalloc(s) < len) {
         s = sdsMakeRoomFor(s,len-sdslen(s));
-        if (s == NULL) return NULL;
+        if (s == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
     memcpy(s, t, len);
     s[len] = '\0';
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
+    __A_VARIABLE = 1;
     return sdscpylen(s, t, strlen(t));
 }
 
@@ -454,6 +504,7 @@ int sdsll2str(char *s, long long value) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -483,6 +534,7 @@ int sdsull2str(char *s, unsigned long long v) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -494,6 +546,7 @@ sds sdsfromlonglong(long long value) {
     char buf[SDS_LLSTR_SIZE];
     int len = sdsll2str(buf,value);
 
+    __A_VARIABLE = 1;
     return sdsnewlen(buf,len);
 }
 
@@ -557,6 +610,7 @@ sds sdscatprintf(sds s, const char *fmt, ...) {
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return t;
 }
 
@@ -661,6 +715,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
 
     /* Add null-term */
     s[i] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -690,6 +745,7 @@ sds sdstrim(sds s, const char *cset) {
     if (s != sp) memmove(s, sp, len);
     s[len] = '\0';
     sdssetlen(s,len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -712,7 +768,10 @@ sds sdstrim(sds s, const char *cset) {
 void sdsrange(sds s, int start, int end) {
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return;
+    if (len == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -735,6 +794,7 @@ void sdsrange(sds s, int start, int end) {
     if (start && newlen) memmove(s, s+start, newlen);
     s[newlen] = 0;
     sdssetlen(s,newlen);
+    __A_VARIABLE = 1;
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
@@ -742,6 +802,7 @@ void sdstolower(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Apply toupper() to every character of the sds string 's'. */
@@ -749,6 +810,7 @@ void sdstoupper(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two sds strings s1 and s2 with memcmp().
@@ -770,7 +832,11 @@ int sdscmp(const sds s1, const sds s2) {
     l2 = sdslen(s2);
     minlen = (l1 < l2) ? l1 : l2;
     cmp = memcmp(s1,s2,minlen);
-    if (cmp == 0) return l1-l2;
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return l1-l2;
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -794,13 +860,20 @@ sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count
     int elements = 0, slots = 5, start = 0, j;
     sds *tokens;
 
-    if (seplen < 1 || len < 0) return NULL;
+    if (seplen < 1 || len < 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     tokens = s_malloc(sizeof(sds)*slots);
-    if (tokens == NULL) return NULL;
+    if (tokens == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (len == 0) {
         *count = 0;
+        __A_VARIABLE = 1;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
@@ -827,6 +900,7 @@ sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count
     if (tokens[elements] == NULL) goto cleanup;
     elements++;
     *count = elements;
+    __A_VARIABLE = 1;
     return tokens;
 
 cleanup:
@@ -835,16 +909,21 @@ cleanup:
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
         s_free(tokens);
         *count = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
-    if (!tokens) return;
+    if (!tokens) {
+        __A_VARIABLE = 1;
+        return;
+    }
     while(count--)
         sdsfree(tokens[count]);
     s_free(tokens);
+    __A_VARIABLE = 1;
 }
 
 /* Append to the sds string "s" an escaped string representation where
@@ -875,12 +954,14 @@ sds sdscatrepr(sds s, const char *p, size_t len) {
         }
         p++;
     }
+    __A_VARIABLE = 1;
     return sdscatlen(s,"\"",1);
 }
 
 /* Helper function for sdssplitargs() that returns non zero if 'c'
  * is a valid hex digit. */
 int is_hex_digit(char c) {
+    __A_VARIABLE = 1;
     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
            (c >= 'A' && c <= 'F');
 }
@@ -889,23 +970,40 @@ int is_hex_digit(char c) {
  * integer from 0 to 15 */
 int hex_digit_to_int(char c) {
     switch(c) {
-    case '0': return 0;
-    case '1': return 1;
-    case '2': return 2;
-    case '3': return 3;
-    case '4': return 4;
-    case '5': return 5;
-    case '6': return 6;
-    case '7': return 7;
-    case '8': return 8;
-    case '9': return 9;
-    case 'a': case 'A': return 10;
-    case 'b': case 'B': return 11;
-    case 'c': case 'C': return 12;
-    case 'd': case 'D': return 13;
-    case 'e': case 'E': return 14;
-    case 'f': case 'F': return 15;
-    default: return 0;
+    case '0': __A_VARIABLE = 1;
+        return 0;
+    case '1': __A_VARIABLE = 1;
+        return 1;
+    case '2': __A_VARIABLE = 1;
+        return 2;
+    case '3': __A_VARIABLE = 1;
+        return 3;
+    case '4': __A_VARIABLE = 1;
+        return 4;
+    case '5': __A_VARIABLE = 1;
+        return 5;
+    case '6': __A_VARIABLE = 1;
+        return 6;
+    case '7': __A_VARIABLE = 1;
+        return 7;
+    case '8': __A_VARIABLE = 1;
+        return 8;
+    case '9': __A_VARIABLE = 1;
+        return 9;
+    case 'a': case 'A': __A_VARIABLE = 1;
+        return 10;
+    case 'b': case 'B': __A_VARIABLE = 1;
+        return 11;
+    case 'c': case 'C': __A_VARIABLE = 1;
+        return 12;
+    case 'd': case 'D': __A_VARIABLE = 1;
+        return 13;
+    case 'e': case 'E': __A_VARIABLE = 1;
+        return 14;
+    case 'f': case 'F': __A_VARIABLE = 1;
+        return 15;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1058,6 +1156,7 @@ sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -1071,6 +1170,7 @@ sds sdsjoin(char **argv, int argc, char *sep) {
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1083,6 +1183,7 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
         join = sdscatsds(join, argv[j]);
         if (j != argc-1) join = sdscatlen(join,sep,seplen);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1091,9 +1192,12 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
  * the overhead of function calls. Here we define these wrappers only for
  * the programs SDS is linked to, if they want to touch the SDS internals
  * even if they use a different allocator. */
-void *sds_malloc(size_t size) { return s_malloc(size); }
-void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
-void sds_free(void *ptr) { s_free(ptr); }
+void *sds_malloc(size_t size) { __A_VARIABLE = 1;
+	return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) { __A_VARIABLE = 1;
+	return s_realloc(ptr,size); }
+void sds_free(void *ptr) { s_free(ptr); __A_VARIABLE = 1;
+}
 
 #if defined(SDS_TEST_MAIN)
 #include <stdio.h>
@@ -1267,6 +1371,7 @@ int sdsTest(void) {
 
 #ifdef SDS_TEST_MAIN
 int main(void) {
+    __A_VARIABLE = 1;
     return sdsTest();
 }
 #endif
diff --git a/deps/hiredis/test.c b/deps/hiredis/test.c
index a23d606..dee5eee 100644
--- a/deps/hiredis/test.c
+++ b/deps/hiredis/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "fmacros.h"
 #include <stdio.h>
 #include <stdlib.h>
@@ -41,6 +42,7 @@ static int tests = 0, fails = 0;
 static long long usec(void) {
     struct timeval tv;
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
@@ -70,6 +72,7 @@ static redisContext *select_database(redisContext *c) {
         exit(1);
     }
 
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -85,9 +88,12 @@ static int disconnect(redisContext *c, int keep_fd) {
     freeReplyObject(reply);
 
     /* Free the context as well, but keep the fd if requested. */
-    if (keep_fd)
+    if (keep_fd) {
+        __A_VARIABLE = 1;
         return redisFreeKeepFd(c);
+    }
     redisFree(c);
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -119,6 +125,7 @@ static redisContext *connect(struct config config) {
         exit(1);
     }
 
+    __A_VARIABLE = 1;
     return select_database(c);
 }
 
@@ -240,6 +247,7 @@ static void test_format_commands(void) {
     test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
         len == 4+4+(3+2)+4+(7+2)+4+(3+2));
     sdsfree(sds_cmd);
+    __A_VARIABLE = 1;
 }
 
 static void test_append_formatted_commands(struct config config) {
@@ -262,6 +270,7 @@ static void test_append_formatted_commands(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_reply_reader(void) {
@@ -341,6 +350,7 @@ static void test_reply_reader(void) {
         ((redisReply*)reply)->elements == 0);
     freeReplyObject(reply);
     redisReaderFree(reader);
+    __A_VARIABLE = 1;
 }
 
 static void test_free_null(void) {
@@ -354,6 +364,7 @@ static void test_free_null(void) {
     test("Don't fail when freeReplyObject is passed a NULL value: ");
     freeReplyObject(reply);
     test_cond(reply == NULL);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection_errors(void) {
@@ -381,6 +392,7 @@ static void test_blocking_connection_errors(void) {
     c = redisConnectUnix((char*)"/tmp/idontexist.sock");
     test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection(struct config config) {
@@ -459,6 +471,7 @@ static void test_blocking_connection(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_connection_timeouts(struct config config) {
@@ -505,6 +518,7 @@ static void test_blocking_connection_timeouts(struct config config) {
     freeReplyObject(reply);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_blocking_io_errors(struct config config) {
@@ -556,6 +570,7 @@ static void test_blocking_io_errors(struct config config) {
     test_cond(redisGetReply(c,&_reply) == REDIS_ERR &&
         c->err == REDIS_ERR_IO && errno == EAGAIN);
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_invalid_timeout_errors(struct config config) {
@@ -580,6 +595,7 @@ static void test_invalid_timeout_errors(struct config config) {
 
     test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
     redisFree(c);
+    __A_VARIABLE = 1;
 }
 
 static void test_throughput(struct config config) {
@@ -645,6 +661,7 @@ static void test_throughput(struct config config) {
     printf("\t(%dx LRANGE with 500 elements (pipelined): %.3fs)\n", num, (t2-t1)/1000000.0);
 
     disconnect(c, 0);
+    __A_VARIABLE = 1;
 }
 
 // static long __test_callback_flags = 0;
@@ -815,9 +832,11 @@ int main(int argc, char **argv) {
 
     if (fails) {
         printf("*** %d TESTS FAILED ***\n", fails);
+        __A_VARIABLE = 1;
         return 1;
     }
 
     printf("ALL TESTS PASSED\n");
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/jemalloc/src/arena.c b/deps/jemalloc/src/arena.c
index 5d55bf1..bec6dfe 100644
--- a/deps/jemalloc/src/arena.c
+++ b/deps/jemalloc/src/arena.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_ARENA_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -71,6 +72,7 @@ arena_basic_stats_merge(UNUSED tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
 	*nactive += atomic_load_zu(&arena->nactive, ATOMIC_RELAXED);
 	*ndirty += extents_npages_get(&arena->extents_dirty);
 	*nmuzzy += extents_npages_get(&arena->extents_muzzy);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -203,6 +205,7 @@ arena_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
 	for (szind_t i = 0; i < NBINS; i++) {
 		bin_stats_merge(tsdn, &bstats[i], &arena->bins[i]);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -218,6 +221,7 @@ arena_extents_dirty_dalloc(tsdn_t *tsdn, arena_t *arena,
 	} else {
 		arena_background_thread_inactivity_check(tsdn, arena, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -233,6 +237,7 @@ arena_slab_reg_alloc(extent_t *slab, const bin_info_t *bin_info) {
 	ret = (void *)((uintptr_t)extent_addr_get(slab) +
 	    (uintptr_t)(bin_info->reg_size * regind));
 	extent_nfree_dec(slab);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -257,6 +262,7 @@ arena_slab_regind(extent_t *slab, szind_t binind, const void *ptr) {
 
 	assert(regind < bin_infos[binind].nregs);
 
+	__A_VARIABLE = 1;
 	return regind;
 }
 
@@ -272,17 +278,20 @@ arena_slab_reg_dalloc(extent_t *slab, arena_slab_data_t *slab_data, void *ptr) {
 
 	bitmap_unset(slab_data->bitmap, &bin_info->bitmap_info, regind);
 	extent_nfree_inc(slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_nactive_add(arena_t *arena, size_t add_pages) {
 	atomic_fetch_add_zu(&arena->nactive, add_pages, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_nactive_sub(arena_t *arena, size_t sub_pages) {
 	assert(atomic_load_zu(&arena->nactive, ATOMIC_RELAXED) >= sub_pages);
 	atomic_fetch_sub_zu(&arena->nactive, sub_pages, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -299,6 +308,7 @@ arena_large_malloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
 
 	arena_stats_add_u64(tsdn, &arena->stats,
 	    &arena->stats.lstats[hindex].nmalloc, 1);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -315,6 +325,7 @@ arena_large_dalloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t usize) {
 
 	arena_stats_add_u64(tsdn, &arena->stats,
 	    &arena->stats.lstats[hindex].ndalloc, 1);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -322,6 +333,7 @@ arena_large_ralloc_stats_update(tsdn_t *tsdn, arena_t *arena, size_t oldusize,
     size_t usize) {
 	arena_large_dalloc_stats_update(tsdn, arena, oldusize);
 	arena_large_malloc_stats_update(tsdn, arena, usize);
+	__A_VARIABLE = 1;
 }
 
 extent_t *
@@ -373,6 +385,7 @@ arena_extent_alloc_large(tsdn_t *tsdn, arena_t *arena, size_t usize,
 		arena_nactive_add(arena, size >> LG_PAGE);
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -385,6 +398,7 @@ arena_extent_dalloc_large_prep(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_sub(arena, extent_size_get(extent) >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -399,6 +413,7 @@ arena_extent_ralloc_large_shrink(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_sub(arena, udiff >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -413,16 +428,19 @@ arena_extent_ralloc_large_expand(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 	arena_nactive_add(arena, udiff >> LG_PAGE);
+	__A_VARIABLE = 1;
 }
 
 static ssize_t
 arena_decay_ms_read(arena_decay_t *decay) {
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);
 }
 
 static void
 arena_decay_ms_write(arena_decay_t *decay, ssize_t decay_ms) {
 	atomic_store_zd(&decay->time_ms, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -440,10 +458,12 @@ arena_decay_deadline_init(arena_decay_t *decay) {
 		    nstime_ns(&decay->interval)));
 		nstime_add(&decay->deadline, &jitter);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
 arena_decay_deadline_reached(const arena_decay_t *decay, const nstime_t *time) {
+	__A_VARIABLE = 1;
 	return (nstime_compare(&decay->deadline, time) <= 0);
 }
 
@@ -464,6 +484,7 @@ arena_decay_backlog_npages_limit(const arena_decay_t *decay) {
 	}
 	npages_limit_backlog = (size_t)(sum >> SMOOTHSTEP_BFP);
 
+	__A_VARIABLE = 1;
 	return npages_limit_backlog;
 }
 
@@ -483,6 +504,7 @@ arena_decay_backlog_update_last(arena_decay_t *decay, size_t current_npages) {
 			decay->ceil_npages = npages_limit;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -505,6 +527,7 @@ arena_decay_backlog_update(arena_decay_t *decay, uint64_t nadvance_u64,
 	}
 
 	arena_decay_backlog_update_last(decay, current_npages);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -516,6 +539,7 @@ arena_decay_try_purge(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    npages_limit, current_npages - npages_limit,
 		    is_background_thread);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -540,6 +564,7 @@ arena_decay_epoch_advance_helper(arena_decay_t *decay, const nstime_t *time,
 
 	/* Update the backlog. */
 	arena_decay_backlog_update(decay, nadvance_u64, current_npages);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -557,6 +582,7 @@ arena_decay_epoch_advance(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		arena_decay_try_purge(tsdn, arena, decay, extents,
 		    current_npages, npages_limit, is_background_thread);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -574,6 +600,7 @@ arena_decay_reinit(arena_decay_t *decay, ssize_t decay_ms) {
 	arena_decay_deadline_init(decay);
 	decay->nunpurged = 0;
 	memset(decay->backlog, 0, SMOOTHSTEP_NSTEPS * sizeof(size_t));
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -587,6 +614,7 @@ arena_decay_init(arena_decay_t *decay, ssize_t decay_ms,
 	}
 	if (malloc_mutex_init(&decay->mtx, "decay", WITNESS_RANK_DECAY,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	decay->purging = false;
@@ -595,18 +623,22 @@ arena_decay_init(arena_decay_t *decay, ssize_t decay_ms,
 	if (config_stats) {
 		decay->stats = stats;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 arena_decay_ms_valid(ssize_t decay_ms) {
 	if (decay_ms < -1) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (decay_ms == -1 || (uint64_t)decay_ms <= NSTIME_SEC_MAX *
 	    KQU(1000)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -623,6 +655,7 @@ arena_maybe_decay(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 			    0, extents_npages_get(extents),
 			    is_background_thread);
 		}
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -665,21 +698,25 @@ arena_maybe_decay(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    is_background_thread);
 	}
 
+	__A_VARIABLE = 1;
 	return advance_epoch;
 }
 
 static ssize_t
 arena_decay_ms_get(arena_decay_t *decay) {
+	__A_VARIABLE = 1;
 	return arena_decay_ms_read(decay);
 }
 
 ssize_t
 arena_dirty_decay_ms_get(arena_t *arena) {
+	__A_VARIABLE = 1;
 	return arena_decay_ms_get(&arena->decay_dirty);
 }
 
 ssize_t
 arena_muzzy_decay_ms_get(arena_t *arena) {
+	__A_VARIABLE = 1;
 	return arena_decay_ms_get(&arena->decay_muzzy);
 }
 
@@ -687,6 +724,7 @@ static bool
 arena_decay_ms_set(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
     extents_t *extents, ssize_t decay_ms) {
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -703,12 +741,14 @@ arena_decay_ms_set(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 	arena_maybe_decay(tsdn, arena, decay, extents, false);
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 arena_dirty_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
     ssize_t decay_ms) {
+	__A_VARIABLE = 1;
 	return arena_decay_ms_set(tsdn, arena, &arena->decay_dirty,
 	    &arena->extents_dirty, decay_ms);
 }
@@ -716,6 +756,7 @@ arena_dirty_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
 bool
 arena_muzzy_decay_ms_set(tsdn_t *tsdn, arena_t *arena,
     ssize_t decay_ms) {
+	__A_VARIABLE = 1;
 	return arena_decay_ms_set(tsdn, arena, &arena->decay_muzzy,
 	    &arena->extents_muzzy, decay_ms);
 }
@@ -736,6 +777,7 @@ arena_stash_decayed(tsdn_t *tsdn, arena_t *arena,
 		extent_list_append(decay_extents, extent);
 		nstashed += extent_size_get(extent) >> LG_PAGE;
 	}
+	__A_VARIABLE = 1;
 	return nstashed;
 }
 
@@ -802,6 +844,7 @@ arena_decay_stashed(tsdn_t *tsdn, arena_t *arena,
 		arena_stats_unlock(tsdn, &arena->stats);
 	}
 
+	__A_VARIABLE = 1;
 	return npurged;
 }
 
@@ -821,6 +864,7 @@ arena_decay_to_limit(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 	malloc_mutex_assert_owner(tsdn, &decay->mtx);
 
 	if (decay->purging) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	decay->purging = true;
@@ -842,6 +886,7 @@ arena_decay_to_limit(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 
 	malloc_mutex_lock(tsdn, &decay->mtx);
 	decay->purging = false;
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -853,11 +898,13 @@ arena_decay_impl(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    extents_npages_get(extents), is_background_thread);
 		malloc_mutex_unlock(tsdn, &decay->mtx);
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	if (malloc_mutex_trylock(tsdn, &decay->mtx)) {
 		/* No need to wait if another thread is in progress. */
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -876,12 +923,14 @@ arena_decay_impl(tsdn_t *tsdn, arena_t *arena, arena_decay_t *decay,
 		    npages_new);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 arena_decay_dirty(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
     bool all) {
+	__A_VARIABLE = 1;
 	return arena_decay_impl(tsdn, arena, &arena->decay_dirty,
 	    &arena->extents_dirty, is_background_thread, all);
 }
@@ -889,6 +938,7 @@ arena_decay_dirty(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
 static bool
 arena_decay_muzzy(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
     bool all) {
+	__A_VARIABLE = 1;
 	return arena_decay_impl(tsdn, arena, &arena->decay_muzzy,
 	    &arena->extents_muzzy, is_background_thread, all);
 }
@@ -896,9 +946,11 @@ arena_decay_muzzy(tsdn_t *tsdn, arena_t *arena, bool is_background_thread,
 void
 arena_decay(tsdn_t *tsdn, arena_t *arena, bool is_background_thread, bool all) {
 	if (arena_decay_dirty(tsdn, arena, is_background_thread, all)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	arena_decay_muzzy(tsdn, arena, is_background_thread, all);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -907,28 +959,33 @@ arena_slab_dalloc(tsdn_t *tsdn, arena_t *arena, extent_t *slab) {
 
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_nonfull_insert(bin_t *bin, extent_t *slab) {
 	assert(extent_nfree_get(slab) > 0);
 	extent_heap_insert(&bin->slabs_nonfull, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_nonfull_remove(bin_t *bin, extent_t *slab) {
 	extent_heap_remove(&bin->slabs_nonfull, slab);
+	__A_VARIABLE = 1;
 }
 
 static extent_t *
 arena_bin_slabs_nonfull_tryget(bin_t *bin) {
 	extent_t *slab = extent_heap_remove_first(&bin->slabs_nonfull);
 	if (slab == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	if (config_stats) {
 		bin->stats.reslabs++;
 	}
+	__A_VARIABLE = 1;
 	return slab;
 }
 
@@ -941,17 +998,21 @@ arena_bin_slabs_full_insert(arena_t *arena, bin_t *bin, extent_t *slab) {
 	 *  linkage (often results in cache misses) for auto arenas.
 	 */
 	if (arena_is_auto(arena)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_list_append(&bin->slabs_full, slab);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_bin_slabs_full_remove(arena_t *arena, bin_t *bin, extent_t *slab) {
 	if (arena_is_auto(arena)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_list_remove(&bin->slabs_full, slab);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1031,6 +1092,7 @@ arena_reset(tsd_t *tsd, arena_t *arena) {
 	}
 
 	atomic_store_zu(&arena->nactive, 0, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1050,6 +1112,7 @@ arena_destroy_retained(tsdn_t *tsdn, arena_t *arena) {
 	    &arena->extents_retained, 0)) != NULL) {
 		extent_destroy_wrapper(tsdn, arena, &extent_hooks, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1086,6 +1149,7 @@ arena_destroy(tsd_t *tsd, arena_t *arena) {
 	 * this arena.
 	 */
 	base_delete(tsd_tsdn(tsd), arena->base);
+	__A_VARIABLE = 1;
 }
 
 static extent_t *
@@ -1108,6 +1172,7 @@ arena_slab_alloc_hard(tsdn_t *tsdn, arena_t *arena,
 		    bin_info->slab_size);
 	}
 
+	__A_VARIABLE = 1;
 	return slab;
 }
 
@@ -1133,6 +1198,7 @@ arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind,
 		slab = arena_slab_alloc_hard(tsdn, arena, &extent_hooks,
 		    bin_info, szind);
 		if (slab == NULL) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 	}
@@ -1145,6 +1211,7 @@ arena_slab_alloc(tsdn_t *tsdn, arena_t *arena, szind_t binind,
 
 	arena_nactive_add(arena, extent_size_get(slab) >> LG_PAGE);
 
+	__A_VARIABLE = 1;
 	return slab;
 }
 
@@ -1157,6 +1224,7 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 	/* Look for a usable slab. */
 	slab = arena_bin_slabs_nonfull_tryget(bin);
 	if (slab != NULL) {
+		__A_VARIABLE = 1;
 		return slab;
 	}
 	/* No existing slabs have any space available. */
@@ -1174,6 +1242,7 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 			bin->stats.nslabs++;
 			bin->stats.curslabs++;
 		}
+		__A_VARIABLE = 1;
 		return slab;
 	}
 
@@ -1184,9 +1253,11 @@ arena_bin_nonfull_slab_get(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 	 */
 	slab = arena_bin_slabs_nonfull_tryget(bin);
 	if (slab != NULL) {
+		__A_VARIABLE = 1;
 		return slab;
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1229,6 +1300,7 @@ arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 					    bin);
 				}
 			}
+			__A_VARIABLE = 1;
 			return ret;
 		}
 
@@ -1237,12 +1309,14 @@ arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, bin_t *bin,
 	}
 
 	if (slab == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	bin->slabcur = slab;
 
 	assert(extent_nfree_get(bin->slabcur) > 0);
 
+	__A_VARIABLE = 1;
 	return arena_slab_reg_alloc(slab, bin_info);
 }
 
@@ -1297,6 +1371,7 @@ arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
 	malloc_mutex_unlock(tsdn, &bin->lock);
 	tbin->ncached = i;
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1304,11 +1379,13 @@ arena_alloc_junk_small(void *ptr, const bin_info_t *bin_info, bool zero) {
 	if (!zero) {
 		memset(ptr, JEMALLOC_ALLOC_JUNK, bin_info->reg_size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_dalloc_junk_small_impl(void *ptr, const bin_info_t *bin_info) {
 	memset(ptr, JEMALLOC_FREE_JUNK, bin_info->reg_size);
+	__A_VARIABLE = 1;
 }
 arena_dalloc_junk_small_t *JET_MUTABLE arena_dalloc_junk_small =
     arena_dalloc_junk_small_impl;
@@ -1333,6 +1410,7 @@ arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero) {
 
 	if (ret == NULL) {
 		malloc_mutex_unlock(tsdn, &bin->lock);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1364,6 +1442,7 @@ arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero) {
 	}
 
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1376,12 +1455,15 @@ arena_malloc_hard(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind,
 		arena = arena_choose(tsdn_tsd(tsdn), arena);
 	}
 	if (unlikely(arena == NULL)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	if (likely(size <= SMALL_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return arena_malloc_small(tsdn, arena, ind, zero);
 	}
+	__A_VARIABLE = 1;
 	return large_malloc(tsdn, arena, sz_index2size(ind), zero);
 }
 
@@ -1402,6 +1484,7 @@ arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 			ret = large_palloc(tsdn, arena, usize, alignment, zero);
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1427,6 +1510,7 @@ arena_prof_promote(tsdn_t *tsdn, const void *ptr, size_t usize) {
 	prof_accum_cancel(tsdn, &arena->prof_accum, usize);
 
 	assert(isalloc(tsdn, ptr) == usize);
+	__A_VARIABLE = 1;
 }
 
 static size_t
@@ -1442,6 +1526,7 @@ arena_prof_demote(tsdn_t *tsdn, extent_t *extent, const void *ptr) {
 
 	assert(isalloc(tsdn, ptr) == LARGE_MINCLASS);
 
+	__A_VARIABLE = 1;
 	return LARGE_MINCLASS;
 }
 
@@ -1459,6 +1544,7 @@ arena_dalloc_promoted(tsdn_t *tsdn, void *ptr, tcache_t *tcache,
 	} else {
 		large_dalloc(tsdn, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1481,6 +1567,7 @@ arena_dissociate_bin_slab(arena_t *arena, extent_t *slab, bin_t *bin) {
 			arena_bin_slabs_nonfull_remove(bin, slab);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1496,6 +1583,7 @@ arena_dalloc_bin_slab(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 	if (config_stats) {
 		bin->stats.curslabs--;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1523,6 +1611,7 @@ arena_bin_lower_slab(UNUSED tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 	} else {
 		arena_bin_slabs_nonfull_insert(bin, slab);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1551,12 +1640,14 @@ arena_dalloc_bin_locked_impl(tsdn_t *tsdn, arena_t *arena, extent_t *slab,
 		bin->stats.ndalloc++;
 		bin->stats.curregs--;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_dalloc_bin_junked_locked(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
     void *ptr) {
 	arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, true);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1567,6 +1658,7 @@ arena_dalloc_bin(tsdn_t *tsdn, arena_t *arena, extent_t *extent, void *ptr) {
 	malloc_mutex_lock(tsdn, &bin->lock);
 	arena_dalloc_bin_locked_impl(tsdn, arena, extent, ptr, false);
 	malloc_mutex_unlock(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1576,6 +1668,7 @@ arena_dalloc_small(tsdn_t *tsdn, void *ptr) {
 
 	arena_dalloc_bin(tsdn, arena, extent, ptr);
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -1618,13 +1711,16 @@ static void *
 arena_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero, tcache_t *tcache) {
 	if (alignment == 0) {
+		__A_VARIABLE = 1;
 		return arena_malloc(tsdn, arena, usize, sz_size2index(usize),
 		    zero, tcache, true);
 	}
 	usize = sz_sa2u(usize, alignment);
 	if (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
+	__A_VARIABLE = 1;
 	return ipalloct(tsdn, usize, alignment, zero, tcache, arena);
 }
 
@@ -1633,17 +1729,20 @@ arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
     size_t size, size_t alignment, bool zero, tcache_t *tcache) {
 	size_t usize = sz_s2u(size);
 	if (unlikely(usize == 0 || size > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	if (likely(usize <= SMALL_MAXCLASS)) {
 		/* Try to avoid moving the allocation. */
 		if (!arena_ralloc_no_move(tsdn, ptr, oldsize, usize, 0, zero)) {
+			__A_VARIABLE = 1;
 			return ptr;
 		}
 	}
 
 	if (oldsize >= LARGE_MINCLASS && usize >= LARGE_MINCLASS) {
+		__A_VARIABLE = 1;
 		return large_ralloc(tsdn, arena, iealloc(tsdn, ptr), usize,
 		    alignment, zero, tcache);
 	}
@@ -1655,6 +1754,7 @@ arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
 	void *ret = arena_ralloc_move_helper(tsdn, arena, usize, alignment,
 	    zero, tcache);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1666,48 +1766,58 @@ arena_ralloc(tsdn_t *tsdn, arena_t *arena, void *ptr, size_t oldsize,
 	size_t copysize = (usize < oldsize) ? usize : oldsize;
 	memcpy(ret, ptr, copysize);
 	isdalloct(tsdn, ptr, oldsize, tcache, NULL, true);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 dss_prec_t
 arena_dss_prec_get(arena_t *arena) {
+	__A_VARIABLE = 1;
 	return (dss_prec_t)atomic_load_u(&arena->dss_prec, ATOMIC_ACQUIRE);
 }
 
 bool
 arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec) {
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return (dss_prec != dss_prec_disabled);
 	}
 	atomic_store_u(&arena->dss_prec, (unsigned)dss_prec, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 ssize_t
 arena_dirty_decay_ms_default_get(void) {
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&dirty_decay_ms_default, ATOMIC_RELAXED);
 }
 
 bool
 arena_dirty_decay_ms_default_set(ssize_t decay_ms) {
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	atomic_store_zd(&dirty_decay_ms_default, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 	return false;
 }
 
 ssize_t
 arena_muzzy_decay_ms_default_get(void) {
+	__A_VARIABLE = 1;
 	return atomic_load_zd(&muzzy_decay_ms_default, ATOMIC_RELAXED);
 }
 
 bool
 arena_muzzy_decay_ms_default_set(ssize_t decay_ms) {
 	if (!arena_decay_ms_valid(decay_ms)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	atomic_store_zd(&muzzy_decay_ms_default, decay_ms, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1722,6 +1832,7 @@ arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
 		/* Grow no more than the new limit. */
 		if ((new_ind = sz_psz2ind(limit + 1) - 1) >
 		     EXTENT_GROW_MAX_PIND) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
@@ -1735,26 +1846,31 @@ arena_retain_grow_limit_get_set(tsd_t *tsd, arena_t *arena, size_t *old_limit,
 	}
 	malloc_mutex_unlock(tsd_tsdn(tsd), &arena->extent_grow_mtx);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 unsigned
 arena_nthreads_get(arena_t *arena, bool internal) {
+	__A_VARIABLE = 1;
 	return atomic_load_u(&arena->nthreads[internal], ATOMIC_RELAXED);
 }
 
 void
 arena_nthreads_inc(arena_t *arena, bool internal) {
 	atomic_fetch_add_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_nthreads_dec(arena_t *arena, bool internal) {
 	atomic_fetch_sub_u(&arena->nthreads[internal], 1, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 size_t
 arena_extent_sn_next(arena_t *arena) {
+	__A_VARIABLE = 1;
 	return atomic_fetch_add_zu(&arena->extent_sn_next, 1, ATOMIC_RELAXED);
 }
 
@@ -1928,12 +2044,14 @@ arena_boot(void) {
 #undef REGIND_bin_yes
 #undef REGIND_bin_no
 #undef SC
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork0(tsdn_t *tsdn, arena_t *arena) {
 	malloc_mutex_prefork(tsdn, &arena->decay_dirty.mtx);
 	malloc_mutex_prefork(tsdn, &arena->decay_muzzy.mtx);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1941,11 +2059,13 @@ arena_prefork1(tsdn_t *tsdn, arena_t *arena) {
 	if (config_stats) {
 		malloc_mutex_prefork(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork2(tsdn_t *tsdn, arena_t *arena) {
 	malloc_mutex_prefork(tsdn, &arena->extent_grow_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1953,21 +2073,25 @@ arena_prefork3(tsdn_t *tsdn, arena_t *arena) {
 	extents_prefork(tsdn, &arena->extents_dirty);
 	extents_prefork(tsdn, &arena->extents_muzzy);
 	extents_prefork(tsdn, &arena->extents_retained);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork4(tsdn_t *tsdn, arena_t *arena) {
 	malloc_mutex_prefork(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork5(tsdn_t *tsdn, arena_t *arena) {
 	base_prefork(tsdn, arena->base);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_prefork6(tsdn_t *tsdn, arena_t *arena) {
 	malloc_mutex_prefork(tsdn, &arena->large_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1975,6 +2099,7 @@ arena_prefork7(tsdn_t *tsdn, arena_t *arena) {
 	for (unsigned i = 0; i < NBINS; i++) {
 		bin_prefork(tsdn, &arena->bins[i]);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1996,6 +2121,7 @@ arena_postfork_parent(tsdn_t *tsdn, arena_t *arena) {
 	if (config_stats) {
 		malloc_mutex_postfork_parent(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2040,4 +2166,5 @@ arena_postfork_child(tsdn_t *tsdn, arena_t *arena) {
 	if (config_stats) {
 		malloc_mutex_postfork_child(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/background_thread.c b/deps/jemalloc/src/background_thread.c
index 3517a3b..e9bf67d 100644
--- a/deps/jemalloc/src/background_thread.c
+++ b/deps/jemalloc/src/background_thread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_BACKGROUND_THREAD_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -40,6 +41,7 @@ pthread_create_wrapper_init(void) {
 		isthreaded = true;
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 int
@@ -47,6 +49,7 @@ pthread_create_wrapper(pthread_t *__restrict thread, const pthread_attr_t *attr,
     void *(*start_routine)(void *), void *__restrict arg) {
 	pthread_create_wrapper_init();
 
+	__A_VARIABLE = 1;
 	return pthread_create_fptr(thread, attr, start_routine, arg);
 }
 #endif /* JEMALLOC_PTHREAD_CREATE_WRAPPER */
@@ -78,6 +81,7 @@ background_thread_info_init(tsdn_t *tsdn, background_thread_info_t *info) {
 		info->tot_n_runs = 0;
 		nstime_init(&info->tot_sleep_time, 0);
 	}
+	__A_VARIABLE = 1;
 }
 
 static inline bool
@@ -111,6 +115,7 @@ decay_npurge_after_interval(arena_decay_t *decay, size_t interval) {
 		sum += decay->backlog[i] * (h_steps[i] - h_steps[i - interval]);
 	}
 
+	__A_VARIABLE = 1;
 	return (size_t)(sum >> SMOOTHSTEP_BFP);
 }
 
@@ -119,6 +124,7 @@ arena_decay_compute_purge_interval_impl(tsdn_t *tsdn, arena_decay_t *decay,
     extents_t *extents) {
 	if (malloc_mutex_trylock(tsdn, &decay->mtx)) {
 		/* Use minimal interval if decay is contended. */
+		__A_VARIABLE = 1;
 		return BACKGROUND_THREAD_MIN_INTERVAL_NS;
 	}
 
@@ -196,6 +202,7 @@ label_done:
 	    BACKGROUND_THREAD_MIN_INTERVAL_NS : interval;
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 
+	__A_VARIABLE = 1;
 	return interval;
 }
 
@@ -206,11 +213,13 @@ arena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena) {
 	i1 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_dirty,
 	    &arena->extents_dirty);
 	if (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {
+		__A_VARIABLE = 1;
 		return i1;
 	}
 	i2 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_muzzy,
 	    &arena->extents_muzzy);
 
+	__A_VARIABLE = 1;
 	return i1 < i2 ? i1 : i2;
 }
 
@@ -268,6 +277,7 @@ background_thread_sleep(tsdn_t *tsdn, background_thread_info_t *info,
 			nstime_add(&info->tot_sleep_time, &after_sleep);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -278,9 +288,11 @@ background_thread_pause_check(tsdn_t *tsdn, background_thread_info_t *info) {
 		malloc_mutex_lock(tsdn, &background_thread_lock);
 		malloc_mutex_unlock(tsdn, &background_thread_lock);
 		malloc_mutex_lock(tsdn, &info->mtx);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -307,6 +319,7 @@ background_work_sleep_once(tsdn_t *tsdn, background_thread_info_t *info, unsigne
 		}
 	}
 	background_thread_sleep(tsdn, info, min_interval);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -334,17 +347,20 @@ background_threads_disable_single(tsd_t *tsd, background_thread_info_t *info) {
 
 	if (!has_thread) {
 		post_reentrancy(tsd);
+		__A_VARIABLE = 1;
 		return false;
 	}
 	void *ret;
 	if (pthread_join(info->thread, &ret)) {
 		post_reentrancy(tsd);
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(ret == NULL);
 	n_background_threads--;
 	post_reentrancy(tsd);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -362,6 +378,7 @@ background_thread_create_signals_masked(pthread_t *thread,
 	sigset_t oldset;
 	int mask_err = pthread_sigmask(SIG_SETMASK, &set, &oldset);
 	if (mask_err != 0) {
+		__A_VARIABLE = 1;
 		return mask_err;
 	}
 	int create_err = pthread_create_wrapper(thread, attr, start_routine,
@@ -379,6 +396,7 @@ background_thread_create_signals_masked(pthread_t *thread,
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 	return create_err;
 }
 
@@ -387,6 +405,7 @@ check_background_thread_creation(tsd_t *tsd, unsigned *n_created,
     bool *created_threads) {
 	bool ret = false;
 	if (likely(*n_created == n_background_threads)) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 
@@ -429,6 +448,7 @@ check_background_thread_creation(tsd_t *tsd, unsigned *n_created,
 	}
 	malloc_mutex_lock(tsdn, &background_thread_info[0].mtx);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -479,6 +499,7 @@ background_thread0_work(tsd_t *tsd) {
 	}
 	background_thread_info[0].state = background_thread_stopped;
 	assert(n_background_threads == 1);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -502,6 +523,7 @@ background_work(tsd_t *tsd, unsigned ind) {
 	assert(info->state == background_thread_stopped);
 	background_thread_wakeup_time_set(tsd_tsdn(tsd), info, 0);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -523,6 +545,7 @@ background_thread_entry(void *ind_arg) {
 	assert(pthread_equal(pthread_self(),
 	    background_thread_info[thread_ind].thread));
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -532,6 +555,7 @@ background_thread_init(tsd_t *tsd, background_thread_info_t *info) {
 	info->state = background_thread_started;
 	background_thread_info_init(tsd_tsdn(tsd), info);
 	n_background_threads++;
+	__A_VARIABLE = 1;
 }
 
 /* Create a new background thread if needed. */
@@ -553,6 +577,7 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 	}
 	malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 	if (!need_new_thread) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (arena_ind != 0) {
@@ -563,6 +588,7 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 		pthread_cond_signal(&t0->cond);
 		malloc_mutex_unlock(tsd_tsdn(tsd), &t0->mtx);
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -583,9 +609,11 @@ background_thread_create(tsd_t *tsd, unsigned arena_ind) {
 		n_background_threads--;
 		malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -622,6 +650,7 @@ background_threads_enable(tsd_t *tsd) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return background_thread_create(tsd, 0);
 }
 
@@ -633,10 +662,12 @@ background_threads_disable(tsd_t *tsd) {
 	/* Thread 0 will be responsible for terminating other threads. */
 	if (background_threads_disable_single(tsd,
 	    &background_thread_info[0])) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(n_background_threads == 0);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -653,6 +684,7 @@ background_thread_interval_check(tsdn_t *tsdn, arena_t *arena,
 		 * threads.  So keep this non-blocking, and leave the work to a
 		 * future epoch.
 		 */
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -722,12 +754,14 @@ label_done_unlock2:
 	malloc_mutex_unlock(tsdn, &decay->mtx);
 label_done:
 	malloc_mutex_unlock(tsdn, &info->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 background_thread_prefork0(tsdn_t *tsdn) {
 	malloc_mutex_prefork(tsdn, &background_thread_lock);
 	background_thread_enabled_at_fork = background_thread_enabled();
+	__A_VARIABLE = 1;
 }
 
 void
@@ -735,6 +769,7 @@ background_thread_prefork1(tsdn_t *tsdn) {
 	for (unsigned i = 0; i < max_background_threads; i++) {
 		malloc_mutex_prefork(tsdn, &background_thread_info[i].mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -744,6 +779,7 @@ background_thread_postfork_parent(tsdn_t *tsdn) {
 		    &background_thread_info[i].mtx);
 	}
 	malloc_mutex_postfork_parent(tsdn, &background_thread_lock);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -754,6 +790,7 @@ background_thread_postfork_child(tsdn_t *tsdn) {
 	}
 	malloc_mutex_postfork_child(tsdn, &background_thread_lock);
 	if (!background_thread_enabled_at_fork) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -771,6 +808,7 @@ background_thread_postfork_child(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsdn, &info->mtx);
 	}
 	malloc_mutex_unlock(tsdn, &background_thread_lock);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -779,6 +817,7 @@ background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
 	malloc_mutex_lock(tsdn, &background_thread_lock);
 	if (!background_thread_enabled()) {
 		malloc_mutex_unlock(tsdn, &background_thread_lock);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -800,6 +839,7 @@ background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
 	}
 	malloc_mutex_unlock(tsdn, &background_thread_lock);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -810,6 +850,7 @@ background_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {
 static bool
 pthread_create_fptr_init(void) {
 	if (pthread_create_fptr != NULL) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	pthread_create_fptr = dlsym(RTLD_NEXT, "pthread_create");
@@ -824,6 +865,7 @@ pthread_create_fptr_init(void) {
 		can_enable_background_thread = true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -840,6 +882,7 @@ background_thread_ctl_init(tsdn_t *tsdn) {
 	pthread_create_fptr_init();
 	pthread_create_wrapper_init();
 #endif
+	__A_VARIABLE = 1;
 }
 
 #endif /* defined(JEMALLOC_BACKGROUND_THREAD) */
diff --git a/deps/jemalloc/src/base.c b/deps/jemalloc/src/base.c
index b0324b5..59ca7d2 100644
--- a/deps/jemalloc/src/base.c
+++ b/deps/jemalloc/src/base.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_BASE_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -24,6 +25,7 @@ const char *metadata_thp_mode_names[] = {
 
 static inline bool
 metadata_thp_madvise(void) {
+	__A_VARIABLE = 1;
 	return (metadata_thp_enabled() &&
 	    (init_system_thp_mode == thp_mode_default));
 }
@@ -48,6 +50,7 @@ base_map(tsdn_t *tsdn, extent_hooks_t *extent_hooks, unsigned ind, size_t size)
 		post_reentrancy(tsd);
 	}
 
+	__A_VARIABLE = 1;
 	return addr;
 }
 
@@ -113,6 +116,7 @@ label_done:
 		    (size & HUGEPAGE_MASK) == 0);
 		pages_nohuge(addr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -124,6 +128,7 @@ base_extent_init(size_t *extent_sn_next, extent_t *extent, void *addr,
 	(*extent_sn_next)++;
 
 	extent_binit(extent, addr, size, sn);
+	__A_VARIABLE = 1;
 }
 
 static size_t
@@ -137,6 +142,7 @@ base_get_num_blocks(base_t *base, bool with_new_block) {
 		b = b->next;
 	}
 
+	__A_VARIABLE = 1;
 	return n_blocks;
 }
 
@@ -145,6 +151,7 @@ base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
 	assert(opt_metadata_thp == metadata_thp_auto);
 	malloc_mutex_assert_owner(tsdn, &base->mtx);
 	if (base->auto_thp_switched) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	/* Called when adding a new block. */
@@ -157,6 +164,7 @@ base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
 		    BASE_AUTO_THP_THRESHOLD_A0);
 	}
 	if (!should_switch) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -174,6 +182,7 @@ base_auto_thp_switch(tsdn_t *tsdn, base_t *base) {
 		block = block->next;
 		assert(block == NULL || (base_ind_get(base) == 0));
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -191,6 +200,7 @@ base_extent_bump_alloc_helper(extent_t *extent, size_t *gap_size, size_t size,
 	extent_binit(extent, (void *)((uintptr_t)extent_addr_get(extent) +
 	    *gap_size + size), extent_bsize_get(extent) - *gap_size - size,
 	    extent_sn_get(extent));
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -226,6 +236,7 @@ base_extent_bump_alloc_post(base_t *base, extent_t *extent, size_t gap_size,
 			assert(base->mapped >= base->n_thp << LG_HUGEPAGE);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -236,6 +247,7 @@ base_extent_bump_alloc(base_t *base, extent_t *extent, size_t size,
 
 	ret = base_extent_bump_alloc_helper(extent, &gap_size, size, alignment);
 	base_extent_bump_alloc_post(base, extent, gap_size, ret, size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -270,6 +282,7 @@ base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
 	base_block_t *block = (base_block_t *)base_map(tsdn, extent_hooks, ind,
 	    block_size);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -297,6 +310,7 @@ base_block_alloc(tsdn_t *tsdn, base_t *base, extent_hooks_t *extent_hooks,
 	assert(block_size >= header_size);
 	base_extent_init(extent_sn_next, &block->extent,
 	    (void *)((uintptr_t)block + header_size), block_size - header_size);
+	__A_VARIABLE = 1;
 	return block;
 }
 
@@ -319,6 +333,7 @@ base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
 	    alignment);
 	malloc_mutex_lock(tsdn, &base->mtx);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	block->next = base->blocks;
@@ -338,11 +353,13 @@ base_extent_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
 		assert(base->resident <= base->mapped);
 		assert(base->n_thp << LG_HUGEPAGE <= base->mapped);
 	}
+	__A_VARIABLE = 1;
 	return &block->extent;
 }
 
 base_t *
 b0get(void) {
+	__A_VARIABLE = 1;
 	return b0;
 }
 
@@ -353,6 +370,7 @@ base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	base_block_t *block = base_block_alloc(tsdn, NULL, extent_hooks, ind,
 	    &pind_last, &extent_sn_next, sizeof(base_t), QUANTUM);
 	if (block == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -366,6 +384,7 @@ base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	if (malloc_mutex_init(&base->mtx, "base", WITNESS_RANK_BASE,
 	    malloc_mutex_rank_exclusive)) {
 		base_unmap(tsdn, extent_hooks, ind, block, block->size);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	base->pind_last = pind_last;
@@ -389,6 +408,7 @@ base_new(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	base_extent_bump_alloc_post(base, &block->extent, gap_size, base,
 	    base_size);
 
+	__A_VARIABLE = 1;
 	return base;
 }
 
@@ -402,10 +422,12 @@ base_delete(tsdn_t *tsdn, base_t *base) {
 		base_unmap(tsdn, extent_hooks, base_ind_get(base), block,
 		    block->size);
 	} while (next != NULL);
+	__A_VARIABLE = 1;
 }
 
 extent_hooks_t *
 base_extent_hooks_get(base_t *base) {
+	__A_VARIABLE = 1;
 	return (extent_hooks_t *)atomic_load_p(&base->extent_hooks,
 	    ATOMIC_ACQUIRE);
 }
@@ -414,6 +436,7 @@ extent_hooks_t *
 base_extent_hooks_set(base_t *base, extent_hooks_t *extent_hooks) {
 	extent_hooks_t *old_extent_hooks = base_extent_hooks_get(base);
 	atomic_store_p(&base->extent_hooks, extent_hooks, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return old_extent_hooks;
 }
 
@@ -449,6 +472,7 @@ base_alloc_impl(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment,
 	}
 label_return:
 	malloc_mutex_unlock(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -462,6 +486,7 @@ label_return:
  */
 void *
 base_alloc(tsdn_t *tsdn, base_t *base, size_t size, size_t alignment) {
+	__A_VARIABLE = 1;
 	return base_alloc_impl(tsdn, base, size, alignment, NULL);
 }
 
@@ -471,9 +496,11 @@ base_alloc_extent(tsdn_t *tsdn, base_t *base) {
 	extent_t *extent = base_alloc_impl(tsdn, base, sizeof(extent_t),
 	    CACHELINE, &esn);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	extent_esn_set(extent, esn);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -490,25 +517,30 @@ base_stats_get(tsdn_t *tsdn, base_t *base, size_t *allocated, size_t *resident,
 	*mapped = base->mapped;
 	*n_thp = base->n_thp;
 	malloc_mutex_unlock(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_prefork(tsdn_t *tsdn, base_t *base) {
 	malloc_mutex_prefork(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_postfork_parent(tsdn_t *tsdn, base_t *base) {
 	malloc_mutex_postfork_parent(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 base_postfork_child(tsdn_t *tsdn, base_t *base) {
 	malloc_mutex_postfork_child(tsdn, &base->mtx);
+	__A_VARIABLE = 1;
 }
 
 bool
 base_boot(tsdn_t *tsdn) {
 	b0 = base_new(tsdn, 0, (extent_hooks_t *)&extent_hooks_default);
+	__A_VARIABLE = 1;
 	return (b0 == NULL);
 }
diff --git a/deps/jemalloc/src/bin.c b/deps/jemalloc/src/bin.c
index 0886bc4..46ddd96 100644
--- a/deps/jemalloc/src/bin.c
+++ b/deps/jemalloc/src/bin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
 
@@ -23,6 +24,7 @@ bool
 bin_init(bin_t *bin) {
 	if (malloc_mutex_init(&bin->lock, "bin", WITNESS_RANK_BIN,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	bin->slabcur = NULL;
@@ -31,20 +33,24 @@ bin_init(bin_t *bin) {
 	if (config_stats) {
 		memset(&bin->stats, 0, sizeof(bin_stats_t));
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 void
 bin_prefork(tsdn_t *tsdn, bin_t *bin) {
 	malloc_mutex_prefork(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 bin_postfork_parent(tsdn_t *tsdn, bin_t *bin) {
 	malloc_mutex_postfork_parent(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
 
 void
 bin_postfork_child(tsdn_t *tsdn, bin_t *bin) {
 	malloc_mutex_postfork_child(tsdn, &bin->lock);
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/bitmap.c b/deps/jemalloc/src/bitmap.c
index 468b317..e5da7a6 100644
--- a/deps/jemalloc/src/bitmap.c
+++ b/deps/jemalloc/src/bitmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_BITMAP_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -34,10 +35,12 @@ bitmap_info_init(bitmap_info_t *binfo, size_t nbits) {
 	assert(binfo->levels[i].group_offset <= BITMAP_GROUPS_MAX);
 	binfo->nlevels = i;
 	binfo->nbits = nbits;
+	__A_VARIABLE = 1;
 }
 
 static size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo) {
+	__A_VARIABLE = 1;
 	return binfo->levels[binfo->nlevels].group_offset;
 }
 
@@ -54,6 +57,7 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 	if (fill) {
 		/* The "filled" bitmap starts out with all 0 bits. */
 		memset(bitmap, 0, bitmap_size(binfo));
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -78,6 +82,7 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 			bitmap[binfo->levels[i+1].group_offset - 1] >>= extra;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 #else /* BITMAP_USE_TREE */
@@ -89,10 +94,12 @@ bitmap_info_init(bitmap_info_t *binfo, size_t nbits) {
 
 	binfo->ngroups = BITMAP_BITS2GROUPS(nbits);
 	binfo->nbits = nbits;
+	__A_VARIABLE = 1;
 }
 
 static size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo) {
+	__A_VARIABLE = 1;
 	return binfo->ngroups;
 }
 
@@ -102,6 +109,7 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 
 	if (fill) {
 		memset(bitmap, 0, bitmap_size(binfo));
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -111,11 +119,13 @@ bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo, bool fill) {
 	if (extra != 0) {
 		bitmap[binfo->ngroups - 1] >>= extra;
 	}
+	__A_VARIABLE = 1;
 }
 
 #endif /* BITMAP_USE_TREE */
 
 size_t
 bitmap_size(const bitmap_info_t *binfo) {
+	__A_VARIABLE = 1;
 	return (bitmap_info_ngroups(binfo) << LG_SIZEOF_BITMAP);
 }
diff --git a/deps/jemalloc/src/ckh.c b/deps/jemalloc/src/ckh.c
index e95e0a3..7c61ba2 100644
--- a/deps/jemalloc/src/ckh.c
+++ b/deps/jemalloc/src/ckh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  *******************************************************************************
  * Implementation of (2^1+,2) cuckoo hashing, where 2^1+ indicates that each
@@ -67,10 +68,12 @@ ckh_bucket_search(ckh_t *ckh, size_t bucket, const void *key) {
 	for (i = 0; i < (ZU(1) << LG_CKH_BUCKET_CELLS); i++) {
 		cell = &ckh->tab[(bucket << LG_CKH_BUCKET_CELLS) + i];
 		if (cell->key != NULL && ckh->keycomp(key, cell->key)) {
+			__A_VARIABLE = 1;
 			return (bucket << LG_CKH_BUCKET_CELLS) + i;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return SIZE_T_MAX;
 }
 
@@ -89,12 +92,14 @@ ckh_isearch(ckh_t *ckh, const void *key) {
 	bucket = hashes[0] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	cell = ckh_bucket_search(ckh, bucket, key);
 	if (cell != SIZE_T_MAX) {
+		__A_VARIABLE = 1;
 		return cell;
 	}
 
 	/* Search secondary bucket. */
 	bucket = hashes[1] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	cell = ckh_bucket_search(ckh, bucket, key);
+	__A_VARIABLE = 1;
 	return cell;
 }
 
@@ -117,10 +122,12 @@ ckh_try_bucket_insert(ckh_t *ckh, size_t bucket, const void *key,
 			cell->key = key;
 			cell->data = data;
 			ckh->count++;
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -191,14 +198,17 @@ ckh_evict_reloc_insert(ckh_t *ckh, size_t argbucket, void const **argkey,
 		if (tbucket == argbucket) {
 			*argkey = key;
 			*argdata = data;
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		bucket = tbucket;
 		if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -212,18 +222,21 @@ ckh_try_insert(ckh_t *ckh, void const**argkey, void const**argdata) {
 	/* Try to insert in primary bucket. */
 	bucket = hashes[0] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	/* Try to insert in secondary bucket. */
 	bucket = hashes[1] & ((ZU(1) << ckh->lg_curbuckets) - 1);
 	if (!ckh_try_bucket_insert(ckh, bucket, key, data)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	/*
 	 * Try to find a place for this item via iterative eviction/relocation.
 	 */
+	__A_VARIABLE = 1;
 	return ckh_evict_reloc_insert(ckh, bucket, argkey, argdata);
 }
 
@@ -244,12 +257,14 @@ ckh_rebuild(ckh_t *ckh, ckhc_t *aTab) {
 			data = aTab[i].data;
 			if (ckh_try_insert(ckh, &key, &data)) {
 				ckh->count = count;
+				__A_VARIABLE = 1;
 				return true;
 			}
 			nins++;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -304,6 +319,7 @@ ckh_grow(tsd_t *tsd, ckh_t *ckh) {
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -321,6 +337,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 	lg_curcells = ckh->lg_curbuckets + LG_CKH_BUCKET_CELLS - 1;
 	usize = sz_sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
 	if (unlikely(usize == 0 || usize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tab = (ckhc_t *)ipallocztm(tsd_tsdn(tsd), usize, CACHELINE, true, NULL,
@@ -330,6 +347,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 		 * An OOM error isn't worth propagating, since it doesn't
 		 * prevent this or future operations from proceeding.
 		 */
+		__A_VARIABLE = 1;
 		return;
 	}
 	/* Swap in new table. */
@@ -343,6 +361,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 #ifdef CKH_COUNT
 		ckh->nshrinks++;
 #endif
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -353,6 +372,7 @@ ckh_shrink(tsd_t *tsd, ckh_t *ckh) {
 #ifdef CKH_COUNT
 	ckh->nshrinkfails++;
 #endif
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -409,6 +429,7 @@ ckh_new(tsd_t *tsd, ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -432,12 +453,14 @@ ckh_delete(tsd_t *tsd, ckh_t *ckh) {
 	if (config_debug) {
 		memset(ckh, JEMALLOC_FREE_JUNK, sizeof(ckh_t));
 	}
+	__A_VARIABLE = 1;
 }
 
 size_t
 ckh_count(ckh_t *ckh) {
 	assert(ckh != NULL);
 
+	__A_VARIABLE = 1;
 	return ckh->count;
 }
 
@@ -455,10 +478,12 @@ ckh_iter(ckh_t *ckh, size_t *tabind, void **key, void **data) {
 				*data = (void *)ckh->tab[i].data;
 			}
 			*tabind = i + 1;
+			__A_VARIABLE = 1;
 			return false;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -482,6 +507,7 @@ ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data) {
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -512,9 +538,11 @@ ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
 			ckh_shrink(tsd, ckh);
 		}
 
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -532,15 +560,18 @@ ckh_search(ckh_t *ckh, const void *searchkey, void **key, void **data) {
 		if (data != NULL) {
 			*data = (void *)ckh->tab[cell].data;
 		}
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
 void
 ckh_string_hash(const void *key, size_t r_hash[2]) {
 	hash(key, strlen((const char *)key), 0x94122f33U, r_hash);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -548,6 +579,7 @@ ckh_string_keycomp(const void *k1, const void *k2) {
 	assert(k1 != NULL);
 	assert(k2 != NULL);
 
+	__A_VARIABLE = 1;
 	return !strcmp((char *)k1, (char *)k2);
 }
 
@@ -561,9 +593,11 @@ ckh_pointer_hash(const void *key, size_t r_hash[2]) {
 	assert(sizeof(u.v) == sizeof(u.i));
 	u.v = key;
 	hash(&u.i, sizeof(u.i), 0xd983396eU, r_hash);
+	__A_VARIABLE = 1;
 }
 
 bool
 ckh_pointer_keycomp(const void *k1, const void *k2) {
+	__A_VARIABLE = 1;
 	return (k1 == k2);
 }
diff --git a/deps/jemalloc/src/ctl.c b/deps/jemalloc/src/ctl.c
index 1e713a3..e9d4451 100644
--- a/deps/jemalloc/src/ctl.c
+++ b/deps/jemalloc/src/ctl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_CTL_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
diff --git a/deps/jemalloc/src/div.c b/deps/jemalloc/src/div.c
index 808892a..fc907ff 100644
--- a/deps/jemalloc/src/div.c
+++ b/deps/jemalloc/src/div.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 
 #include "jemalloc/internal/div.h"
@@ -52,4 +53,5 @@ div_init(div_info_t *div_info, size_t d) {
 #ifdef JEMALLOC_DEBUG
 	div_info->d = d;
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/extent.c b/deps/jemalloc/src/extent.c
index 09d6d77..4f69ca3 100644
--- a/deps/jemalloc/src/extent.c
+++ b/deps/jemalloc/src/extent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_EXTENT_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -164,12 +165,14 @@ extent_lock_from_addr(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, void *addr) {
 	rtree_leaf_elm_t *elm = rtree_leaf_elm_lookup(tsdn, &extents_rtree,
 	    rtree_ctx, (uintptr_t)addr, false, false);
 	if (elm == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	lock_result_t lock_result;
 	do {
 		lock_result = extent_rtree_leaf_elm_try_lock(tsdn, elm, &ret);
 	} while (lock_result == lock_result_failure);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -179,10 +182,12 @@ extent_alloc(tsdn_t *tsdn, arena_t *arena) {
 	extent_t *extent = extent_avail_first(&arena->extent_avail);
 	if (extent == NULL) {
 		malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+		__A_VARIABLE = 1;
 		return base_alloc_extent(tsdn, arena->base);
 	}
 	extent_avail_remove(&arena->extent_avail, extent);
 	malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -191,10 +196,12 @@ extent_dalloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 	malloc_mutex_lock(tsdn, &arena->extent_avail_mtx);
 	extent_avail_insert(&arena->extent_avail, extent);
 	malloc_mutex_unlock(tsdn, &arena->extent_avail_mtx);
+	__A_VARIABLE = 1;
 }
 
 extent_hooks_t *
 extent_hooks_get(arena_t *arena) {
+	__A_VARIABLE = 1;
 	return base_extent_hooks_get(arena->base);
 }
 
@@ -210,6 +217,7 @@ extent_hooks_set(tsd_t *tsd, arena_t *arena, extent_hooks_t *extent_hooks) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -219,6 +227,7 @@ extent_hooks_assure_initialized(arena_t *arena,
 	if (*r_extent_hooks == EXTENT_HOOKS_INITIALIZER) {
 		*r_extent_hooks = extent_hooks_get(arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 #ifndef JEMALLOC_JET
@@ -240,10 +249,12 @@ extent_size_quantize_floor(size_t size) {
 		 * PAGE-spaced size classes, but it's simplest to just handle
 		 * the one case that would cause erroneous results.
 		 */
+		__A_VARIABLE = 1;
 		return size;
 	}
 	ret = sz_pind2sz(pind - 1) + sz_large_pad;
 	assert(ret <= size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -271,6 +282,7 @@ extent_size_quantize_ceil(size_t size) {
 		ret = sz_pind2sz(sz_psz2ind(ret - sz_large_pad + 1)) +
 		    sz_large_pad;
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -282,6 +294,7 @@ extents_init(tsdn_t *tsdn, extents_t *extents, extent_state_t state,
     bool delay_coalesce) {
 	if (malloc_mutex_init(&extents->mtx, "extents", WITNESS_RANK_EXTENTS,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	for (unsigned i = 0; i < NPSIZES+1; i++) {
@@ -292,16 +305,19 @@ extents_init(tsdn_t *tsdn, extents_t *extents, extent_state_t state,
 	atomic_store_zu(&extents->npages, 0, ATOMIC_RELAXED);
 	extents->state = state;
 	extents->delay_coalesce = delay_coalesce;
+	__A_VARIABLE = 1;
 	return false;
 }
 
 extent_state_t
 extents_state_get(const extents_t *extents) {
+	__A_VARIABLE = 1;
 	return extents->state;
 }
 
 size_t
 extents_npages_get(extents_t *extents) {
+	__A_VARIABLE = 1;
 	return atomic_load_zu(&extents->npages, ATOMIC_RELAXED);
 }
 
@@ -329,6 +345,7 @@ extents_insert_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
 	    atomic_load_zu(&extents->npages, ATOMIC_RELAXED);
 	atomic_store_zu(&extents->npages, cur_extents_npages + npages,
 	    ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -355,6 +372,7 @@ extents_remove_locked(tsdn_t *tsdn, extents_t *extents, extent_t *extent) {
 	assert(cur_extents_npages >= npages);
 	atomic_store_zu(&extents->npages,
 	    cur_extents_npages - (size >> LG_PAGE), ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -387,10 +405,12 @@ extents_fit_alignment(extents_t *extents, size_t min_size, size_t max_size,
 
 		size_t leadsize = next_align - base;
 		if (candidate_size - leadsize >= min_size) {
+			__A_VARIABLE = 1;
 			return extent;
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -407,14 +427,17 @@ extents_best_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		 * large extents for much smaller sizes.
 		 */
 		if ((sz_pind2sz(i) >> opt_lg_extent_max_active_fit) > size) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		assert(!extent_heap_empty(&extents->heaps[i]));
 		extent_t *extent = extent_heap_first(&extents->heaps[i]);
 		assert(extent_size_get(extent) >= size);
+		__A_VARIABLE = 1;
 		return extent;
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -444,6 +467,7 @@ extents_first_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		assert(i < NPSIZES);
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -461,6 +485,7 @@ extents_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 	size_t max_size = esize + PAGE_CEILING(alignment) - PAGE;
 	/* Beware size_t wrap-around. */
 	if (max_size < esize) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -478,6 +503,7 @@ extents_fit_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 		    alignment);
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -492,9 +518,11 @@ extent_try_delayed_coalesce(tsdn_t *tsdn, arena_t *arena,
 	extent_state_set(extent, extents_state_get(extents));
 
 	if (!coalesced) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	extents_insert_locked(tsdn, extents, extent);
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -510,6 +538,7 @@ extents_alloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_t *extent = extent_recycle(tsdn, arena, r_extent_hooks, extents,
 	    new_addr, size, pad, alignment, slab, szind, zero, commit, false);
 	assert(extent == NULL || extent_dumpable_get(extent));
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -526,6 +555,7 @@ extents_dalloc(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_zeroed_set(extent, false);
 
 	extent_record(tsdn, arena, r_extent_hooks, extents, extent, false);
+	__A_VARIABLE = 1;
 }
 
 extent_t *
@@ -589,6 +619,7 @@ extents_evict(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 
 label_return:
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -608,21 +639,25 @@ extents_leak(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		}
 	}
 	extent_dalloc(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_prefork(tsdn_t *tsdn, extents_t *extents) {
 	malloc_mutex_prefork(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_postfork_parent(tsdn_t *tsdn, extents_t *extents) {
 	malloc_mutex_postfork_parent(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
 extents_postfork_child(tsdn_t *tsdn, extents_t *extents) {
 	malloc_mutex_postfork_child(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -633,6 +668,7 @@ extent_deactivate_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 
 	extent_state_set(extent, extents_state_get(extents));
 	extents_insert_locked(tsdn, extents, extent);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -641,6 +677,7 @@ extent_deactivate(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 	malloc_mutex_lock(tsdn, &extents->mtx);
 	extent_deactivate_locked(tsdn, arena, extents, extent);
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -651,6 +688,7 @@ extent_activate_locked(tsdn_t *tsdn, arena_t *arena, extents_t *extents,
 
 	extents_remove_locked(tsdn, extents, extent);
 	extent_state_set(extent, extent_state_active);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -660,6 +698,7 @@ extent_rtree_leaf_elms_lookup(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
 	*r_elm_a = rtree_leaf_elm_lookup(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)extent_base_get(extent), dependent, init_missing);
 	if (!dependent && *r_elm_a == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(*r_elm_a != NULL);
@@ -667,10 +706,12 @@ extent_rtree_leaf_elms_lookup(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
 	*r_elm_b = rtree_leaf_elm_lookup(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)extent_last_get(extent), dependent, init_missing);
 	if (!dependent && *r_elm_b == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	assert(*r_elm_b != NULL);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -682,6 +723,7 @@ extent_rtree_write_acquired(tsdn_t *tsdn, rtree_leaf_elm_t *elm_a,
 		rtree_leaf_elm_write(tsdn, &extents_rtree, elm_b, extent, szind,
 		    slab);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -695,6 +737,7 @@ extent_interior_register(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx, extent_t *extent,
 		    (uintptr_t)extent_base_get(extent) + (uintptr_t)(i <<
 		    LG_PAGE), extent, szind, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -721,6 +764,7 @@ extent_gdump_add(tsdn_t *tsdn, const extent_t *extent) {
 			prof_gdump(tsdn);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -732,6 +776,7 @@ extent_gdump_sub(tsdn_t *tsdn, const extent_t *extent) {
 		assert(atomic_load_zu(&curpages, ATOMIC_RELAXED) >= nsub);
 		atomic_fetch_sub_zu(&curpages, nsub, ATOMIC_RELAXED);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -748,6 +793,7 @@ extent_register_impl(tsdn_t *tsdn, extent_t *extent, bool gdump_add) {
 
 	if (extent_rtree_leaf_elms_lookup(tsdn, rtree_ctx, extent, false, true,
 	    &elm_a, &elm_b)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -764,16 +810,19 @@ extent_register_impl(tsdn_t *tsdn, extent_t *extent, bool gdump_add) {
 		extent_gdump_add(tsdn, extent);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 static bool
 extent_register(tsdn_t *tsdn, extent_t *extent) {
+	__A_VARIABLE = 1;
 	return extent_register_impl(tsdn, extent, true);
 }
 
 static bool
 extent_register_no_gdump_add(tsdn_t *tsdn, extent_t *extent) {
+	__A_VARIABLE = 1;
 	return extent_register_impl(tsdn, extent, false);
 }
 
@@ -781,6 +830,7 @@ static void
 extent_reregister(tsdn_t *tsdn, extent_t *extent) {
 	bool err = extent_register(tsdn, extent);
 	assert(!err);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -802,6 +852,7 @@ extent_interior_deregister(tsdn_t *tsdn, rtree_ctx_t *rtree_ctx,
 		    (uintptr_t)extent_base_get(extent) + (uintptr_t)(i <<
 		    LG_PAGE));
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -828,16 +879,19 @@ extent_deregister_impl(tsdn_t *tsdn, extent_t *extent, bool gdump) {
 	if (config_prof && gdump) {
 		extent_gdump_sub(tsdn, extent);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deregister(tsdn_t *tsdn, extent_t *extent) {
 	extent_deregister_impl(tsdn, extent, true);
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_deregister_no_gdump_sub(tsdn_t *tsdn, extent_t *extent) {
 	extent_deregister_impl(tsdn, extent, false);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -896,12 +950,14 @@ extent_recycle_extract(tsdn_t *tsdn, arena_t *arena,
 	}
 	if (extent == NULL) {
 		malloc_mutex_unlock(tsdn, &extents->mtx);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	extent_activate_locked(tsdn, arena, extents, extent);
 	malloc_mutex_unlock(tsdn, &extents->mtx);
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -945,6 +1001,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 	    PAGE_CEILING(alignment)) - (uintptr_t)extent_base_get(*extent);
 	assert(new_addr == NULL || leadsize == 0);
 	if (extent_size_get(*extent) < leadsize + esize) {
+		__A_VARIABLE = 1;
 		return extent_split_interior_cant_alloc;
 	}
 	size_t trailsize = extent_size_get(*extent) - leadsize - esize;
@@ -963,6 +1020,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 		if (*extent == NULL) {
 			*to_leak = *lead;
 			*lead = NULL;
+			__A_VARIABLE = 1;
 			return extent_split_interior_error;
 		}
 	}
@@ -977,6 +1035,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 			*to_salvage = *lead;
 			*lead = NULL;
 			*extent = NULL;
+			__A_VARIABLE = 1;
 			return extent_split_interior_error;
 		}
 	}
@@ -999,6 +1058,7 @@ extent_split_interior(tsdn_t *tsdn, arena_t *arena,
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return extent_split_interior_ok;
 }
 
@@ -1075,6 +1135,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	    rtree_ctx, extents, new_addr, size, pad, alignment, slab,
 	    growing_retained);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1082,6 +1143,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	    extents, new_addr, size, pad, alignment, slab, szind, extent,
 	    growing_retained);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1090,6 +1152,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		    0, extent_size_get(extent), growing_retained)) {
 			extent_record(tsdn, arena, r_extent_hooks, extents,
 			    extent, growing_retained);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		extent_zeroed_set(extent, true);
@@ -1125,6 +1188,7 @@ extent_recycle(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 			}
 		}
 	}
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1146,21 +1210,25 @@ extent_alloc_core(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 	if (have_dss && dss_prec == dss_prec_primary && (ret =
 	    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
 	    commit)) != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	/* mmap. */
 	if ((ret = extent_alloc_mmap(new_addr, size, alignment, zero, commit))
 	    != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	/* "secondary" dss. */
 	if (have_dss && dss_prec == dss_prec_secondary && (ret =
 	    extent_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
 	    commit)) != NULL) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 
 	/* All strategies for allocation failed. */
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1173,6 +1241,7 @@ extent_alloc_default_impl(tsdn_t *tsdn, arena_t *arena, void *new_addr,
 	if (have_madvise_huge && ret) {
 		pages_set_thp_state(ret, size);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1190,6 +1259,7 @@ extent_alloc_default(extent_hooks_t *extent_hooks, void *new_addr, size_t size,
 	 */
 	assert(arena != NULL);
 
+	__A_VARIABLE = 1;
 	return extent_alloc_default_impl(tsdn, arena, new_addr, size,
 	    alignment, zero, commit);
 }
@@ -1209,12 +1279,14 @@ extent_hook_pre_reentrancy(tsdn_t *tsdn, arena_t *arena) {
 	} else {
 		pre_reentrancy(tsd, arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_hook_post_reentrancy(tsdn_t *tsdn) {
 	tsd_t *tsd = tsdn_null(tsdn) ? tsd_fetch() : tsdn_tsd(tsdn);
 	post_reentrancy(tsd);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -1380,9 +1452,11 @@ extent_grow_retained(tsdn_t *tsdn, arena_t *arena,
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 label_err:
 	malloc_mutex_unlock(tsdn, &arena->extent_grow_mtx);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1412,6 +1486,7 @@ extent_alloc_retained(tsdn_t *tsdn, arena_t *arena,
 	}
 	malloc_mutex_assert_not_owner(tsdn, &arena->extent_grow_mtx);
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1422,6 +1497,7 @@ extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
 	size_t esize = size + pad;
 	extent_t *extent = extent_alloc(tsdn, arena);
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	void *addr;
@@ -1437,6 +1513,7 @@ extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
 	}
 	if (addr == NULL) {
 		extent_dalloc(tsdn, arena, extent);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	extent_init(extent, arena, addr, esize, slab, szind,
@@ -1448,9 +1525,11 @@ extent_alloc_wrapper_hard(tsdn_t *tsdn, arena_t *arena,
 	if (extent_register(tsdn, extent)) {
 		extents_leak(tsdn, arena, r_extent_hooks,
 		    &arena->extents_retained, extent, false);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1473,6 +1552,7 @@ extent_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 			 * that is very unlikely to succeed (unless it happens
 			 * to be at the end).
 			 */
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		extent = extent_alloc_wrapper_hard(tsdn, arena, r_extent_hooks,
@@ -1480,6 +1560,7 @@ extent_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	assert(extent == NULL || extent_dumpable_get(extent));
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1488,18 +1569,22 @@ extent_can_coalesce(arena_t *arena, extents_t *extents, const extent_t *inner,
     const extent_t *outer) {
 	assert(extent_arena_get(inner) == arena);
 	if (extent_arena_get(outer) != arena) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	assert(extent_state_get(inner) == extent_state_active);
 	if (extent_state_get(outer) != extents->state) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
 	if (extent_committed_get(inner) != extent_committed_get(outer)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -1520,6 +1605,7 @@ extent_coalesce(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 		extent_deactivate_locked(tsdn, arena, extents, outer);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1555,6 +1641,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 				if (extents->delay_coalesce) {
 					/* Do minimal coalescing. */
 					*coalesced = true;
+					__A_VARIABLE = 1;
 					return extent;
 				}
 				again = true;
@@ -1576,6 +1663,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 				if (extents->delay_coalesce) {
 					/* Do minimal coalescing. */
 					*coalesced = true;
+					__A_VARIABLE = 1;
 					return extent;
 				}
 				again = true;
@@ -1586,6 +1674,7 @@ extent_try_coalesce(tsdn_t *tsdn, arena_t *arena,
 	if (extents->delay_coalesce) {
 		*coalesced = false;
 	}
+	__A_VARIABLE = 1;
 	return extent;
 }
 
@@ -1634,6 +1723,7 @@ extent_record(tsdn_t *tsdn, arena_t *arena, extent_hooks_t **r_extent_hooks,
 	extent_deactivate_locked(tsdn, arena, extents, extent);
 
 	malloc_mutex_unlock(tsdn, &extents->mtx);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1646,22 +1736,27 @@ extent_dalloc_gap(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 	if (extent_register(tsdn, extent)) {
 		extents_leak(tsdn, arena, &extent_hooks,
 		    &arena->extents_retained, extent, false);
+		__A_VARIABLE = 1;
 		return;
 	}
 	extent_dalloc_wrapper(tsdn, arena, &extent_hooks, extent);
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_dalloc_default_impl(void *addr, size_t size) {
 	if (!have_dss || !extent_in_dss(addr)) {
+		__A_VARIABLE = 1;
 		return extent_dalloc_mmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 extent_dalloc_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     bool committed, unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return extent_dalloc_default_impl(addr, size);
 }
 
@@ -1696,6 +1791,7 @@ extent_dalloc_wrapper_try(tsdn_t *tsdn, arena_t *arena,
 		extent_dalloc(tsdn, arena, extent);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1712,6 +1808,7 @@ extent_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 	 */
 	extent_deregister(tsdn, extent);
 	if (!extent_dalloc_wrapper_try(tsdn, arena, r_extent_hooks, extent)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1751,6 +1848,7 @@ extent_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
 
 	extent_record(tsdn, arena, r_extent_hooks, &arena->extents_retained,
 	    extent, false);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1758,12 +1856,14 @@ extent_destroy_default_impl(void *addr, size_t size) {
 	if (!have_dss || !extent_in_dss(addr)) {
 		pages_unmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 extent_destroy_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     bool committed, unsigned arena_ind) {
 	extent_destroy_default_impl(addr, size);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -1794,11 +1894,13 @@ extent_destroy_wrapper(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	extent_dalloc(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 static bool
 extent_commit_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t offset, size_t length, unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return pages_commit((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1821,6 +1923,7 @@ extent_commit_impl(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 	extent_committed_set(extent, extent_committed_get(extent) || !err);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1828,6 +1931,7 @@ bool
 extent_commit_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	__A_VARIABLE = 1;
 	return extent_commit_impl(tsdn, arena, r_extent_hooks, extent, offset,
 	    length, false);
 }
@@ -1835,6 +1939,7 @@ extent_commit_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_decommit_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t offset, size_t length, unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return pages_decommit((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1859,6 +1964,7 @@ extent_decommit_wrapper(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 	extent_committed_set(extent, extent_committed_get(extent) && err);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1871,6 +1977,7 @@ extent_purge_lazy_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
 	assert(length != 0);
 	assert((length & PAGE_MASK) == 0);
 
+	__A_VARIABLE = 1;
 	return pages_purge_lazy((void *)((uintptr_t)addr + (uintptr_t)offset),
 	    length);
 }
@@ -1886,6 +1993,7 @@ extent_purge_lazy_impl(tsdn_t *tsdn, arena_t *arena,
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->purge_lazy == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (*r_extent_hooks != &extent_hooks_default) {
@@ -1898,6 +2006,7 @@ extent_purge_lazy_impl(tsdn_t *tsdn, arena_t *arena,
 		extent_hook_post_reentrancy(tsdn);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1905,6 +2014,7 @@ bool
 extent_purge_lazy_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	__A_VARIABLE = 1;
 	return extent_purge_lazy_impl(tsdn, arena, r_extent_hooks, extent,
 	    offset, length, false);
 }
@@ -1918,6 +2028,7 @@ extent_purge_forced_default(extent_hooks_t *extent_hooks, void *addr,
 	assert(length != 0);
 	assert((length & PAGE_MASK) == 0);
 
+	__A_VARIABLE = 1;
 	return pages_purge_forced((void *)((uintptr_t)addr +
 	    (uintptr_t)offset), length);
 }
@@ -1933,6 +2044,7 @@ extent_purge_forced_impl(tsdn_t *tsdn, arena_t *arena,
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->purge_forced == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (*r_extent_hooks != &extent_hooks_default) {
@@ -1944,6 +2056,7 @@ extent_purge_forced_impl(tsdn_t *tsdn, arena_t *arena,
 	if (*r_extent_hooks != &extent_hooks_default) {
 		extent_hook_post_reentrancy(tsdn);
 	}
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -1951,6 +2064,7 @@ bool
 extent_purge_forced_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t offset,
     size_t length) {
+	__A_VARIABLE = 1;
 	return extent_purge_forced_impl(tsdn, arena, r_extent_hooks, extent,
 	    offset, length, false);
 }
@@ -1959,6 +2073,7 @@ extent_purge_forced_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_split_default(extent_hooks_t *extent_hooks, void *addr, size_t size,
     size_t size_a, size_t size_b, bool committed, unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return !maps_coalesce;
 }
 #endif
@@ -1982,6 +2097,7 @@ extent_split_impl(tsdn_t *tsdn, arena_t *arena,
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->split == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -2043,12 +2159,14 @@ extent_split_impl(tsdn_t *tsdn, arena_t *arena,
 
 	extent_unlock2(tsdn, extent, trail);
 
+	__A_VARIABLE = 1;
 	return trail;
 label_error_c:
 	extent_unlock2(tsdn, extent, trail);
 label_error_b:
 	extent_dalloc(tsdn, arena, trail);
 label_error_a:
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -2056,6 +2174,7 @@ extent_t *
 extent_split_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *extent, size_t size_a,
     szind_t szind_a, bool slab_a, size_t size_b, szind_t szind_b, bool slab_b) {
+	__A_VARIABLE = 1;
 	return extent_split_impl(tsdn, arena, r_extent_hooks, extent, size_a,
 	    szind_a, slab_a, size_b, szind_b, slab_b, false);
 }
@@ -2063,12 +2182,15 @@ extent_split_wrapper(tsdn_t *tsdn, arena_t *arena,
 static bool
 extent_merge_default_impl(void *addr_a, void *addr_b) {
 	if (!maps_coalesce) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (have_dss && !extent_dss_mergeable(addr_a, addr_b)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -2076,6 +2198,7 @@ extent_merge_default_impl(void *addr_a, void *addr_b) {
 static bool
 extent_merge_default(extent_hooks_t *extent_hooks, void *addr_a, size_t size_a,
     void *addr_b, size_t size_b, bool committed, unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return extent_merge_default_impl(addr_a, addr_b);
 }
 #endif
@@ -2090,6 +2213,7 @@ extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
 	extent_hooks_assure_initialized(arena, r_extent_hooks);
 
 	if ((*r_extent_hooks)->merge == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2108,6 +2232,7 @@ extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
 	}
 
 	if (err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2149,23 +2274,27 @@ extent_merge_impl(tsdn_t *tsdn, arena_t *arena,
 
 	extent_dalloc(tsdn, extent_arena_get(b), b);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
 bool
 extent_merge_wrapper(tsdn_t *tsdn, arena_t *arena,
     extent_hooks_t **r_extent_hooks, extent_t *a, extent_t *b) {
+	__A_VARIABLE = 1;
 	return extent_merge_impl(tsdn, arena, r_extent_hooks, a, b, false);
 }
 
 bool
 extent_boot(void) {
 	if (rtree_new(&extents_rtree, true)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	if (mutex_pool_init(&extent_mutex_pool, "extent_mutex_pool",
 	    WITNESS_RANK_EXTENT_POOL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -2173,5 +2302,6 @@ extent_boot(void) {
 		extent_dss_boot();
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/extent_dss.c b/deps/jemalloc/src/extent_dss.c
index 2b1ea9c..cb78601 100644
--- a/deps/jemalloc/src/extent_dss.c
+++ b/deps/jemalloc/src/extent_dss.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_EXTENT_DSS_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -53,18 +54,22 @@ extent_dss_prec_get(void) {
 	dss_prec_t ret;
 
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return dss_prec_disabled;
 	}
 	ret = (dss_prec_t)atomic_load_u(&dss_prec_default, ATOMIC_ACQUIRE);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 bool
 extent_dss_prec_set(dss_prec_t dss_prec) {
 	if (!have_dss) {
+		__A_VARIABLE = 1;
 		return (dss_prec != dss_prec_disabled);
 	}
 	atomic_store_u(&dss_prec_default, (unsigned)dss_prec, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -79,6 +84,7 @@ extent_dss_extending_start(void) {
 		}
 		spin_adaptive(&spinner);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -86,6 +92,7 @@ extent_dss_extending_finish(void) {
 	assert(atomic_load_b(&dss_extending, ATOMIC_RELAXED));
 
 	atomic_store_b(&dss_extending, false, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -96,13 +103,16 @@ extent_dss_max_update(void *new_addr) {
 	 */
 	void *max_cur = extent_dss_sbrk(0);
 	if (max_cur == (void *)-1) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	atomic_store_p(&dss_max, max_cur, ATOMIC_RELEASE);
 	/* Fixed new_addr can only be supported if it is at the edge of DSS. */
 	if (new_addr != NULL && max_cur != new_addr) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
+	__A_VARIABLE = 1;
 	return max_cur;
 }
 
@@ -120,11 +130,13 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 	 * interpret a large allocation request as a negative increment.
 	 */
 	if ((intptr_t)size < 0) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	gap = extent_alloc(tsdn, arena);
 	if (gap == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -207,6 +219,7 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 						memset(ret, 0, size);
 					}
 				}
+				__A_VARIABLE = 1;
 				return ret;
 			}
 			/*
@@ -224,11 +237,13 @@ extent_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
 label_oom:
 	extent_dss_extending_finish();
 	extent_dalloc(tsdn, arena, gap);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 static bool
 extent_in_dss_helper(void *addr, void *max) {
+	__A_VARIABLE = 1;
 	return ((uintptr_t)addr >= (uintptr_t)dss_base && (uintptr_t)addr <
 	    (uintptr_t)max);
 }
@@ -237,6 +252,7 @@ bool
 extent_in_dss(void *addr) {
 	cassert(have_dss);
 
+	__A_VARIABLE = 1;
 	return extent_in_dss_helper(addr, atomic_load_p(&dss_max,
 	    ATOMIC_ACQUIRE));
 }
@@ -249,10 +265,12 @@ extent_dss_mergeable(void *addr_a, void *addr_b) {
 
 	if ((uintptr_t)addr_a < (uintptr_t)dss_base && (uintptr_t)addr_b <
 	    (uintptr_t)dss_base) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	max = atomic_load_p(&dss_max, ATOMIC_ACQUIRE);
+	__A_VARIABLE = 1;
 	return (extent_in_dss_helper(addr_a, max) ==
 	    extent_in_dss_helper(addr_b, max));
 }
@@ -265,6 +283,7 @@ extent_dss_boot(void) {
 	atomic_store_b(&dss_extending, false, ATOMIC_RELAXED);
 	atomic_store_b(&dss_exhausted, dss_base == (void *)-1, ATOMIC_RELAXED);
 	atomic_store_p(&dss_max, dss_base, ATOMIC_RELAXED);
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
diff --git a/deps/jemalloc/src/extent_mmap.c b/deps/jemalloc/src/extent_mmap.c
index 8d607dc..7a0330a 100644
--- a/deps/jemalloc/src/extent_mmap.c
+++ b/deps/jemalloc/src/extent_mmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_EXTENT_MMAP_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -24,12 +25,14 @@ extent_alloc_mmap(void *new_addr, size_t size, size_t alignment, bool *zero,
 	void *ret = pages_map(new_addr, size, ALIGNMENT_CEILING(alignment,
 	    PAGE), commit);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	assert(ret != NULL);
 	if (*commit) {
 		*zero = true;
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -38,5 +41,6 @@ extent_dalloc_mmap(void *addr, size_t size) {
 	if (!opt_retain) {
 		pages_unmap(addr, size);
 	}
+	__A_VARIABLE = 1;
 	return opt_retain;
 }
diff --git a/deps/jemalloc/src/hash.c b/deps/jemalloc/src/hash.c
index 7b2bdc2..84649ac 100644
--- a/deps/jemalloc/src/hash.c
+++ b/deps/jemalloc/src/hash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_HASH_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
diff --git a/deps/jemalloc/src/hooks.c b/deps/jemalloc/src/hooks.c
index 6266ecd..da97b84 100644
--- a/deps/jemalloc/src/hooks.c
+++ b/deps/jemalloc/src/hooks.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 
 /*
diff --git a/deps/jemalloc/src/jemalloc.c b/deps/jemalloc/src/jemalloc.c
index 5b936cb..b502f12 100644
--- a/deps/jemalloc/src/jemalloc.c
+++ b/deps/jemalloc/src/jemalloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -148,6 +149,7 @@ _init_init_lock(void) {
 		    malloc_mutex_rank_exclusive);
 	}
 	init_lock_initialized = true;
+	__A_VARIABLE = 1;
 }
 
 #ifdef _MSC_VER
@@ -201,22 +203,27 @@ static bool	malloc_init_hard(void);
 
 bool
 malloc_initialized(void) {
+	__A_VARIABLE = 1;
 	return (malloc_init_state == malloc_init_initialized);
 }
 
 JEMALLOC_ALWAYS_INLINE bool
 malloc_init_a0(void) {
 	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
+		__A_VARIABLE = 1;
 		return malloc_init_hard_a0();
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
 JEMALLOC_ALWAYS_INLINE bool
 malloc_init(void) {
 	if (unlikely(!malloc_initialized()) && malloc_init_hard()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -228,9 +235,11 @@ malloc_init(void) {
 static void *
 a0ialloc(size_t size, bool zero, bool is_internal) {
 	if (unlikely(malloc_init_a0())) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,
 	    is_internal, arena_get(TSDN_NULL, 0, true), true);
 }
@@ -238,16 +247,19 @@ a0ialloc(size_t size, bool zero, bool is_internal) {
 static void
 a0idalloc(void *ptr, bool is_internal) {
 	idalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);
+	__A_VARIABLE = 1;
 }
 
 void *
 a0malloc(size_t size) {
+	__A_VARIABLE = 1;
 	return a0ialloc(size, false, true);
 }
 
 void
 a0dalloc(void *ptr) {
 	a0idalloc(ptr, true);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -262,6 +274,7 @@ bootstrap_malloc(size_t size) {
 		size = 1;
 	}
 
+	__A_VARIABLE = 1;
 	return a0ialloc(size, false, false);
 }
 
@@ -275,35 +288,42 @@ bootstrap_calloc(size_t num, size_t size) {
 		num_size = 1;
 	}
 
+	__A_VARIABLE = 1;
 	return a0ialloc(num_size, true, false);
 }
 
 void
 bootstrap_free(void *ptr) {
 	if (unlikely(ptr == NULL)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	a0idalloc(ptr, false);
+	__A_VARIABLE = 1;
 }
 
 void
 arena_set(unsigned ind, arena_t *arena) {
 	atomic_store_p(&arenas[ind], arena, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void
 narenas_total_set(unsigned narenas) {
 	atomic_store_u(&narenas_total, narenas, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static void
 narenas_total_inc(void) {
 	atomic_fetch_add_u(&narenas_total, 1, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 unsigned
 narenas_total_get(void) {
+	__A_VARIABLE = 1;
 	return atomic_load_u(&narenas_total, ATOMIC_ACQUIRE);
 }
 
@@ -314,6 +334,7 @@ arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 
 	assert(ind <= narenas_total_get());
 	if (ind >= MALLOCX_ARENA_LIMIT) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	if (ind == narenas_total_get()) {
@@ -327,18 +348,21 @@ arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 	arena = arena_get(tsdn, ind, false);
 	if (arena != NULL) {
 		assert(ind < narenas_auto);
+		__A_VARIABLE = 1;
 		return arena;
 	}
 
 	/* Actually initialize the arena. */
 	arena = arena_new(tsdn, ind, extent_hooks);
 
+	__A_VARIABLE = 1;
 	return arena;
 }
 
 static void
 arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
 	if (ind == 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (have_background_thread) {
@@ -352,6 +376,7 @@ arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 arena_t *
@@ -364,6 +389,7 @@ arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
 
 	arena_new_create_background_thread(tsdn, ind);
 
+	__A_VARIABLE = 1;
 	return arena;
 }
 
@@ -377,6 +403,7 @@ arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
 	} else {
 		tsd_arena_set(tsd, arena);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -388,6 +415,7 @@ arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
 	arena_nthreads_dec(oldarena, false);
 	arena_nthreads_inc(newarena, false);
 	tsd_arena_set(tsd, newarena);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -402,6 +430,7 @@ arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
 	} else {
 		tsd_arena_set(tsd, NULL);
 	}
+	__A_VARIABLE = 1;
 }
 
 arena_tdata_t *
@@ -477,6 +506,7 @@ label_return:
 	if (arenas_tdata_old != NULL) {
 		a0dalloc(arenas_tdata_old);
 	}
+	__A_VARIABLE = 1;
 	return tdata;
 }
 
@@ -603,6 +633,7 @@ iarena_cleanup(tsd_t *tsd) {
 	if (iarena != NULL) {
 		arena_unbind(tsd, arena_ind_get(iarena), true);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -613,6 +644,7 @@ arena_cleanup(tsd_t *tsd) {
 	if (arena != NULL) {
 		arena_unbind(tsd, arena_ind_get(arena), false);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -627,6 +659,7 @@ arenas_tdata_cleanup(tsd_t *tsd) {
 		tsd_arenas_tdata_set(tsd, NULL);
 		a0dalloc(arenas_tdata);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -659,6 +692,7 @@ stats_print_atexit(void) {
 		}
 	}
 	je_malloc_stats_print(NULL, NULL, opt_stats_print_opts);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -669,9 +703,11 @@ stats_print_atexit(void) {
 JEMALLOC_ALWAYS_INLINE void
 check_entry_exit_locking(tsdn_t *tsdn) {
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tsdn_null(tsdn)) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd_t *tsd = tsdn_tsd(tsdn);
@@ -681,9 +717,11 @@ check_entry_exit_locking(tsdn_t *tsdn) {
 	 */
 	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
 	if (reentrancy_level != 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -733,6 +771,7 @@ malloc_ncpus(void) {
 #else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 #endif
+	__A_VARIABLE = 1;
 	return ((result == -1) ? 1 : (unsigned)result);
 }
 
@@ -797,9 +836,11 @@ malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
 				malloc_write("<jemalloc>: Conf string ends "
 				    "with key\n");
 			}
+			__A_VARIABLE = 1;
 			return true;
 		default:
 			malloc_write("<jemalloc>: Malformed conf string\n");
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
@@ -833,6 +874,7 @@ malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
 	}
 
 	*opts_p = opts;
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -842,6 +884,7 @@ malloc_abort_invalid_conf(void) {
 	malloc_printf("<jemalloc>: Abort (abort_conf:true) on invalid conf "
 	    "value (see above).\n");
 	abort();
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -851,6 +894,7 @@ malloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,
 	    (int)vlen, v);
 	/* If abort_conf is set, error out after processing all options. */
 	had_conf_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -866,6 +910,7 @@ malloc_slow_flag_init(void) {
 	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
 
 	malloc_slow = (malloc_slow_flags != 0);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1243,6 +1288,7 @@ malloc_conf_init(void) {
 		}
 	}
 	atomic_store_b(&log_init_done, true, ATOMIC_RELEASE);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1289,15 +1335,19 @@ malloc_init_hard_a0_locked() {
 		}
 	}
 	if (pages_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (base_boot(TSDN_NULL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (extent_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (ctl_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (config_prof) {
@@ -1305,10 +1355,12 @@ malloc_init_hard_a0_locked() {
 	}
 	arena_boot();
 	if (tcache_boot(TSDN_NULL)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (malloc_mutex_init(&arenas_lock, "arenas", WITNESS_RANK_ARENAS,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	/*
@@ -1323,11 +1375,13 @@ malloc_init_hard_a0_locked() {
 	 */
 	if (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&extent_hooks_default)
 	    == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	a0 = arena_get(TSDN_NULL, 0, false);
 	malloc_init_state = malloc_init_a0_initialized;
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1338,6 +1392,7 @@ malloc_init_hard_a0(void) {
 	malloc_mutex_lock(TSDN_NULL, &init_lock);
 	ret = malloc_init_hard_a0_locked();
 	malloc_mutex_unlock(TSDN_NULL, &init_lock);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1392,6 +1447,7 @@ percpu_arena_as_initialized(percpu_arena_mode_t mode) {
 		mode += percpu_arena_mode_enabled_base;
 	}
 
+	__A_VARIABLE = 1;
 	return mode;
 }
 
@@ -1470,17 +1526,20 @@ malloc_init_narenas(void) {
 static void
 malloc_init_percpu(void) {
 	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
+	__A_VARIABLE = 1;
 }
 
 static bool
 malloc_init_hard_finish(void) {
 	if (malloc_mutex_boot()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
 	malloc_init_state = malloc_init_initialized;
 	malloc_slow_flag_init();
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1494,6 +1553,7 @@ malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
 		assert(tsd_reentrancy_level_get(tsd) > 0);
 		post_reentrancy(tsd);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1522,9 +1582,11 @@ malloc_init_hard(void) {
 	/* Recursive allocation relies on functional tsd. */
 	tsd = malloc_tsd_boot0();
 	if (tsd == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (malloc_init_hard_recursible()) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1565,10 +1627,12 @@ malloc_init_hard(void) {
 		bool err = background_thread_create(tsd, 0);
 		malloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);
 		if (err) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
 #undef UNLOCK_RETURN
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1634,6 +1698,7 @@ static_opts_init(static_opts_t *static_opts) {
 	static_opts->oom_string = "";
 	static_opts->invalid_alignment_string = "";
 	static_opts->slow = false;
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -1665,6 +1730,7 @@ dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
 	dynamic_opts->zero = false;
 	dynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;
 	dynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;
+	__A_VARIABLE = 1;
 }
 
 /* ind is ignored if dopts->alignment > 0. */
@@ -1702,10 +1768,12 @@ imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
 	}
 
 	if (unlikely(dopts->alignment != 0)) {
+		__A_VARIABLE = 1;
 		return ipalloct(tsd_tsdn(tsd), usize, dopts->alignment,
 		    dopts->zero, tcache, arena);
 	}
 
+	__A_VARIABLE = 1;
 	return iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false,
 	    arena, sopts->slow);
 }
@@ -1756,6 +1824,7 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	if (!may_overflow) {
 		assert(dopts->num_items == 1);
 		*size = dopts->item_size;
+		__A_VARIABLE = 1;
 		return false;
 	}
 
@@ -1765,6 +1834,7 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	*size = dopts->item_size * dopts->num_items;
 
 	if (unlikely(*size == 0)) {
+		__A_VARIABLE = 1;
 		return (dopts->num_items != 0 && dopts->item_size != 0);
 	}
 
@@ -1775,11 +1845,14 @@ compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
 	 * can be represented in N bits (without the possibility of overflow).
 	 */
 	if (likely((high_bits & (dopts->num_items | dopts->item_size)) == 0)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (likely(*size / dopts->item_size == dopts->num_items)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -1928,6 +2001,7 @@ imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
 	/* Success! */
 	check_entry_exit_locking(tsd_tsdn(tsd));
 	*dopts->result = allocation;
+	__A_VARIABLE = 1;
 	return 0;
 
 label_oom:
@@ -1950,6 +2024,7 @@ label_oom:
 		*dopts->result = NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return ENOMEM;
 
 	/*
@@ -1977,6 +2052,7 @@ label_invalid_alignment:
 		*dopts->result = NULL;
 	}
 
+	__A_VARIABLE = 1;
 	return EINVAL;
 }
 
@@ -2180,11 +2256,13 @@ irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
 	}
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, true);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
 	    old_tctx);
 
+	__A_VARIABLE = 1;
 	return p;
 }
 
@@ -2225,6 +2303,7 @@ ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
 		idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,
 		    true);
 	}
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ALWAYS_INLINE void
@@ -2281,6 +2360,7 @@ isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
 	} else {
 		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
@@ -2402,6 +2482,7 @@ je_free(void *ptr) {
 		check_entry_exit_locking(tsd_tsdn(tsd));
 	}
 	LOG("core.free.exit", "");
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -2635,6 +2716,7 @@ irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
 	}
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, false);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -2652,6 +2734,7 @@ irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
 	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
 	    old_usize, old_tctx);
 
+	__A_VARIABLE = 1;
 	return p;
 }
 
@@ -2755,10 +2838,12 @@ ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
 	size_t usize;
 
 	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero)) {
+		__A_VARIABLE = 1;
 		return old_usize;
 	}
 	usize = isalloc(tsdn, ptr);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -2768,11 +2853,13 @@ ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
 	size_t usize;
 
 	if (tctx == NULL) {
+		__A_VARIABLE = 1;
 		return old_usize;
 	}
 	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
 	    zero);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -2817,11 +2904,13 @@ ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
 	}
 	if (usize == old_usize) {
 		prof_alloc_rollback(tsd, tctx, false);
+		__A_VARIABLE = 1;
 		return usize;
 	}
 	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
 	    old_tctx);
 
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -2886,6 +2975,7 @@ label_not_resized:
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.xallocx.exit", "result: %zu", usize);
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -2959,6 +3049,7 @@ je_dallocx(void *ptr, int flags) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.dallocx.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
@@ -2972,6 +3063,7 @@ inallocx(tsdn_t *tsdn, size_t size, int flags) {
 		usize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
 	}
 	check_entry_exit_locking(tsdn);
+	__A_VARIABLE = 1;
 	return usize;
 }
 
@@ -3021,6 +3113,7 @@ je_sdallocx(void *ptr, size_t size, int flags) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.sdallocx.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
@@ -3060,6 +3153,7 @@ je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctl.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3069,6 +3163,7 @@ je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.mallctl.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -3080,6 +3175,7 @@ je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctlnametomib.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3089,6 +3185,7 @@ je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
 	check_entry_exit_locking(tsd_tsdn(tsd));
 
 	LOG("core.mallctlnametomib.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -3102,6 +3199,7 @@ je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 
 	if (unlikely(malloc_init())) {
 		LOG("core.mallctlbymib.exit", "result: %d", EAGAIN);
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -3110,6 +3208,7 @@ je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
 	check_entry_exit_locking(tsd_tsdn(tsd));
 	LOG("core.mallctlbymib.exit", "result: %d", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -3125,6 +3224,7 @@ je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 	stats_print(write_cb, cbopaque, opts);
 	check_entry_exit_locking(tsdn);
 	LOG("core.malloc_stats_print.exit", "");
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
@@ -3152,6 +3252,7 @@ je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
 
 	check_entry_exit_locking(tsdn);
 	LOG("core.malloc_usable_size.exit", "result: %zu", ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -3182,6 +3283,7 @@ JEMALLOC_ATTR(constructor)
 static void
 jemalloc_constructor(void) {
 	malloc_init();
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -3321,6 +3423,7 @@ jemalloc_postfork_child(void) {
 	malloc_mutex_postfork_child(tsd_tsdn(tsd), &arenas_lock);
 	tcache_postfork_child(tsd_tsdn(tsd));
 	ctl_postfork_child(tsd_tsdn(tsd));
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
@@ -3333,5 +3436,6 @@ jemalloc_postfork_child(void) {
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
 	assert(ptr != NULL);
+	__A_VARIABLE = 1;
 	return iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);
 }
diff --git a/deps/jemalloc/src/large.c b/deps/jemalloc/src/large.c
index 27a2c67..8e1a62f 100644
--- a/deps/jemalloc/src/large.c
+++ b/deps/jemalloc/src/large.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_LARGE_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -14,6 +15,7 @@ void *
 large_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero) {
 	assert(usize == sz_s2u(usize));
 
+	__A_VARIABLE = 1;
 	return large_palloc(tsdn, arena, usize, CACHELINE, zero);
 }
 
@@ -29,6 +31,7 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 
 	ausize = sz_sa2u(usize, alignment);
 	if (unlikely(ausize == 0 || ausize > LARGE_MAXCLASS)) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -46,6 +49,7 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 	}
 	if (unlikely(arena == NULL) || (extent = arena_extent_alloc_large(tsdn,
 	    arena, usize, alignment, &is_zeroed)) == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -68,12 +72,14 @@ large_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
 	}
 
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 	return extent_addr_get(extent);
 }
 
 static void
 large_dalloc_junk_impl(void *ptr, size_t size) {
 	memset(ptr, JEMALLOC_FREE_JUNK, size);
+	__A_VARIABLE = 1;
 }
 large_dalloc_junk_t *JET_MUTABLE large_dalloc_junk = large_dalloc_junk_impl;
 
@@ -88,6 +94,7 @@ large_dalloc_maybe_junk_impl(void *ptr, size_t size) {
 			large_dalloc_junk(ptr, size);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 large_dalloc_maybe_junk_t *JET_MUTABLE large_dalloc_maybe_junk =
     large_dalloc_maybe_junk_impl;
@@ -264,8 +271,10 @@ static void *
 large_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero) {
 	if (alignment <= CACHELINE) {
+		__A_VARIABLE = 1;
 		return large_malloc(tsdn, arena, usize, zero);
 	}
+	__A_VARIABLE = 1;
 	return large_palloc(tsdn, arena, usize, alignment, zero);
 }
 
@@ -281,6 +290,7 @@ large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
 
 	/* Try to avoid moving the allocation. */
 	if (!large_ralloc_no_move(tsdn, extent, usize, usize, zero)) {
+		__A_VARIABLE = 1;
 		return extent_addr_get(extent);
 	}
 
@@ -292,12 +302,14 @@ large_ralloc(tsdn_t *tsdn, arena_t *arena, extent_t *extent, size_t usize,
 	void *ret = large_ralloc_move_helper(tsdn, arena, usize, alignment,
 	    zero);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	size_t copysize = (usize < oldusize) ? usize : oldusize;
 	memcpy(ret, extent_addr_get(extent), copysize);
 	isdalloct(tsdn, extent_addr_get(extent), oldusize, tcache, NULL, true);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -324,22 +336,26 @@ large_dalloc_prep_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent,
 		}
 	}
 	arena_extent_dalloc_large_prep(tsdn, arena, extent);
+	__A_VARIABLE = 1;
 }
 
 static void
 large_dalloc_finish_impl(tsdn_t *tsdn, arena_t *arena, extent_t *extent) {
 	extent_hooks_t *extent_hooks = EXTENT_HOOKS_INITIALIZER;
 	arena_extents_dirty_dalloc(tsdn, arena, &extent_hooks, extent);
+	__A_VARIABLE = 1;
 }
 
 void
 large_dalloc_prep_junked_locked(tsdn_t *tsdn, extent_t *extent) {
 	large_dalloc_prep_impl(tsdn, extent_arena_get(extent), extent, true);
+	__A_VARIABLE = 1;
 }
 
 void
 large_dalloc_finish(tsdn_t *tsdn, extent_t *extent) {
 	large_dalloc_finish_impl(tsdn, extent_arena_get(extent), extent);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -348,24 +364,29 @@ large_dalloc(tsdn_t *tsdn, extent_t *extent) {
 	large_dalloc_prep_impl(tsdn, arena, extent, false);
 	large_dalloc_finish_impl(tsdn, arena, extent);
 	arena_decay_tick(tsdn, arena);
+	__A_VARIABLE = 1;
 }
 
 size_t
 large_salloc(tsdn_t *tsdn, const extent_t *extent) {
+	__A_VARIABLE = 1;
 	return extent_usize_get(extent);
 }
 
 prof_tctx_t *
 large_prof_tctx_get(tsdn_t *tsdn, const extent_t *extent) {
+	__A_VARIABLE = 1;
 	return extent_prof_tctx_get(extent);
 }
 
 void
 large_prof_tctx_set(tsdn_t *tsdn, extent_t *extent, prof_tctx_t *tctx) {
 	extent_prof_tctx_set(extent, tctx);
+	__A_VARIABLE = 1;
 }
 
 void
 large_prof_tctx_reset(tsdn_t *tsdn, extent_t *extent) {
 	large_prof_tctx_set(tsdn, extent, (prof_tctx_t *)(uintptr_t)1U);
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/log.c b/deps/jemalloc/src/log.c
index 778902f..c58ca06 100644
--- a/deps/jemalloc/src/log.c
+++ b/deps/jemalloc/src/log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
 
@@ -15,6 +16,7 @@ log_var_extract_segment(const char* segment_begin) {
 	const char *end;
 	for (end = segment_begin; *end != '\0' && *end != '|'; end++) {
 	}
+	__A_VARIABLE = 1;
 	return end;
 }
 
@@ -53,6 +55,7 @@ log_var_update_state(log_var_t *log_var) {
 	 * avoid log-spew, we default to not displaying anything.
 	 */
 	if (!atomic_load_b(&log_init_done, ATOMIC_ACQUIRE)) {
+		__A_VARIABLE = 1;
 		return LOG_INITIALIZED_NOT_ENABLED;
 	}
 
@@ -64,15 +67,18 @@ log_var_update_state(log_var_t *log_var) {
 		    log_var_begin, log_var_end)) {
 			atomic_store_u(&log_var->state, LOG_ENABLED,
 			    ATOMIC_RELAXED);
+			__A_VARIABLE = 1;
 			return LOG_ENABLED;
 		}
 		if (*segment_end == '\0') {
 			/* Hit the end of the segment string with no match. */
 			atomic_store_u(&log_var->state,
 			    LOG_INITIALIZED_NOT_ENABLED, ATOMIC_RELAXED);
+			__A_VARIABLE = 1;
 			return LOG_INITIALIZED_NOT_ENABLED;
 		}
 		/* Otherwise, skip the delimiter and continue. */
 		segment_begin = segment_end + 1;
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/malloc_io.c b/deps/jemalloc/src/malloc_io.c
index 7bdc13f..4f5b961 100644
--- a/deps/jemalloc/src/malloc_io.c
+++ b/deps/jemalloc/src/malloc_io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_MALLOC_IO_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -71,6 +72,7 @@ static char *x2s(uintmax_t x, bool alt_form, bool uppercase, char *s,
 static void
 wrtmessage(void *cbopaque, const char *s) {
 	malloc_write_fd(STDERR_FILENO, s, strlen(s));
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_EXPORT void	(*je_malloc_message)(void *, const char *s);
@@ -86,6 +88,7 @@ malloc_write(const char *s) {
 	} else {
 		wrtmessage(NULL, s);
 	}
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -228,6 +231,7 @@ label_return:
 			*endptr = (char *)p;
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -270,6 +274,7 @@ u2s(uintmax_t x, unsigned base, bool uppercase, char *s, size_t *slen_p) {
 	}}
 
 	*slen_p = U2S_BUFSIZE - 1 - i;
+	__A_VARIABLE = 1;
 	return &s[i];
 }
 
@@ -298,6 +303,7 @@ d2s(intmax_t x, char sign, char *s, size_t *slen_p) {
 		break;
 	default: not_reached();
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
@@ -309,6 +315,7 @@ o2s(uintmax_t x, bool alt_form, char *s, size_t *slen_p) {
 		(*slen_p)++;
 		*s = '0';
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
@@ -320,6 +327,7 @@ x2s(uintmax_t x, bool alt_form, bool uppercase, char *s, size_t *slen_p) {
 		(*slen_p) += 2;
 		memcpy(s, uppercase ? "0X" : "0x", 2);
 	}
+	__A_VARIABLE = 1;
 	return s;
 }
 
@@ -616,6 +624,7 @@ malloc_snprintf(char *str, size_t size, const char *format, ...) {
 	ret = malloc_vsnprintf(str, size, format, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -637,6 +646,7 @@ malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
 
 	malloc_vsnprintf(buf, sizeof(buf), format, ap);
 	write_cb(cbopaque, buf);
+	__A_VARIABLE = 1;
 }
 
 /*
@@ -652,6 +662,7 @@ malloc_cprintf(void (*write_cb)(void *, const char *), void *cbopaque,
 	va_start(ap, format);
 	malloc_vcprintf(write_cb, cbopaque, format, ap);
 	va_end(ap);
+	__A_VARIABLE = 1;
 }
 
 /* Print to stderr in such a way as to avoid memory allocation. */
@@ -663,6 +674,7 @@ malloc_printf(const char *format, ...) {
 	va_start(ap, format);
 	malloc_vcprintf(NULL, NULL, format, ap);
 	va_end(ap);
+	__A_VARIABLE = 1;
 }
 
 /*
diff --git a/deps/jemalloc/src/mutex.c b/deps/jemalloc/src/mutex.c
index 30222b3..29af2b9 100644
--- a/deps/jemalloc/src/mutex.c
+++ b/deps/jemalloc/src/mutex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_MUTEX_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -32,6 +33,7 @@ JEMALLOC_EXPORT int
 pthread_create(pthread_t *__restrict thread,
     const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),
     void *__restrict arg) {
+	__A_VARIABLE = 1;
 	return pthread_create_wrapper(thread, attr, start_routine, arg);
 }
 #endif
@@ -57,6 +59,7 @@ malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
 		spin_cpu_spinwait();
 		if (!malloc_mutex_trylock_final(mutex)) {
 			data->n_spin_acquired++;
+			__A_VARIABLE = 1;
 			return;
 		}
 	} while (cnt++ < max_cnt);
@@ -64,6 +67,7 @@ malloc_mutex_lock_slow(malloc_mutex_t *mutex) {
 	if (!config_stats) {
 		/* Only spin is useful when stats is off. */
 		malloc_mutex_lock_final(mutex);
+		__A_VARIABLE = 1;
 		return;
 	}
 label_spin_done:
@@ -77,6 +81,7 @@ label_spin_done:
 	if (!malloc_mutex_trylock_final(mutex)) {
 		atomic_fetch_sub_u32(&data->n_waiting_thds, 1, ATOMIC_RELAXED);
 		data->n_spin_acquired++;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -98,6 +103,7 @@ label_spin_done:
 	if (n_thds > data->max_n_thds) {
 		data->max_n_thds = n_thds;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -106,12 +112,14 @@ mutex_prof_data_init(mutex_prof_data_t *data) {
 	nstime_init(&data->max_wait_time, 0);
 	nstime_init(&data->tot_wait_time, 0);
 	data->prev_owner = NULL;
+	__A_VARIABLE = 1;
 }
 
 void
 malloc_mutex_prof_data_reset(tsdn_t *tsdn, malloc_mutex_t *mutex) {
 	malloc_mutex_assert_owner(tsdn, mutex);
 	mutex_prof_data_init(&mutex->prof_data);
+	__A_VARIABLE = 1;
 }
 
 static int
@@ -185,11 +193,13 @@ malloc_mutex_init(malloc_mutex_t *mutex, const char *name,
 void
 malloc_mutex_prefork(tsdn_t *tsdn, malloc_mutex_t *mutex) {
 	malloc_mutex_lock(tsdn, mutex);
+	__A_VARIABLE = 1;
 }
 
 void
 malloc_mutex_postfork_parent(tsdn_t *tsdn, malloc_mutex_t *mutex) {
 	malloc_mutex_unlock(tsdn, mutex);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -206,6 +216,7 @@ malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex) {
 		}
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 bool
diff --git a/deps/jemalloc/src/mutex_pool.c b/deps/jemalloc/src/mutex_pool.c
index f24d10e..3dbcc61 100644
--- a/deps/jemalloc/src/mutex_pool.c
+++ b/deps/jemalloc/src/mutex_pool.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_MUTEX_POOL_C_
 
 #include "jemalloc/internal/jemalloc_preamble.h"
@@ -11,8 +12,10 @@ mutex_pool_init(mutex_pool_t *pool, const char *name, witness_rank_t rank) {
 	for (int i = 0; i < MUTEX_POOL_SIZE; ++i) {
 		if (malloc_mutex_init(&pool->mutexes[i], name, rank,
 		    malloc_mutex_address_ordered)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/nstime.c b/deps/jemalloc/src/nstime.c
index 71db353..4dc4c1b 100644
--- a/deps/jemalloc/src/nstime.c
+++ b/deps/jemalloc/src/nstime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
 
@@ -11,40 +12,48 @@
 void
 nstime_init(nstime_t *time, uint64_t ns) {
 	time->ns = ns;
+	__A_VARIABLE = 1;
 }
 
 void
 nstime_init2(nstime_t *time, uint64_t sec, uint64_t nsec) {
 	time->ns = sec * BILLION + nsec;
+	__A_VARIABLE = 1;
 }
 
 uint64_t
 nstime_ns(const nstime_t *time) {
+	__A_VARIABLE = 1;
 	return time->ns;
 }
 
 uint64_t
 nstime_msec(const nstime_t *time) {
+	__A_VARIABLE = 1;
 	return time->ns / MILLION;
 }
 
 uint64_t
 nstime_sec(const nstime_t *time) {
+	__A_VARIABLE = 1;
 	return time->ns / BILLION;
 }
 
 uint64_t
 nstime_nsec(const nstime_t *time) {
+	__A_VARIABLE = 1;
 	return time->ns % BILLION;
 }
 
 void
 nstime_copy(nstime_t *time, const nstime_t *source) {
 	*time = *source;
+	__A_VARIABLE = 1;
 }
 
 int
 nstime_compare(const nstime_t *a, const nstime_t *b) {
+	__A_VARIABLE = 1;
 	return (a->ns > b->ns) - (a->ns < b->ns);
 }
 
@@ -53,6 +62,7 @@ nstime_add(nstime_t *time, const nstime_t *addend) {
 	assert(UINT64_MAX - time->ns >= addend->ns);
 
 	time->ns += addend->ns;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -60,6 +70,7 @@ nstime_iadd(nstime_t *time, uint64_t addend) {
 	assert(UINT64_MAX - time->ns >= addend);
 
 	time->ns += addend;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -67,6 +78,7 @@ nstime_subtract(nstime_t *time, const nstime_t *subtrahend) {
 	assert(nstime_compare(time, subtrahend) >= 0);
 
 	time->ns -= subtrahend->ns;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -74,6 +86,7 @@ nstime_isubtract(nstime_t *time, uint64_t subtrahend) {
 	assert(time->ns >= subtrahend);
 
 	time->ns -= subtrahend;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -82,6 +95,7 @@ nstime_imultiply(nstime_t *time, uint64_t multiplier) {
 	    2))) == 0) || ((time->ns * multiplier) / multiplier == time->ns));
 
 	time->ns *= multiplier;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -89,12 +103,14 @@ nstime_idivide(nstime_t *time, uint64_t divisor) {
 	assert(divisor != 0);
 
 	time->ns /= divisor;
+	__A_VARIABLE = 1;
 }
 
 uint64_t
 nstime_divide(const nstime_t *time, const nstime_t *divisor) {
 	assert(divisor->ns != 0);
 
+	__A_VARIABLE = 1;
 	return time->ns / divisor->ns;
 }
 
@@ -109,6 +125,7 @@ nstime_get(nstime_t *time) {
 	ticks_100ns = (((uint64_t)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 
 	nstime_init(time, ticks_100ns * 100);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE)
 #  define NSTIME_MONOTONIC true
@@ -118,6 +135,7 @@ nstime_get(nstime_t *time) {
 
 	clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
 	nstime_init2(time, ts.tv_sec, ts.tv_nsec);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_CLOCK_MONOTONIC)
 #  define NSTIME_MONOTONIC true
@@ -127,12 +145,14 @@ nstime_get(nstime_t *time) {
 
 	clock_gettime(CLOCK_MONOTONIC, &ts);
 	nstime_init2(time, ts.tv_sec, ts.tv_nsec);
+	__A_VARIABLE = 1;
 }
 #elif defined(JEMALLOC_HAVE_MACH_ABSOLUTE_TIME)
 #  define NSTIME_MONOTONIC true
 static void
 nstime_get(nstime_t *time) {
 	nstime_init(time, mach_absolute_time());
+	__A_VARIABLE = 1;
 }
 #else
 #  define NSTIME_MONOTONIC false
@@ -142,11 +162,13 @@ nstime_get(nstime_t *time) {
 
 	gettimeofday(&tv, NULL);
 	nstime_init2(time, tv.tv_sec, tv.tv_usec * 1000);
+	__A_VARIABLE = 1;
 }
 #endif
 
 static bool
 nstime_monotonic_impl(void) {
+	__A_VARIABLE = 1;
 	return NSTIME_MONOTONIC;
 #undef NSTIME_MONOTONIC
 }
@@ -162,9 +184,11 @@ nstime_update_impl(nstime_t *time) {
 	/* Handle non-monotonic clocks. */
 	if (unlikely(nstime_compare(&old_time, time) > 0)) {
 		nstime_copy(time, &old_time);
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 nstime_update_t *JET_MUTABLE nstime_update = nstime_update_impl;
diff --git a/deps/jemalloc/src/pages.c b/deps/jemalloc/src/pages.c
index 2600269..3732684 100644
--- a/deps/jemalloc/src/pages.c
+++ b/deps/jemalloc/src/pages.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_PAGES_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 
@@ -92,6 +93,7 @@ os_pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
 #endif
 	assert(ret == NULL || (addr == NULL && ret != addr) || (addr != NULL &&
 	    ret == addr));
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -149,6 +151,7 @@ os_pages_unmap(void *addr, size_t size) {
 			abort();
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -156,6 +159,7 @@ pages_map_slow(size_t size, size_t alignment, bool *commit) {
 	size_t alloc_size = size + alignment - os_page;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -163,6 +167,7 @@ pages_map_slow(size_t size, size_t alignment, bool *commit) {
 	do {
 		void *pages = os_pages_map(NULL, alloc_size, alignment, commit);
 		if (pages == NULL) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		size_t leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment)
@@ -172,6 +177,7 @@ pages_map_slow(size_t size, size_t alignment, bool *commit) {
 
 	assert(ret != NULL);
 	assert(PAGE_ADDR2BASE(ret) == ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -196,15 +202,18 @@ pages_map(void *addr, size_t size, size_t alignment, bool *commit) {
 
 	void *ret = os_pages_map(addr, size, os_page, commit);
 	if (ret == NULL || ret == addr) {
+		__A_VARIABLE = 1;
 		return ret;
 	}
 	assert(addr == NULL);
 	if (ALIGNMENT_ADDR2OFFSET(ret, alignment) != 0) {
 		os_pages_unmap(ret, size);
+		__A_VARIABLE = 1;
 		return pages_map_slow(size, alignment, commit);
 	}
 
 	assert(PAGE_ADDR2BASE(ret) == ret);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -214,6 +223,7 @@ pages_unmap(void *addr, size_t size) {
 	assert(PAGE_CEILING(size) == size);
 
 	os_pages_unmap(addr, size);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -251,11 +261,13 @@ pages_commit_impl(void *addr, size_t size, bool commit) {
 
 bool
 pages_commit(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_commit_impl(addr, size, true);
 }
 
 bool
 pages_decommit(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_commit_impl(addr, size, false);
 }
 
@@ -329,11 +341,13 @@ pages_huge_impl(void *addr, size_t size, bool aligned) {
 
 bool
 pages_huge(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_huge_impl(addr, size, true);
 }
 
 static bool
 pages_huge_unaligned(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_huge_impl(addr, size, false);
 }
 
@@ -353,11 +367,13 @@ pages_nohuge_impl(void *addr, size_t size, bool aligned) {
 
 bool
 pages_nohuge(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_nohuge_impl(addr, size, true);
 }
 
 static bool
 pages_nohuge_unaligned(void *addr, size_t size) {
+	__A_VARIABLE = 1;
 	return pages_nohuge_impl(addr, size, false);
 }
 
@@ -470,6 +486,7 @@ os_overcommits_proc(void) {
 #endif
 
 	if (fd == -1) {
+		__A_VARIABLE = 1;
 		return false; /* Error. */
 	}
 
@@ -481,6 +498,7 @@ os_overcommits_proc(void) {
 #endif
 
 	if (nread < 1) {
+		__A_VARIABLE = 1;
 		return false; /* Error. */
 	}
 	/*
@@ -489,6 +507,7 @@ os_overcommits_proc(void) {
 	 * 1: Always overcommit.
 	 * 2: Never overcommit.
 	 */
+	__A_VARIABLE = 1;
 	return (buf[0] == '0' || buf[0] == '1');
 }
 #endif
@@ -496,6 +515,7 @@ os_overcommits_proc(void) {
 void
 pages_set_thp_state (void *ptr, size_t size) {
 	if (opt_thp == thp_mode_default || opt_thp == init_system_thp_mode) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	assert(opt_thp != thp_mode_not_supported &&
@@ -510,6 +530,7 @@ pages_set_thp_state (void *ptr, size_t size) {
 		    init_system_thp_mode == thp_mode_always);
 		pages_nohuge_unaligned(ptr, size);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -553,9 +574,11 @@ init_thp_state(void) {
 	} else {
 		goto label_error;
 	}
+	__A_VARIABLE = 1;
 	return;
 label_error:
 	opt_thp = init_system_thp_mode = thp_mode_not_supported;
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -566,6 +589,7 @@ pages_boot(void) {
 		if (opt_abort) {
 			abort();
 		}
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -593,6 +617,7 @@ pages_boot(void) {
 		bool committed = false;
 		void *madv_free_page = os_pages_map(NULL, PAGE, PAGE, &committed);
 		if (madv_free_page == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		assert(pages_can_purge_lazy_runtime);
@@ -602,5 +627,6 @@ pages_boot(void) {
 		os_pages_unmap(madv_free_page, PAGE);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
diff --git a/deps/jemalloc/src/prng.c b/deps/jemalloc/src/prng.c
index 83c04bf..bf2aab0 100644
--- a/deps/jemalloc/src/prng.c
+++ b/deps/jemalloc/src/prng.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_PRNG_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
diff --git a/deps/jemalloc/src/prof.c b/deps/jemalloc/src/prof.c
index 13df641..7193c26 100644
--- a/deps/jemalloc/src/prof.c
+++ b/deps/jemalloc/src/prof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_PROF_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -165,6 +166,7 @@ prof_tctx_comp(const prof_tctx_t *a, const prof_tctx_t *b) {
 			    b_tctx_uid);
 		}
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -180,6 +182,7 @@ prof_gctx_comp(const prof_gctx_t *a, const prof_gctx_t *b) {
 	if (ret == 0) {
 		ret = (a_len > b_len) - (a_len < b_len);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -199,6 +202,7 @@ prof_tdata_comp(const prof_tdata_t *a, const prof_tdata_t *b) {
 
 		ret = ((a_discrim > b_discrim) - (a_discrim < b_discrim));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -235,6 +239,7 @@ prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated) {
 			malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -251,6 +256,7 @@ prof_malloc_sample_object(tsdn_t *tsdn, const void *ptr, size_t usize,
 	}
 	tctx->prepared = false;
 	malloc_mutex_unlock(tsdn, tctx->tdata->lock);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -266,6 +272,7 @@ prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx) {
 	} else {
 		malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -274,6 +281,7 @@ bt_init(prof_bt_t *bt, void **vec) {
 
 	bt->vec = vec;
 	bt->len = 0;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -287,6 +295,7 @@ prof_enter(tsd_t *tsd, prof_tdata_t *tdata) {
 	}
 
 	malloc_mutex_lock(tsd_tsdn(tsd), &bt2gctx_mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -313,6 +322,7 @@ prof_leave(tsd_t *tsd, prof_tdata_t *tdata) {
 			prof_gdump(tsd_tsdn(tsd));
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 #ifdef JEMALLOC_PROF_LIBUNWIND
@@ -326,15 +336,18 @@ prof_backtrace(prof_bt_t *bt) {
 
 	nframes = unw_backtrace(bt->vec, PROF_BT_MAX);
 	if (nframes <= 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	bt->len = nframes;
+	__A_VARIABLE = 1;
 }
 #elif (defined(JEMALLOC_PROF_LIBGCC))
 static _Unwind_Reason_Code
 prof_unwind_init_callback(struct _Unwind_Context *context, void *arg) {
 	cassert(config_prof);
 
+	__A_VARIABLE = 1;
 	return _URC_NO_REASON;
 }
 
@@ -347,14 +360,17 @@ prof_unwind_callback(struct _Unwind_Context *context, void *arg) {
 
 	ip = (void *)_Unwind_GetIP(context);
 	if (ip == NULL) {
+		__A_VARIABLE = 1;
 		return _URC_END_OF_STACK;
 	}
 	data->bt->vec[data->bt->len] = ip;
 	data->bt->len++;
 	if (data->bt->len == data->max) {
+		__A_VARIABLE = 1;
 		return _URC_END_OF_STACK;
 	}
 
+	__A_VARIABLE = 1;
 	return _URC_NO_REASON;
 }
 
@@ -365,6 +381,7 @@ prof_backtrace(prof_bt_t *bt) {
 	cassert(config_prof);
 
 	_Unwind_Backtrace(prof_unwind_callback, &data);
+	__A_VARIABLE = 1;
 }
 #elif (defined(JEMALLOC_PROF_GCC))
 void
@@ -534,6 +551,7 @@ void
 prof_backtrace(prof_bt_t *bt) {
 	cassert(config_prof);
 	not_reached();
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -541,11 +559,13 @@ static malloc_mutex_t *
 prof_gctx_mutex_choose(void) {
 	unsigned ngctxs = atomic_fetch_add_u(&cum_gctxs, 1, ATOMIC_RELAXED);
 
+	__A_VARIABLE = 1;
 	return &gctx_locks[(ngctxs - 1) % PROF_NCTX_LOCKS];
 }
 
 static malloc_mutex_t *
 prof_tdata_mutex_choose(uint64_t thr_uid) {
+	__A_VARIABLE = 1;
 	return &tdata_locks[thr_uid % PROF_NTDATA_LOCKS];
 }
 
@@ -559,6 +579,7 @@ prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt) {
 	    sz_size2index(size), false, NULL, true, arena_get(TSDN_NULL, 0, true),
 	    true);
 	if (gctx == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	gctx->lock = prof_gctx_mutex_choose();
@@ -572,6 +593,7 @@ prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt) {
 	memcpy(gctx->vec, bt->vec, bt->len * sizeof(void *));
 	gctx->bt.vec = gctx->vec;
 	gctx->bt.len = bt->len;
+	__A_VARIABLE = 1;
 	return gctx;
 }
 
@@ -608,6 +630,7 @@ prof_gctx_try_destroy(tsd_t *tsd, prof_tdata_t *tdata_self, prof_gctx_t *gctx,
 		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 		prof_leave(tsd, tdata_self);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -615,28 +638,36 @@ prof_tctx_should_destroy(tsdn_t *tsdn, prof_tctx_t *tctx) {
 	malloc_mutex_assert_owner(tsdn, tctx->tdata->lock);
 
 	if (opt_prof_accum) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (tctx->cnts.curobjs != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (tctx->prepared) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static bool
 prof_gctx_should_destroy(prof_gctx_t *gctx) {
 	if (opt_prof_accum) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (!tctx_tree_empty(&gctx->tctxs)) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (gctx->nlimbo != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -714,6 +745,7 @@ prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx) {
 	if (destroy_tctx) {
 		idalloctm(tsd_tsdn(tsd), tctx, NULL, NULL, true, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -794,6 +826,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -814,6 +847,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 		 */
 		if (prof_lookup_global(tsd, bt, tdata, &btkey, &gctx,
 		    &new_gctx)) {
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 
@@ -825,6 +859,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 			if (new_gctx) {
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 			}
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		ret.p->tdata = tdata;
@@ -843,6 +878,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 			}
 			idalloctm(tsd_tsdn(tsd), ret.v, NULL, NULL, true, true);
+			__A_VARIABLE = 1;
 			return NULL;
 		}
 		malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
@@ -852,6 +888,7 @@ prof_lookup(tsd_t *tsd, prof_bt_t *bt) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 	}
 
+	__A_VARIABLE = 1;
 	return ret.p;
 }
 
@@ -917,6 +954,7 @@ prof_tdata_count_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 
 	(*tdata_count)++;
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -931,6 +969,7 @@ prof_tdata_count(void) {
 	    (void *)&tdata_count);
 	malloc_mutex_unlock(tsdn, &tdatas_mtx);
 
+	__A_VARIABLE = 1;
 	return tdata_count;
 }
 
@@ -943,6 +982,7 @@ prof_bt_count(void) {
 	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
@@ -950,6 +990,7 @@ prof_bt_count(void) {
 	bt_count = ckh_count(&bt2gctx);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &bt2gctx_mtx);
 
+	__A_VARIABLE = 1;
 	return bt_count;
 }
 #endif
@@ -967,6 +1008,7 @@ prof_dump_open_impl(bool propagate_err, const char *filename) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 prof_dump_open_t *JET_MUTABLE prof_dump_open = prof_dump_open_impl;
@@ -991,6 +1033,7 @@ prof_dump_flush(bool propagate_err) {
 	}
 	prof_dump_buf_end = 0;
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1003,6 +1046,7 @@ prof_dump_close(bool propagate_err) {
 	close(prof_dump_fd);
 	prof_dump_fd = -1;
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1018,6 +1062,7 @@ prof_dump_write(bool propagate_err, const char *s) {
 		/* Flush the buffer if it is full. */
 		if (prof_dump_buf_end == PROF_DUMP_BUFSIZE) {
 			if (prof_dump_flush(propagate_err) && propagate_err) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -1034,6 +1079,7 @@ prof_dump_write(bool propagate_err, const char *s) {
 		i += n;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1049,6 +1095,7 @@ prof_dump_printf(bool propagate_err, const char *format, ...) {
 	va_end(ap);
 	ret = prof_dump_write(propagate_err, buf);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1061,6 +1108,7 @@ prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata) {
 	switch (tctx->state) {
 	case prof_tctx_state_initializing:
 		malloc_mutex_unlock(tsdn, tctx->gctx->lock);
+		__A_VARIABLE = 1;
 		return;
 	case prof_tctx_state_nominal:
 		tctx->state = prof_tctx_state_dumping;
@@ -1081,6 +1129,7 @@ prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata) {
 	case prof_tctx_state_purgatory:
 		not_reached();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1093,6 +1142,7 @@ prof_tctx_merge_gctx(tsdn_t *tsdn, prof_tctx_t *tctx, prof_gctx_t *gctx) {
 		gctx->cnt_summed.accumobjs += tctx->dump_cnts.accumobjs;
 		gctx->cnt_summed.accumbytes += tctx->dump_cnts.accumbytes;
 	}
+	__A_VARIABLE = 1;
 }
 
 static prof_tctx_t *
@@ -1113,6 +1163,7 @@ prof_tctx_merge_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
 		not_reached();
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1140,12 +1191,14 @@ prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *opaque) {
 		    "%"FMTu64"]\n", tctx->thr_uid, tctx->dump_cnts.curobjs,
 		    tctx->dump_cnts.curbytes, tctx->dump_cnts.accumobjs,
 		    tctx->dump_cnts.accumbytes)) {
+			__A_VARIABLE = 1;
 			return tctx;
 		}
 		break;
 	default:
 		not_reached();
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1172,6 +1225,7 @@ prof_tctx_finish_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg) {
 
 	ret = NULL;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1192,6 +1246,7 @@ prof_dump_gctx_prep(tsdn_t *tsdn, prof_gctx_t *gctx, prof_gctx_tree_t *gctxs) {
 	memset(&gctx->cnt_summed, 0, sizeof(prof_cnt_t));
 
 	malloc_mutex_unlock(tsdn, gctx->lock);
+	__A_VARIABLE = 1;
 }
 
 struct prof_gctx_merge_iter_arg_s {
@@ -1212,6 +1267,7 @@ prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
 	}
 	malloc_mutex_unlock(arg->tsdn, gctx->lock);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1259,6 +1315,7 @@ prof_gctx_finish(tsd_t *tsd, prof_gctx_tree_t *gctxs) {
 			malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 struct prof_tdata_merge_iter_arg_s {
@@ -1298,6 +1355,7 @@ prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 	}
 	malloc_mutex_unlock(arg->tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1307,6 +1365,7 @@ prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 	bool propagate_err = *(bool *)arg;
 
 	if (!tdata->dumping) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1317,8 +1376,10 @@ prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
 	    tdata->cnt_summed.accumbytes,
 	    (tdata->thread_name != NULL) ? " " : "",
 	    (tdata->thread_name != NULL) ? tdata->thread_name : "")) {
+		__A_VARIABLE = 1;
 		return tdata;
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -1332,6 +1393,7 @@ prof_dump_header_impl(tsdn_t *tsdn, bool propagate_err,
 	    "  t*: %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]\n",
 	    ((uint64_t)1U << lg_prof_sample), cnt_all->curobjs,
 	    cnt_all->curbytes, cnt_all->accumobjs, cnt_all->accumbytes)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1339,6 +1401,7 @@ prof_dump_header_impl(tsdn_t *tsdn, bool propagate_err,
 	ret = (tdata_tree_iter(&tdatas, NULL, prof_tdata_dump_iter,
 	    (void *)&propagate_err) != NULL);
 	malloc_mutex_unlock(tsdn, &tdatas_mtx);
+	__A_VARIABLE = 1;
 	return ret;
 }
 prof_dump_header_t *JET_MUTABLE prof_dump_header = prof_dump_header_impl;
@@ -1395,6 +1458,7 @@ prof_dump_gctx(tsdn_t *tsdn, bool propagate_err, prof_gctx_t *gctx,
 
 	ret = false;
 label_return:
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1419,6 +1483,7 @@ prof_open_maps(const char *format, ...) {
 	}
 #endif
 
+	__A_VARIABLE = 1;
 	return mfd;
 }
 #endif
@@ -1485,6 +1550,7 @@ label_return:
 	if (mfd != -1) {
 		close(mfd);
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1521,6 +1587,7 @@ prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_ngctx,
 		    filename);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 struct prof_gctx_dump_iter_arg_s {
@@ -1545,6 +1612,7 @@ prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque) {
 	ret = NULL;
 label_return:
 	malloc_mutex_unlock(arg->tsdn, gctx->lock);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -1588,6 +1656,7 @@ prof_dump_prep(tsd_t *tsd, prof_tdata_t *tdata,
 	    (void *)prof_gctx_merge_iter_arg);
 
 	prof_leave(tsd, tdata);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1599,6 +1668,7 @@ prof_dump_file(tsd_t *tsd, bool propagate_err, const char *filename,
     prof_gctx_tree_t *gctxs) {
 	/* Create dump file. */
 	if ((prof_dump_fd = prof_dump_open(propagate_err, filename)) == -1) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1622,12 +1692,15 @@ prof_dump_file(tsd_t *tsd, bool propagate_err, const char *filename,
 	}
 
 	if (prof_dump_close(propagate_err)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 label_write_error:
 	prof_dump_close(propagate_err);
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -1639,6 +1712,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 
 	prof_tdata_t * tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1660,6 +1734,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 	post_reentrancy(tsd);
 
 	if (err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -1667,6 +1742,7 @@ prof_dump(tsd_t *tsd, bool propagate_err, const char *filename,
 		prof_leakcheck(&prof_tdata_merge_iter_arg.cnt_all,
 		    prof_gctx_merge_iter_arg.leak_ngctx, filename);
 	}
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -1695,6 +1771,7 @@ prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
 		if (accumbytes != NULL) {
 			*accumbytes = 0;
 		}
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1714,6 +1791,7 @@ prof_cnt_all(uint64_t *curobjs, uint64_t *curbytes, uint64_t *accumobjs,
 	if (accumbytes != NULL) {
 		*accumbytes = prof_tdata_merge_iter_arg.cnt_all.accumbytes;
 	}
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -1735,6 +1813,7 @@ prof_dump_filename(char *filename, char v, uint64_t vseq) {
 		    opt_prof_prefix, prof_getpid(), prof_dump_seq, v);
 	}
 	prof_dump_seq++;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1747,6 +1826,7 @@ prof_fdump(void) {
 	assert(opt_prof_prefix[0] != '\0');
 
 	if (!prof_booted) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsd_fetch();
@@ -1756,6 +1836,7 @@ prof_fdump(void) {
 	prof_dump_filename(filename, 'f', VSEQ_INVALID);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 	prof_dump(tsd, false, filename, opt_prof_leak);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -1782,19 +1863,23 @@ prof_idump(tsdn_t *tsdn) {
 	cassert(config_prof);
 
 	if (!prof_booted || tsdn_null(tsdn) || !prof_active_get_unlocked()) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsdn_tsd(tsdn);
 	if (tsd_reentrancy_level_get(tsd) > 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tdata->enq) {
 		tdata->enq_idump = true;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1806,6 +1891,7 @@ prof_idump(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -1814,12 +1900,14 @@ prof_mdump(tsd_t *tsd, const char *filename) {
 	assert(tsd_reentrancy_level_get(tsd) == 0);
 
 	if (!opt_prof || !prof_booted) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	char filename_buf[DUMP_FILENAME_BUFSIZE];
 	if (filename == NULL) {
 		/* No filename specified, so automatically generate one. */
 		if (opt_prof_prefix[0] == '\0') {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
@@ -1828,6 +1916,7 @@ prof_mdump(tsd_t *tsd, const char *filename) {
 		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		filename = filename_buf;
 	}
+	__A_VARIABLE = 1;
 	return prof_dump(tsd, true, filename, false);
 }
 
@@ -1839,19 +1928,23 @@ prof_gdump(tsdn_t *tsdn) {
 	cassert(config_prof);
 
 	if (!prof_booted || tsdn_null(tsdn) || !prof_active_get_unlocked()) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	tsd = tsdn_tsd(tsdn);
 	if (tsd_reentrancy_level_get(tsd) > 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (tdata->enq) {
 		tdata->enq_gdump = true;
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -1863,6 +1956,7 @@ prof_gdump(tsdn_t *tsdn) {
 		malloc_mutex_unlock(tsdn, &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1872,6 +1966,7 @@ prof_bt_hash(const void *key, size_t r_hash[2]) {
 	cassert(config_prof);
 
 	hash(bt->vec, bt->len * sizeof(void *), 0x94122f33U, r_hash);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -1882,8 +1977,10 @@ prof_bt_keycomp(const void *k1, const void *k2) {
 	cassert(config_prof);
 
 	if (bt1->len != bt2->len) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return (memcmp(bt1->vec, bt2->vec, bt1->len * sizeof(void *)) == 0);
 }
 
@@ -1896,6 +1993,7 @@ prof_thr_uid_alloc(tsdn_t *tsdn) {
 	next_thr_uid++;
 	malloc_mutex_unlock(tsdn, &next_thr_uid_mtx);
 
+	__A_VARIABLE = 1;
 	return thr_uid;
 }
 
@@ -1911,6 +2009,7 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	    sz_size2index(sizeof(prof_tdata_t)), false, NULL, true,
 	    arena_get(TSDN_NULL, 0, true), true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1925,6 +2024,7 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	if (ckh_new(tsd, &tdata->bt2tctx, PROF_CKH_MINITEMS, prof_bt_hash,
 	    prof_bt_keycomp)) {
 		idalloctm(tsd_tsdn(tsd), tdata, NULL, NULL, true, true);
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -1942,11 +2042,13 @@ prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
 	tdata_tree_insert(&tdatas, tdata);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 
+	__A_VARIABLE = 1;
 	return tdata;
 }
 
 prof_tdata_t *
 prof_tdata_init(tsd_t *tsd) {
+	__A_VARIABLE = 1;
 	return prof_tdata_init_impl(tsd, prof_thr_uid_alloc(tsd_tsdn(tsd)), 0,
 	    NULL, prof_thread_active_init_get(tsd_tsdn(tsd)));
 }
@@ -1954,11 +2056,14 @@ prof_tdata_init(tsd_t *tsd) {
 static bool
 prof_tdata_should_destroy_unlocked(prof_tdata_t *tdata, bool even_if_attached) {
 	if (tdata->attached && !even_if_attached) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	if (ckh_count(&tdata->bt2tctx) != 0) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -1967,6 +2072,7 @@ prof_tdata_should_destroy(tsdn_t *tsdn, prof_tdata_t *tdata,
     bool even_if_attached) {
 	malloc_mutex_assert_owner(tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return prof_tdata_should_destroy_unlocked(tdata, even_if_attached);
 }
 
@@ -1985,6 +2091,7 @@ prof_tdata_destroy_locked(tsd_t *tsd, prof_tdata_t *tdata,
 	}
 	ckh_delete(tsd, &tdata->bt2tctx);
 	idalloctm(tsd_tsdn(tsd), tdata, NULL, NULL, true, true);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1992,6 +2099,7 @@ prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata, bool even_if_attached) {
 	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
 	prof_tdata_destroy_locked(tsd, tdata, even_if_attached);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -2017,6 +2125,7 @@ prof_tdata_detach(tsd_t *tsd, prof_tdata_t *tdata) {
 	if (destroy_tdata) {
 		prof_tdata_destroy(tsd, tdata, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 prof_tdata_t *
@@ -2028,6 +2137,7 @@ prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata) {
 	bool active = tdata->active;
 
 	prof_tdata_detach(tsd, tdata);
+	__A_VARIABLE = 1;
 	return prof_tdata_init_impl(tsd, thr_uid, thr_discrim, thread_name,
 	    active);
 }
@@ -2046,6 +2156,7 @@ prof_tdata_expire(tsdn_t *tsdn, prof_tdata_t *tdata) {
 	}
 	malloc_mutex_unlock(tsdn, tdata->lock);
 
+	__A_VARIABLE = 1;
 	return destroy_tdata;
 }
 
@@ -2054,6 +2165,7 @@ prof_tdata_reset_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
     void *arg) {
 	tsdn_t *tsdn = (tsdn_t *)arg;
 
+	__A_VARIABLE = 1;
 	return (prof_tdata_expire(tsdn, tdata) ? tdata : NULL);
 }
 
@@ -2082,6 +2194,7 @@ prof_reset(tsd_t *tsd, size_t lg_sample) {
 
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_mtx);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2089,6 +2202,7 @@ prof_tdata_cleanup(tsd_t *tsd) {
 	prof_tdata_t *tdata;
 
 	if (!config_prof) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -2096,6 +2210,7 @@ prof_tdata_cleanup(tsd_t *tsd) {
 	if (tdata != NULL) {
 		prof_tdata_detach(tsd, tdata);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -2105,6 +2220,7 @@ prof_active_get(tsdn_t *tsdn) {
 	malloc_mutex_lock(tsdn, &prof_active_mtx);
 	prof_active_current = prof_active;
 	malloc_mutex_unlock(tsdn, &prof_active_mtx);
+	__A_VARIABLE = 1;
 	return prof_active_current;
 }
 
@@ -2116,6 +2232,7 @@ prof_active_set(tsdn_t *tsdn, bool active) {
 	prof_active_old = prof_active;
 	prof_active = active;
 	malloc_mutex_unlock(tsdn, &prof_active_mtx);
+	__A_VARIABLE = 1;
 	return prof_active_old;
 }
 
@@ -2125,8 +2242,10 @@ prof_thread_name_get(tsd_t *tsd) {
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return "";
 	}
+	__A_VARIABLE = 1;
 	return (tdata->thread_name != NULL ? tdata->thread_name : "");
 }
 
@@ -2136,20 +2255,24 @@ prof_thread_name_alloc(tsdn_t *tsdn, const char *thread_name) {
 	size_t size;
 
 	if (thread_name == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
 	size = strlen(thread_name) + 1;
 	if (size == 1) {
+		__A_VARIABLE = 1;
 		return "";
 	}
 
 	ret = iallocztm(tsdn, size, sz_size2index(size), false, NULL, true,
 	    arena_get(TSDN_NULL, 0, true), true);
 	if (ret == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	memcpy(ret, thread_name, size);
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -2161,22 +2284,26 @@ prof_thread_name_set(tsd_t *tsd, const char *thread_name) {
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
 	/* Validate input. */
 	if (thread_name == NULL) {
+		__A_VARIABLE = 1;
 		return EFAULT;
 	}
 	for (i = 0; thread_name[i] != '\0'; i++) {
 		char c = thread_name[i];
 		if (!isgraph(c) && !isblank(c)) {
+			__A_VARIABLE = 1;
 			return EFAULT;
 		}
 	}
 
 	s = prof_thread_name_alloc(tsd_tsdn(tsd), thread_name);
 	if (s == NULL) {
+		__A_VARIABLE = 1;
 		return EAGAIN;
 	}
 
@@ -2188,6 +2315,7 @@ prof_thread_name_set(tsd_t *tsd, const char *thread_name) {
 	if (strlen(s) > 0) {
 		tdata->thread_name = s;
 	}
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -2197,8 +2325,10 @@ prof_thread_active_get(tsd_t *tsd) {
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return false;
 	}
+	__A_VARIABLE = 1;
 	return tdata->active;
 }
 
@@ -2208,9 +2338,11 @@ prof_thread_active_set(tsd_t *tsd, bool active) {
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	tdata->active = active;
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -2221,6 +2353,7 @@ prof_thread_active_init_get(tsdn_t *tsdn) {
 	malloc_mutex_lock(tsdn, &prof_thread_active_init_mtx);
 	active_init = prof_thread_active_init;
 	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
+	__A_VARIABLE = 1;
 	return active_init;
 }
 
@@ -2232,6 +2365,7 @@ prof_thread_active_init_set(tsdn_t *tsdn, bool active_init) {
 	active_init_old = prof_thread_active_init;
 	prof_thread_active_init = active_init;
 	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
+	__A_VARIABLE = 1;
 	return active_init_old;
 }
 
@@ -2242,6 +2376,7 @@ prof_gdump_get(tsdn_t *tsdn) {
 	malloc_mutex_lock(tsdn, &prof_gdump_mtx);
 	prof_gdump_current = prof_gdump_val;
 	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
+	__A_VARIABLE = 1;
 	return prof_gdump_current;
 }
 
@@ -2253,6 +2388,7 @@ prof_gdump_set(tsdn_t *tsdn, bool gdump) {
 	prof_gdump_old = prof_gdump_val;
 	prof_gdump_val = gdump;
 	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
+	__A_VARIABLE = 1;
 	return prof_gdump_old;
 }
 
@@ -2262,6 +2398,7 @@ prof_boot0(void) {
 
 	memcpy(opt_prof_prefix, PROF_PREFIX_DEFAULT,
 	    sizeof(PROF_PREFIX_DEFAULT));
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2286,6 +2423,7 @@ prof_boot1(void) {
 			    opt_lg_prof_interval);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -2300,12 +2438,14 @@ prof_boot2(tsd_t *tsd) {
 		prof_active = opt_prof_active;
 		if (malloc_mutex_init(&prof_active_mtx, "prof_active",
 		    WITNESS_RANK_PROF_ACTIVE, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		prof_gdump_val = opt_prof_gdump;
 		if (malloc_mutex_init(&prof_gdump_mtx, "prof_gdump",
 		    WITNESS_RANK_PROF_GDUMP, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
@@ -2314,36 +2454,43 @@ prof_boot2(tsd_t *tsd) {
 		    "prof_thread_active_init",
 		    WITNESS_RANK_PROF_THREAD_ACTIVE_INIT,
 		    malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		if (ckh_new(tsd, &bt2gctx, PROF_CKH_MINITEMS, prof_bt_hash,
 		    prof_bt_keycomp)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		if (malloc_mutex_init(&bt2gctx_mtx, "prof_bt2gctx",
 		    WITNESS_RANK_PROF_BT2GCTX, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		tdata_tree_new(&tdatas);
 		if (malloc_mutex_init(&tdatas_mtx, "prof_tdatas",
 		    WITNESS_RANK_PROF_TDATAS, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		next_thr_uid = 0;
 		if (malloc_mutex_init(&next_thr_uid_mtx, "prof_next_thr_uid",
 		    WITNESS_RANK_PROF_NEXT_THR_UID, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
 		if (malloc_mutex_init(&prof_dump_seq_mtx, "prof_dump_seq",
 		    WITNESS_RANK_PROF_DUMP_SEQ, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		if (malloc_mutex_init(&prof_dump_mtx, "prof_dump",
 		    WITNESS_RANK_PROF_DUMP, malloc_mutex_rank_exclusive)) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 
@@ -2359,12 +2506,14 @@ prof_boot2(tsd_t *tsd) {
 		    b0get(), PROF_NCTX_LOCKS * sizeof(malloc_mutex_t),
 		    CACHELINE);
 		if (gctx_locks == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		for (i = 0; i < PROF_NCTX_LOCKS; i++) {
 			if (malloc_mutex_init(&gctx_locks[i], "prof_gctx",
 			    WITNESS_RANK_PROF_GCTX,
 			    malloc_mutex_rank_exclusive)) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -2373,12 +2522,14 @@ prof_boot2(tsd_t *tsd) {
 		    b0get(), PROF_NTDATA_LOCKS * sizeof(malloc_mutex_t),
 		    CACHELINE);
 		if (tdata_locks == NULL) {
+			__A_VARIABLE = 1;
 			return true;
 		}
 		for (i = 0; i < PROF_NTDATA_LOCKS; i++) {
 			if (malloc_mutex_init(&tdata_locks[i], "prof_tdata",
 			    WITNESS_RANK_PROF_TDATA,
 			    malloc_mutex_rank_exclusive)) {
+				__A_VARIABLE = 1;
 				return true;
 			}
 		}
@@ -2394,6 +2545,7 @@ prof_boot2(tsd_t *tsd) {
 
 	prof_booted = true;
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -2412,6 +2564,7 @@ prof_prefork0(tsdn_t *tsdn) {
 			malloc_mutex_prefork(tsdn, &gctx_locks[i]);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2423,6 +2576,7 @@ prof_prefork1(tsdn_t *tsdn) {
 		malloc_mutex_prefork(tsdn, &next_thr_uid_mtx);
 		malloc_mutex_prefork(tsdn, &prof_thread_active_init_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2446,6 +2600,7 @@ prof_postfork_parent(tsdn_t *tsdn) {
 		malloc_mutex_postfork_parent(tsdn, &bt2gctx_mtx);
 		malloc_mutex_postfork_parent(tsdn, &prof_dump_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -2468,6 +2623,7 @@ prof_postfork_child(tsdn_t *tsdn) {
 		malloc_mutex_postfork_child(tsdn, &bt2gctx_mtx);
 		malloc_mutex_postfork_child(tsdn, &prof_dump_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 /******************************************************************************/
diff --git a/deps/jemalloc/src/rtree.c b/deps/jemalloc/src/rtree.c
index 53702cf..799fce0 100644
--- a/deps/jemalloc/src/rtree.c
+++ b/deps/jemalloc/src/rtree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_RTREE_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
diff --git a/deps/jemalloc/src/stats.c b/deps/jemalloc/src/stats.c
index 08b9507..5ab5ef1 100644
--- a/deps/jemalloc/src/stats.c
+++ b/deps/jemalloc/src/stats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_STATS_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -57,6 +58,7 @@ static bool
 get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
 	if (divisor == 0 || dividend > divisor) {
 		/* The rate is not supposed to be greater than 1. */
+		__A_VARIABLE = 1;
 		return true;
 	}
 	if (dividend > 0) {
@@ -74,6 +76,7 @@ get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
 		malloc_snprintf(str, 6, "1");
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -82,6 +85,7 @@ static void
 gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
     const char *mutex, const char *counter) {
 	malloc_snprintf(str, buf_len, "stats.%s.%s.%s", prefix, mutex, counter);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -116,6 +120,7 @@ mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
 #undef OP
 #undef WIDTH_uint32_t
 #undef WIDTH_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -139,6 +144,7 @@ mutex_stats_read_global(const char *name, emitter_col_t *col_name,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -164,6 +170,7 @@ mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -186,6 +193,7 @@ mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 /* "row" can be NULL to avoid emitting in table mode. */
@@ -213,6 +221,7 @@ mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
 #undef OP
 #undef EMITTER_TYPE_uint32_t
 #undef EMITTER_TYPE_uint64_t
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -405,6 +414,7 @@ stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i) {
 	if (in_gap) {
 		emitter_table_printf(emitter, "                     ---\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -492,6 +502,7 @@ stats_arena_lextents_print(emitter_t *emitter, unsigned i) {
 	if (in_gap) {
 		emitter_table_printf(emitter, "                     ---\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -517,6 +528,7 @@ stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind) {
 		emitter_json_dict_end(emitter); /* Close the mutex dict. */
 	}
 	emitter_json_dict_end(emitter); /* End "mutexes". */
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -820,6 +832,7 @@ stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
 	if (large) {
 		stats_arena_lextents_print(emitter, i);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1059,6 +1072,7 @@ stats_general_print(emitter_t *emitter) {
 	}
 
 	emitter_json_dict_end(emitter); /* Close "arenas" */
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -1219,6 +1233,7 @@ stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
 		}
 		emitter_json_dict_end(emitter); /* Close "stats.arenas". */
 	}
+	__A_VARIABLE = 1;
 }
 
 void
diff --git a/deps/jemalloc/src/sz.c b/deps/jemalloc/src/sz.c
index 9de77e4..d642cf0 100644
--- a/deps/jemalloc/src/sz.c
+++ b/deps/jemalloc/src/sz.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/sz.h"
 
diff --git a/deps/jemalloc/src/tcache.c b/deps/jemalloc/src/tcache.c
index a769a6b..4c195e8 100644
--- a/deps/jemalloc/src/tcache.c
+++ b/deps/jemalloc/src/tcache.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_TCACHE_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -33,6 +34,7 @@ static malloc_mutex_t	tcaches_mtx;
 
 size_t
 tcache_salloc(tsdn_t *tsdn, const void *ptr) {
+	__A_VARIABLE = 1;
 	return arena_salloc(tsdn, ptr);
 }
 
@@ -82,6 +84,7 @@ tcache_event_hard(tsd_t *tsd, tcache_t *tcache) {
 	if (tcache->next_gc_bin == nhbins) {
 		tcache->next_gc_bin = 0;
 	}
+	__A_VARIABLE = 1;
 }
 
 void *
@@ -97,6 +100,7 @@ tcache_alloc_small_hard(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
 	}
 	ret = cache_bin_alloc_easy(tbin, tcache_success);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -183,6 +187,7 @@ tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, cache_bin_t *tbin,
 	if (tbin->ncached < tbin->low_water) {
 		tbin->low_water = tbin->ncached;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -281,6 +286,7 @@ tcache_bin_flush_large(tsd_t *tsd, cache_bin_t *tbin, szind_t binind,
 	if (tbin->ncached < tbin->low_water) {
 		tbin->low_water = tbin->ncached;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -302,6 +308,7 @@ tcache_arena_associate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
 
 		malloc_mutex_unlock(tsdn, &arena->tcache_ql_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -329,12 +336,14 @@ tcache_arena_dissociate(tsdn_t *tsdn, tcache_t *tcache) {
 		malloc_mutex_unlock(tsdn, &arena->tcache_ql_mtx);
 	}
 	tcache->arena = NULL;
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_arena_reassociate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
 	tcache_arena_dissociate(tsdn, tcache);
 	tcache_arena_associate(tsdn, tcache, arena);
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -348,6 +357,7 @@ tsd_tcache_enabled_data_init(tsd_t *tsd) {
 		tsd_tcache_data_init(tsd);
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -383,6 +393,7 @@ tcache_init(tsd_t *tsd, tcache_t *tcache, void *avail_stack) {
 		    (void **)((uintptr_t)avail_stack + (uintptr_t)stack_offset);
 	}
 	assert(stack_offset == stack_nelms * sizeof(void *));
+	__A_VARIABLE = 1;
 }
 
 /* Initialize auto tcache (embedded in TSD). */
@@ -397,6 +408,7 @@ tsd_tcache_data_init(tsd_t *tsd) {
 	void *avail_array = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true,
 	    NULL, true, arena_get(TSDN_NULL, 0, true));
 	if (avail_array == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -424,6 +436,7 @@ tsd_tcache_data_init(tsd_t *tsd) {
 	}
 	assert(arena == tcache->arena);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -444,6 +457,7 @@ tcache_create_explicit(tsd_t *tsd) {
 	tcache = ipallocztm(tsd_tsdn(tsd), size, CACHELINE, true, NULL, true,
 	    arena_get(TSDN_NULL, 0, true));
 	if (tcache == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 
@@ -451,6 +465,7 @@ tcache_create_explicit(tsd_t *tsd) {
 	    (void *)((uintptr_t)tcache + (uintptr_t)stack_offset));
 	tcache_arena_associate(tsd_tsdn(tsd), tcache, arena_ichoose(tsd, NULL));
 
+	__A_VARIABLE = 1;
 	return tcache;
 }
 
@@ -480,12 +495,14 @@ tcache_flush_cache(tsd_t *tsd, tcache_t *tcache) {
 	    tcache->prof_accumbytes)) {
 		prof_idump(tsd_tsdn(tsd));
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 tcache_flush(tsd_t *tsd) {
 	assert(tcache_available(tsd));
 	tcache_flush_cache(tsd, tsd_tcachep_get(tsd));
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -503,6 +520,7 @@ tcache_destroy(tsd_t *tsd, tcache_t *tcache, bool tsd_tcache) {
 		/* Release both the tcache struct and avail array. */
 		idalloctm(tsd_tsdn(tsd), tcache, NULL, NULL, true, true);
 	}
+	__A_VARIABLE = 1;
 }
 
 /* For auto tcache (embedded in TSD) only. */
@@ -514,6 +532,7 @@ tcache_cleanup(tsd_t *tsd) {
 		if (config_debug) {
 			assert(tcache_small_bin_get(tcache, 0)->avail == NULL);
 		}
+		__A_VARIABLE = 1;
 		return;
 	}
 	assert(tsd_tcache_enabled_get(tsd));
@@ -523,6 +542,7 @@ tcache_cleanup(tsd_t *tsd) {
 	if (config_debug) {
 		tcache_small_bin_get(tcache, 0)->avail = NULL;
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -547,6 +567,7 @@ tcache_stats_merge(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena) {
 		    tbin->tstats.nrequests);
 		tbin->tstats.nrequests = 0;
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -572,6 +593,7 @@ tcaches_create_prep(tsd_t *tsd) {
 	err = false;
 label_return:
 	malloc_mutex_unlock(tsd_tsdn(tsd), &tcaches_mtx);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -610,6 +632,7 @@ tcaches_create(tsd_t *tsd, unsigned *r_ind) {
 	err = false;
 label_return:
 	witness_assert_depth(tsdn_witness_tsdp_get(tsd_tsdn(tsd)), 0);
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -618,10 +641,12 @@ tcaches_elm_remove(tsd_t *tsd, tcaches_t *elm) {
 	malloc_mutex_assert_owner(tsd_tsdn(tsd), &tcaches_mtx);
 
 	if (elm->tcache == NULL) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	tcache_t *tcache = elm->tcache;
 	elm->tcache = NULL;
+	__A_VARIABLE = 1;
 	return tcache;
 }
 
@@ -633,6 +658,7 @@ tcaches_flush(tsd_t *tsd, unsigned ind) {
 	if (tcache != NULL) {
 		tcache_destroy(tsd, tcache, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -646,6 +672,7 @@ tcaches_destroy(tsd_t *tsd, unsigned ind) {
 	if (tcache != NULL) {
 		tcache_destroy(tsd, tcache, false);
 	}
+	__A_VARIABLE = 1;
 }
 
 bool
@@ -660,6 +687,7 @@ tcache_boot(tsdn_t *tsdn) {
 
 	if (malloc_mutex_init(&tcaches_mtx, "tcaches", WITNESS_RANK_TCACHES,
 	    malloc_mutex_rank_exclusive)) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 
@@ -669,6 +697,7 @@ tcache_boot(tsdn_t *tsdn) {
 	tcache_bin_info = (cache_bin_info_t *)base_alloc(tsdn, b0get(), nhbins
 	    * sizeof(cache_bin_info_t), CACHELINE);
 	if (tcache_bin_info == NULL) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	stack_nelms = 0;
@@ -692,6 +721,7 @@ tcache_boot(tsdn_t *tsdn) {
 		stack_nelms += tcache_bin_info[i].ncached_max;
 	}
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -700,6 +730,7 @@ tcache_prefork(tsdn_t *tsdn) {
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_prefork(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -707,6 +738,7 @@ tcache_postfork_parent(tsdn_t *tsdn) {
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_postfork_parent(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -714,4 +746,5 @@ tcache_postfork_child(tsdn_t *tsdn) {
 	if (!config_prof && opt_tcache) {
 		malloc_mutex_postfork_child(tsdn, &tcaches_mtx);
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/ticker.c b/deps/jemalloc/src/ticker.c
index d7b8cd2..9e4f23d 100644
--- a/deps/jemalloc/src/ticker.c
+++ b/deps/jemalloc/src/ticker.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_TICKER_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
diff --git a/deps/jemalloc/src/tsd.c b/deps/jemalloc/src/tsd.c
index c143068..3f012a3 100644
--- a/deps/jemalloc/src/tsd.c
+++ b/deps/jemalloc/src/tsd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_TSD_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -61,6 +62,7 @@ tsd_slow_update(tsd_t *tsd) {
 			tsd->state = tsd_state_nominal;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -93,6 +95,7 @@ assert_tsd_data_cleanup_done(tsd_t *tsd) {
 	assert(*tsd_arenas_tdatap_get_unsafe(tsd) == NULL);
 	assert(*tsd_tcache_enabledp_get_unsafe(tsd) == false);
 	assert(*tsd_prof_tdatap_get_unsafe(tsd) == NULL);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -110,6 +113,7 @@ tsd_data_init_nocleanup(tsd_t *tsd) {
 	*tsd_reentrancy_levelp_get(tsd) = 1;
 	assert_tsd_data_cleanup_done(tsd);
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -153,17 +157,20 @@ tsd_fetch_slow(tsd_t *tsd, bool minimal) {
 		assert(tsd->state == tsd_state_reincarnated);
 	}
 
+	__A_VARIABLE = 1;
 	return tsd;
 }
 
 void *
 malloc_tsd_malloc(size_t size) {
+	__A_VARIABLE = 1;
 	return a0malloc(CACHELINE_CEILING(size));
 }
 
 void
 malloc_tsd_dalloc(void *wrapper) {
 	a0dalloc(wrapper);
+	__A_VARIABLE = 1;
 }
 
 #if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
@@ -190,6 +197,7 @@ _malloc_thread_cleanup(void) {
 			}
 		}
 	} while (again);
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -198,6 +206,7 @@ malloc_tsd_cleanup_register(bool (*f)(void)) {
 	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
 	cleanups[ncleanups] = f;
 	ncleanups++;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -208,6 +217,7 @@ tsd_do_data_cleanup(tsd_t *tsd) {
 	arenas_tdata_cleanup(tsd);
 	tcache_cleanup(tsd);
 	witnesses_cleanup(tsd_witness_tsdp_get_unsafe(tsd));
+	__A_VARIABLE = 1;
 }
 
 void
@@ -253,6 +263,7 @@ tsd_cleanup(void *arg) {
 		test_callback(data);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
 
 tsd_t *
@@ -261,10 +272,12 @@ malloc_tsd_boot0(void) {
 
 	ncleanups = 0;
 	if (tsd_boot0()) {
+		__A_VARIABLE = 1;
 		return NULL;
 	}
 	tsd = tsd_fetch();
 	*tsd_arenas_tdata_bypassp_get(tsd) = true;
+	__A_VARIABLE = 1;
 	return tsd;
 }
 
@@ -275,6 +288,7 @@ malloc_tsd_boot1(void) {
 	/* malloc_slow has been set properly.  Update tsd_slow. */
 	tsd_slow_update(tsd);
 	*tsd_arenas_tdata_bypassp_get(tsd) = false;
+	__A_VARIABLE = 1;
 }
 
 #ifdef _WIN32
@@ -292,6 +306,7 @@ _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
 	default:
 		break;
 	}
+	__A_VARIABLE = 1;
 	return true;
 }
 
@@ -331,6 +346,7 @@ tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
 	ql_foreach(iter, &head->blocks, link) {
 		if (iter->thread == self) {
 			malloc_mutex_unlock(TSDN_NULL, &head->lock);
+			__A_VARIABLE = 1;
 			return iter->data;
 		}
 	}
@@ -339,6 +355,7 @@ tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block) {
 	block->thread = self;
 	ql_tail_insert(&head->blocks, block, link);
 	malloc_mutex_unlock(TSDN_NULL, &head->lock);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -347,5 +364,6 @@ tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block) {
 	malloc_mutex_lock(TSDN_NULL, &head->lock);
 	ql_remove(&head->blocks, block, link);
 	malloc_mutex_unlock(TSDN_NULL, &head->lock);
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/deps/jemalloc/src/witness.c b/deps/jemalloc/src/witness.c
index f42b72a..485c342 100644
--- a/deps/jemalloc/src/witness.c
+++ b/deps/jemalloc/src/witness.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define JEMALLOC_WITNESS_C_
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
@@ -12,6 +13,7 @@ witness_init(witness_t *witness, const char *name, witness_rank_t rank,
 	witness->rank = rank;
 	witness->comp = comp;
 	witness->opaque = opaque;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -25,6 +27,7 @@ witness_lock_error_impl(const witness_list_t *witnesses,
 	}
 	malloc_printf(" %s(%u)\n", witness->name, witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_lock_error_t *JET_MUTABLE witness_lock_error = witness_lock_error_impl;
 
@@ -33,6 +36,7 @@ witness_owner_error_impl(const witness_t *witness) {
 	malloc_printf("<jemalloc>: Should own %s(%u)\n", witness->name,
 	    witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_owner_error_t *JET_MUTABLE witness_owner_error =
     witness_owner_error_impl;
@@ -42,6 +46,7 @@ witness_not_owner_error_impl(const witness_t *witness) {
 	malloc_printf("<jemalloc>: Should not own %s(%u)\n", witness->name,
 	    witness->rank);
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_not_owner_error_t *JET_MUTABLE witness_not_owner_error =
     witness_not_owner_error_impl;
@@ -58,6 +63,7 @@ witness_depth_error_impl(const witness_list_t *witnesses,
 	}
 	malloc_printf("\n");
 	abort();
+	__A_VARIABLE = 1;
 }
 witness_depth_error_t *JET_MUTABLE witness_depth_error =
     witness_depth_error_impl;
@@ -67,27 +73,33 @@ witnesses_cleanup(witness_tsd_t *witness_tsd) {
 	witness_assert_lockless(witness_tsd_tsdn(witness_tsd));
 
 	/* Do nothing. */
+	__A_VARIABLE = 1;
 }
 
 void
 witness_prefork(witness_tsd_t *witness_tsd) {
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_tsd->forking = true;
+	__A_VARIABLE = 1;
 }
 
 void
 witness_postfork_parent(witness_tsd_t *witness_tsd) {
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	witness_tsd->forking = false;
+	__A_VARIABLE = 1;
 }
 
 void
 witness_postfork_child(witness_tsd_t *witness_tsd) {
 	if (!config_debug) {
+		__A_VARIABLE = 1;
 		return;
 	}
 #ifndef JEMALLOC_MUTEX_INIT_CB
@@ -97,4 +109,5 @@ witness_postfork_child(witness_tsd_t *witness_tsd) {
 	ql_new(witnesses);
 #endif
 	witness_tsd->forking = false;
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/src/zone.c b/deps/jemalloc/src/zone.c
index 23dfdd0..716ac5c 100644
--- a/deps/jemalloc/src/zone.c
+++ b/deps/jemalloc/src/zone.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "jemalloc/internal/jemalloc_preamble.h"
 #include "jemalloc/internal/jemalloc_internal_includes.h"
 
@@ -140,16 +141,19 @@ zone_size(malloc_zone_t *zone, const void *ptr) {
 	 * not work in practice, we must check all pointers to assure that they
 	 * reside within a mapped extent before determining size.
 	 */
+	__A_VARIABLE = 1;
 	return ivsalloc(tsdn_fetch(), ptr);
 }
 
 static void *
 zone_malloc(malloc_zone_t *zone, size_t size) {
+	__A_VARIABLE = 1;
 	return je_malloc(size);
 }
 
 static void *
 zone_calloc(malloc_zone_t *zone, size_t num, size_t size) {
+	__A_VARIABLE = 1;
 	return je_calloc(num, size);
 }
 
@@ -159,6 +163,7 @@ zone_valloc(malloc_zone_t *zone, size_t size) {
 
 	je_posix_memalign(&ret, PAGE, size);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -166,18 +171,22 @@ static void
 zone_free(malloc_zone_t *zone, void *ptr) {
 	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
 		je_free(ptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(ptr);
+	__A_VARIABLE = 1;
 }
 
 static void *
 zone_realloc(malloc_zone_t *zone, void *ptr, size_t size) {
 	if (ivsalloc(tsdn_fetch(), ptr) != 0) {
+		__A_VARIABLE = 1;
 		return je_realloc(ptr, size);
 	}
 
+	__A_VARIABLE = 1;
 	return realloc(ptr, size);
 }
 
@@ -187,6 +196,7 @@ zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size) {
 
 	je_posix_memalign(&ret, alignment, size);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -198,16 +208,19 @@ zone_free_definite_size(malloc_zone_t *zone, void *ptr, size_t size) {
 	if (alloc_size != 0) {
 		assert(alloc_size == size);
 		je_free(ptr);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(ptr);
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_destroy(malloc_zone_t *zone) {
 	/* This function should never be called. */
 	not_reached();
+	__A_VARIABLE = 1;
 }
 
 static unsigned
@@ -221,6 +234,7 @@ zone_batch_malloc(struct _malloc_zone_t *zone, size_t size, void **results,
 			break;
 	}
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
@@ -233,10 +247,12 @@ zone_batch_free(struct _malloc_zone_t *zone, void **to_be_freed,
 		zone_free(zone, to_be_freed[i]);
 		to_be_freed[i] = NULL;
 	}
+	__A_VARIABLE = 1;
 }
 
 static size_t
 zone_pressure_relief(struct _malloc_zone_t *zone, size_t goal) {
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -245,6 +261,7 @@ zone_good_size(malloc_zone_t *zone, size_t size) {
 	if (size == 0) {
 		size = 1;
 	}
+	__A_VARIABLE = 1;
 	return sz_s2u(size);
 }
 
@@ -252,20 +269,24 @@ static kern_return_t
 zone_enumerator(task_t task, void *data, unsigned type_mask,
     vm_address_t zone_address, memory_reader_t reader,
     vm_range_recorder_t recorder) {
+	__A_VARIABLE = 1;
 	return KERN_SUCCESS;
 }
 
 static boolean_t
 zone_check(malloc_zone_t *zone) {
+	__A_VARIABLE = 1;
 	return true;
 }
 
 static void
 zone_print(malloc_zone_t *zone, boolean_t verbose) {
+	__A_VARIABLE = 1;
 }
 
 static void
 zone_log(malloc_zone_t *zone, void *address) {
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -279,6 +300,7 @@ zone_force_lock(malloc_zone_t *zone) {
 		zone_force_lock_pid = getpid();
 		jemalloc_prefork();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -304,6 +326,7 @@ zone_force_unlock(malloc_zone_t *zone) {
 		}
 		zone_force_lock_pid = -1;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -313,11 +336,13 @@ zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {
 	stats->size_in_use = 0;
 	stats->max_size_in_use = 0;
 	stats->size_allocated = 0;
+	__A_VARIABLE = 1;
 }
 
 static boolean_t
 zone_locked(malloc_zone_t *zone) {
 	/* Pretend no lock is being held */
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -326,6 +351,7 @@ zone_reinit_lock(malloc_zone_t *zone) {
 	/* As of OSX 10.12, this function is only used when force_unlock would
 	 * be used if the zone version were < 9. So just use force_unlock. */
 	zone_force_unlock(zone);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -364,6 +390,7 @@ zone_init(void) {
 	jemalloc_zone_introspect.enumerate_unavailable_without_blocks = NULL;
 #endif
 	jemalloc_zone_introspect.reinit_lock = zone_reinit_lock;
+	__A_VARIABLE = 1;
 }
 
 static malloc_zone_t *
@@ -390,9 +417,11 @@ zone_default_get(void) {
 	}
 
 	if (num_zones) {
+		__A_VARIABLE = 1;
 		return zones[0];
 	}
 
+	__A_VARIABLE = 1;
 	return malloc_default_zone();
 }
 
@@ -431,6 +460,7 @@ zone_promote(void) {
 
 		zone = zone_default_get();
 	} while (zone != &jemalloc_zone);
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_ATTR(constructor)
@@ -443,6 +473,7 @@ zone_register(void) {
 	default_zone = zone_default_get();
 	if (!default_zone->zone_name || strcmp(default_zone->zone_name,
 	    "DefaultMallocZone") != 0) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -466,4 +497,5 @@ zone_register(void) {
 
 	/* Promote the custom zone to be default. */
 	zone_promote();
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/integration/MALLOCX_ARENA.c b/deps/jemalloc/test/integration/MALLOCX_ARENA.c
index 222164d..d695019 100644
--- a/deps/jemalloc/test/integration/MALLOCX_ARENA.c
+++ b/deps/jemalloc/test/integration/MALLOCX_ARENA.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NTHREADS 10
@@ -41,6 +42,7 @@ thd_start(void *arg) {
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	dallocx(p, 0);
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -56,11 +58,13 @@ TEST_BEGIN(test_MALLOCX_ARENA) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_MALLOCX_ARENA);
 }
diff --git a/deps/jemalloc/test/integration/aligned_alloc.c b/deps/jemalloc/test/integration/aligned_alloc.c
index 536b67e..70a3c08 100644
--- a/deps/jemalloc/test/integration/aligned_alloc.c
+++ b/deps/jemalloc/test/integration/aligned_alloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define MAXALIGN (((size_t)1) << 23)
@@ -11,6 +12,7 @@ static void
 purge(void) {
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_alignment_errors) {
@@ -31,6 +33,7 @@ TEST_BEGIN(test_alignment_errors) {
 		    "Expected error for invalid alignment %zu",
 		    alignment + 1);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -75,6 +78,7 @@ TEST_BEGIN(test_oom_errors) {
 	assert_false(p != NULL || get_errno() != ENOMEM,
 	    "Expected error for aligned_alloc(&p, %zu, %zu)",
 	    alignment, size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -121,11 +125,13 @@ TEST_BEGIN(test_alignment_and_size) {
 		purge();
 	}
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_alignment_errors,
 	    test_oom_errors,
diff --git a/deps/jemalloc/test/integration/allocated.c b/deps/jemalloc/test/integration/allocated.c
index 1425fd0..41ab5ab 100644
--- a/deps/jemalloc/test/integration/allocated.c
+++ b/deps/jemalloc/test/integration/allocated.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static const bool config_stats =
@@ -91,16 +92,19 @@ thd_start(void *arg) {
 	    "Deallocated memory counter should increase by at least the amount "
 	    "explicitly deallocated");
 
+	__A_VARIABLE = 1;
 	return NULL;
 label_ENOENT:
 	assert_false(config_stats,
 	    "ENOENT should only be returned if stats are disabled");
 	test_skip("\"thread.allocated\" mallctl not available");
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_main_thread) {
 	thd_start(NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -109,12 +113,14 @@ TEST_BEGIN(test_subthread) {
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
 	/* Run tests multiple times to check for bad interactions. */
+	__A_VARIABLE = 1;
 	return test(
 	    test_main_thread,
 	    test_subthread,
diff --git a/deps/jemalloc/test/integration/extent.c b/deps/jemalloc/test/integration/extent.c
index b5db087..664cf0b 100644
--- a/deps/jemalloc/test/integration/extent.c
+++ b/deps/jemalloc/test/integration/extent.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "test/extent_hooks.h"
@@ -8,9 +9,11 @@ check_background_thread_enabled(void) {
 	size_t sz = sizeof(bool);
 	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
 	if (ret == ENOENT) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	assert_d_eq(ret, 0, "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 	return enabled;
 }
 
@@ -96,6 +99,7 @@ test_extent_body(unsigned arena_ind) {
 	p = mallocx(42, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -113,6 +117,7 @@ test_manual_hook_auto_arena(void) {
 	assert_d_eq(mallctl("opt.narenas", (void *)&narenas, &sz, NULL, 0),
 	    0, "Unexpected mallctl() failure");
 	if (narenas == 1) {
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -133,6 +138,7 @@ test_manual_hook_auto_arena(void) {
 		    "Expected auto arena 1 created only once.");
 		auto_arena_created = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -203,6 +209,7 @@ test_manual_hook_body(void) {
 	    "Unexpected extent_hooks error");
 	assert_ptr_eq(old_hooks->merge, default_hooks->merge,
 	    "Unexpected extent_hooks error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_extent_manual_hook) {
@@ -219,6 +226,7 @@ TEST_BEGIN(test_extent_manual_hook) {
 	test_manual_hook_body();
 
 	try_split = try_merge = try_purge_lazy = try_purge_forced = true;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -237,11 +245,13 @@ TEST_BEGIN(test_extent_auto_hook) {
 
 	test_skip_if(check_background_thread_enabled());
 	test_extent_body(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_extent_manual_hook,
 	    test_extent_auto_hook);
diff --git a/deps/jemalloc/test/integration/mallocx.c b/deps/jemalloc/test/integration/mallocx.c
index fd960f3..ca8b197 100644
--- a/deps/jemalloc/test/integration/mallocx.c
+++ b/deps/jemalloc/test/integration/mallocx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static unsigned
@@ -9,11 +10,13 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nlarge(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
@@ -32,11 +35,13 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_large_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
@@ -49,6 +54,7 @@ static void
 purge(void) {
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_overflow) {
@@ -68,6 +74,7 @@ TEST_BEGIN(test_overflow) {
 	assert_ptr_null(mallocx(1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)),
 	    "Expected OOM for mallocx(size=1, MALLOCX_ALIGN(%#zx))",
 	    ZU(PTRDIFF_MAX)+1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -110,6 +117,7 @@ TEST_BEGIN(test_oom) {
 	assert_ptr_null(mallocx(0x80000000UL, MALLOCX_ALIGN(0x80000000UL)),
 	    "Expected OOM for mallocx()");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -147,6 +155,7 @@ TEST_BEGIN(test_basic) {
 		purge();
 	}
 #undef MAXSZ
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -215,11 +224,13 @@ TEST_BEGIN(test_alignment_and_size) {
 	}
 #undef MAXALIGN
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_overflow,
 	    test_oom,
diff --git a/deps/jemalloc/test/integration/overflow.c b/deps/jemalloc/test/integration/overflow.c
index 6a9785b..a3df3d8 100644
--- a/deps/jemalloc/test/integration/overflow.c
+++ b/deps/jemalloc/test/integration/overflow.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_overflow) {
@@ -36,11 +37,13 @@ TEST_BEGIN(test_overflow) {
 	assert_ptr_null(realloc(p, SIZE_T_MAX),
 	    "Expected OOM due to over-sized allocation request");
 	free(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_overflow);
 }
diff --git a/deps/jemalloc/test/integration/posix_memalign.c b/deps/jemalloc/test/integration/posix_memalign.c
index 2c2726d..a23b437 100644
--- a/deps/jemalloc/test/integration/posix_memalign.c
+++ b/deps/jemalloc/test/integration/posix_memalign.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define MAXALIGN (((size_t)1) << 23)
@@ -11,6 +12,7 @@ static void
 purge(void) {
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_alignment_errors) {
@@ -29,6 +31,7 @@ TEST_BEGIN(test_alignment_errors) {
 		    "Expected error for invalid alignment %zu",
 		    alignment + 1);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -67,6 +70,7 @@ TEST_BEGIN(test_oom_errors) {
 	assert_d_ne(posix_memalign(&p, alignment, size), 0,
 	    "Expected error for posix_memalign(&p, %zu, %zu)",
 	    alignment, size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -115,11 +119,13 @@ TEST_BEGIN(test_alignment_and_size) {
 		purge();
 	}
 #undef NITER
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_alignment_errors,
 	    test_oom_errors,
diff --git a/deps/jemalloc/test/integration/rallocx.c b/deps/jemalloc/test/integration/rallocx.c
index 7821ca5..d709d8b 100644
--- a/deps/jemalloc/test/integration/rallocx.c
+++ b/deps/jemalloc/test/integration/rallocx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static unsigned
@@ -9,11 +10,13 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nlarge(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
@@ -32,11 +35,13 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_large_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
@@ -81,6 +86,7 @@ TEST_BEGIN(test_grow_and_shrink) {
 #undef MAXSZ
 #undef NSZS
 #undef NCYCLES
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -144,6 +150,7 @@ TEST_BEGIN(test_zero) {
 		dallocx(p, 0);
 	}
 #undef FILL_BYTE
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -168,6 +175,7 @@ TEST_BEGIN(test_align) {
 	}
 	dallocx(p, 0);
 #undef MAX_ALIGN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -205,6 +213,7 @@ TEST_BEGIN(test_lg_align_and_zero) {
 	dallocx(p, 0);
 #undef MAX_VALIDATE
 #undef MAX_LG_ALIGN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -231,11 +240,13 @@ TEST_BEGIN(test_overflow) {
 	    ZU(PTRDIFF_MAX)+1);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_grow_and_shrink,
 	    test_zero,
diff --git a/deps/jemalloc/test/integration/sdallocx.c b/deps/jemalloc/test/integration/sdallocx.c
index ca01448..4320d87 100644
--- a/deps/jemalloc/test/integration/sdallocx.c
+++ b/deps/jemalloc/test/integration/sdallocx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define MAXALIGN (((size_t)1) << 22)
@@ -6,6 +7,7 @@
 TEST_BEGIN(test_basic) {
 	void *ptr = mallocx(64, 0);
 	sdallocx(ptr, 64, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -44,11 +46,13 @@ TEST_BEGIN(test_alignment_and_size) {
 			}
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_basic,
 	    test_alignment_and_size);
diff --git a/deps/jemalloc/test/integration/thread_arena.c b/deps/jemalloc/test/integration/thread_arena.c
index 1e5ec05..49c773e 100644
--- a/deps/jemalloc/test/integration/thread_arena.c
+++ b/deps/jemalloc/test/integration/thread_arena.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NTHREADS 10
@@ -34,6 +35,7 @@ thd_start(void *arg) {
 	assert_u_eq(arena_ind, main_arena_ind,
 	    "Arena index should be same as for main thread");
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -43,6 +45,7 @@ mallctl_failure(int err) {
 
 	buferror(err, buf, sizeof(buf));
 	test_fail("Error in mallctl(): %s", buf);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_thread_arena) {
@@ -76,11 +79,13 @@ TEST_BEGIN(test_thread_arena) {
 		assert_zd_eq(join_ret, 0, "Unexpected thread join error");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_thread_arena);
 }
diff --git a/deps/jemalloc/test/integration/thread_tcache_enabled.c b/deps/jemalloc/test/integration/thread_tcache_enabled.c
index 95c9acc..5bcc4d7 100644
--- a/deps/jemalloc/test/integration/thread_tcache_enabled.c
+++ b/deps/jemalloc/test/integration/thread_tcache_enabled.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 void *
@@ -59,11 +60,13 @@ thd_start(void *arg) {
 	assert_false(e0, "tcache should be disabled");
 
 	free(malloc(1));
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_main_thread) {
 	thd_start(NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -72,12 +75,14 @@ TEST_BEGIN(test_subthread) {
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
 	/* Run tests multiple times to check for bad interactions. */
+	__A_VARIABLE = 1;
 	return test(
 	    test_main_thread,
 	    test_subthread,
diff --git a/deps/jemalloc/test/integration/xallocx.c b/deps/jemalloc/test/integration/xallocx.c
index cd0ca04..8025500 100644
--- a/deps/jemalloc/test/integration/xallocx.c
+++ b/deps/jemalloc/test/integration/xallocx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 /*
@@ -15,6 +16,7 @@ arena_ind(void) {
 		    0), 0, "Unexpected mallctl failure creating arena");
 	}
 
+	__A_VARIABLE = 1;
 	return ind;
 }
 
@@ -30,6 +32,7 @@ TEST_BEGIN(test_same_size) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -45,6 +48,7 @@ TEST_BEGIN(test_extra_no_move) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -60,6 +64,7 @@ TEST_BEGIN(test_no_move_fail) {
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -77,11 +82,13 @@ get_nsizes_impl(const char *cmd) {
 
 static unsigned
 get_nsmall(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nbins");
 }
 
 static unsigned
 get_nlarge(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
@@ -100,16 +107,19 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_small_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.bin.0.size", ind);
 }
 
 static size_t
 get_large_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
@@ -139,6 +149,7 @@ TEST_BEGIN(test_size) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -170,6 +181,7 @@ TEST_BEGIN(test_size_extra_overflow) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -201,6 +213,7 @@ TEST_BEGIN(test_extra_small) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -270,6 +283,7 @@ TEST_BEGIN(test_extra_large) {
 	    "Unexpected xallocx() behavior");
 
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -290,6 +304,7 @@ print_filled_extents(const void *p, uint8_t c, size_t len) {
 		}
 	}
 	malloc_printf(" %#x[%zu..%zu)\n", c0, range0, i);
+	__A_VARIABLE = 1;
 }
 
 static bool
@@ -308,6 +323,7 @@ validate_fill(const void *p, uint8_t c, size_t offset, size_t len) {
 		print_filled_extents(p, c, offset + len);
 	}
 
+	__A_VARIABLE = 1;
 	return err;
 }
 
@@ -357,6 +373,7 @@ test_zero(size_t szmin, size_t szmax) {
 	}
 
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_zero_large) {
@@ -367,11 +384,13 @@ TEST_BEGIN(test_zero_large) {
 	large1 = get_large_size(1);
 
 	test_zero(large1, large0 * 2);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_same_size,
 	    test_extra_no_move,
diff --git a/deps/jemalloc/test/src/SFMT.c b/deps/jemalloc/test/src/SFMT.c
index c05e218..c446f30 100644
--- a/deps/jemalloc/test/src/SFMT.c
+++ b/deps/jemalloc/test/src/SFMT.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file derives from SFMT 1.3.3
  * (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html), which was
@@ -143,10 +144,12 @@ static inline void swap(w128_t *array, int size);
  */
 #ifdef ONLY64
 static inline int idxof(int i) {
+    __A_VARIABLE = 1;
     return i ^ 1;
 }
 #else
 static inline int idxof(int i) {
+    __A_VARIABLE = 1;
     return i;
 }
 #endif
@@ -173,6 +176,7 @@ static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[1] = (uint32_t)ol;
     out->u[2] = (uint32_t)(oh >> 32);
     out->u[3] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #else
 static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
@@ -188,6 +192,7 @@ static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[0] = (uint32_t)ol;
     out->u[3] = (uint32_t)(oh >> 32);
     out->u[2] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #endif
 /**
@@ -212,6 +217,7 @@ static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[1] = (uint32_t)ol;
     out->u[2] = (uint32_t)(oh >> 32);
     out->u[3] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #else
 static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
@@ -227,6 +233,7 @@ static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
     out->u[0] = (uint32_t)ol;
     out->u[3] = (uint32_t)(oh >> 32);
     out->u[2] = (uint32_t)oh;
+    __A_VARIABLE = 1;
 }
 #endif
 #endif
@@ -256,6 +263,7 @@ static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 	^ (d->u[2] << SL1);
     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3]
 	^ (d->u[3] << SL1);
+    __A_VARIABLE = 1;
 }
 #else
 static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
@@ -273,6 +281,7 @@ static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
 	^ (d->u[2] << SL1);
     r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3]
 	^ (d->u[3] << SL1);
+    __A_VARIABLE = 1;
 }
 #endif
 #endif
@@ -300,6 +309,7 @@ static inline void gen_rand_all(sfmt_t *ctx) {
 	r1 = r2;
 	r2 = &ctx->sfmt[i];
     }
+    __A_VARIABLE = 1;
 }
 
 /**
@@ -339,6 +349,7 @@ static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size) {
 	r2 = &array[i];
 	ctx->sfmt[j] = array[i];
     }
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -355,6 +366,7 @@ static inline void swap(w128_t *array, int size) {
 	array[i].u[1] = x;
 	array[i].u[3] = y;
     }
+    __A_VARIABLE = 1;
 }
 #endif
 /**
@@ -364,6 +376,7 @@ static inline void swap(w128_t *array, int size) {
  * @return 32-bit integer
  */
 static uint32_t func1(uint32_t x) {
+    __A_VARIABLE = 1;
     return (x ^ (x >> 27)) * (uint32_t)1664525UL;
 }
 
@@ -374,6 +387,7 @@ static uint32_t func1(uint32_t x) {
  * @return 32-bit integer
  */
 static uint32_t func2(uint32_t x) {
+    __A_VARIABLE = 1;
     return (x ^ (x >> 27)) * (uint32_t)1566083941UL;
 }
 
@@ -393,6 +407,7 @@ static void period_certification(sfmt_t *ctx) {
     inner &= 1;
     /* check OK */
     if (inner == 1) {
+	__A_VARIABLE = 1;
 	return;
     }
     /* check NG, and modification */
@@ -401,11 +416,13 @@ static void period_certification(sfmt_t *ctx) {
 	for (j = 0; j < 32; j++) {
 	    if ((work & parity[i]) != 0) {
 		psfmt32[idxof(i)] ^= work;
+		__A_VARIABLE = 1;
 		return;
 	    }
 	    work = work << 1;
 	}
     }
+    __A_VARIABLE = 1;
 }
 
 /*----------------
@@ -417,6 +434,7 @@ static void period_certification(sfmt_t *ctx) {
  * and all parameters of this generator.
  */
 const char *get_idstring(void) {
+    __A_VARIABLE = 1;
     return IDSTR;
 }
 
@@ -426,6 +444,7 @@ const char *get_idstring(void) {
  * @return minimum size of array used for fill_array32() function.
  */
 int get_min_array_size32(void) {
+    __A_VARIABLE = 1;
     return N32;
 }
 
@@ -435,6 +454,7 @@ int get_min_array_size32(void) {
  * @return minimum size of array used for fill_array64() function.
  */
 int get_min_array_size64(void) {
+    __A_VARIABLE = 1;
     return N64;
 }
 
@@ -454,6 +474,7 @@ uint32_t gen_rand32(sfmt_t *ctx) {
 	ctx->idx = 0;
     }
     r = psfmt32[ctx->idx++];
+    __A_VARIABLE = 1;
     return r;
 }
 
@@ -469,6 +490,7 @@ uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit) {
 	    break;
 	}
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 #endif
@@ -519,6 +541,7 @@ uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
 	    break;
 	}
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -556,6 +579,7 @@ void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
 
     gen_rand_array(ctx, (w128_t *)array, size / 4);
     ctx->idx = N32;
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -596,6 +620,7 @@ void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
 #if defined(BIG_ENDIAN64) && !defined(ONLY64)
     swap((w128_t *)array, size /2);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /**
@@ -611,6 +636,7 @@ sfmt_t *init_gen_rand(uint32_t seed) {
     uint32_t *psfmt32;
 
     if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
+	__A_VARIABLE = 1;
 	return NULL;
     }
     ctx = (sfmt_t *)p;
@@ -626,6 +652,7 @@ sfmt_t *init_gen_rand(uint32_t seed) {
     period_certification(ctx);
     ctx->initialized = 1;
 
+    __A_VARIABLE = 1;
     return ctx;
 }
 
@@ -646,6 +673,7 @@ sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
     uint32_t *psfmt32;
 
     if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
+	__A_VARIABLE = 1;
 	return NULL;
     }
     ctx = (sfmt_t *)p;
@@ -708,6 +736,7 @@ sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
     period_certification(ctx);
     ctx->initialized = 1;
 
+    __A_VARIABLE = 1;
     return ctx;
 }
 
@@ -716,4 +745,5 @@ void fini_gen_rand(sfmt_t *ctx) {
 
     ctx->initialized = 0;
     free(ctx);
+    __A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/btalloc.c b/deps/jemalloc/test/src/btalloc.c
index d570952..405a45d 100644
--- a/deps/jemalloc/test/src/btalloc.c
+++ b/deps/jemalloc/test/src/btalloc.c
@@ -1,6 +1,8 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 void *
 btalloc(size_t size, unsigned bits) {
+	__A_VARIABLE = 1;
 	return btalloc_0(size, bits);
 }
diff --git a/deps/jemalloc/test/src/btalloc_0.c b/deps/jemalloc/test/src/btalloc_0.c
index 77d8904..7869fa5 100644
--- a/deps/jemalloc/test/src/btalloc_0.c
+++ b/deps/jemalloc/test/src/btalloc_0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 btalloc_n_gen(0)
diff --git a/deps/jemalloc/test/src/btalloc_1.c b/deps/jemalloc/test/src/btalloc_1.c
index 4c126c3..e1cc44c 100644
--- a/deps/jemalloc/test/src/btalloc_1.c
+++ b/deps/jemalloc/test/src/btalloc_1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 btalloc_n_gen(1)
diff --git a/deps/jemalloc/test/src/math.c b/deps/jemalloc/test/src/math.c
index 1758c67..a2a2fbb 100644
--- a/deps/jemalloc/test/src/math.c
+++ b/deps/jemalloc/test/src/math.c
@@ -1,2 +1,3 @@
+static volatile int __A_VARIABLE;
 #define MATH_C_
 #include "test/jemalloc_test.h"
diff --git a/deps/jemalloc/test/src/mq.c b/deps/jemalloc/test/src/mq.c
index 9b5f672..e286a82 100644
--- a/deps/jemalloc/test/src/mq.c
+++ b/deps/jemalloc/test/src/mq.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 /*
@@ -24,4 +25,5 @@ mq_nanosleep(unsigned ns) {
 		nanosleep(&timeout, NULL);
 	}
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/mtx.c b/deps/jemalloc/test/src/mtx.c
index a393c01..c30df6b 100644
--- a/deps/jemalloc/test/src/mtx.c
+++ b/deps/jemalloc/test/src/mtx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #ifndef _CRT_SPINCOUNT
@@ -39,6 +40,7 @@ mtx_fini(mtx_t *mtx) {
 #else
 	pthread_mutex_destroy(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 void
@@ -52,6 +54,7 @@ mtx_lock(mtx_t *mtx) {
 #else
 	pthread_mutex_lock(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
 
 void
@@ -65,4 +68,5 @@ mtx_unlock(mtx_t *mtx) {
 #else
 	pthread_mutex_unlock(&mtx->lock);
 #endif
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/test.c b/deps/jemalloc/test/src/test.c
index 01a4d73..582c4dc 100644
--- a/deps/jemalloc/test/src/test.c
+++ b/deps/jemalloc/test/src/test.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 /* Test status state. */
@@ -24,14 +25,18 @@ static const char *
 reentrancy_t_str(reentrancy_t r) {
 	switch (r) {
 	case non_reentrant:
+		__A_VARIABLE = 1;
 		return "non-reentrant";
 	case libc_reentrant:
+		__A_VARIABLE = 1;
 		return "libc-reentrant";
 	case arena_new_reentrant:
+		__A_VARIABLE = 1;
 		return "arena_new-reentrant";
 	default:
 		unreachable();
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -44,21 +49,25 @@ do_hook(bool *hook_ran, void (**hook)()) {
 		free(malloc(alloc_size));
 		alloc_size *= 2;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
 libc_reentrancy_hook() {
 	do_hook(&libc_hook_ran, &hooks_libc_hook);
+	__A_VARIABLE = 1;
 }
 
 static void
 arena_new_reentrancy_hook() {
 	do_hook(&arena_new_hook_ran, &hooks_arena_new_hook);
+	__A_VARIABLE = 1;
 }
 
 /* Actual test infrastructure. */
 bool
 test_is_reentrant() {
+	__A_VARIABLE = 1;
 	return reentrancy != non_reentrant;
 }
 
@@ -72,6 +81,7 @@ test_skip(const char *format, ...) {
 	va_end(ap);
 	malloc_printf("\n");
 	test_status = test_status_skip;
+	__A_VARIABLE = 1;
 }
 
 JEMALLOC_FORMAT_PRINTF(1, 2)
@@ -84,16 +94,21 @@ test_fail(const char *format, ...) {
 	va_end(ap);
 	malloc_printf("\n");
 	test_status = test_status_fail;
+	__A_VARIABLE = 1;
 }
 
 static const char *
 test_status_string(test_status_t test_status) {
 	switch (test_status) {
-	case test_status_pass: return "pass";
-	case test_status_skip: return "skip";
-	case test_status_fail: return "fail";
+	case test_status_pass: __A_VARIABLE = 1;
+		return "pass";
+	case test_status_skip: __A_VARIABLE = 1;
+		return "skip";
+	case test_status_fail: __A_VARIABLE = 1;
+		return "fail";
 	default: not_reached();
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -101,6 +116,7 @@ p_test_init(const char *name) {
 	test_count++;
 	test_status = test_status_pass;
 	test_name = name;
+	__A_VARIABLE = 1;
 }
 
 void
@@ -108,6 +124,7 @@ p_test_fini(void) {
 	test_counts[test_status]++;
 	malloc_printf("%s (%s): %s\n", test_name, reentrancy_t_str(reentrancy),
 	    test_status_string(test_status));
+	__A_VARIABLE = 1;
 }
 
 static test_status_t
@@ -123,6 +140,7 @@ p_test_impl(bool do_malloc_init, bool do_reentrant, test_t *t, va_list ap) {
 		 */
 		if (nallocx(1, 0) == 0) {
 			malloc_printf("Initialization error");
+			__A_VARIABLE = 1;
 			return test_status_fail;
 		}
 	}
@@ -164,6 +182,7 @@ p_test_impl(bool do_malloc_init, bool do_reentrant, test_t *t, va_list ap) {
 	    test_status_string(test_status_fail),
 	    test_counts[test_status_fail], test_count);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -177,6 +196,7 @@ p_test(test_t *t, ...) {
 	ret = p_test_impl(true, true, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -190,6 +210,7 @@ p_test_no_reentrancy(test_t *t, ...) {
 	ret = p_test_impl(true, false, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -207,6 +228,7 @@ p_test_no_malloc_init(test_t *t, ...) {
 	ret = p_test_impl(false, false, t, ap);
 	va_end(ap);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -214,4 +236,5 @@ void
 p_test_fail(const char *prefix, const char *message) {
 	malloc_cprintf(NULL, NULL, "%s%s\n", prefix, message);
 	test_status = test_status_fail;
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/src/thd.c b/deps/jemalloc/test/src/thd.c
index 9a15eab..56b0b3c 100644
--- a/deps/jemalloc/test/src/thd.c
+++ b/deps/jemalloc/test/src/thd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #ifdef _WIN32
@@ -8,6 +9,7 @@ thd_create(thd_t *thd, void *(*proc)(void *), void *arg) {
 	if (*thd == NULL) {
 		test_fail("Error in CreateThread()\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 void
@@ -17,6 +19,7 @@ thd_join(thd_t thd, void **ret) {
 		GetExitCodeThread(thd, (LPDWORD) &exit_code);
 		*ret = (void *)(uintptr_t)exit_code;
 	}
+	__A_VARIABLE = 1;
 }
 
 #else
@@ -25,10 +28,12 @@ thd_create(thd_t *thd, void *(*proc)(void *), void *arg) {
 	if (pthread_create(thd, NULL, proc, arg) != 0) {
 		test_fail("Error in pthread_create()\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 void
 thd_join(thd_t thd, void **ret) {
 	pthread_join(thd, ret);
+	__A_VARIABLE = 1;
 }
 #endif
diff --git a/deps/jemalloc/test/src/timer.c b/deps/jemalloc/test/src/timer.c
index c451c63..2ca100d 100644
--- a/deps/jemalloc/test/src/timer.c
+++ b/deps/jemalloc/test/src/timer.c
@@ -1,15 +1,18 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 void
 timer_start(timedelta_t *timer) {
 	nstime_init(&timer->t0, 0);
 	nstime_update(&timer->t0);
+	__A_VARIABLE = 1;
 }
 
 void
 timer_stop(timedelta_t *timer) {
 	nstime_copy(&timer->t1, &timer->t0);
 	nstime_update(&timer->t1);
+	__A_VARIABLE = 1;
 }
 
 uint64_t
@@ -18,6 +21,7 @@ timer_usec(const timedelta_t *timer) {
 
 	nstime_copy(&delta, &timer->t1);
 	nstime_subtract(&delta, &timer->t0);
+	__A_VARIABLE = 1;
 	return nstime_ns(&delta) / 1000;
 }
 
@@ -33,6 +37,7 @@ timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen) {
 	n = malloc_snprintf(&buf[i], buflen-i, "%"FMTu64, t0 / t1);
 	i += n;
 	if (i >= buflen) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	mult = 1;
@@ -53,4 +58,5 @@ timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen) {
 		i += n;
 		mult *= 10;
 	}
+	__A_VARIABLE = 1;
 }
diff --git a/deps/jemalloc/test/stress/microbench.c b/deps/jemalloc/test/stress/microbench.c
index 988b793..10f424d 100644
--- a/deps/jemalloc/test/stress/microbench.c
+++ b/deps/jemalloc/test/stress/microbench.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static inline void
@@ -13,6 +14,7 @@ time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter,
 		func();
 	}
 	timer_stop(timer);
+	__A_VARIABLE = 1;
 }
 
 void
@@ -25,6 +27,7 @@ compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
 	p = mallocx(1, 0);
 	if (p == NULL) {
 		test_fail("Unexpected mallocx() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 
@@ -38,6 +41,7 @@ compare_funcs(uint64_t nwarmup, uint64_t niter, const char *name_a,
 	    ratio_buf);
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -46,9 +50,11 @@ malloc_free(void) {
 	void *p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -56,14 +62,17 @@ mallocx_free(void) {
 	void *p = mallocx(1, 0);
 	if (p == NULL) {
 		test_fail("Unexpected mallocx() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_malloc_vs_mallocx) {
 	compare_funcs(10*1000*1000, 100*1000*1000, "malloc",
 	    malloc_free, "mallocx", mallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -82,20 +91,24 @@ malloc_sdallocx(void) {
 	void *p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	sdallocx(p, 1, 0);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_free_vs_dallocx) {
 	compare_funcs(10*1000*1000, 100*1000*1000, "free", malloc_free,
 	    "dallocx", malloc_dallocx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_dallocx_vs_sdallocx) {
 	compare_funcs(10*1000*1000, 100*1000*1000, "dallocx", malloc_dallocx,
 	    "sdallocx", malloc_sdallocx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -106,10 +119,12 @@ malloc_mus_free(void) {
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	malloc_usable_size(p);
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -119,17 +134,20 @@ malloc_sallocx_free(void) {
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (sallocx(p, 0) < 1) {
 		test_fail("Unexpected sallocx() failure");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_mus_vs_sallocx) {
 	compare_funcs(10*1000*1000, 100*1000*1000, "malloc_usable_size",
 	    malloc_mus_free, "sallocx", malloc_sallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -140,22 +158,26 @@ malloc_nallocx_free(void) {
 	p = malloc(1);
 	if (p == NULL) {
 		test_fail("Unexpected malloc() failure");
+		__A_VARIABLE = 1;
 		return;
 	}
 	if (nallocx(1, 0) < 1) {
 		test_fail("Unexpected nallocx() failure");
 	}
 	free(p);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_sallocx_vs_nallocx) {
 	compare_funcs(10*1000*1000, 100*1000*1000, "sallocx",
 	    malloc_sallocx_free, "nallocx", malloc_nallocx_free);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_malloc_vs_mallocx,
 	    test_free_vs_dallocx,
diff --git a/deps/jemalloc/test/unit/SFMT.c b/deps/jemalloc/test/unit/SFMT.c
index 1fc8cf1..c585e44 100644
--- a/deps/jemalloc/test/unit/SFMT.c
+++ b/deps/jemalloc/test/unit/SFMT.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file derives from SFMT 1.3.3
  * (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html), which was
@@ -1591,6 +1592,7 @@ TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_gen_rand_32,
 	    test_by_array_32,
diff --git a/deps/jemalloc/test/unit/a0.c b/deps/jemalloc/test/unit/a0.c
index a27ab3f..d9e7c9c 100644
--- a/deps/jemalloc/test/unit/a0.c
+++ b/deps/jemalloc/test/unit/a0.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_a0) {
@@ -6,11 +7,13 @@ TEST_BEGIN(test_a0) {
 	p = a0malloc(1);
 	assert_ptr_not_null(p, "Unexpected a0malloc() error");
 	a0dalloc(p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_malloc_init(
 	    test_a0);
 }
diff --git a/deps/jemalloc/test/unit/arena_reset.c b/deps/jemalloc/test/unit/arena_reset.c
index f5fb24d..5c0bcc4 100644
--- a/deps/jemalloc/test/unit/arena_reset.c
+++ b/deps/jemalloc/test/unit/arena_reset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #ifndef ARENA_RESET_PROF_C_
 #include "test/jemalloc_test.h"
 #endif
@@ -16,16 +17,19 @@ get_nsizes_impl(const char *cmd) {
 	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static unsigned
 get_nsmall(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nbins");
 }
 
 static unsigned
 get_nlarge(void) {
+	__A_VARIABLE = 1;
 	return get_nsizes_impl("arenas.nlextents");
 }
 
@@ -44,16 +48,19 @@ get_size_impl(const char *cmd, size_t ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
 static size_t
 get_small_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.bin.0.size", ind);
 }
 
 static size_t
 get_large_size(size_t ind) {
+	__A_VARIABLE = 1;
 	return get_size_impl("arenas.lextent.0.size", ind);
 }
 
@@ -67,20 +74,25 @@ vsalloc(tsdn_t *tsdn, const void *ptr) {
 	szind_t szind;
 	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
 	    (uintptr_t)ptr, false, &extent, &szind)) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
 	if (extent == NULL) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 	if (extent_state_get(extent) != extent_state_active) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
 	if (szind == NSIZES) {
+		__A_VARIABLE = 1;
 		return 0;
 	}
 
+	__A_VARIABLE = 1;
 	return sz_index2size(szind);
 }
 
@@ -91,6 +103,7 @@ do_arena_create(extent_hooks_t *h) {
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
 	    (void *)(h != NULL ? &h : NULL), (h != NULL ? sizeof(h) : 0)), 0,
 	    "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
@@ -131,6 +144,7 @@ do_arena_reset_pre(unsigned arena_ind, void ***ptrs, unsigned *nptrs) {
 		assert_zu_gt(ivsalloc(tsdn, (*ptrs)[i]), 0,
 		    "Allocation should have queryable size");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -155,6 +169,7 @@ do_arena_reset_post(void **ptrs, unsigned nptrs, unsigned arena_ind) {
 	}
 
 	free(ptrs);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -168,16 +183,19 @@ do_arena_reset_destroy(const char *name, unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_reset(unsigned arena_ind) {
 	do_arena_reset_destroy("arena.0.reset", arena_ind);
+	__A_VARIABLE = 1;
 }
 
 static void
 do_arena_destroy(unsigned arena_ind) {
 	do_arena_reset_destroy("arena.0.destroy", arena_ind);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_arena_reset) {
@@ -189,6 +207,7 @@ TEST_BEGIN(test_arena_reset) {
 	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
 	do_arena_reset(arena_ind);
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -218,6 +237,7 @@ arena_i_initialized(unsigned arena_ind, bool refresh) {
 TEST_BEGIN(test_arena_destroy_initial) {
 	assert_false(arena_i_initialized(MALLCTL_ARENAS_DESTROYED, false),
 	    "Destroyed arena stats should not be initialized");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -258,6 +278,7 @@ TEST_BEGIN(test_arena_destroy_hooks_default) {
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
 
 	do_arena_destroy(arena_ind_another);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -277,10 +298,12 @@ extent_dalloc_unmap(extent_hooks_t *extent_hooks, void *addr, size_t size,
 	    "Wrong hook function");
 	called_dalloc = true;
 	if (!try_dalloc) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	pages_unmap(addr, size);
 	did_dalloc = true;
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -331,11 +354,13 @@ TEST_BEGIN(test_arena_destroy_hooks_unmap) {
 	do_arena_reset_post(ptrs, nptrs, arena_ind);
 
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_arena_reset,
 	    test_arena_destroy_initial,
diff --git a/deps/jemalloc/test/unit/arena_reset_prof.c b/deps/jemalloc/test/unit/arena_reset_prof.c
index 38d8012..d947743 100644
--- a/deps/jemalloc/test/unit/arena_reset_prof.c
+++ b/deps/jemalloc/test/unit/arena_reset_prof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 #define ARENA_RESET_PROF_C_
 
diff --git a/deps/jemalloc/test/unit/atomic.c b/deps/jemalloc/test/unit/atomic.c
index 572d8d2..c3e12b8 100644
--- a/deps/jemalloc/test/unit/atomic.c
+++ b/deps/jemalloc/test/unit/atomic.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 /*
@@ -182,6 +183,7 @@ TEST_BEGIN(test_atomic_u64) {
 #else
 	INTEGER_TEST_BODY(uint64_t, u64);
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -189,24 +191,28 @@ TEST_END
 TEST_STRUCT(uint32_t, u32);
 TEST_BEGIN(test_atomic_u32) {
 	INTEGER_TEST_BODY(uint32_t, u32);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(void *, p);
 TEST_BEGIN(test_atomic_p) {
 	TEST_BODY(void *, p);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(size_t, zu);
 TEST_BEGIN(test_atomic_zu) {
 	INTEGER_TEST_BODY(size_t, zu);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_STRUCT(ssize_t, zd);
 TEST_BEGIN(test_atomic_zd) {
 	INTEGER_TEST_BODY(ssize_t, zd);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -214,11 +220,13 @@ TEST_END
 TEST_STRUCT(unsigned, u);
 TEST_BEGIN(test_atomic_u) {
 	INTEGER_TEST_BODY(unsigned, u);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_atomic_u64,
 	    test_atomic_u32,
diff --git a/deps/jemalloc/test/unit/background_thread.c b/deps/jemalloc/test/unit/background_thread.c
index f7bd37c..1cf5126 100644
--- a/deps/jemalloc/test/unit/background_thread.c
+++ b/deps/jemalloc/test/unit/background_thread.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/util.h"
@@ -19,6 +20,7 @@ test_switch_background_thread_ctl(bool new_val) {
 		assert_zu_eq(n_background_threads, 0,
 		    "Number of background threads should be zero.\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -38,6 +40,7 @@ test_repeat_background_thread_ctl(bool before) {
 		assert_zu_eq(n_background_threads, 0,
 		    "Number of background threads should be zero.\n");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_background_thread_ctl) {
@@ -67,6 +70,7 @@ TEST_BEGIN(test_background_thread_ctl) {
 		test_repeat_background_thread_ctl(false);
 		test_repeat_background_thread_ctl(false);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -107,12 +111,14 @@ TEST_BEGIN(test_background_thread_running) {
 	}
 	test_switch_background_thread_ctl(false);
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
 	/* Background_thread creation tests reentrancy naturally. */
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_background_thread_ctl,
 	    test_background_thread_running);
diff --git a/deps/jemalloc/test/unit/background_thread_enable.c b/deps/jemalloc/test/unit/background_thread_enable.c
index ff95e67..67ccdf7 100644
--- a/deps/jemalloc/test/unit/background_thread_enable.c
+++ b/deps/jemalloc/test/unit/background_thread_enable.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 const char *malloc_conf = "background_thread:false,narenas:1,max_background_threads:20";
@@ -27,6 +28,7 @@ TEST_BEGIN(test_deferred) {
 	enable = false;
 	assert_d_eq(mallctl("background_thread", NULL, NULL, &enable, sz_b), 0,
 	    "Failed to disable background threads");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -72,11 +74,13 @@ TEST_BEGIN(test_max_background_threads) {
 		    0, "Failed to set max background threads");
 	assert_zu_eq(n_background_threads, maxt,
 		     "Number of background threads should be 3.\n");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 		test_deferred,
 		test_max_background_threads);
diff --git a/deps/jemalloc/test/unit/base.c b/deps/jemalloc/test/unit/base.c
index 6b792cf..78cfcd6 100644
--- a/deps/jemalloc/test/unit/base.c
+++ b/deps/jemalloc/test/unit/base.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "test/extent_hooks.h"
@@ -55,6 +56,7 @@ TEST_BEGIN(test_base_hooks_default) {
 	}
 
 	base_delete(tsdn, base);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -100,6 +102,7 @@ TEST_BEGIN(test_base_hooks_null) {
 	base_delete(tsdn, base);
 
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -222,11 +225,13 @@ TEST_BEGIN(test_base_hooks_not_null) {
 	try_purge_lazy = true;
 	try_purge_forced = true;
 	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_base_hooks_default,
 	    test_base_hooks_null,
diff --git a/deps/jemalloc/test/unit/bit_util.c b/deps/jemalloc/test/unit/bit_util.c
index 42a9701..a392066 100644
--- a/deps/jemalloc/test/unit/bit_util.c
+++ b/deps/jemalloc/test/unit/bit_util.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/bit_util.h"
@@ -35,21 +36,25 @@
 
 TEST_BEGIN(test_pow2_ceil_u64) {
 	TEST_POW2_CEIL(uint64_t, u64, FMTu64);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_pow2_ceil_u32) {
 	TEST_POW2_CEIL(uint32_t, u32, FMTu32);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_pow2_ceil_zu) {
 	TEST_POW2_CEIL(size_t, zu, "zu");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_pow2_ceil_u64,
 	    test_pow2_ceil_u32,
diff --git a/deps/jemalloc/test/unit/bitmap.c b/deps/jemalloc/test/unit/bitmap.c
index cafb203..9922f2e 100644
--- a/deps/jemalloc/test/unit/bitmap.c
+++ b/deps/jemalloc/test/unit/bitmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NBITS_TAB \
diff --git a/deps/jemalloc/test/unit/ckh.c b/deps/jemalloc/test/unit/ckh.c
index 707ea5f..d6a3ad4 100644
--- a/deps/jemalloc/test/unit/ckh.c
+++ b/deps/jemalloc/test/unit/ckh.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_new_delete) {
@@ -13,6 +14,7 @@ TEST_BEGIN(test_new_delete) {
 	assert_false(ckh_new(tsd, &ckh, 3, ckh_pointer_hash,
 	    ckh_pointer_keycomp), "Unexpected ckh_new() error");
 	ckh_delete(tsd, &ckh);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -100,6 +102,7 @@ TEST_BEGIN(test_count_insert_search_remove) {
 	}
 
 	ckh_delete(tsd, &ckh);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -199,11 +202,13 @@ TEST_BEGIN(test_insert_iter_remove) {
 	    ZU(0), ckh_count(&ckh));
 	ckh_delete(tsd, &ckh);
 #undef NITEMS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_new_delete,
 	    test_count_insert_search_remove,
diff --git a/deps/jemalloc/test/unit/decay.c b/deps/jemalloc/test/unit/decay.c
index f727bf9..de8deff 100644
--- a/deps/jemalloc/test/unit/decay.c
+++ b/deps/jemalloc/test/unit/decay.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/ticker.h"
@@ -15,14 +16,17 @@ check_background_thread_enabled(void) {
 	size_t sz = sizeof(bool);
 	int ret = mallctl("background_thread", (void *)&enabled, &sz, NULL,0);
 	if (ret == ENOENT) {
+		__A_VARIABLE = 1;
 		return false;
 	}
 	assert_d_eq(ret, 0, "Unexpected mallctl error");
+	__A_VARIABLE = 1;
 	return enabled;
 }
 
 static bool
 nstime_monotonic_mock(void) {
+	__A_VARIABLE = 1;
 	return monotonic_mock;
 }
 
@@ -32,6 +36,7 @@ nstime_update_mock(nstime_t *time) {
 	if (monotonic_mock) {
 		nstime_copy(time, &time_mock);
 	}
+	__A_VARIABLE = 1;
 	return !monotonic_mock;
 }
 
@@ -58,6 +63,7 @@ do_arena_create(ssize_t dirty_decay_ms, ssize_t muzzy_decay_ms) {
 	    (void *)&muzzy_decay_ms, sizeof(muzzy_decay_ms)), 0,
 	    "Unexpected mallctlbymib() failure");
 
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
@@ -70,6 +76,7 @@ do_arena_destroy(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 void
@@ -77,6 +84,7 @@ do_epoch(void) {
 	uint64_t epoch = 1;
 	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
 	    0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 
 void
@@ -88,6 +96,7 @@ do_purge(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 void
@@ -99,6 +108,7 @@ do_decay(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static uint64_t
@@ -112,24 +122,28 @@ get_arena_npurge_impl(const char *mibname, unsigned arena_ind) {
 	size_t sz = sizeof(npurge);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&npurge, &sz, NULL, 0),
 	    config_stats ? 0 : ENOENT, "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return npurge;
 }
 
 static uint64_t
 get_arena_dirty_npurge(unsigned arena_ind) {
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.dirty_npurge", arena_ind);
 }
 
 static uint64_t
 get_arena_muzzy_npurge(unsigned arena_ind) {
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.muzzy_npurge", arena_ind);
 }
 
 static uint64_t
 get_arena_npurge(unsigned arena_ind) {
 	do_epoch();
+	__A_VARIABLE = 1;
 	return get_arena_npurge_impl("stats.arenas.0.dirty_npurge", arena_ind) +
 	    get_arena_npurge_impl("stats.arenas.0.muzzy_npurge", arena_ind);
 }
@@ -146,6 +160,7 @@ get_arena_pdirty(unsigned arena_ind) {
 	size_t sz = sizeof(pdirty);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&pdirty, &sz, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return pdirty;
 }
 
@@ -161,6 +176,7 @@ get_arena_pmuzzy(unsigned arena_ind) {
 	size_t sz = sizeof(pmuzzy);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&pmuzzy, &sz, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 	return pmuzzy;
 }
 
@@ -168,6 +184,7 @@ static void *
 do_mallocx(size_t size, int flags) {
 	void *p = mallocx(size, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
+	__A_VARIABLE = 1;
 	return p;
 }
 
@@ -176,6 +193,7 @@ generate_dirty(unsigned arena_ind, size_t size) {
 	int flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
 	void *p = do_mallocx(size, flags);
 	dallocx(p, flags);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_decay_ticks) {
@@ -369,6 +387,7 @@ TEST_BEGIN(test_decay_ticks) {
 			    "flush (sz=%zu)", sz);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -477,6 +496,7 @@ TEST_BEGIN(test_decay_ticker) {
 	nstime_monotonic = nstime_monotonic_orig;
 	nstime_update = nstime_update_orig;
 #undef NPS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -535,6 +555,7 @@ TEST_BEGIN(test_decay_nonmonotonic) {
 	nstime_monotonic = nstime_monotonic_orig;
 	nstime_update = nstime_update_orig;
 #undef NPS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -555,6 +576,7 @@ TEST_BEGIN(test_decay_now) {
 		    "Unexpected muzzy pages");
 	}
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -585,11 +607,13 @@ TEST_BEGIN(test_decay_never) {
 		pdirty_prev = pdirty;
 	}
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_decay_ticks,
 	    test_decay_ticker,
diff --git a/deps/jemalloc/test/unit/div.c b/deps/jemalloc/test/unit/div.c
index b47f10b..3ec9260 100644
--- a/deps/jemalloc/test/unit/div.c
+++ b/deps/jemalloc/test/unit/div.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/div.h"
@@ -19,11 +20,13 @@ TEST_BEGIN(test_div_exhaustive) {
 			    "got quotient %zu", divisor, dividend, quotient);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_div_exhaustive);
 }
diff --git a/deps/jemalloc/test/unit/emitter.c b/deps/jemalloc/test/unit/emitter.c
index 535c7cf..3637b45 100644
--- a/deps/jemalloc/test/unit/emitter.c
+++ b/deps/jemalloc/test/unit/emitter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 #include "jemalloc/internal/emitter.h"
 
@@ -62,6 +63,7 @@ forwarding_cb(void *buf_descriptor_v, const char *str) {
 	buf_descriptor->buf += written;
 	buf_descriptor->len -= written;
 	assert_zu_gt(buf_descriptor->len, 0, "Buffer out of space!");
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -88,6 +90,7 @@ assert_emit_output(void (*emit_fn)(emitter_t *),
 	    &buf_descriptor);
 	(*emit_fn)(&emitter);
 	assert_str_eq(expected_table_output, buf, "table output failure");
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -107,6 +110,7 @@ emit_dict(emitter_t *emitter) {
 	    "note_key2", emitter_type_bool, &b_false);
 	emitter_dict_end(emitter);
 	emitter_end(emitter);
+	__A_VARIABLE = 1;
 }
 static const char *dict_json =
 "{\n"
@@ -126,6 +130,7 @@ static const char *dict_table =
 
 TEST_BEGIN(test_dict) {
 	assert_emit_output(&emit_dict, dict_json, dict_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -149,6 +154,7 @@ static const char *table_printf_table =
 TEST_BEGIN(test_table_printf) {
 	assert_emit_output(&emit_table_printf, table_printf_json,
 	    table_printf_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -194,6 +200,7 @@ static const char *nested_dict_table =
 TEST_BEGIN(test_nested_dict) {
 	assert_emit_output(&emit_nested_dict, nested_dict_json,
 	    nested_dict_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -248,6 +255,7 @@ static const char *types_table =
 
 TEST_BEGIN(test_types) {
 	assert_emit_output(&emit_types, types_json, types_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -294,6 +302,7 @@ const char *modal_table =
 
 TEST_BEGIN(test_modal) {
 	assert_emit_output(&emit_modal, modal_json, modal_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -340,6 +349,7 @@ static const char *json_arr_table = "";
 
 TEST_BEGIN(test_json_arr) {
 	assert_emit_output(&emit_json_arr, json_arr_json, json_arr_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -397,11 +407,13 @@ static const char *table_row_table =
 
 TEST_BEGIN(test_table_row) {
 	assert_emit_output(&emit_table_row, table_row_json, table_row_table);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_dict,
 	    test_table_printf,
diff --git a/deps/jemalloc/test/unit/extent_quantize.c b/deps/jemalloc/test/unit/extent_quantize.c
index 0ca7a75..a0a6b19 100644
--- a/deps/jemalloc/test/unit/extent_quantize.c
+++ b/deps/jemalloc/test/unit/extent_quantize.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_small_extent_size) {
@@ -31,6 +32,7 @@ TEST_BEGIN(test_small_extent_size) {
 		    "Small extent quantization should be a no-op "
 		    "(extent_size=%zu)", extent_size);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -95,6 +97,7 @@ TEST_BEGIN(test_large_extent_size) {
 			    PAGE);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -129,11 +132,13 @@ TEST_BEGIN(test_monotonic) {
 		floor_prev = floor;
 		ceil_prev = ceil;
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_small_extent_size,
 	    test_large_extent_size,
diff --git a/deps/jemalloc/test/unit/fork.c b/deps/jemalloc/test/unit/fork.c
index b169075..0557f36 100644
--- a/deps/jemalloc/test/unit/fork.c
+++ b/deps/jemalloc/test/unit/fork.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #ifndef _WIN32
@@ -25,6 +26,7 @@ wait_for_child_exit(int pid) {
 			break;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -69,6 +71,7 @@ TEST_BEGIN(test_fork) {
 #else
 	test_skip("fork(2) is irrelevant to Windows");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -100,6 +103,7 @@ do_test_fork_multithreaded() {
 	thd_create(&child, do_fork_thd, NULL);
 	do_fork_thd(NULL);
 	thd_join(child, NULL);
+	__A_VARIABLE = 1;
 }
 #endif
 
@@ -130,11 +134,13 @@ TEST_BEGIN(test_fork_multithreaded) {
 #else
 	test_skip("fork(2) is irrelevant to Windows");
 #endif
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_fork,
 	    test_fork_multithreaded);
diff --git a/deps/jemalloc/test/unit/hash.c b/deps/jemalloc/test/unit/hash.c
index 7cc034f..8b90892 100644
--- a/deps/jemalloc/test/unit/hash.c
+++ b/deps/jemalloc/test/unit/hash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * This file is based on code that is part of SMHasher
  * (https://code.google.com/p/smhasher/), and is subject to the MIT license
diff --git a/deps/jemalloc/test/unit/hooks.c b/deps/jemalloc/test/unit/hooks.c
index b70172e..0f03d5a 100644
--- a/deps/jemalloc/test/unit/hooks.c
+++ b/deps/jemalloc/test/unit/hooks.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static bool hook_called = false;
@@ -5,10 +6,12 @@ static bool hook_called = false;
 static void
 hook() {
 	hook_called = true;
+	__A_VARIABLE = 1;
 }
 
 static int
 func_to_hook(int arg1, int arg2) {
+	__A_VARIABLE = 1;
 	return arg1 + arg2;
 }
 
@@ -19,6 +22,7 @@ TEST_BEGIN(unhooked_call) {
 	hook_called = false;
 	assert_d_eq(3, func_to_hook(1, 2), "Hooking changed return value.");
 	assert_false(hook_called, "Nulling out hook didn't take.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -27,11 +31,13 @@ TEST_BEGIN(hooked_call) {
 	hook_called = false;
 	assert_d_eq(3, func_to_hook(1, 2), "Hooking changed return value.");
 	assert_true(hook_called, "Hook should have executed.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    unhooked_call,
 	    hooked_call);
diff --git a/deps/jemalloc/test/unit/junk.c b/deps/jemalloc/test/unit/junk.c
index 243ced4..9e9f4b7 100644
--- a/deps/jemalloc/test/unit/junk.c
+++ b/deps/jemalloc/test/unit/junk.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/util.h"
@@ -12,6 +13,7 @@ static void
 watch_junking(void *p) {
 	watch_for_junking = p;
 	saw_junking = false;
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -27,6 +29,7 @@ arena_dalloc_junk_small_intercept(void *ptr, const bin_info_t *bin_info) {
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -42,6 +45,7 @@ large_dalloc_junk_intercept(void *ptr, size_t usize) {
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -50,6 +54,7 @@ large_dalloc_maybe_junk_intercept(void *ptr, size_t usize) {
 	if (ptr == watch_for_junking) {
 		saw_junking = true;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -119,22 +124,26 @@ test_junk(size_t sz_min, size_t sz_max) {
 		large_dalloc_junk = large_dalloc_junk_orig;
 		large_dalloc_maybe_junk = large_dalloc_maybe_junk_orig;
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_junk_small) {
 	test_skip_if(!config_fill);
 	test_junk(1, SMALL_MAXCLASS-1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_junk_large) {
 	test_skip_if(!config_fill);
 	test_junk(SMALL_MAXCLASS+1, (1U << (LG_LARGE_MINCLASS+1)));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_junk_small,
 	    test_junk_large);
diff --git a/deps/jemalloc/test/unit/junk_alloc.c b/deps/jemalloc/test/unit/junk_alloc.c
index a442a0c..92006c7 100644
--- a/deps/jemalloc/test/unit/junk_alloc.c
+++ b/deps/jemalloc/test/unit/junk_alloc.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 #include "junk.c"
diff --git a/deps/jemalloc/test/unit/junk_free.c b/deps/jemalloc/test/unit/junk_free.c
index a442a0c..92006c7 100644
--- a/deps/jemalloc/test/unit/junk_free.c
+++ b/deps/jemalloc/test/unit/junk_free.c
@@ -1 +1,2 @@
+static volatile int __A_VARIABLE;
 #include "junk.c"
diff --git a/deps/jemalloc/test/unit/log.c b/deps/jemalloc/test/unit/log.c
index a52bd73..c2a6bf5 100644
--- a/deps/jemalloc/test/unit/log.c
+++ b/deps/jemalloc/test/unit/log.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/log.h"
@@ -37,6 +38,7 @@ TEST_BEGIN(test_log_disabled) {
 	expect_no_logging("l12");
 	expect_no_logging("l123|a456|b789");
 	expect_no_logging("|||");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -178,11 +180,13 @@ TEST_BEGIN(test_log_only_format_string) {
 	if (false) {
 		LOG("log_str", "No arguments follow this format string.");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_log_disabled,
 	    test_log_enabled_direct,
diff --git a/deps/jemalloc/test/unit/mallctl.c b/deps/jemalloc/test/unit/mallctl.c
index 1ecbab0..8dee355 100644
--- a/deps/jemalloc/test/unit/mallctl.c
+++ b/deps/jemalloc/test/unit/mallctl.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/util.h"
@@ -26,6 +27,7 @@ TEST_BEGIN(test_mallctl_errors) {
 	sz = sizeof(epoch)+1;
 	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
 	    "mallctl() should return EINVAL for output size mismatch");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -36,6 +38,7 @@ TEST_BEGIN(test_mallctlnametomib_errors) {
 	miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("no_such_name", mib, &miblen), ENOENT,
 	    "mallctlnametomib() should return ENOENT for non-existent names");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -72,6 +75,7 @@ TEST_BEGIN(test_mallctlbymib_errors) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
 	    EINVAL,
 	    "mallctlbymib() should return EINVAL for output size mismatch");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -99,6 +103,7 @@ TEST_BEGIN(test_mallctl_read_write) {
 	    (void *)&new_epoch, sizeof(new_epoch)), 0,
 	    "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -113,6 +118,7 @@ TEST_BEGIN(test_mallctlnametomib_short_mib) {
 	assert_zu_eq(miblen, 3, "Unexpected mib output length");
 	assert_zu_eq(mib[3], 42,
 	    "mallctlnametomib() wrote past the end of the input mib");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -139,6 +145,7 @@ TEST_BEGIN(test_mallctl_config) {
 	TEST_MALLCTL_CONFIG(xmalloc, bool);
 
 #undef TEST_MALLCTL_CONFIG
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -186,6 +193,7 @@ TEST_BEGIN(test_mallctl_opt) {
 	TEST_MALLCTL_OPT(bool, prof_leak, prof);
 
 #undef TEST_MALLCTL_OPT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -210,6 +218,7 @@ TEST_BEGIN(test_manpage_example) {
 		    NULL, 0), 0, "Unexpected mallctlbymib() failure");
 		/* Do something with bin_size... */
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -233,6 +242,7 @@ TEST_BEGIN(test_tcache_none) {
 
 	/* Clean up. */
 	dallocx(p1, MALLOCX_TCACHE_NONE);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -326,6 +336,7 @@ TEST_BEGIN(test_tcache) {
 		    (void *)&tis[i], sizeof(unsigned)), 0,
 		    "Unexpected mallctl() failure, i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -362,6 +373,7 @@ TEST_BEGIN(test_thread_arena) {
 			    "should not be allowed with percpu arena");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -400,6 +412,7 @@ TEST_BEGIN(test_arena_i_initialized) {
 	    "Unexpected mallctl() failure");
 	assert_true(initialized,
 	    "Merged arena statistics should always be initialized");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -432,6 +445,7 @@ TEST_BEGIN(test_arena_i_dirty_decay_ms) {
 		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
 		    "Unexpected old arena.0.dirty_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -464,6 +478,7 @@ TEST_BEGIN(test_arena_i_muzzy_decay_ms) {
 		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
 		    "Unexpected old arena.0.muzzy_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -487,6 +502,7 @@ TEST_BEGIN(test_arena_i_purge) {
 	mib[1] = MALLCTL_ARENAS_ALL;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -510,6 +526,7 @@ TEST_BEGIN(test_arena_i_decay) {
 	mib[1] = MALLCTL_ARENAS_ALL;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -555,6 +572,7 @@ TEST_BEGIN(test_arena_i_dss) {
 	    0), 0, "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected value for dss precedence");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -603,6 +621,7 @@ TEST_BEGIN(test_arena_i_retain_grow_limit) {
 	/* Restore to default. */
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &default_limit,
 	    sizeof(default_limit)), 0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -635,6 +654,7 @@ TEST_BEGIN(test_arenas_dirty_decay_ms) {
 		assert_zd_eq(old_dirty_decay_ms, prev_dirty_decay_ms,
 		    "Unexpected old arenas.dirty_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -667,6 +687,7 @@ TEST_BEGIN(test_arenas_muzzy_decay_ms) {
 		assert_zd_eq(old_muzzy_decay_ms, prev_muzzy_decay_ms,
 		    "Unexpected old arenas.muzzy_decay_ms");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -685,6 +706,7 @@ TEST_BEGIN(test_arenas_constants) {
 	TEST_ARENAS_CONSTANT(unsigned, nlextents, NSIZES - NBINS);
 
 #undef TEST_ARENAS_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -703,6 +725,7 @@ TEST_BEGIN(test_arenas_bin_constants) {
 	    bin_infos[0].slab_size);
 
 #undef TEST_ARENAS_BIN_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -718,6 +741,7 @@ TEST_BEGIN(test_arenas_lextent_constants) {
 	TEST_ARENAS_LEXTENT_CONSTANT(size_t, size, LARGE_MINCLASS);
 
 #undef TEST_ARENAS_LEXTENT_CONSTANT
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -735,6 +759,7 @@ TEST_BEGIN(test_arenas_create) {
 	assert_u_eq(narenas_before+1, narenas_after,
 	    "Unexpected number of arenas before versus after extension");
 	assert_u_eq(arena, narenas_after-1, "Unexpected arena index");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -751,6 +776,7 @@ TEST_BEGIN(test_arenas_lookup) {
 	    0, "Unexpected mallctl() failure");
 	assert_u_eq(arena, arena1, "Unexpected arena index");
 	dallocx(ptr, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -770,11 +796,13 @@ TEST_BEGIN(test_stats_arenas) {
 	TEST_STATS_ARENAS(size_t, pdirty);
 
 #undef TEST_STATS_ARENAS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_mallctl_errors,
 	    test_mallctlnametomib_errors,
diff --git a/deps/jemalloc/test/unit/malloc_io.c b/deps/jemalloc/test/unit/malloc_io.c
index 79ba7fc..44d1cf4 100644
--- a/deps/jemalloc/test/unit/malloc_io.c
+++ b/deps/jemalloc/test/unit/malloc_io.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_malloc_strtoumax_no_endptr) {
@@ -7,6 +8,7 @@ TEST_BEGIN(test_malloc_strtoumax_no_endptr) {
 	assert_ju_eq(malloc_strtoumax("0", NULL, 0), 0, "Unexpected result");
 	err = get_errno();
 	assert_d_eq(err, 0, "Unexpected failure");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -101,6 +103,7 @@ TEST_BEGIN(test_malloc_strtoumax) {
 			    test->input, test->base);
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -133,6 +136,7 @@ TEST_BEGIN(test_malloc_snprintf_truncated) {
 	}
 #undef BUFLEN
 #undef TEST
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -245,11 +249,13 @@ TEST_BEGIN(test_malloc_snprintf) {
 	TEST("_0x1234abc_", "_%#zx_", ((ssize_t)0x1234abc));
 	TEST("_0X1234ABC_", "_%#zX_", ((ssize_t)0x1234ABC));
 #undef BUFLEN
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_malloc_strtoumax_no_endptr,
 	    test_malloc_strtoumax,
diff --git a/deps/jemalloc/test/unit/math.c b/deps/jemalloc/test/unit/math.c
index 09ef20c..36e661e 100644
--- a/deps/jemalloc/test/unit/math.c
+++ b/deps/jemalloc/test/unit/math.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define MAX_REL_ERR 1.0e-9
@@ -18,9 +19,11 @@ double_eq_rel(double a, double b, double max_rel_err, double max_abs_err) {
 	double rel_err;
 
 	if (fabs(a - b) < max_abs_err) {
+		__A_VARIABLE = 1;
 		return true;
 	}
 	rel_err = (fabs(b) > fabs(a)) ? fabs((a-b)/b) : fabs((a-b)/a);
+	__A_VARIABLE = 1;
 	return (rel_err < max_rel_err);
 }
 
@@ -33,6 +36,7 @@ factorial(unsigned x) {
 		ret *= (uint64_t)i;
 	}
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -45,6 +49,7 @@ TEST_BEGIN(test_ln_gamma_factorial) {
 		    (double)factorial(x-1), MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect factorial result for x=%u", x);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -196,6 +201,7 @@ TEST_BEGIN(test_ln_gamma_misc) {
 		    ln_gamma_misc_expected[i], MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect ln_gamma result for i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -246,6 +252,7 @@ TEST_BEGIN(test_pt_norm) {
 		    MAX_REL_ERR, MAX_ABS_ERR),
 		    "Incorrect pt_norm result for i=%u", i);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -301,6 +308,7 @@ TEST_BEGIN(test_pt_chi2) {
 			e++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -363,6 +371,7 @@ TEST_BEGIN(test_pt_gamma_shape) {
 			e++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -375,11 +384,13 @@ TEST_BEGIN(test_pt_gamma_scale) {
 	    pt_gamma(0.5, shape, 10.0, ln_gamma_shape), MAX_REL_ERR,
 	    MAX_ABS_ERR),
 	    "Scale should be trivially equivalent to external multiplication");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_ln_gamma_factorial,
 	    test_ln_gamma_misc,
diff --git a/deps/jemalloc/test/unit/mq.c b/deps/jemalloc/test/unit/mq.c
index 57a4d54..c44336f 100644
--- a/deps/jemalloc/test/unit/mq.c
+++ b/deps/jemalloc/test/unit/mq.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NSENDERS	3
@@ -26,6 +27,7 @@ TEST_BEGIN(test_mq_basic) {
 	assert_ptr_eq(mq_get(&mq), &msg, "mq_get() should return msg");
 
 	mq_fini(&mq);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -55,6 +57,7 @@ thd_sender_start(void *arg) {
 		msg = (mq_msg_t *)p;
 		mq_put(mq, msg);
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -77,11 +80,13 @@ TEST_BEGIN(test_mq_threaded) {
 	}
 
 	mq_fini(&mq);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_mq_basic,
 	    test_mq_threaded);
diff --git a/deps/jemalloc/test/unit/mtx.c b/deps/jemalloc/test/unit/mtx.c
index 424587b..760f4f9 100644
--- a/deps/jemalloc/test/unit/mtx.c
+++ b/deps/jemalloc/test/unit/mtx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NTHREADS	2
@@ -10,6 +11,7 @@ TEST_BEGIN(test_mtx_basic) {
 	mtx_lock(&mtx);
 	mtx_unlock(&mtx);
 	mtx_fini(&mtx);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -28,6 +30,7 @@ thd_start(void *varg) {
 		arg->x++;
 		mtx_unlock(&arg->mtx);
 	}
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -46,11 +49,13 @@ TEST_BEGIN(test_mtx_race) {
 	}
 	assert_u_eq(arg.x, NTHREADS * NINCRS,
 	    "Race-related counter corruption");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_mtx_basic,
 	    test_mtx_race);
diff --git a/deps/jemalloc/test/unit/nstime.c b/deps/jemalloc/test/unit/nstime.c
index f313780..208618b 100644
--- a/deps/jemalloc/test/unit/nstime.c
+++ b/deps/jemalloc/test/unit/nstime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define BILLION	UINT64_C(1000000000)
@@ -9,6 +10,7 @@ TEST_BEGIN(test_nstime_init) {
 	assert_u64_eq(nstime_ns(&nst), 42000000043, "ns incorrectly read");
 	assert_u64_eq(nstime_sec(&nst), 42, "sec incorrectly read");
 	assert_u64_eq(nstime_nsec(&nst), 43, "nsec incorrectly read");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -18,6 +20,7 @@ TEST_BEGIN(test_nstime_init2) {
 	nstime_init2(&nst, 42, 43);
 	assert_u64_eq(nstime_sec(&nst), 42, "sec incorrectly read");
 	assert_u64_eq(nstime_nsec(&nst), 43, "nsec incorrectly read");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -29,6 +32,7 @@ TEST_BEGIN(test_nstime_copy) {
 	nstime_copy(&nstb, &nsta);
 	assert_u64_eq(nstime_sec(&nstb), 42, "sec incorrectly copied");
 	assert_u64_eq(nstime_nsec(&nstb), 43, "nsec incorrectly copied");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -63,6 +67,7 @@ TEST_BEGIN(test_nstime_compare) {
 	    "nsta should be less than nstb");
 	assert_d_eq(nstime_compare(&nstb, &nsta), 1,
 	    "nstb should be greater than nsta");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -82,6 +87,7 @@ TEST_BEGIN(test_nstime_add) {
 	nstime_init2(&nstb, 85, BILLION - 2);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect addition result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -99,6 +105,7 @@ TEST_BEGIN(test_nstime_iadd) {
 	nstime_init2(&nstb, 43, 2);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect addition result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -118,6 +125,7 @@ TEST_BEGIN(test_nstime_subtract) {
 	nstime_init2(&nstb, 0, BILLION - 1);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect subtraction result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -135,6 +143,7 @@ TEST_BEGIN(test_nstime_isubtract) {
 	nstime_init2(&nstb, 0, BILLION - 1);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect subtraction result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -152,6 +161,7 @@ TEST_BEGIN(test_nstime_imultiply) {
 	nstime_init2(&nstb, 127, 999999998);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect multiplication result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -171,6 +181,7 @@ TEST_BEGIN(test_nstime_idivide) {
 	nstime_idivide(&nsta, 3);
 	assert_d_eq(nstime_compare(&nsta, &nstb), 0,
 	    "Incorrect division result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -198,11 +209,13 @@ TEST_BEGIN(test_nstime_divide) {
 	nstime_subtract(&nsta, &nstc);
 	assert_u64_eq(nstime_divide(&nsta, &nstb), 9,
 	    "Incorrect division result");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_nstime_monotonic) {
 	nstime_monotonic();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -226,12 +239,14 @@ TEST_BEGIN(test_nstime_update) {
 		    "Update should detect time roll-back.");
 		assert_d_eq(nstime_compare(&nst, &nst0), 0,
 		    "Time should not have been modified");
+		__A_VARIABLE = 1;
 	}
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_nstime_init,
 	    test_nstime_init2,
diff --git a/deps/jemalloc/test/unit/pack.c b/deps/jemalloc/test/unit/pack.c
index fc188b0..818c1d6 100644
--- a/deps/jemalloc/test/unit/pack.c
+++ b/deps/jemalloc/test/unit/pack.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 /*
@@ -38,11 +39,13 @@ binind_compute(void) {
 		assert_d_eq(mallctlbymib(mib, miblen, (void *)&size, &sz, NULL,
 		    0), 0, "Unexpected mallctlbymib failure");
 		if (size == SZ) {
+			__A_VARIABLE = 1;
 			return i;
 		}
 	}
 
 	test_fail("Unable to compute nregs_per_run");
+	__A_VARIABLE = 1;
 	return 0;
 }
 
@@ -60,6 +63,7 @@ nregs_per_run_compute(void) {
 	sz = sizeof(nregs);
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&nregs, &sz, NULL,
 	    0), 0, "Unexpected mallctlbymib failure");
+	__A_VARIABLE = 1;
 	return nregs;
 }
 
@@ -72,6 +76,7 @@ arenas_create_mallctl(void) {
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz, NULL, 0),
 	    0, "Error in arenas.create");
 
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
@@ -85,6 +90,7 @@ arena_reset_mallctl(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_pack) {
@@ -156,11 +162,13 @@ TEST_BEGIN(test_pack) {
 
 	/* Clean up. */
 	arena_reset_mallctl(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_pack);
 }
diff --git a/deps/jemalloc/test/unit/pages.c b/deps/jemalloc/test/unit/pages.c
index ee729ee..341ca2b 100644
--- a/deps/jemalloc/test/unit/pages.c
+++ b/deps/jemalloc/test/unit/pages.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_pages_huge) {
@@ -19,11 +20,13 @@ TEST_BEGIN(test_pages_huge) {
 	}
 
 	pages_unmap(pages, alloc_size);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_pages_huge);
 }
diff --git a/deps/jemalloc/test/unit/ph.c b/deps/jemalloc/test/unit/ph.c
index 88bf56f..938c39a 100644
--- a/deps/jemalloc/test/unit/ph.c
+++ b/deps/jemalloc/test/unit/ph.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/ph.h"
@@ -24,6 +25,7 @@ node_cmp(const node_t *a, const node_t *b) {
 		ret = (((uintptr_t)a) > ((uintptr_t)b))
 		    - (((uintptr_t)a) < ((uintptr_t)b));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -33,6 +35,7 @@ node_cmp_magic(const node_t *a, const node_t *b) {
 	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
 	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
 
+	__A_VARIABLE = 1;
 	return node_cmp(a, b);
 }
 
@@ -51,6 +54,7 @@ node_print(const node_t *node, unsigned depth) {
 
 	leftmost_child = phn_lchild_get(node_t, link, node);
 	if (leftmost_child == NULL) {
+		__A_VARIABLE = 1;
 		return;
 	}
 	node_print(leftmost_child, depth + 1);
@@ -59,6 +63,7 @@ node_print(const node_t *node, unsigned depth) {
 	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
 		node_print(sibling, depth + 1);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -82,6 +87,7 @@ heap_print(const heap_t *heap) {
 
 label_return:
 	malloc_printf("^^^ heap %p ^^^\n", heap);
+	__A_VARIABLE = 1;
 }
 
 static unsigned
@@ -96,6 +102,7 @@ node_validate(const node_t *node, const node_t *parent) {
 
 	leftmost_child = phn_lchild_get(node_t, link, node);
 	if (leftmost_child == NULL) {
+		__A_VARIABLE = 1;
 		return nnodes;
 	}
 	assert_ptr_eq((void *)phn_prev_get(node_t, link, leftmost_child),
@@ -109,6 +116,7 @@ node_validate(const node_t *node, const node_t *parent) {
 		    "sibling's prev doesn't link to sibling");
 		nnodes += node_validate(sibling, node);
 	}
+	__A_VARIABLE = 1;
 	return nnodes;
 }
 
@@ -135,6 +143,7 @@ label_return:
 	if (false) {
 		heap_print(heap);
 	}
+	__A_VARIABLE = 1;
 	return nnodes;
 }
 
@@ -145,6 +154,7 @@ TEST_BEGIN(test_ph_empty) {
 	assert_true(heap_empty(&heap), "Heap should be empty");
 	assert_ptr_null(heap_first(&heap), "Unexpected node");
 	assert_ptr_null(heap_any(&heap), "Unexpected node");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -159,6 +169,7 @@ static node_t *
 node_remove_first(heap_t *heap) {
 	node_t *node = heap_remove_first(heap);
 	node->magic = 0;
+	__A_VARIABLE = 1;
 	return node;
 }
 
@@ -166,6 +177,7 @@ static node_t *
 node_remove_any(heap_t *heap) {
 	node_t *node = heap_remove_any(heap);
 	node->magic = 0;
+	__A_VARIABLE = 1;
 	return node;
 }
 
@@ -307,11 +319,13 @@ TEST_BEGIN(test_ph_random) {
 	fini_gen_rand(sfmt);
 #undef NNODES
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_ph_empty,
 	    test_ph_random);
diff --git a/deps/jemalloc/test/unit/prng.c b/deps/jemalloc/test/unit/prng.c
index b5795c2..76d26b7 100644
--- a/deps/jemalloc/test/unit/prng.c
+++ b/deps/jemalloc/test/unit/prng.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static void
@@ -35,6 +36,7 @@ test_prng_lg_range_u32(bool atomic) {
 		    "Expected high order bits of full-width result, "
 		    "lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -71,6 +73,7 @@ test_prng_lg_range_u64(void) {
 		    "Expected high order bits of full-width result, "
 		    "lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -109,30 +112,36 @@ test_prng_lg_range_zu(bool atomic) {
 		    lg_range)), "Expected high order bits of full-width "
 		    "result, lg_range=%u", lg_range);
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prng_lg_range_u32_nonatomic) {
 	test_prng_lg_range_u32(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_u32_atomic) {
 	test_prng_lg_range_u32(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_u64_nonatomic) {
 	test_prng_lg_range_u64();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_zu_nonatomic) {
 	test_prng_lg_range_zu(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_lg_range_zu_atomic) {
 	test_prng_lg_range_zu(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -154,6 +163,7 @@ test_prng_range_u32(bool atomic) {
 			assert_u32_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -174,6 +184,7 @@ test_prng_range_u64(void) {
 			assert_u64_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -194,35 +205,42 @@ test_prng_range_zu(bool atomic) {
 			assert_zu_lt(r, range, "Out of range");
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prng_range_u32_nonatomic) {
 	test_prng_range_u32(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_u32_atomic) {
 	test_prng_range_u32(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_u64_nonatomic) {
 	test_prng_range_u64();
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_zu_nonatomic) {
 	test_prng_range_zu(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_prng_range_zu_atomic) {
 	test_prng_range_zu(true);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_prng_lg_range_u32_nonatomic,
 	    test_prng_lg_range_u32_atomic,
diff --git a/deps/jemalloc/test/unit/prof_accum.c b/deps/jemalloc/test/unit/prof_accum.c
index 2522006..70adf62 100644
--- a/deps/jemalloc/test/unit/prof_accum.c
+++ b/deps/jemalloc/test/unit/prof_accum.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #define NTHREADS		4
@@ -12,11 +13,13 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
 static void *
 alloc_from_permuted_backtrace(unsigned thd_ind, unsigned iteration) {
+	__A_VARIABLE = 1;
 	return btalloc(1, thd_ind*NALLOCS_PER_THREAD + iteration);
 }
 
@@ -46,6 +49,7 @@ thd_start(void *varg) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -71,11 +75,13 @@ TEST_BEGIN(test_idump) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_idump);
 }
diff --git a/deps/jemalloc/test/unit/prof_active.c b/deps/jemalloc/test/unit/prof_active.c
index 850a24a..e61044e 100644
--- a/deps/jemalloc/test/unit/prof_active.c
+++ b/deps/jemalloc/test/unit/prof_active.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static void
@@ -10,6 +11,7 @@ mallctl_bool_get(const char *name, bool expected, const char *func, int line) {
 	    "%s():%d: Unexpected mallctl failure reading %s", func, line, name);
 	assert_b_eq(old, expected, "%s():%d: Unexpected %s value", func, line,
 	    name);
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -25,12 +27,14 @@ mallctl_bool_set(const char *name, bool old_expected, bool val_new,
 	    line, name);
 	assert_b_eq(old, old_expected, "%s():%d: Unexpected %s value", func,
 	    line, name);
+	__A_VARIABLE = 1;
 }
 
 static void
 mallctl_prof_active_get_impl(bool prof_active_old_expected, const char *func,
     int line) {
 	mallctl_bool_get("prof.active", prof_active_old_expected, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_prof_active_get(a)					\
 	mallctl_prof_active_get_impl(a, __func__, __LINE__)
@@ -40,6 +44,7 @@ mallctl_prof_active_set_impl(bool prof_active_old_expected,
     bool prof_active_new, const char *func, int line) {
 	mallctl_bool_set("prof.active", prof_active_old_expected,
 	    prof_active_new, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_prof_active_set(a, b)					\
 	mallctl_prof_active_set_impl(a, b, __func__, __LINE__)
@@ -49,6 +54,7 @@ mallctl_thread_prof_active_get_impl(bool thread_prof_active_old_expected,
     const char *func, int line) {
 	mallctl_bool_get("thread.prof.active", thread_prof_active_old_expected,
 	    func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_prof_active_get(a)				\
 	mallctl_thread_prof_active_get_impl(a, __func__, __LINE__)
@@ -58,6 +64,7 @@ mallctl_thread_prof_active_set_impl(bool thread_prof_active_old_expected,
     bool thread_prof_active_new, const char *func, int line) {
 	mallctl_bool_set("thread.prof.active", thread_prof_active_old_expected,
 	    thread_prof_active_new, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_prof_active_set(a, b)				\
 	mallctl_thread_prof_active_set_impl(a, b, __func__, __LINE__)
@@ -74,6 +81,7 @@ prof_sampling_probe_impl(bool expect_sample, const char *func, int line) {
 	assert_zu_eq(prof_bt_count(), expected_backtraces,
 	    "%s():%d: Unexpected backtrace count", func, line);
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 #define prof_sampling_probe(a)						\
 	prof_sampling_probe_impl(a, __func__, __LINE__)
@@ -107,11 +115,13 @@ TEST_BEGIN(test_prof_active) {
 	/* Restore settings. */
 	mallctl_prof_active_set(true, true);
 	mallctl_thread_prof_active_set(true, false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_active);
 }
diff --git a/deps/jemalloc/test/unit/prof_gdump.c b/deps/jemalloc/test/unit/prof_gdump.c
index fcb434c..1c49975 100644
--- a/deps/jemalloc/test/unit/prof_gdump.c
+++ b/deps/jemalloc/test/unit/prof_gdump.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static bool did_prof_dump_open;
@@ -11,6 +12,7 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
@@ -64,11 +66,13 @@ TEST_BEGIN(test_gdump) {
 	dallocx(q, 0);
 	dallocx(r, 0);
 	dallocx(s, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_gdump);
 }
diff --git a/deps/jemalloc/test/unit/prof_idump.c b/deps/jemalloc/test/unit/prof_idump.c
index 1cc6c98..fca0cca 100644
--- a/deps/jemalloc/test/unit/prof_idump.c
+++ b/deps/jemalloc/test/unit/prof_idump.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static bool did_prof_dump_open;
@@ -11,6 +12,7 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
@@ -32,11 +34,13 @@ TEST_BEGIN(test_idump) {
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 	dallocx(p, 0);
 	assert_true(did_prof_dump_open, "Expected a profile dump");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_idump);
 }
diff --git a/deps/jemalloc/test/unit/prof_reset.c b/deps/jemalloc/test/unit/prof_reset.c
index 7cce42d..9842fdb 100644
--- a/deps/jemalloc/test/unit/prof_reset.c
+++ b/deps/jemalloc/test/unit/prof_reset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static int
@@ -7,6 +8,7 @@ prof_dump_open_intercept(bool propagate_err, const char *filename) {
 	fd = open("/dev/null", O_WRONLY);
 	assert_d_ne(fd, -1, "Unexpected open() failure");
 
+	__A_VARIABLE = 1;
 	return fd;
 }
 
@@ -14,6 +16,7 @@ static void
 set_prof_active(bool active) {
 	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
 	    sizeof(active)), 0, "Unexpected mallctl failure");
+	__A_VARIABLE = 1;
 }
 
 static size_t
@@ -24,6 +27,7 @@ get_lg_prof_sample(void) {
 	assert_d_eq(mallctl("prof.lg_sample", (void *)&lg_prof_sample, &sz,
 	    NULL, 0), 0,
 	    "Unexpected mallctl failure while reading profiling sample rate");
+	__A_VARIABLE = 1;
 	return lg_prof_sample;
 }
 
@@ -34,6 +38,7 @@ do_prof_reset(size_t lg_prof_sample) {
 	    "Unexpected mallctl failure while resetting profile data");
 	assert_zu_eq(lg_prof_sample, get_lg_prof_sample(),
 	    "Expected profile sample rate change");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_prof_reset_basic) {
@@ -78,6 +83,7 @@ TEST_BEGIN(test_prof_reset_basic) {
 	assert_zu_eq(lg_prof_sample_orig, lg_prof_sample,
 	    "Unexpected disagreement between \"opt.lg_prof_sample\" and "
 	    "\"prof.lg_sample\"");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -89,6 +95,7 @@ prof_dump_header_intercept(tsdn_t *tsdn, bool propagate_err,
 	prof_dump_header_intercepted = true;
 	memcpy(&cnt_all_copy, cnt_all, sizeof(prof_cnt_t));
 
+	__A_VARIABLE = 1;
 	return false;
 }
 
@@ -127,6 +134,7 @@ TEST_BEGIN(test_prof_reset_cleanup) {
 	assert_zu_eq(prof_bt_count(), 0, "Expected 0 backtraces");
 
 	set_prof_active(false);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -176,6 +184,7 @@ thd_start(void *varg) {
 		}
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -214,6 +223,7 @@ TEST_BEGIN(test_prof_reset) {
 	set_prof_active(false);
 
 	do_prof_reset(lg_prof_sample_orig);
+	__A_VARIABLE = 1;
 }
 TEST_END
 #undef NTHREADS
@@ -278,6 +288,7 @@ main(void) {
 	/* Intercept dumping prior to running any tests. */
 	prof_dump_open = prof_dump_open_intercept;
 
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_reset_basic,
 	    test_prof_reset_cleanup,
diff --git a/deps/jemalloc/test/unit/prof_tctx.c b/deps/jemalloc/test/unit/prof_tctx.c
index ff3b2b0..d2cbd62 100644
--- a/deps/jemalloc/test/unit/prof_tctx.c
+++ b/deps/jemalloc/test/unit/prof_tctx.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_prof_realloc) {
@@ -36,11 +37,13 @@ TEST_BEGIN(test_prof_realloc) {
 	prof_cnt_all(&curobjs_3, NULL, NULL, NULL);
 	assert_u64_eq(curobjs_0, curobjs_3,
 	    "Sample size should have returned to base level");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_prof_realloc);
 }
diff --git a/deps/jemalloc/test/unit/prof_thread_name.c b/deps/jemalloc/test/unit/prof_thread_name.c
index c9c2a2b..940fd1f 100644
--- a/deps/jemalloc/test/unit/prof_thread_name.c
+++ b/deps/jemalloc/test/unit/prof_thread_name.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static void
@@ -13,6 +14,7 @@ mallctl_thread_name_get_impl(const char *thread_name_expected, const char *func,
 	    func, line);
 	assert_str_eq(thread_name_old, thread_name_expected,
 	    "%s():%d: Unexpected thread.prof.name value", func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_name_get(a)					\
 	mallctl_thread_name_get_impl(a, __func__, __LINE__)
@@ -25,6 +27,7 @@ mallctl_thread_name_set_impl(const char *thread_name, const char *func,
 	    "%s():%d: Unexpected mallctl failure reading thread.prof.name",
 	    func, line);
 	mallctl_thread_name_get_impl(thread_name, func, line);
+	__A_VARIABLE = 1;
 }
 #define mallctl_thread_name_set(a)					\
 	mallctl_thread_name_set_impl(a, __func__, __LINE__)
@@ -65,6 +68,7 @@ TEST_BEGIN(test_prof_thread_name_validation) {
 	}
 
 	mallctl_thread_name_set("");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -107,6 +111,7 @@ TEST_BEGIN(test_prof_thread_name_threaded) {
 	for (i = 0; i < NTHREADS; i++) {
 		thd_join(thds[i], NULL);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 #undef NTHREADS
@@ -114,6 +119,7 @@ TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_prof_thread_name_validation,
 	    test_prof_thread_name_threaded);
diff --git a/deps/jemalloc/test/unit/ql.c b/deps/jemalloc/test/unit/ql.c
index b76c24c..d39a0d1 100644
--- a/deps/jemalloc/test/unit/ql.c
+++ b/deps/jemalloc/test/unit/ql.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/ql.h"
@@ -33,6 +34,7 @@ test_empty_list(list_head_t *head) {
 		i++;
 	}
 	assert_u_eq(i, 0, "Unexpected element for empty list");
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_ql_empty) {
@@ -40,6 +42,7 @@ TEST_BEGIN(test_ql_empty) {
 
 	ql_new(&head);
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -87,6 +90,7 @@ test_entries_list(list_head_t *head, list_t *entries, unsigned nentries) {
 		t = ql_prev(head, &entries[i], link);
 		assert_c_eq(t->id, entries[i-1].id, "Element id mismatch");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_ql_tail_insert) {
@@ -101,6 +105,7 @@ TEST_BEGIN(test_ql_tail_insert) {
 	}
 
 	test_entries_list(&head, entries, NENTRIES);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -120,6 +125,7 @@ TEST_BEGIN(test_ql_tail_remove) {
 		ql_tail_remove(&head, list_t, link);
 	}
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -135,6 +141,7 @@ TEST_BEGIN(test_ql_head_insert) {
 	}
 
 	test_entries_list(&head, entries, NENTRIES);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -154,6 +161,7 @@ TEST_BEGIN(test_ql_head_remove) {
 		ql_head_remove(&head, list_t, link);
 	}
 	test_empty_list(&head);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -189,11 +197,13 @@ TEST_BEGIN(test_ql_insert) {
 	ql_before_insert(&head, f, e, link);
 
 	test_entries_list(&head, entries, sizeof(entries)/sizeof(list_t));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_ql_empty,
 	    test_ql_tail_insert,
diff --git a/deps/jemalloc/test/unit/qr.c b/deps/jemalloc/test/unit/qr.c
index 271a109..504dfd1 100644
--- a/deps/jemalloc/test/unit/qr.c
+++ b/deps/jemalloc/test/unit/qr.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/qr.h"
@@ -22,6 +23,7 @@ init_entries(ring_t *entries) {
 		qr_new(&entries[i], link);
 		entries[i].id = 'a' + i;
 	}
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -59,6 +61,7 @@ test_independent_entries(ring_t *entries) {
 		    "Previous element in single-element ring should be same as "
 		    "current element");
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_qr_one) {
@@ -66,6 +69,7 @@ TEST_BEGIN(test_qr_one) {
 
 	init_entries(entries);
 	test_independent_entries(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -111,6 +115,7 @@ TEST_BEGIN(test_qr_after_insert) {
 		qr_after_insert(&entries[i - 1], &entries[i], link);
 	}
 	test_entries_ring(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -140,6 +145,7 @@ TEST_BEGIN(test_qr_remove) {
 		qr_remove(&entries[i], link);
 	}
 	test_independent_entries(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -178,6 +184,7 @@ TEST_BEGIN(test_qr_before_insert) {
 		assert_c_eq(t->id, entries[(i+1) % NENTRIES].id,
 		    "Element id mismatch");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -201,6 +208,7 @@ test_split_entries(ring_t *entries) {
 			j++;
 		}
 	}
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_qr_meld_split) {
@@ -229,11 +237,13 @@ TEST_BEGIN(test_qr_meld_split) {
 
 	qr_meld(&entries[0], &entries[0], ring_t, link);
 	test_entries_ring(entries);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_qr_one,
 	    test_qr_after_insert,
diff --git a/deps/jemalloc/test/unit/rb.c b/deps/jemalloc/test/unit/rb.c
index 65c0492..66507a4 100644
--- a/deps/jemalloc/test/unit/rb.c
+++ b/deps/jemalloc/test/unit/rb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/rb.h"
@@ -38,6 +39,7 @@ node_cmp(const node_t *a, const node_t *b) {
 		ret = (((uintptr_t)a) > ((uintptr_t)b))
 		    - (((uintptr_t)a) < ((uintptr_t)b));
 	}
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -141,6 +143,7 @@ tree_iterate_cb(tree_t *tree, node_t *node, void *data) {
 
 	(*i)++;
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -151,6 +154,7 @@ tree_iterate(tree_t *tree) {
 	i = 0;
 	tree_iter(tree, NULL, tree_iterate_cb, (void *)&i);
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
@@ -161,6 +165,7 @@ tree_iterate_reverse(tree_t *tree) {
 	i = 0;
 	tree_reverse_iter(tree, NULL, tree_iterate_cb, (void *)&i);
 
+	__A_VARIABLE = 1;
 	return i;
 }
 
@@ -194,6 +199,7 @@ node_remove(tree_t *tree, node_t *node, unsigned nnodes) {
 	    "Unexpected node iteration count");
 	assert_u_eq(tree_iterate_reverse(tree), nnodes-1,
 	    "Unexpected node iteration count");
+	__A_VARIABLE = 1;
 }
 
 static node_t *
@@ -203,6 +209,7 @@ remove_iterate_cb(tree_t *tree, node_t *node, void *data) {
 
 	node_remove(tree, node, *nnodes);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -213,6 +220,7 @@ remove_reverse_iterate_cb(tree_t *tree, node_t *node, void *data) {
 
 	node_remove(tree, node, *nnodes);
 
+	__A_VARIABLE = 1;
 	return ret;
 }
 
@@ -222,6 +230,7 @@ destroy_cb(node_t *node, void *data) {
 
 	assert_u_gt(*nnodes, 0, "Destruction removed too many nodes");
 	(*nnodes)--;
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_rb_random) {
@@ -344,11 +353,13 @@ TEST_BEGIN(test_rb_random) {
 #undef NNODES
 #undef NBAGS
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_rb_empty,
 	    test_rb_random);
diff --git a/deps/jemalloc/test/unit/retained.c b/deps/jemalloc/test/unit/retained.c
index d51a598..4047944 100644
--- a/deps/jemalloc/test/unit/retained.c
+++ b/deps/jemalloc/test/unit/retained.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/spin.h"
@@ -17,6 +18,7 @@ do_arena_create(extent_hooks_t *h) {
 	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
 	    (void *)(h != NULL ? &h : NULL), (h != NULL ? sizeof(h) : 0)), 0,
 	    "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 	return arena_ind;
 }
 
@@ -31,6 +33,7 @@ do_arena_destroy(unsigned arena_ind) {
 	mib[1] = (size_t)arena_ind;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
+	__A_VARIABLE = 1;
 }
 
 static void
@@ -38,6 +41,7 @@ do_refresh(void) {
 	uint64_t epoch = 1;
 	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
 	    sizeof(epoch)), 0, "Unexpected mallctl() failure");
+	__A_VARIABLE = 1;
 }
 
 static size_t
@@ -53,16 +57,19 @@ do_get_size_impl(const char *cmd, unsigned arena_ind) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&size, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\"], ...) failure", cmd);
 
+	__A_VARIABLE = 1;
 	return size;
 }
 
 static size_t
 do_get_active(unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return do_get_size_impl("stats.arenas.0.pactive", arena_ind) * PAGE;
 }
 
 static size_t
 do_get_mapped(unsigned arena_ind) {
+	__A_VARIABLE = 1;
 	return do_get_size_impl("stats.arenas.0.mapped", arena_ind);
 }
 
@@ -94,6 +101,7 @@ thd_start(void *arg) {
 		atomic_fetch_add_u(&nfinished, 1, ATOMIC_RELEASE);
 	}
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -171,11 +179,13 @@ TEST_BEGIN(test_retained) {
 	}
 
 	do_arena_destroy(arena_ind);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_retained);
 }
diff --git a/deps/jemalloc/test/unit/rtree.c b/deps/jemalloc/test/unit/rtree.c
index 908100f..0543e6b 100644
--- a/deps/jemalloc/test/unit/rtree.c
+++ b/deps/jemalloc/test/unit/rtree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/rtree.h"
@@ -15,6 +16,7 @@ rtree_node_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	rtree_node_elm_t *node;
 
 	if (rtree != &test_rtree) {
+		__A_VARIABLE = 1;
 		return rtree_node_alloc_orig(tsdn, rtree, nelms);
 	}
 
@@ -23,6 +25,7 @@ rtree_node_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	assert_ptr_not_null(node, "Unexpected calloc() failure");
 	malloc_mutex_lock(tsdn, &rtree->init_lock);
 
+	__A_VARIABLE = 1;
 	return node;
 }
 
@@ -31,10 +34,12 @@ rtree_node_dalloc_intercept(tsdn_t *tsdn, rtree_t *rtree,
     rtree_node_elm_t *node) {
 	if (rtree != &test_rtree) {
 		rtree_node_dalloc_orig(tsdn, rtree, node);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(node);
+	__A_VARIABLE = 1;
 }
 
 static rtree_leaf_elm_t *
@@ -42,6 +47,7 @@ rtree_leaf_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	rtree_leaf_elm_t *leaf;
 
 	if (rtree != &test_rtree) {
+		__A_VARIABLE = 1;
 		return rtree_leaf_alloc_orig(tsdn, rtree, nelms);
 	}
 
@@ -50,6 +56,7 @@ rtree_leaf_alloc_intercept(tsdn_t *tsdn, rtree_t *rtree, size_t nelms) {
 	assert_ptr_not_null(leaf, "Unexpected calloc() failure");
 	malloc_mutex_lock(tsdn, &rtree->init_lock);
 
+	__A_VARIABLE = 1;
 	return leaf;
 }
 
@@ -58,10 +65,12 @@ rtree_leaf_dalloc_intercept(tsdn_t *tsdn, rtree_t *rtree,
     rtree_leaf_elm_t *leaf) {
 	if (rtree != &test_rtree) {
 		rtree_leaf_dalloc_orig(tsdn, rtree, leaf);
+		__A_VARIABLE = 1;
 		return;
 	}
 
 	free(leaf);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_rtree_read_empty) {
@@ -76,6 +85,7 @@ TEST_BEGIN(test_rtree_read_empty) {
 	assert_ptr_null(rtree_extent_read(tsdn, rtree, &rtree_ctx, PAGE,
 	    false), "rtree_extent_read() should return NULL for empty tree");
 	rtree_delete(tsdn, rtree);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -152,6 +162,7 @@ TEST_BEGIN(test_rtree_bits) {
 	}
 
 	rtree_delete(tsdn, rtree);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -205,6 +216,7 @@ TEST_BEGIN(test_rtree_random) {
 	fini_gen_rand(sfmt);
 #undef NSET
 #undef SEED
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -219,6 +231,7 @@ main(void) {
 	rtree_leaf_dalloc_orig = rtree_leaf_dalloc;
 	rtree_leaf_dalloc = rtree_leaf_dalloc_intercept;
 
+	__A_VARIABLE = 1;
 	return test(
 	    test_rtree_read_empty,
 	    test_rtree_extrema,
diff --git a/deps/jemalloc/test/unit/size_classes.c b/deps/jemalloc/test/unit/size_classes.c
index bcff560..abf7619 100644
--- a/deps/jemalloc/test/unit/size_classes.c
+++ b/deps/jemalloc/test/unit/size_classes.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static size_t
@@ -19,6 +20,7 @@ get_max_size_class(void) {
 	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
 	    NULL, 0), 0, "Unexpected mallctlbymib() error");
 
+	__A_VARIABLE = 1;
 	return max_size_class;
 }
 
@@ -77,6 +79,7 @@ TEST_BEGIN(test_size_classes) {
 	    "sz_s2u() does not round up to size class");
 	assert_zu_eq(size_class, sz_s2u(size_class),
 	    "sz_s2u() does not compute same size class");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -133,6 +136,7 @@ TEST_BEGIN(test_psize_classes) {
 	    "sz_psz2u() does not round up to size class");
 	assert_zu_eq(size_class, sz_psz2u(size_class),
 	    "sz_psz2u() does not compute same size class");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -171,11 +175,13 @@ TEST_BEGIN(test_overflow) {
 	    "size");
 	assert_zu_eq(sz_psz2u(SIZE_T_MAX), max_psz,
 	    "sz_psz2u() should return (LARGE_MAXCLASS + PAGE) on overflow");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_size_classes,
 	    test_psize_classes,
diff --git a/deps/jemalloc/test/unit/slab.c b/deps/jemalloc/test/unit/slab.c
index 7e662ae..e65f9d2 100644
--- a/deps/jemalloc/test/unit/slab.c
+++ b/deps/jemalloc/test/unit/slab.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_arena_slab_regind) {
@@ -22,11 +23,13 @@ TEST_BEGIN(test_arena_slab_regind) {
 		}
 		free(extent_addr_get(&slab));
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_arena_slab_regind);
 }
diff --git a/deps/jemalloc/test/unit/smoothstep.c b/deps/jemalloc/test/unit/smoothstep.c
index 7c5dbb7..3f29980 100644
--- a/deps/jemalloc/test/unit/smoothstep.c
+++ b/deps/jemalloc/test/unit/smoothstep.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static const uint64_t smoothstep_tab[] = {
@@ -33,6 +34,7 @@ TEST_BEGIN(test_smoothstep_integral) {
 		malloc_printf("%"FMTu64" ulps under 1/2 (limit %d)\n",
 		    max - sum, SMOOTHSTEP_NSTEPS);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -54,6 +56,7 @@ TEST_BEGIN(test_smoothstep_monotonic) {
 	}
 	assert_u64_eq(smoothstep_tab[SMOOTHSTEP_NSTEPS-1],
 	    (KQU(1) << SMOOTHSTEP_BFP), "Last step must equal 1");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -90,11 +93,13 @@ TEST_BEGIN(test_smoothstep_slope) {
 		prev_h = h;
 		prev_delta = delta;
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_smoothstep_integral,
 	    test_smoothstep_monotonic,
diff --git a/deps/jemalloc/test/unit/spin.c b/deps/jemalloc/test/unit/spin.c
index b965f74..3c9d905 100644
--- a/deps/jemalloc/test/unit/spin.c
+++ b/deps/jemalloc/test/unit/spin.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/spin.h"
@@ -8,11 +9,13 @@ TEST_BEGIN(test_spin) {
 	for (unsigned i = 0; i < 100; i++) {
 		spin_adaptive(&spinner);
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_spin);
 }
diff --git a/deps/jemalloc/test/unit/stats.c b/deps/jemalloc/test/unit/stats.c
index 231010e..162cadd 100644
--- a/deps/jemalloc/test/unit/stats.c
+++ b/deps/jemalloc/test/unit/stats.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_stats_summary) {
@@ -22,6 +23,7 @@ TEST_BEGIN(test_stats_summary) {
 		assert_zu_lt(active, mapped,
 		    "active should be less than mapped");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -62,6 +64,7 @@ TEST_BEGIN(test_stats_large) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -124,11 +127,13 @@ TEST_BEGIN(test_stats_arenas_summary) {
 		assert_u64_le(muzzy_nmadvise, muzzy_purged,
 		    "muzzy_nmadvise should be no greater than muzzy_purged");
 	}
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 void *
 thd_start(void *arg) {
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -138,6 +143,7 @@ no_lazy_lock(void) {
 
 	thd_create(&thd, thd_start, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_stats_arenas_small) {
@@ -182,6 +188,7 @@ TEST_BEGIN(test_stats_arenas_small) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -217,12 +224,14 @@ TEST_BEGIN(test_stats_arenas_large) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 static void
 gen_mallctl_str(char *cmd, char *name, unsigned arena_ind) {
 	sprintf(cmd, "stats.arenas.%u.bins.0.%s", arena_ind, name);
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_stats_arenas_bins) {
@@ -311,6 +320,7 @@ TEST_BEGIN(test_stats_arenas_bins) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -352,11 +362,13 @@ TEST_BEGIN(test_stats_arenas_lextents) {
 	}
 
 	dallocx(p, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_stats_summary,
 	    test_stats_large,
diff --git a/deps/jemalloc/test/unit/stats_print.c b/deps/jemalloc/test/unit/stats_print.c
index 014d002..7a7fc48 100644
--- a/deps/jemalloc/test/unit/stats_print.c
+++ b/deps/jemalloc/test/unit/stats_print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/util.h"
diff --git a/deps/jemalloc/test/unit/ticker.c b/deps/jemalloc/test/unit/ticker.c
index e5790a3..760e9b1 100644
--- a/deps/jemalloc/test/unit/ticker.c
+++ b/deps/jemalloc/test/unit/ticker.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 #include "jemalloc/internal/ticker.h"
@@ -24,6 +25,7 @@ TEST_BEGIN(test_ticker_tick) {
 		    "Expected ticker reset");
 	}
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -42,6 +44,7 @@ TEST_BEGIN(test_ticker_ticks) {
 	assert_true(ticker_ticks(&ticker, NTICKS + 1), "Expected ticker fire");
 	assert_u_eq(ticker_read(&ticker), NTICKS, "Unexpected ticker value");
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -61,11 +64,13 @@ TEST_BEGIN(test_ticker_copy) {
 	assert_true(ticker_ticks(&tb, NTICKS), "Expected ticker fire");
 	assert_u_eq(ticker_read(&tb), NTICKS, "Unexpected ticker value");
 #undef NTICKS
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_ticker_tick,
 	    test_ticker_ticks,
diff --git a/deps/jemalloc/test/unit/tsd.c b/deps/jemalloc/test/unit/tsd.c
index 6c47913..20c2aa5 100644
--- a/deps/jemalloc/test/unit/tsd.c
+++ b/deps/jemalloc/test/unit/tsd.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static int data_cleanup_count;
@@ -26,6 +27,7 @@ data_cleanup(int *data) {
 		reincarnate = true;
 		break;
 	case 2:
+		__A_VARIABLE = 1;
 		return;
 	default:
 		not_reached();
@@ -36,6 +38,7 @@ data_cleanup(int *data) {
 		assert_ptr_not_null(p, "Unexpeced mallocx() failure");
 		dallocx(p, 0);
 	}
+	__A_VARIABLE = 1;
 }
 
 static void *
@@ -61,11 +64,13 @@ thd_start(void *arg) {
 	tsd_test_callback_set(tsd, &data_cleanup);
 
 	free(p);
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
 TEST_BEGIN(test_tsd_main_thread) {
 	thd_start((void *)(uintptr_t)0xa5f3e329);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -81,6 +86,7 @@ TEST_BEGIN(test_tsd_sub_thread) {
 	 */
 	assert_x_ge(data_cleanup_count, 3,
 	    "Cleanup function should have executed multiple times.");
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -114,6 +120,7 @@ thd_start_reincarnated(void *arg) {
 	assert_ptr_null(*tsd_arenap_get_unsafe(tsd),
 	    "TSD arena should have been cleared after 2nd cleanup.");
 
+	__A_VARIABLE = 1;
 	return NULL;
 }
 
@@ -121,6 +128,7 @@ TEST_BEGIN(test_tsd_reincarnation) {
 	thd_t thd;
 	thd_create(&thd, thd_start_reincarnated, NULL);
 	thd_join(thd, NULL);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -129,9 +137,11 @@ main(void) {
 	/* Ensure tsd bootstrapped. */
 	if (nallocx(1, 0) == 0) {
 		malloc_printf("Initialization error");
+		__A_VARIABLE = 1;
 		return test_status_fail;
 	}
 
+	__A_VARIABLE = 1;
 	return test_no_reentrancy(
 	    test_tsd_main_thread,
 	    test_tsd_sub_thread,
diff --git a/deps/jemalloc/test/unit/witness.c b/deps/jemalloc/test/unit/witness.c
index 5986da4..e9c6d25 100644
--- a/deps/jemalloc/test/unit/witness.c
+++ b/deps/jemalloc/test/unit/witness.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static witness_lock_error_t *witness_lock_error_orig;
@@ -14,22 +15,26 @@ static void
 witness_lock_error_intercept(const witness_list_t *witnesses,
     const witness_t *witness) {
 	saw_lock_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_owner_error_intercept(const witness_t *witness) {
 	saw_owner_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_not_owner_error_intercept(const witness_t *witness) {
 	saw_not_owner_error = true;
+	__A_VARIABLE = 1;
 }
 
 static void
 witness_depth_error_intercept(const witness_list_t *witnesses,
     witness_rank_t rank_inclusive, unsigned depth) {
 	saw_depth_error = true;
+	__A_VARIABLE = 1;
 }
 
 static int
@@ -39,6 +44,7 @@ witness_comp(const witness_t *a, void *oa, const witness_t *b, void *ob) {
 	assert(oa == (void *)a);
 	assert(ob == (void *)b);
 
+	__A_VARIABLE = 1;
 	return strcmp(a->name, b->name);
 }
 
@@ -50,6 +56,7 @@ witness_comp_reverse(const witness_t *a, void *oa, const witness_t *b,
 	assert(oa == (void *)a);
 	assert(ob == (void *)b);
 
+	__A_VARIABLE = 1;
 	return -strcmp(a->name, b->name);
 }
 
@@ -90,6 +97,7 @@ TEST_BEGIN(test_witness) {
 	witness_assert_lockless(&witness_tsdn);
 	witness_assert_depth(&witness_tsdn, 0);
 	witness_assert_depth_to_rank(&witness_tsdn, (witness_rank_t)1U, 0);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -142,6 +150,7 @@ TEST_BEGIN(test_witness_comp) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_lock_error = witness_lock_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -173,6 +182,7 @@ TEST_BEGIN(test_witness_reversal) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_lock_error = witness_lock_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -208,6 +218,7 @@ TEST_BEGIN(test_witness_recursive) {
 	witness_owner_error = witness_owner_error_orig;
 	witness_lock_error = witness_lock_error_orig;
 
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -232,6 +243,7 @@ TEST_BEGIN(test_witness_unlock_not_owned) {
 	witness_assert_lockless(&witness_tsdn);
 
 	witness_owner_error = witness_owner_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
@@ -265,11 +277,13 @@ TEST_BEGIN(test_witness_depth) {
 	witness_assert_depth(&witness_tsdn, 0);
 
 	witness_depth_error = witness_depth_error_orig;
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_witness,
 	    test_witness_comp,
diff --git a/deps/jemalloc/test/unit/zero.c b/deps/jemalloc/test/unit/zero.c
index 553692b..7f60c7c 100644
--- a/deps/jemalloc/test/unit/zero.c
+++ b/deps/jemalloc/test/unit/zero.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "test/jemalloc_test.h"
 
 static void
@@ -37,22 +38,26 @@ test_zero(size_t sz_min, size_t sz_max) {
 
 	dallocx(s, 0);
 #undef MAGIC
+	__A_VARIABLE = 1;
 }
 
 TEST_BEGIN(test_zero_small) {
 	test_skip_if(!config_fill);
 	test_zero(1, SMALL_MAXCLASS-1);
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 TEST_BEGIN(test_zero_large) {
 	test_skip_if(!config_fill);
 	test_zero(SMALL_MAXCLASS+1, (1U << (LG_LARGE_MINCLASS+1)));
+	__A_VARIABLE = 1;
 }
 TEST_END
 
 int
 main(void) {
+	__A_VARIABLE = 1;
 	return test(
 	    test_zero_small,
 	    test_zero_large);
diff --git a/deps/linenoise/example.c b/deps/linenoise/example.c
index 3a544d3..f7ef279 100644
--- a/deps/linenoise/example.c
+++ b/deps/linenoise/example.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -9,14 +10,17 @@ void completion(const char *buf, linenoiseCompletions *lc) {
         linenoiseAddCompletion(lc,"hello");
         linenoiseAddCompletion(lc,"hello there");
     }
+    __A_VARIABLE = 1;
 }
 
 char *hints(const char *buf, int *color, int *bold) {
     if (!strcasecmp(buf,"hello")) {
         *color = 35;
         *bold = 0;
+        __A_VARIABLE = 1;
         return " World";
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -70,5 +74,6 @@ int main(int argc, char **argv) {
         }
         free(line);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/linenoise/linenoise.c b/deps/linenoise/linenoise.c
index fce14a7..e928b0f 100644
--- a/deps/linenoise/linenoise.c
+++ b/deps/linenoise/linenoise.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* linenoise.c -- guerrilla line editing library against the idea that a
  * line editing lib needs to be 20,000 lines of C code.
  *
@@ -200,6 +201,7 @@ FILE *lndebug_fp = NULL;
 /* Set if to use or not the multi line mode. */
 void linenoiseSetMultiLine(int ml) {
     mlmode = ml;
+    __A_VARIABLE = 1;
 }
 
 /* Return true if the terminal name is in the list of terminals we know are
@@ -208,9 +210,16 @@ static int isUnsupportedTerm(void) {
     char *term = getenv("TERM");
     int j;
 
-    if (term == NULL) return 0;
+    if (term == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     for (j = 0; unsupported_term[j]; j++)
-        if (!strcasecmp(term,unsupported_term[j])) return 1;
+        if (!strcasecmp(term,unsupported_term[j])) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -243,10 +252,12 @@ static int enableRawMode(int fd) {
     /* put terminal in raw mode after flushing */
     if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;
     rawmode = 1;
+    __A_VARIABLE = 1;
     return 0;
 
 fatal:
     errno = ENOTTY;
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -254,6 +265,7 @@ static void disableRawMode(int fd) {
     /* Don't even check the return value as it's too late. */
     if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)
         rawmode = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Use the ESC [6n escape sequence to query the horizontal cursor position
@@ -265,7 +277,10 @@ static int getCursorPosition(int ifd, int ofd) {
     unsigned int i = 0;
 
     /* Report cursor location */
-    if (write(ofd, "\x1b[6n", 4) != 4) return -1;
+    if (write(ofd, "\x1b[6n", 4) != 4) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Read the response: ESC [ rows ; cols R */
     while (i < sizeof(buf)-1) {
@@ -276,8 +291,15 @@ static int getCursorPosition(int ifd, int ofd) {
     buf[i] = '\0';
 
     /* Parse it. */
-    if (buf[0] != ESC || buf[1] != '[') return -1;
-    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
+    if (buf[0] != ESC || buf[1] != '[') {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return cols;
 }
 
@@ -321,6 +343,7 @@ void linenoiseClearScreen(void) {
     if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
         /* nothing to do, just to avoid warning. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* Beep, used for completion when there is nothing to complete or when all
@@ -328,6 +351,7 @@ void linenoiseClearScreen(void) {
 static void linenoiseBeep(void) {
     fprintf(stderr, "\x7");
     fflush(stderr);
+    __A_VARIABLE = 1;
 }
 
 /* ============================== Completion ================================ */
@@ -339,6 +363,7 @@ static void freeCompletions(linenoiseCompletions *lc) {
         free(lc->cvec[i]);
     if (lc->cvec != NULL)
         free(lc->cvec);
+    __A_VARIABLE = 1;
 }
 
 /* This is an helper function for linenoiseEdit() and is called when the
@@ -408,18 +433,21 @@ static int completeLine(struct linenoiseState *ls) {
 /* Register a callback function to be called for tab-completion. */
 void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
     completionCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* Register a hits function to be called to show hits to the user at the
  * right of the prompt. */
 void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
     hintsCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* Register a function to free the hints returned by the hints callback
  * registered with linenoiseSetHintsCallback(). */
 void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
     freeHintsCallback = fn;
+    __A_VARIABLE = 1;
 }
 
 /* This function is used by the callback function registered by the user
@@ -431,15 +459,20 @@ void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
     char *copy, **cvec;
 
     copy = malloc(len+1);
-    if (copy == NULL) return;
+    if (copy == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memcpy(copy,str,len+1);
     cvec = realloc(lc->cvec,sizeof(char*)*(lc->len+1));
     if (cvec == NULL) {
         free(copy);
+        __A_VARIABLE = 1;
         return;
     }
     lc->cvec = cvec;
     lc->cvec[lc->len++] = copy;
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Line editing ================================= */
@@ -456,19 +489,25 @@ struct abuf {
 static void abInit(struct abuf *ab) {
     ab->b = NULL;
     ab->len = 0;
+    __A_VARIABLE = 1;
 }
 
 static void abAppend(struct abuf *ab, const char *s, int len) {
     char *new = realloc(ab->b,ab->len+len);
 
-    if (new == NULL) return;
+    if (new == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memcpy(new+ab->len,s,len);
     ab->b = new;
     ab->len += len;
+    __A_VARIABLE = 1;
 }
 
 static void abFree(struct abuf *ab) {
     free(ab->b);
+    __A_VARIABLE = 1;
 }
 
 /* Helper of refreshSingleLine() and refreshMultiLine() to show hints
@@ -493,6 +532,7 @@ void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
             if (freeHintsCallback) freeHintsCallback(hint);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Single line low level line refresh.
@@ -534,6 +574,7 @@ static void refreshSingleLine(struct linenoiseState *l) {
     abAppend(&ab,seq,strlen(seq));
     if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
     abFree(&ab);
+    __A_VARIABLE = 1;
 }
 
 /* Multi line low level line refresh.
@@ -621,6 +662,7 @@ static void refreshMultiLine(struct linenoiseState *l) {
 
     if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
     abFree(&ab);
+    __A_VARIABLE = 1;
 }
 
 /* Calls the two low level functions refreshSingleLine() or
@@ -630,6 +672,7 @@ static void refreshLine(struct linenoiseState *l) {
         refreshMultiLine(l);
     else
         refreshSingleLine(l);
+    __A_VARIABLE = 1;
 }
 
 /* Insert the character 'c' at cursor current position.
@@ -667,6 +710,7 @@ void linenoiseEditMoveLeft(struct linenoiseState *l) {
         l->pos--;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor on the right. */
@@ -675,6 +719,7 @@ void linenoiseEditMoveRight(struct linenoiseState *l) {
         l->pos++;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor to the start of the line. */
@@ -683,6 +728,7 @@ void linenoiseEditMoveHome(struct linenoiseState *l) {
         l->pos = 0;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Move cursor to the end of the line. */
@@ -691,6 +737,7 @@ void linenoiseEditMoveEnd(struct linenoiseState *l) {
         l->pos = l->len;
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Substitute the currently edited line with the next or previous history
@@ -728,6 +775,7 @@ void linenoiseEditDelete(struct linenoiseState *l) {
         l->buf[l->len] = '\0';
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Backspace implementation. */
@@ -739,6 +787,7 @@ void linenoiseEditBackspace(struct linenoiseState *l) {
         l->buf[l->len] = '\0';
         refreshLine(l);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Delete the previosu word, maintaining the cursor at the start of the
@@ -755,6 +804,7 @@ void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
     memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
     l->len -= diff;
     refreshLine(l);
+    __A_VARIABLE = 1;
 }
 
 /* This function is the core of the line editing capability of linenoise.
@@ -957,7 +1007,10 @@ void linenoisePrintKeyCodes(void) {
 
     printf("Linenoise key codes debugging mode.\n"
             "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
-    if (enableRawMode(STDIN_FILENO) == -1) return;
+    if (enableRawMode(STDIN_FILENO) == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     memset(quit,' ',4);
     while(1) {
         char c;
@@ -975,6 +1028,7 @@ void linenoisePrintKeyCodes(void) {
         fflush(stdout);
     }
     disableRawMode(STDIN_FILENO);
+    __A_VARIABLE = 1;
 }
 
 /* This function calls the line editing function linenoiseEdit() using
@@ -984,13 +1038,18 @@ static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
 
     if (buflen == 0) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return -1;
     }
 
-    if (enableRawMode(STDIN_FILENO) == -1) return -1;
+    if (enableRawMode(STDIN_FILENO) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
     disableRawMode(STDIN_FILENO);
     printf("\n");
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -1068,6 +1127,7 @@ char *linenoise(const char *prompt) {
  * allocator. */
 void linenoiseFree(void *ptr) {
     free(ptr);
+    __A_VARIABLE = 1;
 }
 
 /* ================================ History ================================= */
@@ -1082,12 +1142,14 @@ static void freeHistory(void) {
             free(history[j]);
         free(history);
     }
+    __A_VARIABLE = 1;
 }
 
 /* At exit we'll try to fix the terminal to the initial conditions. */
 static void linenoiseAtExit(void) {
     disableRawMode(STDIN_FILENO);
     freeHistory();
+    __A_VARIABLE = 1;
 }
 
 /* This is the API call to add a new entry in the linenoise history.
@@ -1100,22 +1162,34 @@ static void linenoiseAtExit(void) {
 int linenoiseHistoryAdd(const char *line) {
     char *linecopy;
 
-    if (history_max_len == 0) return 0;
+    if (history_max_len == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Initialization on first call. */
     if (history == NULL) {
         history = malloc(sizeof(char*)*history_max_len);
-        if (history == NULL) return 0;
+        if (history == NULL) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         memset(history,0,(sizeof(char*)*history_max_len));
     }
 
     /* Don't add duplicated lines. */
-    if (history_len && !strcmp(history[history_len-1], line)) return 0;
+    if (history_len && !strcmp(history[history_len-1], line)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Add an heap allocated copy of the line in the history.
      * If we reached the max length, remove the older line. */
     linecopy = strdup(line);
-    if (!linecopy) return 0;
+    if (!linecopy) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (history_len == history_max_len) {
         free(history[0]);
         memmove(history,history+1,sizeof(char*)*(history_max_len-1));
@@ -1123,6 +1197,7 @@ int linenoiseHistoryAdd(const char *line) {
     }
     history[history_len] = linecopy;
     history_len++;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1133,12 +1208,18 @@ int linenoiseHistoryAdd(const char *line) {
 int linenoiseHistorySetMaxLen(int len) {
     char **new;
 
-    if (len < 1) return 0;
+    if (len < 1) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (history) {
         int tocopy = history_len;
 
         new = malloc(sizeof(char*)*len);
-        if (new == NULL) return 0;
+        if (new == NULL) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
 
         /* If we can't copy everything, free the elements we'll not use. */
         if (len < tocopy) {
@@ -1155,6 +1236,7 @@ int linenoiseHistorySetMaxLen(int len) {
     history_max_len = len;
     if (history_len > history_max_len)
         history_len = history_max_len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1167,11 +1249,15 @@ int linenoiseHistorySave(const char *filename) {
 
     fp = fopen(filename,"w");
     umask(old_umask);
-    if (fp == NULL) return -1;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     chmod(filename,S_IRUSR|S_IWUSR);
     for (j = 0; j < history_len; j++)
         fprintf(fp,"%s\n",history[j]);
     fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1184,7 +1270,10 @@ int linenoiseHistoryLoad(const char *filename) {
     FILE *fp = fopen(filename,"r");
     char buf[LINENOISE_MAX_LINE];
 
-    if (fp == NULL) return -1;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
         char *p;
@@ -1195,5 +1284,6 @@ int linenoiseHistoryLoad(const char *filename) {
         linenoiseHistoryAdd(buf);
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/deps/lua/etc/all.c b/deps/lua/etc/all.c
index dab68fa..faede74 100644
--- a/deps/lua/etc/all.c
+++ b/deps/lua/etc/all.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 * all.c -- Lua core, libraries and interpreter in a single file
 */
diff --git a/deps/lua/etc/min.c b/deps/lua/etc/min.c
index 6a85a4d..0945127 100644
--- a/deps/lua/etc/min.c
+++ b/deps/lua/etc/min.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 * min.c -- a minimal Lua interpreter
 * loads stdin only with minimal error handling.
@@ -26,6 +27,7 @@ static int print(lua_State *L)
    printf("%s:%p",luaL_typename(L,i),lua_topointer(L,i));
  }
  printf("\n");
+ __A_VARIABLE = 1;
  return 0;
 }
 
@@ -35,5 +37,6 @@ int main(void)
  lua_register(L,"print",print);
  if (luaL_dofile(L,NULL)!=0) fprintf(stderr,"%s\n",lua_tostring(L,-1));
  lua_close(L);
+ __A_VARIABLE = 1;
  return 0;
 }
diff --git a/deps/lua/etc/noparser.c b/deps/lua/etc/noparser.c
index 13ba546..12601e9 100644
--- a/deps/lua/etc/noparser.c
+++ b/deps/lua/etc/noparser.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 * The code below can be used to make a Lua core that does not contain the
 * parsing modules (lcode, llex, lparser), which represent 35% of the total core.
@@ -20,6 +21,7 @@
 
 LUAI_FUNC void luaX_init (lua_State *L) {
   UNUSED(L);
+  __A_VARIABLE = 1;
 }
 
 LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
@@ -28,6 +30,7 @@ LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *n
   UNUSED(name);
   lua_pushliteral(L,"parser not loaded");
   lua_error(L);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -41,6 +44,7 @@ LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data,
   UNUSED(strip);
 #if 1
   UNUSED(L);
+  __A_VARIABLE = 1;
   return 0;
 #else
   lua_pushliteral(L,"dumper not loaded");
diff --git a/deps/lua/src/fpconv.c b/deps/lua/src/fpconv.c
index 7990831..5ccae9b 100644
--- a/deps/lua/src/fpconv.c
+++ b/deps/lua/src/fpconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* fpconv - Floating point conversion routines
  *
  * Copyright (c) 2011-2012  Mark Pulford <mark@kyne.com.au>
@@ -63,6 +64,7 @@ static void fpconv_update_locale()
     }
 
     locale_decimal_point = buf[1];
+    __A_VARIABLE = 1;
 }
 
 /* Check for a valid number character: [-+0-9a-yA-Y.]
@@ -76,16 +78,23 @@ static inline int valid_number_character(char ch)
 {
     char lower_ch;
 
-    if ('0' <= ch && ch <= '9')
+    if ('0' <= ch && ch <= '9') {
+        __A_VARIABLE = 1;
         return 1;
-    if (ch == '-' || ch == '+' || ch == '.')
+    }
+    if (ch == '-' || ch == '+' || ch == '.') {
+        __A_VARIABLE = 1;
         return 1;
+    }
 
     /* Hex digits, exponent (e), base (p), "infinity",.. */
     lower_ch = ch | 0x20;
-    if ('a' <= lower_ch && lower_ch <= 'y')
+    if ('a' <= lower_ch && lower_ch <= 'y') {
+        __A_VARIABLE = 1;
         return 1;
+    }
 
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -98,6 +107,7 @@ static int strtod_buffer_size(const char *s)
     while (valid_number_character(*p))
         p++;
 
+    __A_VARIABLE = 1;
     return p - s;
 }
 
@@ -111,13 +121,16 @@ double fpconv_strtod(const char *nptr, char **endptr)
     double value;
 
     /* System strtod() is fine when decimal point is '.' */
-    if (locale_decimal_point == '.')
+    if (locale_decimal_point == '.') {
+        __A_VARIABLE = 1;
         return strtod(nptr, endptr);
+    }
 
     buflen = strtod_buffer_size(nptr);
     if (!buflen) {
         /* No valid characters found, standard strtod() return */
         *endptr = (char *)nptr;
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -146,6 +159,7 @@ double fpconv_strtod(const char *nptr, char **endptr)
     if (buflen >= FPCONV_G_FMT_BUFSIZE)
         free(buf);
 
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -168,6 +182,7 @@ static void set_number_format(char *fmt, int precision)
     fmt[i++] = '0' + d2;
     fmt[i++] = 'g';
     fmt[i] = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Assumes there is always at least 32 characters available in the target buffer */
@@ -181,8 +196,10 @@ int fpconv_g_fmt(char *str, double num, int precision)
     set_number_format(fmt, precision);
 
     /* Pass through when decimal point character is dot. */
-    if (locale_decimal_point == '.')
+    if (locale_decimal_point == '.') {
+        __A_VARIABLE = 1;
         return snprintf(str, FPCONV_G_FMT_BUFSIZE, fmt, num);
+    }
 
     /* snprintf() to a buffer then translate for other decimal point characters */
     len = snprintf(buf, FPCONV_G_FMT_BUFSIZE, fmt, num);
@@ -193,12 +210,14 @@ int fpconv_g_fmt(char *str, double num, int precision)
         *str++ = (*b == locale_decimal_point ? '.' : *b);
     } while(*b++);
 
+    __A_VARIABLE = 1;
     return len;
 }
 
 void fpconv_init()
 {
     fpconv_update_locale();
+    __A_VARIABLE = 1;
 }
 
 /* vi:ai et sw=4 ts=4:
diff --git a/deps/lua/src/lapi.c b/deps/lua/src/lapi.c
index 5d5145d..8acb4ca 100644
--- a/deps/lua/src/lapi.c
+++ b/deps/lua/src/lapi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
 ** Lua API
@@ -89,6 +90,7 @@ static Table *getcurrenv (lua_State *L) {
 void luaA_pushobject (lua_State *L, const TValue *o) {
   setobj2s(L, L->top, o);
   api_incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -103,13 +105,17 @@ LUA_API int lua_checkstack (lua_State *L, int size) {
       L->ci->top = L->top + size;
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
 
 LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
   int i;
-  if (from == to) return;
+  if (from == to) {
+    __A_VARIABLE = 1;
+    return;
+  }
   lua_lock(to);
   api_checknelems(from, n);
   api_check(from, G(from) == G(to));
@@ -119,11 +125,13 @@ LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
     setobj2s(to, to->top++, from->top + i);
   }
   lua_unlock(to);
+  __A_VARIABLE = 1;
 }
 
 
 LUA_API void lua_setlevel (lua_State *from, lua_State *to) {
   to->nCcalls = from->nCcalls;
+  __A_VARIABLE = 1;
 }
 
 
@@ -133,6 +141,7 @@ LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
   old = G(L)->panic;
   G(L)->panic = panicf;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return old;
 }
 
@@ -146,6 +155,7 @@ LUA_API lua_State *lua_newthread (lua_State *L) {
   api_incr_top(L);
   lua_unlock(L);
   luai_userstatethread(L, L1);
+  __A_VARIABLE = 1;
   return L1;
 }
 
@@ -157,6 +167,7 @@ LUA_API lua_State *lua_newthread (lua_State *L) {
 
 
 LUA_API int lua_gettop (lua_State *L) {
+  __A_VARIABLE = 1;
   return cast_int(L->top - L->base);
 }
 
@@ -174,6 +185,7 @@ LUA_API void lua_settop (lua_State *L, int idx) {
     L->top += idx+1;  /* `subtract' index (index is negative) */
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -185,6 +197,7 @@ LUA_API void lua_remove (lua_State *L, int idx) {
   while (++p < L->top) setobjs2s(L, p-1, p);
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -197,6 +210,7 @@ LUA_API void lua_insert (lua_State *L, int idx) {
   for (q = L->top; q>p; q--) setobjs2s(L, q, q-1);
   setobjs2s(L, p, L->top);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -222,6 +236,7 @@ LUA_API void lua_replace (lua_State *L, int idx) {
   }
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -230,6 +245,7 @@ LUA_API void lua_pushvalue (lua_State *L, int idx) {
   setobj2s(L, L->top, index2adr(L, idx));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -241,18 +257,21 @@ LUA_API void lua_pushvalue (lua_State *L, int idx) {
 
 LUA_API int lua_type (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);
 }
 
 
 LUA_API const char *lua_typename (lua_State *L, int t) {
   UNUSED(L);
+  __A_VARIABLE = 1;
   return (t == LUA_TNONE) ? "no value" : luaT_typenames[t];
 }
 
 
 LUA_API int lua_iscfunction (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return iscfunction(o);
 }
 
@@ -260,18 +279,21 @@ LUA_API int lua_iscfunction (lua_State *L, int idx) {
 LUA_API int lua_isnumber (lua_State *L, int idx) {
   TValue n;
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return tonumber(o, &n);
 }
 
 
 LUA_API int lua_isstring (lua_State *L, int idx) {
   int t = lua_type(L, idx);
+  __A_VARIABLE = 1;
   return (t == LUA_TSTRING || t == LUA_TNUMBER);
 }
 
 
 LUA_API int lua_isuserdata (lua_State *L, int idx) {
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (ttisuserdata(o) || ttislightuserdata(o));
 }
 
@@ -279,6 +301,7 @@ LUA_API int lua_isuserdata (lua_State *L, int idx) {
 LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
   StkId o1 = index2adr(L, index1);
   StkId o2 = index2adr(L, index2);
+  __A_VARIABLE = 1;
   return (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
          : luaO_rawequalObj(o1, o2);
 }
@@ -292,6 +315,7 @@ LUA_API int lua_equal (lua_State *L, int index1, int index2) {
   o2 = index2adr(L, index2);
   i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0 : equalobj(L, o1, o2);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -305,6 +329,7 @@ LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
   i = (o1 == luaO_nilobject || o2 == luaO_nilobject) ? 0
        : luaV_lessthan(L, o1, o2);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -336,6 +361,7 @@ LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {
 
 LUA_API int lua_toboolean (lua_State *L, int idx) {
   const TValue *o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return !l_isfalse(o);
 }
 
@@ -347,6 +373,7 @@ LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
     if (!luaV_tostring(L, o)) {  /* conversion failed? */
       if (len != NULL) *len = 0;
       lua_unlock(L);
+      __A_VARIABLE = 1;
       return NULL;
     }
     luaC_checkGC(L);
@@ -354,6 +381,7 @@ LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
     lua_unlock(L);
   }
   if (len != NULL) *len = tsvalue(o)->len;
+  __A_VARIABLE = 1;
   return svalue(o);
 }
 
@@ -361,23 +389,29 @@ LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
 LUA_API size_t lua_objlen (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TSTRING: return tsvalue(o)->len;
-    case LUA_TUSERDATA: return uvalue(o)->len;
-    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    case LUA_TSTRING: __A_VARIABLE = 1;
+    return tsvalue(o)->len;
+    case LUA_TUSERDATA: __A_VARIABLE = 1;
+    return uvalue(o)->len;
+    case LUA_TTABLE: __A_VARIABLE = 1;
+    return luaH_getn(hvalue(o));
     case LUA_TNUMBER: {
       size_t l;
       lua_lock(L);  /* `luaV_tostring' may create a new string */
       l = (luaV_tostring(L, o) ? tsvalue(o)->len : 0);
       lua_unlock(L);
+      __A_VARIABLE = 1;
       return l;
     }
-    default: return 0;
+    default: __A_VARIABLE = 1;
+    return 0;
   }
 }
 
 
 LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (!iscfunction(o)) ? NULL : clvalue(o)->c.f;
 }
 
@@ -385,15 +419,19 @@ LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
 LUA_API void *lua_touserdata (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
-    case LUA_TLIGHTUSERDATA: return pvalue(o);
-    default: return NULL;
+    case LUA_TUSERDATA: __A_VARIABLE = 1;
+      return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: __A_VARIABLE = 1;
+      return pvalue(o);
+    default: __A_VARIABLE = 1;
+    return NULL;
   }
 }
 
 
 LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
+  __A_VARIABLE = 1;
   return (!ttisthread(o)) ? NULL : thvalue(o);
 }
 
@@ -401,13 +439,18 @@ LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
 LUA_API const void *lua_topointer (lua_State *L, int idx) {
   StkId o = index2adr(L, idx);
   switch (ttype(o)) {
-    case LUA_TTABLE: return hvalue(o);
-    case LUA_TFUNCTION: return clvalue(o);
-    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TTABLE: __A_VARIABLE = 1;
+      return hvalue(o);
+    case LUA_TFUNCTION: __A_VARIABLE = 1;
+      return clvalue(o);
+    case LUA_TTHREAD: __A_VARIABLE = 1;
+      return thvalue(o);
     case LUA_TUSERDATA:
     case LUA_TLIGHTUSERDATA:
+      __A_VARIABLE = 1;
       return lua_touserdata(L, idx);
-    default: return NULL;
+    default: __A_VARIABLE = 1;
+      return NULL;
   }
 }
 
@@ -423,6 +466,7 @@ LUA_API void lua_pushnil (lua_State *L) {
   setnilvalue(L->top);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -431,6 +475,7 @@ LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
   setnvalue(L->top, n);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -439,6 +484,7 @@ LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
   setnvalue(L->top, cast_num(n));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -448,6 +494,7 @@ LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
   setsvalue2s(L, L->top, luaS_newlstr(L, s, len));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -456,6 +503,7 @@ LUA_API void lua_pushstring (lua_State *L, const char *s) {
     lua_pushnil(L);
   else
     lua_pushlstring(L, s, strlen(s));
+  __A_VARIABLE = 1;
 }
 
 
@@ -466,6 +514,7 @@ LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
   luaC_checkGC(L);
   ret = luaO_pushvfstring(L, fmt, argp);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -479,6 +528,7 @@ LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
   ret = luaO_pushvfstring(L, fmt, argp);
   va_end(argp);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return ret;
 }
 
@@ -497,6 +547,7 @@ LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
   lua_assert(iswhite(obj2gco(cl)));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -505,6 +556,7 @@ LUA_API void lua_pushboolean (lua_State *L, int b) {
   setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -513,6 +565,7 @@ LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
   setpvalue(L->top, p);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -521,6 +574,7 @@ LUA_API int lua_pushthread (lua_State *L) {
   setthvalue(L, L->top, L);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return (G(L)->mainthread == L);
 }
 
@@ -538,6 +592,7 @@ LUA_API void lua_gettable (lua_State *L, int idx) {
   api_checkvalidindex(L, t);
   luaV_gettable(L, t, L->top - 1, L->top - 1);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -551,6 +606,7 @@ LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
   luaV_gettable(L, t, &key, L->top);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -561,6 +617,7 @@ LUA_API void lua_rawget (lua_State *L, int idx) {
   api_check(L, ttistable(t));
   setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -572,6 +629,7 @@ LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
   setobj2s(L, L->top, luaH_getnum(hvalue(o), n));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -581,6 +639,7 @@ LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
   sethvalue(L, L->top, luaH_new(L, narray, nrec));
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -609,6 +668,7 @@ LUA_API int lua_getmetatable (lua_State *L, int objindex) {
     res = 1;
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -634,6 +694,7 @@ LUA_API void lua_getfenv (lua_State *L, int idx) {
   }
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -651,6 +712,7 @@ LUA_API void lua_settable (lua_State *L, int idx) {
   luaV_settable(L, t, L->top - 2, L->top - 1);
   L->top -= 2;  /* pop index and value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -665,6 +727,7 @@ LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
   luaV_settable(L, t, &key, L->top - 1);
   L->top--;  /* pop value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -678,6 +741,7 @@ LUA_API void lua_rawset (lua_State *L, int idx) {
   luaC_barriert(L, hvalue(t), L->top-1);
   L->top -= 2;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -691,6 +755,7 @@ LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
   luaC_barriert(L, hvalue(o), L->top-1);
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -727,6 +792,7 @@ LUA_API int lua_setmetatable (lua_State *L, int objindex) {
   }
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -756,6 +822,7 @@ LUA_API int lua_setfenv (lua_State *L, int idx) {
   if (res) luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
   L->top--;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -782,6 +849,7 @@ LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
   luaD_call(L, func, nresults);
   adjustresults(L, nresults);
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -798,6 +866,7 @@ struct CallS {  /* data to `f_call' */
 static void f_call (lua_State *L, void *ud) {
   struct CallS *c = cast(struct CallS *, ud);
   luaD_call(L, c->func, c->nresults);
+  __A_VARIABLE = 1;
 }
 
 
@@ -821,6 +890,7 @@ LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
   status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
   adjustresults(L, nresults);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -844,6 +914,7 @@ static void f_Ccall (lua_State *L, void *ud) {
   setpvalue(L->top, c->ud);  /* push only argument */
   api_incr_top(L);
   luaD_call(L, L->top - 2, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -855,6 +926,7 @@ LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
   c.ud = ud;
   status = luaD_pcall(L, f_Ccall, &c, savestack(L, L->top), 0);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -868,6 +940,7 @@ LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
   luaZ_init(L, &z, reader, data);
   status = luaD_protectedparser(L, &z, chunkname);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -883,11 +956,13 @@ LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
   else
     status = 1;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 LUA_API int  lua_status (lua_State *L) {
+  __A_VARIABLE = 1;
   return L->status;
 }
 
@@ -951,6 +1026,7 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
     default: res = -1;  /* invalid option */
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -966,6 +1042,7 @@ LUA_API int lua_error (lua_State *L) {
   api_checknelems(L, 1);
   luaG_errormsg(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return 0;  /* to avoid warnings */
 }
 
@@ -983,6 +1060,7 @@ LUA_API int lua_next (lua_State *L, int idx) {
   else  /* no more elements */
     L->top -= 1;  /* remove key */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return more;
 }
 
@@ -1001,6 +1079,7 @@ LUA_API void lua_concat (lua_State *L, int n) {
   }
   /* else n == 1; nothing to do */
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1010,6 +1089,7 @@ LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
   if (ud) *ud = G(L)->ud;
   f = G(L)->frealloc;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -1019,6 +1099,7 @@ LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
   G(L)->ud = ud;
   G(L)->frealloc = f;
   lua_unlock(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1030,6 +1111,7 @@ LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
   setuvalue(L, L->top, u);
   api_incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return u + 1;
 }
 
@@ -1064,6 +1146,7 @@ LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
     api_incr_top(L);
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
@@ -1082,6 +1165,7 @@ LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
     luaC_barrier(L, clvalue(fi), L->top);
   }
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
diff --git a/deps/lua/src/lauxlib.c b/deps/lua/src/lauxlib.c
index 10f14e2..e6a3d95 100644
--- a/deps/lua/src/lauxlib.c
+++ b/deps/lua/src/lauxlib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
 ** Auxiliary functions for building Lua libraries
@@ -42,17 +43,22 @@
 
 LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
   lua_Debug ar;
-  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */ {
+    __A_VARIABLE = 1;
     return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  }
   lua_getinfo(L, "n", &ar);
   if (strcmp(ar.namewhat, "method") == 0) {
     narg--;  /* do not count `self' */
-    if (narg == 0)  /* error is in the self argument itself? */
+    if (narg == 0)  /* error is in the self argument itself? */ {
+      __A_VARIABLE = 1;
       return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
                            ar.name, extramsg);
+    }
   }
   if (ar.name == NULL)
     ar.name = "?";
+  __A_VARIABLE = 1;
   return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
                         narg, ar.name, extramsg);
 }
@@ -61,12 +67,14 @@ LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
 LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
   const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                     tname, luaL_typename(L, narg));
+  __A_VARIABLE = 1;
   return luaL_argerror(L, narg, msg);
 }
 
 
 static void tag_error (lua_State *L, int narg, int tag) {
   luaL_typerror(L, narg, lua_typename(L, tag));
+  __A_VARIABLE = 1;
 }
 
 
@@ -76,10 +84,12 @@ LUALIB_API void luaL_where (lua_State *L, int level) {
     lua_getinfo(L, "Sl", &ar);  /* get info about it */
     if (ar.currentline > 0) {  /* is there info? */
       lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      __A_VARIABLE = 1;
       return;
     }
   }
   lua_pushliteral(L, "");  /* else, no information available... */
+  __A_VARIABLE = 1;
 }
 
 
@@ -90,6 +100,7 @@ LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
   lua_pushvfstring(L, fmt, argp);
   va_end(argp);
   lua_concat(L, 2);
+  __A_VARIABLE = 1;
   return lua_error(L);
 }
 
@@ -102,8 +113,11 @@ LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
                              luaL_checkstring(L, narg);
   int i;
   for (i=0; lst[i]; i++)
-    if (strcmp(lst[i], name) == 0)
+    if (strcmp(lst[i], name) == 0) {
+      __A_VARIABLE = 1;
       return i;
+    }
+  __A_VARIABLE = 1;
   return luaL_argerror(L, narg,
                        lua_pushfstring(L, "invalid option " LUA_QS, name));
 }
@@ -111,12 +125,15 @@ LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
 
 LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
   lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get registry.name */
-  if (!lua_isnil(L, -1))  /* name already in use? */
-    return 0;  /* leave previous value on top, but return 0 */
+  if (!lua_isnil(L, -1))  /* name already in use? */ {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* leave previous value on top, but return 0 */
   lua_pop(L, 1);
   lua_newtable(L);  /* create metatable */
   lua_pushvalue(L, -1);
   lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -128,11 +145,13 @@ LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
       lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */
       if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
         lua_pop(L, 2);  /* remove both metatables */
+        __A_VARIABLE = 1;
         return p;
       }
     }
   }
   luaL_typerror(L, ud, tname);  /* else error */
+  __A_VARIABLE = 1;
   return NULL;  /* to avoid warnings */
 }
 
@@ -140,24 +159,28 @@ LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
 LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
   if (!lua_checkstack(L, space))
     luaL_error(L, "stack overflow (%s)", mes);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
   if (lua_type(L, narg) != t)
     tag_error(L, narg, t);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_checkany (lua_State *L, int narg) {
   if (lua_type(L, narg) == LUA_TNONE)
     luaL_argerror(L, narg, "value expected");
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
   const char *s = lua_tolstring(L, narg, len);
   if (!s) tag_error(L, narg, LUA_TSTRING);
+  __A_VARIABLE = 1;
   return s;
 }
 
@@ -177,11 +200,13 @@ LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
   lua_Number d = lua_tonumber(L, narg);
   if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
     tag_error(L, narg, LUA_TNUMBER);
+  __A_VARIABLE = 1;
   return d;
 }
 
 
 LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  __A_VARIABLE = 1;
   return luaL_opt(L, luaL_checknumber, narg, def);
 }
 
@@ -190,12 +215,14 @@ LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
   lua_Integer d = lua_tointeger(L, narg);
   if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
     tag_error(L, narg, LUA_TNUMBER);
+  __A_VARIABLE = 1;
   return d;
 }
 
 
 LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
                                                       lua_Integer def) {
+  __A_VARIABLE = 1;
   return luaL_opt(L, luaL_checkinteger, narg, def);
 }
 
@@ -218,10 +245,13 @@ LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
 
 LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
   obj = abs_index(L, obj);
-  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */ {
+    __A_VARIABLE = 1;
     return 0;
+  }
   lua_pushvalue(L, obj);
   lua_call(L, 1, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -235,6 +265,7 @@ LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
 static int libsize (const luaL_Reg *l) {
   int size = 0;
   for (; l->name; l++) size++;
+  __A_VARIABLE = 1;
   return size;
 }
 
@@ -265,6 +296,7 @@ LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
     lua_setfield(L, -(nup+2), l->name);
   }
   lua_pop(L, nup);  /* remove upvalues */
+  __A_VARIABLE = 1;
 }
 
 
@@ -280,6 +312,7 @@ LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
 static int checkint (lua_State *L, int topop) {
   int n = (lua_type(L, -1) == LUA_TNUMBER) ? lua_tointeger(L, -1) : -1;
   lua_pop(L, topop);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -296,6 +329,7 @@ static void getsizes (lua_State *L) {
     lua_pushvalue(L, -1);
     lua_setfield(L, LUA_REGISTRYINDEX, "LUA_SIZES");  /* store in register */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -315,6 +349,7 @@ LUALIB_API void luaL_setn (lua_State *L, int t, int n) {
     lua_rawset(L, -3);  /* sizes[t] = n */
     lua_pop(L, 1);  /* remove `sizes' */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -323,11 +358,18 @@ LUALIB_API int luaL_getn (lua_State *L, int t) {
   t = abs_index(L, t);
   lua_pushliteral(L, "n");  /* try t.n */
   lua_rawget(L, t);
-  if ((n = checkint(L, 1)) >= 0) return n;
+  if ((n = checkint(L, 1)) >= 0) {
+    __A_VARIABLE = 1;
+    return n;
+  }
   getsizes(L);  /* else try sizes[t] */
   lua_pushvalue(L, t);
   lua_rawget(L, -2);
-  if ((n = checkint(L, 2)) >= 0) return n;
+  if ((n = checkint(L, 2)) >= 0) {
+    __A_VARIABLE = 1;
+    return n;
+  }
+  __A_VARIABLE = 1;
   return (int)lua_objlen(L, t);
 }
 
@@ -350,6 +392,7 @@ LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
   }
   luaL_addstring(&b, s);  /* push last suffix */
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return lua_tostring(L, -1);
 }
 
@@ -423,12 +466,14 @@ static void adjuststack (luaL_Buffer *B) {
     lua_concat(L, toget);
     B->lvl = B->lvl - toget + 1;
   }
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
   if (emptybuffer(B))
     adjuststack(B);
+  __A_VARIABLE = 1;
   return B->buffer;
 }
 
@@ -436,11 +481,13 @@ LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
 LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
   while (l--)
     luaL_addchar(B, *s++);
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
   luaL_addlstring(B, s, strlen(s));
+  __A_VARIABLE = 1;
 }
 
 
@@ -448,6 +495,7 @@ LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
   emptybuffer(B);
   lua_concat(B->L, B->lvl);
   B->lvl = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -466,6 +514,7 @@ LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
     B->lvl++;  /* add new value into B stack */
     adjuststack(B);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -473,6 +522,7 @@ LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
   B->L = L;
   B->p = B->buffer;
   B->lvl = 0;
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================== */
@@ -483,6 +533,7 @@ LUALIB_API int luaL_ref (lua_State *L, int t) {
   t = abs_index(L, t);
   if (lua_isnil(L, -1)) {
     lua_pop(L, 1);  /* remove from stack */
+    __A_VARIABLE = 1;
     return LUA_REFNIL;  /* `nil' has a unique fixed reference */
   }
   lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
@@ -497,6 +548,7 @@ LUALIB_API int luaL_ref (lua_State *L, int t) {
     ref++;  /* create new reference */
   }
   lua_rawseti(L, t, ref);
+  __A_VARIABLE = 1;
   return ref;
 }
 
@@ -509,6 +561,7 @@ LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
     lua_pushinteger(L, ref);
     lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -532,10 +585,15 @@ static const char *getF (lua_State *L, void *ud, size_t *size) {
   if (lf->extraline) {
     lf->extraline = 0;
     *size = 1;
+    __A_VARIABLE = 1;
     return "\n";
   }
-  if (feof(lf->f)) return NULL;
+  if (feof(lf->f)) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);
+  __A_VARIABLE = 1;
   return (*size > 0) ? lf->buff : NULL;
 }
 
@@ -545,6 +603,7 @@ static int errfile (lua_State *L, const char *what, int fnameindex) {
   const char *filename = lua_tostring(L, fnameindex) + 1;
   lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
   lua_remove(L, fnameindex);
+  __A_VARIABLE = 1;
   return LUA_ERRFILE;
 }
 
@@ -599,9 +658,13 @@ typedef struct LoadS {
 static const char *getS (lua_State *L, void *ud, size_t *size) {
   LoadS *ls = (LoadS *)ud;
   (void)L;
-  if (ls->size == 0) return NULL;
+  if (ls->size == 0) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   *size = ls->size;
   ls->size = 0;
+  __A_VARIABLE = 1;
   return ls->s;
 }
 
@@ -611,6 +674,7 @@ LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
   LoadS ls;
   ls.s = buff;
   ls.size = size;
+  __A_VARIABLE = 1;
   return lua_load(L, getS, &ls, name);
 }
 
@@ -640,6 +704,7 @@ static int panic (lua_State *L) {
   (void)L;  /* to avoid warnings */
   fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
                    lua_tostring(L, -1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -647,6 +712,7 @@ static int panic (lua_State *L) {
 LUALIB_API lua_State *luaL_newstate (void) {
   lua_State *L = lua_newstate(l_alloc, NULL);
   if (L) lua_atpanic(L, &panic);
+  __A_VARIABLE = 1;
   return L;
 }
 
diff --git a/deps/lua/src/lbaselib.c b/deps/lua/src/lbaselib.c
index 2ab550b..91074b5 100644
--- a/deps/lua/src/lbaselib.c
+++ b/deps/lua/src/lbaselib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
 ** Basic library
@@ -38,14 +39,17 @@ static int luaB_print (lua_State *L) {
     lua_pushvalue(L, i);   /* value to print */
     lua_call(L, 1, 1);
     s = lua_tostring(L, -1);  /* get result */
-    if (s == NULL)
+    if (s == NULL) {
+      __A_VARIABLE = 1;
       return luaL_error(L, LUA_QL("tostring") " must return a string to "
                            LUA_QL("print"));
+    }
     if (i>1) fputs("\t", stdout);
     fputs(s, stdout);
     lua_pop(L, 1);  /* pop result */
   }
   fputs("\n", stdout);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -86,6 +90,7 @@ static int luaB_error (lua_State *L) {
     lua_pushvalue(L, 1);
     lua_concat(L, 2);
   }
+  __A_VARIABLE = 1;
   return lua_error(L);
 }
 
@@ -94,9 +99,11 @@ static int luaB_getmetatable (lua_State *L) {
   luaL_checkany(L, 1);
   if (!lua_getmetatable(L, 1)) {
     lua_pushnil(L);
+    __A_VARIABLE = 1;
     return 1;  /* no metatable */
   }
   luaL_getmetafield(L, 1, "__metatable");
+  __A_VARIABLE = 1;
   return 1;  /* returns either __metatable field (if present) or metatable */
 }
 
@@ -110,6 +117,7 @@ static int luaB_setmetatable (lua_State *L) {
     luaL_error(L, "cannot change a protected metatable");
   lua_settop(L, 2);
   lua_setmetatable(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -127,6 +135,7 @@ static void getfunc (lua_State *L, int opt) {
       luaL_error(L, "no function environment for tail call at level %d",
                     level);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -136,6 +145,7 @@ static int luaB_getfenv (lua_State *L) {
     lua_pushvalue(L, LUA_GLOBALSINDEX);  /* return the thread's global env. */
   else
     lua_getfenv(L, -1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -162,6 +172,7 @@ static int luaB_rawequal (lua_State *L) {
   luaL_checkany(L, 1);
   luaL_checkany(L, 2);
   lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -171,6 +182,7 @@ static int luaB_rawget (lua_State *L) {
   luaL_checkany(L, 2);
   lua_settop(L, 2);
   lua_rawget(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -180,12 +192,14 @@ static int luaB_rawset (lua_State *L) {
   luaL_checkany(L, 3);
   lua_settop(L, 3);
   lua_rawset(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_gcinfo (lua_State *L) {
   lua_pushinteger(L, lua_getgccount(L));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -202,14 +216,17 @@ static int luaB_collectgarbage (lua_State *L) {
     case LUA_GCCOUNT: {
       int b = lua_gc(L, LUA_GCCOUNTB, 0);
       lua_pushnumber(L, res + ((lua_Number)b/1024));
+      __A_VARIABLE = 1;
       return 1;
     }
     case LUA_GCSTEP: {
       lua_pushboolean(L, res);
+      __A_VARIABLE = 1;
       return 1;
     }
     default: {
       lua_pushnumber(L, res);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
@@ -219,6 +236,7 @@ static int luaB_collectgarbage (lua_State *L) {
 static int luaB_type (lua_State *L) {
   luaL_checkany(L, 1);
   lua_pushstring(L, luaL_typename(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -240,6 +258,7 @@ static int luaB_pairs (lua_State *L) {
   lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
   lua_pushvalue(L, 1);  /* state, */
   lua_pushnil(L);  /* and initial value */
+  __A_VARIABLE = 1;
   return 3;
 }
 
@@ -250,6 +269,7 @@ static int ipairsaux (lua_State *L) {
   i++;  /* next value */
   lua_pushinteger(L, i);
   lua_rawgeti(L, 1, i);
+  __A_VARIABLE = 1;
   return (lua_isnil(L, -1)) ? 0 : 2;
 }
 
@@ -259,6 +279,7 @@ static int luaB_ipairs (lua_State *L) {
   lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
   lua_pushvalue(L, 1);  /* state, */
   lua_pushinteger(L, 0);  /* and initial value */
+  __A_VARIABLE = 1;
   return 3;
 }
 
@@ -278,12 +299,14 @@ static int luaB_loadstring (lua_State *L) {
   size_t l;
   const char *s = luaL_checklstring(L, 1, &l);
   const char *chunkname = luaL_optstring(L, 2, s);
+  __A_VARIABLE = 1;
   return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
 }
 
 
 static int luaB_loadfile (lua_State *L) {
   const char *fname = luaL_optstring(L, 1, NULL);
+  __A_VARIABLE = 1;
   return load_aux(L, luaL_loadfile(L, fname));
 }
 
@@ -318,6 +341,7 @@ static int luaB_load (lua_State *L) {
   luaL_checktype(L, 1, LUA_TFUNCTION);
   lua_settop(L, 3);  /* function, eventual name, plus one reserved slot */
   status = lua_load(L, generic_reader, NULL, cname);
+  __A_VARIABLE = 1;
   return load_aux(L, status);
 }
 
@@ -327,14 +351,18 @@ static int luaB_dofile (lua_State *L) {
   int n = lua_gettop(L);
   if (luaL_loadfile(L, fname) != 0) lua_error(L);
   lua_call(L, 0, LUA_MULTRET);
+  __A_VARIABLE = 1;
   return lua_gettop(L) - n;
 }
 
 
 static int luaB_assert (lua_State *L) {
   luaL_checkany(L, 1);
-  if (!lua_toboolean(L, 1))
+  if (!lua_toboolean(L, 1)) {
+    __A_VARIABLE = 1;
     return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  }
+  __A_VARIABLE = 1;
   return lua_gettop(L);
 }
 
@@ -344,13 +372,19 @@ static int luaB_unpack (lua_State *L) {
   luaL_checktype(L, 1, LUA_TTABLE);
   i = luaL_optint(L, 2, 1);
   e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
-  if (i > e) return 0;  /* empty range */
+  if (i > e) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* empty range */
   n = e - i + 1;  /* number of elements */
-  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */ {
+    __A_VARIABLE = 1;
     return luaL_error(L, "too many results to unpack");
+  }
   lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
   while (i++ < e)  /* push arg[i + 1...e] */
     lua_rawgeti(L, 1, i);
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -377,6 +411,7 @@ static int luaB_pcall (lua_State *L) {
   status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
   lua_pushboolean(L, (status == 0));
   lua_insert(L, 1);
+  __A_VARIABLE = 1;
   return lua_gettop(L);  /* return status + all results */
 }
 
@@ -389,14 +424,17 @@ static int luaB_xpcall (lua_State *L) {
   status = lua_pcall(L, 0, LUA_MULTRET, 1);
   lua_pushboolean(L, (status == 0));
   lua_replace(L, 1);
+  __A_VARIABLE = 1;
   return lua_gettop(L);  /* return status + all results */
 }
 
 
 static int luaB_tostring (lua_State *L) {
   luaL_checkany(L, 1);
-  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
-    return 1;  /* use its value */
+  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */ {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* use its value */
   switch (lua_type(L, 1)) {
     case LUA_TNUMBER:
       lua_pushstring(L, lua_tostring(L, 1));
@@ -414,6 +452,7 @@ static int luaB_tostring (lua_State *L) {
       lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
       break;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -511,6 +550,7 @@ static int luaB_costatus (lua_State *L) {
   lua_State *co = lua_tothread(L, 1);
   luaL_argcheck(L, co, 1, "coroutine expected");
   lua_pushstring(L, statnames[costatus(L, co)]);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -569,6 +609,7 @@ static int luaB_auxwrap (lua_State *L) {
     }
     lua_error(L);  /* propagate error */
   }
+  __A_VARIABLE = 1;
   return r;
 }
 
@@ -579,6 +620,7 @@ static int luaB_cocreate (lua_State *L) {
     "Lua function expected");
   lua_pushvalue(L, 1);  /* move function to top */
   lua_xmove(L, NL, 1);  /* move function from L to NL */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -586,11 +628,13 @@ static int luaB_cocreate (lua_State *L) {
 static int luaB_cowrap (lua_State *L) {
   luaB_cocreate(L);
   lua_pushcclosure(L, luaB_auxwrap, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int luaB_yield (lua_State *L) {
+  __A_VARIABLE = 1;
   return lua_yield(L, lua_gettop(L));
 }
 
@@ -598,6 +642,7 @@ static int luaB_yield (lua_State *L) {
 static int luaB_corunning (lua_State *L) {
   if (lua_pushthread(L))
     lua_pushnil(L);  /* main thread is not a coroutine */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -620,6 +665,7 @@ static void auxopen (lua_State *L, const char *name,
   lua_pushcfunction(L, u);
   lua_pushcclosure(L, f, 1);
   lua_setfield(L, -2, name);
+  __A_VARIABLE = 1;
 }
 
 
@@ -642,12 +688,14 @@ static void base_open (lua_State *L) {
   lua_setfield(L, -2, "__mode");  /* metatable(w).__mode = "kv" */
   lua_pushcclosure(L, luaB_newproxy, 1);
   lua_setglobal(L, "newproxy");  /* set global `newproxy' */
+  __A_VARIABLE = 1;
 }
 
 
 LUALIB_API int luaopen_base (lua_State *L) {
   base_open(L);
   luaL_register(L, LUA_COLIBNAME, co_funcs);
+  __A_VARIABLE = 1;
   return 2;
 }
 
diff --git a/deps/lua/src/lcode.c b/deps/lua/src/lcode.c
index 679cb9c..97bd056 100644
--- a/deps/lua/src/lcode.c
+++ b/deps/lua/src/lcode.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
 ** Code generator for Lua
@@ -28,6 +29,7 @@
 
 
 static int isnumeral(expdesc *e) {
+  __A_VARIABLE = 1;
   return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
 }
 
@@ -62,17 +64,20 @@ int luaK_jump (FuncState *fs) {
   fs->jpc = NO_JUMP;
   j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
   luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  __A_VARIABLE = 1;
   return j;
 }
 
 
 void luaK_ret (FuncState *fs, int first, int nret) {
   luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+  __A_VARIABLE = 1;
 }
 
 
 static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
   luaK_codeABC(fs, op, A, B, C);
+  __A_VARIABLE = 1;
   return luaK_jump(fs);
 }
 
@@ -84,6 +89,7 @@ static void fixjump (FuncState *fs, int pc, int dest) {
   if (abs(offset) > MAXARG_sBx)
     luaX_syntaxerror(fs->ls, "control structure too long");
   SETARG_sBx(*jmp, offset);
+  __A_VARIABLE = 1;
 }
 
 
@@ -93,6 +99,7 @@ static void fixjump (FuncState *fs, int pc, int dest) {
 */
 int luaK_getlabel (FuncState *fs) {
   fs->lasttarget = fs->pc;
+  __A_VARIABLE = 1;
   return fs->pc;
 }
 
@@ -122,21 +129,28 @@ static Instruction *getjumpcontrol (FuncState *fs, int pc) {
 static int need_value (FuncState *fs, int list) {
   for (; list != NO_JUMP; list = getjump(fs, list)) {
     Instruction i = *getjumpcontrol(fs, list);
-    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+    if (GET_OPCODE(i) != OP_TESTSET) {
+      __A_VARIABLE = 1;
+      return 1;
+    }
   }
+  __A_VARIABLE = 1;
   return 0;  /* not found */
 }
 
 
 static int patchtestreg (FuncState *fs, int node, int reg) {
   Instruction *i = getjumpcontrol(fs, node);
-  if (GET_OPCODE(*i) != OP_TESTSET)
-    return 0;  /* cannot patch other instructions */
+  if (GET_OPCODE(*i) != OP_TESTSET) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* cannot patch other instructions */
   if (reg != NO_REG && reg != GETARG_B(*i))
     SETARG_A(*i, reg);
   else  /* no register to put value or register already has the value */
     *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
 
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -144,6 +158,7 @@ static int patchtestreg (FuncState *fs, int node, int reg) {
 static void removevalues (FuncState *fs, int list) {
   for (; list != NO_JUMP; list = getjump(fs, list))
       patchtestreg(fs, list, NO_REG);
+  __A_VARIABLE = 1;
 }
 
 
@@ -157,12 +172,14 @@ static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
       fixjump(fs, list, dtarget);  /* jump to default target */
     list = next;
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void dischargejpc (FuncState *fs) {
   patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
   fs->jpc = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
@@ -173,12 +190,14 @@ void luaK_patchlist (FuncState *fs, int list, int target) {
     lua_assert(target < fs->pc);
     patchlistaux(fs, list, target, NO_REG, target);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_patchtohere (FuncState *fs, int list) {
   luaK_getlabel(fs);
   luaK_concat(fs, &fs->jpc, list);
+  __A_VARIABLE = 1;
 }
 
 
@@ -203,12 +222,14 @@ void luaK_checkstack (FuncState *fs, int n) {
       luaX_syntaxerror(fs->ls, "function or expression too complex");
     fs->f->maxstacksize = cast_byte(newstack);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_reserveregs (FuncState *fs, int n) {
   luaK_checkstack(fs, n);
   fs->freereg += n;
+  __A_VARIABLE = 1;
 }
 
 
@@ -217,12 +238,14 @@ static void freereg (FuncState *fs, int reg) {
     fs->freereg--;
     lua_assert(reg == fs->freereg);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void freeexp (FuncState *fs, expdesc *e) {
   if (e->k == VNONRELOC)
     freereg(fs, e->u.s.info);
+  __A_VARIABLE = 1;
 }
 
 
@@ -250,6 +273,7 @@ static int addk (FuncState *fs, TValue *k, TValue *v) {
 int luaK_stringK (FuncState *fs, TString *s) {
   TValue o;
   setsvalue(fs->L, &o, s);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
@@ -257,6 +281,7 @@ int luaK_stringK (FuncState *fs, TString *s) {
 int luaK_numberK (FuncState *fs, lua_Number r) {
   TValue o;
   setnvalue(&o, r);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
@@ -264,6 +289,7 @@ int luaK_numberK (FuncState *fs, lua_Number r) {
 static int boolK (FuncState *fs, int b) {
   TValue o;
   setbvalue(&o, b);
+  __A_VARIABLE = 1;
   return addk(fs, &o, &o);
 }
 
@@ -273,6 +299,7 @@ static int nilK (FuncState *fs) {
   setnilvalue(&v);
   /* cannot use nil as key; instead use table itself to represent nil */
   sethvalue(fs->L, &k, fs->h);
+  __A_VARIABLE = 1;
   return addk(fs, &k, &v);
 }
 
@@ -286,6 +313,7 @@ void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
     SETARG_A(getcode(fs, e), fs->freereg);
     luaK_reserveregs(fs, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -298,6 +326,7 @@ void luaK_setoneret (FuncState *fs, expdesc *e) {
     SETARG_B(getcode(fs, e), 2);
     e->k = VRELOCABLE;  /* can relocate its simple result */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -331,11 +360,13 @@ void luaK_dischargevars (FuncState *fs, expdesc *e) {
     }
     default: break;  /* there is one value available (somewhere) */
   }
+  __A_VARIABLE = 1;
 }
 
 
 static int code_label (FuncState *fs, int A, int b, int jump) {
   luaK_getlabel(fs);  /* those instructions may be jump targets */
+  __A_VARIABLE = 1;
   return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
 }
 
@@ -371,11 +402,13 @@ static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
     }
     default: {
       lua_assert(e->k == VVOID || e->k == VJMP);
+      __A_VARIABLE = 1;
       return;  /* nothing to do... */
     }
   }
   e->u.s.info = reg;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
@@ -384,6 +417,7 @@ static void discharge2anyreg (FuncState *fs, expdesc *e) {
     luaK_reserveregs(fs, 1);
     discharge2reg(fs, e, fs->freereg-1);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -408,6 +442,7 @@ static void exp2reg (FuncState *fs, expdesc *e, int reg) {
   e->f = e->t = NO_JUMP;
   e->u.s.info = reg;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
@@ -416,19 +451,25 @@ void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
   freeexp(fs, e);
   luaK_reserveregs(fs, 1);
   exp2reg(fs, e, fs->freereg - 1);
+  __A_VARIABLE = 1;
 }
 
 
 int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
   luaK_dischargevars(fs, e);
   if (e->k == VNONRELOC) {
-    if (!hasjumps(e)) return e->u.s.info;  /* exp is already in a register */
+    if (!hasjumps(e)) {
+      __A_VARIABLE = 1;
+      return e->u.s.info;
+    }  /* exp is already in a register */
     if (e->u.s.info >= fs->nactvar) {  /* reg. is not a local? */
       exp2reg(fs, e, e->u.s.info);  /* put value on it */
+      __A_VARIABLE = 1;
       return e->u.s.info;
     }
   }
   luaK_exp2nextreg(fs, e);  /* default */
+  __A_VARIABLE = 1;
   return e->u.s.info;
 }
 
@@ -438,6 +479,7 @@ void luaK_exp2val (FuncState *fs, expdesc *e) {
     luaK_exp2anyreg(fs, e);
   else
     luaK_dischargevars(fs, e);
+  __A_VARIABLE = 1;
 }
 
 
@@ -474,6 +516,7 @@ void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
     case VLOCAL: {
       freeexp(fs, ex);
       exp2reg(fs, ex, var->u.s.info);
+      __A_VARIABLE = 1;
       return;
     }
     case VUPVAL: {
@@ -497,6 +540,7 @@ void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
     }
   }
   freeexp(fs, ex);
+  __A_VARIABLE = 1;
 }
 
 
@@ -510,6 +554,7 @@ void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
   freeexp(fs, key);
   e->u.s.info = func;
   e->k = VNONRELOC;
+  __A_VARIABLE = 1;
 }
 
 
@@ -518,6 +563,7 @@ static void invertjump (FuncState *fs, expdesc *e) {
   lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
                                            GET_OPCODE(*pc) != OP_TEST);
   SETARG_A(*pc, !(GETARG_A(*pc)));
+  __A_VARIABLE = 1;
 }
 
 
@@ -526,12 +572,14 @@ static int jumponcond (FuncState *fs, expdesc *e, int cond) {
     Instruction ie = getcode(fs, e);
     if (GET_OPCODE(ie) == OP_NOT) {
       fs->pc--;  /* remove previous OP_NOT */
+      __A_VARIABLE = 1;
       return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
     }
     /* else go through */
   }
   discharge2anyreg(fs, e);
   freeexp(fs, e);
+  __A_VARIABLE = 1;
   return condjump(fs, OP_TESTSET, NO_REG, e->u.s.info, cond);
 }
 
@@ -557,6 +605,7 @@ void luaK_goiftrue (FuncState *fs, expdesc *e) {
   luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
   luaK_patchtohere(fs, e->t);
   e->t = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
@@ -580,6 +629,7 @@ static void luaK_goiffalse (FuncState *fs, expdesc *e) {
   luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
   luaK_patchtohere(fs, e->f);
   e->f = NO_JUMP;
+  __A_VARIABLE = 1;
 }
 
 
@@ -615,18 +665,23 @@ static void codenot (FuncState *fs, expdesc *e) {
   { int temp = e->f; e->f = e->t; e->t = temp; }
   removevalues(fs, e->f);
   removevalues(fs, e->t);
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
   t->u.s.aux = luaK_exp2RK(fs, k);
   t->k = VINDEXED;
+  __A_VARIABLE = 1;
 }
 
 
 static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
   lua_Number v1, v2, r;
-  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if (!isnumeral(e1) || !isnumeral(e2)) {
+      __A_VARIABLE = 1;
+      return 0;
+  }
   v1 = e1->u.nval;
   v2 = e2->u.nval;
   switch (op) {
@@ -634,18 +689,29 @@ static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
     case OP_SUB: r = luai_numsub(v1, v2); break;
     case OP_MUL: r = luai_nummul(v1, v2); break;
     case OP_DIV:
-      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+      if (v2 == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+      }  /* do not attempt to divide by 0 */
       r = luai_numdiv(v1, v2); break;
     case OP_MOD:
-      if (v2 == 0) return 0;  /* do not attempt to divide by 0 */
+      if (v2 == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+      }  /* do not attempt to divide by 0 */
       r = luai_nummod(v1, v2); break;
     case OP_POW: r = luai_numpow(v1, v2); break;
     case OP_UNM: r = luai_numunm(v1); break;
-    case OP_LEN: return 0;  /* no constant folding for 'len' */
+    case OP_LEN: __A_VARIABLE = 1;
+      return 0;  /* no constant folding for 'len' */
     default: lua_assert(0); r = 0; break;
   }
-  if (luai_numisnan(r)) return 0;  /* do not attempt to produce NaN */
+  if (luai_numisnan(r)) {
+      __A_VARIABLE = 1;
+      return 0;
+  }  /* do not attempt to produce NaN */
   e1->u.nval = r;
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -683,6 +749,7 @@ static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
   }
   e1->u.s.info = condjump(fs, op, cond, o1, o2);
   e1->k = VJMP;
+  __A_VARIABLE = 1;
 }
 
 
@@ -704,6 +771,7 @@ void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -731,6 +799,7 @@ void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
       break;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -778,11 +847,13 @@ void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
     case OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); break;
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
 void luaK_fixline (FuncState *fs, int line) {
   fs->f->lineinfo[fs->pc - 1] = line;
+  __A_VARIABLE = 1;
 }
 
 
@@ -797,6 +868,7 @@ static int luaK_code (FuncState *fs, Instruction i, int line) {
   luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                   MAX_INT, "code size overflow");
   f->lineinfo[fs->pc] = line;
+  __A_VARIABLE = 1;
   return fs->pc++;
 }
 
@@ -805,6 +877,7 @@ int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
   lua_assert(getOpMode(o) == iABC);
   lua_assert(getBMode(o) != OpArgN || b == 0);
   lua_assert(getCMode(o) != OpArgN || c == 0);
+  __A_VARIABLE = 1;
   return luaK_code(fs, CREATE_ABC(o, a, b, c), fs->ls->lastline);
 }
 
@@ -812,6 +885,7 @@ int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
 int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
   lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
   lua_assert(getCMode(o) == OpArgN);
+  __A_VARIABLE = 1;
   return luaK_code(fs, CREATE_ABx(o, a, bc), fs->ls->lastline);
 }
 
@@ -827,5 +901,6 @@ void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
     luaK_code(fs, cast(Instruction, c), fs->ls->lastline);
   }
   fs->freereg = base + 1;  /* free registers with list values */
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/ldblib.c b/deps/lua/src/ldblib.c
index 2027eda..389b548 100644
--- a/deps/lua/src/ldblib.c
+++ b/deps/lua/src/ldblib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ldblib.c,v 1.104.1.4 2009/08/04 18:50:18 roberto Exp $
 ** Interface from Lua to its debug API
@@ -21,6 +22,7 @@
 
 static int db_getregistry (lua_State *L) {
   lua_pushvalue(L, LUA_REGISTRYINDEX);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -30,6 +32,7 @@ static int db_getmetatable (lua_State *L) {
   if (!lua_getmetatable(L, 1)) {
     lua_pushnil(L);  /* no metatable */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -40,6 +43,7 @@ static int db_setmetatable (lua_State *L) {
                     "nil or table expected");
   lua_settop(L, 2);
   lua_pushboolean(L, lua_setmetatable(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -47,6 +51,7 @@ static int db_setmetatable (lua_State *L) {
 static int db_getfenv (lua_State *L) {
   luaL_checkany(L, 1);
   lua_getfenv(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -57,6 +62,7 @@ static int db_setfenv (lua_State *L) {
   if (lua_setfenv(L, 1) == 0)
     luaL_error(L, LUA_QL("setfenv")
                   " cannot change environment of given object");
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -64,12 +70,14 @@ static int db_setfenv (lua_State *L) {
 static void settabss (lua_State *L, const char *i, const char *v) {
   lua_pushstring(L, v);
   lua_setfield(L, -2, i);
+  __A_VARIABLE = 1;
 }
 
 
 static void settabsi (lua_State *L, const char *i, int v) {
   lua_pushinteger(L, v);
   lua_setfield(L, -2, i);
+  __A_VARIABLE = 1;
 }
 
 
@@ -93,6 +101,7 @@ static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
   else
     lua_xmove(L1, L, 1);
   lua_setfield(L, -2, fname);
+  __A_VARIABLE = 1;
 }
 
 
@@ -166,12 +175,15 @@ static int db_setlocal (lua_State *L) {
   int arg;
   lua_State *L1 = getthread(L, &arg);
   lua_Debug ar;
-  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */ {
+    __A_VARIABLE = 1;
     return luaL_argerror(L, arg+1, "level out of range");
+  }
   luaL_checkany(L, arg+3);
   lua_settop(L, arg+3);
   lua_xmove(L, L1, 1);
   lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -180,22 +192,31 @@ static int auxupvalue (lua_State *L, int get) {
   const char *name;
   int n = luaL_checkint(L, 2);
   luaL_checktype(L, 1, LUA_TFUNCTION);
-  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  if (lua_iscfunction(L, 1)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* cannot touch C upvalues from Lua */
   name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
-  if (name == NULL) return 0;
+  if (name == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   lua_pushstring(L, name);
   lua_insert(L, -(get+1));
+  __A_VARIABLE = 1;
   return get + 1;
 }
 
 
 static int db_getupvalue (lua_State *L) {
+  __A_VARIABLE = 1;
   return auxupvalue(L, 1);
 }
 
 
 static int db_setupvalue (lua_State *L) {
   luaL_checkany(L, 3);
+  __A_VARIABLE = 1;
   return auxupvalue(L, 0);
 }
 
@@ -219,6 +240,7 @@ static void hookf (lua_State *L, lua_Debug *ar) {
     lua_assert(lua_getinfo(L, "lS", ar));
     lua_call(L, 2, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -228,6 +250,7 @@ static int makemask (const char *smask, int count) {
   if (strchr(smask, 'r')) mask |= LUA_MASKRET;
   if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
   if (count > 0) mask |= LUA_MASKCOUNT;
+  __A_VARIABLE = 1;
   return mask;
 }
 
@@ -238,6 +261,7 @@ static char *unmakemask (int mask, char *smask) {
   if (mask & LUA_MASKRET) smask[i++] = 'r';
   if (mask & LUA_MASKLINE) smask[i++] = 'l';
   smask[i] = '\0';
+  __A_VARIABLE = 1;
   return smask;
 }
 
@@ -252,6 +276,7 @@ static void gethooktable (lua_State *L) {
     lua_pushvalue(L, -2);
     lua_rawset(L, LUA_REGISTRYINDEX);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -275,6 +300,7 @@ static int db_sethook (lua_State *L) {
   lua_rawset(L, -3);  /* set new hook */
   lua_pop(L, 1);  /* remove hook table */
   lua_sethook(L1, func, mask, count);  /* set hooks */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -295,6 +321,7 @@ static int db_gethook (lua_State *L) {
   }
   lua_pushstring(L, unmakemask(mask, buff));
   lua_pushinteger(L, lua_gethookcount(L1));
+  __A_VARIABLE = 1;
   return 3;
 }
 
@@ -304,8 +331,10 @@ static int db_debug (lua_State *L) {
     char buffer[250];
     fputs("lua_debug> ", stderr);
     if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
-        strcmp(buffer, "cont\n") == 0)
+        strcmp(buffer, "cont\n") == 0) {
+      __A_VARIABLE = 1;
       return 0;
+    }
     if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
         lua_pcall(L, 0, 0, 0)) {
       fputs(lua_tostring(L, -1), stderr);
@@ -313,6 +342,7 @@ static int db_debug (lua_State *L) {
     }
     lua_settop(L, 0);  /* remove eventual returns */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -393,6 +423,7 @@ static const luaL_Reg dblib[] = {
 
 LUALIB_API int luaopen_debug (lua_State *L) {
   luaL_register(L, LUA_DBLIBNAME, dblib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ldebug.c b/deps/lua/src/ldebug.c
index 50ad3d3..114c437 100644
--- a/deps/lua/src/ldebug.c
+++ b/deps/lua/src/ldebug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
 ** Debug Interface
@@ -34,9 +35,13 @@ static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
 
 
 static int currentpc (lua_State *L, CallInfo *ci) {
-  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  if (!isLua(ci)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* function is not a Lua function? */
   if (ci == L->ci)
     ci->savedpc = L->savedpc;
+  __A_VARIABLE = 1;
   return pcRel(ci->savedpc, ci_func(ci)->l.p);
 }
 
@@ -62,21 +67,25 @@ LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
   L->basehookcount = count;
   resethookcount(L);
   L->hookmask = cast_byte(mask);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 LUA_API lua_Hook lua_gethook (lua_State *L) {
+  __A_VARIABLE = 1;
   return L->hook;
 }
 
 
 LUA_API int lua_gethookmask (lua_State *L) {
+  __A_VARIABLE = 1;
   return L->hookmask;
 }
 
 
 LUA_API int lua_gethookcount (lua_State *L) {
+  __A_VARIABLE = 1;
   return L->basehookcount;
 }
 
@@ -100,11 +109,13 @@ LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
   }
   else status = 0;  /* no such level */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static Proto *getluaproto (CallInfo *ci) {
+  __A_VARIABLE = 1;
   return (isLua(ci) ? ci_func(ci)->l.p : NULL);
 }
 
@@ -131,6 +142,7 @@ LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
   if (name)
       luaA_pushobject(L, ci->base + (n - 1));
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
@@ -143,6 +155,7 @@ LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
       setobjs2s(L, ci->base + (n - 1), L->top - 1);
   L->top--;  /* pop value */
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return name;
 }
 
@@ -161,6 +174,7 @@ static void funcinfo (lua_Debug *ar, Closure *cl) {
     ar->what = (ar->linedefined == 0) ? "main" : "Lua";
   }
   luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+  __A_VARIABLE = 1;
 }
 
 
@@ -171,6 +185,7 @@ static void info_tailcall (lua_Debug *ar) {
   ar->source = "=(tail call)";
   luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
   ar->nups = 0;
+  __A_VARIABLE = 1;
 }
 
 
@@ -187,6 +202,7 @@ static void collectvalidlines (lua_State *L, Closure *f) {
     sethvalue(L, L->top, t); 
   }
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -195,6 +211,7 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
   int status = 1;
   if (f == NULL) {
     info_tailcall(ar);
+    __A_VARIABLE = 1;
     return status;
   }
   for (; *what; what++) {
@@ -225,6 +242,7 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
       default: status = 0;  /* invalid option */
     }
   }
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -255,6 +273,7 @@ LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
   if (strchr(what, 'L'))
     collectvalidlines(L, f);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -281,6 +300,7 @@ static int precheck (const Proto *pt) {
   check(pt->sizeupvalues <= pt->nups);
   check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
   check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -294,9 +314,11 @@ int luaG_checkopenop (Instruction i) {
     case OP_RETURN:
     case OP_SETLIST: {
       check(GETARG_B(i) == 0);
+      __A_VARIABLE = 1;
       return 1;
     }
-    default: return 0;  /* invalid instruction after an open call */
+    default: __A_VARIABLE = 1;
+    return 0;  /* invalid instruction after an open call */
   }
 }
 
@@ -310,6 +332,7 @@ static int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {
       check(ISK(r) ? INDEXK(r) < pt->sizek : r < pt->maxstacksize);
       break;
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -471,6 +494,7 @@ static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return pt->code[last];
 }
 
@@ -482,6 +506,7 @@ static Instruction symbexec (const Proto *pt, int lastpc, int reg) {
 
 
 int luaG_checkcode (const Proto *pt) {
+  __A_VARIABLE = 1;
   return (symbexec(pt, pt->sizecode, NO_REG) != 0);
 }
 
@@ -501,8 +526,10 @@ static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
     int pc = currentpc(L, ci);
     Instruction i;
     *name = luaF_getlocalname(p, stackpos+1, pc);
-    if (*name)  /* is a local? */
+    if (*name)  /* is a local? */ {
+      __A_VARIABLE = 1;
       return "local";
+    }
     i = symbexec(p, pc, stackpos);  /* try symbolic execution */
     lua_assert(pc != -1);
     switch (GET_OPCODE(i)) {
@@ -510,33 +537,40 @@ static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,
         int g = GETARG_Bx(i);  /* global index */
         lua_assert(ttisstring(&p->k[g]));
         *name = svalue(&p->k[g]);
+        __A_VARIABLE = 1;
         return "global";
       }
       case OP_MOVE: {
         int a = GETARG_A(i);
         int b = GETARG_B(i);  /* move from `b' to `a' */
-        if (b < a)
-          return getobjname(L, ci, b, name);  /* get name for `b' */
+        if (b < a) {
+          __A_VARIABLE = 1;
+          return getobjname(L, ci, b, name);
+        }  /* get name for `b' */
         break;
       }
       case OP_GETTABLE: {
         int k = GETARG_C(i);  /* key index */
         *name = kname(p, k);
+        __A_VARIABLE = 1;
         return "field";
       }
       case OP_GETUPVAL: {
         int u = GETARG_B(i);  /* upvalue index */
         *name = p->upvalues ? getstr(p->upvalues[u]) : "?";
+        __A_VARIABLE = 1;
         return "upvalue";
       }
       case OP_SELF: {
         int k = GETARG_C(i);  /* key index */
         *name = kname(p, k);
+        __A_VARIABLE = 1;
         return "method";
       }
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* no useful name found */
 }
 
@@ -559,7 +593,11 @@ static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
 static int isinstack (CallInfo *ci, const TValue *o) {
   StkId p;
   for (p = ci->base; p < ci->top; p++)
-    if (o == p) return 1;
+    if (o == p) {
+      __A_VARIABLE = 1;
+      return 1;
+    }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -575,6 +613,7 @@ void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
                 op, kind, name, t);
   else
     luaG_runerror(L, "attempt to %s a %s value", op, t);
+  __A_VARIABLE = 1;
 }
 
 
@@ -582,6 +621,7 @@ void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
   if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
   lua_assert(!ttisstring(p1) && !ttisnumber(p1));
   luaG_typeerror(L, p1, "concatenate");
+  __A_VARIABLE = 1;
 }
 
 
@@ -590,6 +630,7 @@ void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
   if (luaV_tonumber(p1, &temp) == NULL)
     p2 = p1;  /* first operand is wrong */
   luaG_typeerror(L, p2, "perform arithmetic on");
+  __A_VARIABLE = 1;
 }
 
 
@@ -600,6 +641,7 @@ int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
     luaG_runerror(L, "attempt to compare two %s values", t1);
   else
     luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -612,6 +654,7 @@ static void addinfo (lua_State *L, const char *msg) {
     luaO_chunkid(buff, getstr(getluaproto(ci)->source), LUA_IDSIZE);
     luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -625,6 +668,7 @@ void luaG_errormsg (lua_State *L) {
     luaD_call(L, L->top - 2, 1);  /* call it */
   }
   luaD_throw(L, LUA_ERRRUN);
+  __A_VARIABLE = 1;
 }
 
 
@@ -634,5 +678,6 @@ void luaG_runerror (lua_State *L, const char *fmt, ...) {
   addinfo(L, luaO_pushvfstring(L, fmt, argp));
   va_end(argp);
   luaG_errormsg(L);
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/ldo.c b/deps/lua/src/ldo.c
index 514f7a2..25c1d5e 100644
--- a/deps/lua/src/ldo.c
+++ b/deps/lua/src/ldo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ldo.c,v 2.38.1.4 2012/01/18 02:27:10 roberto Exp $
 ** Stack and Call structure of Lua
@@ -65,6 +66,7 @@ void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
     }
   }
   L->top = oldtop + 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -75,6 +77,7 @@ static void restore_stack_limit (lua_State *L) {
     if (inuse + 1 < LUAI_MAXCALLS)  /* can `undo' overflow? */
       luaD_reallocCI(L, LUAI_MAXCALLS);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -88,6 +91,7 @@ static void resetstack (lua_State *L, int status) {
   restore_stack_limit(L);
   L->errfunc = 0;
   L->errorJmp = NULL;
+  __A_VARIABLE = 1;
 }
 
 
@@ -105,6 +109,7 @@ void luaD_throw (lua_State *L, int errcode) {
     }
     exit(EXIT_FAILURE);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -117,6 +122,7 @@ int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
     (*f)(L, ud);
   );
   L->errorJmp = lj.previous;  /* restore old error handler */
+  __A_VARIABLE = 1;
   return lj.status;
 }
 
@@ -135,6 +141,7 @@ static void correctstack (lua_State *L, TValue *oldstack) {
     ci->func = (ci->func - oldstack) + L->stack;
   }
   L->base = (L->base - oldstack) + L->stack;
+  __A_VARIABLE = 1;
 }
 
 
@@ -146,6 +153,7 @@ void luaD_reallocstack (lua_State *L, int newsize) {
   L->stacksize = realsize;
   L->stack_last = L->stack+newsize;
   correctstack(L, oldstack);
+  __A_VARIABLE = 1;
 }
 
 
@@ -155,6 +163,7 @@ void luaD_reallocCI (lua_State *L, int newsize) {
   L->size_ci = newsize;
   L->ci = (L->ci - oldci) + L->base_ci;
   L->end_ci = L->base_ci + L->size_ci - 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -163,6 +172,7 @@ void luaD_growstack (lua_State *L, int n) {
     luaD_reallocstack(L, 2*L->stacksize);
   else
     luaD_reallocstack(L, L->stacksize + n);
+  __A_VARIABLE = 1;
 }
 
 
@@ -174,6 +184,7 @@ static CallInfo *growCI (lua_State *L) {
     if (L->size_ci > LUAI_MAXCALLS)
       luaG_runerror(L, "stack overflow");
   }
+  __A_VARIABLE = 1;
   return ++L->ci;
 }
 
@@ -202,6 +213,7 @@ void luaD_callhook (lua_State *L, int event, int line) {
     L->ci->top = restorestack(L, ci_top);
     L->top = restorestack(L, top);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -237,6 +249,7 @@ static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
     sethvalue(L, L->top++, htab);
     lua_assert(iswhite(obj2gco(htab)));
   }
+  __A_VARIABLE = 1;
   return base;
 }
 
@@ -252,6 +265,7 @@ static StkId tryfuncTM (lua_State *L, StkId func) {
   incr_top(L);
   func = restorestack(L, funcr);  /* previous call may change stack */
   setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  __A_VARIABLE = 1;
   return func;
 }
 
@@ -336,6 +350,7 @@ static StkId callrethooks (lua_State *L, StkId firstResult) {
     while ((L->hookmask & LUA_MASKRET) && L->ci->tailcalls--) /* tail calls */
       luaD_callhook(L, LUA_HOOKTAILRET, -1);
   }
+  __A_VARIABLE = 1;
   return restorestack(L, fr);
 }
 
@@ -357,6 +372,7 @@ int luaD_poscall (lua_State *L, StkId firstResult) {
   while (i-- > 0)
     setnilvalue(res++);
   L->top = res;
+  __A_VARIABLE = 1;
   return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
 }
 
@@ -378,6 +394,7 @@ void luaD_call (lua_State *L, StkId func, int nResults) {
     luaV_execute(L, 1);  /* call it */
   L->nCcalls--;
   luaC_checkGC(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -411,6 +428,7 @@ static int resume_error (lua_State *L, const char *msg) {
   setsvalue2s(L, L->top, luaS_new(L, msg));
   incr_top(L);
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return LUA_ERRRUN;
 }
 
@@ -418,10 +436,14 @@ static int resume_error (lua_State *L, const char *msg) {
 LUA_API int lua_resume (lua_State *L, int nargs) {
   int status;
   lua_lock(L);
-  if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci))
+  if (L->status != LUA_YIELD && (L->status != 0 || L->ci != L->base_ci)) {
+      __A_VARIABLE = 1;
       return resume_error(L, "cannot resume non-suspended coroutine");
-  if (L->nCcalls >= LUAI_MAXCCALLS)
+  }
+  if (L->nCcalls >= LUAI_MAXCCALLS) {
+    __A_VARIABLE = 1;
     return resume_error(L, "C stack overflow");
+  }
   luai_userstateresume(L, nargs);
   lua_assert(L->errfunc == 0);
   L->baseCcalls = ++L->nCcalls;
@@ -437,6 +459,7 @@ LUA_API int lua_resume (lua_State *L, int nargs) {
   }
   --L->nCcalls;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -449,6 +472,7 @@ LUA_API int lua_yield (lua_State *L, int nresults) {
   L->base = L->top - nresults;  /* protect stack slots below */
   L->status = LUA_YIELD;
   lua_unlock(L);
+  __A_VARIABLE = 1;
   return -1;
 }
 
@@ -474,6 +498,7 @@ int luaD_pcall (lua_State *L, Pfunc func, void *u,
     restore_stack_limit(L);
   }
   L->errfunc = old_errfunc;
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -503,6 +528,7 @@ static void f_parser (lua_State *L, void *ud) {
     cl->l.upvals[i] = luaF_newupval(L);
   setclvalue(L, L->top, cl);
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -513,6 +539,7 @@ int luaD_protectedparser (lua_State *L, ZIO *z, const char *name) {
   luaZ_initbuffer(L, &p.buff);
   status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
   luaZ_freebuffer(L, &p.buff);
+  __A_VARIABLE = 1;
   return status;
 }
 
diff --git a/deps/lua/src/ldump.c b/deps/lua/src/ldump.c
index c9d3d48..7d43e9e 100644
--- a/deps/lua/src/ldump.c
+++ b/deps/lua/src/ldump.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ldump.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** save precompiled Lua chunks
@@ -34,28 +35,33 @@ static void DumpBlock(const void* b, size_t size, DumpState* D)
   D->status=(*D->writer)(D->L,b,size,D->data);
   lua_lock(D->L);
  }
+ __A_VARIABLE = 1;
 }
 
 static void DumpChar(int y, DumpState* D)
 {
  char x=(char)y;
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpInt(int x, DumpState* D)
 {
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpNumber(lua_Number x, DumpState* D)
 {
  DumpVar(x,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpVector(const void* b, int n, size_t size, DumpState* D)
 {
  DumpInt(n,D);
  DumpMem(b,n,size,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpString(const TString* s, DumpState* D)
@@ -71,6 +77,7 @@ static void DumpString(const TString* s, DumpState* D)
   DumpVar(size,D);
   DumpBlock(getstr(s),size,D);
  }
+ __A_VARIABLE = 1;
 }
 
 #define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
@@ -106,6 +113,7 @@ static void DumpConstants(const Proto* f, DumpState* D)
  n=f->sizep;
  DumpInt(n,D);
  for (i=0; i<n; i++) DumpFunction(f->p[i],f->source,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpDebug(const Proto* f, DumpState* D)
@@ -124,6 +132,7 @@ static void DumpDebug(const Proto* f, DumpState* D)
  n= (D->strip) ? 0 : f->sizeupvalues;
  DumpInt(n,D);
  for (i=0; i<n; i++) DumpString(f->upvalues[i],D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
@@ -138,6 +147,7 @@ static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
  DumpCode(f,D);
  DumpConstants(f,D);
  DumpDebug(f,D);
+ __A_VARIABLE = 1;
 }
 
 static void DumpHeader(DumpState* D)
@@ -145,6 +155,7 @@ static void DumpHeader(DumpState* D)
  char h[LUAC_HEADERSIZE];
  luaU_header(h);
  DumpBlock(h,LUAC_HEADERSIZE,D);
+ __A_VARIABLE = 1;
 }
 
 /*
@@ -160,5 +171,6 @@ int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip
  D.status=0;
  DumpHeader(&D);
  DumpFunction(f,NULL,&D);
+ __A_VARIABLE = 1;
  return D.status;
 }
diff --git a/deps/lua/src/lfunc.c b/deps/lua/src/lfunc.c
index 813e88f..f9c7f8f 100644
--- a/deps/lua/src/lfunc.c
+++ b/deps/lua/src/lfunc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
@@ -26,6 +27,7 @@ Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
   c->c.isC = 1;
   c->c.env = e;
   c->c.nupvalues = cast_byte(nelems);
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -37,6 +39,7 @@ Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {
   c->l.env = e;
   c->l.nupvalues = cast_byte(nelems);
   while (nelems--) c->l.upvals[nelems] = NULL;
+  __A_VARIABLE = 1;
   return c;
 }
 
@@ -46,6 +49,7 @@ UpVal *luaF_newupval (lua_State *L) {
   luaC_link(L, obj2gco(uv), LUA_TUPVAL);
   uv->v = &uv->u.value;
   setnilvalue(uv->v);
+  __A_VARIABLE = 1;
   return uv;
 }
 
@@ -60,6 +64,7 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
     if (p->v == level) {  /* found a corresponding upvalue? */
       if (isdead(g, obj2gco(p)))  /* is it dead? */
         changewhite(obj2gco(p));  /* ressurect it */
+      __A_VARIABLE = 1;
       return p;
     }
     pp = &p->next;
@@ -75,6 +80,7 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
   uv->u.l.next->u.l.prev = uv;
   g->uvhead.u.l.next = uv;
   lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  __A_VARIABLE = 1;
   return uv;
 }
 
@@ -83,6 +89,7 @@ static void unlinkupval (UpVal *uv) {
   lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
   uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
   uv->u.l.prev->u.l.next = uv->u.l.next;
+  __A_VARIABLE = 1;
 }
 
 
@@ -90,6 +97,7 @@ void luaF_freeupval (lua_State *L, UpVal *uv) {
   if (uv->v != &uv->u.value)  /* is it open? */
     unlinkupval(uv);  /* remove from open list */
   luaM_free(L, uv);  /* free upvalue */
+  __A_VARIABLE = 1;
 }
 
 
@@ -109,6 +117,7 @@ void luaF_close (lua_State *L, StkId level) {
       luaC_linkupval(L, uv);  /* link upvalue into `gcroot' list */
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -134,6 +143,7 @@ Proto *luaF_newproto (lua_State *L) {
   f->linedefined = 0;
   f->lastlinedefined = 0;
   f->source = NULL;
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -146,6 +156,7 @@ void luaF_freeproto (lua_State *L, Proto *f) {
   luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
   luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
   luaM_free(L, f);
+  __A_VARIABLE = 1;
 }
 
 
@@ -153,6 +164,7 @@ void luaF_freeclosure (lua_State *L, Closure *c) {
   int size = (c->c.isC) ? sizeCclosure(c->c.nupvalues) :
                           sizeLclosure(c->l.nupvalues);
   luaM_freemem(L, c, size);
+  __A_VARIABLE = 1;
 }
 
 
@@ -165,10 +177,13 @@ const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
   for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
     if (pc < f->locvars[i].endpc) {  /* is variable active? */
       local_number--;
-      if (local_number == 0)
+      if (local_number == 0) {
+        __A_VARIABLE = 1;
         return getstr(f->locvars[i].varname);
+      }
     }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* not found */
 }
 
diff --git a/deps/lua/src/lgc.c b/deps/lua/src/lgc.c
index e909c79..bda24c6 100644
--- a/deps/lua/src/lgc.c
+++ b/deps/lua/src/lgc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lgc.c,v 2.38.1.2 2011/03/18 18:05:38 roberto Exp $
 ** Garbage Collector
@@ -63,6 +64,7 @@ static void removeentry (Node *n) {
   lua_assert(ttisnil(gval(n)));
   if (iscollectable(gkey(n)))
     setttype(gkey(n), LUA_TDEADKEY);  /* dead key; remove it */
+  __A_VARIABLE = 1;
 }
 
 
@@ -71,6 +73,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
   white2gray(o);
   switch (o->gch.tt) {
     case LUA_TSTRING: {
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TUSERDATA: {
@@ -78,6 +81,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
       gray2black(o);  /* udata are never gray */
       if (mt) markobject(g, mt);
       markobject(g, gco2u(o)->env);
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TUPVAL: {
@@ -85,6 +89,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
       markvalue(g, uv->v);
       if (uv->v == &uv->u.value)  /* closed? */
         gray2black(o);  /* open upvalues are never black */
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TFUNCTION: {
@@ -109,6 +114,7 @@ static void reallymarkobject (global_State *g, GCObject *o) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -121,6 +127,7 @@ static void marktmu (global_State *g) {
       reallymarkobject(g, u);
     } while (u != g->tmudata);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -151,6 +158,7 @@ size_t luaC_separateudata (lua_State *L, int all) {
       }
     }
   }
+  __A_VARIABLE = 1;
   return deadmem;
 }
 
@@ -174,7 +182,10 @@ static int traversetable (global_State *g, Table *h) {
       g->weak = obj2gco(h);  /* ... so put in the appropriate list */
     }
   }
-  if (weakkey && weakvalue) return 1;
+  if (weakkey && weakvalue) {
+    __A_VARIABLE = 1;
+    return 1;
+  }
   if (!weakvalue) {
     i = h->sizearray;
     while (i--)
@@ -192,6 +203,7 @@ static int traversetable (global_State *g, Table *h) {
       if (!weakvalue) markvalue(g, gval(n));
     }
   }
+  __A_VARIABLE = 1;
   return weakkey || weakvalue;
 }
 
@@ -217,6 +229,7 @@ static void traverseproto (global_State *g, Proto *f) {
     if (f->locvars[i].varname)
       stringmark(f->locvars[i].varname);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -235,14 +248,17 @@ static void traverseclosure (global_State *g, Closure *cl) {
     for (i=0; i<cl->l.nupvalues; i++)  /* mark its upvalues */
       markobject(g, cl->l.upvals[i]);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void checkstacksizes (lua_State *L, StkId max) {
   int ci_used = cast_int(L->ci - L->base_ci);  /* number of `ci' in use */
   int s_used = cast_int(max - L->stack);  /* part of stack in use */
-  if (L->size_ci > LUAI_MAXCALLS)  /* handling overflow? */
-    return;  /* do not touch the stacks */
+  if (L->size_ci > LUAI_MAXCALLS)  /* handling overflow? */ {
+    __A_VARIABLE = 1;
+    return;
+  }  /* do not touch the stacks */
   if (4*ci_used < L->size_ci && 2*BASIC_CI_SIZE < L->size_ci)
     luaD_reallocCI(L, L->size_ci/2);  /* still big enough... */
   condhardstacktests(luaD_reallocCI(L, ci_used + 1));
@@ -250,6 +266,7 @@ static void checkstacksizes (lua_State *L, StkId max) {
       2*(BASIC_STACK_SIZE+EXTRA_STACK) < L->stacksize)
     luaD_reallocstack(L, L->stacksize/2);  /* still big enough... */
   condhardstacktests(luaD_reallocstack(L, s_used));
+  __A_VARIABLE = 1;
 }
 
 
@@ -267,6 +284,7 @@ static void traversestack (global_State *g, lua_State *l) {
   for (; o <= lim; o++)
     setnilvalue(o);
   checkstacksizes(l, lim);
+  __A_VARIABLE = 1;
 }
 
 
@@ -284,6 +302,7 @@ static l_mem propagatemark (global_State *g) {
       g->gray = h->gclist;
       if (traversetable(g, h))  /* table is weak? */
         black2gray(o);  /* keep it gray */
+      __A_VARIABLE = 1;
       return sizeof(Table) + sizeof(TValue) * h->sizearray +
                              sizeof(Node) * sizenode(h);
     }
@@ -291,6 +310,7 @@ static l_mem propagatemark (global_State *g) {
       Closure *cl = gco2cl(o);
       g->gray = cl->c.gclist;
       traverseclosure(g, cl);
+      __A_VARIABLE = 1;
       return (cl->c.isC) ? sizeCclosure(cl->c.nupvalues) :
                            sizeLclosure(cl->l.nupvalues);
     }
@@ -301,6 +321,7 @@ static l_mem propagatemark (global_State *g) {
       g->grayagain = o;
       black2gray(o);
       traversestack(g, th);
+      __A_VARIABLE = 1;
       return sizeof(lua_State) + sizeof(TValue) * th->stacksize +
                                  sizeof(CallInfo) * th->size_ci;
     }
@@ -308,6 +329,7 @@ static l_mem propagatemark (global_State *g) {
       Proto *p = gco2p(o);
       g->gray = p->gclist;
       traverseproto(g, p);
+      __A_VARIABLE = 1;
       return sizeof(Proto) + sizeof(Instruction) * p->sizecode +
                              sizeof(Proto *) * p->sizep +
                              sizeof(TValue) * p->sizek + 
@@ -315,7 +337,8 @@ static l_mem propagatemark (global_State *g) {
                              sizeof(LocVar) * p->sizelocvars +
                              sizeof(TString *) * p->sizeupvalues;
     }
-    default: lua_assert(0); return 0;
+    default: lua_assert(0); __A_VARIABLE = 1;
+    return 0;
   }
 }
 
@@ -323,6 +346,7 @@ static l_mem propagatemark (global_State *g) {
 static size_t propagateall (global_State *g) {
   size_t m = 0;
   while (g->gray) m += propagatemark(g);
+  __A_VARIABLE = 1;
   return m;
 }
 
@@ -335,11 +359,16 @@ static size_t propagateall (global_State *g) {
 ** being finalized, keep them in keys, but not in values
 */
 static int iscleared (const TValue *o, int iskey) {
-  if (!iscollectable(o)) return 0;
+  if (!iscollectable(o)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (ttisstring(o)) {
     stringmark(rawtsvalue(o));  /* strings are `values', so are never weak */
+    __A_VARIABLE = 1;
     return 0;
   }
+  __A_VARIABLE = 1;
   return iswhite(gcvalue(o)) ||
     (ttisuserdata(o) && (!iskey && isfinalized(uvalue(o))));
 }
@@ -372,6 +401,7 @@ static void cleartable (GCObject *l) {
     }
     l = h->gclist;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -397,6 +427,7 @@ static void freeobj (lua_State *L, GCObject *o) {
     }
     default: lua_assert(0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -424,6 +455,7 @@ static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
       freeobj(L, curr);
     }
   }
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -439,6 +471,7 @@ static void checkSizes (lua_State *L) {
     size_t newsize = luaZ_sizebuffer(&g->buff) / 2;
     luaZ_resizebuffer(L, &g->buff, newsize);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -468,6 +501,7 @@ static void GCTM (lua_State *L) {
     L->allowhook = oldah;  /* restore hooks */
     g->GCthreshold = oldt;  /* restore threshold */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -477,6 +511,7 @@ static void GCTM (lua_State *L) {
 void luaC_callGCTM (lua_State *L) {
   while (G(L)->tmudata)
     GCTM(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -487,6 +522,7 @@ void luaC_freeall (lua_State *L) {
   sweepwholelist(L, &g->rootgc);
   for (i = 0; i < g->strt.size; i++)  /* free all string lists */
     sweepwholelist(L, &g->strt.hash[i]);
+  __A_VARIABLE = 1;
 }
 
 
@@ -494,6 +530,7 @@ static void markmt (global_State *g) {
   int i;
   for (i=0; i<NUM_TAGS; i++)
     if (g->mt[i]) markobject(g, g->mt[i]);
+  __A_VARIABLE = 1;
 }
 
 
@@ -509,6 +546,7 @@ static void markroot (lua_State *L) {
   markvalue(g, registry(L));
   markmt(g);
   g->gcstate = GCSpropagate;
+  __A_VARIABLE = 1;
 }
 
 
@@ -519,6 +557,7 @@ static void remarkupvals (global_State *g) {
     if (isgray(obj2gco(uv)))
       markvalue(g, uv->v);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -550,6 +589,7 @@ static void atomic (lua_State *L) {
   g->sweepgc = &g->rootgc;
   g->gcstate = GCSsweepstring;
   g->estimate = g->totalbytes - udsize;  /* first estimate */
+  __A_VARIABLE = 1;
 }
 
 
@@ -629,6 +669,7 @@ void luaC_step (lua_State *L) {
   else {
     setthreshold(g);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -655,6 +696,7 @@ void luaC_fullgc (lua_State *L) {
     singlestep(L);
   }
   setthreshold(g);
+  __A_VARIABLE = 1;
 }
 
 
@@ -668,6 +710,7 @@ void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {
     reallymarkobject(g, v);  /* restore invariant */
   else  /* don't mind */
     makewhite(g, o);  /* mark as white just to avoid other barriers */
+    __A_VARIABLE = 1;
 }
 
 
@@ -679,6 +722,7 @@ void luaC_barrierback (lua_State *L, Table *t) {
   black2gray(o);  /* make table gray (again) */
   t->gclist = g->grayagain;
   g->grayagain = o;
+  __A_VARIABLE = 1;
 }
 
 
@@ -688,6 +732,7 @@ void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
   g->rootgc = o;
   o->gch.marked = luaC_white(g);
   o->gch.tt = tt;
+  __A_VARIABLE = 1;
 }
 
 
@@ -706,5 +751,6 @@ void luaC_linkupval (lua_State *L, UpVal *uv) {
       lua_assert(g->gcstate != GCSfinalize && g->gcstate != GCSpause);
     }
   }
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/linit.c b/deps/lua/src/linit.c
index c1f90df..8cab450 100644
--- a/deps/lua/src/linit.c
+++ b/deps/lua/src/linit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Initialization of libraries for lua.c
@@ -34,5 +35,6 @@ LUALIB_API void luaL_openlibs (lua_State *L) {
     lua_pushstring(L, lib->name);
     lua_call(L, 1, 0);
   }
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/liolib.c b/deps/lua/src/liolib.c
index 649f9a5..7b3023b 100644
--- a/deps/lua/src/liolib.c
+++ b/deps/lua/src/liolib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: liolib.c,v 2.73.1.4 2010/05/14 15:33:51 roberto Exp $
 ** Standard I/O (and system) library
@@ -48,6 +49,7 @@ static int pushresult (lua_State *L, int i, const char *filename) {
 static void fileerror (lua_State *L, int arg, const char *filename) {
   lua_pushfstring(L, "%s: %s", filename, strerror(errno));
   luaL_argerror(L, arg, lua_tostring(L, -1));
+  __A_VARIABLE = 1;
 }
 
 
@@ -65,6 +67,7 @@ static int io_type (lua_State *L) {
     lua_pushliteral(L, "closed file");
   else
     lua_pushliteral(L, "file");
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -73,6 +76,7 @@ static FILE *tofile (lua_State *L) {
   FILE **f = tofilep(L);
   if (*f == NULL)
     luaL_error(L, "attempt to use a closed file");
+  __A_VARIABLE = 1;
   return *f;
 }
 
@@ -88,6 +92,7 @@ static FILE **newfile (lua_State *L) {
   *pf = NULL;  /* file handle is currently `closed' */
   luaL_getmetatable(L, LUA_FILEHANDLE);
   lua_setmetatable(L, -2);
+  __A_VARIABLE = 1;
   return pf;
 }
 
@@ -98,6 +103,7 @@ static FILE **newfile (lua_State *L) {
 static int io_noclose (lua_State *L) {
   lua_pushnil(L);
   lua_pushliteral(L, "cannot close standard file");
+  __A_VARIABLE = 1;
   return 2;
 }
 
@@ -109,6 +115,7 @@ static int io_pclose (lua_State *L) {
   FILE **p = tofilep(L);
   int ok = lua_pclose(L, *p);
   *p = NULL;
+  __A_VARIABLE = 1;
   return pushresult(L, ok, NULL);
 }
 
@@ -120,6 +127,7 @@ static int io_fclose (lua_State *L) {
   FILE **p = tofilep(L);
   int ok = (fclose(*p) == 0);
   *p = NULL;
+  __A_VARIABLE = 1;
   return pushresult(L, ok, NULL);
 }
 
@@ -127,6 +135,7 @@ static int io_fclose (lua_State *L) {
 static int aux_close (lua_State *L) {
   lua_getfenv(L, 1);
   lua_getfield(L, -1, "__close");
+  __A_VARIABLE = 1;
   return (lua_tocfunction(L, -1))(L);
 }
 
@@ -135,6 +144,7 @@ static int io_close (lua_State *L) {
   if (lua_isnone(L, 1))
     lua_rawgeti(L, LUA_ENVIRONINDEX, IO_OUTPUT);
   tofile(L);  /* make sure argument is a file */
+  __A_VARIABLE = 1;
   return aux_close(L);
 }
 
@@ -144,6 +154,7 @@ static int io_gc (lua_State *L) {
   /* ignore closed files */
   if (f != NULL)
     aux_close(L);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -154,6 +165,7 @@ static int io_tostring (lua_State *L) {
     lua_pushliteral(L, "file (closed)");
   else
     lua_pushfstring(L, "file (%p)", f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -163,6 +175,7 @@ static int io_open (lua_State *L) {
   const char *mode = luaL_optstring(L, 2, "r");
   FILE **pf = newfile(L);
   *pf = fopen(filename, mode);
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
@@ -176,6 +189,7 @@ static int io_popen (lua_State *L) {
   const char *mode = luaL_optstring(L, 2, "r");
   FILE **pf = newfile(L);
   *pf = lua_popen(L, filename, mode);
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
 }
 
@@ -183,6 +197,7 @@ static int io_popen (lua_State *L) {
 static int io_tmpfile (lua_State *L) {
   FILE **pf = newfile(L);
   *pf = tmpfile();
+  __A_VARIABLE = 1;
   return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
 }
 
@@ -193,6 +208,7 @@ static FILE *getiofile (lua_State *L, int findex) {
   f = *(FILE **)lua_touserdata(L, -1);
   if (f == NULL)
     luaL_error(L, "standard %s file is closed", fnames[findex - 1]);
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -214,16 +230,19 @@ static int g_iofile (lua_State *L, int f, const char *mode) {
   }
   /* return current value */
   lua_rawgeti(L, LUA_ENVIRONINDEX, f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int io_input (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_iofile(L, IO_INPUT, "r");
 }
 
 
 static int io_output (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_iofile(L, IO_OUTPUT, "w");
 }
 
@@ -235,12 +254,14 @@ static void aux_lines (lua_State *L, int idx, int toclose) {
   lua_pushvalue(L, idx);
   lua_pushboolean(L, toclose);  /* close/not close file when finished */
   lua_pushcclosure(L, io_readline, 2);
+  __A_VARIABLE = 1;
 }
 
 
 static int f_lines (lua_State *L) {
   tofile(L);  /* check that it's a valid file handle */
   aux_lines(L, 1, 0);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -287,6 +308,7 @@ static int test_eof (lua_State *L, FILE *f) {
   int c = getc(f);
   ungetc(c, f);
   lua_pushlstring(L, NULL, 0);
+  __A_VARIABLE = 1;
   return (c != EOF);
 }
 
@@ -327,6 +349,7 @@ static int read_chars (lua_State *L, FILE *f, size_t n) {
     n -= nr;  /* still have to read `n' chars */
   } while (n > 0 && nr == rlen);  /* until end of count or eof */
   luaL_pushresult(&b);  /* close buffer */
+  __A_VARIABLE = 1;
   return (n == 0 || lua_objlen(L, -1) > 0);
 }
 
@@ -379,11 +402,13 @@ static int g_read (lua_State *L, FILE *f, int first) {
 
 
 static int io_read (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_read(L, getiofile(L, IO_INPUT), 1);
 }
 
 
 static int f_read (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_read(L, tofile(L), 2);
 }
 
@@ -425,16 +450,19 @@ static int g_write (lua_State *L, FILE *f, int arg) {
       status = status && (fwrite(s, sizeof(char), l, f) == l);
     }
   }
+  __A_VARIABLE = 1;
   return pushresult(L, status, NULL);
 }
 
 
 static int io_write (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_write(L, getiofile(L, IO_OUTPUT), 1);
 }
 
 
 static int f_write (lua_State *L) {
+  __A_VARIABLE = 1;
   return g_write(L, tofile(L), 2);
 }
 
@@ -462,17 +490,20 @@ static int f_setvbuf (lua_State *L) {
   int op = luaL_checkoption(L, 2, NULL, modenames);
   lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
   int res = setvbuf(f, NULL, mode[op], sz);
+  __A_VARIABLE = 1;
   return pushresult(L, res == 0, NULL);
 }
 
 
 
 static int io_flush (lua_State *L) {
+  __A_VARIABLE = 1;
   return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
 }
 
 
 static int f_flush (lua_State *L) {
+  __A_VARIABLE = 1;
   return pushresult(L, fflush(tofile(L)) == 0, NULL);
 }
 
@@ -512,6 +543,7 @@ static void createmeta (lua_State *L) {
   lua_pushvalue(L, -1);  /* push metatable */
   lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
   luaL_register(L, NULL, flib);  /* file methods */
+  __A_VARIABLE = 1;
 }
 
 
@@ -524,6 +556,7 @@ static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {
   lua_pushvalue(L, -2);  /* copy environment */
   lua_setfenv(L, -2);  /* set it */
   lua_setfield(L, -3, fname);
+  __A_VARIABLE = 1;
 }
 
 
@@ -531,6 +564,7 @@ static void newfenv (lua_State *L, lua_CFunction cls) {
   lua_createtable(L, 0, 1);
   lua_pushcfunction(L, cls);
   lua_setfield(L, -2, "__close");
+  __A_VARIABLE = 1;
 }
 
 
@@ -551,6 +585,7 @@ LUALIB_API int luaopen_io (lua_State *L) {
   newfenv(L, io_pclose);  /* create environment for 'popen' */
   lua_setfenv(L, -2);  /* set fenv for 'popen' */
   lua_pop(L, 1);  /* pop 'popen' */
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/llex.c b/deps/lua/src/llex.c
index 88c6790..82bf1be 100644
--- a/deps/lua/src/llex.c
+++ b/deps/lua/src/llex.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: llex.c,v 2.20.1.2 2009/11/23 14:58:22 roberto Exp $
 ** Lexical Analyzer
diff --git a/deps/lua/src/lmathlib.c b/deps/lua/src/lmathlib.c
index 441fbf7..4aad9d4 100644
--- a/deps/lua/src/lmathlib.c
+++ b/deps/lua/src/lmathlib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lmathlib.c,v 1.67.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Standard mathematical library
@@ -25,71 +26,85 @@
 
 static int math_abs (lua_State *L) {
   lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_sin (lua_State *L) {
   lua_pushnumber(L, sin(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_sinh (lua_State *L) {
   lua_pushnumber(L, sinh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_cos (lua_State *L) {
   lua_pushnumber(L, cos(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_cosh (lua_State *L) {
   lua_pushnumber(L, cosh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_tan (lua_State *L) {
   lua_pushnumber(L, tan(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_tanh (lua_State *L) {
   lua_pushnumber(L, tanh(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_asin (lua_State *L) {
   lua_pushnumber(L, asin(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_acos (lua_State *L) {
   lua_pushnumber(L, acos(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_atan (lua_State *L) {
   lua_pushnumber(L, atan(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_atan2 (lua_State *L) {
   lua_pushnumber(L, atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_ceil (lua_State *L) {
   lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_floor (lua_State *L) {
   lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_fmod (lua_State *L) {
   lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -98,41 +113,49 @@ static int math_modf (lua_State *L) {
   double fp = modf(luaL_checknumber(L, 1), &ip);
   lua_pushnumber(L, ip);
   lua_pushnumber(L, fp);
+  __A_VARIABLE = 1;
   return 2;
 }
 
 static int math_sqrt (lua_State *L) {
   lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_pow (lua_State *L) {
   lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_log (lua_State *L) {
   lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_log10 (lua_State *L) {
   lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_exp (lua_State *L) {
   lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_deg (lua_State *L) {
   lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 static int math_rad (lua_State *L) {
   lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -140,11 +163,13 @@ static int math_frexp (lua_State *L) {
   int e;
   lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &e));
   lua_pushinteger(L, e);
+  __A_VARIABLE = 1;
   return 2;
 }
 
 static int math_ldexp (lua_State *L) {
   lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -160,6 +185,7 @@ static int math_min (lua_State *L) {
       dmin = d;
   }
   lua_pushnumber(L, dmin);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -174,6 +200,7 @@ static int math_max (lua_State *L) {
       dmax = d;
   }
   lua_pushnumber(L, dmax);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -200,14 +227,17 @@ static int math_random (lua_State *L) {
       lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
       break;
     }
-    default: return luaL_error(L, "wrong number of arguments");
+    default: __A_VARIABLE = 1;
+    return luaL_error(L, "wrong number of arguments");
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int math_randomseed (lua_State *L) {
   srand(luaL_checkint(L, 1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -258,6 +288,7 @@ LUALIB_API int luaopen_math (lua_State *L) {
   lua_getfield(L, -1, "fmod");
   lua_setfield(L, -2, "mod");
 #endif
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/lmem.c b/deps/lua/src/lmem.c
index ae7d8c9..cb75b7e 100644
--- a/deps/lua/src/lmem.c
+++ b/deps/lua/src/lmem.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Interface to Memory Manager
@@ -59,12 +60,14 @@ void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
   }
   newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
   *size = newsize;  /* update only when everything else is OK */
+  __A_VARIABLE = 1;
   return newblock;
 }
 
 
 void *luaM_toobig (lua_State *L) {
   luaG_runerror(L, "memory allocation error: block too big");
+  __A_VARIABLE = 1;
   return NULL;  /* to avoid warnings */
 }
 
@@ -81,6 +84,7 @@ void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
     luaD_throw(L, LUA_ERRMEM);
   lua_assert((nsize == 0) == (block == NULL));
   g->totalbytes = (g->totalbytes - osize) + nsize;
+  __A_VARIABLE = 1;
   return block;
 }
 
diff --git a/deps/lua/src/loadlib.c b/deps/lua/src/loadlib.c
index 6158c53..cae4a9e 100644
--- a/deps/lua/src/loadlib.c
+++ b/deps/lua/src/loadlib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: loadlib.c,v 1.52.1.4 2009/09/09 13:17:16 roberto Exp $
 ** Dynamic library loader for Lua
@@ -62,12 +63,14 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
 
 static void ll_unloadlib (void *lib) {
   dlclose(lib);
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
   void *lib = dlopen(path, RTLD_NOW);
   if (lib == NULL) lua_pushstring(L, dlerror());
+  __A_VARIABLE = 1;
   return lib;
 }
 
@@ -75,6 +78,7 @@ static void *ll_load (lua_State *L, const char *path) {
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
   lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
   if (f == NULL) lua_pushstring(L, dlerror());
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -106,6 +110,7 @@ static void setprogdir (lua_State *L) {
     luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);
     lua_remove(L, -2);  /* remove original string */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -117,16 +122,19 @@ static void pusherror (lua_State *L) {
     lua_pushstring(L, buffer);
   else
     lua_pushfstring(L, "system error %d\n", error);
+  __A_VARIABLE = 1;
 }
 
 static void ll_unloadlib (void *lib) {
   FreeLibrary((HINSTANCE)lib);
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
   HINSTANCE lib = LoadLibraryA(path);
   if (lib == NULL) pusherror(L);
+  __A_VARIABLE = 1;
   return lib;
 }
 
@@ -134,6 +142,7 @@ static void *ll_load (lua_State *L, const char *path) {
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
   lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);
   if (f == NULL) pusherror(L);
+  __A_VARIABLE = 1;
   return f;
 }
 
@@ -163,21 +172,27 @@ static void pusherror (lua_State *L) {
   int err_num;
   NSLinkEditError(&err, &err_num, &err_file, &err_str);
   lua_pushstring(L, err_str);
+  __A_VARIABLE = 1;
 }
 
 
 static const char *errorfromcode (NSObjectFileImageReturnCode ret) {
   switch (ret) {
     case NSObjectFileImageInappropriateFile:
+      __A_VARIABLE = 1;
       return "file is not a bundle";
     case NSObjectFileImageArch:
+      __A_VARIABLE = 1;
       return "library is for wrong CPU type";
     case NSObjectFileImageFormat:
+      __A_VARIABLE = 1;
       return "bad format";
     case NSObjectFileImageAccess:
+      __A_VARIABLE = 1;
       return "cannot access file";
     case NSObjectFileImageFailure:
     default:
+      __A_VARIABLE = 1;
       return "unable to load library";
   }
 }
@@ -185,6 +200,7 @@ static const char *errorfromcode (NSObjectFileImageReturnCode ret) {
 
 static void ll_unloadlib (void *lib) {
   NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
+  __A_VARIABLE = 1;
 }
 
 
@@ -194,6 +210,7 @@ static void *ll_load (lua_State *L, const char *path) {
   /* this would be a rare case, but prevents crashing if it happens */
   if(!_dyld_present()) {
     lua_pushliteral(L, "dyld not present");
+    __A_VARIABLE = 1;
     return NULL;
   }
   ret = NSCreateObjectFileImageFromFile(path, &img);
@@ -202,9 +219,11 @@ static void *ll_load (lua_State *L, const char *path) {
                        NSLINKMODULE_OPTION_RETURN_ON_ERROR);
     NSDestroyObjectFileImage(img);
     if (mod == NULL) pusherror(L);
+    __A_VARIABLE = 1;
     return mod;
   }
   lua_pushstring(L, errorfromcode(ret));
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -213,8 +232,10 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
   NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);
   if (nss == NULL) {
     lua_pushfstring(L, "symbol " LUA_QS " not found", sym);
+    __A_VARIABLE = 1;
     return NULL;
   }
+  __A_VARIABLE = 1;
   return (lua_CFunction)NSAddressOfSymbol(nss);
 }
 
@@ -238,12 +259,14 @@ static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
 
 static void ll_unloadlib (void *lib) {
   (void)lib;  /* to avoid warnings */
+  __A_VARIABLE = 1;
 }
 
 
 static void *ll_load (lua_State *L, const char *path) {
   (void)path;  /* to avoid warnings */
   lua_pushliteral(L, DLMSG);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -251,6 +274,7 @@ static void *ll_load (lua_State *L, const char *path) {
 static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
   (void)lib; (void)sym;  /* to avoid warnings */
   lua_pushliteral(L, DLMSG);
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -275,6 +299,7 @@ static void **ll_register (lua_State *L, const char *path) {
     lua_pushvalue(L, -2);
     lua_settable(L, LUA_REGISTRYINDEX);
   }
+  __A_VARIABLE = 1;
   return plib;
 }
 
@@ -287,6 +312,7 @@ static int gctm (lua_State *L) {
   void **lib = (void **)luaL_checkudata(L, 1, "_LOADLIB");
   if (*lib) ll_unloadlib(*lib);
   *lib = NULL;  /* mark library as closed */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -331,8 +357,12 @@ static int ll_loadlib (lua_State *L) {
 
 static int readable (const char *filename) {
   FILE *f = fopen(filename, "r");  /* try to open file */
-  if (f == NULL) return 0;  /* open failed */
+  if (f == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* open failed */
   fclose(f);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -340,10 +370,14 @@ static int readable (const char *filename) {
 static const char *pushnexttemplate (lua_State *L, const char *path) {
   const char *l;
   while (*path == *LUA_PATHSEP) path++;  /* skip separators */
-  if (*path == '\0') return NULL;  /* no more templates */
+  if (*path == '\0') {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no more templates */
   l = strchr(path, *LUA_PATHSEP);  /* find next separator */
   if (l == NULL) l = path + strlen(path);
   lua_pushlstring(L, path, l - path);  /* template */
+  __A_VARIABLE = 1;
   return l;
 }
 
@@ -361,12 +395,15 @@ static const char *findfile (lua_State *L, const char *name,
     const char *filename;
     filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);
     lua_remove(L, -2);  /* remove path template */
-    if (readable(filename))  /* does file exist and is readable? */
-      return filename;  /* return that file name */
+    if (readable(filename))  /* does file exist and is readable? */ {
+      __A_VARIABLE = 1;
+      return filename;
+    }  /* return that file name */
     lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
     lua_remove(L, -2);  /* remove file name */
     lua_concat(L, 2);  /* add entry to possible error message */
   }
+  __A_VARIABLE = 1;
   return NULL;  /* not found */
 }
 
@@ -374,6 +411,7 @@ static const char *findfile (lua_State *L, const char *name,
 static void loaderror (lua_State *L, const char *filename) {
   luaL_error(L, "error loading module " LUA_QS " from file " LUA_QS ":\n\t%s",
                 lua_tostring(L, 1), filename, lua_tostring(L, -1));
+  __A_VARIABLE = 1;
 }
 
 
@@ -381,9 +419,13 @@ static int loader_Lua (lua_State *L) {
   const char *filename;
   const char *name = luaL_checkstring(L, 1);
   filename = findfile(L, name, "path");
-  if (filename == NULL) return 1;  /* library not found in this path */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* library not found in this path */
   if (luaL_loadfile(L, filename) != 0)
     loaderror(L, filename);
+  __A_VARIABLE = 1;
   return 1;  /* library loaded successfully */
 }
 
@@ -395,6 +437,7 @@ static const char *mkfuncname (lua_State *L, const char *modname) {
   funcname = luaL_gsub(L, modname, ".", LUA_OFSEP);
   funcname = lua_pushfstring(L, POF"%s", funcname);
   lua_remove(L, -2);  /* remove 'gsub' result */
+  __A_VARIABLE = 1;
   return funcname;
 }
 
@@ -403,10 +446,14 @@ static int loader_C (lua_State *L) {
   const char *funcname;
   const char *name = luaL_checkstring(L, 1);
   const char *filename = findfile(L, name, "cpath");
-  if (filename == NULL) return 1;  /* library not found in this path */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* library not found in this path */
   funcname = mkfuncname(L, name);
   if (ll_loadfunc(L, filename, funcname) != 0)
     loaderror(L, filename);
+  __A_VARIABLE = 1;
   return 1;  /* library loaded successfully */
 }
 
@@ -417,17 +464,25 @@ static int loader_Croot (lua_State *L) {
   const char *name = luaL_checkstring(L, 1);
   const char *p = strchr(name, '.');
   int stat;
-  if (p == NULL) return 0;  /* is root */
+  if (p == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* is root */
   lua_pushlstring(L, name, p - name);
   filename = findfile(L, lua_tostring(L, -1), "cpath");
-  if (filename == NULL) return 1;  /* root not found */
+  if (filename == NULL) {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* root not found */
   funcname = mkfuncname(L, name);
   if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {
     if (stat != ERRFUNC) loaderror(L, filename);  /* real error */
     lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
                        name, filename);
+    __A_VARIABLE = 1;
     return 1;  /* function not found */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -440,6 +495,7 @@ static int loader_preload (lua_State *L) {
   lua_getfield(L, -1, name);
   if (lua_isnil(L, -1))  /* not found? */
     lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -457,6 +513,7 @@ static int ll_require (lua_State *L) {
   if (lua_toboolean(L, -1)) {  /* is it there? */
     if (lua_touserdata(L, -1) == sentinel)  /* check loops */
       luaL_error(L, "loop or previous error loading module " LUA_QS, name);
+    __A_VARIABLE = 1;
     return 1;  /* package is already loaded */
   }
   /* else must load it; iterate over available loaders */
@@ -490,6 +547,7 @@ static int ll_require (lua_State *L) {
     lua_pushvalue(L, -1);  /* extra copy to be returned */
     lua_setfield(L, 2, name);  /* _LOADED[name] = true */
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -513,6 +571,7 @@ static void setfenv (lua_State *L) {
   lua_pushvalue(L, -2);
   lua_setfenv(L, -2);
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
 }
 
 
@@ -523,6 +582,7 @@ static void dooptions (lua_State *L, int n) {
     lua_pushvalue(L, -2);  /* module */
     lua_call(L, 1, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -538,6 +598,7 @@ static void modinit (lua_State *L, const char *modname) {
   /* set _PACKAGE as package name (full module name minus last part) */
   lua_pushlstring(L, modname, dot - modname);
   lua_setfield(L, -2, "_PACKAGE");
+  __A_VARIABLE = 1;
 }
 
 
@@ -549,8 +610,10 @@ static int ll_module (lua_State *L) {
   if (!lua_istable(L, -1)) {  /* not found? */
     lua_pop(L, 1);  /* remove previous result */
     /* try global variable (and create one if it does not exist) */
-    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)
+    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL) {
+      __A_VARIABLE = 1;
       return luaL_error(L, "name conflict for module " LUA_QS, modname);
+    }
     lua_pushvalue(L, -1);
     lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */
   }
@@ -565,6 +628,7 @@ static int ll_module (lua_State *L) {
   lua_pushvalue(L, -1);
   setfenv(L);
   dooptions(L, loaded - 1);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -578,6 +642,7 @@ static int ll_seeall (lua_State *L) {
   }
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -603,6 +668,7 @@ static void setpath (lua_State *L, const char *fieldname, const char *envname,
   }
   setprogdir(L);
   lua_setfield(L, -2, fieldname);
+  __A_VARIABLE = 1;
 }
 
 
@@ -661,6 +727,7 @@ LUALIB_API int luaopen_package (lua_State *L) {
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   luaL_register(L, NULL, ll_funcs);  /* open lib into global table */
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
   return 1;  /* return 'package' table */
 }
 
diff --git a/deps/lua/src/lobject.c b/deps/lua/src/lobject.c
index 4ff5073..a279dfb 100644
--- a/deps/lua/src/lobject.c
+++ b/deps/lua/src/lobject.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lobject.c,v 2.22.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Some generic functions over Lua objects
@@ -64,6 +65,7 @@ int luaO_log2 (unsigned int x) {
   };
   int l = -1;
   while (x >= 256) { l += 8; x >>= 8; }
+  __A_VARIABLE = 1;
   return l + log_2[x];
 
 }
@@ -90,12 +92,22 @@ int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
 int luaO_str2d (const char *s, lua_Number *result) {
   char *endptr;
   *result = lua_str2number(s, &endptr);
-  if (endptr == s) return 0;  /* conversion failed */
+  if (endptr == s) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* conversion failed */
   if (*endptr == 'x' || *endptr == 'X')  /* maybe an hexadecimal constant? */
     *result = cast_num(strtoul(s, &endptr, 16));
-  if (*endptr == '\0') return 1;  /* most common case */
+  if (*endptr == '\0') {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* most common case */
   while (isspace(cast(unsigned char, *endptr))) endptr++;
-  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  if (*endptr != '\0') {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* invalid trailing characters? */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -104,6 +116,7 @@ int luaO_str2d (const char *s, lua_Number *result) {
 static void pushstr (lua_State *L, const char *str) {
   setsvalue2s(L, L->top, luaS_new(L, str));
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -165,6 +178,7 @@ const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
   pushstr(L, fmt);
   luaV_concat(L, n+1, cast_int(L->top - L->base) - 1);
   L->top -= n;
+  __A_VARIABLE = 1;
   return svalue(L->top - 1);
 }
 
@@ -175,6 +189,7 @@ const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
   va_start(argp, fmt);
   msg = luaO_pushvfstring(L, fmt, argp);
   va_end(argp);
+  __A_VARIABLE = 1;
   return msg;
 }
 
@@ -211,4 +226,5 @@ void luaO_chunkid (char *out, const char *source, size_t bufflen) {
       strcat(out, "\"]");
     }
   }
+  __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/lopcodes.c b/deps/lua/src/lopcodes.c
index 4cc7452..b56df42 100644
--- a/deps/lua/src/lopcodes.c
+++ b/deps/lua/src/lopcodes.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lopcodes.c,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
 ** See Copyright Notice in lua.h
diff --git a/deps/lua/src/loslib.c b/deps/lua/src/loslib.c
index da06a57..2e9ad56 100644
--- a/deps/lua/src/loslib.c
+++ b/deps/lua/src/loslib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: loslib.c,v 1.19.1.3 2008/01/18 16:38:18 roberto Exp $
 ** Standard Operating System library
@@ -37,12 +38,14 @@ static int os_pushresult (lua_State *L, int i, const char *filename) {
 
 static int os_execute (lua_State *L) {
   lua_pushinteger(L, system(luaL_optstring(L, 1, NULL)));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_remove (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
+  __A_VARIABLE = 1;
   return os_pushresult(L, remove(filename) == 0, filename);
 }
 
@@ -50,6 +53,7 @@ static int os_remove (lua_State *L) {
 static int os_rename (lua_State *L) {
   const char *fromname = luaL_checkstring(L, 1);
   const char *toname = luaL_checkstring(L, 2);
+  __A_VARIABLE = 1;
   return os_pushresult(L, rename(fromname, toname) == 0, fromname);
 }
 
@@ -58,21 +62,26 @@ static int os_tmpname (lua_State *L) {
   char buff[LUA_TMPNAMBUFSIZE];
   int err;
   lua_tmpnam(buff, err);
-  if (err)
+  if (err) {
+    __A_VARIABLE = 1;
     return luaL_error(L, "unable to generate a unique filename");
+  }
   lua_pushstring(L, buff);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_getenv (lua_State *L) {
   lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_clock (lua_State *L) {
   lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -88,13 +97,17 @@ static int os_clock (lua_State *L) {
 static void setfield (lua_State *L, const char *key, int value) {
   lua_pushinteger(L, value);
   lua_setfield(L, -2, key);
+  __A_VARIABLE = 1;
 }
 
 static void setboolfield (lua_State *L, const char *key, int value) {
-  if (value < 0)  /* undefined? */
-    return;  /* does not set field */
+  if (value < 0)  /* undefined? */ {
+    __A_VARIABLE = 1;
+    return;
+  }  /* does not set field */
   lua_pushboolean(L, value);
   lua_setfield(L, -2, key);
+  __A_VARIABLE = 1;
 }
 
 static int getboolfield (lua_State *L, const char *key) {
@@ -102,6 +115,7 @@ static int getboolfield (lua_State *L, const char *key) {
   lua_getfield(L, -1, key);
   res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
   lua_pop(L, 1);
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -163,6 +177,7 @@ static int os_date (lua_State *L) {
     }
     luaL_pushresult(&b);
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -188,6 +203,7 @@ static int os_time (lua_State *L) {
     lua_pushnil(L);
   else
     lua_pushnumber(L, (lua_Number)t);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -195,6 +211,7 @@ static int os_time (lua_State *L) {
 static int os_difftime (lua_State *L) {
   lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
                              (time_t)(luaL_optnumber(L, 2, 0))));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -209,12 +226,14 @@ static int os_setlocale (lua_State *L) {
   const char *l = luaL_optstring(L, 1, NULL);
   int op = luaL_checkoption(L, 2, "all", catnames);
   lua_pushstring(L, setlocale(cat[op], l));
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int os_exit (lua_State *L) {
   exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  __A_VARIABLE = 1;
 }
 
 static const luaL_Reg syslib[] = {
@@ -238,6 +257,7 @@ static const luaL_Reg syslib[] = {
 
 LUALIB_API int luaopen_os (lua_State *L) {
   luaL_register(L, LUA_OSLIBNAME, syslib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/lparser.c b/deps/lua/src/lparser.c
index dda7488..8955134 100644
--- a/deps/lua/src/lparser.c
+++ b/deps/lua/src/lparser.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
 ** Lua Parser
@@ -59,12 +60,14 @@ static void anchor_token (LexState *ls) {
     TString *ts = ls->t.seminfo.ts;
     luaX_newstring(ls, getstr(ts), ts->tsv.len);
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void error_expected (LexState *ls, int token) {
   luaX_syntaxerror(ls,
       luaO_pushfstring(ls->L, LUA_QS " expected", luaX_token2str(ls, token)));
+  __A_VARIABLE = 1;
 }
 
 
@@ -74,6 +77,7 @@ static void errorlimit (FuncState *fs, int limit, const char *what) {
     luaO_pushfstring(fs->L, "function at line %d has more than %d %s",
                             fs->f->linedefined, limit, what);
   luaX_lexerror(fs->ls, msg, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -89,11 +93,13 @@ static int testnext (LexState *ls, int c) {
 static void check (LexState *ls, int c) {
   if (ls->t.token != c)
     error_expected(ls, c);
+  __A_VARIABLE = 1;
 }
 
 static void checknext (LexState *ls, int c) {
   check(ls, c);
   luaX_next(ls);
+  __A_VARIABLE = 1;
 }
 
 
@@ -111,6 +117,7 @@ static void check_match (LexState *ls, int what, int who, int where) {
               luaX_token2str(ls, what), luaX_token2str(ls, who), where));
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -119,6 +126,7 @@ static TString *str_checkname (LexState *ls) {
   check(ls, TK_NAME);
   ts = ls->t.seminfo.ts;
   luaX_next(ls);
+  __A_VARIABLE = 1;
   return ts;
 }
 
@@ -127,16 +135,19 @@ static void init_exp (expdesc *e, expkind k, int i) {
   e->f = e->t = NO_JUMP;
   e->k = k;
   e->u.s.info = i;
+  __A_VARIABLE = 1;
 }
 
 
 static void codestring (LexState *ls, expdesc *e, TString *s) {
   init_exp(e, VK, luaK_stringK(ls->fs, s));
+  __A_VARIABLE = 1;
 }
 
 
 static void checkname(LexState *ls, expdesc *e) {
   codestring(ls, e, str_checkname(ls));
+  __A_VARIABLE = 1;
 }
 
 
@@ -149,6 +160,7 @@ static int registerlocalvar (LexState *ls, TString *varname) {
   while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
   f->locvars[fs->nlocvars].varname = varname;
   luaC_objbarrier(ls->L, f, varname);
+  __A_VARIABLE = 1;
   return fs->nlocvars++;
 }
 
@@ -161,6 +173,7 @@ static void new_localvar (LexState *ls, TString *name, int n) {
   FuncState *fs = ls->fs;
   luaY_checklimit(fs, fs->nactvar+n+1, LUAI_MAXVARS, "local variables");
   fs->actvar[fs->nactvar+n] = cast(unsigned short, registerlocalvar(ls, name));
+  __A_VARIABLE = 1;
 }
 
 
@@ -170,6 +183,7 @@ static void adjustlocalvars (LexState *ls, int nvars) {
   for (; nvars; nvars--) {
     getlocvar(fs, fs->nactvar - nvars).startpc = fs->pc;
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -177,6 +191,7 @@ static void removevars (LexState *ls, int tolevel) {
   FuncState *fs = ls->fs;
   while (fs->nactvar > tolevel)
     getlocvar(fs, --fs->nactvar).endpc = fs->pc;
+  __A_VARIABLE = 1;
 }
 
 
@@ -187,6 +202,7 @@ static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
   for (i=0; i<f->nups; i++) {
     if (fs->upvalues[i].k == v->k && fs->upvalues[i].info == v->u.s.info) {
       lua_assert(f->upvalues[i] == name);
+      __A_VARIABLE = 1;
       return i;
     }
   }
@@ -200,6 +216,7 @@ static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
   lua_assert(v->k == VLOCAL || v->k == VUPVAL);
   fs->upvalues[f->nups].k = cast_byte(v->k);
   fs->upvalues[f->nups].info = cast_byte(v->u.s.info);
+  __A_VARIABLE = 1;
   return f->nups++;
 }
 
@@ -207,9 +224,12 @@ static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
 static int searchvar (FuncState *fs, TString *n) {
   int i;
   for (i=fs->nactvar-1; i >= 0; i--) {
-    if (n == getlocvar(fs, i).varname)
+    if (n == getlocvar(fs, i).varname) {
+      __A_VARIABLE = 1;
       return i;
+    }
   }
+  __A_VARIABLE = 1;
   return -1;  /* not found */
 }
 
@@ -218,6 +238,7 @@ static void markupval (FuncState *fs, int level) {
   BlockCnt *bl = fs->bl;
   while (bl && bl->nactvar > level) bl = bl->previous;
   if (bl) bl->upval = 1;
+  __A_VARIABLE = 1;
 }
 
 
@@ -250,6 +271,7 @@ static void singlevar (LexState *ls, expdesc *var) {
   FuncState *fs = ls->fs;
   if (singlevaraux(fs, varname, var, 1) == VGLOBAL)
     var->u.s.info = luaK_stringK(fs, varname);  /* info points to global name */
+  __A_VARIABLE = 1;
 }
 
 
@@ -270,12 +292,14 @@ static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
       luaK_nil(fs, reg, extra);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void enterlevel (LexState *ls) {
   if (++ls->L->nCcalls > LUAI_MAXCCALLS)
 	luaX_lexerror(ls, "chunk has too many syntax levels", 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -290,6 +314,7 @@ static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
   bl->previous = fs->bl;
   fs->bl = bl;
   lua_assert(fs->freereg == fs->nactvar);
+  __A_VARIABLE = 1;
 }
 
 
@@ -304,6 +329,7 @@ static void leaveblock (FuncState *fs) {
   lua_assert(bl->nactvar == fs->nactvar);
   fs->freereg = fs->nactvar;  /* free registers */
   luaK_patchtohere(fs, bl->breaklist);
+  __A_VARIABLE = 1;
 }
 
 
@@ -322,6 +348,7 @@ static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
     OpCode o = (func->upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
     luaK_codeABC(fs, o, 0, func->upvalues[i].info, 0);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -350,6 +377,7 @@ static void open_func (LexState *ls, FuncState *fs) {
   incr_top(L);
   setptvalue2s(L, L->top, f);
   incr_top(L);
+  __A_VARIABLE = 1;
 }
 
 
@@ -377,6 +405,7 @@ static void close_func (LexState *ls) {
   /* last token read was anchored in defunct function; must reanchor it */
   if (fs) anchor_token(ls);
   L->top -= 2;  /* remove table and prototype from the stack */
+  __A_VARIABLE = 1;
 }
 
 
@@ -394,6 +423,7 @@ Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
   lua_assert(funcstate.prev == NULL);
   lua_assert(funcstate.f->nups == 0);
   lua_assert(lexstate.fs == NULL);
+  __A_VARIABLE = 1;
   return funcstate.f;
 }
 
@@ -412,6 +442,7 @@ static void field (LexState *ls, expdesc *v) {
   luaX_next(ls);  /* skip the dot or colon */
   checkname(ls, &key);
   luaK_indexed(fs, v, &key);
+  __A_VARIABLE = 1;
 }
 
 
@@ -421,6 +452,7 @@ static void yindex (LexState *ls, expdesc *v) {
   expr(ls, v);
   luaK_exp2val(ls->fs, v);
   checknext(ls, ']');
+  __A_VARIABLE = 1;
 }
 
 
@@ -458,22 +490,30 @@ static void recfield (LexState *ls, struct ConsControl *cc) {
   expr(ls, &val);
   luaK_codeABC(fs, OP_SETTABLE, cc->t->u.s.info, rkkey, luaK_exp2RK(fs, &val));
   fs->freereg = reg;  /* free registers */
+  __A_VARIABLE = 1;
 }
 
 
 static void closelistfield (FuncState *fs, struct ConsControl *cc) {
-  if (cc->v.k == VVOID) return;  /* there is no list item */
+  if (cc->v.k == VVOID) {
+    __A_VARIABLE = 1;
+    return;
+  }  /* there is no list item */
   luaK_exp2nextreg(fs, &cc->v);
   cc->v.k = VVOID;
   if (cc->tostore == LFIELDS_PER_FLUSH) {
     luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);  /* flush */
     cc->tostore = 0;  /* no more items pending */
   }
+  __A_VARIABLE = 1;
 }
 
 
 static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
-  if (cc->tostore == 0) return;
+  if (cc->tostore == 0) {
+    __A_VARIABLE = 1;
+    return;
+  }
   if (hasmultret(cc->v.k)) {
     luaK_setmultret(fs, &cc->v);
     luaK_setlist(fs, cc->t->u.s.info, cc->na, LUA_MULTRET);
@@ -484,6 +524,7 @@ static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
       luaK_exp2nextreg(fs, &cc->v);
     luaK_setlist(fs, cc->t->u.s.info, cc->na, cc->tostore);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -492,6 +533,7 @@ static void listfield (LexState *ls, struct ConsControl *cc) {
   luaY_checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
   cc->na++;
   cc->tostore++;
+  __A_VARIABLE = 1;
 }
 
 
@@ -534,6 +576,7 @@ static void constructor (LexState *ls, expdesc *t) {
   lastlistfield(fs, &cc);
   SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
   SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================================== */
@@ -570,6 +613,7 @@ static void parlist (LexState *ls) {
   adjustlocalvars(ls, nparams);
   f->numparams = cast_byte(fs->nactvar - (f->is_vararg & VARARG_HASARG));
   luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+  __A_VARIABLE = 1;
 }
 
 
@@ -590,6 +634,7 @@ static void body (LexState *ls, expdesc *e, int needself, int line) {
   check_match(ls, TK_END, TK_FUNCTION, line);
   close_func(ls);
   pushclosure(ls, &new_fs, e);
+  __A_VARIABLE = 1;
 }
 
 
@@ -602,6 +647,7 @@ static int explist1 (LexState *ls, expdesc *v) {
     expr(ls, v);
     n++;
   }
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -636,6 +682,7 @@ static void funcargs (LexState *ls, expdesc *f) {
     }
     default: {
       luaX_syntaxerror(ls, "function arguments expected");
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -652,6 +699,7 @@ static void funcargs (LexState *ls, expdesc *f) {
   luaK_fixline(fs, line);
   fs->freereg = base+1;  /* call remove function and arguments and leaves
                             (unless changed) one result */
+  __A_VARIABLE = 1;
 }
 
 
@@ -673,14 +721,17 @@ static void prefixexp (LexState *ls, expdesc *v) {
       expr(ls, v);
       check_match(ls, ')', '(', line);
       luaK_dischargevars(ls->fs, v);
+      __A_VARIABLE = 1;
       return;
     }
     case TK_NAME: {
       singlevar(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
     default: {
       luaX_syntaxerror(ls, "unexpected symbol");
+      __A_VARIABLE = 1;
       return;
     }
   }
@@ -718,9 +769,11 @@ static void primaryexp (LexState *ls, expdesc *v) {
         funcargs(ls, v);
         break;
       }
-      default: return;
+      default: __A_VARIABLE = 1;
+      return;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -759,50 +812,74 @@ static void simpleexp (LexState *ls, expdesc *v) {
     }
     case '{': {  /* constructor */
       constructor(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
     case TK_FUNCTION: {
       luaX_next(ls);
       body(ls, v, 0, ls->linenumber);
+      __A_VARIABLE = 1;
       return;
     }
     default: {
       primaryexp(ls, v);
+      __A_VARIABLE = 1;
       return;
     }
   }
   luaX_next(ls);
+  __A_VARIABLE = 1;
 }
 
 
 static UnOpr getunopr (int op) {
   switch (op) {
-    case TK_NOT: return OPR_NOT;
-    case '-': return OPR_MINUS;
-    case '#': return OPR_LEN;
-    default: return OPR_NOUNOPR;
+    case TK_NOT: __A_VARIABLE = 1;
+      return OPR_NOT;
+    case '-': __A_VARIABLE = 1;
+      return OPR_MINUS;
+    case '#': __A_VARIABLE = 1;
+      return OPR_LEN;
+    default: __A_VARIABLE = 1;
+    return OPR_NOUNOPR;
   }
 }
 
 
 static BinOpr getbinopr (int op) {
   switch (op) {
-    case '+': return OPR_ADD;
-    case '-': return OPR_SUB;
-    case '*': return OPR_MUL;
-    case '/': return OPR_DIV;
-    case '%': return OPR_MOD;
-    case '^': return OPR_POW;
-    case TK_CONCAT: return OPR_CONCAT;
-    case TK_NE: return OPR_NE;
-    case TK_EQ: return OPR_EQ;
-    case '<': return OPR_LT;
-    case TK_LE: return OPR_LE;
-    case '>': return OPR_GT;
-    case TK_GE: return OPR_GE;
-    case TK_AND: return OPR_AND;
-    case TK_OR: return OPR_OR;
-    default: return OPR_NOBINOPR;
+    case '+': __A_VARIABLE = 1;
+      return OPR_ADD;
+    case '-': __A_VARIABLE = 1;
+      return OPR_SUB;
+    case '*': __A_VARIABLE = 1;
+      return OPR_MUL;
+    case '/': __A_VARIABLE = 1;
+      return OPR_DIV;
+    case '%': __A_VARIABLE = 1;
+      return OPR_MOD;
+    case '^': __A_VARIABLE = 1;
+      return OPR_POW;
+    case TK_CONCAT: __A_VARIABLE = 1;
+      return OPR_CONCAT;
+    case TK_NE: __A_VARIABLE = 1;
+      return OPR_NE;
+    case TK_EQ: __A_VARIABLE = 1;
+      return OPR_EQ;
+    case '<': __A_VARIABLE = 1;
+      return OPR_LT;
+    case TK_LE: __A_VARIABLE = 1;
+      return OPR_LE;
+    case '>': __A_VARIABLE = 1;
+      return OPR_GT;
+    case TK_GE: __A_VARIABLE = 1;
+      return OPR_GE;
+    case TK_AND: __A_VARIABLE = 1;
+      return OPR_AND;
+    case TK_OR: __A_VARIABLE = 1;
+      return OPR_OR;
+    default: __A_VARIABLE = 1;
+    return OPR_NOBINOPR;
   }
 }
 
@@ -849,12 +926,14 @@ static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {
     op = nextop;
   }
   leavelevel(ls);
+  __A_VARIABLE = 1;
   return op;  /* return first untreated operator */
 }
 
 
 static void expr (LexState *ls, expdesc *v) {
   subexpr(ls, v, 0);
+  __A_VARIABLE = 1;
 }
 
 /* }==================================================================== */
@@ -872,8 +951,10 @@ static int block_follow (int token) {
   switch (token) {
     case TK_ELSE: case TK_ELSEIF: case TK_END:
     case TK_UNTIL: case TK_EOS:
+      __A_VARIABLE = 1;
       return 1;
-    default: return 0;
+    default: __A_VARIABLE = 1;
+      return 0;
   }
 }
 
@@ -886,6 +967,7 @@ static void block (LexState *ls) {
   chunk(ls);
   lua_assert(bl.breaklist == NO_JUMP);
   leaveblock(fs);
+  __A_VARIABLE = 1;
 }
 
 
@@ -925,6 +1007,7 @@ static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
     luaK_codeABC(fs, OP_MOVE, fs->freereg, v->u.s.info, 0);  /* make copy */
     luaK_reserveregs(fs, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -968,6 +1051,7 @@ static int cond (LexState *ls) {
   expr(ls, &v);  /* read condition */
   if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
   luaK_goiftrue(ls->fs, &v);
+  __A_VARIABLE = 1;
   return v.f;
 }
 
@@ -985,6 +1069,7 @@ static void breakstat (LexState *ls) {
   if (upval)
     luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
   luaK_concat(fs, &bl->breaklist, luaK_jump(fs));
+  __A_VARIABLE = 1;
 }
 
 
@@ -1004,6 +1089,7 @@ static void whilestat (LexState *ls, int line) {
   check_match(ls, TK_END, TK_WHILE, line);
   leaveblock(fs);
   luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+  __A_VARIABLE = 1;
 }
 
 
@@ -1030,6 +1116,7 @@ static void repeatstat (LexState *ls, int line) {
     luaK_patchlist(ls->fs, luaK_jump(fs), repeat_init);  /* and repeat */
   }
   leaveblock(fs);  /* finish loop */
+  __A_VARIABLE = 1;
 }
 
 
@@ -1039,6 +1126,7 @@ static int exp1 (LexState *ls) {
   expr(ls, &e);
   k = e.k;
   luaK_exp2nextreg(ls->fs, &e);
+  __A_VARIABLE = 1;
   return k;
 }
 
@@ -1061,6 +1149,7 @@ static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
                      luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
   luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
   luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1083,6 +1172,7 @@ static void fornum (LexState *ls, TString *varname, int line) {
     luaK_reserveregs(fs, 1);
   }
   forbody(ls, base, line, 1, 1);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1106,6 +1196,7 @@ static void forlist (LexState *ls, TString *indexname) {
   adjust_assign(ls, 3, explist1(ls, &e), &e);
   luaK_checkstack(fs, 3);  /* extra space to call generator */
   forbody(ls, base, line, nvars - 3, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1124,6 +1215,7 @@ static void forstat (LexState *ls, int line) {
   }
   check_match(ls, TK_END, TK_FOR, line);
   leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+  __A_VARIABLE = 1;
 }
 
 
@@ -1134,6 +1226,7 @@ static int test_then_block (LexState *ls) {
   condexit = cond(ls);
   checknext(ls, TK_THEN);
   block(ls);  /* `then' part */
+  __A_VARIABLE = 1;
   return condexit;
 }
 
@@ -1159,6 +1252,7 @@ static void ifstat (LexState *ls, int line) {
     luaK_concat(fs, &escapelist, flist);
   luaK_patchtohere(fs, escapelist);
   check_match(ls, TK_END, TK_IF, line);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1173,6 +1267,7 @@ static void localfunc (LexState *ls) {
   luaK_storevar(fs, &v, &b);
   /* debug information will only see the variable after this point! */
   getlocvar(fs, fs->nactvar - 1).startpc = fs->pc;
+  __A_VARIABLE = 1;
 }
 
 
@@ -1192,6 +1287,7 @@ static void localstat (LexState *ls) {
   }
   adjust_assign(ls, nvars, nexps, &e);
   adjustlocalvars(ls, nvars);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1205,6 +1301,7 @@ static int funcname (LexState *ls, expdesc *v) {
     needself = 1;
     field(ls, v);
   }
+  __A_VARIABLE = 1;
   return needself;
 }
 
@@ -1218,6 +1315,7 @@ static void funcstat (LexState *ls, int line) {
   body(ls, &b, needself, line);
   luaK_storevar(ls->fs, &v, &b);
   luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+  __A_VARIABLE = 1;
 }
 
 
@@ -1232,6 +1330,7 @@ static void exprstat (LexState *ls) {
     v.prev = NULL;
     assignment(ls, &v, 1);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -1265,6 +1364,7 @@ static void retstat (LexState *ls) {
     }
   }
   luaK_ret(fs, first, nret);
+  __A_VARIABLE = 1;
 }
 
 
@@ -1273,28 +1373,34 @@ static int statement (LexState *ls) {
   switch (ls->t.token) {
     case TK_IF: {  /* stat -> ifstat */
       ifstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_WHILE: {  /* stat -> whilestat */
       whilestat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_DO: {  /* stat -> DO block END */
       luaX_next(ls);  /* skip DO */
       block(ls);
       check_match(ls, TK_END, TK_DO, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_FOR: {  /* stat -> forstat */
       forstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_REPEAT: {  /* stat -> repeatstat */
       repeatstat(ls, line);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_FUNCTION: {
       funcstat(ls, line);  /* stat -> funcstat */
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_LOCAL: {  /* stat -> localstat */
@@ -1303,19 +1409,23 @@ static int statement (LexState *ls) {
         localfunc(ls);
       else
         localstat(ls);
+      __A_VARIABLE = 1;
       return 0;
     }
     case TK_RETURN: {  /* stat -> retstat */
       retstat(ls);
+      __A_VARIABLE = 1;
       return 1;  /* must be last statement */
     }
     case TK_BREAK: {  /* stat -> breakstat */
       luaX_next(ls);  /* skip BREAK */
       breakstat(ls);
+      __A_VARIABLE = 1;
       return 1;  /* must be last statement */
     }
     default: {
       exprstat(ls);
+      __A_VARIABLE = 1;
       return 0;  /* to avoid warnings */
     }
   }
@@ -1334,6 +1444,7 @@ static void chunk (LexState *ls) {
     ls->fs->freereg = ls->fs->nactvar;  /* free registers */
   }
   leavelevel(ls);
+  __A_VARIABLE = 1;
 }
 
 /* }====================================================================== */
diff --git a/deps/lua/src/lstate.c b/deps/lua/src/lstate.c
index 4313b83..2f6445d 100644
--- a/deps/lua/src/lstate.c
+++ b/deps/lua/src/lstate.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lstate.c,v 2.36.1.2 2008/01/03 15:20:39 roberto Exp $
 ** Global State
@@ -55,12 +56,14 @@ static void stack_init (lua_State *L1, lua_State *L) {
   setnilvalue(L1->top++);  /* `function' entry for this `ci' */
   L1->base = L1->ci->base = L1->top;
   L1->ci->top = L1->top + LUA_MINSTACK;
+  __A_VARIABLE = 1;
 }
 
 
 static void freestack (lua_State *L, lua_State *L1) {
   luaM_freearray(L, L1->base_ci, L1->size_ci, CallInfo);
   luaM_freearray(L, L1->stack, L1->stacksize, TValue);
+  __A_VARIABLE = 1;
 }
 
 
@@ -78,6 +81,7 @@ static void f_luaopen (lua_State *L, void *ud) {
   luaX_init(L);
   luaS_fix(luaS_newliteral(L, MEMERRMSG));
   g->GCthreshold = 4*g->totalbytes;
+  __A_VARIABLE = 1;
 }
 
 
@@ -99,6 +103,7 @@ static void preinit_state (lua_State *L, global_State *g) {
   L->savedpc = NULL;
   L->errfunc = 0;
   setnilvalue(gt(L));
+  __A_VARIABLE = 1;
 }
 
 
@@ -113,6 +118,7 @@ static void close_state (lua_State *L) {
   freestack(L, L);
   lua_assert(g->totalbytes == sizeof(LG));
   (*g->frealloc)(g->ud, fromstate(L), state_size(LG), 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -127,6 +133,7 @@ lua_State *luaE_newthread (lua_State *L) {
   L1->hook = L->hook;
   resethookcount(L1);
   lua_assert(iswhite(obj2gco(L1)));
+  __A_VARIABLE = 1;
   return L1;
 }
 
@@ -137,6 +144,7 @@ void luaE_freethread (lua_State *L, lua_State *L1) {
   luai_userstatefree(L1);
   freestack(L, L1);
   luaM_freemem(L, fromstate(L1), state_size(lua_State));
+  __A_VARIABLE = 1;
 }
 
 
@@ -145,7 +153,10 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   lua_State *L;
   global_State *g;
   void *l = (*f)(ud, NULL, 0, state_size(LG));
-  if (l == NULL) return NULL;
+  if (l == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }
   L = tostate(l);
   g = &((LG *)L)->g;
   L->next = NULL;
@@ -186,6 +197,7 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   }
   else
     luai_userstateopen(L);
+  __A_VARIABLE = 1;
   return L;
 }
 
@@ -193,6 +205,7 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
 static void callallgcTM (lua_State *L, void *ud) {
   UNUSED(ud);
   luaC_callGCTM(L);  /* call GC metamethods for all udata */
+  __A_VARIABLE = 1;
 }
 
 
@@ -210,5 +223,6 @@ LUA_API void lua_close (lua_State *L) {
   lua_assert(G(L)->tmudata == NULL);
   luai_userstateclose(L);
   close_state(L);
+  __A_VARIABLE = 1;
 }
 
diff --git a/deps/lua/src/lstring.c b/deps/lua/src/lstring.c
index 4911315..f2da5c6 100644
--- a/deps/lua/src/lstring.c
+++ b/deps/lua/src/lstring.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** String table (keeps all strings handled by Lua)
@@ -23,8 +24,10 @@ void luaS_resize (lua_State *L, int newsize) {
   GCObject **newhash;
   stringtable *tb;
   int i;
-  if (G(L)->gcstate == GCSsweepstring)
-    return;  /* cannot resize during GC traverse */
+  if (G(L)->gcstate == GCSsweepstring) {
+    __A_VARIABLE = 1;
+    return;
+  }  /* cannot resize during GC traverse */
   newhash = luaM_newvector(L, newsize, GCObject *);
   tb = &G(L)->strt;
   for (i=0; i<newsize; i++) newhash[i] = NULL;
@@ -44,6 +47,7 @@ void luaS_resize (lua_State *L, int newsize) {
   luaM_freearray(L, tb->hash, tb->size, TString *);
   tb->size = newsize;
   tb->hash = newhash;
+  __A_VARIABLE = 1;
 }
 
 
@@ -68,6 +72,7 @@ static TString *newlstr (lua_State *L, const char *str, size_t l,
   tb->nuse++;
   if (tb->nuse > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
     luaS_resize(L, tb->size*2);  /* too crowded */
+  __A_VARIABLE = 1;
   return ts;
 }
 
@@ -86,9 +91,11 @@ TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
     if (ts->tsv.len == l && (memcmp(str, getstr(ts), l) == 0)) {
       /* string may be dead */
       if (isdead(G(L), o)) changewhite(o);
+      __A_VARIABLE = 1;
       return ts;
     }
   }
+  __A_VARIABLE = 1;
   return newlstr(L, str, l, h);  /* not found */
 }
 
@@ -106,6 +113,7 @@ Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
   /* chain it on udata list (after main thread) */
   u->uv.next = G(L)->mainthread->next;
   G(L)->mainthread->next = obj2gco(u);
+  __A_VARIABLE = 1;
   return u;
 }
 
diff --git a/deps/lua/src/lstrlib.c b/deps/lua/src/lstrlib.c
index 7a03489..b837aac 100644
--- a/deps/lua/src/lstrlib.c
+++ b/deps/lua/src/lstrlib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lstrlib.c,v 1.132.1.5 2010/05/14 15:34:19 roberto Exp $
 ** Standard library for string operations and pattern-matching
@@ -29,6 +30,7 @@ static int str_len (lua_State *L) {
   size_t l;
   luaL_checklstring(L, 1, &l);
   lua_pushinteger(L, l);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -36,6 +38,7 @@ static int str_len (lua_State *L) {
 static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
   /* relative string position: negative means back from end */
   if (pos < 0) pos += (ptrdiff_t)len + 1;
+  __A_VARIABLE = 1;
   return (pos >= 0) ? pos : 0;
 }
 
@@ -50,6 +53,7 @@ static int str_sub (lua_State *L) {
   if (start <= end)
     lua_pushlstring(L, s+start-1, end-start+1);
   else lua_pushliteral(L, "");
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -61,6 +65,7 @@ static int str_reverse (lua_State *L) {
   luaL_buffinit(L, &b);
   while (l--) luaL_addchar(&b, s[l]);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -74,6 +79,7 @@ static int str_lower (lua_State *L) {
   for (i=0; i<l; i++)
     luaL_addchar(&b, tolower(uchar(s[i])));
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -87,6 +93,7 @@ static int str_upper (lua_State *L) {
   for (i=0; i<l; i++)
     luaL_addchar(&b, toupper(uchar(s[i])));
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -99,6 +106,7 @@ static int str_rep (lua_State *L) {
   while (n-- > 0)
     luaL_addlstring(&b, s, l);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -111,13 +119,17 @@ static int str_byte (lua_State *L) {
   int n, i;
   if (posi <= 0) posi = 1;
   if ((size_t)pose > l) pose = l;
-  if (posi > pose) return 0;  /* empty interval; return no values */
+  if (posi > pose) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* empty interval; return no values */
   n = (int)(pose -  posi + 1);
   if (posi + n <= pose)  /* overflow? */
     luaL_error(L, "string slice too long");
   luaL_checkstack(L, n, "string slice too long");
   for (i=0; i<n; i++)
     lua_pushinteger(L, uchar(s[posi+i-1]));
+  __A_VARIABLE = 1;
   return n;
 }
 
@@ -133,6 +145,7 @@ static int str_char (lua_State *L) {
     luaL_addchar(&b, uchar(c));
   }
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -140,6 +153,7 @@ static int str_char (lua_State *L) {
 static int writer (lua_State *L, const void* b, size_t size, void* B) {
   (void)L;
   luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -152,6 +166,7 @@ static int str_dump (lua_State *L) {
   if (lua_dump(L, writer, &b) != 0)
     luaL_error(L, "unable to dump given function");
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -185,8 +200,11 @@ typedef struct MatchState {
 
 static int check_capture (MatchState *ms, int l) {
   l -= '1';
-  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED) {
+    __A_VARIABLE = 1;
     return luaL_error(ms->L, "invalid capture index");
+  }
+  __A_VARIABLE = 1;
   return l;
 }
 
@@ -194,7 +212,11 @@ static int check_capture (MatchState *ms, int l) {
 static int capture_to_close (MatchState *ms) {
   int level = ms->level;
   for (level--; level>=0; level--)
-    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+    if (ms->capture[level].len == CAP_UNFINISHED) {
+      __A_VARIABLE = 1;
+      return level;
+    }
+  __A_VARIABLE = 1;
   return luaL_error(ms->L, "invalid pattern capture");
 }
 
@@ -204,6 +226,7 @@ static const char *classend (MatchState *ms, const char *p) {
     case L_ESC: {
       if (*p == '\0')
         luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      __A_VARIABLE = 1;
       return p+1;
     }
     case '[': {
@@ -214,9 +237,11 @@ static const char *classend (MatchState *ms, const char *p) {
         if (*(p++) == L_ESC && *p != '\0')
           p++;  /* skip escapes (e.g. `%]') */
       } while (*p != ']');
+      __A_VARIABLE = 1;
       return p+1;
     }
     default: {
+      __A_VARIABLE = 1;
       return p;
     }
   }
@@ -236,8 +261,10 @@ static int match_class (int c, int cl) {
     case 'w' : res = isalnum(c); break;
     case 'x' : res = isxdigit(c); break;
     case 'z' : res = (c == 0); break;
-    default: return (cl == c);
+    default: __A_VARIABLE = 1;
+    return (cl == c);
   }
+  __A_VARIABLE = 1;
   return (islower(cl) ? res : !res);
 }
 
@@ -267,10 +294,14 @@ static int matchbracketclass (int c, const char *p, const char *ec) {
 
 static int singlematch (int c, const char *p, const char *ep) {
   switch (*p) {
-    case '.': return 1;  /* matches any char */
-    case L_ESC: return match_class(c, uchar(*(p+1)));
-    case '[': return matchbracketclass(c, p, ep-1);
-    default:  return (uchar(*p) == c);
+    case '.': __A_VARIABLE = 1;
+      return 1;  /* matches any char */
+    case L_ESC: __A_VARIABLE = 1;
+      return match_class(c, uchar(*(p+1)));
+    case '[': __A_VARIABLE = 1;
+      return matchbracketclass(c, p, ep-1);
+    default:  __A_VARIABLE = 1;
+    return (uchar(*p) == c);
   }
 }
 
@@ -306,9 +337,13 @@ static const char *max_expand (MatchState *ms, const char *s,
   /* keeps trying to match with the maximum repetitions */
   while (i>=0) {
     const char *res = match(ms, (s+i), ep+1);
-    if (res) return res;
+    if (res) {
+      __A_VARIABLE = 1;
+      return res;
+    }
     i--;  /* else didn't match; reduce 1 repetition to try again */
   }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -336,6 +371,7 @@ static const char *start_capture (MatchState *ms, const char *s,
   ms->level = level+1;
   if ((res=match(ms, s, p)) == NULL)  /* match failed? */
     ms->level--;  /* undo capture */
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -347,6 +383,7 @@ static const char *end_capture (MatchState *ms, const char *s,
   ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
   if ((res = match(ms, s, p)) == NULL)  /* match failed? */
     ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  __A_VARIABLE = 1;
   return res;
 }
 
@@ -479,6 +516,7 @@ static void push_onecapture (MatchState *ms, int i, const char *s,
     else
       lua_pushlstring(ms->L, ms->capture[i].init, l);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -488,6 +526,7 @@ static int push_captures (MatchState *ms, const char *s, const char *e) {
   luaL_checkstack(ms->L, nlevels, "too many captures");
   for (i = 0; i < nlevels; i++)
     push_onecapture(ms, i, s, e);
+  __A_VARIABLE = 1;
   return nlevels;  /* number of strings pushed */
 }
 
@@ -536,11 +575,13 @@ static int str_find_aux (lua_State *L, int find) {
 
 
 static int str_find (lua_State *L) {
+  __A_VARIABLE = 1;
   return str_find_aux(L, 1);
 }
 
 
 static int str_match (lua_State *L) {
+  __A_VARIABLE = 1;
   return str_find_aux(L, 0);
 }
 
@@ -564,9 +605,11 @@ static int gmatch_aux (lua_State *L) {
       if (e == src) newstart++;  /* empty match? go at least one position */
       lua_pushinteger(L, newstart);
       lua_replace(L, lua_upvalueindex(3));
+      __A_VARIABLE = 1;
       return push_captures(&ms, src, e);
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* not found */
 }
 
@@ -577,11 +620,13 @@ static int gmatch (lua_State *L) {
   lua_settop(L, 2);
   lua_pushinteger(L, 0);
   lua_pushcclosure(L, gmatch_aux, 3);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int gfind_nodef (lua_State *L) {
+  __A_VARIABLE = 1;
   return luaL_error(L, LUA_QL("string.gfind") " was renamed to "
                        LUA_QL("string.gmatch"));
 }
@@ -606,6 +651,7 @@ static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
       }
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -616,6 +662,7 @@ static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
     case LUA_TNUMBER:
     case LUA_TSTRING: {
       add_s(ms, b, s, e);
+      __A_VARIABLE = 1;
       return;
     }
     case LUA_TFUNCTION: {
@@ -638,6 +685,7 @@ static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
   else if (!lua_isstring(L, -1))
     luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1)); 
   luaL_addvalue(b);  /* add result to accumulator */
+  __A_VARIABLE = 1;
 }
 
 
@@ -676,6 +724,7 @@ static int str_gsub (lua_State *L) {
   luaL_addlstring(&b, src, ms.src_end-src);
   luaL_pushresult(&b);
   lua_pushinteger(L, n);  /* number of substitutions */
+  __A_VARIABLE = 1;
   return 2;
 }
 
@@ -720,6 +769,7 @@ static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
     s++;
   }
   luaL_addchar(b, '"');
+  __A_VARIABLE = 1;
 }
 
 static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
@@ -740,6 +790,7 @@ static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
   strncpy(form, strfrmt, p - strfrmt + 1);
   form += p - strfrmt + 1;
   *form = '\0';
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -750,6 +801,7 @@ static void addintlen (char *form) {
   strcpy(form + l - 1, LUA_INTFRMLEN);
   form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
   form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
+  __A_VARIABLE = 1;
 }
 
 
@@ -853,6 +905,7 @@ static void createmetatable (lua_State *L) {
   lua_pushvalue(L, -2);  /* string library... */
   lua_setfield(L, -2, "__index");  /* ...is the __index metamethod */
   lua_pop(L, 1);  /* pop metatable */
+  __A_VARIABLE = 1;
 }
 
 
@@ -866,6 +919,7 @@ LUALIB_API int luaopen_string (lua_State *L) {
   lua_setfield(L, -2, "gfind");
 #endif
   createmetatable(L);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ltable.c b/deps/lua/src/ltable.c
index ec84f4f..511e03f 100644
--- a/deps/lua/src/ltable.c
+++ b/deps/lua/src/ltable.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
 ** Lua tables (hash)
@@ -84,10 +85,13 @@ static const Node dummynode_ = {
 static Node *hashnum (const Table *t, lua_Number n) {
   unsigned int a[numints];
   int i;
-  if (luai_numeq(n, 0))  /* avoid problems with -0 */
+  if (luai_numeq(n, 0))  /* avoid problems with -0 */ {
+    __A_VARIABLE = 1;
     return gnode(t, 0);
+  }
   memcpy(a, &n, sizeof(a));
   for (i = 1; i < numints; i++) a[0] += a[i];
+  __A_VARIABLE = 1;
   return hashmod(t, a[0]);
 }
 
@@ -100,14 +104,19 @@ static Node *hashnum (const Table *t, lua_Number n) {
 static Node *mainposition (const Table *t, const TValue *key) {
   switch (ttype(key)) {
     case LUA_TNUMBER:
+      __A_VARIABLE = 1;
       return hashnum(t, nvalue(key));
     case LUA_TSTRING:
+      __A_VARIABLE = 1;
       return hashstr(t, rawtsvalue(key));
     case LUA_TBOOLEAN:
+      __A_VARIABLE = 1;
       return hashboolean(t, bvalue(key));
     case LUA_TLIGHTUSERDATA:
+      __A_VARIABLE = 1;
       return hashpointer(t, pvalue(key));
     default:
+      __A_VARIABLE = 1;
       return hashpointer(t, gcvalue(key));
   }
 }
@@ -122,9 +131,12 @@ static int arrayindex (const TValue *key) {
     lua_Number n = nvalue(key);
     int k;
     lua_number2int(k, n);
-    if (luai_numeq(cast_num(k), n))
+    if (luai_numeq(cast_num(k), n)) {
+      __A_VARIABLE = 1;
       return k;
+    }
   }
+  __A_VARIABLE = 1;
   return -1;  /* `key' did not match some condition */
 }
 
@@ -165,6 +177,7 @@ int luaH_next (lua_State *L, Table *t, StkId key) {
     if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
       setnvalue(key, cast_num(i+1));
       setobj2s(L, key+1, &t->array[i]);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
@@ -172,9 +185,11 @@ int luaH_next (lua_State *L, Table *t, StkId key) {
     if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
       setobj2s(L, key, key2tval(gnode(t, i)));
       setobj2s(L, key+1, gval(gnode(t, i)));
+      __A_VARIABLE = 1;
       return 1;
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* no more elements */
 }
 
@@ -204,6 +219,7 @@ static int computesizes (int nums[], int *narray) {
   }
   *narray = n;
   lua_assert(*narray/2 <= na && na <= *narray);
+  __A_VARIABLE = 1;
   return na;
 }
 
@@ -240,6 +256,7 @@ static int numusearray (const Table *t, int *nums) {
     nums[lg] += lc;
     ause += lc;
   }
+  __A_VARIABLE = 1;
   return ause;
 }
 
@@ -256,6 +273,7 @@ static int numusehash (const Table *t, int *nums, int *pnasize) {
     }
   }
   *pnasize += ause;
+  __A_VARIABLE = 1;
   return totaluse;
 }
 
@@ -266,6 +284,7 @@ static void setarrayvector (lua_State *L, Table *t, int size) {
   for (i=t->sizearray; i<size; i++)
      setnilvalue(&t->array[i]);
   t->sizearray = size;
+  __A_VARIABLE = 1;
 }
 
 
@@ -291,6 +310,7 @@ static void setnodevector (lua_State *L, Table *t, int size) {
   }
   t->lsizenode = cast_byte(lsize);
   t->lastfree = gnode(t, size);  /* all positions are free */
+  __A_VARIABLE = 1;
 }
 
 
@@ -321,12 +341,14 @@ static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
   }
   if (nold != dummynode)
     luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+  __A_VARIABLE = 1;
 }
 
 
 void luaH_resizearray (lua_State *L, Table *t, int nasize) {
   int nsize = (t->node == dummynode) ? 0 : sizenode(t);
   resize(L, t, nasize, nsize);
+  __A_VARIABLE = 1;
 }
 
 
@@ -346,6 +368,7 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
   na = computesizes(nums, &nasize);
   /* resize the table to new computed sizes */
   resize(L, t, nasize, totaluse - na);
+  __A_VARIABLE = 1;
 }
 
 
@@ -367,6 +390,7 @@ Table *luaH_new (lua_State *L, int narray, int nhash) {
   t->node = cast(Node *, dummynode);
   setarrayvector(L, t, narray);
   setnodevector(L, t, nhash);
+  __A_VARIABLE = 1;
   return t;
 }
 
@@ -376,14 +400,18 @@ void luaH_free (lua_State *L, Table *t) {
     luaM_freearray(L, t->node, sizenode(t), Node);
   luaM_freearray(L, t->array, t->sizearray, TValue);
   luaM_free(L, t);
+  __A_VARIABLE = 1;
 }
 
 
 static Node *getfreepos (Table *t) {
   while (t->lastfree-- > t->node) {
-    if (ttisnil(gkey(t->lastfree)))
+    if (ttisnil(gkey(t->lastfree))) {
+      __A_VARIABLE = 1;
       return t->lastfree;
+    }
   }
+  __A_VARIABLE = 1;
   return NULL;  /* could not find a free place */
 }
 
@@ -403,6 +431,7 @@ static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
     Node *n = getfreepos(t);  /* get a free place */
     if (n == NULL) {  /* cannot find a free place? */
       rehash(L, t, key);  /* grow table */
+      __A_VARIABLE = 1;
       return luaH_set(L, t, key);  /* re-insert key into grown table */
     }
     lua_assert(n != dummynode);
@@ -425,6 +454,7 @@ static TValue *newkey (lua_State *L, Table *t, const TValue *key) {
   gkey(mp)->value = key->value; gkey(mp)->tt = key->tt;
   luaC_barriert(L, t, key);
   lua_assert(ttisnil(gval(mp)));
+  __A_VARIABLE = 1;
   return gval(mp);
 }
 
@@ -540,6 +570,7 @@ static int unbound_search (Table *t, unsigned int j) {
       /* table was built with bad purposes: resort to linear search */
       i = 1;
       while (!ttisnil(luaH_getnum(t, i))) i++;
+      __A_VARIABLE = 1;
       return i - 1;
     }
   }
@@ -549,6 +580,7 @@ static int unbound_search (Table *t, unsigned int j) {
     if (ttisnil(luaH_getnum(t, m))) j = m;
     else i = m;
   }
+  __A_VARIABLE = 1;
   return i;
 }
 
@@ -580,9 +612,11 @@ int luaH_getn (Table *t) {
 #if defined(LUA_DEBUG)
 
 Node *luaH_mainposition (const Table *t, const TValue *key) {
+  __A_VARIABLE = 1;
   return mainposition(t, key);
 }
 
-int luaH_isdummy (Node *n) { return n == dummynode; }
+int luaH_isdummy (Node *n) { __A_VARIABLE = 1;
+	return n == dummynode; }
 
 #endif
diff --git a/deps/lua/src/ltablib.c b/deps/lua/src/ltablib.c
index b6d9cb4..285c86b 100644
--- a/deps/lua/src/ltablib.c
+++ b/deps/lua/src/ltablib.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
 ** Library for Table Manipulation
@@ -28,10 +29,13 @@ static int foreachi (lua_State *L) {
     lua_pushinteger(L, i);  /* 1st argument */
     lua_rawgeti(L, 1, i);  /* 2nd argument */
     lua_call(L, 2, 1);
-    if (!lua_isnil(L, -1))
+    if (!lua_isnil(L, -1)) {
+      __A_VARIABLE = 1;
       return 1;
+    }
     lua_pop(L, 1);  /* remove nil result */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -45,10 +49,13 @@ static int foreach (lua_State *L) {
     lua_pushvalue(L, -3);  /* key */
     lua_pushvalue(L, -3);  /* value */
     lua_call(L, 2, 1);
-    if (!lua_isnil(L, -1))
+    if (!lua_isnil(L, -1)) {
+      __A_VARIABLE = 1;
       return 1;
+    }
     lua_pop(L, 2);  /* remove value and result */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -65,12 +72,14 @@ static int maxn (lua_State *L) {
     }
   }
   lua_pushnumber(L, max);
+  __A_VARIABLE = 1;
   return 1;
 }
 
 
 static int getn (lua_State *L) {
   lua_pushinteger(L, aux_getn(L, 1));
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -83,6 +92,7 @@ static int setn (lua_State *L) {
   luaL_error(L, LUA_QL("setn") " is obsolete");
 #endif
   lua_pushvalue(L, 1);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -106,11 +116,13 @@ static int tinsert (lua_State *L) {
       break;
     }
     default: {
+      __A_VARIABLE = 1;
       return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
     }
   }
   luaL_setn(L, 1, e);  /* new size */
   lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -118,8 +130,10 @@ static int tinsert (lua_State *L) {
 static int tremove (lua_State *L) {
   int e = aux_getn(L, 1);
   int pos = luaL_optint(L, 2, e);
-  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */
-   return 0;  /* nothing to remove */
+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */ {
+   __A_VARIABLE = 1;
+   return 0;
+  }  /* nothing to remove */
   luaL_setn(L, 1, e - 1);  /* t.n = n-1 */
   lua_rawgeti(L, 1, pos);  /* result = t[pos] */
   for ( ;pos<e; pos++) {
@@ -128,6 +142,7 @@ static int tremove (lua_State *L) {
   }
   lua_pushnil(L);
   lua_rawseti(L, 1, e);  /* t[e] = nil */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -138,6 +153,7 @@ static void addfield (lua_State *L, luaL_Buffer *b, int i) {
     luaL_error(L, "invalid value (%s) at index %d in table for "
                   LUA_QL("concat"), luaL_typename(L, -1), i);
     luaL_addvalue(b);
+    __A_VARIABLE = 1;
 }
 
 
@@ -157,6 +173,7 @@ static int tconcat (lua_State *L) {
   if (i == last)  /* add last value (if interval was not empty) */
     addfield(L, &b, i);
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -173,6 +190,7 @@ static int tconcat (lua_State *L) {
 static void set2 (lua_State *L, int i, int j) {
   lua_rawseti(L, 1, i);
   lua_rawseti(L, 1, j);
+  __A_VARIABLE = 1;
 }
 
 static int sort_comp (lua_State *L, int a, int b) {
@@ -251,6 +269,7 @@ static void auxsort (lua_State *L, int l, int u) {
     }
     auxsort(L, j, i);  /* call recursively the smaller one */
   }  /* repeat the routine for the larger one */
+  __A_VARIABLE = 1;
 }
 
 static int sort (lua_State *L) {
@@ -260,6 +279,7 @@ static int sort (lua_State *L) {
     luaL_checktype(L, 2, LUA_TFUNCTION);
   lua_settop(L, 2);  /* make sure there is two arguments */
   auxsort(L, 1, n);
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -282,6 +302,7 @@ static const luaL_Reg tab_funcs[] = {
 
 LUALIB_API int luaopen_table (lua_State *L) {
   luaL_register(L, LUA_TABLIBNAME, tab_funcs);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/ltm.c b/deps/lua/src/ltm.c
index c27f0f6..2dcc41f 100644
--- a/deps/lua/src/ltm.c
+++ b/deps/lua/src/ltm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: ltm.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
 ** Tag methods
@@ -40,6 +41,7 @@ void luaT_init (lua_State *L) {
     G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
     luaS_fix(G(L)->tmname[i]);  /* never collect these names */
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -70,6 +72,7 @@ const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
     default:
       mt = G(L)->mt[ttype(o)];
   }
+  __A_VARIABLE = 1;
   return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
 }
 
diff --git a/deps/lua/src/lua.c b/deps/lua/src/lua.c
index 3a46609..72f4ed7 100644
--- a/deps/lua/src/lua.c
+++ b/deps/lua/src/lua.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lua.c,v 1.160.1.2 2007/12/28 15:32:23 roberto Exp $
 ** Lua stand-alone interpreter
@@ -29,6 +30,7 @@ static void lstop (lua_State *L, lua_Debug *ar) {
   (void)ar;  /* unused arg. */
   lua_sethook(L, NULL, 0, 0);
   luaL_error(L, "interrupted!");
+  __A_VARIABLE = 1;
 }
 
 
@@ -36,6 +38,7 @@ static void laction (int i) {
   signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                               terminate process (default action) */
   lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+  __A_VARIABLE = 1;
 }
 
 
@@ -52,6 +55,7 @@ static void print_usage (void) {
   ,
   progname);
   fflush(stderr);
+  __A_VARIABLE = 1;
 }
 
 
@@ -59,6 +63,7 @@ static void l_message (const char *pname, const char *msg) {
   if (pname) fprintf(stderr, "%s: ", pname);
   fprintf(stderr, "%s\n", msg);
   fflush(stderr);
+  __A_VARIABLE = 1;
 }
 
 
@@ -69,26 +74,32 @@ static int report (lua_State *L, int status) {
     l_message(progname, msg);
     lua_pop(L, 1);
   }
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static int traceback (lua_State *L) {
-  if (!lua_isstring(L, 1))  /* 'message' not a string? */
-    return 1;  /* keep it intact */
+  if (!lua_isstring(L, 1))  /* 'message' not a string? */ {
+    __A_VARIABLE = 1;
+    return 1;
+  }  /* keep it intact */
   lua_getfield(L, LUA_GLOBALSINDEX, "debug");
   if (!lua_istable(L, -1)) {
     lua_pop(L, 1);
+    __A_VARIABLE = 1;
     return 1;
   }
   lua_getfield(L, -1, "traceback");
   if (!lua_isfunction(L, -1)) {
     lua_pop(L, 2);
+    __A_VARIABLE = 1;
     return 1;
   }
   lua_pushvalue(L, 1);  /* pass error message */
   lua_pushinteger(L, 2);  /* skip this function and traceback */
   lua_call(L, 2, 1);  /* call debug.traceback */
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -104,12 +115,14 @@ static int docall (lua_State *L, int narg, int clear) {
   lua_remove(L, base);  /* remove traceback function */
   /* force a complete garbage collection in case of errors */
   if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
+  __A_VARIABLE = 1;
   return status;
 }
 
 
 static void print_version (void) {
   l_message(NULL, LUA_RELEASE "  " LUA_COPYRIGHT);
+  __A_VARIABLE = 1;
 }
 
 
@@ -127,18 +140,21 @@ static int getargs (lua_State *L, char **argv, int n) {
     lua_pushstring(L, argv[i]);
     lua_rawseti(L, -2, i - n);
   }
+  __A_VARIABLE = 1;
   return narg;
 }
 
 
 static int dofile (lua_State *L, const char *name) {
   int status = luaL_loadfile(L, name) || docall(L, 0, 1);
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
 
 static int dostring (lua_State *L, const char *s, const char *name) {
   int status = luaL_loadbuffer(L, s, strlen(s), name) || docall(L, 0, 1);
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
@@ -146,6 +162,7 @@ static int dostring (lua_State *L, const char *s, const char *name) {
 static int dolibrary (lua_State *L, const char *name) {
   lua_getglobal(L, "require");
   lua_pushstring(L, name);
+  __A_VARIABLE = 1;
   return report(L, docall(L, 1, 1));
 }
 
@@ -156,6 +173,7 @@ static const char *get_prompt (lua_State *L, int firstline) {
   p = lua_tostring(L, -1);
   if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
   lua_pop(L, 1);  /* remove global */
+  __A_VARIABLE = 1;
   return p;
 }
 
@@ -167,9 +185,11 @@ static int incomplete (lua_State *L, int status) {
     const char *tp = msg + lmsg - (sizeof(LUA_QL("<eof>")) - 1);
     if (strstr(msg, LUA_QL("<eof>")) == tp) {
       lua_pop(L, 1);
+      __A_VARIABLE = 1;
       return 1;
     }
   }
+  __A_VARIABLE = 1;
   return 0;  /* else... */
 }
 
@@ -179,8 +199,10 @@ static int pushline (lua_State *L, int firstline) {
   char *b = buffer;
   size_t l;
   const char *prmt = get_prompt(L, firstline);
-  if (lua_readline(L, b, prmt) == 0)
-    return 0;  /* no input */
+  if (lua_readline(L, b, prmt) == 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* no input */
   l = strlen(b);
   if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
     b[l-1] = '\0';  /* remove it */
@@ -189,6 +211,7 @@ static int pushline (lua_State *L, int firstline) {
   else
     lua_pushstring(L, b);
   lua_freeline(L, b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -196,19 +219,24 @@ static int pushline (lua_State *L, int firstline) {
 static int loadline (lua_State *L) {
   int status;
   lua_settop(L, 0);
-  if (!pushline(L, 1))
-    return -1;  /* no input */
+  if (!pushline(L, 1)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* no input */
   for (;;) {  /* repeat until gets a complete line */
     status = luaL_loadbuffer(L, lua_tostring(L, 1), lua_strlen(L, 1), "=stdin");
     if (!incomplete(L, status)) break;  /* cannot try to add lines? */
-    if (!pushline(L, 0))  /* no more input? */
+    if (!pushline(L, 0))  /* no more input? */ {
+      __A_VARIABLE = 1;
       return -1;
+    }
     lua_pushliteral(L, "\n");  /* add a new line... */
     lua_insert(L, -2);  /* ...between the two lines */
     lua_concat(L, 3);  /* join them */
   }
   lua_saveline(L, 1);
   lua_remove(L, 1);  /* remove line */
+  __A_VARIABLE = 1;
   return status;
 }
 
@@ -233,6 +261,7 @@ static void dotty (lua_State *L) {
   fputs("\n", stdout);
   fflush(stdout);
   progname = oldprogname;
+  __A_VARIABLE = 1;
 }
 
 
@@ -250,6 +279,7 @@ static int handle_script (lua_State *L, char **argv, int n) {
     status = docall(L, narg, 0);
   else
     lua_pop(L, narg);      
+  __A_VARIABLE = 1;
   return report(L, status);
 }
 
@@ -261,13 +291,17 @@ static int handle_script (lua_State *L, char **argv, int n) {
 static int collectargs (char **argv, int *pi, int *pv, int *pe) {
   int i;
   for (i = 1; argv[i] != NULL; i++) {
-    if (argv[i][0] != '-')  /* not an option? */
+    if (argv[i][0] != '-')  /* not an option? */ {
+        __A_VARIABLE = 1;
         return i;
+    }
     switch (argv[i][1]) {  /* option */
       case '-':
         notail(argv[i]);
+        __A_VARIABLE = 1;
         return (argv[i+1] != NULL ? i+1 : 0);
       case '\0':
+        __A_VARIABLE = 1;
         return i;
       case 'i':
         notail(argv[i]);
@@ -281,12 +315,17 @@ static int collectargs (char **argv, int *pi, int *pv, int *pe) {
       case 'l':
         if (argv[i][2] == '\0') {
           i++;
-          if (argv[i] == NULL) return -1;
+          if (argv[i] == NULL) {
+            __A_VARIABLE = 1;
+            return -1;
+          }
         }
         break;
-      default: return -1;  /* invalid option */
+      default: __A_VARIABLE = 1;
+        return -1;  /* invalid option */
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -301,21 +340,26 @@ static int runargs (lua_State *L, char **argv, int n) {
         const char *chunk = argv[i] + 2;
         if (*chunk == '\0') chunk = argv[++i];
         lua_assert(chunk != NULL);
-        if (dostring(L, chunk, "=(command line)") != 0)
+        if (dostring(L, chunk, "=(command line)") != 0) {
+          __A_VARIABLE = 1;
           return 1;
+        }
         break;
       }
       case 'l': {
         const char *filename = argv[i] + 2;
         if (*filename == '\0') filename = argv[++i];
         lua_assert(filename != NULL);
-        if (dolibrary(L, filename))
-          return 1;  /* stop if file fails */
+        if (dolibrary(L, filename)) {
+          __A_VARIABLE = 1;
+          return 1;
+        }  /* stop if file fails */
         break;
       }
       default: break;
     }
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -348,19 +392,29 @@ static int pmain (lua_State *L) {
   luaL_openlibs(L);  /* open libraries */
   lua_gc(L, LUA_GCRESTART, 0);
   s->status = handle_luainit(L);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   script = collectargs(argv, &has_i, &has_v, &has_e);
   if (script < 0) {  /* invalid args? */
     print_usage();
     s->status = 1;
+    __A_VARIABLE = 1;
     return 0;
   }
   if (has_v) print_version();
   s->status = runargs(L, argv, (script > 0) ? script : s->argc);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (script)
     s->status = handle_script(L, argv, script);
-  if (s->status != 0) return 0;
+  if (s->status != 0) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (has_i)
     dotty(L);
   else if (script == 0 && !has_e && !has_v) {
@@ -370,6 +424,7 @@ static int pmain (lua_State *L) {
     }
     else dofile(L, NULL);  /* executes stdin as a file */
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -380,6 +435,7 @@ int main (int argc, char **argv) {
   lua_State *L = lua_open();  /* create state */
   if (L == NULL) {
     l_message(argv[0], "cannot create state: not enough memory");
+    __A_VARIABLE = 1;
     return EXIT_FAILURE;
   }
   s.argc = argc;
@@ -387,6 +443,7 @@ int main (int argc, char **argv) {
   status = lua_cpcall(L, &pmain, &s);
   report(L, status);
   lua_close(L);
+  __A_VARIABLE = 1;
   return (status || s.status) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
 
diff --git a/deps/lua/src/lua_bit.c b/deps/lua/src/lua_bit.c
index 690df7d..bab9c87 100644
--- a/deps/lua/src/lua_bit.c
+++ b/deps/lua/src/lua_bit.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** Lua BitOp -- a bit operations library for Lua 5.1/5.2.
 ** http://bitop.luajit.org/
diff --git a/deps/lua/src/lua_cjson.c b/deps/lua/src/lua_cjson.c
index c26c0d7..ecfa5d3 100644
--- a/deps/lua/src/lua_cjson.c
+++ b/deps/lua/src/lua_cjson.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Lua CJSON - JSON support for Lua
  *
  * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
diff --git a/deps/lua/src/lua_cmsgpack.c b/deps/lua/src/lua_cmsgpack.c
index 8921547..6a2d7f5 100644
--- a/deps/lua/src/lua_cmsgpack.c
+++ b/deps/lua/src/lua_cmsgpack.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <math.h>
 #include <stdlib.h>
 #include <stdint.h>
diff --git a/deps/lua/src/lua_struct.c b/deps/lua/src/lua_struct.c
index 4d5f027..7cbfc50 100644
--- a/deps/lua/src/lua_struct.c
+++ b/deps/lua/src/lua_struct.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** {======================================================
 ** Library for packing/unpacking structures.
@@ -108,22 +109,32 @@ static int getnum (const char **fmt, int df) {
 
 static size_t optsize (lua_State *L, char opt, const char **fmt) {
   switch (opt) {
-    case 'B': case 'b': return sizeof(char);
-    case 'H': case 'h': return sizeof(short);
-    case 'L': case 'l': return sizeof(long);
-    case 'T': return sizeof(size_t);
-    case 'f':  return sizeof(float);
-    case 'd':  return sizeof(double);
-    case 'x': return 1;
-    case 'c': return getnum(fmt, 1);
+    case 'B': case 'b': __A_VARIABLE = 1;
+    return sizeof(char);
+    case 'H': case 'h': __A_VARIABLE = 1;
+    return sizeof(short);
+    case 'L': case 'l': __A_VARIABLE = 1;
+    return sizeof(long);
+    case 'T': __A_VARIABLE = 1;
+    return sizeof(size_t);
+    case 'f':  __A_VARIABLE = 1;
+    return sizeof(float);
+    case 'd':  __A_VARIABLE = 1;
+    return sizeof(double);
+    case 'x': __A_VARIABLE = 1;
+    return 1;
+    case 'c': __A_VARIABLE = 1;
+    return getnum(fmt, 1);
     case 'i': case 'I': {
       int sz = getnum(fmt, sizeof(int));
       if (sz > MAXINTSIZE)
         luaL_error(L, "integral size %d is larger than limit of %d",
                        sz, MAXINTSIZE);
+      __A_VARIABLE = 1;
       return sz;
     }
-    default: return 0;  /* other cases do not need alignment */
+    default: __A_VARIABLE = 1;
+    return 0;  /* other cases do not need alignment */
   }
 }
 
@@ -133,9 +144,13 @@ static size_t optsize (lua_State *L, char opt, const char **fmt) {
 ** at current position 'len'
 */
 static int gettoalign (size_t len, Header *h, int opt, size_t size) {
-  if (size == 0 || opt == 'c') return 0;
+  if (size == 0 || opt == 'c') {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   if (size > (size_t)h->align)
     size = h->align;  /* respect max. alignment */
+  __A_VARIABLE = 1;
   return (size - (len & (size - 1))) & (size - 1);
 }
 
@@ -146,14 +161,18 @@ static int gettoalign (size_t len, Header *h, int opt, size_t size) {
 static void controloptions (lua_State *L, int opt, const char **fmt,
                             Header *h) {
   switch (opt) {
-    case  ' ': return;  /* ignore white spaces */
-    case '>': h->endian = BIG; return;
-    case '<': h->endian = LITTLE; return;
+    case  ' ': __A_VARIABLE = 1;
+    return;  /* ignore white spaces */
+    case '>': h->endian = BIG; __A_VARIABLE = 1;
+    return;
+    case '<': h->endian = LITTLE; __A_VARIABLE = 1;
+    return;
     case '!': {
       int a = getnum(fmt, MAXALIGN);
       if (!isp2(a))
         luaL_error(L, "alignment %d is not a power of 2", a);
       h->align = a;
+      __A_VARIABLE = 1;
       return;
     }
     default: {
@@ -161,6 +180,7 @@ static void controloptions (lua_State *L, int opt, const char **fmt,
       luaL_argerror(L, 1, msg);
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -188,6 +208,7 @@ static void putinteger (lua_State *L, luaL_Buffer *b, int arg, int endian,
     }
   }
   luaL_addlstring(b, buff, size);
+  __A_VARIABLE = 1;
 }
 
 
@@ -200,6 +221,7 @@ static void correctbytes (char *b, int size, int endian) {
       b[size] = temp;
     }
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -257,6 +279,7 @@ static int b_pack (lua_State *L) {
     totalsize += size;
   }
   luaL_pushresult(&b);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -357,6 +380,7 @@ static int b_unpack (lua_State *L) {
     pos += size;
   }
   lua_pushinteger(L, pos + 1);  /* next position */
+  __A_VARIABLE = 1;
   return n + 1;
 }
 
@@ -379,6 +403,7 @@ static int b_size (lua_State *L) {
     pos += size;
   }
   lua_pushinteger(L, pos);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -398,6 +423,7 @@ LUALIB_API int luaopen_struct (lua_State *L);
 
 LUALIB_API int luaopen_struct (lua_State *L) {
   luaL_register(L, "struct", thislib);
+  __A_VARIABLE = 1;
   return 1;
 }
 
diff --git a/deps/lua/src/luac.c b/deps/lua/src/luac.c
index d070173..cac373b 100644
--- a/deps/lua/src/luac.c
+++ b/deps/lua/src/luac.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: luac.c,v 1.54 2006/06/02 17:37:11 lhf Exp $
 ** Lua compiler (saves bytecodes to files; also list bytecodes)
@@ -37,12 +38,14 @@ static void fatal(const char* message)
 {
  fprintf(stderr,"%s: %s\n",progname,message);
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 static void cannot(const char* what)
 {
  fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 static void usage(const char* message)
@@ -63,6 +66,7 @@ static void usage(const char* message)
  "  --       stop handling options\n",
  progname,Output);
  exit(EXIT_FAILURE);
+ __A_VARIABLE = 1;
 }
 
 #define	IS(s)	(strcmp(argv[i],s)==0)
@@ -111,6 +115,7 @@ static int doargs(int argc, char* argv[])
   printf("%s  %s\n",LUA_RELEASE,LUA_COPYRIGHT);
   if (version==argc-1) exit(EXIT_SUCCESS);
  }
+ __A_VARIABLE = 1;
  return i;
 }
 
@@ -147,6 +152,7 @@ static const Proto* combine(lua_State* L, int n)
 static int writer(lua_State* L, const void* p, size_t size, void* u)
 {
  UNUSED(L);
+ __A_VARIABLE = 1;
  return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
 }
 
@@ -180,6 +186,7 @@ static int pmain(lua_State* L)
   if (ferror(D)) cannot("write");
   if (fclose(D)) cannot("close");
  }
+ __A_VARIABLE = 1;
  return 0;
 }
 
@@ -196,5 +203,6 @@ int main(int argc, char* argv[])
  s.argv=argv;
  if (lua_cpcall(L,pmain,&s)!=0) fatal(lua_tostring(L,-1));
  lua_close(L);
+ __A_VARIABLE = 1;
  return EXIT_SUCCESS;
 }
diff --git a/deps/lua/src/lundump.c b/deps/lua/src/lundump.c
index 8010a45..a62fb15 100644
--- a/deps/lua/src/lundump.c
+++ b/deps/lua/src/lundump.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
 ** load precompiled Lua chunks
@@ -37,6 +38,7 @@ static void error(LoadState* S, const char* why)
 {
  luaO_pushfstring(S->L,"%s: %s in precompiled chunk",S->name,why);
  luaD_throw(S->L,LUA_ERRSYNTAX);
+ __A_VARIABLE = 1;
 }
 #endif
 
@@ -49,12 +51,14 @@ static void LoadBlock(LoadState* S, void* b, size_t size)
 {
  size_t r=luaZ_read(S->Z,b,size);
  IF (r!=0, "unexpected end");
+ __A_VARIABLE = 1;
 }
 
 static int LoadChar(LoadState* S)
 {
  char x;
  LoadVar(S,x);
+ __A_VARIABLE = 1;
  return x;
 }
 
@@ -63,6 +67,7 @@ static int LoadInt(LoadState* S)
  int x;
  LoadVar(S,x);
  IF (x<0, "bad integer");
+ __A_VARIABLE = 1;
  return x;
 }
 
@@ -70,6 +75,7 @@ static lua_Number LoadNumber(LoadState* S)
 {
  lua_Number x;
  LoadVar(S,x);
+ __A_VARIABLE = 1;
  return x;
 }
 
@@ -93,6 +99,7 @@ static void LoadCode(LoadState* S, Proto* f)
  f->code=luaM_newvector(S->L,n,Instruction);
  f->sizecode=n;
  LoadVector(S,f->code,n,sizeof(Instruction));
+ __A_VARIABLE = 1;
 }
 
 static Proto* LoadFunction(LoadState* S, TString* p);
@@ -132,6 +139,7 @@ static void LoadConstants(LoadState* S, Proto* f)
  f->sizep=n;
  for (i=0; i<n; i++) f->p[i]=NULL;
  for (i=0; i<n; i++) f->p[i]=LoadFunction(S,f->source);
+ __A_VARIABLE = 1;
 }
 
 static void LoadDebug(LoadState* S, Proto* f)
@@ -156,6 +164,7 @@ static void LoadDebug(LoadState* S, Proto* f)
  f->sizeupvalues=n;
  for (i=0; i<n; i++) f->upvalues[i]=NULL;
  for (i=0; i<n; i++) f->upvalues[i]=LoadString(S);
+ __A_VARIABLE = 1;
 }
 
 static Proto* LoadFunction(LoadState* S, TString* p)
@@ -177,6 +186,7 @@ static Proto* LoadFunction(LoadState* S, TString* p)
  IF (!luaG_checkcode(f), "bad code");
  S->L->top--;
  S->L->nCcalls--;
+ __A_VARIABLE = 1;
  return f;
 }
 
@@ -187,6 +197,7 @@ static void LoadHeader(LoadState* S)
  luaU_header(h);
  LoadBlock(S,s,LUAC_HEADERSIZE);
  IF (memcmp(h,s,LUAC_HEADERSIZE)!=0, "bad header");
+ __A_VARIABLE = 1;
 }
 
 /*
@@ -205,6 +216,7 @@ Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
  S.Z=Z;
  S.b=buff;
  LoadHeader(&S);
+ __A_VARIABLE = 1;
  return LoadFunction(&S,luaS_newliteral(L,"=?"));
 }
 
@@ -224,4 +236,5 @@ void luaU_header (char* h)
  *h++=(char)sizeof(Instruction);
  *h++=(char)sizeof(lua_Number);
  *h++=(char)(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/lvm.c b/deps/lua/src/lvm.c
index e0a0cd8..0179719 100644
--- a/deps/lua/src/lvm.c
+++ b/deps/lua/src/lvm.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
 ** Lua virtual machine
@@ -74,6 +75,7 @@ static void traceexec (lua_State *L, const Instruction *pc) {
     if (npc == 0 || pc <= oldpc || newline != getline(p, pcRel(oldpc, p)))
       luaD_callhook(L, LUA_HOOKLINE, newline);
   }
+  __A_VARIABLE = 1;
 }
 
 
@@ -89,6 +91,7 @@ static void callTMres (lua_State *L, StkId res, const TValue *f,
   res = restorestack(L, result);
   L->top--;
   setobjs2s(L, res, L->top);
+  __A_VARIABLE = 1;
 }
 
 
@@ -102,6 +105,7 @@ static void callTM (lua_State *L, const TValue *f, const TValue *p1,
   luaD_checkstack(L, 4);
   L->top += 4;
   luaD_call(L, L->top - 4, 0);
+  __A_VARIABLE = 1;
 }
 
 
@@ -167,8 +171,12 @@ static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
   const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
   if (ttisnil(tm))
     tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
-  if (ttisnil(tm)) return 0;
+  if (ttisnil(tm)) {
+    __A_VARIABLE = 1;
+    return 0;
+  }
   callTMres(L, res, tm, p1, p2);
+  __A_VARIABLE = 1;
   return 1;
 }
 
@@ -177,12 +185,24 @@ static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,
                                   TMS event) {
   const TValue *tm1 = fasttm(L, mt1, event);
   const TValue *tm2;
-  if (tm1 == NULL) return NULL;  /* no metamethod */
-  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  if (tm1 == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no metamethod */
+  if (mt1 == mt2) {
+    __A_VARIABLE = 1;
+    return tm1;
+  }  /* same metatables => same metamethods */
   tm2 = fasttm(L, mt2, event);
-  if (tm2 == NULL) return NULL;  /* no metamethod */
-  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+  if (tm2 == NULL) {
+    __A_VARIABLE = 1;
+    return NULL;
+  }  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */ {
+    __A_VARIABLE = 1;
     return tm1;
+  }
+  __A_VARIABLE = 1;
   return NULL;
 }
 
@@ -191,11 +211,17 @@ static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
                          TMS event) {
   const TValue *tm1 = luaT_gettmbyobj(L, p1, event);
   const TValue *tm2;
-  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  if (ttisnil(tm1)) {
+    __A_VARIABLE = 1;
+    return -1;
+  }  /* no metamethod? */
   tm2 = luaT_gettmbyobj(L, p2, event);
-  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */ {
+    __A_VARIABLE = 1;
     return -1;
+  }
   callTMres(L, L->top, tm1, p1, p2);
+  __A_VARIABLE = 1;
   return !l_isfalse(L->top);
 }
 
@@ -256,25 +282,40 @@ int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
   const TValue *tm;
   lua_assert(ttype(t1) == ttype(t2));
   switch (ttype(t1)) {
-    case LUA_TNIL: return 1;
-    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
-    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
-    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TNIL: __A_VARIABLE = 1;
+    return 1;
+    case LUA_TNUMBER: __A_VARIABLE = 1;
+    return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: __A_VARIABLE = 1;
+    return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: __A_VARIABLE = 1;
+    return pvalue(t1) == pvalue(t2);
     case LUA_TUSERDATA: {
-      if (uvalue(t1) == uvalue(t2)) return 1;
+      if (uvalue(t1) == uvalue(t2)) {
+        __A_VARIABLE = 1;
+        return 1;
+      }
       tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
                          TM_EQ);
       break;  /* will try TM */
     }
     case LUA_TTABLE: {
-      if (hvalue(t1) == hvalue(t2)) return 1;
+      if (hvalue(t1) == hvalue(t2)) {
+      __A_VARIABLE = 1;
+      return 1;
+      }
       tm = get_compTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
       break;  /* will try TM */
     }
-    default: return gcvalue(t1) == gcvalue(t2);
+    default: __A_VARIABLE = 1;
+    return gcvalue(t1) == gcvalue(t2);
   }
-  if (tm == NULL) return 0;  /* no TM? */
+  if (tm == NULL) {
+    __A_VARIABLE = 1;
+    return 0;
+  }  /* no TM? */
   callTMres(L, L->top, tm, t1, t2);  /* call TM */
+  __A_VARIABLE = 1;
   return !l_isfalse(L->top);
 }
 
@@ -311,6 +352,7 @@ void luaV_concat (lua_State *L, int total, int last) {
     total -= n-1;  /* got `n' strings to create 1 new */
     last -= n-1;
   } while (total > 1);  /* repeat until only 1 result left */
+  __A_VARIABLE = 1;
 }
 
 
@@ -334,6 +376,7 @@ static void Arith (lua_State *L, StkId ra, const TValue *rb,
   }
   else if (!call_binTM(L, rb, rc, ra, op))
     luaG_aritherror(L, rb, rc);
+  __A_VARIABLE = 1;
 }
 
 
diff --git a/deps/lua/src/lzio.c b/deps/lua/src/lzio.c
index 293edd5..2363cb4 100644
--- a/deps/lua/src/lzio.c
+++ b/deps/lua/src/lzio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: lzio.c,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
 ** a generic input stream interface
@@ -25,9 +26,13 @@ int luaZ_fill (ZIO *z) {
   lua_unlock(L);
   buff = z->reader(L, z->data, &size);
   lua_lock(L);
-  if (buff == NULL || size == 0) return EOZ;
+  if (buff == NULL || size == 0) {
+    __A_VARIABLE = 1;
+    return EOZ;
+  }
   z->n = size - 1;
   z->p = buff;
+  __A_VARIABLE = 1;
   return char2int(*(z->p++));
 }
 
@@ -51,6 +56,7 @@ void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
   z->data = data;
   z->n = 0;
   z->p = NULL;
+  __A_VARIABLE = 1;
 }
 
 
@@ -58,8 +64,10 @@ void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
 size_t luaZ_read (ZIO *z, void *b, size_t n) {
   while (n) {
     size_t m;
-    if (luaZ_lookahead(z) == EOZ)
-      return n;  /* return number of missing bytes */
+    if (luaZ_lookahead(z) == EOZ) {
+      __A_VARIABLE = 1;
+      return n;
+    }  /* return number of missing bytes */
     m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
     memcpy(b, z->p, m);
     z->n -= m;
@@ -67,6 +75,7 @@ size_t luaZ_read (ZIO *z, void *b, size_t n) {
     b = (char *)b + m;
     n -= m;
   }
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -76,6 +85,7 @@ char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
     if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
     luaZ_resizebuffer(L, buff, n);
   }
+  __A_VARIABLE = 1;
   return buff->buffer;
 }
 
diff --git a/deps/lua/src/print.c b/deps/lua/src/print.c
index e240cfc..725e7e7 100644
--- a/deps/lua/src/print.c
+++ b/deps/lua/src/print.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
 ** $Id: print.c,v 1.55a 2006/05/31 13:30:05 lhf Exp $
 ** print bytecodes
@@ -46,6 +47,7 @@ static void PrintString(const TString* ts)
   }
  }
  putchar('"');
+ __A_VARIABLE = 1;
 }
 
 static void PrintConstant(const Proto* f, int i)
@@ -69,6 +71,7 @@ static void PrintConstant(const Proto* f, int i)
 	printf("? type=%d",ttype(o));
 	break;
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintCode(const Proto* f)
@@ -153,6 +156,7 @@ static void PrintCode(const Proto* f)
   }
   printf("\n");
  }
+ __A_VARIABLE = 1;
 }
 
 #define SS(x)	(x==1)?"":"s"
@@ -176,6 +180,7 @@ static void PrintHeader(const Proto* f)
 	S(f->maxstacksize),S(f->nups));
  printf("%d local%s, %d constant%s, %d function%s\n",
 	S(f->sizelocvars),S(f->sizek),S(f->sizep));
+ __A_VARIABLE = 1;
 }
 
 static void PrintConstants(const Proto* f)
@@ -188,6 +193,7 @@ static void PrintConstants(const Proto* f)
   PrintConstant(f,i);
   printf("\n");
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintLocals(const Proto* f)
@@ -199,17 +205,22 @@ static void PrintLocals(const Proto* f)
   printf("\t%d\t%s\t%d\t%d\n",
   i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
  }
+ __A_VARIABLE = 1;
 }
 
 static void PrintUpvalues(const Proto* f)
 {
  int i,n=f->sizeupvalues;
  printf("upvalues (%d) for %p:\n",n,VOID(f));
- if (f->upvalues==NULL) return;
+ if (f->upvalues==NULL) {
+  __A_VARIABLE = 1;
+  return;
+ }
  for (i=0; i<n; i++)
  {
   printf("\t%d\t%s\n",i,getstr(f->upvalues[i]));
  }
+ __A_VARIABLE = 1;
 }
 
 void PrintFunction(const Proto* f, int full)
@@ -224,4 +235,5 @@ void PrintFunction(const Proto* f, int full)
   PrintUpvalues(f);
  }
  for (i=0; i<n; i++) PrintFunction(f->p[i],full);
+ __A_VARIABLE = 1;
 }
diff --git a/deps/lua/src/strbuf.c b/deps/lua/src/strbuf.c
index f0f7f4b..e109202 100644
--- a/deps/lua/src/strbuf.c
+++ b/deps/lua/src/strbuf.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* strbuf - String buffer routines
  *
  * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
@@ -39,6 +40,7 @@ static void die(const char *fmt, ...)
     fprintf(stderr, "\n");
 
     exit(-1);
+    __A_VARIABLE = 1;
 }
 
 void strbuf_init(strbuf_t *s, int len)
@@ -63,6 +65,7 @@ void strbuf_init(strbuf_t *s, int len)
         die("Out of memory");
 
     strbuf_ensure_null(s);
+    __A_VARIABLE = 1;
 }
 
 strbuf_t *strbuf_new(int len)
@@ -78,6 +81,7 @@ strbuf_t *strbuf_new(int len)
     /* Dynamic strbuf allocation / deallocation */
     s->dynamic = 1;
 
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -89,6 +93,7 @@ void strbuf_set_increment(strbuf_t *s, int increment)
         die("BUG: Invalid string increment");
 
     s->increment = increment;
+    __A_VARIABLE = 1;
 }
 
 static inline void debug_stats(strbuf_t *s)
@@ -97,6 +102,7 @@ static inline void debug_stats(strbuf_t *s)
         fprintf(stderr, "strbuf(%lx) reallocs: %d, length: %d, size: %d\n",
                 (long)s, s->reallocs, s->length, s->size);
     }
+    __A_VARIABLE = 1;
 }
 
 /* If strbuf_t has not been dynamically allocated, strbuf_free() can
@@ -111,6 +117,7 @@ void strbuf_free(strbuf_t *s)
     }
     if (s->dynamic)
         free(s);
+    __A_VARIABLE = 1;
 }
 
 char *strbuf_free_to_string(strbuf_t *s, int *len)
@@ -128,6 +135,7 @@ char *strbuf_free_to_string(strbuf_t *s, int *len)
     if (s->dynamic)
         free(s);
 
+    __A_VARIABLE = 1;
     return buf;
 }
 
@@ -142,8 +150,10 @@ static int calculate_new_size(strbuf_t *s, int len)
     reqsize = len + 1;
 
     /* If the user has requested to shrink the buffer, do it exactly */
-    if (s->size > reqsize)
+    if (s->size > reqsize) {
+        __A_VARIABLE = 1;
         return reqsize;
+    }
 
     newsize = s->size;
     if (s->increment < 0) {
@@ -155,6 +165,7 @@ static int calculate_new_size(strbuf_t *s, int len)
         newsize = ((newsize + s->increment - 1) / s->increment) * s->increment;
     }
 
+    __A_VARIABLE = 1;
     return newsize;
 }
 
@@ -177,6 +188,7 @@ void strbuf_resize(strbuf_t *s, int len)
     if (!s->buf)
         die("Out of memory");
     s->reallocs++;
+    __A_VARIABLE = 1;
 }
 
 void strbuf_append_string(strbuf_t *s, const char *str)
@@ -195,6 +207,7 @@ void strbuf_append_string(strbuf_t *s, const char *str)
         s->length++;
         space--;
     }
+    __A_VARIABLE = 1;
 }
 
 /* strbuf_append_fmt() should only be used when an upper bound
@@ -214,6 +227,7 @@ void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...)
         die("BUG: Unable to convert number");  /* This should never happen.. */
 
     s->length += fmt_len;
+    __A_VARIABLE = 1;
 }
 
 /* strbuf_append_fmt_retry() can be used when the there is no known
@@ -245,6 +259,7 @@ void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)
     }
 
     s->length += fmt_len;
+    __A_VARIABLE = 1;
 }
 
 /* vi:ai et sw=4 ts=4:
diff --git a/src/adlist.c b/src/adlist.c
index ec5f8bb..fa59542 100644
--- a/src/adlist.c
+++ b/src/adlist.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* adlist.c - A generic doubly linked list implementation
  *
  * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -42,13 +43,16 @@ list *listCreate(void)
 {
     struct list *list;
 
-    if ((list = zmalloc(sizeof(*list))) == NULL)
+    if ((list = zmalloc(sizeof(*list))) == NULL) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
     list->head = list->tail = NULL;
     list->len = 0;
     list->dup = NULL;
     list->free = NULL;
     list->match = NULL;
+    __A_VARIABLE = 1;
     return list;
 }
 
@@ -77,6 +81,7 @@ void listRelease(list *list)
 {
     listEmpty(list);
     zfree(list);
+    __A_VARIABLE = 1;
 }
 
 /* Add a new node to the list, to head, containing the specified 'value'
@@ -199,6 +204,7 @@ listIter *listGetIterator(list *list, int direction)
 /* Release the iterator memory */
 void listReleaseIterator(listIter *iter) {
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Create an iterator in the list private iterator structure */
@@ -236,6 +242,7 @@ listNode *listNext(listIter *iter)
         else
             iter->next = current->prev;
     }
+    __A_VARIABLE = 1;
     return current;
 }
 
@@ -359,4 +366,5 @@ void listJoin(list *l, list *o) {
     /* Setup other as an empty list. */
     o->head = o->tail = NULL;
     o->len = 0;
+    __A_VARIABLE = 1;
 }
diff --git a/src/ae.c b/src/ae.c
index cd2894a..12fc4e6 100644
--- a/src/ae.c
+++ b/src/ae.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* A simple event-driven programming library. Originally I wrote this code
  * for the Jim's event-loop (Jim is a Tcl interpreter) but later translated
  * it in form of a library for easy reuse.
@@ -58,6 +59,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -100,6 +102,7 @@ aeEventLoop *aeCreateEventLoop(int setsize) {
      * vector with it. */
     for (i = 0; i < setsize; i++)
         eventLoop->events[i].mask = AE_NONE;
+    __A_VARIABLE = 1;
     return eventLoop;
 
 err:
@@ -108,11 +111,13 @@ err:
         zfree(eventLoop->fired);
         zfree(eventLoop);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 /* Return the current set size. */
 int aeGetSetSize(aeEventLoop *eventLoop) {
+    __A_VARIABLE = 1;
     return eventLoop->setsize;
 }
 
@@ -126,9 +131,18 @@ int aeGetSetSize(aeEventLoop *eventLoop) {
 int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
     int i;
 
-    if (setsize == eventLoop->setsize) return AE_OK;
-    if (eventLoop->maxfd >= setsize) return AE_ERR;
-    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;
+    if (setsize == eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return AE_OK;
+    }
+    if (eventLoop->maxfd >= setsize) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
+    if (aeApiResize(eventLoop,setsize) == -1) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
 
     eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
     eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
@@ -138,6 +152,7 @@ int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
      * an AE_NONE mask. */
     for (i = eventLoop->maxfd+1; i < setsize; i++)
         eventLoop->events[i].mask = AE_NONE;
+    __A_VARIABLE = 1;
     return AE_OK;
 }
 
@@ -146,10 +161,12 @@ void aeDeleteEventLoop(aeEventLoop *eventLoop) {
     zfree(eventLoop->events);
     zfree(eventLoop->fired);
     zfree(eventLoop);
+    __A_VARIABLE = 1;
 }
 
 void aeStop(aeEventLoop *eventLoop) {
     eventLoop->stop = 1;
+    __A_VARIABLE = 1;
 }
 
 int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
@@ -157,26 +174,36 @@ int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
 {
     if (fd >= eventLoop->setsize) {
         errno = ERANGE;
+        __A_VARIABLE = 1;
         return AE_ERR;
     }
     aeFileEvent *fe = &eventLoop->events[fd];
 
-    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
+    if (aeApiAddEvent(eventLoop, fd, mask) == -1) {
+        __A_VARIABLE = 1;
         return AE_ERR;
+    }
     fe->mask |= mask;
     if (mask & AE_READABLE) fe->rfileProc = proc;
     if (mask & AE_WRITABLE) fe->wfileProc = proc;
     fe->clientData = clientData;
     if (fd > eventLoop->maxfd)
         eventLoop->maxfd = fd;
+    __A_VARIABLE = 1;
     return AE_OK;
 }
 
 void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
 {
-    if (fd >= eventLoop->setsize) return;
+    if (fd >= eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return;
+    }
     aeFileEvent *fe = &eventLoop->events[fd];
-    if (fe->mask == AE_NONE) return;
+    if (fe->mask == AE_NONE) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* We want to always remove AE_BARRIER if set when AE_WRITABLE
      * is removed. */
@@ -192,12 +219,17 @@ void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
             if (eventLoop->events[j].mask != AE_NONE) break;
         eventLoop->maxfd = j;
     }
+    __A_VARIABLE = 1;
 }
 
 int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {
-    if (fd >= eventLoop->setsize) return 0;
+    if (fd >= eventLoop->setsize) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     aeFileEvent *fe = &eventLoop->events[fd];
 
+    __A_VARIABLE = 1;
     return fe->mask;
 }
 
@@ -208,6 +240,7 @@ static void aeGetTime(long *seconds, long *milliseconds)
     gettimeofday(&tv, NULL);
     *seconds = tv.tv_sec;
     *milliseconds = tv.tv_usec/1000;
+    __A_VARIABLE = 1;
 }
 
 static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {
@@ -222,6 +255,7 @@ static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms)
     }
     *sec = when_sec;
     *ms = when_ms;
+    __A_VARIABLE = 1;
 }
 
 long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
@@ -232,7 +266,10 @@ long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
     aeTimeEvent *te;
 
     te = zmalloc(sizeof(*te));
-    if (te == NULL) return AE_ERR;
+    if (te == NULL) {
+        __A_VARIABLE = 1;
+        return AE_ERR;
+    }
     te->id = id;
     aeAddMillisecondsToNow(milliseconds,&te->when_sec,&te->when_ms);
     te->timeProc = proc;
@@ -243,6 +280,7 @@ long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
     if (te->next)
         te->next->prev = te;
     eventLoop->timeEventHead = te;
+    __A_VARIABLE = 1;
     return id;
 }
 
@@ -252,10 +290,12 @@ int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
     while(te) {
         if (te->id == id) {
             te->id = AE_DELETED_EVENT_ID;
+            __A_VARIABLE = 1;
             return AE_OK;
         }
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return AE_ERR; /* NO event with the specified ID found */
 }
 
@@ -282,6 +322,7 @@ static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)
             nearest = te;
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return nearest;
 }
 
@@ -357,6 +398,7 @@ static int processTimeEvents(aeEventLoop *eventLoop) {
         }
         te = te->next;
     }
+    __A_VARIABLE = 1;
     return processed;
 }
 
@@ -380,7 +422,10 @@ int aeProcessEvents(aeEventLoop *eventLoop, int flags)
     int processed = 0, numevents;
 
     /* Nothing to do? return ASAP */
-    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;
+    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Note that we want call select() even if there are no
      * file events to process as long as we want to process time
@@ -487,6 +532,7 @@ int aeProcessEvents(aeEventLoop *eventLoop, int flags)
     if (flags & AE_TIME_EVENTS)
         processed += processTimeEvents(eventLoop);
 
+    __A_VARIABLE = 1;
     return processed; /* return the number of processed file/time events */
 }
 
@@ -519,18 +565,22 @@ void aeMain(aeEventLoop *eventLoop) {
             eventLoop->beforesleep(eventLoop);
         aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
     }
+    __A_VARIABLE = 1;
 }
 
 char *aeGetApiName(void) {
+    __A_VARIABLE = 1;
     return aeApiName();
 }
 
 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
     eventLoop->beforesleep = beforesleep;
+    __A_VARIABLE = 1;
 }
 
 void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
     eventLoop->aftersleep = aftersleep;
+    __A_VARIABLE = 1;
 }
 
 #undef gettimeofday
diff --git a/src/ae_epoll.c b/src/ae_epoll.c
index 410aac7..fc2c2a7 100644
--- a/src/ae_epoll.c
+++ b/src/ae_epoll.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Linux epoll(2) based ae.c module
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -39,19 +40,25 @@ typedef struct aeApiState {
 static int aeApiCreate(aeEventLoop *eventLoop) {
     aeApiState *state = zmalloc(sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     state->events = zmalloc(sizeof(struct epoll_event)*eventLoop->setsize);
     if (!state->events) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     state->epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
     if (state->epfd == -1) {
         zfree(state->events);
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -59,6 +66,7 @@ static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
     aeApiState *state = eventLoop->apidata;
 
     state->events = zrealloc(state->events, sizeof(struct epoll_event)*setsize);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -68,6 +76,7 @@ static void aeApiFree(aeEventLoop *eventLoop) {
     close(state->epfd);
     zfree(state->events);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
@@ -83,7 +92,11 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
     if (mask & AE_READABLE) ee.events |= EPOLLIN;
     if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
     ee.data.fd = fd;
-    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
+    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -103,6 +116,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
          * EPOLL_CTL_DEL. */
         epoll_ctl(state->epfd,EPOLL_CTL_DEL,fd,&ee);
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
@@ -127,9 +141,11 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             eventLoop->fired[j].mask = mask;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    __A_VARIABLE = 1;
     return "epoll";
 }
diff --git a/src/ae_evport.c b/src/ae_evport.c
index 5c317be..7866ad4 100644
--- a/src/ae_evport.c
+++ b/src/ae_evport.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ae.c module for illumos event ports.
  *
  * Copyright (c) 2012, Joyent, Inc. All rights reserved.
@@ -75,11 +76,15 @@ typedef struct aeApiState {
 static int aeApiCreate(aeEventLoop *eventLoop) {
     int i;
     aeApiState *state = zmalloc(sizeof(aeApiState));
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     state->portfd = port_create();
     if (state->portfd == -1) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
 
@@ -91,11 +96,13 @@ static int aeApiCreate(aeEventLoop *eventLoop) {
     }
 
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
     /* Nothing to resize here. */
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -104,16 +111,20 @@ static void aeApiFree(aeEventLoop *eventLoop) {
 
     close(state->portfd);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiLookupPending(aeApiState *state, int fd) {
     int i;
 
     for (i = 0; i < state->npending; i++) {
-        if (state->pending_fds[i] == fd)
+        if (state->pending_fds[i] == fd) {
+            __A_VARIABLE = 1;
             return (i);
+        }
     }
 
+    __A_VARIABLE = 1;
     return (-1);
 }
 
@@ -146,6 +157,7 @@ static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
             fprintf(stderr, "aeApiAssociate: event port limit exceeded.");
     }
 
+    __A_VARIABLE = 1;
     return rv;
 }
 
@@ -174,9 +186,11 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
         if (evport_debug)
             fprintf(stderr, "aeApiAddEvent: adding to pending fd %d\n", fd);
         state->pending_masks[pfd] |= fullmask;
+        __A_VARIABLE = 1;
         return 0;
     }
 
+    __A_VARIABLE = 1;
     return (aeApiAssociate("aeApiAddEvent", state->portfd, fd, fullmask));
 }
 
@@ -203,6 +217,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
         if (state->pending_masks[pfd] == AE_NONE)
             state->pending_fds[pfd] = -1;
 
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -238,6 +253,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
          */
         abort(); /* will not return */
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
@@ -284,8 +300,10 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
     nevents = 1;
     if (port_getn(state->portfd, event, MAX_EVENT_BATCHSZ, &nevents,
         tsp) == -1 && (errno != ETIME || nevents == 0)) {
-        if (errno == ETIME || errno == EINTR)
+        if (errno == ETIME || errno == EINTR) {
+            __A_VARIABLE = 1;
             return 0;
+        }
 
         /* Any other error indicates a bug. */
         perror("aeApiPoll: port_get");
@@ -312,9 +330,11 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             state->pending_masks[i] = (uintptr_t)event[i].portev_user;
     }
 
+    __A_VARIABLE = 1;
     return nevents;
 }
 
 static char *aeApiName(void) {
+    __A_VARIABLE = 1;
     return "evport";
 }
diff --git a/src/ae_kqueue.c b/src/ae_kqueue.c
index 6796f4c..de3d552 100644
--- a/src/ae_kqueue.c
+++ b/src/ae_kqueue.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Kqueue(2)-based ae.c module
  *
  * Copyright (C) 2009 Harish Mallipeddi - harish.mallipeddi@gmail.com
@@ -41,19 +42,25 @@ typedef struct aeApiState {
 static int aeApiCreate(aeEventLoop *eventLoop) {
     aeApiState *state = zmalloc(sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     state->events = zmalloc(sizeof(struct kevent)*eventLoop->setsize);
     if (!state->events) {
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     state->kqfd = kqueue();
     if (state->kqfd == -1) {
         zfree(state->events);
         zfree(state);
+        __A_VARIABLE = 1;
         return -1;
     }
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -61,6 +68,7 @@ static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
     aeApiState *state = eventLoop->apidata;
 
     state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -70,6 +78,7 @@ static void aeApiFree(aeEventLoop *eventLoop) {
     close(state->kqfd);
     zfree(state->events);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
@@ -78,12 +87,19 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
 
     if (mask & AE_READABLE) {
         EV_SET(&ke, fd, EVFILT_READ, EV_ADD, 0, 0, NULL);
-        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
     if (mask & AE_WRITABLE) {
         EV_SET(&ke, fd, EVFILT_WRITE, EV_ADD, 0, 0, NULL);
-        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
+        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -99,6 +115,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
         EV_SET(&ke, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
         kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
@@ -130,9 +147,11 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             eventLoop->fired[j].mask = mask;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    __A_VARIABLE = 1;
     return "kqueue";
 }
diff --git a/src/ae_select.c b/src/ae_select.c
index ed4f2a3..d1641dc 100644
--- a/src/ae_select.c
+++ b/src/ae_select.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Select()-based ae.c module.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -44,21 +45,30 @@ typedef struct aeApiState {
 static int aeApiCreate(aeEventLoop *eventLoop) {
     aeApiState *state = flexos_calloc_whitelist(1, sizeof(aeApiState));
 
-    if (!state) return -1;
+    if (!state) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     FD_ZERO(&state->rfds);
     FD_ZERO(&state->wfds);
     eventLoop->apidata = state;
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
     /* Just ensure we have enough room in the fd_set type. */
-    if (setsize >= FD_SETSIZE) return -1;
+    if (setsize >= FD_SETSIZE) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static void aeApiFree(aeEventLoop *eventLoop) {
     zfree(eventLoop->apidata);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
@@ -66,6 +76,7 @@ static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
 
     if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
     if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -74,6 +85,7 @@ static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
 
     if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
     if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
+    __A_VARIABLE = 1;
 }
 
 static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
@@ -102,9 +114,11 @@ static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
             numevents++;
         }
     }
+    __A_VARIABLE = 1;
     return numevents;
 }
 
 static char *aeApiName(void) {
+    __A_VARIABLE = 1;
     return "select";
 }
diff --git a/src/anet.c b/src/anet.c
index 69005e5..afa94a7 100644
--- a/src/anet.c
+++ b/src/anet.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* anet.c -- Basic TCP socket stuff made a bit less boring
  *
  * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -53,10 +54,14 @@ static void anetSetError(char *err, const char *fmt, ...)
 {
     va_list ap;
 
-    if (!err) return;
+    if (!err) {
+        __A_VARIABLE = 1;
+        return;
+    }
     va_start(ap, fmt);
     vsnprintf(err, ANET_ERR_LEN, fmt, ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 int anetSetBlock(char *err, int fd, int non_block) {
@@ -67,6 +72,7 @@ int anetSetBlock(char *err, int fd, int non_block) {
      * interrupted by a signal. */
     if ((flags = fcntl(fd, F_GETFL)) == -1) {
         anetSetError(err, "fcntl(F_GETFL): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -77,16 +83,20 @@ int anetSetBlock(char *err, int fd, int non_block) {
 
     if (fcntl(fd, F_SETFL, flags) == -1) {
         anetSetError(err, "fcntl(F_SETFL,O_NONBLOCK): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetNonBlock(char *err, int fd) {
+    __A_VARIABLE = 1;
     return anetSetBlock(err,fd,1);
 }
 
 int anetBlock(char *err, int fd) {
+    __A_VARIABLE = 1;
     return anetSetBlock(err,fd,0);
 }
 
@@ -155,18 +165,22 @@ static int anetSetTcpNoDelay(char *err, int fd, int val)
     if (ret == -1)
     {
         anetSetError(err, "setsockopt TCP_NODELAY: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetEnableTcpNoDelay(char *err, int fd)
 {
+    __A_VARIABLE = 1;
     return anetSetTcpNoDelay(err, fd, 1);
 }
 
 int anetDisableTcpNoDelay(char *err, int fd)
 {
+    __A_VARIABLE = 1;
     return anetSetTcpNoDelay(err, fd, 0);
 }
 
@@ -178,8 +192,10 @@ int anetSetSendBuffer(char *err, int fd, int buffsize)
     if (ret == -1)
     {
         anetSetError(err, "setsockopt SO_SNDBUF: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -190,8 +206,10 @@ int anetTcpKeepAlive(char *err, int fd)
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_KEEPALIVE: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -206,8 +224,10 @@ int anetSendTimeout(char *err, int fd, long long ms) {
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_SNDTIMEO: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -232,6 +252,7 @@ int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
     flexos_gate_r(liblwip, rv, getaddrinfo, host, NULL, &hints, &info);
     if (rv != 0) {
         anetSetError(err, "%s", gai_strerror(rv));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
     if (info->ai_family == AF_INET) {
@@ -243,14 +264,17 @@ int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
     }
 
     freeaddrinfo(info);
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
 int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len) {
+    __A_VARIABLE = 1;
     return anetGenericResolve(err,host,ipbuf,ipbuf_len,ANET_NONE);
 }
 
 int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len) {
+    __A_VARIABLE = 1;
     return anetGenericResolve(err,host,ipbuf,ipbuf_len,ANET_IP_ONLY);
 }
 
@@ -262,8 +286,10 @@ static int anetSetReuseAddr(char *err, int fd) {
     flexos_gate_r(liblwip, ret, setsockopt, fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
     if (ret == -1) {
         anetSetError(err, "setsockopt SO_REUSEADDR: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -272,6 +298,7 @@ static int anetCreateSocket(char *err, int domain) {
     flexos_gate_r(liblwip, s, socket, domain, SOCK_STREAM, 0);
     if (s == -1) {
         anetSetError(err, "creating socket: %s", strerror(errno));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -279,8 +306,10 @@ static int anetCreateSocket(char *err, int domain) {
      * will be able to close/open sockets a zillion of times */
     if (anetSetReuseAddr(err,s) == ANET_ERR) {
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -372,17 +401,20 @@ end:
 
 int anetTcpConnect(char *err, char *addr, int port)
 {
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONE);
 }
 
 int anetTcpNonBlockConnect(char *err, char *addr, int port)
 {
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);
 }
 
 int anetTcpNonBlockBindConnect(char *err, char *addr, int port,
                                char *source_addr)
 {
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,source_addr,
             ANET_CONNECT_NONBLOCK);
 }
@@ -390,6 +422,7 @@ int anetTcpNonBlockBindConnect(char *err, char *addr, int port,
 int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port,
                                          char *source_addr)
 {
+    __A_VARIABLE = 1;
     return anetTcpGenericConnect(err,addr,port,source_addr,
             ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);
 }
@@ -399,36 +432,45 @@ int anetUnixGenericConnect(char *err, char *path, int flags)
     int s;
     struct sockaddr_un sa;
 
-    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
+    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
     if (flags & ANET_CONNECT_NONBLOCK) {
         if (anetNonBlock(err,s) != ANET_OK) {
             close(s);
+            __A_VARIABLE = 1;
             return ANET_ERR;
         }
     }
     if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
         if (errno == EINPROGRESS &&
-            flags & ANET_CONNECT_NONBLOCK)
+            flags & ANET_CONNECT_NONBLOCK) {
+            __A_VARIABLE = 1;
             return s;
+        }
 
         anetSetError(err, "connect: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 int anetUnixConnect(char *err, char *path)
 {
+    __A_VARIABLE = 1;
     return anetUnixGenericConnect(err,path,ANET_CONNECT_NONE);
 }
 
 int anetUnixNonBlockConnect(char *err, char *path)
 {
+    __A_VARIABLE = 1;
     return anetUnixGenericConnect(err,path,ANET_CONNECT_NONBLOCK);
 }
 
@@ -439,11 +481,18 @@ int anetRead(int fd, char *buf, int count)
     ssize_t nread, totlen = 0;
     while(totlen != count) {
         nread = read(fd,buf,count-totlen);
-        if (nread == 0) return totlen;
-        if (nread == -1) return -1;
+        if (nread == 0) {
+            __A_VARIABLE = 1;
+            return totlen;
+        }
+        if (nread == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         totlen += nread;
         buf += nread;
     }
+    __A_VARIABLE = 1;
     return totlen;
 }
 
@@ -454,11 +503,18 @@ int anetWrite(int fd, char *buf, int count)
     ssize_t nwritten, totlen = 0;
     while(totlen != count) {
         nwritten = write(fd,buf,count-totlen);
-        if (nwritten == 0) return totlen;
-        if (nwritten == -1) return -1;
+        if (nwritten == 0) {
+            __A_VARIABLE = 1;
+            return totlen;
+        }
+        if (nwritten == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         totlen += nwritten;
         buf += nwritten;
     }
+    __A_VARIABLE = 1;
     return totlen;
 }
 
@@ -469,6 +525,7 @@ static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int
     if (ret == -1) {
         anetSetError(err, "bind: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
 
@@ -476,8 +533,10 @@ static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int
     if (ret == -1) {
         anetSetError(err, "listen: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -488,8 +547,10 @@ static int anetV6Only(char *err, int s) {
     if (ret == -1) {
         anetSetError(err, "setsockopt: %s", strerror(errno));
         close(s);
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
+    __A_VARIABLE = 1;
     return ANET_OK;
 }
 
@@ -511,6 +572,7 @@ static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backl
 
     if (rv != 0) {
         anetSetError(err, "%s", gai_strerror(rv));
+        __A_VARIABLE = 1;
         return ANET_ERR;
     }
     for (p = servinfo; p != NULL; p = p->ai_next) {
@@ -533,16 +595,19 @@ error:
     s = ANET_ERR;
 end:
     flexos_gate(liblwip, freeaddrinfo, servinfo);
+    __A_VARIABLE = 1;
     return s;
 }
 
 int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
 {
+    __A_VARIABLE = 1;
     return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
 }
 
 int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)
 {
+    __A_VARIABLE = 1;
     return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);
 }
 
@@ -551,16 +616,21 @@ int anetUnixServer(char *err, char *path, mode_t perm, int backlog)
     int s;
     struct sockaddr_un sa;
 
-    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
+    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     memset(&sa,0,sizeof(sa));
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
-    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)
+    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
     if (perm)
         chmod(sa.sun_path, perm);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -585,8 +655,10 @@ static struct sockaddr_storage sa __section(".data_shared");
 static socklen_t salen __section(".data_shared") = sizeof(sa);
 int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {
     int fd;
-    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
+    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
     if (sa.ss_family == AF_INET) {
         struct sockaddr_in *s = (struct sockaddr_in *)&sa;
@@ -597,6 +669,7 @@ int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {
         if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
         if (port) *port = ntohs(s->sin6_port);
     }
+    __A_VARIABLE = 1;
     return fd;
 }
 
@@ -604,9 +677,12 @@ int anetUnixAccept(char *err, int s) {
     int fd;
     struct sockaddr_un sa;
     socklen_t salen = sizeof(sa);
-    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1)
+    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == -1) {
+        __A_VARIABLE = 1;
         return ANET_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return fd;
 }
 
@@ -633,6 +709,7 @@ int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {
     } else {
         goto error;
     }
+    __A_VARIABLE = 1;
     return 0;
 
 error:
@@ -645,6 +722,7 @@ error:
         }
     }
     if (port) *port = 0;
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -652,6 +730,7 @@ error:
  * (matches for ":"), the ip is surrounded by []. IP and port are just
  * separated by colons. This the standard to display addresses within Redis. */
 int anetFormatAddr(char *buf, size_t buf_len, char *ip, int port) {
+    __A_VARIABLE = 1;
     return snprintf(buf,buf_len, strchr(ip,':') ?
            "[%s]:%d" : "%s:%d", ip, port);
 }
@@ -662,6 +741,7 @@ int anetFormatPeer(int fd, char *buf, size_t buf_len) {
     int port;
 
     anetPeerToString(fd,ip,sizeof(ip),&port);
+    __A_VARIABLE = 1;
     return anetFormatAddr(buf, buf_len, ip, port);
 }
 
@@ -673,6 +753,7 @@ int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
         if (port) *port = 0;
         ip[0] = '?';
         ip[1] = '\0';
+        __A_VARIABLE = 1;
         return -1;
     }
     if (sa.ss_family == AF_INET) {
@@ -684,6 +765,7 @@ int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
         if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
         if (port) *port = ntohs(s->sin6_port);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -692,5 +774,6 @@ int anetFormatSock(int fd, char *fmt, size_t fmt_len) {
     int port;
 
     anetSockName(fd,ip,sizeof(ip),&port);
+    __A_VARIABLE = 1;
     return anetFormatAddr(fmt, fmt_len, ip, port);
 }
diff --git a/src/aof.c b/src/aof.c
index 1014164..de5445d 100644
--- a/src/aof.c
+++ b/src/aof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -73,6 +74,7 @@ void aofRewriteBufferReset(void) {
 
     server.aof_rewrite_buf_blocks = listCreate();
     listSetFreeMethod(server.aof_rewrite_buf_blocks,zfree);
+    __A_VARIABLE = 1;
 }
 
 /* Return the current size of the AOF rewrite buffer. */
@@ -86,6 +88,7 @@ unsigned long aofRewriteBufferSize(void) {
         aofrwblock *block = listNodeValue(ln);
         size += block->used;
     }
+    __A_VARIABLE = 1;
     return size;
 }
 
@@ -107,18 +110,23 @@ void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
         if (server.aof_stop_sending_diff || !block) {
             aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
                               AE_WRITABLE);
+            __A_VARIABLE = 1;
             return;
         }
         if (block->used > 0) {
             nwritten = write(server.aof_pipe_write_data_to_child,
                              block->buf,block->used);
-            if (nwritten <= 0) return;
+            if (nwritten <= 0) {
+            	__A_VARIABLE = 1;
+            	return;
+            }
             memmove(block->buf,block->buf+nwritten,block->used-nwritten);
             block->used -= nwritten;
             block->free += nwritten;
         }
         if (block->used == 0) listDelNode(server.aof_rewrite_buf_blocks,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Append data to the AOF rewrite buffer, allocating new blocks if needed. */
@@ -166,6 +174,7 @@ void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {
         aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,
             AE_WRITABLE, aofChildWriteDiffData, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Write the buffer (possibly composed of multiple blocks) into the specified
@@ -185,11 +194,13 @@ ssize_t aofRewriteBufferWrite(int fd) {
             nwritten = write(fd,block->buf,block->used);
             if (nwritten != (ssize_t)block->used) {
                 if (nwritten == 0) errno = EIO;
+                __A_VARIABLE = 1;
                 return -1;
             }
             count += nwritten;
         }
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -200,6 +211,7 @@ ssize_t aofRewriteBufferWrite(int fd) {
 /* Return true if an AOf fsync is currently already in progress in a
  * BIO thread. */
 int aofFsyncInProgress(void) {
+    __A_VARIABLE = 1;
     return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
 }
 
@@ -207,13 +219,17 @@ int aofFsyncInProgress(void) {
  * file descriptor (the one of the AOF file) in another thread. */
 void aof_background_fsync(int fd) {
     bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(long)fd,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Kills an AOFRW child process if exists */
 static void killAppendOnlyChild(void) {
     int statloc;
     /* No AOFRW child? return. */
-    if (server.aof_child_pid == -1) return;
+    if (server.aof_child_pid == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Kill AOFRW child, wait for child exit. */
     serverLog(LL_NOTICE,"Killing running AOF rewrite child: %ld",
         (long) server.aof_child_pid);
@@ -227,6 +243,7 @@ static void killAppendOnlyChild(void) {
     server.aof_rewrite_time_start = -1;
     /* Close pipes used for IPC between the two processes. */
     aofClosePipes();
+    __A_VARIABLE = 1;
 }
 
 /* Called when the user switches from "appendonly yes" to "appendonly no"
@@ -241,6 +258,7 @@ void stopAppendOnly(void) {
     server.aof_selected_db = -1;
     server.aof_state = AOF_OFF;
     killAppendOnlyChild();
+    __A_VARIABLE = 1;
 }
 
 /* Called when the user switches from "appendonly no" to "appendonly yes"
@@ -304,6 +322,7 @@ ssize_t aofWrite(int fd, const char *buf, size_t len) {
             if (errno == EINTR) {
                 continue;
             }
+            __A_VARIABLE = 1;
             return totwritten ? totwritten : -1;
         }
 
@@ -312,6 +331,7 @@ ssize_t aofWrite(int fd, const char *buf, size_t len) {
         totwritten += nwritten;
     }
 
+    __A_VARIABLE = 1;
     return totwritten;
 }
 
@@ -537,6 +557,7 @@ sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
         dst = sdscatlen(dst,"\r\n",2);
         decrRefCount(o);
     }
+    __A_VARIABLE = 1;
     return dst;
 }
 
@@ -574,6 +595,7 @@ sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, r
     buf = catAppendOnlyGenericCommand(buf, 3, argv);
     decrRefCount(argv[0]);
     decrRefCount(argv[2]);
+    __A_VARIABLE = 1;
     return buf;
 }
 
@@ -641,6 +663,7 @@ void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int a
         aofRewriteBufferAppend((unsigned char*)buf,sdslen(buf));
 
     sdsfree(buf);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -673,6 +696,7 @@ struct client *createFakeClient(void) {
     listSetFreeMethod(c->reply,freeClientReplyValue);
     listSetDupMethod(c->reply,dupClientReplyValue);
     initClientMultiState(c);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -682,6 +706,7 @@ void freeFakeClientArgv(struct client *c) {
     for (j = 0; j < c->argc; j++)
         decrRefCount(c->argv[j]);
     zfree(c->argv);
+    __A_VARIABLE = 1;
 }
 
 void freeFakeClient(struct client *c) {
@@ -690,6 +715,7 @@ void freeFakeClient(struct client *c) {
     listRelease(c->watched_keys);
     freeClientMultiState(c);
     zfree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Replay the append log file. On success C_OK is returned. On non fatal
@@ -717,6 +743,7 @@ int loadAppendOnlyFile(char *filename) {
         server.aof_current_size = 0;
         server.aof_fsync_offset = server.aof_current_size;
         fclose(fp);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -855,6 +882,7 @@ loaded_ok: /* DB loaded, cleanup and return C_OK to the caller. */
     aofUpdateCurrentSize();
     server.aof_rewrite_base_size = server.aof_current_size;
     server.aof_fsync_offset = server.aof_current_size;
+    __A_VARIABLE = 1;
     return C_OK;
 
 readerr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */
@@ -897,6 +925,7 @@ fmterr: /* Format error. */
     if (fakeClient) freeFakeClient(fakeClient); /* avoid valgrind warning */
     serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -1105,19 +1134,35 @@ int rewriteHashObject(rio *r, robj *key, robj *o) {
             int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                 AOF_REWRITE_ITEMS_PER_CMD : items;
 
-            if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
-            if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
-            if (rioWriteBulkObject(r,key) == 0) return 0;
+            if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
+            if (rioWriteBulkString(r,"HMSET",5) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
+            if (rioWriteBulkObject(r,key) == 0) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
         }
 
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
         items--;
     }
 
     hashTypeReleaseIterator(hi);
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1127,8 +1172,12 @@ int rioWriteBulkStreamID(rio *r,streamID *id) {
     int retval;
 
     sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
-    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) return 0;
+    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     sdsfree(replyid);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1141,19 +1190,59 @@ int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t
                RETRYCOUNT <count> JUSTID FORCE. */
     streamID id;
     streamDecodeID(rawid,&id);
-    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
-    if (rioWriteBulkString(r,"XCLAIM",6) == 0) return 0;
-    if (rioWriteBulkObject(r,key) == 0) return 0;
-    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
-    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
-    if (rioWriteBulkString(r,"0",1) == 0) return 0;
-    if (rioWriteBulkStreamID(r,&id) == 0) return 0;
-    if (rioWriteBulkString(r,"TIME",4) == 0) return 0;
-    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
-    if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) return 0;
-    if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) return 0;
-    if (rioWriteBulkString(r,"JUSTID",6) == 0) return 0;
-    if (rioWriteBulkString(r,"FORCE",5) == 0) return 0;
+    if (rioWriteBulkCount(r,'*',12) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"XCLAIM",6) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkObject(r,key) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,groupname,groupname_len) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"0",1) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkStreamID(r,&id) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"TIME",4) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"RETRYCOUNT",10) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkLongLong(r,nack->delivery_count) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"JUSTID",6) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWriteBulkString(r,"FORCE",5) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1268,6 +1357,7 @@ int rewriteModuleObject(rio *r, robj *key, robj *o) {
         moduleFreeContext(io.ctx);
         zfree(io.ctx);
     }
+    __A_VARIABLE = 1;
     return io.error ? 0 : 1;
 }
 
@@ -1283,6 +1373,7 @@ ssize_t aofReadDiffFromParent(void) {
         server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
         total += nread;
     }
+    __A_VARIABLE = 1;
     return total;
 }
 
@@ -1354,10 +1445,12 @@ int rewriteAppendOnlyFileRio(rio *aof) {
         dictReleaseIterator(di);
         di = NULL;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     if (di) dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1380,6 +1473,7 @@ int rewriteAppendOnlyFile(char *filename) {
     fp = fopen(tmpfile,"w");
     if (!fp) {
         serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1454,15 +1548,18 @@ int rewriteAppendOnlyFile(char *filename) {
     if (rename(tmpfile,filename) == -1) {
         serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", strerror(errno));
         unlink(tmpfile);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     serverLog(LL_WARNING,"Write error writing append only file on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1494,6 +1591,7 @@ void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
     /* Remove the handler since this can be called only one time during a
      * rewrite. */
     aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
+    __A_VARIABLE = 1;
 }
 
 /* Create the pipes used for parent - child process IPC during rewrite.
@@ -1520,12 +1618,14 @@ int aofCreatePipes(void) {
     server.aof_pipe_write_ack_to_child = fds[5];
     server.aof_pipe_read_ack_from_parent = fds[4];
     server.aof_stop_sending_diff = 0;
+    __A_VARIABLE = 1;
     return C_OK;
 
 error:
     serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
         strerror(errno));
     for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1538,6 +1638,7 @@ void aofClosePipes(void) {
     close(server.aof_pipe_read_ack_from_child);
     close(server.aof_pipe_write_ack_to_child);
     close(server.aof_pipe_read_ack_from_parent);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -1627,6 +1728,7 @@ void bgrewriteaofCommand(client *c) {
     } else {
         addReply(c,shared.err);
     }
+    __A_VARIABLE = 1;
 }
 
 void aofRemoveTempFile(pid_t childpid) {
@@ -1634,6 +1736,7 @@ void aofRemoveTempFile(pid_t childpid) {
 
     snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) childpid);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* Update the server.aof_current_size field explicitly using stat(2)
@@ -1653,6 +1756,7 @@ void aofUpdateCurrentSize(void) {
     }
     latencyEndMonitor(latency);
     latencyAddSampleIfNeeded("aof-fstat",latency);
+    __A_VARIABLE = 1;
 }
 
 /* A background append only file rewriting (BGREWRITEAOF) terminated its work.
@@ -1805,4 +1909,5 @@ cleanup:
     /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */
     if (server.aof_state == AOF_WAIT_REWRITE)
         server.aof_rewrite_scheduled = 1;
+    __A_VARIABLE = 1;
 }
diff --git a/src/bio.c b/src/bio.c
index 2af6845..b611e10 100644
--- a/src/bio.c
+++ b/src/bio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Background I/O service for Redis.
  *
  * This file implements operations that we need to perform in the background.
@@ -126,6 +127,7 @@ void bioInit(void) {
         }
         bio_threads[j] = thread;
     }
+    __A_VARIABLE = 1;
 }
 
 void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
@@ -140,6 +142,7 @@ void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
     bio_pending[type]++;
     pthread_cond_signal(&bio_newjob_cond[type]);
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
 }
 
 void *bioProcessBackgroundJobs(void *arg) {
@@ -151,6 +154,7 @@ void *bioProcessBackgroundJobs(void *arg) {
     if (type >= BIO_NUM_OPS) {
         serverLog(LL_WARNING,
             "Warning: bio thread started with wrong type %lu",type);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -213,6 +217,7 @@ void *bioProcessBackgroundJobs(void *arg) {
         /* Unblock threads blocked on bioWaitStepOfType() if any. */
         pthread_cond_broadcast(&bio_step_cond[type]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of pending jobs of the specified type. */
@@ -221,6 +226,7 @@ unsigned long long bioPendingJobsOfType(int type) {
     pthread_mutex_lock(&bio_mutex[type]);
     val = bio_pending[type];
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -243,6 +249,7 @@ unsigned long long bioWaitStepOfType(int type) {
         val = bio_pending[type];
     }
     pthread_mutex_unlock(&bio_mutex[type]);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -265,4 +272,5 @@ void bioKillThreads(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/bitops.c b/src/bitops.c
index 7328d63..4d40075 100644
--- a/src/bitops.c
+++ b/src/bitops.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Bit operations.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -88,6 +89,7 @@ size_t redisPopcount(void *s, long count) {
     /* Count the remaining bytes. */
     p = (unsigned char*)p4;
     while(count--) bits += bitsinbyte[*p++];
+    __A_VARIABLE = 1;
     return bits;
 }
 
@@ -163,7 +165,10 @@ long redisBitpos(void *s, unsigned long count, int bit) {
      * return -1 to signal that there is not a single "1" in the whole
      * string. This can't happen when we are looking for "0" as we assume
      * that the right of the string is zero padded. */
-    if (bit == 1 && word == 0) return -1;
+    if (bit == 1 && word == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Last word left, scan bit by bit. The first thing we need is to
      * have a single "1" set in the most significant position in an
@@ -174,7 +179,10 @@ long redisBitpos(void *s, unsigned long count, int bit) {
     one = ~one;      /* All bits set to 0 but the MSB. */
 
     while(one) {
-        if (((one & word) != 0) == bit) return pos;
+        if (((one & word) != 0) == bit) {
+            __A_VARIABLE = 1;
+            return pos;
+        }
         pos++;
         one >>= 1;
     }
@@ -182,6 +190,7 @@ long redisBitpos(void *s, unsigned long count, int bit) {
     /* If we reached this point, there is a bug in the algorithm, since
      * the case of no match is handled as a special case before. */
     serverPanic("End of redisBitpos() reached.");
+    __A_VARIABLE = 1;
     return 0; /* Just to avoid warnings. */
 }
 
@@ -219,11 +228,13 @@ void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint6
         p[byte] = byteval & 0xff;
         offset++;
     }
+    __A_VARIABLE = 1;
 }
 
 void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
     uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
     setUnsignedBitfield(p,offset,bits,uv);
+    __A_VARIABLE = 1;
 }
 
 uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
@@ -237,6 +248,7 @@ uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
         value = (value<<1) | bitval;
         offset++;
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -259,6 +271,7 @@ int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
      * integers. */
     if (value & ((uint64_t)1 << (bits-1)))
         value |= ((uint64_t)-1) << bits;
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -386,6 +399,7 @@ void printBits(unsigned char *p, unsigned long count) {
         printf("|");
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -420,6 +434,7 @@ int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int b
 
     if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -430,10 +445,12 @@ int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int b
     if ((loffset < 0) || ((unsigned long long)loffset >> 3) >= (512*1024*1024))
     {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     *offset = (size_t)loffset;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -518,6 +535,7 @@ unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
     } else {
         if (len) *len = 0;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -530,19 +548,27 @@ void setbitCommand(client *c) {
     int byteval, bitval;
     long on;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
-    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
+    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* Bits can only be set or cleared... */
     if (on & ~1) {
         addReplyError(c,err);
+        __A_VARIABLE = 1;
         return;
     }
 
-    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;
+    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Get current values */
     byte = bitoffset >> 3;
@@ -558,6 +584,7 @@ void setbitCommand(client *c) {
     notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c, bitval ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 /* GETBIT key offset */
@@ -568,11 +595,16 @@ void getbitCommand(client *c) {
     size_t byte, bit;
     size_t bitval = 0;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     byte = bitoffset >> 3;
     bit = 7 - (bitoffset & 0x7);
@@ -585,6 +617,7 @@ void getbitCommand(client *c) {
     }
 
     addReply(c, bitval ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 /* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */
diff --git a/src/blocked.c b/src/blocked.c
index 2b43f2b..3d5b06d 100644
--- a/src/blocked.c
+++ b/src/blocked.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* blocked.c - generic support for blocking operations like BLPOP & WAIT.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -79,11 +80,14 @@ int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int
     long long tval;
 
     if (getLongLongFromObjectOrReply(c,object,&tval,
-        "timeout is not an integer or out of range") != C_OK)
+        "timeout is not an integer or out of range") != C_OK) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
 
     if (tval < 0) {
         addReplyError(c,"timeout is negative");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -93,6 +97,7 @@ int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int
     }
     *timeout = tval;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -104,6 +109,7 @@ void blockClient(client *c, int btype) {
     c->btype = btype;
     server.blocked_clients++;
     server.blocked_clients_by_type[btype]++;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called in the beforeSleep() function of the event loop
@@ -130,6 +136,7 @@ void processUnblockedClients(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function will schedule the client for reprocessing at a safe time.
@@ -155,6 +162,7 @@ void queueClientForReprocessing(client *c) {
         c->flags |= CLIENT_UNBLOCKED;
         listAddNodeTail(server.unblocked_clients,c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Unblock a client calling the right function depending on the kind
@@ -178,6 +186,7 @@ void unblockClient(client *c) {
     c->flags &= ~CLIENT_BLOCKED;
     c->btype = BLOCKED_NONE;
     queueClientForReprocessing(c);
+    __A_VARIABLE = 1;
 }
 
 /* This function gets called when a blocked client timed out in order to
@@ -195,6 +204,7 @@ void replyToBlockedClientTimedOut(client *c) {
     } else {
         serverPanic("Unknown btype in replyToBlockedClientTimedOut().");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Mass-unblock clients because something changed in the instance that makes
@@ -220,6 +230,7 @@ void disconnectAllBlockedClients(void) {
             c->flags |= CLIENT_CLOSE_AFTER_REPLY;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function should be called by Redis every time a single command,
@@ -465,6 +476,7 @@ void handleClientsBlockedOnKeys(void) {
         }
         listRelease(l); /* We have the new list on place at this point. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* This is how the current blocking lists/sorted sets/streams work, we use
@@ -536,6 +548,7 @@ void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeo
         listAddNodeTail(l,c);
     }
     blockClient(c,btype);
+    __A_VARIABLE = 1;
 }
 
 /* Unblock a client that's waiting in a blocking operation such as BLPOP.
@@ -573,6 +586,7 @@ void unblockClientWaitingData(client *c) {
         c->bpop.xread_group = NULL;
         c->bpop.xread_consumer = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* If the specified key has clients blocked waiting for list pushes, this
@@ -586,10 +600,16 @@ void signalKeyAsReady(redisDb *db, robj *key) {
     readyList *rl;
 
     /* No clients blocking for this key? No need to queue it. */
-    if (dictFind(db->blocking_keys,key) == NULL) return;
+    if (dictFind(db->blocking_keys,key) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Key was already signaled? No need to queue it again. */
-    if (dictFind(db->ready_keys,key) != NULL) return;
+    if (dictFind(db->ready_keys,key) != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Ok, we need to queue this key into server.ready_keys. */
     rl = zmalloc(sizeof(*rl));
@@ -603,6 +623,7 @@ void signalKeyAsReady(redisDb *db, robj *key) {
      * check. */
     incrRefCount(key);
     serverAssert(dictAdd(db->ready_keys,key,NULL) == DICT_OK);
+    __A_VARIABLE = 1;
 }
 
 
diff --git a/src/childinfo.c b/src/childinfo.c
index 719025e..9dcd87a 100644
--- a/src/childinfo.c
+++ b/src/childinfo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -43,6 +44,7 @@ void openChildInfoPipe(void) {
     } else {
         memset(&server.child_info_data,0,sizeof(server.child_info_data));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Close the pipes opened with openChildInfoPipe(). */
@@ -55,23 +57,31 @@ void closeChildInfoPipe(void) {
         server.child_info_pipe[0] = -1;
         server.child_info_pipe[1] = -1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send COW data to parent. The child should call this function after populating
  * the corresponding fields it want to sent (according to the process type). */
 void sendChildInfo(int ptype) {
-    if (server.child_info_pipe[1] == -1) return;
+    if (server.child_info_pipe[1] == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     server.child_info_data.magic = CHILD_INFO_MAGIC;
     server.child_info_data.process_type = ptype;
     ssize_t wlen = sizeof(server.child_info_data);
     if (write(server.child_info_pipe[1],&server.child_info_data,wlen) != wlen) {
         /* Nothing to do on error, this will be detected by the other side. */
     }
+    __A_VARIABLE = 1;
 }
 
 /* Receive COW data from parent. */
 void receiveChildInfo(void) {
-    if (server.child_info_pipe[0] == -1) return;
+    if (server.child_info_pipe[0] == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ssize_t wlen = sizeof(server.child_info_data);
     if (read(server.child_info_pipe[0],&server.child_info_data,wlen) == wlen &&
         server.child_info_data.magic == CHILD_INFO_MAGIC)
@@ -82,4 +92,5 @@ void receiveChildInfo(void) {
             server.stat_aof_cow_bytes = server.child_info_data.cow_size;
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/cluster.c b/src/cluster.c
index 858c0c9..c1e8708 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis Cluster implementation.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -349,11 +350,13 @@ int clusterSaveConfig(int do_fsync) {
     }
     close(fd);
     sdsfree(ci);
+    __A_VARIABLE = 1;
     return 0;
 
 err:
     if (fd != -1) close(fd);
     sdsfree(ci);
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -362,6 +365,7 @@ void clusterSaveConfigOrDie(int do_fsync) {
         serverLog(LL_WARNING,"Fatal: can't update cluster config file.");
         exit(1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Lock the cluster config using flock(), and leaks the file descritor used to
@@ -425,6 +429,7 @@ void clusterUpdateMyselfFlags(void) {
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE);
     }
+    __A_VARIABLE = 1;
 }
 
 void clusterInit(void) {
@@ -518,6 +523,7 @@ void clusterInit(void) {
     server.cluster->mf_end = 0;
     resetManualFailover();
     clusterUpdateMyselfFlags();
+    __A_VARIABLE = 1;
 }
 
 /* Reset a node performing a soft or hard reset:
@@ -581,6 +587,7 @@ void clusterReset(int hard) {
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE|
                          CLUSTER_TODO_FSYNC_CONFIG);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -594,6 +601,7 @@ clusterLink *createClusterLink(clusterNode *node) {
     link->rcvbuf = sdsempty();
     link->node = node;
     link->fd = -1;
+    __A_VARIABLE = 1;
     return link;
 }
 
@@ -610,6 +618,7 @@ void freeClusterLink(clusterLink *link) {
         link->node->link = NULL;
     close(link->fd);
     zfree(link);
+    __A_VARIABLE = 1;
 }
 
 #define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
@@ -624,7 +633,10 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
 
     /* If the server is starting up, don't accept cluster connections:
      * UPDATE messages may interact with the database content. */
-    if (server.masterhost == NULL && server.loading) return;
+    if (server.masterhost == NULL && server.loading) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     while(max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
@@ -632,6 +644,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_VERBOSE,
                     "Error accepting cluster node: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         anetNonBlock(NULL,cfd);
@@ -648,6 +661,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         link->fd = cfd;
         aeCreateFileEvent(server.el,cfd,AE_READABLE,clusterReadHandler,link);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -667,17 +681,24 @@ unsigned int keyHashSlot(char *key, int keylen) {
         if (key[s] == '{') break;
 
     /* No '{' ? Hash the whole key. This is the base case. */
-    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
+    if (s == keylen) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* '{' found? Check if we have the corresponding '}'. */
     for (e = s+1; e < keylen; e++)
         if (key[e] == '}') break;
 
     /* No '}' or nothing between {} ? Hash the whole key. */
-    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
+    if (e == keylen || e == s+1) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* If we are here there is both a { and a } on its right. Hash
      * what is in the middle between { and }. */
+    __A_VARIABLE = 1;
     return crc16(key+s+1,e-s-1) & 0x3FFF;
 }
 
@@ -719,6 +740,7 @@ clusterNode *createClusterNode(char *nodename, int flags) {
     node->repl_offset_time = 0;
     node->repl_offset = 0;
     listSetFreeMethod(node->fail_reports,zfree);
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -745,6 +767,7 @@ int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
         fr = ln->value;
         if (fr->node == sender) {
             fr->time = mstime();
+            __A_VARIABLE = 1;
             return 0;
         }
     }
@@ -754,6 +777,7 @@ int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
     fr->node = sender;
     fr->time = mstime();
     listAddNodeTail(l,fr);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -776,6 +800,7 @@ void clusterNodeCleanupFailureReports(clusterNode *node) {
         fr = ln->value;
         if (now - fr->time > maxtime) listDelNode(l,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Remove the failing report for 'node' if it was previously considered
@@ -801,11 +826,15 @@ int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
         fr = ln->value;
         if (fr->node == sender) break;
     }
-    if (!ln) return 0; /* No failure report from this sender. */
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* No failure report from this sender. */
 
     /* Remove the failure report. */
     listDelNode(l,ln);
     clusterNodeCleanupFailureReports(node);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -814,6 +843,7 @@ int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
  * node as well. */
 int clusterNodeFailureReportsCount(clusterNode *node) {
     clusterNodeCleanupFailureReports(node);
+    __A_VARIABLE = 1;
     return listLength(node->fail_reports);
 }
 
@@ -830,9 +860,11 @@ int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
             master->numslaves--;
             if (master->numslaves == 0)
                 master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
+            __A_VARIABLE = 1;
             return C_OK;
         }
     }
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -841,12 +873,16 @@ int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
 
     /* If it's already a slave, don't add it again. */
     for (j = 0; j < master->numslaves; j++)
-        if (master->slaves[j] == slave) return C_ERR;
+        if (master->slaves[j] == slave) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     master->slaves = zrealloc(master->slaves,
         sizeof(clusterNode*)*(master->numslaves+1));
     master->slaves[master->numslaves] = slave;
     master->numslaves++;
     master->flags |= CLUSTER_NODE_MIGRATE_TO;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -855,6 +891,7 @@ int clusterCountNonFailingSlaves(clusterNode *n) {
 
     for (j = 0; j < n->numslaves; j++)
         if (!nodeFailed(n->slaves[j])) okslaves++;
+    __A_VARIABLE = 1;
     return okslaves;
 }
 
@@ -881,6 +918,7 @@ void freeClusterNode(clusterNode *n) {
     listRelease(n->fail_reports);
     zfree(n->slaves);
     zfree(n);
+    __A_VARIABLE = 1;
 }
 
 /* Add a node to the nodes hash table */
@@ -889,6 +927,7 @@ int clusterAddNode(clusterNode *node) {
 
     retval = dictAdd(server.cluster->nodes,
             sdsnewlen(node->name,CLUSTER_NAMELEN), node);
+    __A_VARIABLE = 1;
     return (retval == DICT_OK) ? C_OK : C_ERR;
 }
 
@@ -930,6 +969,7 @@ void clusterDelNode(clusterNode *delnode) {
 
     /* 3) Free the node, unlinking it from the cluster. */
     freeClusterNode(delnode);
+    __A_VARIABLE = 1;
 }
 
 /* Node lookup by name */
@@ -939,7 +979,11 @@ clusterNode *clusterLookupNode(const char *name) {
 
     de = dictFind(server.cluster->nodes,s);
     sdsfree(s);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return dictGetVal(de);
 }
 
@@ -958,6 +1002,7 @@ void clusterRenameNode(clusterNode *node, char *newname) {
     serverAssert(retval == DICT_OK);
     memcpy(node->name, newname, CLUSTER_NAMELEN);
     clusterAddNode(node);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -978,6 +1023,7 @@ uint64_t clusterGetMaxEpoch(void) {
     }
     dictReleaseIterator(di);
     if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
+    __A_VARIABLE = 1;
     return max;
 }
 
@@ -1078,9 +1124,15 @@ int clusterBumpConfigEpochWithoutConsensus(void) {
 void clusterHandleConfigEpochCollision(clusterNode *sender) {
     /* Prerequisites: nodes have the same configEpoch and are both masters. */
     if (sender->configEpoch != myself->configEpoch ||
-        !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
+        !nodeIsMaster(sender) || !nodeIsMaster(myself)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     /* Don't act if the colliding node has a smaller Node ID. */
-    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
+    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     /* Get the next ID available at the best of this node knowledge. */
     server.cluster->currentEpoch++;
     myself->configEpoch = server.cluster->currentEpoch;
@@ -1090,6 +1142,7 @@ void clusterHandleConfigEpochCollision(clusterNode *sender) {
         " configEpoch set to %llu",
         sender->name,
         (unsigned long long) myself->configEpoch);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -1135,6 +1188,7 @@ void clusterBlacklistCleanup(void) {
             dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Cleanup the blacklist and add a new node ID to the black list. */
@@ -1151,6 +1205,7 @@ void clusterBlacklistAddNode(clusterNode *node) {
     de = dictFind(server.cluster->nodes_black_list,id);
     dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
     sdsfree(id);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if the specified node ID exists in the blacklist.
@@ -1163,6 +1218,7 @@ int clusterBlacklistExists(char *nodeid) {
     clusterBlacklistCleanup();
     retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
     sdsfree(id);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1195,13 +1251,22 @@ void markNodeAsFailingIfNeeded(clusterNode *node) {
     int failures;
     int needed_quorum = (server.cluster->size / 2) + 1;
 
-    if (!nodeTimedOut(node)) return; /* We can reach it. */
-    if (nodeFailed(node)) return; /* Already FAILing. */
+    if (!nodeTimedOut(node)) {
+        __A_VARIABLE = 1;
+        return;
+    } /* We can reach it. */
+    if (nodeFailed(node)) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Already FAILing. */
 
     failures = clusterNodeFailureReportsCount(node);
     /* Also count myself as a voter if I'm a master. */
     if (nodeIsMaster(myself)) failures++;
-    if (failures < needed_quorum) return; /* No weak agreement from masters. */
+    if (failures < needed_quorum) {
+        __A_VARIABLE = 1;
+        return;
+    } /* No weak agreement from masters. */
 
     serverLog(LL_NOTICE,
         "Marking node %.40s as failing (quorum reached).", node->name);
@@ -1215,6 +1280,7 @@ void markNodeAsFailingIfNeeded(clusterNode *node) {
      * reachable nodes to flag the node as FAIL. */
     if (nodeIsMaster(myself)) clusterSendFail(node->name);
     clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called only if a node is marked as FAIL, but we are able
@@ -1250,6 +1316,7 @@ void clearNodeFailureIfNeeded(clusterNode *node) {
         node->flags &= ~CLUSTER_NODE_FAIL;
         clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return true if we already have a node in HANDSHAKE state matching the
@@ -1269,6 +1336,7 @@ int clusterHandshakeInProgress(char *ip, int port, int cport) {
             node->cport == cport) break;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return de != NULL;
 }
 
@@ -1437,6 +1505,7 @@ void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
         /* Next node */
         g++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* IP -> string conversion. 'buf' is supposed to at least be 46 bytes.
@@ -1449,6 +1518,7 @@ void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
     } else {
         anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Update the node address to the IP address that can be extracted
@@ -1476,11 +1546,17 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
      *
      * As a side effect this function never frees the passed 'link', so
      * it is safe to call during packet processing. */
-    if (link == node->link) return 0;
+    if (link == node->link) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     nodeIp2String(ip,link,hdr->myip);
     if (node->port == port && node->cport == cport &&
-        strcmp(ip,node->ip) == 0) return 0;
+        strcmp(ip,node->ip) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* IP / port is different, update it. */
     memcpy(node->ip,ip,sizeof(ip));
@@ -1495,6 +1571,7 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
      * replication target as well. */
     if (nodeIsSlave(myself) && myself->slaveof == node)
         replicationSetMaster(node->ip, node->port);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1502,7 +1579,10 @@ int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
  * a node that we believed to be a slave is now acting as master in order to
  * update the state of the node. */
 void clusterSetNodeAsMaster(clusterNode *n) {
-    if (nodeIsMaster(n)) return;
+    if (nodeIsMaster(n)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (n->slaveof) {
         clusterNodeRemoveSlave(n->slaveof,n);
@@ -1515,6 +1595,7 @@ void clusterSetNodeAsMaster(clusterNode *n) {
     /* Update config and state. */
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when we receive a master configuration via a
@@ -1548,6 +1629,7 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
 
     if (sender == myself) {
         serverLog(LL_WARNING,"Discarding UPDATE message about myself.");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1593,8 +1675,10 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
     /* After updating the slots configuration, don't do any actual change
      * in the state of the server if a module disabled Redis Cluster
      * keys redirections. */
-    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
+    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* If at least one slot was reassigned from a node to another node
      * with a greater configEpoch, it is possible that:
@@ -1622,6 +1706,7 @@ void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoc
         for (j = 0; j < dirty_slots_count; j++)
             delKeysInSlot(dirty_slots[j]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* When this function is called, there is a packet to process starting
@@ -2113,6 +2198,7 @@ int clusterProcessPacket(clusterLink *link) {
    completely free the node on error. */
 void handleLinkIOError(clusterLink *link) {
     freeClusterLink(link);
+    __A_VARIABLE = 1;
 }
 
 /* Send data. This is handled using a trivial send buffer that gets
@@ -2129,11 +2215,13 @@ void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         serverLog(LL_DEBUG,"I/O error writing to node link: %s",
             (nwritten == -1) ? strerror(errno) : "short write");
         handleLinkIOError(link);
+        __A_VARIABLE = 1;
         return;
     }
     sdsrange(link->sndbuf,nwritten,-1);
     if (sdslen(link->sndbuf) == 0)
         aeDeleteFileEvent(server.el, link->fd, AE_WRITABLE);
+    __A_VARIABLE = 1;
 }
 
 /* Read data. Try to read the first field of the header first to check the
@@ -2219,6 +2307,7 @@ void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
     uint16_t type = ntohs(hdr->type);
     if (type < CLUSTERMSG_TYPE_COUNT)
         server.cluster->stats_bus_messages_sent[type]++;
+    __A_VARIABLE = 1;
 }
 
 /* Send a message to all the nodes that are part of the cluster having
@@ -2241,6 +2330,7 @@ void clusterBroadcastMessage(void *buf, size_t len) {
         clusterSendMessage(node->link,buf,len);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Build the message header. hdr must point to a buffer at least
@@ -2317,6 +2407,7 @@ void clusterBuildMessageHdr(clusterMsg *hdr, int type) {
     }
     hdr->totlen = htonl(totlen);
     /* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */
+    __A_VARIABLE = 1;
 }
 
 /* Return non zero if the node is already present in the gossip section of the
@@ -2328,6 +2419,7 @@ int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {
         if (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
                 CLUSTER_NAMELEN) == 0) break;
     }
+    __A_VARIABLE = 1;
     return j != count;
 }
 
@@ -2344,6 +2436,7 @@ void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
     gossip->cport = htons(n->cport);
     gossip->flags = htons(n->flags);
     gossip->notused1 = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Send a PING or PONG packet to the specified node, making sure to add enough
@@ -2474,6 +2567,7 @@ void clusterSendPing(clusterLink *link, int type) {
     hdr->totlen = htonl(totlen);
     clusterSendMessage(link,buf,totlen);
     zfree(buf);
+    __A_VARIABLE = 1;
 }
 
 /* Send a PONG packet to every connected node that's not in handshake state
@@ -2511,6 +2605,7 @@ void clusterBroadcastPong(int target) {
         clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Send a PUBLISH message.
@@ -2555,6 +2650,7 @@ void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {
     decrRefCount(channel);
     decrRefCount(message);
     if (payload != buf) zfree(payload);
+    __A_VARIABLE = 1;
 }
 
 /* Send a FAIL message to all the nodes we are able to contact.
@@ -2569,6 +2665,7 @@ void clusterSendFail(char *nodename) {
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
     memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
     clusterBroadcastMessage(buf,ntohl(hdr->totlen));
+    __A_VARIABLE = 1;
 }
 
 /* Send an UPDATE message to the specified link carrying the specified 'node'
@@ -2578,12 +2675,16 @@ void clusterSendUpdate(clusterLink *link, clusterNode *node) {
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
 
-    if (link == NULL) return;
+    if (link == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);
     memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
     hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
     memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
     clusterSendMessage(link,buf,ntohl(hdr->totlen));
+    __A_VARIABLE = 1;
 }
 
 /* Send a MODULE message.
@@ -2620,6 +2721,7 @@ void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
         clusterBroadcastMessage(heapbuf,totlen);
 
     if (heapbuf != buf) zfree(heapbuf);
+    __A_VARIABLE = 1;
 }
 
 /* This function gets a cluster node ID string as target, the same way the nodes
@@ -2633,11 +2735,15 @@ int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uin
 
     if (target != NULL) {
         node = clusterLookupNode(target);
-        if (node == NULL || node->link == NULL) return C_ERR;
+        if (node == NULL || node->link == NULL) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     }
 
     clusterSendModule(target ? node->link : NULL,
                       module_id, type, payload, len);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2650,6 +2756,7 @@ int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uin
  * -------------------------------------------------------------------------- */
 void clusterPropagatePublish(robj *channel, robj *message) {
     clusterSendPublish(NULL, channel, message);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -2675,6 +2782,7 @@ void clusterRequestFailoverAuth(void) {
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterBroadcastMessage(buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Send a FAILOVER_AUTH_ACK message to the specified node. */
@@ -2683,11 +2791,15 @@ void clusterSendFailoverAuth(clusterNode *node) {
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
 
-    if (!node->link) return;
+    if (!node->link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK);
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterSendMessage(node->link,buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Send a MFSTART message to the specified node. */
@@ -2696,11 +2808,15 @@ void clusterSendMFStart(clusterNode *node) {
     clusterMsg *hdr = (clusterMsg*) buf;
     uint32_t totlen;
 
-    if (!node->link) return;
+    if (!node->link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_MFSTART);
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     hdr->totlen = htonl(totlen);
     clusterSendMessage(node->link,buf,totlen);
+    __A_VARIABLE = 1;
 }
 
 /* Vote for the node asking for our vote if there are the conditions. */
@@ -2716,7 +2832,10 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
      * right to vote, as the cluster size in Redis Cluster is the number
      * of masters serving at least one slot, and quorum is the cluster
      * size + 1 */
-    if (nodeIsSlave(myself) || myself->numslots == 0) return;
+    if (nodeIsSlave(myself) || myself->numslots == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Request epoch must be >= our currentEpoch.
      * Note that it is impossible for it to actually be greater since
@@ -2728,6 +2847,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
             node->name,
             (unsigned long long) requestCurrentEpoch,
             (unsigned long long) server.cluster->currentEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2737,6 +2857,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 "Failover auth denied to %.40s: already voted for epoch %llu",
                 node->name,
                 (unsigned long long) server.cluster->currentEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2759,6 +2880,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                     "Failover auth denied to %.40s: its master is up",
                     node->name);
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2773,6 +2895,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 node->name,
                 (long long) ((server.cluster_node_timeout*2)-
                              (mstime() - node->slaveof->voted_time)));
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2795,6 +2918,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
                 node->name, j,
                 (unsigned long long) server.cluster->slots[j]->configEpoch,
                 (unsigned long long) requestConfigEpoch);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2805,6 +2929,7 @@ void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
     clusterSendFailoverAuth(node);
     serverLog(LL_WARNING, "Failover auth granted to %.40s for epoch %llu",
         node->name, (unsigned long long) server.cluster->currentEpoch);
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the "rank" of this instance, a slave, in the context
@@ -2826,13 +2951,17 @@ int clusterGetSlaveRank(void) {
 
     serverAssert(nodeIsSlave(myself));
     master = myself->slaveof;
-    if (master == NULL) return 0; /* Never called by slaves without master. */
+    if (master == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Never called by slaves without master. */
 
     myoffset = replicationGetSlaveOffset();
     for (j = 0; j < master->numslaves; j++)
         if (master->slaves[j] != myself &&
             !nodeCantFailover(master->slaves[j]) &&
             master->slaves[j]->repl_offset > myoffset) rank++;
+    __A_VARIABLE = 1;
     return rank;
 }
 
@@ -2865,8 +2994,10 @@ void clusterLogCantFailover(int reason) {
 
     /* Don't log if we have the same reason for some time. */
     if (reason == server.cluster->cant_failover_reason &&
-        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
+        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     server.cluster->cant_failover_reason = reason;
 
@@ -2875,7 +3006,10 @@ void clusterLogCantFailover(int reason) {
      * a long time. */
     if (myself->slaveof &&
         nodeFailed(myself->slaveof) &&
-        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;
+        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     switch(reason) {
     case CLUSTER_CANT_FAILOVER_DATA_AGE:
@@ -2898,6 +3032,7 @@ void clusterLogCantFailover(int reason) {
     }
     lastlog_time = time(NULL);
     serverLog(LL_WARNING,"Currently unable to failover: %s", msg);
+    __A_VARIABLE = 1;
 }
 
 /* This function implements the final part of automatic and manual failovers,
@@ -2910,7 +3045,10 @@ void clusterFailoverReplaceYourMaster(void) {
     int j;
     clusterNode *oldmaster = myself->slaveof;
 
-    if (nodeIsMaster(myself) || oldmaster == NULL) return;
+    if (nodeIsMaster(myself) || oldmaster == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* 1) Turn this node into a master. */
     clusterSetNodeAsMaster(myself);
@@ -2934,6 +3072,7 @@ void clusterFailoverReplaceYourMaster(void) {
 
     /* 5) If there was a manual failover in progress, clear the state. */
     resetManualFailover();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called if we are a slave node and our master serving
@@ -2981,6 +3120,7 @@ void clusterHandleSlaveFailover(void) {
         /* There are no reasons to failover, so we set the reason why we
          * are returning without failing over to NONE. */
         server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3010,6 +3150,7 @@ void clusterHandleSlaveFailover(void) {
     {
         if (!manual_failover) {
             clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -3044,6 +3185,7 @@ void clusterHandleSlaveFailover(void) {
          * to all the other slaves so that they'll updated their offsets
          * if our offset is better. */
         clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3070,12 +3212,14 @@ void clusterHandleSlaveFailover(void) {
     /* Return ASAP if we can't still start the election. */
     if (mstime() < server.cluster->failover_auth_time) {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* Return ASAP if the election is too old to be valid. */
     if (auth_age > auth_timeout) {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3090,6 +3234,7 @@ void clusterHandleSlaveFailover(void) {
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE|
                              CLUSTER_TODO_FSYNC_CONFIG);
+        __A_VARIABLE = 1;
         return; /* Wait for replies. */
     }
 
@@ -3113,6 +3258,7 @@ void clusterHandleSlaveFailover(void) {
     } else {
         clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3149,15 +3295,24 @@ void clusterHandleSlaveMigration(int max_slaves) {
     dictEntry *de;
 
     /* Step 1: Don't migrate if the cluster state is not ok. */
-    if (server.cluster->state != CLUSTER_OK) return;
+    if (server.cluster->state != CLUSTER_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Step 2: Don't migrate if my master will not be left with at least
      *         'migration-barrier' slaves after my migration. */
-    if (mymaster == NULL) return;
+    if (mymaster == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (j = 0; j < mymaster->numslaves; j++)
         if (!nodeFailed(mymaster->slaves[j]) &&
             !nodeTimedOut(mymaster->slaves[j])) okslaves++;
-    if (okslaves <= server.cluster_migration_barrier) return;
+    if (okslaves <= server.cluster_migration_barrier) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Step 3: Identify a candidate for migration, and check if among the
      * masters with the greatest number of ok slaves, I'm the one with the
@@ -3225,6 +3380,7 @@ void clusterHandleSlaveMigration(int max_slaves) {
             target->name);
         clusterSetMaster(target);
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3270,6 +3426,7 @@ void resetManualFailover(void) {
     server.cluster->mf_can_start = 0;
     server.cluster->mf_slave = NULL;
     server.cluster->mf_master_offset = 0;
+    __A_VARIABLE = 1;
 }
 
 /* If a manual failover timed out, abort it. */
@@ -3278,19 +3435,29 @@ void manualFailoverCheckTimeout(void) {
         serverLog(LL_WARNING,"Manual failover timed out.");
         resetManualFailover();
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called from the cluster cron function in order to go
  * forward with a manual failover state machine. */
 void clusterHandleManualFailover(void) {
     /* Return ASAP if no manual failover is in progress. */
-    if (server.cluster->mf_end == 0) return;
+    if (server.cluster->mf_end == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If mf_can_start is non-zero, the failover was already triggered so the
      * next steps are performed by clusterHandleSlaveFailover(). */
-    if (server.cluster->mf_can_start) return;
+    if (server.cluster->mf_can_start) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
-    if (server.cluster->mf_master_offset == 0) return; /* Wait for offset... */
+    if (server.cluster->mf_master_offset == 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Wait for offset... */
 
     if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
         /* Our replication offset matches the master replication offset
@@ -3300,6 +3467,7 @@ void clusterHandleManualFailover(void) {
             "All master replication stream processed, "
             "manual failover can start.");
     }
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3585,6 +3753,7 @@ void clusterCron(void) {
 
     if (update_state || server.cluster->state == CLUSTER_FAIL)
         clusterUpdateState();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called before the event handler returns to sleep for
@@ -3612,10 +3781,12 @@ void clusterBeforeSleep(void) {
     /* Reset our flags (not strictly needed since every single function
      * called for flags set should be able to clear its flag). */
     server.cluster->todo_before_sleep = 0;
+    __A_VARIABLE = 1;
 }
 
 void clusterDoBeforeSleep(int flags) {
     server.cluster->todo_before_sleep |= flags;
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3627,6 +3798,7 @@ void clusterDoBeforeSleep(int flags) {
 int bitmapTestBit(unsigned char *bitmap, int pos) {
     off_t byte = pos/8;
     int bit = pos&7;
+    __A_VARIABLE = 1;
     return (bitmap[byte] & (1<<bit)) != 0;
 }
 
@@ -3635,6 +3807,7 @@ void bitmapSetBit(unsigned char *bitmap, int pos) {
     off_t byte = pos/8;
     int bit = pos&7;
     bitmap[byte] |= 1<<bit;
+    __A_VARIABLE = 1;
 }
 
 /* Clear the bit at position 'pos' in a bitmap. */
@@ -3642,6 +3815,7 @@ void bitmapClearBit(unsigned char *bitmap, int pos) {
     off_t byte = pos/8;
     int bit = pos&7;
     bitmap[byte] &= ~(1<<bit);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if there is at least one master with slaves in the cluster.
@@ -3658,6 +3832,7 @@ int clusterMastersHaveSlaves(void) {
         slaves += node->numslaves;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return slaves != 0;
 }
 
@@ -3683,6 +3858,7 @@ int clusterNodeSetSlotBit(clusterNode *n, int slot) {
         if (n->numslots == 1 && clusterMastersHaveSlaves())
             n->flags |= CLUSTER_NODE_MIGRATE_TO;
     }
+    __A_VARIABLE = 1;
     return old;
 }
 
@@ -3691,11 +3867,13 @@ int clusterNodeClearSlotBit(clusterNode *n, int slot) {
     int old = bitmapTestBit(n->slots,slot);
     bitmapClearBit(n->slots,slot);
     if (old) n->numslots--;
+    __A_VARIABLE = 1;
     return old;
 }
 
 /* Return the slot bit from the cluster node structure. */
 int clusterNodeGetSlotBit(clusterNode *n, int slot) {
+    __A_VARIABLE = 1;
     return bitmapTestBit(n->slots,slot);
 }
 
@@ -3704,9 +3882,13 @@ int clusterNodeGetSlotBit(clusterNode *n, int slot) {
  * If the slot is already assigned to another instance this is considered
  * an error and C_ERR is returned. */
 int clusterAddSlot(clusterNode *n, int slot) {
-    if (server.cluster->slots[slot]) return C_ERR;
+    if (server.cluster->slots[slot]) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     clusterNodeSetSlotBit(n,slot);
     server.cluster->slots[slot] = n;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3716,9 +3898,13 @@ int clusterAddSlot(clusterNode *n, int slot) {
 int clusterDelSlot(int slot) {
     clusterNode *n = server.cluster->slots[slot];
 
-    if (!n) return C_ERR;
+    if (!n) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
     server.cluster->slots[slot] = NULL;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3733,6 +3919,7 @@ int clusterDelNodeSlots(clusterNode *node) {
             deleted++;
         }
     }
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -3743,6 +3930,7 @@ void clusterCloseAllSlots(void) {
         sizeof(server.cluster->migrating_slots_to));
     memset(server.cluster->importing_slots_from,0,
         sizeof(server.cluster->importing_slots_from));
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3774,7 +3962,10 @@ void clusterUpdateState(void) {
     if (first_call_time == 0) first_call_time = mstime();
     if (nodeIsMaster(myself) &&
         server.cluster->state == CLUSTER_FAIL &&
-        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;
+        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Start assuming the state is OK. We'll turn it into FAIL if there
      * are the right conditions. */
@@ -3843,6 +4034,7 @@ void clusterUpdateState(void) {
             nodeIsMaster(myself) &&
             mstime() - among_minority_time < rejoin_delay)
         {
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -3851,6 +4043,7 @@ void clusterUpdateState(void) {
             new_state == CLUSTER_OK ? "ok" : "fail");
         server.cluster->state = new_state;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called after the node startup in order to verify that data
@@ -3881,16 +4074,24 @@ int verifyClusterConfigWithData(void) {
 
     /* Return ASAP if a module disabled cluster redirections. In that case
      * every master can store keys about every possible hash slot. */
-    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
+    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION) {
+        __A_VARIABLE = 1;
         return C_OK;
+    }
 
     /* If this node is a slave, don't perform the check at all as we
      * completely depend on the replication stream. */
-    if (nodeIsSlave(myself)) return C_OK;
+    if (nodeIsSlave(myself)) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Make sure we only have keys in DB0. */
     for (j = 1; j < server.dbnum; j++) {
-        if (dictSize(server.db[j].dict)) return C_ERR;
+        if (dictSize(server.db[j].dict)) {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
     }
 
     /* Check that all the slots we see populated memory have a corresponding
@@ -3921,6 +4122,7 @@ int verifyClusterConfigWithData(void) {
         }
     }
     if (update_config) clusterSaveConfigOrDie(1);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3946,6 +4148,7 @@ void clusterSetMaster(clusterNode *n) {
     clusterNodeAddSlave(n,myself);
     replicationSetMaster(n->ip, n->port);
     resetManualFailover();
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -3980,6 +4183,7 @@ sds representClusterNodeFlags(sds ci, uint16_t flags) {
     /* If no flag was added, add the "noflags" special flag. */
     if (sdslen(ci) == orig_len) ci = sdscat(ci,"noflags,");
     sdsIncrLen(ci,-1); /* Remove trailing comma. */
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -4049,6 +4253,7 @@ sds clusterGenNodeDescription(clusterNode *node) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -4080,6 +4285,7 @@ sds clusterGenNodesDescription(int filter) {
         ci = sdscatlen(ci,"\n",1);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return ci;
 }
 
@@ -4089,17 +4295,28 @@ sds clusterGenNodesDescription(int filter) {
 
 const char *clusterGetMessageTypeString(int type) {
     switch(type) {
-    case CLUSTERMSG_TYPE_PING: return "ping";
-    case CLUSTERMSG_TYPE_PONG: return "pong";
-    case CLUSTERMSG_TYPE_MEET: return "meet";
-    case CLUSTERMSG_TYPE_FAIL: return "fail";
-    case CLUSTERMSG_TYPE_PUBLISH: return "publish";
-    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return "auth-req";
-    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return "auth-ack";
-    case CLUSTERMSG_TYPE_UPDATE: return "update";
-    case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
-    case CLUSTERMSG_TYPE_MODULE: return "module";
-    }
+    case CLUSTERMSG_TYPE_PING: __A_VARIABLE = 1;
+        return "ping";
+    case CLUSTERMSG_TYPE_PONG: __A_VARIABLE = 1;
+        return "pong";
+    case CLUSTERMSG_TYPE_MEET: __A_VARIABLE = 1;
+        return "meet";
+    case CLUSTERMSG_TYPE_FAIL: __A_VARIABLE = 1;
+        return "fail";
+    case CLUSTERMSG_TYPE_PUBLISH: __A_VARIABLE = 1;
+        return "publish";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: __A_VARIABLE = 1;
+        return "auth-req";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: __A_VARIABLE = 1;
+        return "auth-ack";
+    case CLUSTERMSG_TYPE_UPDATE: __A_VARIABLE = 1;
+        return "update";
+    case CLUSTERMSG_TYPE_MFSTART: __A_VARIABLE = 1;
+        return "mfstart";
+    case CLUSTERMSG_TYPE_MODULE: __A_VARIABLE = 1;
+        return "module";
+    }
+    __A_VARIABLE = 1;
     return "unknown";
 }
 
@@ -4110,8 +4327,10 @@ int getSlotOrReply(client *c, robj *o) {
         slot < 0 || slot >= CLUSTER_SLOTS)
     {
         addReplyError(c,"Invalid or out of range slot");
+        __A_VARIABLE = 1;
         return -1;
     }
+    __A_VARIABLE = 1;
     return (int) slot;
 }
 
@@ -4187,6 +4406,7 @@ void clusterReplyMultiBulkSlots(client *c) {
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c, slot_replylen, num_masters);
+    __A_VARIABLE = 1;
 }
 
 void clusterCommand(client *c) {
@@ -4804,6 +5024,7 @@ void createDumpPayload(rio *payload, robj *o, robj *key) {
                 sdslen(payload->io.buffer.ptr));
     memrev64ifbe(&crc);
     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
+    __A_VARIABLE = 1;
 }
 
 /* Verify that the RDB version of the dump payload matches the one of this Redis
@@ -4816,16 +5037,23 @@ int verifyDumpPayload(unsigned char *p, size_t len) {
     uint64_t crc;
 
     /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
-    if (len < 10) return C_ERR;
+    if (len < 10) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     footer = p+(len-10);
 
     /* Verify RDB version */
     rdbver = (footer[1] << 8) | footer[0];
-    if (rdbver > RDB_VERSION) return C_ERR;
+    if (rdbver > RDB_VERSION) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Verify CRC64 */
     crc = crc64(0,p,len-8);
     memrev64ifbe(&crc);
+    __A_VARIABLE = 1;
     return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
 }
 
@@ -4839,6 +5067,7 @@ void dumpCommand(client *c) {
     /* Check if the key is here. */
     if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
         addReply(c,shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -4849,6 +5078,7 @@ void dumpCommand(client *c) {
     dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);
     addReplyBulk(c,dumpobj);
     decrRefCount(dumpobj);
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -4976,6 +5206,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
     if (cs) {
         sdsfree(name);
         cs->last_use_time = server.unixtime;
+        __A_VARIABLE = 1;
         return cs;
     }
 
@@ -4996,6 +5227,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
         sdsfree(name);
         addReplyErrorFormat(c,"Can't connect to target node: %s",
             server.neterr);
+        __A_VARIABLE = 1;
         return NULL;
     }
     anetEnableTcpNoDelay(server.neterr,fd);
@@ -5006,6 +5238,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
         addReplySds(c,
             sdsnew("-IOERR error or timeout connecting to the client\r\n"));
         close(fd);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -5015,6 +5248,7 @@ migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long ti
     cs->last_dbid = -1;
     cs->last_use_time = server.unixtime;
     dictAdd(server.migrate_cached_sockets,name,cs);
+    __A_VARIABLE = 1;
     return cs;
 }
 
@@ -5029,6 +5263,7 @@ void migrateCloseSocket(robj *host, robj *port) {
     cs = dictFetchValue(server.migrate_cached_sockets,name);
     if (!cs) {
         sdsfree(name);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -5036,6 +5271,7 @@ void migrateCloseSocket(robj *host, robj *port) {
     zfree(cs);
     dictDelete(server.migrate_cached_sockets,name);
     sdsfree(name);
+    __A_VARIABLE = 1;
 }
 
 void migrateCloseTimedoutSockets(void) {
@@ -5052,6 +5288,7 @@ void migrateCloseTimedoutSockets(void) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* MIGRATE host port key dbid timeout [COPY | REPLACE | AUTH password]
@@ -5394,10 +5631,12 @@ socket_err:
 void askingCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_ASKING;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* The READONLY command is used by clients to enter the read-only mode.
@@ -5406,16 +5645,19 @@ void askingCommand(client *c) {
 void readonlyCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_READONLY;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* The READWRITE command just clears the READONLY command state. */
 void readwriteCommand(client *c) {
     c->flags &= ~CLIENT_READONLY;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* Return the pointer to the cluster node that is able to serve the command.
@@ -5651,6 +5893,7 @@ void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_co
     } else {
         serverPanic("getNodeByQuery() unknown error.");
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by the function processing clients incrementally
@@ -5676,6 +5919,7 @@ int clusterRedirectBlockedClientIfNeeded(client *c) {
         /* If the cluster is down, unblock the client with the right error. */
         if (server.cluster->state == CLUSTER_FAIL) {
             clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
+            __A_VARIABLE = 1;
             return 1;
         }
 
@@ -5700,10 +5944,12 @@ int clusterRedirectBlockedClientIfNeeded(client *c) {
                         CLUSTER_REDIR_MOVED);
                 }
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return 1;
             }
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/src/config.c b/src/config.c
index ba8e17e..5542003 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Configuration file parsing and CONFIG GET/SET commands implementation.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -105,18 +106,26 @@ clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
 /* Get enum value from name. If there is no match INT_MIN is returned. */
 int configEnumGetValue(configEnum *ce, char *name) {
     while(ce->name != NULL) {
-        if (!strcasecmp(ce->name,name)) return ce->val;
+        if (!strcasecmp(ce->name,name)) {
+            __A_VARIABLE = 1;
+            return ce->val;
+        }
         ce++;
     }
+    __A_VARIABLE = 1;
     return INT_MIN;
 }
 
 /* Get enum name from value. If no match is found NULL is returned. */
 const char *configEnumGetName(configEnum *ce, int val) {
     while(ce->name != NULL) {
-        if (ce->val == val) return ce->name;
+        if (ce->val == val) {
+            __A_VARIABLE = 1;
+            return ce->name;
+        }
         ce++;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -124,11 +133,13 @@ const char *configEnumGetName(configEnum *ce, int val) {
  * there is no match. */
 const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
     const char *name = configEnumGetName(ce,val);
+    __A_VARIABLE = 1;
     return name ? name : "unknown";
 }
 
 /* Used for INFO generation. */
 const char *evictPolicyToString(void) {
+    __A_VARIABLE = 1;
     return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
 }
 
@@ -147,12 +158,14 @@ void appendServerSaveParams(time_t seconds, int changes) {
     server.saveparams[server.saveparamslen].seconds = seconds;
     server.saveparams[server.saveparamslen].changes = changes;
     server.saveparamslen++;
+    __A_VARIABLE = 1;
 }
 
 void resetServerSaveParams(void) {
     zfree(server.saveparams);
     server.saveparams = NULL;
     server.saveparamslen = 0;
+    __A_VARIABLE = 1;
 }
 
 void queueLoadModule(sds path, sds *argv, int argc) {
@@ -167,6 +180,7 @@ void queueLoadModule(sds path, sds *argv, int argc) {
         loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
     }
     listAddNodeTail(server.loadmodule_queue,loadmod);
+    __A_VARIABLE = 1;
 }
 
 void loadServerConfigFromString(char *config) {
@@ -814,6 +828,7 @@ void loadServerConfigFromString(char *config) {
     }
 
     sdsfreesplitres(lines,totlines);
+    __A_VARIABLE = 1;
     return;
 
 loaderr:
@@ -822,6 +837,7 @@ loaderr:
     fprintf(stderr, ">>> '%s'\n", lines[i]);
     fprintf(stderr, "%s\n", err);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Load the server configuration from the specified filename.
@@ -859,6 +875,7 @@ void loadServerConfig(char *filename, char *options) {
     }
     loadServerConfigFromString(config);
     sdsfree(config);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -1572,6 +1589,7 @@ void configGetCommand(client *c) {
         matches++;
     }
     setDeferredMultiBulkLength(c,replylen,matches*2);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -1624,6 +1642,7 @@ struct rewriteConfigState {
 void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
     state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
     state->lines[state->numlines++] = line;
+    __A_VARIABLE = 1;
 }
 
 /* Populate the option -> list of line numbers map. */
@@ -1635,6 +1654,7 @@ void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds op
         dictAdd(state->option_to_line,sdsdup(option),l);
     }
     listAddNodeTail(l,(void*)(long)linenum);
+    __A_VARIABLE = 1;
 }
 
 /* Add the specified option to the set of processed options.
@@ -1645,6 +1665,7 @@ void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *
     sds opt = sdsnew(option);
 
     if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
+    __A_VARIABLE = 1;
 }
 
 /* Read the old file, split it into lines to populate a newly created
@@ -1654,7 +1675,10 @@ void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *
  * If the old file does not exist at all, an empty state is returned. */
 struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
     FILE *fp = fopen(path,"r");
-    if (fp == NULL && errno != ENOENT) return NULL;
+    if (fp == NULL && errno != ENOENT) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     char buf[CONFIG_MAX_LINE+1];
     int linenum = -1;
@@ -1664,7 +1688,10 @@ struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
     state->numlines = 0;
     state->lines = NULL;
     state->has_tail = 0;
-    if (fp == NULL) return state;
+    if (fp == NULL) {
+        __A_VARIABLE = 1;
+        return state;
+    }
 
     /* Read the old file line by line, populate the state. */
     while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
@@ -1717,6 +1744,7 @@ struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
         sdsfreesplitres(argv,argc);
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return state;
 }
 
@@ -1746,6 +1774,7 @@ void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *opti
         /* Option not used previously, and we are not forced to use it. */
         sdsfree(line);
         sdsfree(o);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1769,6 +1798,7 @@ void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *opti
         rewriteConfigAppendLine(state,line);
     }
     sdsfree(o);
+    __A_VARIABLE = 1;
 }
 
 /* Write the long long 'bytes' value as a string in a way that is parsable
@@ -1798,6 +1828,7 @@ void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, lo
     rewriteConfigFormatMemory(buf,sizeof(buf),value);
     line = sdscatprintf(sdsempty(),"%s %s",option,buf);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a yes/no option. */
@@ -1807,6 +1838,7 @@ void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, in
         value ? "yes" : "no");
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a string option. */
@@ -1818,6 +1850,7 @@ void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, c
      * configuration file to be set to NULL again at the next reboot. */
     if (value == NULL) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1829,6 +1862,7 @@ void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, c
     line = sdscatrepr(line, value, strlen(value));
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a numerical (long long range) option. */
@@ -1837,6 +1871,7 @@ void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option
     sds line = sdscatprintf(sdsempty(),"%s %lld",option,value);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a octal option. */
@@ -1845,6 +1880,7 @@ void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, in
     sds line = sdscatprintf(sdsempty(),"%s %o",option,value);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite an enumeration option. It takes as usually state and option name,
@@ -1857,6 +1893,7 @@ void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int
 
     line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the syslog-facility option. */
@@ -1869,6 +1906,7 @@ void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
     name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
     line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the save option. */
@@ -1886,6 +1924,7 @@ void rewriteConfigSaveOption(struct rewriteConfigState *state) {
     }
     /* Mark "save" as processed in case server.saveparamslen is zero. */
     rewriteConfigMarkAsProcessed(state,"save");
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the dir option, always using absolute paths.*/
@@ -1894,9 +1933,11 @@ void rewriteConfigDirOption(struct rewriteConfigState *state) {
 
     if (getcwd(cwd,sizeof(cwd)) == NULL) {
         rewriteConfigMarkAsProcessed(state,"dir");
+        __A_VARIABLE = 1;
         return; /* no rewrite on error. */
     }
     rewriteConfigStringOption(state,"dir",cwd,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the slaveof option. */
@@ -1908,11 +1949,13 @@ void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option)
      * we don't want a slaveof directive inside redis.conf. */
     if (server.cluster_enabled || server.masterhost == NULL) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
     line = sdscatprintf(sdsempty(),"%s %s %d", option,
         server.masterhost, server.masterport);
     rewriteConfigRewriteLine(state,option,line,1);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the notify-keyspace-events option. */
@@ -1927,6 +1970,7 @@ void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
     line = sdscatrepr(line, flags, sdslen(flags));
     sdsfree(flags);
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the client-output-buffer-limit option. */
@@ -1956,6 +2000,7 @@ void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state
                 (long) server.client_obuf_limits[j].soft_limit_seconds);
         rewriteConfigRewriteLine(state,option,line,force);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the bind option. */
@@ -1967,6 +2012,7 @@ void rewriteConfigBindOption(struct rewriteConfigState *state) {
     /* Nothing to rewrite if we don't have bind addresses. */
     if (server.bindaddr_count == 0) {
         rewriteConfigMarkAsProcessed(state,option);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1978,6 +2024,7 @@ void rewriteConfigBindOption(struct rewriteConfigState *state) {
     sdsfree(addresses);
 
     rewriteConfigRewriteLine(state,option,line,force);
+    __A_VARIABLE = 1;
 }
 
 /* Glue together the configuration lines in the current configuration
@@ -1997,6 +2044,7 @@ sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
         content = sdscatsds(content,state->lines[j]);
         content = sdscatlen(content,"\n",1);
     }
+    __A_VARIABLE = 1;
     return content;
 }
 
@@ -2006,6 +2054,7 @@ void rewriteConfigReleaseState(struct rewriteConfigState *state) {
     dictRelease(state->option_to_line);
     dictRelease(state->rewritten);
     zfree(state);
+    __A_VARIABLE = 1;
 }
 
 /* At the end of the rewrite process the state contains the remaining
@@ -2041,6 +2090,7 @@ void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function overwrites the old configuration file with the new content.
@@ -2064,9 +2114,13 @@ int rewriteConfigOverwriteFile(char *configfile, sds content) {
 
     /* 1) Open the old file (or create a new one if it does not
      *    exist), get the size. */
-    if (fd == -1) return -1; /* errno set by open(). */
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* errno set by open(). */
     if (fstat(fd,&sb) == -1) {
         close(fd);
+        __A_VARIABLE = 1;
         return -1; /* errno set by fstat(). */
     }
 
@@ -2097,6 +2151,7 @@ int rewriteConfigOverwriteFile(char *configfile, sds content) {
 cleanup:
     sdsfree(content_padded);
     close(fd);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -2114,7 +2169,10 @@ int rewriteConfig(char *path) {
     int retval;
 
     /* Step 1: read the old config into our rewrite state. */
-    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
+    if ((state = rewriteConfigReadOldFile(path)) == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Step 2: rewrite every single option, replacing or appending it inside
      * the rewrite state. */
@@ -2234,6 +2292,7 @@ int rewriteConfig(char *path) {
 
     sdsfree(newcontent);
     rewriteConfigReleaseState(state);
+    __A_VARIABLE = 1;
     return retval;
 }
 
diff --git a/src/crc16.c b/src/crc16.c
index 7b8c1da..ff3a3c0 100644
--- a/src/crc16.c
+++ b/src/crc16.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "server.h"
 
 /*
@@ -84,5 +85,6 @@ uint16_t crc16(const char *buf, int len) {
     uint16_t crc = 0;
     for (counter = 0; counter < len; counter++)
             crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
+    __A_VARIABLE = 1;
     return crc;
 }
diff --git a/src/crc64.c b/src/crc64.c
index f1f7649..49766b2 100644
--- a/src/crc64.c
+++ b/src/crc64.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis uses the CRC64 variant with "Jones" coefficients and init value of 0.
  *
  * Specification of this CRC64 variant follows:
@@ -177,6 +178,7 @@ uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
         uint8_t byte = s[j];
         crc = crc64_tab[(uint8_t)crc ^ byte] ^ (crc >> 8);
     }
+    __A_VARIABLE = 1;
     return crc;
 }
 
@@ -190,6 +192,7 @@ int crc64Test(int argc, char *argv[]) {
     UNUSED(argv);
     printf("e9c6d914c4b8d9ca == %016llx\n",
         (unsigned long long) crc64(0,(unsigned char*)"123456789",9));
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/db.c b/src/db.c
index 62c8aa1..3558cc8 100644
--- a/src/db.c
+++ b/src/db.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -47,6 +48,7 @@ void updateLFU(robj *val) {
     unsigned long counter = LFUDecrAndReturn(val);
     counter = LFULogIncr(counter);
     val->lru = (LFUGetTimeInMinutes()<<8) | counter;
+    __A_VARIABLE = 1;
 }
 
 /* Low level key lookup API, not actually called directly from commands
@@ -106,6 +108,7 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
          * to return NULL ASAP. */
         if (server.masterhost == NULL) {
             server.stat_keyspace_misses++;
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -127,6 +130,7 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
             server.current_client->cmd->flags & CMD_READONLY)
         {
             server.stat_keyspace_misses++;
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -135,12 +139,14 @@ robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
         server.stat_keyspace_misses++;
     else
         server.stat_keyspace_hits++;
+    __A_VARIABLE = 1;
     return val;
 }
 
 /* Like lookupKeyReadWithFlags(), but does not use any flag, which is the
  * common case. */
 robj *lookupKeyRead(redisDb *db, robj *key) {
+    __A_VARIABLE = 1;
     return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
 }
 
@@ -151,18 +157,21 @@ robj *lookupKeyRead(redisDb *db, robj *key) {
  * does not exist in the specified DB. */
 robj *lookupKeyWrite(redisDb *db, robj *key) {
     expireIfNeeded(db,key);
+    __A_VARIABLE = 1;
     return lookupKey(db,key,LOOKUP_NONE);
 }
 
 robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
     robj *o = lookupKeyRead(c->db, key);
     if (!o) addReply(c,reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
 robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
     robj *o = lookupKeyWrite(c->db, key);
     if (!o) addReply(c,reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -179,6 +188,7 @@ void dbAdd(redisDb *db, robj *key, robj *val) {
         val->type == OBJ_ZSET)
         signalKeyAsReady(db, key);
     if (server.cluster_enabled) slotToKeyAdd(key);
+    __A_VARIABLE = 1;
 }
 
 /* Overwrite an existing key with a new value. Incrementing the reference
@@ -203,6 +213,7 @@ void dbOverwrite(redisDb *db, robj *key, robj *val) {
     }
 
     dictFreeVal(db->dict, &auxentry);
+    __A_VARIABLE = 1;
 }
 
 /* High level Set operation. This function can be used in order to set
@@ -222,9 +233,11 @@ void setKey(redisDb *db, robj *key, robj *val) {
     incrRefCount(val);
     removeExpire(db,key);
     signalModifiedKey(db,key);
+    __A_VARIABLE = 1;
 }
 
 int dbExists(redisDb *db, robj *key) {
+    __A_VARIABLE = 1;
     return dictFind(db->dict,key->ptr) != NULL;
 }
 
@@ -242,7 +255,10 @@ robj *dbRandomKey(redisDb *db) {
         robj *keyobj;
 
         de = dictGetRandomKey(db->dict);
-        if (de == NULL) return NULL;
+        if (de == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
 
         key = dictGetKey(de);
         keyobj = createStringObject(key,sdslen(key));
@@ -256,6 +272,7 @@ robj *dbRandomKey(redisDb *db) {
                  * To prevent the infinite loop we do some tries, but if there
                  * are the conditions for an infinite loop, eventually we
                  * return a key name that may be already expired. */
+                __A_VARIABLE = 1;
                 return keyobj;
             }
             if (expireIfNeeded(db,keyobj)) {
@@ -263,8 +280,10 @@ robj *dbRandomKey(redisDb *db) {
                 continue; /* search for another key. This expired. */
             }
         }
+        __A_VARIABLE = 1;
         return keyobj;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Delete a key, value, and associated expiration entry if any, from the DB */
@@ -283,6 +302,7 @@ int dbSyncDelete(redisDb *db, robj *key) {
 /* This is a wrapper whose behavior depends on the Redis lazy free
  * configuration. Deletes the key synchronously or asynchronously. */
 int dbDelete(redisDb *db, robj *key) {
+    __A_VARIABLE = 1;
     return server.lazyfree_lazy_server_del ? dbAsyncDelete(db,key) :
                                              dbSyncDelete(db,key);
 }
@@ -322,6 +342,7 @@ robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
         decrRefCount(decoded);
         dbOverwrite(db,key,o);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -345,6 +366,7 @@ long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
 
     if (dbnum < -1 || dbnum >= server.dbnum) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return -1;
     }
 
@@ -373,13 +395,17 @@ long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
         }
     }
     if (dbnum == -1) flushSlaveKeysWithExpireList();
+    __A_VARIABLE = 1;
     return removed;
 }
 
 int selectDb(client *c, int id) {
-    if (id < 0 || id >= server.dbnum)
+    if (id < 0 || id >= server.dbnum) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
     c->db = &server.db[id];
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -394,10 +420,12 @@ int selectDb(client *c, int id) {
 
 void signalModifiedKey(redisDb *db, robj *key) {
     touchWatchedKey(db,key);
+    __A_VARIABLE = 1;
 }
 
 void signalFlushedDb(int dbid) {
     touchWatchedKeysOnFlush(dbid);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -432,10 +460,14 @@ int getFlushCommandFlags(client *c, int *flags) {
 void flushdbCommand(client *c) {
     int flags;
 
-    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
+    if (getFlushCommandFlags(c,&flags) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     signalFlushedDb(c->db->id);
     server.dirty += emptyDb(c->db->id,flags,NULL);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* FLUSHALL [ASYNC]
@@ -444,7 +476,10 @@ void flushdbCommand(client *c) {
 void flushallCommand(client *c) {
     int flags;
 
-    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
+    if (getFlushCommandFlags(c,&flags) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     signalFlushedDb(-1);
     server.dirty += emptyDb(-1,flags,NULL);
     addReply(c,shared.ok);
@@ -462,6 +497,7 @@ void flushallCommand(client *c) {
         server.dirty = saved_dirty;
     }
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 /* This command implements DEL and LAZYDEL. */
@@ -481,14 +517,17 @@ void delGenericCommand(client *c, int lazy) {
         }
     }
     addReplyLongLong(c,numdel);
+    __A_VARIABLE = 1;
 }
 
 void delCommand(client *c) {
     delGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void unlinkCommand(client *c) {
     delGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* EXISTS key1 key2 ... key_N.
@@ -501,17 +540,21 @@ void existsCommand(client *c) {
         if (lookupKeyRead(c->db,c->argv[j])) count++;
     }
     addReplyLongLong(c,count);
+    __A_VARIABLE = 1;
 }
 
 void selectCommand(client *c) {
     long id;
 
     if (getLongFromObjectOrReply(c, c->argv[1], &id,
-        "invalid DB index") != C_OK)
+        "invalid DB index") != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (server.cluster_enabled && id != 0) {
         addReplyError(c,"SELECT is not allowed in cluster mode");
+        __A_VARIABLE = 1;
         return;
     }
     if (selectDb(c,id) == C_ERR) {
@@ -519,6 +562,7 @@ void selectCommand(client *c) {
     } else {
         addReply(c,shared.ok);
     }
+    __A_VARIABLE = 1;
 }
 
 void randomkeyCommand(client *c) {
@@ -526,11 +570,13 @@ void randomkeyCommand(client *c) {
 
     if ((key = dbRandomKey(c->db)) == NULL) {
         addReply(c,shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
     addReplyBulk(c,key);
     decrRefCount(key);
+    __A_VARIABLE = 1;
 }
 
 void keysCommand(client *c) {
@@ -558,6 +604,7 @@ void keysCommand(client *c) {
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c,replylen,numkeys);
+    __A_VARIABLE = 1;
 }
 
 /* This callback is used by scanGenericCommand in order to collect elements
@@ -589,6 +636,7 @@ void scanCallback(void *privdata, const dictEntry *de) {
 
     listAddNodeTail(keys, key);
     if (val) listAddNodeTail(keys, val);
+    __A_VARIABLE = 1;
 }
 
 /* Try to parse a SCAN cursor stored at object 'o':
@@ -605,8 +653,10 @@ int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
     if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
     {
         addReplyError(c, "invalid cursor");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -796,21 +846,28 @@ void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
 cleanup:
     listSetFreeMethod(keys,decrRefCountVoid);
     listRelease(keys);
+    __A_VARIABLE = 1;
 }
 
 /* The SCAN command completely relies on scanGenericCommand. */
 void scanCommand(client *c) {
     unsigned long cursor;
-    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     scanGenericCommand(c,NULL,cursor);
+    __A_VARIABLE = 1;
 }
 
 void dbsizeCommand(client *c) {
     addReplyLongLong(c,dictSize(c->db->dict));
+    __A_VARIABLE = 1;
 }
 
 void lastsaveCommand(client *c) {
     addReplyLongLong(c,server.lastsave);
+    __A_VARIABLE = 1;
 }
 
 void typeCommand(client *c) {
@@ -836,6 +893,7 @@ void typeCommand(client *c) {
         }
     }
     addReplyStatus(c,type);
+    __A_VARIABLE = 1;
 }
 
 void shutdownCommand(client *c) {
@@ -875,11 +933,14 @@ void renameGenericCommand(client *c, int nx) {
      * if the key exists, however we still return an error on unexisting key. */
     if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
 
-    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
+    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (samekey) {
         addReply(c,nx ? shared.czero : shared.ok);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -889,6 +950,7 @@ void renameGenericCommand(client *c, int nx) {
         if (nx) {
             decrRefCount(o);
             addReply(c,shared.czero);
+            __A_VARIABLE = 1;
             return;
         }
         /* Overwrite: delete the old key before creating the new one
@@ -906,14 +968,17 @@ void renameGenericCommand(client *c, int nx) {
         c->argv[2],c->db->id);
     server.dirty++;
     addReply(c,nx ? shared.cone : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void renameCommand(client *c) {
     renameGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void renamenxCommand(client *c) {
     renameGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void moveCommand(client *c) {
@@ -924,6 +989,7 @@ void moveCommand(client *c) {
 
     if (server.cluster_enabled) {
         addReplyError(c,"MOVE is not allowed in cluster mode");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -936,6 +1002,7 @@ void moveCommand(client *c) {
         selectDb(c,dbid) == C_ERR)
     {
         addReply(c,shared.outofrangeerr);
+        __A_VARIABLE = 1;
         return;
     }
     dst = c->db;
@@ -945,6 +1012,7 @@ void moveCommand(client *c) {
      * DB as the source DB it is probably an error. */
     if (src == dst) {
         addReply(c,shared.sameobjecterr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -952,6 +1020,7 @@ void moveCommand(client *c) {
     o = lookupKeyWrite(c->db,c->argv[1]);
     if (!o) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     expire = getExpire(c->db,c->argv[1]);
@@ -959,6 +1028,7 @@ void moveCommand(client *c) {
     /* Return zero if the key already exists in the target DB */
     if (lookupKeyWrite(dst,c->argv[1]) != NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     dbAdd(dst,c->argv[1],o);
@@ -969,6 +1039,7 @@ void moveCommand(client *c) {
     dbDelete(src,c->argv[1]);
     server.dirty++;
     addReply(c,shared.cone);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for dbSwapDatabases(): scans the list of keys that have
@@ -987,6 +1058,7 @@ void scanDatabaseForReadyLists(redisDb *db) {
             signalKeyAsReady(db, key);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Swap two databases at runtime so that all clients will magically see
@@ -999,8 +1071,14 @@ void scanDatabaseForReadyLists(redisDb *db) {
  * C_OK is returned. */
 int dbSwapDatabases(int id1, int id2) {
     if (id1 < 0 || id1 >= server.dbnum ||
-        id2 < 0 || id2 >= server.dbnum) return C_ERR;
-    if (id1 == id2) return C_OK;
+        id2 < 0 || id2 >= server.dbnum) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    }
+    if (id1 == id2) {
+    	__A_VARIABLE = 1;
+    	return C_OK;
+    }
     redisDb aux = server.db[id1];
     redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
 
@@ -1026,6 +1104,7 @@ int dbSwapDatabases(int id1, int id2) {
      * if needed. */
     scanDatabaseForReadyLists(db1);
     scanDatabaseForReadyLists(db2);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1066,6 +1145,7 @@ int removeExpire(redisDb *db, robj *key) {
     /* An expire may only be removed if there is a corresponding entry in the
      * main dict. Otherwise, the key will never be freed. */
     serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    __A_VARIABLE = 1;
     return dictDelete(db->expires,key->ptr) == DICT_OK;
 }
 
@@ -1085,6 +1165,7 @@ void setExpire(client *c, redisDb *db, robj *key, long long when) {
     int writable_slave = server.masterhost && server.repl_slave_ro == 0;
     if (c && writable_slave && !(c->flags & CLIENT_MASTER))
         rememberSlaveKeyWithExpire(db,key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the expire time of the specified key, or -1 if no expire
@@ -1094,11 +1175,15 @@ long long getExpire(redisDb *db, robj *key) {
 
     /* No expire? return ASAP */
     if (dictSize(db->expires) == 0 ||
-       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;
+       (de = dictFind(db->expires,key->ptr)) == NULL) {
+    	__A_VARIABLE = 1;
+    	return -1;
+    }
 
     /* The entry was found in the expire dict, this means it should also
      * be present in the main dict (safety check). */
     serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    __A_VARIABLE = 1;
     return dictGetSignedIntegerVal(de);
 }
 
@@ -1124,16 +1209,23 @@ void propagateExpire(redisDb *db, robj *key, int lazy) {
 
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
+    __A_VARIABLE = 1;
 }
 
 /* Check if the key is expired. */
 int keyIsExpired(redisDb *db, robj *key) {
     mstime_t when = getExpire(db,key);
 
-    if (when < 0) return 0; /* No expire for this key */
+    if (when < 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* No expire for this key */
 
     /* Don't expire anything while loading. It will be done later. */
-    if (server.loading) return 0;
+    if (server.loading) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* If we are in the context of a Lua script, we pretend that time is
      * blocked to when the Lua script started. This way a key can expire
@@ -1142,6 +1234,7 @@ int keyIsExpired(redisDb *db, robj *key) {
      * See issue #1525 on Github for more information. */
     mstime_t now = server.lua_caller ? server.lua_time_start : mstime();
 
+    __A_VARIABLE = 1;
     return now > when;
 }
 
@@ -1165,7 +1258,10 @@ int keyIsExpired(redisDb *db, robj *key) {
  * The return value of the function is 0 if the key is still valid,
  * otherwise the function returns 1 if the key is expired. */
 int expireIfNeeded(redisDb *db, robj *key) {
-    if (!keyIsExpired(db,key)) return 0;
+    if (!keyIsExpired(db,key)) {
+                                         __A_VARIABLE = 1;
+                                         return 0;
+    }
 
     /* If we are running in the context of a slave, instead of
      * evicting the expired key from the database, we return ASAP:
@@ -1175,13 +1271,17 @@ int expireIfNeeded(redisDb *db, robj *key) {
      * Still we try to return the right information to the caller,
      * that is, 0 if we think the key should be still valid, 1 if
      * we think the key is expired at this time. */
-    if (server.masterhost != NULL) return 1;
+    if (server.masterhost != NULL) {
+                                         __A_VARIABLE = 1;
+                                         return 1;
+    }
 
     /* Delete the key */
     server.stat_expiredkeys++;
     propagateExpire(db,key,server.lazyfree_lazy_expire);
     notifyKeyspaceEvent(NOTIFY_EXPIRED,
         "expired",key,db->id);
+    __A_VARIABLE = 1;
     return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                          dbSyncDelete(db,key);
 }
@@ -1250,6 +1350,7 @@ int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *nu
 /* Free the result of getKeysFromCommand. */
 void getKeysFreeResult(int *result) {
     zfree(result);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function to extract keys from following commands:
@@ -1264,6 +1365,7 @@ int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *nu
      * reply with syntax error. */
     if (num < 1 || num > (argc-3)) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1278,6 +1380,7 @@ int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *nu
     /* Finally add the argv[1] key position (the storage key target). */
     keys[num] = 1;
     *numkeys = num+1;  /* Total keys = {union,inter} keys + storage key */
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1293,6 +1396,7 @@ int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
      * reply with syntax error. */
     if (num <= 0 || num > (argc-3)) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1302,6 +1406,7 @@ int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     /* Add all key positions for argv[3...n] to keys[] */
     for (i = 0; i < num; i++) keys[i] = 3+i;
 
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1351,6 +1456,7 @@ int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
         }
     }
     *numkeys = num + found_store;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1378,6 +1484,7 @@ int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkey
     keys = zmalloc(sizeof(int)*num);
     for (i = 0; i < num; i++) keys[i] = first+i;
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1416,6 +1523,7 @@ int *georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numk
          keys[1] = stored_key;
     }
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1452,6 +1560,7 @@ int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     /* Syntax error. */
     if (streams_pos == -1 || num == 0 || num % 2 != 0) {
         *numkeys = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
     num /= 2; /* We have half the keys as there are arguments because
@@ -1460,6 +1569,7 @@ int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
     keys = zmalloc(sizeof(int) * num);
     for (i = streams_pos+1; i < argc-num; i++) keys[i-streams_pos-1] = i;
     *numkeys = num;
+    __A_VARIABLE = 1;
     return keys;
 }
 
@@ -1484,14 +1594,17 @@ void slotToKeyUpdateKey(robj *key, int add) {
         raxRemove(server.cluster->slots_to_keys,indexed,keylen+2,NULL);
     }
     if (indexed != buf) zfree(indexed);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyAdd(robj *key) {
     slotToKeyUpdateKey(key,1);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyDel(robj *key) {
     slotToKeyUpdateKey(key,0);
+    __A_VARIABLE = 1;
 }
 
 void slotToKeyFlush(void) {
@@ -1499,6 +1612,7 @@ void slotToKeyFlush(void) {
     server.cluster->slots_to_keys = raxNew();
     memset(server.cluster->slots_keys_count,0,
            sizeof(server.cluster->slots_keys_count));
+    __A_VARIABLE = 1;
 }
 
 /* Pupulate the specified array of objects with keys in the specified slot.
@@ -1518,6 +1632,7 @@ unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int coun
         keys[j++] = createStringObject((char*)iter.key+2,iter.key_len-2);
     }
     raxStop(&iter);
+    __A_VARIABLE = 1;
     return j;
 }
 
@@ -1541,9 +1656,11 @@ unsigned int delKeysInSlot(unsigned int hashslot) {
         j++;
     }
     raxStop(&iter);
+    __A_VARIABLE = 1;
     return j;
 }
 
 unsigned int countKeysInSlot(unsigned int hashslot) {
+    __A_VARIABLE = 1;
     return server.cluster->slots_keys_count[hashslot];
 }
diff --git a/src/debug.c b/src/debug.c
index 1ec7c49..f95a411 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -72,12 +73,14 @@ void xorDigest(unsigned char *digest, void *ptr, size_t len) {
 
     for (j = 0; j < 20; j++)
         digest[j] ^= hash[j];
+    __A_VARIABLE = 1;
 }
 
 void xorStringObjectDigest(unsigned char *digest, robj *o) {
     o = getDecodedObject(o);
     xorDigest(digest,o->ptr,sdslen(o->ptr));
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function instead of just computing the SHA1 and xoring it
@@ -102,12 +105,14 @@ void mixDigest(unsigned char *digest, void *ptr, size_t len) {
     SHA1Init(&ctx);
     SHA1Update(&ctx,digest,20);
     SHA1Final(digest,&ctx);
+    __A_VARIABLE = 1;
 }
 
 void mixStringObjectDigest(unsigned char *digest, robj *o) {
     o = getDecodedObject(o);
     mixDigest(digest,o->ptr,sdslen(o->ptr));
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function computes the digest of a data structure stored in the
@@ -247,6 +252,7 @@ void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o)
     }
     /* If the key has an expire, add it to the mix */
     if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
+    __A_VARIABLE = 1;
 }
 
 /* Compute the dataset digest. Since keys, sets elements, hashes elements
@@ -295,6 +301,7 @@ void computeDatasetDigest(unsigned char *final) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 void debugCommand(client *c) {
@@ -643,6 +650,7 @@ void _serverAssert(const char *estr, const char *file, int line) {
     serverLog(LL_WARNING,"(forcing SIGSEGV to print the bug report.)");
 #endif
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertPrintClientInfo(const client *c) {
@@ -667,6 +675,7 @@ void _serverAssertPrintClientInfo(const client *c) {
         serverLog(LL_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
             j, arg, c->argv[j]->refcount);
     }
+    __A_VARIABLE = 1;
 }
 
 void serverLogObjectDebugInfo(const robj *o) {
@@ -691,18 +700,21 @@ void serverLogObjectDebugInfo(const robj *o) {
         if (o->encoding == OBJ_ENCODING_SKIPLIST)
             serverLog(LL_WARNING,"Skiplist level: %d", (int) ((const zset*)o->ptr)->zsl->level);
     }
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertPrintObject(const robj *o) {
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
     serverLogObjectDebugInfo(o);
+    __A_VARIABLE = 1;
 }
 
 void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
     if (c) _serverAssertPrintClientInfo(c);
     if (o) _serverAssertPrintObject(o);
     _serverAssert(estr,file,line);
+    __A_VARIABLE = 1;
 }
 
 void _serverPanic(const char *file, int line, const char *msg, ...) {
@@ -721,6 +733,7 @@ void _serverPanic(const char *file, int line, const char *msg, ...) {
 #endif
     serverLog(LL_WARNING,"------------------------------------------------");
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 
 void bugReportStart(void) {
@@ -729,6 +742,7 @@ void bugReportStart(void) {
         "\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n");
         server.bug_report_start = 1;
     }
+    __A_VARIABLE = 1;
 }
 
 #ifdef HAVE_BACKTRACE
@@ -794,6 +808,7 @@ void logStackContent(void **sp) {
         else
             serverLog(LL_WARNING, "(%016lx) -> %016lx", addr, val);
     }
+    __A_VARIABLE = 1;
 }
 
 void logRegisters(ucontext_t *uc) {
@@ -1062,6 +1077,7 @@ void logRegisters(ucontext_t *uc) {
     serverLog(LL_WARNING,
         "  Dumping of registers not supported for this OS/arch");
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Return a file descriptor to write directly to the Redis log with the
@@ -1075,6 +1091,7 @@ int openDirectLogFiledes(void) {
     int fd = log_to_stdout ?
         STDOUT_FILENO :
         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
+    __A_VARIABLE = 1;
     return fd;
 }
 
@@ -1082,6 +1099,7 @@ int openDirectLogFiledes(void) {
 void closeDirectLogFiledes(int fd) {
     int log_to_stdout = server.logfile[0] == '\0';
     if (!log_to_stdout) close(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Logs the stack trace using the backtrace() call. This function is designed
@@ -1090,7 +1108,10 @@ void logStackTrace(ucontext_t *uc) {
     void *trace[101];
     int trace_size = 0, fd = openDirectLogFiledes();
 
-    if (fd == -1) return; /* If we can't log there is anything to do. */
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    } /* If we can't log there is anything to do. */
 
     /* Generate the stack trace */
     trace_size = backtrace(trace+1, 100);
@@ -1109,13 +1130,17 @@ void logStackTrace(ucontext_t *uc) {
 
     /* Cleanup */
     closeDirectLogFiledes(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Log information about the "current" client, that is, the client that is
  * currently being served by Redis. May be NULL if Redis is not serving a
  * client right now. */
 void logCurrentClient(void) {
-    if (server.current_client == NULL) return;
+    if (server.current_client == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     client *cc = server.current_client;
     sds client;
@@ -1148,6 +1173,7 @@ void logCurrentClient(void) {
         }
         decrRefCount(key);
     }
+    __A_VARIABLE = 1;
 }
 
 #if defined(HAVE_PROC_MAPS)
@@ -1165,10 +1191,16 @@ int memtest_test_linux_anonymous_maps(void) {
     int regions = 0, j;
 
     int fd = openDirectLogFiledes();
-    if (!fd) return 0;
+    if (!fd) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     fp = fopen("/proc/self/maps","r");
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     while(fgets(line,sizeof(line),fp) != NULL) {
         char *start, *end, *p = line;
 
@@ -1213,6 +1245,7 @@ int memtest_test_linux_anonymous_maps(void) {
      * region that we are testing. */
     fclose(fp);
     closeDirectLogFiledes(fd);
+    __A_VARIABLE = 1;
     return errors;
 }
 #endif
@@ -1228,7 +1261,10 @@ void dumpX86Calls(void *addr, size_t len) {
      * multiple times. */
     unsigned long ht[256] = {0};
 
-    if (len < 5) return;
+    if (len < 5) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (j = 0; j < len-4; j++) {
         if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */
         unsigned long target = (unsigned long)addr+j+5;
@@ -1241,6 +1277,7 @@ void dumpX86Calls(void *addr, size_t len) {
             j += 4; /* Skip the 32 bit immediate. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
@@ -1344,6 +1381,7 @@ void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
     act.sa_handler = SIG_DFL;
     sigaction (sig, &act, NULL);
     kill(getpid(),sig);
+    __A_VARIABLE = 1;
 }
 #endif /* HAVE_BACKTRACE */
 
@@ -1369,6 +1407,7 @@ void serverLogHexDump(int level, char *descr, void *value, size_t len) {
         }
     }
     serverLogRaw(level|LL_RAW,"\n");
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Software Watchdog ============================ */
@@ -1390,6 +1429,7 @@ void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
     serverLogFromHandler(LL_WARNING,"Sorry: no support for backtrace().");
 #endif
     serverLogFromHandler(LL_WARNING,"--------\n");
+    __A_VARIABLE = 1;
 }
 
 /* Schedule a SIGALRM delivery after the specified period in milliseconds.
@@ -1405,6 +1445,7 @@ void watchdogScheduleSignal(int period) {
     it.it_interval.tv_sec = 0;
     it.it_interval.tv_usec = 0;
     setitimer(ITIMER_REAL, &it, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Enable the software watchdog with the specified period in milliseconds. */
@@ -1428,12 +1469,16 @@ void enableWatchdog(int period) {
     if (period < min_period) period = min_period;
     watchdogScheduleSignal(period); /* Adjust the current timer. */
     server.watchdog_period = period;
+    __A_VARIABLE = 1;
 }
 
 /* Disable the software watchdog. */
 void disableWatchdog(void) {
     struct sigaction act;
-    if (server.watchdog_period == 0) return; /* Already disabled. */
+    if (server.watchdog_period == 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Already disabled. */
     watchdogScheduleSignal(0); /* Stop the current timer. */
 
     /* Set the signal handler to SIG_IGN, this will also remove pending
@@ -1443,4 +1488,5 @@ void disableWatchdog(void) {
     act.sa_handler = SIG_IGN;
     sigaction(SIGALRM, &act, NULL);
     server.watchdog_period = 0;
+    __A_VARIABLE = 1;
 }
diff --git a/src/defrag.c b/src/defrag.c
index ecf0255..184b209 100644
--- a/src/defrag.c
+++ b/src/defrag.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* 
  * Active memory defragmentation
  * Try to find key / value allocations that need to be re-allocated in order 
@@ -60,6 +61,7 @@ void* activeDefragAlloc(void *ptr) {
     void *newptr;
     if(!je_get_defrag_hint(ptr, &bin_util, &run_util)) {
         server.stat_active_defrag_misses++;
+        __A_VARIABLE = 1;
         return NULL;
     }
     /* if this run is more utilized than the average utilization in this bin
@@ -67,6 +69,7 @@ void* activeDefragAlloc(void *ptr) {
      * from relatively empty runs into relatively full runs. */
     if (run_util > bin_util || run_util == 1<<16) {
         server.stat_active_defrag_misses++;
+        __A_VARIABLE = 1;
         return NULL;
     }
     /* move this allocation to a new allocation.
@@ -76,6 +79,7 @@ void* activeDefragAlloc(void *ptr) {
     newptr = zmalloc_no_tcache(size);
     memcpy(newptr, ptr, size);
     zfree_no_tcache(ptr);
+    __A_VARIABLE = 1;
     return newptr;
 }
 
@@ -90,8 +94,10 @@ sds activeDefragSds(sds sdsptr) {
     if (newptr) {
         size_t offset = sdsptr - (char*)ptr;
         sdsptr = (char*)newptr + offset;
+        __A_VARIABLE = 1;
         return sdsptr;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -102,8 +108,10 @@ sds activeDefragSds(sds sdsptr) {
  * and should NOT be accessed. */
 robj *activeDefragStringOb(robj* ob, long *defragged) {
     robj *ret = NULL;
-    if (ob->refcount!=1)
+    if (ob->refcount!=1) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     /* try to defrag robj (only if not an EMBSTR type (handled below). */
     if (ob->type!=OBJ_STRING || ob->encoding!=OBJ_ENCODING_EMBSTR) {
@@ -133,6 +141,7 @@ robj *activeDefragStringOb(robj* ob, long *defragged) {
             serverPanic("Unknown string encoding");
         }
     }
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -164,6 +173,7 @@ long dictIterDefragEntry(dictIterator *iter) {
             defragged++;
         }
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -183,6 +193,7 @@ long dictDefragTables(dict* d) {
         if (newtable)
             defragged++, d->ht[1].table = newtable;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -201,6 +212,7 @@ void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnod
         serverAssert(zsl->tail==oldnode);
         zsl->tail = newnode;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Defrag helper for sorted set.
@@ -240,8 +252,10 @@ double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {
     newx = activeDefragAlloc(x);
     if (newx) {
         zslUpdateNode(zsl, x, newx, update);
+        __A_VARIABLE = 1;
         return &newx->score;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -259,6 +273,7 @@ long activeDefragZsetEntry(zset *zs, dictEntry *de) {
         dictSetVal(zs->dict, de, newscore);
         defragged++;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -294,6 +309,7 @@ long activeDefragSdsDict(dict* d, int val_type) {
         defragged += dictIterDefragEntry(di);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -328,6 +344,7 @@ long activeDefragList(list *l, int val_type) {
                 ln->value = newptr, defragged++;
         }
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -382,6 +399,7 @@ long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
     }
     dictReleaseIterator(di);
 
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -403,8 +421,10 @@ dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sd
         }
         if (newkey)
             de->key = newkey;
+        __A_VARIABLE = 1;
         return de;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -429,6 +449,7 @@ long activeDefragQuickListNodes(quicklist *ql) {
             defragged++, node->zl = newzl;
         node = node->next;
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -438,13 +459,17 @@ long activeDefragQuickListNodes(quicklist *ql) {
 void defragLater(redisDb *db, dictEntry *kde) {
     sds key = sdsdup(dictGetKey(kde));
     listAddNodeTail(db->defrag_later, key);
+    __A_VARIABLE = 1;
 }
 
 long scanLaterList(robj *ob) {
     quicklist *ql = ob->ptr;
-    if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST)
+    if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     server.stat_active_defrag_scanned+=ql->len;
+    __A_VARIABLE = 1;
     return activeDefragQuickListNodes(ql);
 }
 
@@ -458,15 +483,19 @@ void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {
     scanLaterZsetData *data = privdata;
     data->defragged += activeDefragZsetEntry(data->zs, de);
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterZset(robj *ob, unsigned long *cursor) {
-    if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST)
+    if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     zset *zs = (zset*)ob->ptr;
     dict *d = zs->dict;
     scanLaterZsetData data = {zs, 0};
     *cursor = dictScan(d, *cursor, scanLaterZsetCallback, defragDictBucketCallback, &data);
+    __A_VARIABLE = 1;
     return data.defragged;
 }
 
@@ -477,14 +506,18 @@ void scanLaterSetCallback(void *privdata, const dictEntry *_de) {
     if ((newsds = activeDefragSds(sdsele)))
         (*defragged)++, de->key = newsds;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterSet(robj *ob, unsigned long *cursor) {
     long defragged = 0;
-    if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT)
+    if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     dict *d = ob->ptr;
     *cursor = dictScan(d, *cursor, scanLaterSetCallback, defragDictBucketCallback, &defragged);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -498,14 +531,18 @@ void scanLaterHashCallback(void *privdata, const dictEntry *_de) {
     if ((newsds = activeDefragSds(sdsele)))
         (*defragged)++, de->v.val = newsds;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 long scanLaterHash(robj *ob, unsigned long *cursor) {
     long defragged = 0;
-    if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT)
+    if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     dict *d = ob->ptr;
     *cursor = dictScan(d, *cursor, scanLaterHashCallback, defragDictBucketCallback, &defragged);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -520,6 +557,7 @@ long defragQuicklist(redisDb *db, dictEntry *kde) {
         defragLater(db, kde);
     else
         defragged += activeDefragQuickListNodes(ql);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -553,6 +591,7 @@ long defragZsetSkiplist(redisDb *db, dictEntry *kde) {
         defragged++, zs->dict = newdict;
     /* defrag the dict tables */
     defragged += dictDefragTables(zs->dict);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -571,6 +610,7 @@ long defragHash(redisDb *db, dictEntry *kde) {
         defragged++, ob->ptr = newd;
     /* defrag the dict tables */
     defragged += dictDefragTables(ob->ptr);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -589,6 +629,7 @@ long defragSet(redisDb *db, dictEntry *kde) {
         defragged++, ob->ptr = newd;
     /* defrag the dict tables */
     defragged += dictDefragTables(ob->ptr);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -598,8 +639,10 @@ int defragRaxNode(raxNode **noderef) {
     raxNode *newnode = activeDefragAlloc(*noderef);
     if (newnode) {
         *noderef = newnode;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -682,6 +725,7 @@ long defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_c
             raxSetData(ri.node, ri.data=newdata), defragged++;
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -703,6 +747,7 @@ void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, long *de
         serverAssert(prev==nack);
         /* note: we don't increment 'defragged' that's done by the caller */
     }
+    __A_VARIABLE = 1;
     return newnack;
 }
 
@@ -721,6 +766,7 @@ void* defragStreamConsumer(raxIterator *ri, void *privdata, long *defragged) {
         PendingEntryContext pel_ctx = {cg, c};
         *defragged += defragRadixTree(&c->pel, 0, defragStreamConsumerPendingEntry, &pel_ctx);
     }
+    __A_VARIABLE = 1;
     return newc; /* returns NULL if c was not defragged */
 }
 
@@ -731,6 +777,7 @@ void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, long *defragged
         *defragged += defragRadixTree(&cg->consumers, 0, defragStreamConsumer, cg);
     if (cg->pel)
         *defragged += defragRadixTree(&cg->pel, 0, NULL, NULL);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -754,6 +801,7 @@ long defragStream(redisDb *db, dictEntry *kde) {
 
     if (s->cgroups)
         defragged += defragRadixTree(&s->cgroups, 1, defragStreamConsumerGroup, NULL);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -833,6 +881,7 @@ long defragKey(redisDb *db, dictEntry *de) {
     } else {
         serverPanic("Unknown object type");
     }
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -845,6 +894,7 @@ void defragScanCallback(void *privdata, const dictEntry *de) {
     else
         server.stat_active_defrag_key_misses++;
     server.stat_active_defrag_scanned++;
+    __A_VARIABLE = 1;
 }
 
 /* Defrag scan callback for each hash table bicket,
@@ -858,6 +908,7 @@ void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
         }
         bucketref = &(*bucketref)->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Utility function to get the fragmentation ratio from jemalloc.
@@ -878,6 +929,7 @@ float getAllocatorFragmentation(size_t *out_frag_bytes) {
     serverLog(LL_DEBUG,
         "allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag_bytes=%zu (%zu rss)",
         allocated, active, resident, frag_pct, rss_pct, frag_bytes, rss_bytes);
+    __A_VARIABLE = 1;
     return frag_pct;
 }
 
@@ -891,6 +943,7 @@ long defragOtherGlobals() {
      * that remain static for a long time */
     defragged += activeDefragSdsDict(server.lua_scripts, DEFRAG_SDS_DICT_VAL_IS_STROB);
     defragged += activeDefragSdsListAndDict(server.repl_scriptcache_fifo, server.repl_scriptcache_dict, DEFRAG_SDS_DICT_NO_VAL);
+    __A_VARIABLE = 1;
     return defragged;
 }
 
@@ -944,8 +997,10 @@ int defragLaterStep(redisDb *db, long long endtime) {
 
             /* stop if we reached the last one. */
             head = listFirst(db->defrag_later);
-            if (!head)
+            if (!head) {
+                __A_VARIABLE = 1;
                 return 0;
+            }
 
             /* start a new key */
             current_key = head->value;
@@ -976,6 +1031,7 @@ int defragLaterStep(redisDb *db, long long endtime) {
                         server.stat_active_defrag_key_hits++;
                     else
                         server.stat_active_defrag_key_misses++;
+                    __A_VARIABLE = 1;
                     return 1;
                 }
                 iterations = 0;
@@ -988,6 +1044,7 @@ int defragLaterStep(redisDb *db, long long endtime) {
         else
             server.stat_active_defrag_key_misses++;
     } while(1);
+    __A_VARIABLE = 1;
 }
 
 #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
@@ -999,8 +1056,10 @@ void computeDefragCycles() {
     float frag_pct = getAllocatorFragmentation(&frag_bytes);
     /* If we're not already running, and below the threshold, exit. */
     if (!server.active_defrag_running) {
-        if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes)
+        if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes) {
+            __A_VARIABLE = 1;
             return;
+        }
     }
 
     /* Calculate the adaptive aggressiveness of the defrag */
@@ -1022,6 +1081,7 @@ void computeDefragCycles() {
             "Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%",
             frag_pct, frag_bytes, cpu_pct);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Perform incremental defragmentation work from the serverCron.
@@ -1135,6 +1195,7 @@ void activeDefragCycle(void) {
 
 void activeDefragCycle(void) {
     /* Not implemented yet. */
+	__A_VARIABLE = 1;
 }
 
 #endif
diff --git a/src/dict.c b/src/dict.c
index 2cf9d48..846527e 100644
--- a/src/dict.c
+++ b/src/dict.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Hash Tables Implementation.
  *
  * This file implements in memory hash tables with insert/del/replace/find/
@@ -75,9 +76,11 @@ static uint8_t dict_hash_function_seed[16];
 
 void dictSetHashFunctionSeed(uint8_t *seed) {
     memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
+    __A_VARIABLE = 1;
 }
 
 uint8_t *dictGetHashFunctionSeed(void) {
+    __A_VARIABLE = 1;
     return dict_hash_function_seed;
 }
 
@@ -88,10 +91,12 @@ uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);
 uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);
 
 uint64_t dictGenHashFunction(const void *key, int len) {
+    __A_VARIABLE = 1;
     return siphash(key,len,dict_hash_function_seed);
 }
 
 uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {
+    __A_VARIABLE = 1;
     return siphash_nocase(buf,len,dict_hash_function_seed);
 }
 
@@ -105,6 +110,7 @@ static void _dictReset(dictht *ht)
     ht->size = 0;
     ht->sizemask = 0;
     ht->used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Create a new hash table */
@@ -114,6 +120,7 @@ dict *dictCreate(dictType *type,
     dict *d = zmalloc(sizeof(*d));
 
     _dictInit(d,type,privDataPtr);
+    __A_VARIABLE = 1;
     return d;
 }
 
@@ -127,6 +134,7 @@ int _dictInit(dict *d, dictType *type,
     d->privdata = privDataPtr;
     d->rehashidx = -1;
     d->iterators = 0;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -136,10 +144,14 @@ int dictResize(dict *d)
 {
     int minimal;
 
-    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
+    if (!dict_can_resize || dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
     minimal = d->ht[0].used;
     if (minimal < DICT_HT_INITIAL_SIZE)
         minimal = DICT_HT_INITIAL_SIZE;
+    __A_VARIABLE = 1;
     return dictExpand(d, minimal);
 }
 
@@ -148,14 +160,19 @@ int dictExpand(dict *d, unsigned long size)
 {
     /* the size is invalid if it is smaller than the number of
      * elements already inside the hash table */
-    if (dictIsRehashing(d) || d->ht[0].used > size)
+    if (dictIsRehashing(d) || d->ht[0].used > size) {
+        __A_VARIABLE = 1;
         return DICT_ERR;
+    }
 
     dictht n; /* the new hash table */
     unsigned long realsize = _dictNextPower(size);
 
     /* Rehashing to the same table size is not useful. */
-    if (realsize == d->ht[0].size) return DICT_ERR;
+    if (realsize == d->ht[0].size) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
 
     /* Allocate the new hash table and initialize all pointers to NULL */
     n.size = realsize;
@@ -167,12 +184,14 @@ int dictExpand(dict *d, unsigned long size)
      * we just set the first hash table so that it can accept keys. */
     if (d->ht[0].table == NULL) {
         d->ht[0] = n;
+        __A_VARIABLE = 1;
         return DICT_OK;
     }
 
     /* Prepare a second hash table for incremental rehashing */
     d->ht[1] = n;
     d->rehashidx = 0;
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -187,7 +206,10 @@ int dictExpand(dict *d, unsigned long size)
  * work it does would be unbound and the function may block for a long time. */
 int dictRehash(dict *d, int n) {
     int empty_visits = n*10; /* Max number of empty buckets to visit. */
-    if (!dictIsRehashing(d)) return 0;
+    if (!dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     while(n-- && d->ht[0].used != 0) {
         dictEntry *de, *nextde;
@@ -197,7 +219,10 @@ int dictRehash(dict *d, int n) {
         assert(d->ht[0].size > (unsigned long)d->rehashidx);
         while(d->ht[0].table[d->rehashidx] == NULL) {
             d->rehashidx++;
-            if (--empty_visits == 0) return 1;
+            if (--empty_visits == 0) {
+                __A_VARIABLE = 1;
+                return 1;
+            }
         }
         de = d->ht[0].table[d->rehashidx];
         /* Move all the keys in this bucket from the old to the new hash HT */
@@ -223,10 +248,12 @@ int dictRehash(dict *d, int n) {
         d->ht[0] = d->ht[1];
         _dictReset(&d->ht[1]);
         d->rehashidx = -1;
+        __A_VARIABLE = 1;
         return 0;
     }
 
     /* More to rehash... */
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -234,6 +261,7 @@ long long timeInMilliseconds(void) {
     struct timeval tv;
 
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
 }
 
@@ -246,6 +274,7 @@ int dictRehashMilliseconds(dict *d, int ms) {
         rehashes += 100;
         if (timeInMilliseconds()-start > ms) break;
     }
+    __A_VARIABLE = 1;
     return rehashes;
 }
 
@@ -259,6 +288,7 @@ int dictRehashMilliseconds(dict *d, int ms) {
  * while it is actively used. */
 static void _dictRehashStep(dict *d) {
     if (d->iterators == 0) dictRehash(d,1);
+    __A_VARIABLE = 1;
 }
 
 /* Add an element to the target hash table */
@@ -266,8 +296,12 @@ int dictAdd(dict *d, void *key, void *val)
 {
     dictEntry *entry = dictAddRaw(d,key,NULL);
 
-    if (!entry) return DICT_ERR;
+    if (!entry) {
+        __A_VARIABLE = 1;
+        return DICT_ERR;
+    }
     dictSetVal(d, entry, val);
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -299,8 +333,10 @@ dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
+    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     /* Allocate the memory and store the new entry.
      * Insert the element in top, with the assumption that in a database
@@ -314,6 +350,7 @@ dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 
     /* Set the hash entry fields. */
     dictSetKey(d, entry, key);
+    __A_VARIABLE = 1;
     return entry;
 }
 
@@ -331,6 +368,7 @@ int dictReplace(dict *d, void *key, void *val)
     entry = dictAddRaw(d,key,&existing);
     if (entry) {
         dictSetVal(d, entry, val);
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -342,6 +380,7 @@ int dictReplace(dict *d, void *key, void *val)
     auxentry = *existing;
     dictSetVal(d, existing, val);
     dictFreeVal(d, &auxentry);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -355,6 +394,7 @@ int dictReplace(dict *d, void *key, void *val)
 dictEntry *dictAddOrFind(dict *d, void *key) {
     dictEntry *entry, *existing;
     entry = dictAddRaw(d,key,&existing);
+    __A_VARIABLE = 1;
     return entry ? entry : existing;
 }
 
@@ -366,7 +406,10 @@ static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
     dictEntry *he, *prevHe;
     int table;
 
-    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
+    if (d->ht[0].used == 0 && d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
@@ -388,6 +431,7 @@ static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
                     zfree(he);
                 }
                 d->ht[table].used--;
+                __A_VARIABLE = 1;
                 return he;
             }
             prevHe = he;
@@ -395,12 +439,14 @@ static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
         }
         if (!dictIsRehashing(d)) break;
     }
+    __A_VARIABLE = 1;
     return NULL; /* not found */
 }
 
 /* Remove an element, returning DICT_OK on success or DICT_ERR if the
  * element was not found. */
 int dictDelete(dict *ht, const void *key) {
+    __A_VARIABLE = 1;
     return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
 }
 
@@ -426,16 +472,21 @@ int dictDelete(dict *ht, const void *key) {
  * dictFreeUnlinkedEntry(entry); // <- This does not need to lookup again.
  */
 dictEntry *dictUnlink(dict *ht, const void *key) {
+    __A_VARIABLE = 1;
     return dictGenericDelete(ht,key,1);
 }
 
 /* You need to call this function to really free the entry after a call
  * to dictUnlink(). It's safe to call this function with 'he' = NULL. */
 void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
-    if (he == NULL) return;
+    if (he == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     dictFreeKey(d, he);
     dictFreeVal(d, he);
     zfree(he);
+    __A_VARIABLE = 1;
 }
 
 /* Destroy an entire dictionary */
@@ -462,6 +513,7 @@ int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {
     zfree(ht->table);
     /* Re-initialize the table */
     _dictReset(ht);
+    __A_VARIABLE = 1;
     return DICT_OK; /* never fails */
 }
 
@@ -471,6 +523,7 @@ void dictRelease(dict *d)
     _dictClear(d,&d->ht[0],NULL);
     _dictClear(d,&d->ht[1],NULL);
     zfree(d);
+    __A_VARIABLE = 1;
 }
 
 dictEntry *dictFind(dict *d, const void *key)
@@ -478,19 +531,28 @@ dictEntry *dictFind(dict *d, const void *key)
     dictEntry *he;
     uint64_t h, idx, table;
 
-    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
+    if (d->ht[0].used + d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    } /* dict is empty */
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         he = d->ht[table].table[idx];
         while(he) {
-            if (key==he->key || dictCompareKeys(d, key, he->key))
+            if (key==he->key || dictCompareKeys(d, key, he->key)) {
+                __A_VARIABLE = 1;
                 return he;
+            }
             he = he->next;
         }
-        if (!dictIsRehashing(d)) return NULL;
+        if (!dictIsRehashing(d)) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -498,6 +560,7 @@ void *dictFetchValue(dict *d, const void *key) {
     dictEntry *he;
 
     he = dictFind(d,key);
+    __A_VARIABLE = 1;
     return he ? dictGetVal(he) : NULL;
 }
 
@@ -536,6 +599,7 @@ long long dictFingerprint(dict *d) {
         hash = hash ^ (hash >> 28);
         hash = hash + (hash << 31);
     }
+    __A_VARIABLE = 1;
     return hash;
 }
 
@@ -549,6 +613,7 @@ dictIterator *dictGetIterator(dict *d)
     iter->safe = 0;
     iter->entry = NULL;
     iter->nextEntry = NULL;
+    __A_VARIABLE = 1;
     return iter;
 }
 
@@ -556,6 +621,7 @@ dictIterator *dictGetSafeIterator(dict *d) {
     dictIterator *i = dictGetIterator(d);
 
     i->safe = 1;
+    __A_VARIABLE = 1;
     return i;
 }
 
@@ -588,9 +654,11 @@ dictEntry *dictNext(dictIterator *iter)
             /* We need to save the 'next' here, the iterator user
              * may delete the entry we are returning. */
             iter->nextEntry = iter->entry->next;
+            __A_VARIABLE = 1;
             return iter->entry;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -603,6 +671,7 @@ void dictReleaseIterator(dictIterator *iter)
             assert(iter->fingerprint == dictFingerprint(iter->d));
     }
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Return a random entry from the hash table. Useful to
@@ -613,7 +682,10 @@ dictEntry *dictGetRandomKey(dict *d)
     unsigned long h;
     int listlen, listele;
 
-    if (dictSize(d) == 0) return NULL;
+    if (dictSize(d) == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (dictIsRehashing(d)) _dictRehashStep(d);
     if (dictIsRehashing(d)) {
         do {
@@ -645,6 +717,7 @@ dictEntry *dictGetRandomKey(dict *d)
     listele = random() % listlen;
     he = orighe;
     while(listele--) he = he->next;
+    __A_VARIABLE = 1;
     return he;
 }
 
@@ -748,6 +821,7 @@ static unsigned long rev(unsigned long v) {
         mask ^= (mask << s);
         v = ((v >> s) & mask) | ((v << s) & ~mask);
     }
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -845,7 +919,10 @@ unsigned long dictScan(dict *d,
     const dictEntry *de, *next;
     unsigned long m0, m1;
 
-    if (dictSize(d) == 0) return 0;
+    if (dictSize(d) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     if (!dictIsRehashing(d)) {
         t0 = &(d->ht[0]);
@@ -913,6 +990,7 @@ unsigned long dictScan(dict *d,
         } while (v & (m0 ^ m1));
     }
 
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -922,10 +1000,16 @@ unsigned long dictScan(dict *d,
 static int _dictExpandIfNeeded(dict *d)
 {
     /* Incremental rehashing already in progress. Return. */
-    if (dictIsRehashing(d)) return DICT_OK;
+    if (dictIsRehashing(d)) {
+        __A_VARIABLE = 1;
+        return DICT_OK;
+    }
 
     /* If the hash table is empty expand it to the initial size. */
-    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);
+    if (d->ht[0].size == 0) {
+        __A_VARIABLE = 1;
+        return dictExpand(d, DICT_HT_INITIAL_SIZE);
+    }
 
     /* If we reached the 1:1 ratio, and we are allowed to resize the hash
      * table (global setting) or we should avoid it but the ratio between
@@ -935,8 +1019,10 @@ static int _dictExpandIfNeeded(dict *d)
         (dict_can_resize ||
          d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
     {
+        __A_VARIABLE = 1;
         return dictExpand(d, d->ht[0].used*2);
     }
+    __A_VARIABLE = 1;
     return DICT_OK;
 }
 
@@ -945,12 +1031,18 @@ static unsigned long _dictNextPower(unsigned long size)
 {
     unsigned long i = DICT_HT_INITIAL_SIZE;
 
-    if (size >= LONG_MAX) return LONG_MAX + 1LU;
+    if (size >= LONG_MAX) {
+        __A_VARIABLE = 1;
+        return LONG_MAX + 1LU;
+    }
     while(1) {
-        if (i >= size)
+        if (i >= size) {
+            __A_VARIABLE = 1;
             return i;
+        }
         i *= 2;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Returns the index of a free slot that can be populated with
@@ -967,8 +1059,10 @@ static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **e
     if (existing) *existing = NULL;
 
     /* Expand the hash table if needed */
-    if (_dictExpandIfNeeded(d) == DICT_ERR)
+    if (_dictExpandIfNeeded(d) == DICT_ERR) {
+        __A_VARIABLE = 1;
         return -1;
+    }
     for (table = 0; table <= 1; table++) {
         idx = hash & d->ht[table].sizemask;
         /* Search if this slot does not already contain the given key */
@@ -976,12 +1070,14 @@ static long _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **e
         while(he) {
             if (key==he->key || dictCompareKeys(d, key, he->key)) {
                 if (existing) *existing = he;
+                __A_VARIABLE = 1;
                 return -1;
             }
             he = he->next;
         }
         if (!dictIsRehashing(d)) break;
     }
+    __A_VARIABLE = 1;
     return idx;
 }
 
@@ -990,17 +1086,21 @@ void dictEmpty(dict *d, void(callback)(void*)) {
     _dictClear(d,&d->ht[1],callback);
     d->rehashidx = -1;
     d->iterators = 0;
+    __A_VARIABLE = 1;
 }
 
 void dictEnableResize(void) {
     dict_can_resize = 1;
+    __A_VARIABLE = 1;
 }
 
 void dictDisableResize(void) {
     dict_can_resize = 0;
+    __A_VARIABLE = 1;
 }
 
 uint64_t dictGetHash(dict *d, const void *key) {
+    __A_VARIABLE = 1;
     return dictHashKey(d, key);
 }
 
@@ -1013,19 +1113,28 @@ dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t h
     dictEntry *he, **heref;
     unsigned long idx, table;
 
-    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
+    if (d->ht[0].used + d->ht[1].used == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    } /* dict is empty */
     for (table = 0; table <= 1; table++) {
         idx = hash & d->ht[table].sizemask;
         heref = &d->ht[table].table[idx];
         he = *heref;
         while(he) {
-            if (oldptr==he->key)
+            if (oldptr==he->key) {
+                __A_VARIABLE = 1;
                 return heref;
+            }
             heref = &he->next;
             he = *heref;
         }
-        if (!dictIsRehashing(d)) return NULL;
+        if (!dictIsRehashing(d)) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1039,6 +1148,7 @@ size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
     size_t l = 0;
 
     if (ht->used == 0) {
+        __A_VARIABLE = 1;
         return snprintf(buf,bufsize,
             "No stats available for empty dictionaries\n");
     }
@@ -1090,6 +1200,7 @@ size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
 
     /* Unlike snprintf(), teturn the number of characters actually written. */
     if (bufsize) buf[bufsize-1] = '\0';
+    __A_VARIABLE = 1;
     return strlen(buf);
 }
 
@@ -1106,6 +1217,7 @@ void dictGetStats(char *buf, size_t bufsize, dict *d) {
     }
     /* Make sure there is a NULL term at the end. */
     if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------------- Benchmark ---------------------------------*/
@@ -1115,6 +1227,7 @@ void dictGetStats(char *buf, size_t bufsize, dict *d) {
 #include "sds.h"
 
 uint64_t hashCallback(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
@@ -1124,7 +1237,11 @@ int compareCallback(void *privdata, const void *key1, const void *key2) {
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
@@ -1132,6 +1249,7 @@ void freeCallback(void *privdata, void *val) {
     DICT_NOTUSED(privdata);
 
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 dictType BenchmarkDictType = {
@@ -1222,5 +1340,6 @@ int main(int argc, char **argv) {
         assert(retval == DICT_OK);
     }
     end_benchmark("Removing and adding");
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/src/endianconv.c b/src/endianconv.c
index f3b0b47..f252b95 100644
--- a/src/endianconv.c
+++ b/src/endianconv.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* endinconv.c -- Endian conversions utilities.
  *
  * This functions are never called directly, but always using the macros
@@ -52,6 +53,7 @@ void memrev16(void *p) {
     t = x[0];
     x[0] = x[1];
     x[1] = t;
+    __A_VARIABLE = 1;
 }
 
 /* Toggle the 32 bit unsigned integer pointed by *p from little endian to
@@ -65,6 +67,7 @@ void memrev32(void *p) {
     t = x[1];
     x[1] = x[2];
     x[2] = t;
+    __A_VARIABLE = 1;
 }
 
 /* Toggle the 64 bit unsigned integer pointed by *p from little endian to
@@ -84,20 +87,24 @@ void memrev64(void *p) {
     t = x[3];
     x[3] = x[4];
     x[4] = t;
+    __A_VARIABLE = 1;
 }
 
 uint16_t intrev16(uint16_t v) {
     memrev16(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
 uint32_t intrev32(uint32_t v) {
     memrev32(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
 uint64_t intrev64(uint64_t v) {
     memrev64(&v);
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -123,6 +130,7 @@ int endianconvTest(int argc, char *argv[]) {
     memrev64(buf);
     printf("%s\n", buf);
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/evict.c b/src/evict.c
index 773916c..debc140 100644
--- a/src/evict.c
+++ b/src/evict.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Maxmemory directive handling (LRU eviction and other policies).
  *
  * ----------------------------------------------------------------------------
@@ -68,6 +69,7 @@ static struct evictionPoolEntry *EvictionPoolLRU;
  * in a reduced-bits format that can be used to set and check the
  * object->lru field of redisObject structures. */
 unsigned int getLRUClock(void) {
+    __A_VARIABLE = 1;
     return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
 }
 
@@ -82,6 +84,7 @@ unsigned int LRU_CLOCK(void) {
     } else {
         lruclock = getLRUClock();
     }
+    __A_VARIABLE = 1;
     return lruclock;
 }
 
@@ -148,6 +151,7 @@ void evictionPoolAlloc(void) {
         ep[j].dbid = 0;
     }
     EvictionPoolLRU = ep;
+    __A_VARIABLE = 1;
 }
 
 /* This is an helper function for freeMemoryIfNeeded(), it is used in order
@@ -254,6 +258,7 @@ void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evic
         pool[k].idle = idle;
         pool[k].dbid = dbid;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -297,6 +302,7 @@ void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evic
  * 16 bits. The returned time is suitable to be stored as LDT (last decrement
  * time) for the LFU implementation. */
 unsigned long LFUGetTimeInMinutes(void) {
+    __A_VARIABLE = 1;
     return (server.unixtime/60) & 65535;
 }
 
@@ -306,19 +312,27 @@ unsigned long LFUGetTimeInMinutes(void) {
  * exactly once. */
 unsigned long LFUTimeElapsed(unsigned long ldt) {
     unsigned long now = LFUGetTimeInMinutes();
-    if (now >= ldt) return now-ldt;
+    if (now >= ldt) {
+        __A_VARIABLE = 1;
+        return now-ldt;
+    }
+    __A_VARIABLE = 1;
     return 65535-ldt+now;
 }
 
 /* Logarithmically increment a counter. The greater is the current counter value
  * the less likely is that it gets really implemented. Saturate it at 255. */
 uint8_t LFULogIncr(uint8_t counter) {
-    if (counter == 255) return 255;
+    if (counter == 255) {
+        __A_VARIABLE = 1;
+        return 255;
+    }
     double r = (double)rand()/RAND_MAX;
     double baseval = counter - LFU_INIT_VAL;
     if (baseval < 0) baseval = 0;
     double p = 1.0/(baseval*server.lfu_log_factor+1);
     if (r < p) counter++;
+    __A_VARIABLE = 1;
     return counter;
 }
 
@@ -338,6 +352,7 @@ unsigned long LFUDecrAndReturn(robj *o) {
     unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;
     if (num_periods)
         counter = (num_periods > counter) ? 0 : counter - num_periods;
+    __A_VARIABLE = 1;
     return counter;
 }
 
@@ -366,6 +381,7 @@ size_t freeMemoryGetNotCountedMemory(void) {
     if (server.aof_state != AOF_OFF) {
         overhead += sdsalloc(server.aof_buf)+aofRewriteBufferSize();
     }
+    __A_VARIABLE = 1;
     return overhead;
 }
 
@@ -403,7 +419,10 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
 
     /* We may return ASAP if there is no need to compute the level. */
     int return_ok_asap = !server.maxmemory || mem_reported <= server.maxmemory;
-    if (return_ok_asap && !level) return C_OK;
+    if (return_ok_asap && !level) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Remove the size of slaves output buffers and AOF buffer from the
      * count of used memory. */
@@ -420,10 +439,16 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
         }
     }
 
-    if (return_ok_asap) return C_OK;
+    if (return_ok_asap) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Check if we are still over the memory limit. */
-    if (mem_used <= server.maxmemory) return C_OK;
+    if (mem_used <= server.maxmemory) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Compute how much memory we need to free. */
     mem_tofree = mem_used - server.maxmemory;
@@ -431,6 +456,7 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
     if (logical) *logical = mem_used;
     if (tofree) *tofree = mem_tofree;
 
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -446,7 +472,10 @@ int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *lev
 int freeMemoryIfNeeded(void) {
     /* By default replicas should ignore maxmemory
      * and just be masters exact copies. */
-    if (server.masterhost && server.repl_slave_ignore_maxmemory) return C_OK;
+    if (server.masterhost && server.repl_slave_ignore_maxmemory) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     size_t mem_reported, mem_tofree, mem_freed;
     mstime_t latency, eviction_latency;
@@ -456,9 +485,14 @@ int freeMemoryIfNeeded(void) {
     /* When clients are paused the dataset should be static not just from the
      * POV of clients not being able to write, but also from the POV of
      * expires and evictions of keys not being performed. */
-    if (clientsArePaused()) return C_OK;
-    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK)
+    if (clientsArePaused()) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
+    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK) {
+        __A_VARIABLE = 1;
         return C_OK;
+    }
 
     mem_freed = 0;
 
@@ -608,6 +642,7 @@ int freeMemoryIfNeeded(void) {
     }
     latencyEndMonitor(latency);
     latencyAddSampleIfNeeded("eviction-cycle",latency);
+    __A_VARIABLE = 1;
     return C_OK;
 
 cant_free:
@@ -619,6 +654,7 @@ cant_free:
             break;
         usleep(1000);
     }
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -630,6 +666,10 @@ cant_free:
  *
  */
 int freeMemoryIfNeededAndSafe(void) {
-    if (server.lua_timedout || server.loading) return C_OK;
+    if (server.lua_timedout || server.loading) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
+    __A_VARIABLE = 1;
     return freeMemoryIfNeeded();
 }
diff --git a/src/expire.c b/src/expire.c
index 0b92ee3..a4a6bcf 100644
--- a/src/expire.c
+++ b/src/expire.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Implementation of EXPIRE (keys with fixed time to live).
  *
  * ----------------------------------------------------------------------------
@@ -108,14 +109,23 @@ void activeExpireCycle(int type) {
     /* When clients are paused the dataset should be static not just from the
      * POV of clients not being able to write, but also from the POV of
      * expires and evictions of keys not being performed. */
-    if (clientsArePaused()) return;
+    if (clientsArePaused()) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
         /* Don't start a fast cycle if the previous cycle did not exit
          * for time limit. Also don't repeat a fast cycle for the same period
          * as the fast cycle total duration itself. */
-        if (!timelimit_exit) return;
-        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
+        if (!timelimit_exit) {
+            __A_VARIABLE = 1;
+            return;
+        }
+        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) {
+            __A_VARIABLE = 1;
+            return;
+        }
         last_fast_cycle = start;
     }
 
@@ -241,6 +251,7 @@ void activeExpireCycle(int type) {
         current_perc = 0;
     server.stat_expired_stale_perc = (current_perc*0.05)+
                                      (server.stat_expired_stale_perc*0.95);
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -284,7 +295,10 @@ dict *slaveKeysWithExpire = NULL;
  * check if they should be evicted. */
 void expireSlaveKeys(void) {
     if (slaveKeysWithExpire == NULL ||
-        dictSize(slaveKeysWithExpire) == 0) return;
+        dictSize(slaveKeysWithExpire) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     int cycles = 0, noexpire = 0;
     mstime_t start = mstime();
@@ -337,6 +351,7 @@ void expireSlaveKeys(void) {
         if ((cycles % 64) == 0 && mstime()-start > 1) break;
         if (dictSize(slaveKeysWithExpire) == 0) break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Track keys that received an EXPIRE or similar command in the context
@@ -353,7 +368,10 @@ void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
         };
         slaveKeysWithExpire = dictCreate(&dt,NULL);
     }
-    if (db->id > 63) return;
+    if (db->id > 63) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
     /* If the entry was just created, set it to a copy of the SDS string
@@ -368,11 +386,16 @@ void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
     uint64_t dbids = dictGetUnsignedIntegerVal(de);
     dbids |= (uint64_t)1 << db->id;
     dictSetUnsignedIntegerVal(de,dbids);
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of keys we are tracking. */
 size_t getSlaveKeyWithExpireCount(void) {
-    if (slaveKeysWithExpire == NULL) return 0;
+    if (slaveKeysWithExpire == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return dictSize(slaveKeysWithExpire);
 }
 
@@ -389,6 +412,7 @@ void flushSlaveKeysWithExpireList(void) {
         dictRelease(slaveKeysWithExpire);
         slaveKeysWithExpire = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -452,21 +476,25 @@ void expireGenericCommand(client *c, long long basetime, int unit) {
 /* EXPIRE key seconds */
 void expireCommand(client *c) {
     expireGenericCommand(c,mstime(),UNIT_SECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* EXPIREAT key time */
 void expireatCommand(client *c) {
     expireGenericCommand(c,0,UNIT_SECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* PEXPIRE key milliseconds */
 void pexpireCommand(client *c) {
     expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* PEXPIREAT key ms_time */
 void pexpireatCommand(client *c) {
     expireGenericCommand(c,0,UNIT_MILLISECONDS);
+    __A_VARIABLE = 1;
 }
 
 /* Implements TTL and PTTL */
@@ -476,6 +504,7 @@ void ttlGenericCommand(client *c, int output_ms) {
     /* If the key does not exist at all, return -2 */
     if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
         addReplyLongLong(c,-2);
+        __A_VARIABLE = 1;
         return;
     }
     /* The key exists. Return -1 if it has no expire, or the actual
@@ -490,16 +519,19 @@ void ttlGenericCommand(client *c, int output_ms) {
     } else {
         addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
     }
+    __A_VARIABLE = 1;
 }
 
 /* TTL key */
 void ttlCommand(client *c) {
     ttlGenericCommand(c, 0);
+    __A_VARIABLE = 1;
 }
 
 /* PTTL key */
 void pttlCommand(client *c) {
     ttlGenericCommand(c, 1);
+    __A_VARIABLE = 1;
 }
 
 /* PERSIST key */
@@ -514,6 +546,7 @@ void persistCommand(client *c) {
     } else {
         addReply(c,shared.czero);
     }
+    __A_VARIABLE = 1;
 }
 
 /* TOUCH key1 [key2 key3 ... keyN] */
@@ -522,5 +555,6 @@ void touchCommand(client *c) {
     for (int j = 1; j < c->argc; j++)
         if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
     addReplyLongLong(c,touched);
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/geo.c b/src/geo.c
index f1d3f18..aab2ca2 100644
--- a/src/geo.c
+++ b/src/geo.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
  * Copyright (c) 2015-2016, Salvatore Sanfilippo <antirez@gmail.com>.
@@ -56,6 +57,7 @@ geoArray *geoArrayCreate(void) {
     ga->array = NULL;
     ga->buckets = 0;
     ga->used = 0;
+    __A_VARIABLE = 1;
     return ga;
 }
 
@@ -68,6 +70,7 @@ geoPoint *geoArrayAppend(geoArray *ga) {
     }
     geoPoint *gp = ga->array+ga->used;
     ga->used++;
+    __A_VARIABLE = 1;
     return gp;
 }
 
@@ -77,6 +80,7 @@ void geoArrayFree(geoArray *ga) {
     for (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
     zfree(ga->array);
     zfree(ga);
+    __A_VARIABLE = 1;
 }
 
 /* ====================================================================
@@ -84,6 +88,7 @@ void geoArrayFree(geoArray *ga) {
  * ==================================================================== */
 int decodeGeohash(double bits, double *xy) {
     GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };
+    __A_VARIABLE = 1;
     return geohashDecodeToLongLatWGS84(hash, xy);
 }
 
@@ -95,6 +100,7 @@ int extractLongLatOrReply(client *c, robj **argv, double *xy) {
     for (i = 0; i < 2; i++) {
         if (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
             C_OK) {
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
@@ -102,8 +108,10 @@ int extractLongLatOrReply(client *c, robj **argv, double *xy) {
         xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
         addReplySds(c, sdscatprintf(sdsempty(),
             "-ERR invalid longitude,latitude pair %f,%f\r\n",xy[0],xy[1]));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -113,8 +121,15 @@ int extractLongLatOrReply(client *c, robj **argv, double *xy) {
 int longLatFromMember(robj *zobj, robj *member, double *xy) {
     double score = 0;
 
-    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
-    if (!decodeGeohash(score, xy)) return C_ERR;
+    if (zsetScore(zobj, member->ptr, &score) == C_ERR) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
+    if (!decodeGeohash(score, xy)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -154,20 +169,24 @@ double extractDistanceOrReply(client *c, robj **argv,
     double distance;
     if (getDoubleFromObjectOrReply(c, argv[0], &distance,
                                    "need numeric radius") != C_OK) {
+        __A_VARIABLE = 1;
         return -1;
     }
 
     if (distance < 0) {
         addReplyError(c,"radius cannot be negative");
+        __A_VARIABLE = 1;
         return -1;
     }
 
     double to_meters = extractUnitOrReply(c,argv[1]);
     if (to_meters < 0) {
+        __A_VARIABLE = 1;
         return -1;
     }
 
     if (conversion) *conversion = to_meters;
+    __A_VARIABLE = 1;
     return distance * to_meters;
 }
 
@@ -180,6 +199,7 @@ void addReplyDoubleDistance(client *c, double d) {
     char dbuf[128];
     int dlen = snprintf(dbuf, sizeof(dbuf), "%.4f", d);
     addReplyBulkCBuffer(c, dbuf, dlen);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for geoGetPointsInRange(): given a sorted set score
@@ -191,12 +211,16 @@ void addReplyDoubleDistance(client *c, double d) {
 int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius, double score, sds member) {
     double distance, xy[2];
 
-    if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */
+    if (!decodeGeohash(score,xy)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Can't decode. */
     /* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
      * reverse order: longitude first, latitude later. */
     if (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],
                                            radius, &distance))
     {
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -207,6 +231,7 @@ int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius,
     gp->dist = distance;
     gp->member = member;
     gp->score = score;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -310,6 +335,7 @@ void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bit
     *min = geohashAlign52Bits(hash);
     hash.bits++;
     *max = geohashAlign52Bits(hash);
+    __A_VARIABLE = 1;
 }
 
 /* Obtain all members between the min/max of this geohash bounding box.
@@ -319,6 +345,7 @@ int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, double lon,
     GeoHashFix52Bits min, max;
 
     scoresOfGeoHashBox(hash,&min,&max);
+    __A_VARIABLE = 1;
     return geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);
 }
 
@@ -377,6 +404,7 @@ int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, d
         count += membersOfGeoHashBox(zobj, neighbors[i], ga, lon, lat, radius);
         last_processed = i;
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -394,6 +422,7 @@ static int sort_gp_asc(const void *a, const void *b) {
 }
 
 static int sort_gp_desc(const void *a, const void *b) {
+    __A_VARIABLE = 1;
     return -sort_gp_asc(a, b);
 }
 
@@ -408,6 +437,7 @@ void geoaddCommand(client *c) {
         /* Need an odd number of arguments if we got this far... */
         addReplyError(c, "syntax error. Try GEOADD key [x1] [y1] [name1] "
                          "[x2] [y2] [name2] ... ");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -429,6 +459,7 @@ void geoaddCommand(client *c) {
             for (i = 0; i < argc; i++)
                 if (argv[i]) decrRefCount(argv[i]);
             zfree(argv);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -446,6 +477,7 @@ void geoaddCommand(client *c) {
     /* Finally call ZADD that will do the work for us. */
     replaceClientCommandVector(c,argc,argv);
     zaddCommand(c);
+    __A_VARIABLE = 1;
 }
 
 #define SORT_NONE 0
@@ -675,21 +707,25 @@ void georadiusGeneric(client *c, int flags) {
 /* GEORADIUS wrapper function. */
 void georadiusCommand(client *c) {
     georadiusGeneric(c, RADIUS_COORDS);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUSBYMEMBER wrapper function. */
 void georadiusbymemberCommand(client *c) {
     georadiusGeneric(c, RADIUS_MEMBER);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUS_RO wrapper function. */
 void georadiusroCommand(client *c) {
     georadiusGeneric(c, RADIUS_COORDS|RADIUS_NOSTORE);
+    __A_VARIABLE = 1;
 }
 
 /* GEORADIUSBYMEMBER_RO wrapper function. */
 void georadiusbymemberroCommand(client *c) {
     georadiusGeneric(c, RADIUS_MEMBER|RADIUS_NOSTORE);
+    __A_VARIABLE = 1;
 }
 
 /* GEOHASH key ele1 ele2 ... eleN
@@ -702,7 +738,10 @@ void geohashCommand(client *c) {
 
     /* Look up the requested zset */
     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
-    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Geohash elements one after the other, using a null bulk reply for
      * missing elements. */
@@ -744,6 +783,7 @@ void geohashCommand(client *c) {
             addReplyBulkCBuffer(c,buf,11);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* GEOPOS key ele1 ele2 ... eleN
@@ -755,7 +795,10 @@ void geoposCommand(client *c) {
 
     /* Look up the requested zset */
     robj *zobj = lookupKeyRead(c->db, c->argv[1]);
-    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Report elements one after the other, using a null bulk reply for
      * missing elements. */
@@ -776,6 +819,7 @@ void geoposCommand(client *c) {
             addReplyHumanLongDouble(c,xy[1]);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* GEODIST key ele1 ele2 [unit]
diff --git a/src/geohash.c b/src/geohash.c
index db5ae02..4cd40fd 100644
--- a/src/geohash.c
+++ b/src/geohash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
  * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
@@ -73,6 +74,7 @@ static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
     x = (x | (x << S[0])) & B[0];
     y = (y | (y << S[0])) & B[0];
 
+    __A_VARIABLE = 1;
     return x | (y << 1);
 }
 
@@ -106,6 +108,7 @@ static inline uint64_t deinterleave64(uint64_t interleaved) {
     x = (x | (x >> S[5])) & B[5];
     y = (y | (y >> S[5])) & B[5];
 
+    __A_VARIABLE = 1;
     return x | (y << 32);
 }
 
@@ -116,6 +119,7 @@ void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
     long_range->min = GEO_LONG_MIN;
     lat_range->max = GEO_LAT_MAX;
     lat_range->min = GEO_LAT_MIN;
+    __A_VARIABLE = 1;
 }
 
 int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
@@ -123,18 +127,25 @@ int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                   GeoHashBits *hash) {
     /* Check basic arguments sanity. */
     if (hash == NULL || step > 32 || step == 0 ||
-        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;
+        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Return an error when trying to index outside the supported
      * constraints. */
     if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
-        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;
+        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     hash->bits = 0;
     hash->step = step;
 
     if (latitude < lat_range->min || latitude > lat_range->max ||
         longitude < long_range->min || longitude > long_range->max) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -147,17 +158,20 @@ int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
     lat_offset *= (1ULL << step);
     long_offset *= (1ULL << step);
     hash->bits = interleave64(lat_offset, long_offset);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
     GeoHashRange r[2] = {{0}};
     geohashGetCoordRange(&r[0], &r[1]);
+    __A_VARIABLE = 1;
     return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
 }
 
 int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                        GeoHashBits *hash) {
+    __A_VARIABLE = 1;
     return geohashEncodeType(longitude, latitude, step, hash);
 }
 
@@ -165,6 +179,7 @@ int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                    const GeoHashBits hash, GeoHashArea *area) {
     if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
         RANGEISZERO(long_range)) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -190,40 +205,53 @@ int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
     area->longitude.max =
         long_range.min + ((ilono + 1) * 1.0 / (1ull << step)) * long_scale;
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
     GeoHashRange r[2] = {{0}};
     geohashGetCoordRange(&r[0], &r[1]);
+    __A_VARIABLE = 1;
     return geohashDecode(r[0], r[1], hash, area);
 }
 
 int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
+    __A_VARIABLE = 1;
     return geohashDecodeType(hash, area);
 }
 
 int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
-    if (!xy) return 0;
+    if (!xy) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     xy[0] = (area->longitude.min + area->longitude.max) / 2;
     xy[1] = (area->latitude.min + area->latitude.max) / 2;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
     GeoHashArea area = {{0}};
-    if (!xy || !geohashDecodeType(hash, &area))
+    if (!xy || !geohashDecodeType(hash, &area)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return geohashDecodeAreaToLongLat(&area, xy);
 }
 
 int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
+    __A_VARIABLE = 1;
     return geohashDecodeToLongLatType(hash, xy);
 }
 
 static void geohash_move_x(GeoHashBits *hash, int8_t d) {
-    if (d == 0)
+    if (d == 0) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
     uint64_t y = hash->bits & 0x5555555555555555ULL;
@@ -239,11 +267,14 @@ static void geohash_move_x(GeoHashBits *hash, int8_t d) {
 
     x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
     hash->bits = (x | y);
+    __A_VARIABLE = 1;
 }
 
 static void geohash_move_y(GeoHashBits *hash, int8_t d) {
-    if (d == 0)
+    if (d == 0) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
     uint64_t y = hash->bits & 0x5555555555555555ULL;
@@ -257,6 +288,7 @@ static void geohash_move_y(GeoHashBits *hash, int8_t d) {
     }
     y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
     hash->bits = (x | y);
+    __A_VARIABLE = 1;
 }
 
 void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
@@ -292,4 +324,5 @@ void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
 
     geohash_move_x(&neighbors->south_west, -1);
     geohash_move_y(&neighbors->south_west, -1);
+    __A_VARIABLE = 1;
 }
diff --git a/src/geohash_helper.c b/src/geohash_helper.c
index e23f17b..9161286 100644
--- a/src/geohash_helper.c
+++ b/src/geohash_helper.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2013-2014, yinqiwen <yinqiwen@gmail.com>
  * Copyright (c) 2014, Matt Stancliff <matt@genges.com>.
@@ -54,13 +55,18 @@ const double EARTH_RADIUS_IN_METERS = 6372797.560856;
 const double MERCATOR_MAX = 20037726.37;
 const double MERCATOR_MIN = -20037726.37;
 
-static inline double deg_rad(double ang) { return ang * D_R; }
-static inline double rad_deg(double ang) { return ang / D_R; }
+static inline double deg_rad(double ang) { __A_VARIABLE = 1;
+	return ang * D_R; }
+static inline double rad_deg(double ang) { __A_VARIABLE = 1;
+	return ang / D_R; }
 
 /* This function is used in order to estimate the step (bits precision)
  * of the 9 search area boxes during radius queries. */
 uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
-    if (range_meters == 0) return 26;
+    if (range_meters == 0) {
+        __A_VARIABLE = 1;
+        return 26;
+    }
     int step = 1;
     while (range_meters < MERCATOR_MAX) {
         range_meters *= 2;
@@ -79,6 +85,7 @@ uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
     /* Frame to valid range. */
     if (step < 1) step = 1;
     if (step > 26) step = 26;
+    __A_VARIABLE = 1;
     return step;
 }
 
@@ -102,12 +109,16 @@ uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
  * should be fixed. */
 int geohashBoundingBox(double longitude, double latitude, double radius_meters,
                        double *bounds) {
-    if (!bounds) return 0;
+    if (!bounds) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     bounds[0] = longitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
     bounds[2] = longitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
     bounds[1] = latitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
     bounds[3] = latitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -193,17 +204,20 @@ GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double
     radius.hash = hash;
     radius.neighbors = neighbors;
     radius.area = area;
+    __A_VARIABLE = 1;
     return radius;
 }
 
 GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,
                                            double radius_meters) {
+    __A_VARIABLE = 1;
     return geohashGetAreasByRadius(longitude, latitude, radius_meters);
 }
 
 GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
     uint64_t bits = hash.bits;
     bits <<= (52 - hash.step * 2);
+    __A_VARIABLE = 1;
     return bits;
 }
 
@@ -216,6 +230,7 @@ double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d
     lon2r = deg_rad(lon2d);
     u = sin((lat2r - lat1r) / 2);
     v = sin((lon2r - lon1r) / 2);
+    __A_VARIABLE = 1;
     return 2.0 * EARTH_RADIUS_IN_METERS *
            asin(sqrt(u * u + cos(lat1r) * cos(lat2r) * v * v));
 }
@@ -224,12 +239,17 @@ int geohashGetDistanceIfInRadius(double x1, double y1,
                                  double x2, double y2, double radius,
                                  double *distance) {
     *distance = geohashGetDistance(x1, y1, x2, y2);
-    if (*distance > radius) return 0;
+    if (*distance > radius) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                       double y2, double radius,
                                       double *distance) {
+    __A_VARIABLE = 1;
     return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
 }
diff --git a/src/hyperloglog.c b/src/hyperloglog.c
index a2c789d..2aebb10 100644
--- a/src/hyperloglog.c
+++ b/src/hyperloglog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* hyperloglog.c - Redis HyperLogLog probabilistic cardinality approximation.
  * This file implements the algorithm and the exported Redis commands.
  *
@@ -442,6 +443,7 @@ uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
     h ^= h >> r;
     h *= m;
     h ^= h >> r;
+    __A_VARIABLE = 1;
     return h;
 }
 
@@ -475,6 +477,7 @@ int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
         bit <<= 1;
     }
     *regp = (int) index;
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -512,6 +515,7 @@ int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
     long index;
     uint8_t count = hllPatLen(ele,elesize,&index);
     /* Update the register if this element produced a longer run of zeroes. */
+    __A_VARIABLE = 1;
     return hllDenseSet(registers,index,count);
 }
 
@@ -571,6 +575,7 @@ void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
             reghisto[reg]++;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* ================== Sparse representation implementation  ================= */
@@ -589,7 +594,10 @@ int hllSparseToDense(robj *o) {
 
     /* If the representation is already the right one return ASAP. */
     hdr = (struct hllhdr*) sparse;
-    if (hdr->encoding == HLL_DENSE) return C_OK;
+    if (hdr->encoding == HLL_DENSE) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Create a string of the right size filled with zero bytes.
      * Note that the cached cardinality is set to 0 as a side effect
@@ -627,12 +635,14 @@ int hllSparseToDense(robj *o) {
      * set to HLL_REGISTERS. */
     if (idx != HLL_REGISTERS) {
         sdsfree(dense);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     /* Free the old representation and set the new one. */
     sdsfree(o->ptr);
     o->ptr = dense;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -700,7 +710,10 @@ int hllSparseSet(robj *o, long index, uint8_t count) {
         p += oplen;
         first += span;
     }
-    if (span == 0 || p >= end) return -1; /* Invalid format. */
+    if (span == 0 || p >= end) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Invalid format. */
 
     next = HLL_SPARSE_IS_XZERO(p) ? p+2 : p+1;
     if (next >= end) next = NULL;
@@ -743,7 +756,10 @@ int hllSparseSet(robj *o, long index, uint8_t count) {
     if (is_val) {
         oldcount = HLL_SPARSE_VAL_VALUE(p);
         /* Case A. */
-        if (oldcount >= count) return 0;
+        if (oldcount >= count) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
 
         /* Case B. */
         if (runlen == 1) {
@@ -876,10 +892,14 @@ updated:
     /* Invalidate the cached cardinality. */
     hdr = o->ptr;
     HLL_INVALIDATE_CACHE(hdr);
+    __A_VARIABLE = 1;
     return 1;
 
 promote: /* Promote to dense representation. */
-    if (hllSparseToDense(o) == C_ERR) return -1; /* Corrupted HLL. */
+    if (hllSparseToDense(o) == C_ERR) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Corrupted HLL. */
     hdr = o->ptr;
 
     /* We need to call hllDenseAdd() to perform the operation after the
@@ -891,6 +911,7 @@ promote: /* Promote to dense representation. */
      * conversion, it will be performed in all the slaves as well. */
     int dense_retval = hllDenseSet(hdr->registers,index,count);
     serverAssert(dense_retval == 1);
+    __A_VARIABLE = 1;
     return dense_retval;
 }
 
@@ -904,6 +925,7 @@ int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
     long index;
     uint8_t count = hllPatLen(ele,elesize,&index);
     /* Update the register if this element produced a longer run of zeroes. */
+    __A_VARIABLE = 1;
     return hllSparseSet(o,index,count);
 }
 
@@ -932,6 +954,7 @@ void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghis
         }
     }
     if (idx != HLL_REGISTERS && invalid) *invalid = 1;
+    __A_VARIABLE = 1;
 }
 
 /* ========================= HyperLogLog Count ==============================
@@ -963,13 +986,17 @@ void hllRawRegHisto(uint8_t *registers, int* reghisto) {
         }
         word++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function sigma as defined in
  * "New cardinality estimation algorithms for HyperLogLog sketches"
  * Otmar Ertl, arXiv:1702.01284 */
 double hllSigma(double x) {
-    if (x == 1.) return INFINITY;
+    if (x == 1.) {
+        __A_VARIABLE = 1;
+        return INFINITY;
+    }
     double zPrime;
     double y = 1;
     double z = x;
@@ -979,6 +1006,7 @@ double hllSigma(double x) {
         z += x * y;
         y += y;
     } while(zPrime != z);
+    __A_VARIABLE = 1;
     return z;
 }
 
@@ -986,7 +1014,10 @@ double hllSigma(double x) {
  * "New cardinality estimation algorithms for HyperLogLog sketches"
  * Otmar Ertl, arXiv:1702.01284 */
 double hllTau(double x) {
-    if (x == 0. || x == 1.) return 0.;
+    if (x == 0. || x == 1.) {
+        __A_VARIABLE = 1;
+        return 0.;
+    }
     double zPrime;
     double y = 1.0;
     double z = 1 - x;
@@ -996,6 +1027,7 @@ double hllTau(double x) {
         y *= 0.5;
         z -= pow(1 - x, 2)*y;
     } while(zPrime != z);
+    __A_VARIABLE = 1;
     return z / 3;
 }
 
@@ -1044,6 +1076,7 @@ uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
     z += m * hllSigma(reghisto[0]/(double)m);
     E = llroundl(HLL_ALPHA_INF*m*m/z);
 
+    __A_VARIABLE = 1;
     return (uint64_t) E;
 }
 
@@ -1051,9 +1084,12 @@ uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
 int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
     struct hllhdr *hdr = o->ptr;
     switch(hdr->encoding) {
-    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
-    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
-    default: return -1; /* Invalid representation. */
+    case HLL_DENSE: __A_VARIABLE = 1;
+        return hllDenseAdd(hdr->registers,ele,elesize);
+    case HLL_SPARSE: __A_VARIABLE = 1;
+        return hllSparseAdd(o,ele,elesize);
+    default: __A_VARIABLE = 1;
+        return -1; /* Invalid representation. */
     }
 }
 
@@ -1140,6 +1176,7 @@ robj *createHLLObject(void) {
     hdr = o->ptr;
     memcpy(hdr->magic,"HYLL",4);
     hdr->encoding = HLL_SPARSE;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -1150,8 +1187,10 @@ int isHLLObjectOrReply(client *c, robj *o) {
     struct hllhdr *hdr;
 
     /* Key exists, check type */
-    if (checkType(c,o,OBJ_STRING))
-        return C_ERR; /* Error already sent. */
+    if (checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Error already sent. */
 
     if (!sdsEncodedObject(o)) goto invalid;
     if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
@@ -1168,12 +1207,14 @@ int isHLLObjectOrReply(client *c, robj *o) {
         stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
 
     /* All tests passed. */
+    __A_VARIABLE = 1;
     return C_OK;
 
 invalid:
     addReplySds(c,
         sdsnew("-WRONGTYPE Key is not a valid "
                "HyperLogLog string value.\r\n"));
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1322,7 +1363,10 @@ void pfmergeCommand(client *c) {
         /* Check type and size. */
         robj *o = lookupKeyRead(c->db,c->argv[j]);
         if (o == NULL) continue; /* Assume empty HLL for non existing var. */
-        if (isHLLObjectOrReply(c,o) != C_OK) return;
+        if (isHLLObjectOrReply(c,o) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
 
         /* If at least one involved HLL is dense, use the dense representation
          * as target ASAP to save time and avoid the conversion step. */
@@ -1333,6 +1377,7 @@ void pfmergeCommand(client *c) {
          * to MAX(max[i],hll[i]). */
         if (hllMerge(max,o) == C_ERR) {
             addReplySds(c,sdsnew(invalid_hll_err));
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -1356,6 +1401,7 @@ void pfmergeCommand(client *c) {
      * one of the inputs was dense. */
     if (use_dense && hllSparseToDense(o) == C_ERR) {
         addReplySds(c,sdsnew(invalid_hll_err));
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1379,6 +1425,7 @@ void pfmergeCommand(client *c) {
     notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* ========================== Testing / Debugging  ========================== */
@@ -1487,6 +1534,7 @@ void pfselftestCommand(client *c) {
 cleanup:
     sdsfree(bitcounters);
     if (o) decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* PFDEBUG <subcommand> <key> ... args ...
diff --git a/src/intset.c b/src/intset.c
index 758445e..87b9eaf 100644
--- a/src/intset.c
+++ b/src/intset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -49,6 +50,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -93,6 +95,7 @@ static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
 
 /* Return the value at pos, using the configured encoding. */
 static int64_t _intsetGet(intset *is, int pos) {
+    __A_VARIABLE = 1;
     return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));
 }
 
@@ -110,6 +113,7 @@ static void _intsetSet(intset *is, int pos, int64_t value) {
         ((int16_t*)is->contents)[pos] = value;
         memrev16ifbe(((int16_t*)is->contents)+pos);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create an empty intset. */
@@ -117,6 +121,7 @@ intset *intsetNew(void) {
     intset *is = zmalloc(sizeof(intset));
     is->encoding = intrev32ifbe(INTSET_ENC_INT16);
     is->length = 0;
+    __A_VARIABLE = 1;
     return is;
 }
 
@@ -124,6 +129,7 @@ intset *intsetNew(void) {
 static intset *intsetResize(intset *is, uint32_t len) {
     uint32_t size = len*intrev32ifbe(is->encoding);
     is = zrealloc(is,sizeof(intset)+size);
+    __A_VARIABLE = 1;
     return is;
 }
 
@@ -195,6 +201,7 @@ static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
     else
         _intsetSet(is,intrev32ifbe(is->length),value);
     is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
+    __A_VARIABLE = 1;
     return is;
 }
 
@@ -217,6 +224,7 @@ static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
         bytes *= sizeof(int16_t);
     }
     memmove(dst,src,bytes);
+    __A_VARIABLE = 1;
 }
 
 /* Insert an integer in the intset */
@@ -266,17 +274,20 @@ intset *intsetRemove(intset *is, int64_t value, int *success) {
         is = intsetResize(is,len-1);
         is->length = intrev32ifbe(len-1);
     }
+    __A_VARIABLE = 1;
     return is;
 }
 
 /* Determine whether a value belongs to this set */
 uint8_t intsetFind(intset *is, int64_t value) {
     uint8_t valenc = _intsetValueEncoding(value);
+    __A_VARIABLE = 1;
     return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
 }
 
 /* Return random member */
 int64_t intsetRandom(intset *is) {
+    __A_VARIABLE = 1;
     return _intsetGet(is,rand()%intrev32ifbe(is->length));
 }
 
@@ -285,18 +296,22 @@ int64_t intsetRandom(intset *is) {
 uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
     if (pos < intrev32ifbe(is->length)) {
         *value = _intsetGet(is,pos);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Return intset length */
 uint32_t intsetLen(const intset *is) {
+    __A_VARIABLE = 1;
     return intrev32ifbe(is->length);
 }
 
 /* Return intset blob size in bytes. */
 size_t intsetBlobLen(intset *is) {
+    __A_VARIABLE = 1;
     return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
 }
 
@@ -320,11 +335,13 @@ static void error(char *err) {
 
 static void ok(void) {
     printf("OK\n");
+    __A_VARIABLE = 1;
 }
 
 static long long usec(void) {
     struct timeval tv;
     gettimeofday(&tv,NULL);
+    __A_VARIABLE = 1;
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
@@ -332,6 +349,7 @@ static long long usec(void) {
 static void _assert(char *estr, char *file, int line) {
     printf("\n\n=== ASSERTION FAILED ===\n");
     printf("==> %s:%d '%s' is not true\n",file,line,estr);
+    __A_VARIABLE = 1;
 }
 
 static intset *createSet(int bits, int size) {
@@ -347,6 +365,7 @@ static intset *createSet(int bits, int size) {
         }
         is = intsetAdd(is,value,NULL);
     }
+    __A_VARIABLE = 1;
     return is;
 }
 
@@ -365,6 +384,7 @@ static void checkConsistency(intset *is) {
             assert(i64[i] < i64[i+1]);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
@@ -506,6 +526,7 @@ int intsetTest(int argc, char **argv) {
         ok();
     }
 
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/latency.c b/src/latency.c
index 97e6a70..8eca6d5 100644
--- a/src/latency.c
+++ b/src/latency.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The latency monitor allows to easily observe the sources of latency
  * in a Redis instance using the LATENCY command. Different latency
  * sources are monitored, like disk I/O, execution of commands, fork
@@ -38,10 +39,12 @@
 /* Dictionary type for latency events. */
 int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {
     UNUSED(privdata);
+    __A_VARIABLE = 1;
     return strcmp(key1,key2) == 0;
 }
 
 uint64_t dictStringHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction(key, strlen(key));
 }
 
@@ -65,12 +68,17 @@ int THPIsEnabled(void) {
     char buf[1024];
 
     FILE *fp = fopen("/sys/kernel/mm/transparent_hugepage/enabled","r");
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (fgets(buf,sizeof(buf),fp) == NULL) {
         fclose(fp);
+        __A_VARIABLE = 1;
         return 0;
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return (strstr(buf,"[never]") == NULL) ? 1 : 0;
 }
 #endif
@@ -79,6 +87,7 @@ int THPIsEnabled(void) {
  * value of the function is non-zero, the process is being targeted by
  * THP support, and is likely to have memory usage / latency issues. */
 int THPGetAnonHugePagesSize(void) {
+    __A_VARIABLE = 1;
     return zmalloc_get_smap_bytes_by_field("AnonHugePages:",-1);
 }
 
@@ -89,6 +98,7 @@ int THPGetAnonHugePagesSize(void) {
  * having a fixed list to maintain. */
 void latencyMonitorInit(void) {
     server.latency_events = dictCreate(&latencyTimeSeriesDictType,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Add the specified sample to the specified time series "event".
@@ -117,6 +127,7 @@ void latencyAddSample(char *event, mstime_t latency) {
     if (ts->samples[prev].time == now) {
         if (latency > ts->samples[prev].latency)
             ts->samples[prev].latency = latency;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -125,6 +136,7 @@ void latencyAddSample(char *event, mstime_t latency) {
 
     ts->idx++;
     if (ts->idx == LATENCY_TS_LEN) ts->idx = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Reset data for the specified event, or all the events data if 'event' is
@@ -147,6 +159,7 @@ int latencyResetEvent(char *event_to_reset) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return resets;
 }
 
@@ -169,7 +182,10 @@ void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
     ls->mad = 0;
     ls->samples = 0;
     ls->period = 0;
-    if (!ts) return;
+    if (!ts) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* First pass, populate everything but the MAD. */
     sum = 0;
@@ -211,6 +227,7 @@ void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
         sum += delta;
     }
     if (ls->samples) ls->mad = sum / ls->samples;
+    __A_VARIABLE = 1;
 }
 
 /* Create a human readable report of latency events for this Redis instance. */
@@ -240,6 +257,7 @@ sds createLatencyReport(void) {
         server.latency_monitor_threshold == 0)
     {
         report = sdscat(report,"I'm sorry, Dave, I can't do that. Latency monitoring is disabled in this Redis instance. You may use \"CONFIG SET latency-monitor-threshold <milliseconds>.\" in order to enable it. If we weren't in a deep space mission I'd suggest to take a look at http://redis.io/topics/latency-monitor.\n");
+        __A_VARIABLE = 1;
         return report;
     }
 
@@ -468,6 +486,7 @@ sds createLatencyReport(void) {
         }
     }
 
+    __A_VARIABLE = 1;
     return report;
 }
 
@@ -489,6 +508,7 @@ void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
         samples++;
     }
     setDeferredMultiBulkLength(c,replylen,samples);
+    __A_VARIABLE = 1;
 }
 
 /* latencyCommand() helper to produce the reply for the LATEST subcommand,
@@ -511,6 +531,7 @@ void latencyCommandReplyWithLatestEvents(client *c) {
         addReplyLongLong(c,ts->max);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 #define LATENCY_GRAPH_COLS 80
@@ -555,6 +576,7 @@ sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
     graph = sdscatlen(graph,"\n",1);
     graph = sparklineRender(graph,seq,LATENCY_GRAPH_COLS,4,SPARKLINE_FILL);
     freeSparklineSequence(seq);
+    __A_VARIABLE = 1;
     return graph;
 }
 
@@ -626,6 +648,7 @@ NULL
     } else {
         addReplySubcommandSyntaxError(c);
     }
+    __A_VARIABLE = 1;
     return;
 
 nodataerr:
@@ -633,5 +656,6 @@ nodataerr:
      * information about. */
     addReplyErrorFormat(c,
         "No samples available for event '%s'", (char*) c->argv[2]->ptr);
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/lazyfree.c b/src/lazyfree.c
index 3d3159c..8276cc8 100644
--- a/src/lazyfree.c
+++ b/src/lazyfree.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "server.h"
 #include "bio.h"
 #include "atomicvar.h"
@@ -10,6 +11,7 @@ pthread_mutex_t lazyfree_objects_mutex = PTHREAD_MUTEX_INITIALIZER;
 size_t lazyfreeGetPendingObjectsCount(void) {
     size_t aux;
     atomicGet(lazyfree_objects,aux);
+    __A_VARIABLE = 1;
     return aux;
 }
 
@@ -99,6 +101,7 @@ void freeObjAsync(robj *o) {
     } else {
         decrRefCount(o);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Empty a Redis DB asynchronously. What the function does actually is to
@@ -110,6 +113,7 @@ void emptyDbAsync(redisDb *db) {
     db->expires = dictCreate(&keyptrDictType,NULL);
     atomicIncr(lazyfree_objects,dictSize(oldht1));
     bioCreateBackgroundJob(BIO_LAZY_FREE,NULL,oldht1,oldht2);
+    __A_VARIABLE = 1;
 }
 
 /* Empty the slots-keys map of Redis CLuster by creating a new empty one
@@ -122,6 +126,7 @@ void slotToKeyFlushAsync(void) {
            sizeof(server.cluster->slots_keys_count));
     atomicIncr(lazyfree_objects,old->numele);
     bioCreateBackgroundJob(BIO_LAZY_FREE,NULL,NULL,old);
+    __A_VARIABLE = 1;
 }
 
 /* Release objects from the lazyfree thread. It's just decrRefCount()
@@ -129,6 +134,7 @@ void slotToKeyFlushAsync(void) {
 void lazyfreeFreeObjectFromBioThread(robj *o) {
     decrRefCount(o);
     atomicDecr(lazyfree_objects,1);
+    __A_VARIABLE = 1;
 }
 
 /* Release a database from the lazyfree thread. The 'db' pointer is the
@@ -141,6 +147,7 @@ void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2) {
     dictRelease(ht1);
     dictRelease(ht2);
     atomicDecr(lazyfree_objects,numkeys);
+    __A_VARIABLE = 1;
 }
 
 /* Release the skiplist mapping Redis Cluster keys to slots in the
@@ -149,4 +156,5 @@ void lazyfreeFreeSlotsMapFromBioThread(rax *rt) {
     size_t len = rt->numele;
     raxFree(rt);
     atomicDecr(lazyfree_objects,len);
+    __A_VARIABLE = 1;
 }
diff --git a/src/listpack.c b/src/listpack.c
index e1f4d9a..ead2e50 100644
--- a/src/listpack.c
+++ b/src/listpack.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Listpack -- A lists of strings serialization format
  *
  * This file implements the specification you can find at:
@@ -205,16 +206,21 @@ int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
  * On success the new listpack is returned, otherwise an error is returned. */
 unsigned char *lpNew(void) {
     unsigned char *lp = lp_malloc(LP_HDR_SIZE+1);
-    if (lp == NULL) return NULL;
+    if (lp == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     lpSetTotalBytes(lp,LP_HDR_SIZE+1);
     lpSetNumElements(lp,0);
     lp[LP_HDR_SIZE] = LP_EOF;
+    __A_VARIABLE = 1;
     return lp;
 }
 
 /* Free the specified listpack. */
 void lpFree(unsigned char *lp) {
     lp_free(lp);
+    __A_VARIABLE = 1;
 }
 
 /* Given an element 'ele' of size 'size', determine if the element can be
@@ -340,8 +346,12 @@ uint64_t lpDecodeBacklen(unsigned char *p) {
         if (!(p[0] & 128)) break;
         shift += 7;
         p--;
-        if (shift > 28) return UINT64_MAX;
+        if (shift > 28) {
+            __A_VARIABLE = 1;
+            return UINT64_MAX;
+        }
     } while(1);
+    __A_VARIABLE = 1;
     return val;
 }
 
@@ -365,21 +375,53 @@ void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
         buf[4] = (len >> 24) & 0xff;
         memcpy(buf+5,s,len);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the encoded length of the listpack element pointed by 'p'. If the
  * element encoding is wrong then 0 is returned. */
 uint32_t lpCurrentEncodedSize(unsigned char *p) {
-    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
-    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
-    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
-    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
-    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
-    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
-    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
-    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
-    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
-    if (p[0] == LP_EOF) return 1;
+    if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (LP_ENCODING_IS_6BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 1+LP_ENCODING_6BIT_STR_LEN(p);
+    }
+    if (LP_ENCODING_IS_13BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 2;
+    }
+    if (LP_ENCODING_IS_16BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 3;
+    }
+    if (LP_ENCODING_IS_24BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 4;
+    }
+    if (LP_ENCODING_IS_32BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 5;
+    }
+    if (LP_ENCODING_IS_64BIT_INT(p[0])) {
+        __A_VARIABLE = 1;
+        return 9;
+    }
+    if (LP_ENCODING_IS_12BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 2+LP_ENCODING_12BIT_STR_LEN(p);
+    }
+    if (LP_ENCODING_IS_32BIT_STR(p[0])) {
+        __A_VARIABLE = 1;
+        return 5+LP_ENCODING_32BIT_STR_LEN(p);
+    }
+    if (p[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -391,6 +433,7 @@ unsigned char *lpSkip(unsigned char *p) {
     unsigned long entrylen = lpCurrentEncodedSize(p);
     entrylen += lpEncodeBacklen(NULL,entrylen);
     p += entrylen;
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -400,7 +443,11 @@ unsigned char *lpSkip(unsigned char *p) {
 unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
     ((void) lp); /* lp is not used for now. However lpPrev() uses it. */
     p = lpSkip(p);
-    if (p[0] == LP_EOF) return NULL;
+    if (p[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -408,10 +455,14 @@ unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
  * the pointer to the preivous element (the one on the left), or NULL if 'p'
  * already pointed to the first element of the listpack. */
 unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
-    if (p-lp == LP_HDR_SIZE) return NULL;
+    if (p-lp == LP_HDR_SIZE) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     p--; /* Seek the first backlen byte of the last element. */
     uint64_t prevlen = lpDecodeBacklen(p);
     prevlen += lpEncodeBacklen(NULL,prevlen);
+    __A_VARIABLE = 1;
     return p-prevlen+1; /* Seek the first byte of the previous entry. */
 }
 
@@ -419,7 +470,11 @@ unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
  * listpack has no elements. */
 unsigned char *lpFirst(unsigned char *lp) {
     lp += LP_HDR_SIZE; /* Skip the header. */
-    if (lp[0] == LP_EOF) return NULL;
+    if (lp[0] == LP_EOF) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return lp;
 }
 
@@ -427,6 +482,7 @@ unsigned char *lpFirst(unsigned char *lp) {
  * listpack has no elements. */
 unsigned char *lpLast(unsigned char *lp) {
     unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
+    __A_VARIABLE = 1;
     return lpPrev(lp,p); /* Will return NULL if EOF is the only element. */
 }
 
@@ -437,7 +493,10 @@ unsigned char *lpLast(unsigned char *lp) {
  * the 'numele' header field range, the new value is set. */
 uint32_t lpLength(unsigned char *lp) {
     uint32_t numele = lpGetNumElements(lp);
-    if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;
+    if (numele != LP_HDR_NUMELE_UNKNOWN) {
+        __A_VARIABLE = 1;
+        return numele;
+    }
 
     /* Too many elements inside the listpack. We need to scan in order
      * to get the total number. */
@@ -451,6 +510,7 @@ uint32_t lpLength(unsigned char *lp) {
     /* If the count is again within range of the header numele field,
      * set it. */
     if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -645,7 +705,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     uint64_t new_listpack_bytes = old_listpack_bytes + enclen + backlen_size
                                   - replaced_len;
-    if (new_listpack_bytes > UINT32_MAX) return NULL;
+    if (new_listpack_bytes > UINT32_MAX) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* We now need to reallocate in order to make space or shrink the
      * allocation (in case 'when' value is LP_REPLACE and the new element is
@@ -657,7 +720,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     /* Realloc before: we need more room. */
     if (new_listpack_bytes > old_listpack_bytes) {
-        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
+        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         dst = lp + poff;
     }
 
@@ -674,7 +740,10 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 
     /* Realloc after: we need to free space. */
     if (new_listpack_bytes < old_listpack_bytes) {
-        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) return NULL;
+        if ((lp = lp_realloc(lp,new_listpack_bytes)) == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         dst = lp + poff;
     }
 
@@ -727,6 +796,7 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
     lp_free(oldlp);
 #endif
 
+    __A_VARIABLE = 1;
     return lp;
 }
 
@@ -736,6 +806,7 @@ unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, un
 unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
     uint64_t listpack_bytes = lpGetTotalBytes(lp);
     unsigned char *eofptr = lp + listpack_bytes - 1;
+    __A_VARIABLE = 1;
     return lpInsert(lp,ele,size,eofptr,LP_BEFORE,NULL);
 }
 
@@ -744,11 +815,13 @@ unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
  * deleted one) is returned by reference. If the deleted element was the
  * last one, '*newp' is set to NULL. */
 unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
+    __A_VARIABLE = 1;
     return lpInsert(lp,NULL,0,p,LP_REPLACE,newp);
 }
 
 /* Return the total number of bytes the listpack is composed of. */
 uint32_t lpBytes(unsigned char *lp) {
+    __A_VARIABLE = 1;
     return lpGetTotalBytes(lp);
 }
 
diff --git a/src/localtime.c b/src/localtime.c
index 3f59a33..9adbdb5 100644
--- a/src/localtime.c
+++ b/src/localtime.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -101,6 +102,7 @@ void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
 
     tmp->tm_mday = days+1;  /* Add 1 since our 'days' is zero-based. */
     tmp->tm_year -= 1900;   /* Surprisingly tm_year is year-1900. */
+    __A_VARIABLE = 1;
 }
 
 #ifdef LOCALTIME_TEST_MAIN
@@ -119,5 +121,6 @@ int main(void) {
     nolocks_localtime(&tm,t,timezone,daylight_active);
     strftime(buf,sizeof(buf),"%d %b %H:%M:%S",&tm);
     printf("[timezone: %d, dl: %d] %s\n", (int)timezone, (int)daylight_active, buf);
+    __A_VARIABLE = 1;
 }
 #endif
diff --git a/src/lolwut.c b/src/lolwut.c
index 19cbcf6..da79f72 100644
--- a/src/lolwut.c
+++ b/src/lolwut.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -44,6 +45,7 @@ void lolwutUnstableCommand(client *c) {
     rendered = sdscat(rendered,REDIS_VERSION);
     rendered = sdscatlen(rendered,"\n",1);
     addReplyBulkSds(c,rendered);
+    __A_VARIABLE = 1;
 }
 
 void lolwutCommand(client *c) {
@@ -53,4 +55,5 @@ void lolwutCommand(client *c) {
         lolwut5Command(c);
     else
         lolwutUnstableCommand(c);
+    __A_VARIABLE = 1;
 }
diff --git a/src/lolwut5.c b/src/lolwut5.c
index 8408b37..9e87812 100644
--- a/src/lolwut5.c
+++ b/src/lolwut5.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2018, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -67,6 +68,7 @@ void lwTranslatePixelsGroup(int byte, char *output) {
     output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
     output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
     output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
+    __A_VARIABLE = 1;
 }
 
 /* Allocate and return a new canvas of the specified size. */
@@ -76,6 +78,7 @@ lwCanvas *lwCreateCanvas(int width, int height) {
     canvas->height = height;
     canvas->pixels = zmalloc(width*height);
     memset(canvas->pixels,0,width*height);
+    __A_VARIABLE = 1;
     return canvas;
 }
 
@@ -83,6 +86,7 @@ lwCanvas *lwCreateCanvas(int width, int height) {
 void lwFreeCanvas(lwCanvas *canvas) {
     zfree(canvas->pixels);
     zfree(canvas);
+    __A_VARIABLE = 1;
 }
 
 /* Set a pixel to the specified color. Color is 0 or 1, where zero means no
@@ -91,14 +95,22 @@ void lwFreeCanvas(lwCanvas *canvas) {
  * out of the size of the canvas without issues. */
 void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {
     if (x < 0 || x >= canvas->width ||
-        y < 0 || y >= canvas->height) return;
+        y < 0 || y >= canvas->height) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     canvas->pixels[x+y*canvas->width] = color;
+    __A_VARIABLE = 1;
 }
 
 /* Return the value of the specified pixel on the canvas. */
 int lwGetPixel(lwCanvas *canvas, int x, int y) {
     if (x < 0 || x >= canvas->width ||
-        y < 0 || y >= canvas->height) return 0;
+        y < 0 || y >= canvas->height) {
+    	__A_VARIABLE = 1;
+    	return 0;
+    }
+    __A_VARIABLE = 1;
     return canvas->pixels[x+y*canvas->width];
 }
 
@@ -123,6 +135,7 @@ void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
             y1 += sy;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Draw a square centered at the specified x,y coordinates, with the specified
@@ -165,6 +178,7 @@ void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle) {
     /* Draw the square. */
     for (int j = 0; j < 4; j++)
         lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],1);
+    __A_VARIABLE = 1;
 }
 
 /* Schotter, the output of LOLWUT of Redis 5, is a computer graphic art piece
@@ -204,6 +218,7 @@ lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_
         }
     }
 
+    __A_VARIABLE = 1;
     return canvas;
 }
 
@@ -233,6 +248,7 @@ sds lwRenderCanvas(lwCanvas *canvas) {
         }
         if (y != canvas->height-1) text = sdscatlen(text,"\n",1);
     }
+    __A_VARIABLE = 1;
     return text;
 }
 
@@ -250,16 +266,22 @@ void lolwut5Command(client *c) {
 
     /* Parse the optional arguments if any. */
     if (c->argc > 1 &&
-        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (c->argc > 2 &&
-        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (c->argc > 3 &&
-        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK)
+        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
      * so we have maximum number of columns, rows, and output resulution. */
@@ -279,4 +301,5 @@ void lolwut5Command(client *c) {
     rendered = sdscatlen(rendered,"\n",1);
     addReplyBulkSds(c,rendered);
     lwFreeCanvas(canvas);
+    __A_VARIABLE = 1;
 }
diff --git a/src/lzf_c.c b/src/lzf_c.c
index e9c69a0..3e7960d 100644
--- a/src/lzf_c.c
+++ b/src/lzf_c.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
  *
diff --git a/src/lzf_d.c b/src/lzf_d.c
index d44bfcc..71ee0cc 100644
--- a/src/lzf_d.c
+++ b/src/lzf_d.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
  *
diff --git a/src/memtest.c b/src/memtest.c
index a455430..0d2a568 100644
--- a/src/memtest.c
+++ b/src/memtest.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -73,10 +74,12 @@ void memtest_progress_start(char *title, int pass) {
     progress_printed = 0;
     progress_full = ws.ws_col*(ws.ws_row-3);
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 void memtest_progress_end(void) {
     printf("\x1b[H\x1b[2J");    /* Cursor home, clear screen. */
+    __A_VARIABLE = 1;
 }
 
 void memtest_progress_step(size_t curr, size_t size, char c) {
@@ -85,6 +88,7 @@ void memtest_progress_step(size_t curr, size_t size, char c) {
     for (j = 0; j < chars-progress_printed; j++) printf("%c",c);
     progress_printed = chars;
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Test that addressing is fine. Every location is populated with its own
@@ -111,12 +115,14 @@ int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
                     (void*) p, *p);
                 exit(1);
             }
+            __A_VARIABLE = 1;
             return 1;
         }
         p++;
         if ((j & 0xffff) == 0 && interactive)
             memtest_progress_step(j+words,words*2,'A');
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -156,6 +162,7 @@ void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
                 memtest_progress_step(w+iwords*off,words,'R');
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Like memtest_fill_random() but uses the two specified values to fill
@@ -189,6 +196,7 @@ void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                 memtest_progress_step(w+iwords*off,words,sym);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
@@ -205,6 +213,7 @@ int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
                     (void*)l1, (void*)l2, *l1, *l2);
                 exit(1);
             }
+            __A_VARIABLE = 1;
             return 1;
         }
         l1 ++;
@@ -212,6 +221,7 @@ int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
         if ((w & 0xffff) == 0 && interactive)
             memtest_progress_step(w,words,'=');
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -226,6 +236,7 @@ int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
         errors += memtest_compare(m,bytes,interactive);
         if (interactive) memtest_progress_end();
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -260,6 +271,7 @@ int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
         if (interactive) memtest_progress_end();
         errors += memtest_compare_times(m,bytes,pass,4,interactive);
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -284,8 +296,14 @@ int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
     size_t left = bytes;
     int errors = 0;
 
-    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
-    if (bytes < 4096*2) return 0; /* Can't test a single page. */
+    if (bytes & 4095) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Can't test across 4k page boundaries. */
+    if (bytes < 4096*2) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Can't test a single page. */
 
     while(left) {
         /* If we have to test a single final page, go back a single page
@@ -329,6 +347,7 @@ int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
         left -= len;
         p += len/sizeof(unsigned long);
     }
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -344,6 +363,7 @@ void memtest_alloc_and_test(size_t megabytes, int passes) {
     }
     memtest_test(m,bytes,passes,1);
     free(m);
+    __A_VARIABLE = 1;
 }
 
 void memtest(size_t megabytes, int passes) {
@@ -357,4 +377,5 @@ void memtest(size_t megabytes, int passes) {
     printf("1) memtest86: http://www.memtest86.com/\n");
     printf("2) memtester: http://pyropus.ca/software/memtester/\n");
     exit(0);
+    __A_VARIABLE = 1;
 }
diff --git a/src/module.c b/src/module.c
index d55bb4e..e149916 100644
--- a/src/module.c
+++ b/src/module.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -314,6 +315,7 @@ void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);
  * and in general is taken into account as memory allocated by Redis.
  * You should avoid using malloc(). */
 void *RM_Alloc(size_t bytes) {
+    __A_VARIABLE = 1;
     return zmalloc(bytes);
 }
 
@@ -322,11 +324,13 @@ void *RM_Alloc(size_t bytes) {
  * and in general is taken into account as memory allocated by Redis.
  * You should avoid using calloc() directly. */
 void *RM_Calloc(size_t nmemb, size_t size) {
+    __A_VARIABLE = 1;
     return zcalloc(nmemb*size);
 }
 
 /* Use like realloc() for memory obtained with RedisModule_Alloc(). */
 void* RM_Realloc(void *ptr, size_t bytes) {
+    __A_VARIABLE = 1;
     return zrealloc(ptr,bytes);
 }
 
@@ -335,10 +339,12 @@ void* RM_Realloc(void *ptr, size_t bytes) {
  * RedisModule_Free() memory allocated with malloc() inside your module. */
 void RM_Free(void *ptr) {
     zfree(ptr);
+    __A_VARIABLE = 1;
 }
 
 /* Like strdup() but returns memory allocated with RedisModule_Alloc(). */
 char *RM_Strdup(const char *str) {
+    __A_VARIABLE = 1;
     return zstrdup(str);
 }
 
@@ -356,6 +362,7 @@ void poolAllocRelease(RedisModuleCtx *ctx) {
         head = next;
     }
     ctx->pa_head = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Return heap allocated memory that will be freed automatically when the
@@ -371,7 +378,10 @@ void poolAllocRelease(RedisModuleCtx *ctx) {
  *
  * The function returns NULL if `bytes` is 0. */
 void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
-    if (bytes == 0) return NULL;
+    if (bytes == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     RedisModulePoolAllocBlock *b = ctx->pa_head;
     size_t left = b ? b->size - b->used : 0;
 
@@ -397,6 +407,7 @@ void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
 
     char *retval = b->memory + b->used;
     b->used += bytes;
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -420,8 +431,10 @@ int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
     robj *obj;
 
     /* The key must be open for writing and non existing to proceed. */
-    if (!(key->mode & REDISMODULE_WRITE) || key->value)
+    if (!(key->mode & REDISMODULE_WRITE) || key->value) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     switch(type) {
     case REDISMODULE_KEYTYPE_LIST:
@@ -435,10 +448,12 @@ int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
     case REDISMODULE_KEYTYPE_HASH:
         obj = createHashObject();
         break;
-    default: return REDISMODULE_ERR;
+    default: __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
     }
     dbAdd(key->db,key->key,obj);
     key->value = obj;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -492,8 +507,12 @@ int moduleDelKeyIfEmpty(RedisModuleKey *key) {
  * used implicitly by including redismodule.h. */
 int RM_GetApi(const char *funcname, void **targetPtrPtr) {
     dictEntry *he = dictFind(server.moduleapi, funcname);
-    if (!he) return REDISMODULE_ERR;
+    if (!he) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     *targetPtrPtr = dictGetVal(he);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -512,6 +531,7 @@ void moduleFreeContext(RedisModuleCtx *ctx) {
             ctx->module->name);
     }
     if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx->client);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for when a command callback is called, in order to handle
@@ -519,7 +539,10 @@ void moduleFreeContext(RedisModuleCtx *ctx) {
 void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
     client *c = ctx->client;
 
-    if (c->flags & CLIENT_LUA) return;
+    if (c->flags & CLIENT_LUA) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Handle the replication of the final EXEC, since whatever a command
      * emits is always wrapped around MULTI/EXEC. */
@@ -530,6 +553,7 @@ void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
             PROPAGATE_AOF|PROPAGATE_REPL);
         decrRefCount(propargv[0]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This Redis command binds the normal Redis command invocation with commands
@@ -559,6 +583,7 @@ void RedisModuleCommandDispatcher(client *c) {
         if (c->argv[i]->refcount > 1)
             trimStringObjectIfNeeded(c->argv[i]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the list of keys, with the same interface as the
@@ -581,6 +606,7 @@ int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc,
     int *res = ctx.keys_pos;
     if (numkeys) *numkeys = ctx.keys_count;
     moduleFreeContext(&ctx);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -588,6 +614,7 @@ int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc,
  * flag "getkeys-api", is called in a special way to get the keys positions
  * and not to get executed. Otherwise zero is returned. */
 int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
 }
 
@@ -606,10 +633,17 @@ int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
  *  keys are at fixed positions. This interface is only used for commands
  *  with a more complex structure. */
 void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
-    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) return;
-    if (pos <= 0) return;
+    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
+    if (pos <= 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));
     ctx->keys_pos[ctx->keys_count++] = pos;
+    __A_VARIABLE = 1;
 }
 
 /* Helper for RM_CreateCommand(). Turns a string representing command
@@ -638,7 +672,11 @@ int commandFlagsFromString(char *s) {
         else break;
     }
     sdsfreesplitres(tokens,count);
-    if (j != count) return -1; /* Some token not processed correctly. */
+    if (j != count) {
+        __A_VARIABLE = 1;
+        return -1;
+    } /* Some token not processed correctly. */
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -697,9 +735,14 @@ int commandFlagsFromString(char *s) {
  */
 int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
     int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
-    if (flags == -1) return REDISMODULE_ERR;
-    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
+    if (flags == -1) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     struct redisCommand *rediscmd;
     RedisModuleCommandProxy *cp;
@@ -708,6 +751,7 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
     /* Check if the command name is busy. */
     if (lookupCommand(cmdname) != NULL) {
         sdsfree(cmdname);
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
 
@@ -734,6 +778,7 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
     cp->rediscmd->calls = 0;
     dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);
     dictAdd(server.orig_commands,sdsdup(cmdname),cp->rediscmd);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -744,7 +789,10 @@ int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc c
 void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
     RedisModule *module;
 
-    if (ctx->module != NULL) return;
+    if (ctx->module != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     module = zmalloc(sizeof(*module));
     module->name = sdsnew((char*)name);
     module->ver = ver;
@@ -755,6 +803,7 @@ void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int api
     module->filters = listCreate();
     module->in_call = 0;
     ctx->module = module;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if the module name is busy.
@@ -763,11 +812,13 @@ int RM_IsModuleNameBusy(const char *name) {
     sds modulename = sdsnew(name);
     dictEntry *de = dictFind(modules,modulename);
     sdsfree(modulename);
+    __A_VARIABLE = 1;
     return de != NULL;
 }
 
 /* Return the current UNIX time in milliseconds. */
 long long RM_Milliseconds(void) {
+    __A_VARIABLE = 1;
     return mstime();
 }
 
@@ -781,11 +832,15 @@ long long RM_Milliseconds(void) {
  * that wants to use automatic memory. */
 void RM_AutoMemory(RedisModuleCtx *ctx) {
     ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
+    __A_VARIABLE = 1;
 }
 
 /* Add a new object to release automatically when the callback returns. */
 void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (ctx->amqueue_used == ctx->amqueue_len) {
         ctx->amqueue_len *= 2;
         if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
@@ -794,6 +849,7 @@ void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
     ctx->amqueue[ctx->amqueue_used].type = type;
     ctx->amqueue[ctx->amqueue_used].ptr = ptr;
     ctx->amqueue_used++;
+    __A_VARIABLE = 1;
 }
 
 /* Mark an object as freed in the auto release queue, so that users can still
@@ -802,7 +858,10 @@ void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
  * The function returns 1 if the object was actually found in the auto memory
  * pool, otherwise 0 is returned. */
 int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     int count = (ctx->amqueue_used+1)/2;
     for (int j = 0; j < count; j++) {
@@ -824,16 +883,21 @@ int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
                 /* Reduce the size of the queue because we either moved the top
                  * element elsewhere or freed it */
                 ctx->amqueue_used--;
+                __A_VARIABLE = 1;
                 return 1;
             }
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Release all the objects in queue. */
 void autoMemoryCollect(RedisModuleCtx *ctx) {
-    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
+    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Clear the AUTO_MEMORY flag from the context, otherwise the functions
      * we call to free the resources, will try to scan the auto release
      * queue to mark the entries as freed. */
@@ -853,6 +917,7 @@ void autoMemoryCollect(RedisModuleCtx *ctx) {
     ctx->amqueue = NULL;
     ctx->amqueue_len = 0;
     ctx->amqueue_used = 0;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -872,6 +937,7 @@ void autoMemoryCollect(RedisModuleCtx *ctx) {
 RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
     RedisModuleString *o = createStringObject(ptr,len);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -894,6 +960,7 @@ RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, .
     RedisModuleString *o = createObject(OBJ_STRING, s);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
 
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -909,6 +976,7 @@ RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, .
 RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {
     char buf[LONG_STR_SIZE];
     size_t len = ll2string(buf,sizeof(buf),ll);
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,buf,len);
 }
 
@@ -923,6 +991,7 @@ RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll
 RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
     RedisModuleString *o = dupStringObject(str);
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -941,6 +1010,7 @@ RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisMod
 void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
     decrRefCount(str);
     if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
+    __A_VARIABLE = 1;
 }
 
 /* Every call to this function, will make the string 'str' requiring
@@ -980,6 +1050,7 @@ void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
          * like RedisModule_StringAppendBuffer() to work. */
         incrRefCount(str);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Given a string module object, this function returns the string pointer
@@ -989,9 +1060,11 @@ const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
     if (str == NULL) {
         const char *errmsg = "(NULL string reply referenced in module)";
         if (len) *len = strlen(errmsg);
+        __A_VARIABLE = 1;
         return errmsg;
     }
     if (len) *len = sdslen(str->ptr);
+    __A_VARIABLE = 1;
     return str->ptr;
 }
 
@@ -1004,6 +1077,7 @@ const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
  * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR
  * is returned. */
 int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
+    __A_VARIABLE = 1;
     return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :
                                                      REDISMODULE_ERR;
 }
@@ -1013,6 +1087,7 @@ int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
  * not a valid string representation of a double value. */
 int RM_StringToDouble(const RedisModuleString *str, double *d) {
     int retval = getDoubleFromObject(str,d);
+    __A_VARIABLE = 1;
     return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -1020,6 +1095,7 @@ int RM_StringToDouble(const RedisModuleString *str, double *d) {
  * a < b, a == b, a > b. Strings are compared byte by byte as two
  * binary blobs without any encoding care / collation attempt. */
 int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {
+    __A_VARIABLE = 1;
     return compareStringObjects(a,b);
 }
 
@@ -1031,6 +1107,7 @@ RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
             "Module attempted to use an in-place string modify operation "
             "with a string referenced multiple times. Please check the code "
             "for API usage correctness.");
+        __A_VARIABLE = 1;
         return NULL;
     }
     if (str->encoding == OBJ_ENCODING_EMBSTR) {
@@ -1043,6 +1120,7 @@ RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
         str->ptr = sdsfromlonglong((long)str->ptr);
         str->encoding = OBJ_ENCODING_RAW;
     }
+    __A_VARIABLE = 1;
     return str;
 }
 
@@ -1052,8 +1130,12 @@ RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
 int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
     UNUSED(ctx);
     str = moduleAssertUnsharedString(str);
-    if (str == NULL) return REDISMODULE_ERR;
+    if (str == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     str->ptr = sdscatlen(str->ptr,buf,len);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1078,6 +1160,7 @@ int RM_WrongArity(RedisModuleCtx *ctx) {
     addReplyErrorFormat(ctx->client,
         "wrong number of arguments for '%s' command",
         (char*)ctx->client->argv[0]->ptr);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1114,8 +1197,12 @@ client *moduleGetReplyClient(RedisModuleCtx *ctx) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyLongLong(c,ll);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1124,11 +1211,15 @@ int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
  * The function always returns REDISMODULE_OK. */
 int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     sds strmsg = sdsnewlen(prefix,1);
     strmsg = sdscat(strmsg,msg);
     strmsg = sdscatlen(strmsg,"\r\n",2);
     addReplySds(c,strmsg);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1147,6 +1238,7 @@ int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
  * The function always returns REDISMODULE_OK.
  */
 int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
+    __A_VARIABLE = 1;
     return replyWithStatus(ctx,err,"-");
 }
 
@@ -1156,6 +1248,7 @@ int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
  *
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
+    __A_VARIABLE = 1;
     return replyWithStatus(ctx,msg,"+");
 }
 
@@ -1172,7 +1265,10 @@ int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {
         ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*
                 (ctx->postponed_arrays_count+1));
@@ -1182,6 +1278,7 @@ int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
     } else {
         addReplyMultiBulkLen(c,len);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1213,13 +1310,17 @@ int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
  */
 void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (ctx->postponed_arrays_count == 0) {
         serverLog(LL_WARNING,
             "API misuse detected in module %s: "
             "RedisModule_ReplySetArrayLength() called without previous "
             "RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) "
             "call.", ctx->module->name);
+            __A_VARIABLE = 1;
             return;
     }
     ctx->postponed_arrays_count--;
@@ -1230,6 +1331,7 @@ void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
         zfree(ctx->postponed_arrays);
         ctx->postponed_arrays = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Reply with a bulk string, taking in input a C buffer pointer and length.
@@ -1237,8 +1339,12 @@ void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulkCBuffer(c,(char*)buf,len);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1248,8 +1354,12 @@ int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulkCString(c,(char*)buf);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1258,8 +1368,12 @@ int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyBulk(c,str);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1269,8 +1383,12 @@ int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithNull(RedisModuleCtx *ctx) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReply(c,shared.nullbulk);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1282,9 +1400,13 @@ int RM_ReplyWithNull(RedisModuleCtx *ctx) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     sds proto = sdsnewlen(reply->proto, reply->protolen);
     addReplySds(c,proto);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1296,8 +1418,12 @@ int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
  * The function always returns REDISMODULE_OK. */
 int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
     client *c = moduleGetReplyClient(ctx);
-    if (c == NULL) return REDISMODULE_OK;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
     addReplyDouble(c,d);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1311,15 +1437,25 @@ int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
 void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {
     /* Skip this if client explicitly wrap the command with MULTI, or if
      * the module command was called by a script. */
-    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) return;
+    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* If we already emitted MULTI return ASAP. */
-    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) return;
+    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* If this is a thread safe context, we do not want to wrap commands
      * executed into MUTLI/EXEC, they are executed as single commands
      * from an external client in essence. */
-    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) return;
+    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
+        __A_VARIABLE = 1;
+        return;
+    }
     execCommandPropagateMulti(ctx->client);
     ctx->flags |= REDISMODULE_CTX_MULTI_EMITTED;
+    __A_VARIABLE = 1;
 }
 
 /* Replicate the specified command and arguments to slaves and AOF, as effect
@@ -1348,13 +1484,19 @@ int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
     va_list ap;
 
     cmd = lookupCommandByCString((char*)cmdname);
-    if (!cmd) return REDISMODULE_ERR;
+    if (!cmd) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Create the client and dispatch the command. */
     va_start(ap, fmt);
     argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
     va_end(ap);
-    if (argv == NULL) return REDISMODULE_ERR;
+    if (argv == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Replicate! */
     moduleReplicateMultiIfNeeded(ctx);
@@ -1365,6 +1507,7 @@ int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
     for (j = 0; j < argc; j++) decrRefCount(argv[j]);
     zfree(argv);
     server.dirty++;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1384,6 +1527,7 @@ int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
         ctx->client->argv,ctx->client->argc,
         PROPAGATE_AOF|PROPAGATE_REPL);
     server.dirty++;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1403,12 +1547,17 @@ int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
  * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way
  * to fetch the ID in the context the function was currently called. */
 unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {
-    if (ctx->client == NULL) return 0;
+    if (ctx->client == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return ctx->client->id;
 }
 
 /* Return the currently selected DB. */
 int RM_GetSelectedDb(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return ctx->client->db->id;
 }
 
@@ -1498,6 +1647,7 @@ int RM_GetContextFlags(RedisModuleCtx *ctx) {
     if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;
     if (level > 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;
 
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -1513,6 +1663,7 @@ int RM_GetContextFlags(RedisModuleCtx *ctx) {
  * before in order to restore the old DB number before returning. */
 int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
     int retval = selectDb(ctx->client,newid);
+    __A_VARIABLE = 1;
     return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -1559,29 +1710,43 @@ void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
 
 /* Close a key handle. */
 void RM_CloseKey(RedisModuleKey *key) {
-    if (key == NULL) return;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (key->mode & REDISMODULE_WRITE) signalModifiedKey(key->db,key->key);
     /* TODO: if (key->iter) RM_KeyIteratorStop(kp); */
     RM_ZsetRangeStop(key);
     decrRefCount(key->key);
     autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);
     zfree(key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the type of the key. If the key pointer is NULL then
  * REDISMODULE_KEYTYPE_EMPTY is returned. */
 int RM_KeyType(RedisModuleKey *key) {
-    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
+    if (key == NULL || key->value ==  NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_EMPTY;
+    }
     /* We map between defines so that we are free to change the internal
      * defines as desired. */
     switch(key->value->type) {
-    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
-    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
-    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
-    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
-    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
-    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
-    default: return 0;
+    case OBJ_STRING: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_STRING;
+    case OBJ_LIST: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_LIST;
+    case OBJ_SET: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_SET;
+    case OBJ_ZSET: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_ZSET;
+    case OBJ_HASH: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_HASH;
+    case OBJ_MODULE: __A_VARIABLE = 1;
+        return REDISMODULE_KEYTYPE_MODULE;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1591,14 +1756,23 @@ int RM_KeyType(RedisModuleKey *key) {
  *
  * If the key pointer is NULL or the key is empty, zero is returned. */
 size_t RM_ValueLength(RedisModuleKey *key) {
-    if (key == NULL || key->value == NULL) return 0;
+    if (key == NULL || key->value == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     switch(key->value->type) {
-    case OBJ_STRING: return stringObjectLen(key->value);
-    case OBJ_LIST: return listTypeLength(key->value);
-    case OBJ_SET: return setTypeSize(key->value);
-    case OBJ_ZSET: return zsetLength(key->value);
-    case OBJ_HASH: return hashTypeLength(key->value);
-    default: return 0;
+    case OBJ_STRING: __A_VARIABLE = 1;
+        return stringObjectLen(key->value);
+    case OBJ_LIST: __A_VARIABLE = 1;
+        return listTypeLength(key->value);
+    case OBJ_SET: __A_VARIABLE = 1;
+        return setTypeSize(key->value);
+    case OBJ_ZSET: __A_VARIABLE = 1;
+        return zsetLength(key->value);
+    case OBJ_HASH: __A_VARIABLE = 1;
+        return hashTypeLength(key->value);
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1607,11 +1781,15 @@ size_t RM_ValueLength(RedisModuleKey *key) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing REDISMODULE_ERR is returned. */
 int RM_DeleteKey(RedisModuleKey *key) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value) {
         dbDelete(key->db,key->key);
         key->value = NULL;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1621,11 +1799,15 @@ int RM_DeleteKey(RedisModuleKey *key) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing REDISMODULE_ERR is returned. */
 int RM_UnlinkKey(RedisModuleKey *key) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value) {
         dbAsyncDelete(key->db,key->key);
         key->value = NULL;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1634,8 +1816,12 @@ int RM_UnlinkKey(RedisModuleKey *key) {
  * REDISMODULE_NO_EXPIRE is returned. */
 mstime_t RM_GetExpire(RedisModuleKey *key) {
     mstime_t expire = getExpire(key->db,key->key);
-    if (expire == -1 || key->value == NULL) return -1;
+    if (expire == -1 || key->value == NULL) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     expire -= mstime();
+    __A_VARIABLE = 1;
     return expire >= 0 ? expire : 0;
 }
 
@@ -1649,14 +1835,17 @@ mstime_t RM_GetExpire(RedisModuleKey *key) {
  * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if
  * the key was not open for writing or is an empty key. */
 int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL)
+    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (expire != REDISMODULE_NO_EXPIRE) {
         expire += mstime();
         setExpire(key->ctx->client,key->db,key->key,expire);
     } else {
         removeExpire(key->db,key->key);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1669,10 +1858,14 @@ int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing or there is an active iterator, REDISMODULE_ERR is returned. */
 int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE) || key->iter) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     RM_DeleteKey(key);
     setKey(key->db,key->key,str);
     key->value = str;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1713,10 +1906,14 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
     char *emptystring = "<dma-empty-string>";
     if (key->value == NULL) {
         *len = 0;
+        __A_VARIABLE = 1;
         return emptystring;
     }
 
-    if (key->value->type != OBJ_STRING) return NULL;
+    if (key->value->type != OBJ_STRING) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* For write access, and even for read access if the object is encoded,
      * we unshare the string (that has the side effect of decoding it). */
@@ -1724,6 +1921,7 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
         key->value = dbUnshareStringValue(key->db, key->key, key->value);
 
     *len = sdslen(key->value->ptr);
+    __A_VARIABLE = 1;
     return key->value->ptr;
 }
 
@@ -1740,13 +1938,25 @@ char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
  * If the key is empty, a string key is created with the new string value
  * unless the new length value requested is zero. */
 int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;
-    if (newlen > 512*1024*1024) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_STRING) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (newlen > 512*1024*1024) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Empty key and new len set to 0. Just return REDISMODULE_OK without
      * doing anything. */
-    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;
+    if (key->value == NULL && newlen == 0) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_OK;
+    }
 
     if (key->value == NULL) {
         /* Empty key: create it with the new size. */
@@ -1767,6 +1977,7 @@ int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
                 key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);
         }
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1779,11 +1990,18 @@ int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
  * is created. On error (key opened for read-only operations or of the wrong
  * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */
 int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_LIST) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
     listTypePush(key->value, ele,
         (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1797,13 +2015,17 @@ int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
 RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
     if (!(key->mode & REDISMODULE_WRITE) ||
         key->value == NULL ||
-        key->value->type != OBJ_LIST) return NULL;
+        key->value->type != OBJ_LIST) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     robj *ele = listTypePop(key->value,
         (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
     robj *decoded = getDecodedObject(ele);
     decrRefCount(ele);
     moduleDelKeyIfEmpty(key);
     autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);
+    __A_VARIABLE = 1;
     return decoded;
 }
 
@@ -1817,6 +2039,7 @@ int RM_ZsetAddFlagsToCoreFlags(int flags) {
     int retflags = 0;
     if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_XX;
     if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_NX;
+    __A_VARIABLE = 1;
     return retflags;
 }
 
@@ -1826,6 +2049,7 @@ int RM_ZsetAddFlagsFromCoreFlags(int flags) {
     if (flags & ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
     if (flags & ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
     if (flags & ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;
+    __A_VARIABLE = 1;
     return retflags;
 }
 
@@ -1859,15 +2083,23 @@ int RM_ZsetAddFlagsFromCoreFlags(int flags) {
  */
 int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
     int flags = 0;
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
     if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
     if (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) {
         if (flagsptr) *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1886,21 +2118,30 @@ int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *f
  * is returned. */
 int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
     int flags = 0;
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
     if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
     flags |= ZADD_INCR;
     if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) {
         if (flagsptr) *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     /* zsetAdd() may signal back that the resulting score is not a number. */
     if (flagsptr && (*flagsptr & ZADD_NAN)) {
         *flagsptr = 0;
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
     if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1923,13 +2164,20 @@ int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int
  *
  * Empty keys will be handled correctly by doing nothing. */
 int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
-    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
-    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value && key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     if (key->value != NULL && zsetDel(key->value,ele->ptr)) {
         if (deleted) *deleted = 1;
     } else {
         if (deleted) *deleted = 0;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1942,9 +2190,19 @@ int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
  * * The key is an open empty key.
  */
 int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
-    if (key->value == NULL) return REDISMODULE_ERR;
-    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
-    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;
+    if (key->value == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    if (zsetScore(key->value,ele->ptr,score) == C_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -1956,6 +2214,7 @@ void zsetKeyReset(RedisModuleKey *key) {
     key->ztype = REDISMODULE_ZSET_RANGE_NONE;
     key->zcurrent = NULL;
     key->zer = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Stop a sorted set iteration. */
@@ -1967,10 +2226,12 @@ void RM_ZsetRangeStop(RedisModuleKey *key) {
      * iterator is not active will result into something more sensible
      * than crashing. */
     zsetKeyReset(key);
+    __A_VARIABLE = 1;
 }
 
 /* Return the "End of range" flag value to signal the end of the iteration. */
 int RM_ZsetRangeEndReached(RedisModuleKey *key) {
+    __A_VARIABLE = 1;
     return key->zer;
 }
 
@@ -1981,7 +2242,10 @@ int RM_ZsetRangeEndReached(RedisModuleKey *key) {
  * otherwise the last. Return REDISMODULE_OK on success otherwise
  * REDISMODULE_ERR. */
 int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
-    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!key->value || key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RM_ZsetRangeStop(key);
     key->ztype = REDISMODULE_ZSET_RANGE_SCORE;
@@ -2007,6 +2271,7 @@ int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, i
         serverPanic("Unsupported zset encoding");
     }
     if (key->zcurrent == NULL) key->zer = 1;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2026,12 +2291,14 @@ int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, i
  * where the min and max value are exclusive (not included) instead of
  * inclusive. */
 int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
+    __A_VARIABLE = 1;
     return zsetInitScoreRange(key,min,max,minex,maxex,1);
 }
 
 /* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of
  * the range is selected for the start of the iteration instead. */
 int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
+    __A_VARIABLE = 1;
     return zsetInitScoreRange(key,min,max,minex,maxex,0);
 }
 
@@ -2045,7 +2312,10 @@ int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int min
  * Note that this function takes 'min' and 'max' in the same form of the
  * Redis ZRANGEBYLEX command. */
 int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
-    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
+    if (!key->value || key->value->type != OBJ_ZSET) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RM_ZsetRangeStop(key);
     key->zer = 0;
@@ -2053,7 +2323,10 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
     /* Setup the range structure used by the sorted set core implementation
      * in order to seek at the specified element. */
     zlexrangespec *zlrs = &key->zlrs;
-    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;
+    if (zslParseLexRange(min, max, zlrs) == C_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     /* Set the range type to lex only after successfully parsing the range,
      * otherwise we don't want the zlexrangespec to be freed. */
@@ -2072,6 +2345,7 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
     }
     if (key->zcurrent == NULL) key->zer = 1;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2088,12 +2362,14 @@ int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleStr
  * The function does not take ownership of the objects, so they can be released
  * ASAP after the iterator is setup. */
 int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
+    __A_VARIABLE = 1;
     return zsetInitLexRange(key,min,max,1);
 }
 
 /* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of
  * the range is selected for the start of the iteration instead. */
 int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
+    __A_VARIABLE = 1;
     return zsetInitLexRange(key,min,max,0);
 }
 
@@ -2103,7 +2379,10 @@ int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModu
 RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
     RedisModuleString *str;
 
-    if (key->zcurrent == NULL) return NULL;
+    if (key->zcurrent == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *eptr, *sptr;
         eptr = key->zcurrent;
@@ -2121,6 +2400,7 @@ RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score
         serverPanic("Unsupported zset encoding");
     }
     autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);
+    __A_VARIABLE = 1;
     return str;
 }
 
@@ -2308,8 +2588,14 @@ int RM_ZsetRangePrev(RedisModuleKey *key) {
  */
 int RM_HashSet(RedisModuleKey *key, int flags, ...) {
     va_list ap;
-    if (!(key->mode & REDISMODULE_WRITE)) return 0;
-    if (key->value && key->value->type != OBJ_HASH) return 0;
+    if (!(key->mode & REDISMODULE_WRITE)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (key->value && key->value->type != OBJ_HASH) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);
 
     int updated = 0;
@@ -2365,6 +2651,7 @@ int RM_HashSet(RedisModuleKey *key, int flags, ...) {
     }
     va_end(ap);
     moduleDelKeyIfEmpty(key);
+    __A_VARIABLE = 1;
     return updated;
 }
 
@@ -2411,7 +2698,10 @@ int RM_HashSet(RedisModuleKey *key, int flags, ...) {
  */
 int RM_HashGet(RedisModuleKey *key, int flags, ...) {
     va_list ap;
-    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;
+    if (key->value && key->value->type != OBJ_HASH) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     va_start(ap, flags);
     while(1) {
@@ -2454,6 +2744,7 @@ int RM_HashGet(RedisModuleKey *key, int flags, ...) {
         if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);
     }
     va_end(ap);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -2481,6 +2772,7 @@ RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds pr
     }
     if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')
         reply->type = REDISMODULE_REPLY_NULL;
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -2493,7 +2785,10 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply);
  * use the protcol of the reply in reply->proto in order to fill the
  * reply with parsed data according to the reply type. */
 void moduleParseCallReply(RedisModuleCallReply *reply) {
-    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) return;
+    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     reply->flags &= ~REDISMODULE_REPLYFLAG_TOPARSE;
 
     switch(reply->proto[0]) {
@@ -2503,6 +2798,7 @@ void moduleParseCallReply(RedisModuleCallReply *reply) {
     case '+': moduleParseCallReply_SimpleString(reply); break;
     case '*': moduleParseCallReply_Array(reply); break;
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_Int(RedisModuleCallReply *reply) {
@@ -2512,6 +2808,7 @@ void moduleParseCallReply_Int(RedisModuleCallReply *reply) {
     string2ll(proto+1,p-proto-1,&reply->val.ll);
     reply->protolen = p-proto+2;
     reply->type = REDISMODULE_REPLY_INTEGER;
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
@@ -2529,6 +2826,7 @@ void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
         reply->protolen = p-proto+2+bulklen+2;
         reply->type = REDISMODULE_REPLY_STRING;
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
@@ -2540,6 +2838,7 @@ void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
     reply->protolen = p-proto+2;
     reply->type = proto[0] == '+' ? REDISMODULE_REPLY_STRING :
                                     REDISMODULE_REPLY_ERROR;
+    __A_VARIABLE = 1;
 }
 
 void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
@@ -2553,6 +2852,7 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
     if (arraylen == -1) {
         reply->protolen = p-proto;
         reply->type = REDISMODULE_REPLY_NULL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2569,6 +2869,7 @@ void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
     }
     reply->protolen = p-proto;
     reply->type = REDISMODULE_REPLY_ARRAY;
+    __A_VARIABLE = 1;
 }
 
 /* Free a Call reply and all the nested replies it contains if it's an
@@ -2577,7 +2878,10 @@ void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
     /* Don't free nested replies by default: the user must always free the
      * toplevel reply. However be gentle and don't crash if the module
      * misuses the API. */
-    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) return;
+    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {
         if (reply->type == REDISMODULE_REPLY_ARRAY) {
@@ -2596,6 +2900,7 @@ void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
         if (reply->proto) sdsfree(reply->proto);
         zfree(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for the recursive free reply function. This is needed in order
@@ -2606,11 +2911,16 @@ void RM_FreeCallReply(RedisModuleCallReply *reply) {
     RedisModuleCtx *ctx = reply->ctx;
     RM_FreeCallReply_Rec(reply,0);
     autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
+    __A_VARIABLE = 1;
 }
 
 /* Return the reply type. */
 int RM_CallReplyType(RedisModuleCallReply *reply) {
-    if (!reply) return REDISMODULE_REPLY_UNKNOWN;
+    if (!reply) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_REPLY_UNKNOWN;
+    }
+    __A_VARIABLE = 1;
     return reply->type;
 }
 
@@ -2621,8 +2931,10 @@ size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
     case REDISMODULE_REPLY_STRING:
     case REDISMODULE_REPLY_ERROR:
     case REDISMODULE_REPLY_ARRAY:
+        __A_VARIABLE = 1;
         return reply->len;
     default:
+        __A_VARIABLE = 1;
         return 0;
     }
 }
@@ -2631,15 +2943,26 @@ size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
  * if the reply type is wrong or the index is out of range. */
 RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
     moduleParseCallReply(reply);
-    if (reply->type != REDISMODULE_REPLY_ARRAY) return NULL;
-    if (idx >= reply->len) return NULL;
+    if (reply->type != REDISMODULE_REPLY_ARRAY) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    if (idx >= reply->len) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return reply->val.array+idx;
 }
 
 /* Return the long long of an integer reply. */
 long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
     moduleParseCallReply(reply);
-    if (reply->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
+    if (reply->type != REDISMODULE_REPLY_INTEGER) {
+        __A_VARIABLE = 1;
+        return LLONG_MIN;
+    }
+    __A_VARIABLE = 1;
     return reply->val.ll;
 }
 
@@ -2647,8 +2970,12 @@ long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
 const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
     moduleParseCallReply(reply);
     if (reply->type != REDISMODULE_REPLY_STRING &&
-        reply->type != REDISMODULE_REPLY_ERROR) return NULL;
+        reply->type != REDISMODULE_REPLY_ERROR) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     if (len) *len = reply->len;
+    __A_VARIABLE = 1;
     return reply->val.str;
 }
 
@@ -2659,13 +2986,16 @@ RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
     switch(reply->type) {
     case REDISMODULE_REPLY_STRING:
     case REDISMODULE_REPLY_ERROR:
+        __A_VARIABLE = 1;
         return RM_CreateString(reply->ctx,reply->val.str,reply->len);
     case REDISMODULE_REPLY_INTEGER: {
         char buf[64];
         int len = ll2string(buf,sizeof(buf),reply->val.ll);
+        __A_VARIABLE = 1;
         return RM_CreateString(reply->ctx,buf,len);
         }
-    default: return NULL;
+    default: __A_VARIABLE = 1;
+        return NULL;
     }
 }
 
@@ -2737,12 +3067,14 @@ robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int
         p++;
     }
     *argcp = argc;
+    __A_VARIABLE = 1;
     return argv;
 
 fmterr:
     for (j = 0; j < argc; j++)
         decrRefCount(argv[j]);
     zfree(argv);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -2843,6 +3175,7 @@ RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const ch
 cleanup:
     if (ctx->module) ctx->module->in_call--;
     freeClient(c);
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -2850,6 +3183,7 @@ cleanup:
  * that returned the reply object. */
 const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
     if (reply->proto) *len = sdslen(reply->proto);
+    __A_VARIABLE = 1;
     return reply->proto;
 }
 
@@ -2895,17 +3229,27 @@ uint64_t moduleTypeEncodeId(const char *name, int encver) {
     /* We use 64 symbols so that we can map each character into 6 bits
      * of the final output. */
     const char *cset = ModuleTypeNameCharSet;
-    if (strlen(name) != 9) return 0;
-    if (encver < 0 || encver > 1023) return 0;
+    if (strlen(name) != 9) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (encver < 0 || encver > 1023) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     uint64_t id = 0;
     for (int j = 0; j < 9; j++) {
         char *p = strchr(cset,name[j]);
-        if (!p) return 0;
+        if (!p) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         unsigned long pos = p-cset;
         id = (id << 6) | pos;
     }
     id = (id << 10) | encver;
+    __A_VARIABLE = 1;
     return id;
 }
 
@@ -2926,11 +3270,13 @@ moduleType *moduleTypeLookupModuleByName(const char *name) {
             moduleType *mt = ln->value;
             if (memcmp(name,mt->name,sizeof(mt->name)) == 0) {
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return mt;
             }
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -2948,7 +3294,10 @@ moduleType *moduleTypeLookupModuleByID(uint64_t id) {
     /* Search in cache to start. */
     int j;
     for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)
-        if (cache[j].id == id) return cache[j].mt;
+        if (cache[j].id == id) {
+            __A_VARIABLE = 1;
+            return cache[j].mt;
+        }
 
     /* Slow module by module lookup. */
     moduleType *mt = NULL;
@@ -2978,6 +3327,7 @@ moduleType *moduleTypeLookupModuleByID(uint64_t id) {
         cache[j].id = id;
         cache[j].mt = mt;
     }
+    __A_VARIABLE = 1;
     return mt;
 }
 
@@ -2995,6 +3345,7 @@ void moduleTypeNameByID(char *name, uint64_t moduleid) {
         *p-- = cset[moduleid & 63];
         moduleid >>= 6;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Register a new data type exported by the module. The parameters are the
@@ -3063,11 +3414,20 @@ void moduleTypeNameByID(char *name, uint64_t moduleid) {
  */
 moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
     uint64_t id = moduleTypeEncodeId(name,encver);
-    if (id == 0) return NULL;
-    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;
+    if (id == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    if (moduleTypeLookupModuleByName(name) != NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     long typemethods_version = ((long*)typemethods_ptr)[0];
-    if (typemethods_version == 0) return NULL;
+    if (typemethods_version == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     struct typemethods {
         uint64_t version;
@@ -3100,6 +3460,7 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
     }
     memcpy(mt->name,name,sizeof(mt->name));
     listAddNodeTail(ctx->module->types,mt);
+    __A_VARIABLE = 1;
     return mt;
 }
 
@@ -3108,12 +3469,16 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
  * On success REDISMODULE_OK is returned. If the key is not open for
  * writing or there is an active iterator, REDISMODULE_ERR is returned. */
 int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
-    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
+    if (!(key->mode & REDISMODULE_WRITE) || key->iter) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     RM_DeleteKey(key);
     robj *o = createModuleObject(mt,value);
     setKey(key->db,key->key,o);
     decrRefCount(o);
     key->value = o;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -3125,8 +3490,12 @@ int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
 moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
     if (key == NULL ||
         key->value == NULL ||
-        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
+        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     moduleValue *mv = key->value->ptr;
+    __A_VARIABLE = 1;
     return mv->type;
 }
 
@@ -3139,8 +3508,12 @@ moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
 void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
     if (key == NULL ||
         key->value == NULL ||
-        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
+        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     moduleValue *mv = key->value->ptr;
+    __A_VARIABLE = 1;
     return mv->value;
 }
 
@@ -3159,13 +3532,17 @@ void moduleRDBLoadError(RedisModuleIO *io) {
         io->type->name,
         (unsigned long long)io->bytes);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Save an unsigned 64 bit value into the RDB file. This function should only
  * be called in the context of the rdb_save method of modules implementing new
  * data types. */
 void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);
     if (retval == -1) goto saveerr;
@@ -3174,10 +3551,12 @@ void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
     retval = rdbSaveLen(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Load an unsigned 64 bit value from the RDB file. This function should only
@@ -3191,10 +3570,12 @@ uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
     uint64_t value;
     int retval = rdbLoadLenByRef(io->rio, NULL, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
@@ -3203,12 +3584,14 @@ void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
     union {uint64_t u; int64_t i;} conv;
     conv.i = value;
     RM_SaveUnsigned(io,conv.u);
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */
 int64_t RM_LoadSigned(RedisModuleIO *io) {
     union {uint64_t u; int64_t i;} conv;
     conv.u = RM_LoadUnsigned(io);
+    __A_VARIABLE = 1;
     return conv.i;
 }
 
@@ -3219,7 +3602,10 @@ int64_t RM_LoadSigned(RedisModuleIO *io) {
  * other Load family functions expecting a serialized string inside
  * the RDB file. */
 void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
     if (retval == -1) goto saveerr;
@@ -3228,16 +3614,21 @@ void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
     retval = rdbSaveStringObject(io->rio, s);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_SaveString() but takes a raw C pointer and length
  * as input. */
 void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
     if (retval == -1) goto saveerr;
@@ -3246,10 +3637,12 @@ void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
     retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Implements RM_LoadString() and RM_LoadStringBuffer() */
@@ -3261,10 +3654,12 @@ void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
     void *s = rdbGenericLoadStringObject(io->rio,
               plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
     if (s == NULL) goto loaderr;
+    __A_VARIABLE = 1;
     return s;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return NULL; /* Never reached. */
 }
 
@@ -3278,6 +3673,7 @@ loaderr:
  * If the data structure does not store strings as RedisModuleString objects,
  * the similar function RedisModule_LoadStringBuffer() could be used instead. */
 RedisModuleString *RM_LoadString(RedisModuleIO *io) {
+    __A_VARIABLE = 1;
     return moduleLoadString(io,0,NULL);
 }
 
@@ -3289,6 +3685,7 @@ RedisModuleString *RM_LoadString(RedisModuleIO *io) {
  * The returned string is not automatically NULL termianted, it is loaded
  * exactly as it was stored inisde the RDB file. */
 char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
+    __A_VARIABLE = 1;
     return moduleLoadString(io,1,lenptr);
 }
 
@@ -3296,7 +3693,10 @@ char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
  * value to the RDB file. The double can be a valid number, a NaN or infinity.
  * It is possible to load back the value with RedisModule_LoadDouble(). */
 void RM_SaveDouble(RedisModuleIO *io, double value) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);
     if (retval == -1) goto saveerr;
@@ -3305,10 +3705,12 @@ void RM_SaveDouble(RedisModuleIO *io, double value) {
     retval = rdbSaveBinaryDoubleValue(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* In the context of the rdb_save method of a module data type, loads back the
@@ -3321,10 +3723,12 @@ double RM_LoadDouble(RedisModuleIO *io) {
     double value;
     int retval = rdbLoadBinaryDoubleValue(io->rio, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
@@ -3332,7 +3736,10 @@ loaderr:
  * value to the RDB file. The float can be a valid number, a NaN or infinity.
  * It is possible to load back the value with RedisModule_LoadFloat(). */
 void RM_SaveFloat(RedisModuleIO *io, float value) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     /* Save opcode. */
     int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);
     if (retval == -1) goto saveerr;
@@ -3341,10 +3748,12 @@ void RM_SaveFloat(RedisModuleIO *io, float value) {
     retval = rdbSaveBinaryFloatValue(io->rio, value);
     if (retval == -1) goto saveerr;
     io->bytes += retval;
+    __A_VARIABLE = 1;
     return;
 
 saveerr:
     io->error = 1;
+    __A_VARIABLE = 1;
 }
 
 /* In the context of the rdb_save method of a module data type, loads back the
@@ -3357,10 +3766,12 @@ float RM_LoadFloat(RedisModuleIO *io) {
     float value;
     int retval = rdbLoadBinaryFloatValue(io->rio, &value);
     if (retval == -1) goto loaderr;
+    __A_VARIABLE = 1;
     return value;
 
 loaderr:
     moduleRDBLoadError(io);
+    __A_VARIABLE = 1;
     return 0; /* Never reached. */
 }
 
@@ -3384,6 +3795,7 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
             ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
             if (ret==-1) {
                 dictReleaseIterator(di);
+                __A_VARIABLE = 1;
                 return -1;
             }
             total_written += ret;
@@ -3391,6 +3803,7 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
     }
 
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return total_written;
 }
 
@@ -3438,6 +3851,7 @@ ssize_t rdbSaveModulesAux(rio *rdb, int when) {
  */
 void RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {
     mixDigest(md->o,ele,len);
+    __A_VARIABLE = 1;
 }
 
 /* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input
@@ -3446,12 +3860,14 @@ void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {
     char buf[LONG_STR_SIZE];
     size_t len = ll2string(buf,sizeof(buf),ll);
     mixDigest(md->o,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* See the documentation for `RedisModule_DigestAddElement()`. */
 void RM_DigestEndSequence(RedisModuleDigest *md) {
     xorDigest(md->x,md->o,sizeof(md->o));
     memset(md->o,0,sizeof(md->o));
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -3464,7 +3880,10 @@ void RM_DigestEndSequence(RedisModuleDigest *md) {
  * the parameters are passed, but it does not return anything as the error
  * handling is performed by Redis itself. */
 void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
-    if (io->error) return;
+    if (io->error) {
+        __A_VARIABLE = 1;
+        return;
+    }
     struct redisCommand *cmd;
     robj **argv = NULL;
     int argc = 0, flags = 0, j;
@@ -3478,6 +3897,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
             io->type->name, cmdname);
         io->error = 1;
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3492,6 +3912,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
             io->type->name, fmt);
         io->error = 1;
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3506,6 +3927,7 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
         decrRefCount(argv[j]);
     }
     zfree(argv);
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -3514,12 +3936,16 @@ void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
  * -------------------------------------------------------------------------- */
 
 RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
-    if (io->ctx) return io->ctx; /* Can't have more than one... */
+    if (io->ctx) {
+        __A_VARIABLE = 1;
+        return io->ctx;
+    } /* Can't have more than one... */
     RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;
     io->ctx = zmalloc(sizeof(RedisModuleCtx));
     *(io->ctx) = ctxtemplate;
     io->ctx->module = io->type->module;
     io->ctx->client = NULL;
+    __A_VARIABLE = 1;
     return io->ctx;
 }
 
@@ -3528,6 +3954,7 @@ RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
  * that the key name is always available, so this may return NULL.
  */
 const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
+    __A_VARIABLE = 1;
     return io->key;
 }
 
@@ -3552,11 +3979,15 @@ void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_li
     else if (!strcasecmp(levelstr,"warning")) level = LL_WARNING;
     else level = LL_VERBOSE; /* Default. */
 
-    if (level < server.verbosity) return;
+    if (level < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     name_len = snprintf(msg, sizeof(msg),"<%s> ", module? module->name: "module");
     vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
     serverLogRaw(level,msg);
+    __A_VARIABLE = 1;
 }
 
 /* Produces a log message to the standard Redis log, the format accepts
@@ -3582,6 +4013,7 @@ void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
     va_start(ap, fmt);
     RM_LogRaw(ctx? ctx->module: NULL,levelstr,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* Log errors from RDB / AOF serialization callbacks.
@@ -3594,6 +4026,7 @@ void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...
     va_start(ap, fmt);
     RM_LogRaw(io->type->module,levelstr,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -3609,6 +4042,7 @@ void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, in
     UNUSED(fd);
     UNUSED(mask);
     UNUSED(privdata);
+    __A_VARIABLE = 1;
 }
 
 /* This is called from blocked.c in order to unblock a client: may be called
@@ -3642,6 +4076,7 @@ void unblockClientFromModule(client *c) {
      * the client blocks) in order to be still able to access the argument
      * vector from callbacks. */
     resetClient(c);
+    __A_VARIABLE = 1;
 }
 
 /* Block a client in the context of a blocking command, returning an handle
@@ -3692,6 +4127,7 @@ RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc
     } else {
         blockClient(c,BLOCKED_MODULE);
     }
+    __A_VARIABLE = 1;
     return bc;
 }
 
@@ -3714,6 +4150,7 @@ int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
         /* Ignore the error, this is best-effort. */
     }
     pthread_mutex_unlock(&moduleUnblockedClientsMutex);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -3722,6 +4159,7 @@ int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
 int RM_AbortBlock(RedisModuleBlockedClient *bc) {
     bc->reply_callback = NULL;
     bc->disconnect_callback = NULL;
+    __A_VARIABLE = 1;
     return RM_UnblockClient(bc,NULL);
 }
 
@@ -3743,6 +4181,7 @@ int RM_AbortBlock(RedisModuleBlockedClient *bc) {
  */
 void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
     bc->disconnect_callback = callback;
+    __A_VARIABLE = 1;
 }
 
 /* This function will check the moduleUnblockedClients queue in order to
@@ -3831,6 +4270,7 @@ void moduleHandleBlockedClients(void) {
         pthread_mutex_lock(&moduleUnblockedClientsMutex);
     }
     pthread_mutex_unlock(&moduleUnblockedClientsMutex);
+    __A_VARIABLE = 1;
 }
 
 /* Called when our client timed out. After this function unblockClient()
@@ -3850,22 +4290,26 @@ void moduleBlockedClientTimedOut(client *c) {
      * because the blocked client will be automatically disconnected in
      * this case, and the user can still hook using the timeout callback. */
     bc->disconnect_callback = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if a module command was called in order to fill the
  * reply for a blocked client. */
 int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;
 }
 
 /* Return non-zero if a module command was called in order to fill the
  * reply for a blocked client that timed out. */
 int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
 }
 
 /* Get the private data set by RedisModule_UnblockClient() */
 void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return ctx->blocked_privdata;
 }
 
@@ -3874,6 +4318,7 @@ void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
  * before sometimes the module has the blocked client handle references
  * around, and wants to cleanup it. */
 RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return ctx->blocked_client;
 }
 
@@ -3881,6 +4326,7 @@ RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
  * the reason for the client to be unblocked is that it disconnected
  * while it was blocked. */
 int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
+    __A_VARIABLE = 1;
     return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
 }
 
@@ -3925,6 +4371,7 @@ RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
         selectDb(ctx->client,bc->dbid);
         ctx->client->id = bc->client->id;
     }
+    __A_VARIABLE = 1;
     return ctx;
 }
 
@@ -3932,6 +4379,7 @@ RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
 void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
     moduleFreeContext(ctx);
     zfree(ctx);
+    __A_VARIABLE = 1;
 }
 
 /* Acquire the server lock before executing a thread safe API call.
@@ -3940,20 +4388,24 @@ void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
 void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
     UNUSED(ctx);
     moduleAcquireGIL();
+    __A_VARIABLE = 1;
 }
 
 /* Release the server lock after a thread safe API call was executed. */
 void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
     UNUSED(ctx);
     moduleReleaseGIL();
+    __A_VARIABLE = 1;
 }
 
 void moduleAcquireGIL(void) {
     pthread_mutex_lock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 void moduleReleaseGIL(void) {
     pthread_mutex_unlock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 
@@ -4018,6 +4470,7 @@ int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNoti
     sub->active = 0;
 
     listAddNodeTail(moduleKeyspaceSubscribers, sub);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4026,7 +4479,10 @@ int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNoti
  * keyspace notifications */
 void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
     /* Don't do anything if there aren't any subscribers */
-    if (listLength(moduleKeyspaceSubscribers) == 0) return;
+    if (listLength(moduleKeyspaceSubscribers) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listIter li;
     listNode *ln;
@@ -4054,6 +4510,7 @@ void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid)
             moduleFreeContext(&ctx);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Unsubscribe any notification subscribers this module has upon unloading */
@@ -4068,6 +4525,7 @@ void moduleUnsubscribeNotifications(RedisModule *module) {
             zfree(sub);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4109,10 +4567,12 @@ void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8
             selectDb(ctx.client, 0);
             r->callback(&ctx,sender_id,type,payload,len);
             moduleFreeContext(&ctx);
+            __A_VARIABLE = 1;
             return;
         }
         r = r->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Register a callback receiver for cluster messages of type 'type'. If there
@@ -4121,7 +4581,10 @@ void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8
  * is already a callback for this function, the callback is unregistered
  * (so this API call is also used in order to delete the receiver). */
 void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
-    if (!server.cluster_enabled) return;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
     moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
@@ -4140,6 +4603,7 @@ void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisM
                     clusterReceivers[type]->next = r->next;
                 zfree(r);
             }
+            __A_VARIABLE = 1;
             return;
         }
         prev = r;
@@ -4155,6 +4619,7 @@ void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisM
         r->next = clusterReceivers[type];
         clusterReceivers[type] = r;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send a message to all the nodes in the cluster if `target` is NULL, otherwise
@@ -4198,7 +4663,10 @@ int RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, un
 char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
     UNUSED(ctx);
 
-    if (!server.cluster_enabled) return NULL;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     size_t count = dictSize(server.cluster->nodes);
     char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
     dictIterator *di = dictGetIterator(server.cluster->nodes);
@@ -4215,20 +4683,29 @@ char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
     ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need
                     * to also get the count argument. */
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return ids;
 }
 
 /* Free the node list obtained with RedisModule_GetClusterNodesList. */
 void RM_FreeClusterNodesList(char **ids) {
-    if (ids == NULL) return;
+    if (ids == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     for (int j = 0; ids[j]; j++) zfree(ids[j]);
     zfree(ids);
+    __A_VARIABLE = 1;
 }
 
 /* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster
  * is disabled. */
 const char *RM_GetMyClusterID(void) {
-    if (!server.cluster_enabled) return NULL;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return server.cluster->myself->name;
 }
 
@@ -4237,7 +4714,11 @@ const char *RM_GetMyClusterID(void) {
  * be smaller, but not greater than this number. If the instance is not in
  * cluster mode, zero is returned. */
 size_t RM_GetClusterSize(void) {
-    if (!server.cluster_enabled) return 0;
+    if (!server.cluster_enabled) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return dictSize(server.cluster->nodes);
 }
 
@@ -4267,8 +4748,10 @@ int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *m
     UNUSED(ctx);
 
     clusterNode *node = clusterLookupNode(id);
-    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
+    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (ip) memcpy(ip,node->name,REDISMODULE_NODE_ID_LEN);
 
@@ -4294,6 +4777,7 @@ int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *m
         if (node->flags & CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;
         if (node->flags & CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4321,6 +4805,7 @@ void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
         server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
     if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
         server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4393,6 +4878,7 @@ int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *client
 
     /* Reschedule the next timer or cancel it. */
     if (next_period <= 0) next_period = 1;
+    __A_VARIABLE = 1;
     return (raxSize(Timers) > 0) ? next_period : AE_NOMORE;
 }
 
@@ -4440,6 +4926,7 @@ RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisMod
     if (aeTimer == -1)
         aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);
 
+    __A_VARIABLE = 1;
     return key;
 }
 
@@ -4449,11 +4936,14 @@ RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisMod
  * the timer was created. */
 int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
     RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
-    if (timer == raxNotFound || timer->module != ctx->module)
+    if (timer == raxNotFound || timer->module != ctx->module) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (data) *data = timer->data;
     raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);
     zfree(timer);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4465,14 +4955,17 @@ int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
  * the caller does not need certain information. */
 int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
     RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
-    if (timer == raxNotFound || timer->module != ctx->module)
+    if (timer == raxNotFound || timer->module != ctx->module) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (remaining) {
         int64_t rem = ntohu64(id)-ustime();
         if (rem < 0) rem = 0;
         *remaining = rem/1000; /* Scale to milliseconds. */
     }
     if (data) *data = timer->data;
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4501,6 +4994,7 @@ RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
     struct RedisModuleDict *d = zmalloc(sizeof(*d));
     d->rax = raxNew();
     if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
+    __A_VARIABLE = 1;
     return d;
 }
 
@@ -4511,10 +5005,12 @@ void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
     if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
     raxFree(d->rax);
     zfree(d);
+    __A_VARIABLE = 1;
 }
 
 /* Return the size of the dictionary (number of keys). */
 uint64_t RM_DictSize(RedisModuleDict *d) {
+    __A_VARIABLE = 1;
     return raxSize(d->rax);
 }
 
@@ -4524,6 +5020,7 @@ uint64_t RM_DictSize(RedisModuleDict *d) {
  * exists the function returns REDISMODULE_ERR. */
 int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
     int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);
+    __A_VARIABLE = 1;
     return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -4531,16 +5028,19 @@ int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
  * value if the key already exists. */
 int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
     int retval = raxInsert(d->rax,key,keylen,ptr,NULL);
+    __A_VARIABLE = 1;
     return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictSetC() but takes the key as a RedisModuleString. */
 int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
+    __A_VARIABLE = 1;
     return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);
 }
 
 /* Like RedisModule_DictReplaceC() but takes the key as a RedisModuleString. */
 int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
+    __A_VARIABLE = 1;
     return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);
 }
 
@@ -4552,11 +5052,13 @@ int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
 void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
     void *res = raxFind(d->rax,key,keylen);
     if (nokey) *nokey = (res == raxNotFound);
+    __A_VARIABLE = 1;
     return (res == raxNotFound) ? NULL : res;
 }
 
 /* Like RedisModule_DictGetC() but takes the key as a RedisModuleString. */
 void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
+    __A_VARIABLE = 1;
     return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);
 }
 
@@ -4569,11 +5071,13 @@ void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
  * having to call RedisModule_DictGet() before deleting the key. */
 int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
     int retval = raxRemove(d->rax,key,keylen,oldval);
+    __A_VARIABLE = 1;
     return retval ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictDelC() but gets the key as a RedisModuleString. */
 int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
+    __A_VARIABLE = 1;
     return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);
 }
 
@@ -4602,12 +5106,14 @@ RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, v
     di->dict = d;
     raxStart(&di->ri,d->rax);
     raxSeek(&di->ri,op,key,keylen);
+    __A_VARIABLE = 1;
     return di;
 }
 
 /* Exactly like RedisModule_DictIteratorStartC, but the key is passed as a
  * RedisModuleString. */
 RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
+    __A_VARIABLE = 1;
     return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));
 }
 
@@ -4616,6 +5122,7 @@ RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, Re
 void RM_DictIteratorStop(RedisModuleDictIter *di) {
     raxStop(&di->ri);
     zfree(di);
+    __A_VARIABLE = 1;
 }
 
 /* After its creation with RedisModule_DictIteratorStart(), it is possible to
@@ -4626,12 +5133,14 @@ void RM_DictIteratorStop(RedisModuleDictIter *di) {
  * or REDISMODULE_ERR in case it was not possible to seek the specified
  * element. It is possible to reseek an iterator as many times as you want. */
 int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
+    __A_VARIABLE = 1;
     return raxSeek(&di->ri,op,key,keylen);
 }
 
 /* Like RedisModule_DictIteratorReseekC() but takes the key as as a
  * RedisModuleString. */
 int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
+    __A_VARIABLE = 1;
     return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));
 }
 
@@ -4661,9 +5170,13 @@ int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleSt
  * next/prev iterator step. Also the pointer is no longer valid once the
  * iterator is released. */
 void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
-    if (!raxNext(&di->ri)) return NULL;
+    if (!raxNext(&di->ri)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (keylen) *keylen = di->ri.key_len;
     if (dataptr) *dataptr = di->ri.data;
+    __A_VARIABLE = 1;
     return di->ri.key;
 }
 
@@ -4671,9 +5184,13 @@ void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
  * the currently selected element in the iterator, it selects the previous
  * element (laxicographically smaller) instead of the next one. */
 void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
-    if (!raxPrev(&di->ri)) return NULL;
+    if (!raxPrev(&di->ri)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (keylen) *keylen = di->ri.key_len;
     if (dataptr) *dataptr = di->ri.data;
+    __A_VARIABLE = 1;
     return di->ri.key;
 }
 
@@ -4687,7 +5204,11 @@ void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
 RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
     size_t keylen;
     void *key = RM_DictNextC(di,&keylen,dataptr);
-    if (key == NULL) return NULL;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,key,keylen);
 }
 
@@ -4697,7 +5218,11 @@ RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, voi
 RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
     size_t keylen;
     void *key = RM_DictPrevC(di,&keylen,dataptr);
-    if (key == NULL) return NULL;
+    if (key == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return RM_CreateString(ctx,key,keylen);
 }
 
@@ -4714,16 +5239,24 @@ RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, voi
  * The function returne REDISMODULE_ERR if the iterator reached the
  * end of elements condition as well. */
 int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
-    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
+    if (raxEOF(&di->ri)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     int res = raxCompare(&di->ri,op,key,keylen);
+    __A_VARIABLE = 1;
     return res ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
 /* Like RedisModule_DictCompareC but gets the key to compare with the current
  * iterator key as a RedisModuleString. */
 int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
-    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
+    if (raxEOF(&di->ri)) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));
+    __A_VARIABLE = 1;
     return res ? REDISMODULE_OK : REDISMODULE_ERR;
 }
 
@@ -4737,6 +5270,7 @@ int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *k
  * Currently this function is not thread safe. */
 void RM_GetRandomBytes(unsigned char *dst, size_t len) {
     getRandomBytes(dst,len);
+    __A_VARIABLE = 1;
 }
 
 /* Like RedisModule_GetRandomBytes() but instead of setting the string to
@@ -4744,6 +5278,7 @@ void RM_GetRandomBytes(unsigned char *dst, size_t len) {
  * hex charset [0-9a-f]. */
 void RM_GetRandomHexChars(char *dst, size_t len) {
     getRandomHexChars(dst,len);
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------------------------------------------------------
@@ -4768,8 +5303,10 @@ int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
     sapi->func = func;
     if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
         zfree(sapi);
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -4808,12 +5345,16 @@ int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
  */
 void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
     dictEntry *de = dictFind(server.sharedapi, apiname);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     RedisModuleSharedAPI *sapi = dictGetVal(de);
     if (listSearchKey(sapi->module->usedby,ctx->module) == NULL) {
         listAddNodeTail(sapi->module->usedby,ctx->module);
         listAddNodeTail(ctx->module->using,sapi->module);
     }
+    __A_VARIABLE = 1;
     return sapi->func;
 }
 
@@ -4837,6 +5378,7 @@ int moduleUnregisterSharedAPI(RedisModule *module) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4858,6 +5400,7 @@ int moduleUnregisterUsedAPI(RedisModule *module) {
             count++;
         }
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4880,6 +5423,7 @@ int moduleUnregisterFilters(RedisModule *module) {
         }
         zfree(filter);
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -4947,6 +5491,7 @@ RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisMod
 
     listAddNodeTail(moduleCommandFilters, filter);
     listAddNodeTail(ctx->module->filters, filter);
+    __A_VARIABLE = 1;
     return filter;
 }
 
@@ -4956,21 +5501,34 @@ int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *fi
     listNode *ln;
 
     /* A module can only remove its own filters */
-    if (filter->module != ctx->module) return REDISMODULE_ERR;
+    if (filter->module != ctx->module) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     ln = listSearchKey(moduleCommandFilters,filter);
-    if (!ln) return REDISMODULE_ERR;
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
     listDelNode(moduleCommandFilters,ln);
     
     ln = listSearchKey(ctx->module->filters,filter);
-    if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }    /* Shouldn't happen */
     listDelNode(ctx->module->filters,ln);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void moduleCallCommandFilters(client *c) {
-    if (listLength(moduleCommandFilters) == 0) return;
+    if (listLength(moduleCommandFilters) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listIter li;
     listNode *ln;
@@ -4995,6 +5553,7 @@ void moduleCallCommandFilters(client *c) {
 
     c->argv = filter.argv;
     c->argc = filter.argc;
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of arguments a filtered command has.  The number of
@@ -5002,6 +5561,7 @@ void moduleCallCommandFilters(client *c) {
  */
 int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
 {
+    __A_VARIABLE = 1;
     return fctx->argc;
 }
 
@@ -5010,7 +5570,11 @@ int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
  */
 const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
 {
-    if (pos < 0 || pos >= fctx->argc) return NULL;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return fctx->argv[pos];
 }
 
@@ -5024,7 +5588,10 @@ int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisM
 {
     int i;
 
-    if (pos < 0 || pos > fctx->argc) return REDISMODULE_ERR;
+    if (pos < 0 || pos > fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     fctx->argv = zrealloc(fctx->argv, (fctx->argc+1)*sizeof(RedisModuleString *));
     for (i = fctx->argc; i > pos; i--) {
@@ -5033,6 +5600,7 @@ int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisM
     fctx->argv[pos] = arg;
     fctx->argc++;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5044,11 +5612,15 @@ int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisM
 
 int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
 {
-    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     decrRefCount(fctx->argv[pos]);
     fctx->argv[pos] = arg;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5058,7 +5630,10 @@ int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, Redis
 int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
 {
     int i;
-    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;
+    if (pos < 0 || pos >= fctx->argc) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     decrRefCount(fctx->argv[pos]);
     for (i = pos; i < fctx->argc-1; i++) {
@@ -5066,6 +5641,7 @@ int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
     }
     fctx->argc--;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -5077,11 +5653,13 @@ int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
  * this gets queries from modules. */
 
 uint64_t dictCStringKeyHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
 }
 
 int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {
     UNUSED(privdata);
+    __A_VARIABLE = 1;
     return strcmp(key1,key2) == 0;
 }
 
@@ -5095,6 +5673,7 @@ dictType moduleAPIDictType = {
 };
 
 int moduleRegisterApi(const char *funcname, void *funcptr) {
+    __A_VARIABLE = 1;
     return dictAdd(server.moduleapi, (char*)funcname, funcptr);
 }
 
@@ -5135,6 +5714,7 @@ void moduleInitModulesSystem(void) {
     /* Our thread-safe contexts GIL must start with already locked:
      * it is just unlocked when it's safe. */
     pthread_mutex_lock(&moduleGIL);
+    __A_VARIABLE = 1;
 }
 
 /* Load all the modules in the server.loadmodule_queue list, which is
@@ -5162,6 +5742,7 @@ void moduleLoadFromQueue(void) {
             exit(1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void moduleFreeModuleStructure(struct RedisModule *module) {
@@ -5169,6 +5750,7 @@ void moduleFreeModuleStructure(struct RedisModule *module) {
     listRelease(module->filters);
     sdsfree(module->name);
     zfree(module);
+    __A_VARIABLE = 1;
 }
 
 void moduleUnregisterCommands(struct RedisModule *module) {
@@ -5191,6 +5773,7 @@ void moduleUnregisterCommands(struct RedisModule *module) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Load a module and initialize it. On success C_OK is returned, otherwise
@@ -5203,6 +5786,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
     handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
     if (handle == NULL) {
         serverLog(LL_WARNING, "Module %s failed to load: %s", path, dlerror());
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,"RedisModule_OnLoad");
@@ -5211,6 +5795,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
         serverLog(LL_WARNING,
             "Module %s does not export RedisModule_OnLoad() "
             "symbol. Module not loaded.",path);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     if (onload((void*)&ctx,module_argv,module_argc) == REDISMODULE_ERR) {
@@ -5223,6 +5808,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
         dlclose(handle);
         serverLog(LL_WARNING,
             "Module %s initialization failed. Module not loaded",path);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -5231,6 +5817,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
     ctx.module->handle = handle;
     serverLog(LL_NOTICE,"Module '%s' loaded from %s",ctx.module->name,path);
     moduleFreeContext(&ctx);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -5356,6 +5943,7 @@ NULL
 
 /* Return the number of registered modules. */
 size_t moduleCount(void) {
+    __A_VARIABLE = 1;
     return dictSize(modules);
 }
 
@@ -5525,4 +6113,5 @@ void moduleRegisterCoreAPI(void) {
     REGISTER_API(CommandFilterArgInsert);
     REGISTER_API(CommandFilterArgReplace);
     REGISTER_API(CommandFilterArgDelete);
+    __A_VARIABLE = 1;
 }
diff --git a/src/modules/helloblock.c b/src/modules/helloblock.c
index b90ccaa..134f3d0 100644
--- a/src/modules/helloblock.c
+++ b/src/modules/helloblock.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Helloblock module -- An example of blocking command implementation
  * with threads.
  *
@@ -43,6 +44,7 @@ int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
     int *myint = RedisModule_GetBlockedClientPrivateData(ctx);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithLongLong(ctx,*myint);
 }
 
@@ -50,6 +52,7 @@ int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx,"Request timedout");
 }
 
@@ -57,6 +60,7 @@ int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
     REDISMODULE_NOT_USED(ctx);
     RedisModule_Free(privdata);
+    __A_VARIABLE = 1;
 }
 
 /* The thread entry point that actually executes the blocking part
@@ -71,6 +75,7 @@ void *HelloBlock_ThreadMain(void *arg) {
     int *r = RedisModule_Alloc(sizeof(int));
     *r = rand();
     RedisModule_UnblockClient(bc,r);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -89,21 +94,27 @@ void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc)
     /* Here you should cleanup your state / threads, and if possible
      * call RedisModule_UnblockClient(), or notify the thread that will
      * call the function ASAP. */
+    __A_VARIABLE = 1;
 }
 
 /* HELLO.BLOCK <delay> <timeout> -- Block for <count> seconds, then reply with
  * a random number. Timeout is the command timeout, so that you can test
  * what happens when the delay is greater than the timeout. */
 int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     long long delay;
     long long timeout;
 
     if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
     if (RedisModule_StringToLongLong(argv[2],&timeout) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
@@ -124,8 +135,10 @@ int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int a
 
     if (pthread_create(&tid,NULL,HelloBlock_ThreadMain,targ) != 0) {
         RedisModule_AbortBlock(bc);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"-ERR Can't start thread");
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -171,6 +184,7 @@ void *HelloKeys_ThreadMain(void *arg) {
 
     RedisModule_FreeThreadSafeContext(ctx);
     RedisModule_UnblockClient(bc,NULL);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -180,7 +194,10 @@ void *HelloKeys_ThreadMain(void *arg) {
  * there. */
 int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     REDISMODULE_NOT_USED(argv);
-    if (argc != 1) return RedisModule_WrongArity(ctx);
+    if (argc != 1) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
 
     pthread_t tid;
 
@@ -194,8 +211,10 @@ int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int ar
      * the reference to the blocked client handle. */
     if (pthread_create(&tid,NULL,HelloKeys_ThreadMain,bc) != 0) {
         RedisModule_AbortBlock(bc);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"-ERR Can't start thread");
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -206,14 +225,22 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"helloblock",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hello.block",
-        HelloBlock_RedisCommand,"",0,0,0) == REDISMODULE_ERR)
+        HelloBlock_RedisCommand,"",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     if (RedisModule_CreateCommand(ctx,"hello.keys",
-        HelloKeys_RedisCommand,"",0,0,0) == REDISMODULE_ERR)
+        HelloKeys_RedisCommand,"",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellocluster.c b/src/modules/hellocluster.c
index cb78187..3833678 100644
--- a/src/modules/hellocluster.c
+++ b/src/modules/hellocluster.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Helloworld cluster -- A ping/pong cluster API example.
  *
  * -----------------------------------------------------------------------------
@@ -46,6 +47,7 @@ int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
     REDISMODULE_NOT_USED(argc);
 
     RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PING,(unsigned char*)"Hey",3);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -57,6 +59,7 @@ int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
     size_t numnodes;
     char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
     if (ids == NULL) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"Cluster not enabled");
     }
 
@@ -69,6 +72,7 @@ int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModule_ReplyWithLongLong(ctx,port);
     }
     RedisModule_FreeClusterNodesList(ids);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -78,12 +82,14 @@ void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, cons
         type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
     RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,(unsigned char*)"Ohi!",4);
     RedisModule_Call(ctx, "INCR", "c", "pings_received");
+    __A_VARIABLE = 1;
 }
 
 /* Callback for message MSGTYPE_PONG. */
 void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
     RedisModule_Log(ctx,"notice","PONG (type %d) RECEIVED from %.*s: '%.*s'",
         type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
+    __A_VARIABLE = 1;
 }
 
 /* This function must be present on each Redis module. It is used in order to
@@ -93,15 +99,22 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellocluster",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellocluster.pingall",
-        PingallCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        PingallCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellocluster.list",
-        ListCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        ListCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     /* Disable Redis Cluster sharding and redirections. This way every node
      * will be able to access every possible key, regardless of the hash slot.
@@ -114,5 +127,6 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     /* Register our handlers for different message types. */
     RedisModule_RegisterClusterMessageReceiver(ctx,MSGTYPE_PING,PingReceiver);
     RedisModule_RegisterClusterMessageReceiver(ctx,MSGTYPE_PONG,PongReceiver);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellodict.c b/src/modules/hellodict.c
index 651615b..78f7643 100644
--- a/src/modules/hellodict.c
+++ b/src/modules/hellodict.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Hellodict -- An example of modules dictionary API
  *
  * This module implements a volatile key-value store on top of the
@@ -46,11 +47,15 @@ static RedisModuleDict *Keyspace;
  *
  * Set the specified key to the specified value. */
 int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModule_DictSet(Keyspace,argv[1],argv[2]);
     /* We need to keep a reference to the value stored at the key, otherwise
      * it would be freed when this callback returns. */
     RedisModule_RetainString(NULL,argv[2]);
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -73,11 +78,15 @@ int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
  * Return a list of matching keys, lexicographically between startkey
  * and endkey. No more than 'count' items are emitted. */
 int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
-    if (argc != 4) return RedisModule_WrongArity(ctx);
+    if (argc != 4) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
 
     /* Parse the count argument. */
     long long count;
     if (RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid count");
     }
 
@@ -101,6 +110,7 @@ int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     /* Cleanup. */
     RedisModule_DictIteratorStop(iter);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -111,22 +121,32 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellodict",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.set",
-        cmd_SET,"write deny-oom",1,1,0) == REDISMODULE_ERR)
+        cmd_SET,"write deny-oom",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.get",
-        cmd_GET,"readonly",1,1,0) == REDISMODULE_ERR)
+        cmd_GET,"readonly",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellodict.keyrange",
-        cmd_KEYRANGE,"readonly",1,1,0) == REDISMODULE_ERR)
+        cmd_KEYRANGE,"readonly",1,1,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     /* Create our global dictionray. Here we'll set our keys and values. */
     Keyspace = RedisModule_CreateDict(NULL);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellotimer.c b/src/modules/hellotimer.c
index 57b111b..61eb9ec 100644
--- a/src/modules/hellotimer.c
+++ b/src/modules/hellotimer.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Timer API example -- Register and handle timer events
  *
  * -----------------------------------------------------------------------------
@@ -42,6 +43,7 @@ void timerHandler(RedisModuleCtx *ctx, void *data) {
     REDISMODULE_NOT_USED(ctx);
     printf("Fired %s!\n", data);
     RedisModule_Free(data);
+    __A_VARIABLE = 1;
 }
 
 /* HELLOTIMER.TIMER*/
@@ -56,6 +58,7 @@ int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModuleTimerID tid = RedisModule_CreateTimer(ctx,delay,timerHandler,buf);
         REDISMODULE_NOT_USED(tid);
     }
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -66,11 +69,17 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellotimer",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotimer.timer",
-        TimerCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
+        TimerCommand_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/hellotype.c b/src/modules/hellotype.c
index ba634c4..92f19bb 100644
--- a/src/modules/hellotype.c
+++ b/src/modules/hellotype.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* This file implements a new module native data type called "HELLOTYPE".
  * The data structure implemented is a very simple ordered linked list of
  * 64 bit integers, in order to have something that is real world enough, but
@@ -65,6 +66,7 @@ struct HelloTypeObject *createHelloTypeObject(void) {
     o = RedisModule_Alloc(sizeof(*o));
     o->head = NULL;
     o->len = 0;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -84,6 +86,7 @@ void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
         o->head = newnode;
     }
     o->len++;
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeReleaseObject(struct HelloTypeObject *o) {
@@ -95,6 +98,7 @@ void HelloTypeReleaseObject(struct HelloTypeObject *o) {
         cur = next;
     }
     RedisModule_Free(o);
+    __A_VARIABLE = 1;
 }
 
 /* ========================= "hellotype" type commands ======================= */
@@ -103,18 +107,23 @@ void HelloTypeReleaseObject(struct HelloTypeObject *o) {
 int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 3) return RedisModule_WrongArity(ctx);
+    if (argc != 3) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
     long long value;
     if ((RedisModule_StringToLongLong(argv[2],&value) != REDISMODULE_OK)) {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,"ERR invalid value: must be a signed 64 bit integer");
     }
 
@@ -132,6 +141,7 @@ int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
 
     RedisModule_ReplyWithLongLong(ctx,hto->len);
     RedisModule_ReplicateVerbatim(ctx);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -139,13 +149,17 @@ int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,
 int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 4) return RedisModule_WrongArity(ctx);
+    if (argc != 4) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
@@ -154,6 +168,7 @@ int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
         RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK ||
         first < 0 || count < 0)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,
             "ERR invalid first or count parameters");
     }
@@ -168,6 +183,7 @@ int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
         node = node->next;
     }
     RedisModule_ReplySetArrayLength(ctx,arraylen);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -175,18 +191,23 @@ int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, i
 int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
 
-    if (argc != 2) return RedisModule_WrongArity(ctx);
+    if (argc != 2) {
+        __A_VARIABLE = 1;
+        return RedisModule_WrongArity(ctx);
+    }
     RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
         REDISMODULE_READ|REDISMODULE_WRITE);
     int type = RedisModule_KeyType(key);
     if (type != REDISMODULE_KEYTYPE_EMPTY &&
         RedisModule_ModuleTypeGetType(key) != HelloType)
     {
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
     }
 
     struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
     RedisModule_ReplyWithLongLong(ctx,hto ? hto->len : 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -196,6 +217,7 @@ int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
 void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
     if (encver != 0) {
         /* RedisModule_Log("warning","Can't load data with version %d", encver);*/
+        __A_VARIABLE = 1;
         return NULL;
     }
     uint64_t elements = RedisModule_LoadUnsigned(rdb);
@@ -204,6 +226,7 @@ void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
         int64_t ele = RedisModule_LoadSigned(rdb);
         HelloTypeInsert(hto,ele);
     }
+    __A_VARIABLE = 1;
     return hto;
 }
 
@@ -215,6 +238,7 @@ void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
         RedisModule_SaveSigned(rdb,node->value);
         node = node->next;
     }
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
@@ -224,6 +248,7 @@ void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value
         RedisModule_EmitAOF(aof,"HELLOTYPE.INSERT","sl",key,node->value);
         node = node->next;
     }
+    __A_VARIABLE = 1;
 }
 
 /* The goal of this function is to return the amount of memory used by
@@ -231,11 +256,13 @@ void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value
 size_t HelloTypeMemUsage(const void *value) {
     const struct HelloTypeObject *hto = value;
     struct HelloTypeNode *node = hto->head;
+    __A_VARIABLE = 1;
     return sizeof(*hto) + sizeof(*node)*hto->len;
 }
 
 void HelloTypeFree(void *value) {
     HelloTypeReleaseObject(value);
+    __A_VARIABLE = 1;
 }
 
 void HelloTypeDigest(RedisModuleDigest *md, void *value) {
@@ -246,6 +273,7 @@ void HelloTypeDigest(RedisModuleDigest *md, void *value) {
         node = node->next;
     }
     RedisModule_DigestEndSequence(md);
+    __A_VARIABLE = 1;
 }
 
 /* This function must be present on each Redis module. It is used in order to
@@ -255,7 +283,10 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"hellotype",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     RedisModuleTypeMethods tm = {
         .version = REDISMODULE_TYPE_METHOD_VERSION,
@@ -268,19 +299,29 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     };
 
     HelloType = RedisModule_CreateDataType(ctx,"hellotype",0,&tm);
-    if (HelloType == NULL) return REDISMODULE_ERR;
+    if (HelloType == NULL) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.insert",
-        HelloTypeInsert_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        HelloTypeInsert_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.range",
-        HelloTypeRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
+        HelloTypeRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"hellotype.len",
-        HelloTypeLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
+        HelloTypeLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/modules/helloworld.c b/src/modules/helloworld.c
index 3b00dea..199b0ab 100644
--- a/src/modules/helloworld.c
+++ b/src/modules/helloworld.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Helloworld module -- A few examples of the Redis Modules API in the form
  * of commands showing how to accomplish common tasks.
  *
diff --git a/src/modules/testmodule.c b/src/modules/testmodule.c
index 67a8617..ba52263 100644
--- a/src/modules/testmodule.c
+++ b/src/modules/testmodule.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Module designed to test the Redis modules subsystem.
  *
  * -----------------------------------------------------------------------------
@@ -40,8 +41,12 @@
 int TestMatchReply(RedisModuleCallReply *reply, char *str) {
     RedisModuleString *mystr;
     mystr = RedisModule_CreateStringFromCallReply(reply);
-    if (!mystr) return 0;
+    if (!mystr) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     const char *ptr = RedisModule_StringPtrLen(mystr,NULL);
+    __A_VARIABLE = 1;
     return strcmp(ptr,str) == 0;
 }
 
@@ -70,10 +75,12 @@ int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     if (!TestMatchReply(item1,"1234")) goto fail;
 
     RedisModule_ReplyWithSimpleString(ctx,"OK");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 
 fail:
     RedisModule_ReplyWithSimpleString(ctx,"ERR");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -86,6 +93,7 @@ int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_StringAppendBuffer(ctx,s,"bar",3);
     RedisModule_ReplyWithString(ctx,s);
     RedisModule_FreeString(ctx,s);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -100,6 +108,7 @@ int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_StringAppendBuffer(ctx,s,"bar",3);
     RedisModule_ReplyWithString(ctx,s);
     RedisModule_FreeString(ctx,s);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -107,6 +116,7 @@ int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_AutoMemory(ctx);
     if (argc < 3) {
+        __A_VARIABLE = 1;
         return RedisModule_WrongArity(ctx);
     }
     RedisModuleString *s = RedisModule_CreateStringPrintf(ctx, 
@@ -118,11 +128,13 @@ int TestStringPrintf(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     RedisModule_ReplyWithString(ctx,s);
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 int failTest(RedisModuleCtx *ctx, const char *msg) {
     RedisModule_ReplyWithError(ctx, msg);
+    __A_VARIABLE = 1;
     return REDISMODULE_ERR;
 }
 
@@ -132,25 +144,33 @@ int TestUnlink(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     REDISMODULE_NOT_USED(argc);
 
     RedisModuleKey *k = RedisModule_OpenKey(ctx, RedisModule_CreateStringPrintf(ctx, "unlinked"), REDISMODULE_WRITE | REDISMODULE_READ);
-    if (!k) return failTest(ctx, "Could not create key");
+    if (!k) {
+        __A_VARIABLE = 1;
+        return failTest(ctx, "Could not create key");
+    }
     
     if (REDISMODULE_ERR == RedisModule_StringSet(k, RedisModule_CreateStringPrintf(ctx, "Foobar"))) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not set string value");
     }
 
     RedisModuleCallReply *rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
     if (!rep || RedisModule_CallReplyInteger(rep) != 1) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Key does not exist before unlink");
     }
 
     if (REDISMODULE_ERR == RedisModule_UnlinkKey(k)) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not unlink key");
     }
 
     rep = RedisModule_Call(ctx, "EXISTS", "c", "unlinked");
     if (!rep || RedisModule_CallReplyInteger(rep) != 0) {
+        __A_VARIABLE = 1;
         return failTest(ctx, "Could not verify key to be unlinked");
     }
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
     
 }
@@ -163,6 +183,7 @@ int NotifyCallback(RedisModuleCtx *ctx, int type, const char *event,
                   event, RedisModule_StringPtrLen(key, NULL));
 
   RedisModule_Call(ctx, "HINCRBY", "csc", "notifications", key, "1");
+  __A_VARIABLE = 1;
   return REDISMODULE_OK;
 }
 
@@ -227,6 +248,7 @@ int TestNotifications(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
 
     RedisModule_Call(ctx, "FLUSHDB", "");
 
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 err:
     RedisModule_Call(ctx, "FLUSHDB", "");
@@ -297,9 +319,11 @@ end:
 
     if (!ok) {
         RedisModule_Log(ctx, "warning", "Failed CTXFLAGS Test. Reason: %s", errString);
+        __A_VARIABLE = 1;
         return RedisModule_ReplyWithSimpleString(ctx, "ERR");
     }
 
+    __A_VARIABLE = 1;
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
@@ -313,6 +337,7 @@ int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char
     if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_STRING) {
         RedisModule_Log(ctx,"warning","Unexpected reply type %d",
             RedisModule_CallReplyType(reply));
+        __A_VARIABLE = 1;
         return 0;
     }
     mystr = RedisModule_CreateStringFromCallReply(reply);
@@ -323,8 +348,10 @@ int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char
         RedisModule_Log(ctx,"warning",
             "Unexpected string reply '%s' (instead of '%s')",
             mystr_ptr, expected_ptr);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -334,6 +361,7 @@ int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, lon
     if (RedisModule_CallReplyType(reply) != REDISMODULE_REPLY_INTEGER) {
         RedisModule_Log(ctx,"warning","Unexpected reply type %d",
             RedisModule_CallReplyType(reply));
+        __A_VARIABLE = 1;
         return 0;
     }
     long long val = RedisModule_CallReplyInteger(reply);
@@ -341,8 +369,10 @@ int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, lon
         RedisModule_Log(ctx,"warning",
             "Unexpected integer reply '%lld' (instead of '%lld')",
             val, expected);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -389,11 +419,13 @@ int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
 
     RedisModule_ReplyWithSimpleString(ctx,"ALL TESTS PASSED");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 
 fail:
     RedisModule_ReplyWithSimpleString(ctx,
         "SOME TEST NOT PASSED! Check server logs");
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -402,35 +434,52 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argc);
 
     if (RedisModule_Init(ctx,"test",1,REDISMODULE_APIVER_1)
-        == REDISMODULE_ERR) return REDISMODULE_ERR;
+        == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.call",
-        TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestCall,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.append",
-        TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringAppend,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.append.am",
-        TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringAppendAM,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.string.printf",
-        TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestStringPrintf,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.ctxflags",
-        TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR)
+        TestCtxFlags,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
     
     if (RedisModule_CreateCommand(ctx,"test.unlink",
-        TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,"test.it",
-        TestIt,"readonly",1,1,1) == REDISMODULE_ERR)
+        TestIt,"readonly",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
     RedisModule_SubscribeToKeyspaceEvents(ctx,
                                             REDISMODULE_NOTIFY_HASH |
@@ -438,8 +487,11 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
                                             REDISMODULE_NOTIFY_STRING,
                                         NotifyCallback);
     if (RedisModule_CreateCommand(ctx,"test.notify",
-        TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        TestNotifications,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/src/multi.c b/src/multi.c
index 5971f46..34cd873 100644
--- a/src/multi.c
+++ b/src/multi.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -36,6 +37,7 @@ void initClientMultiState(client *c) {
     c->mstate.commands = NULL;
     c->mstate.count = 0;
     c->mstate.cmd_flags = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Release all the resources associated with MULTI/EXEC state */
@@ -51,6 +53,7 @@ void freeClientMultiState(client *c) {
         zfree(mc->argv);
     }
     zfree(c->mstate.commands);
+    __A_VARIABLE = 1;
 }
 
 /* Add a new command into the MULTI commands queue */
@@ -69,6 +72,7 @@ void queueMultiCommand(client *c) {
         incrRefCount(mc->argv[j]);
     c->mstate.count++;
     c->mstate.cmd_flags |= c->cmd->flags;
+    __A_VARIABLE = 1;
 }
 
 void discardTransaction(client *c) {
@@ -76,6 +80,7 @@ void discardTransaction(client *c) {
     initClientMultiState(c);
     c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
     unwatchAllKeys(c);
+    __A_VARIABLE = 1;
 }
 
 /* Flag the transacation as DIRTY_EXEC so that EXEC will fail.
@@ -83,24 +88,29 @@ void discardTransaction(client *c) {
 void flagTransaction(client *c) {
     if (c->flags & CLIENT_MULTI)
         c->flags |= CLIENT_DIRTY_EXEC;
+    __A_VARIABLE = 1;
 }
 
 void multiCommand(client *c) {
     if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"MULTI calls can not be nested");
+        __A_VARIABLE = 1;
         return;
     }
     c->flags |= CLIENT_MULTI;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void discardCommand(client *c) {
     if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"DISCARD without MULTI");
+        __A_VARIABLE = 1;
         return;
     }
     discardTransaction(c);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* Send a MULTI command to all the slaves and AOF file. Check the execCommand
@@ -111,6 +121,7 @@ void execCommandPropagateMulti(client *c) {
     propagate(server.multiCommand,c->db->id,&multistring,1,
               PROPAGATE_AOF|PROPAGATE_REPL);
     decrRefCount(multistring);
+    __A_VARIABLE = 1;
 }
 
 void execCommand(client *c) {
@@ -123,6 +134,7 @@ void execCommand(client *c) {
 
     if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"EXEC without MULTI");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -211,6 +223,7 @@ handle_monitor:
      * table, and we do it here with correct ordering. */
     if (listLength(server.monitors) && !server.loading)
         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
+    __A_VARIABLE = 1;
 }
 
 /* ===================== WATCH (CAS alike for MULTI/EXEC) ===================
@@ -241,8 +254,10 @@ void watchForKey(client *c, robj *key) {
     listRewind(c->watched_keys,&li);
     while((ln = listNext(&li))) {
         wk = listNodeValue(ln);
-        if (wk->db == c->db && equalStringObjects(key,wk->key))
-            return; /* Key already watched */
+        if (wk->db == c->db && equalStringObjects(key,wk->key)) {
+            __A_VARIABLE = 1;
+            return;
+        } /* Key already watched */
     }
     /* This key is not already watched in this DB. Let's add it */
     clients = dictFetchValue(c->db->watched_keys,key);
@@ -258,6 +273,7 @@ void watchForKey(client *c, robj *key) {
     wk->db = c->db;
     incrRefCount(key);
     listAddNodeTail(c->watched_keys,wk);
+    __A_VARIABLE = 1;
 }
 
 /* Unwatch all the keys watched by this client. To clean the EXEC dirty
@@ -266,7 +282,10 @@ void unwatchAllKeys(client *c) {
     listIter li;
     listNode *ln;
 
-    if (listLength(c->watched_keys) == 0) return;
+    if (listLength(c->watched_keys) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     listRewind(c->watched_keys,&li);
     while((ln = listNext(&li))) {
         list *clients;
@@ -286,6 +305,7 @@ void unwatchAllKeys(client *c) {
         decrRefCount(wk->key);
         zfree(wk);
     }
+    __A_VARIABLE = 1;
 }
 
 /* "Touch" a key, so that if this key is being WATCHed by some client the
@@ -295,9 +315,15 @@ void touchWatchedKey(redisDb *db, robj *key) {
     listIter li;
     listNode *ln;
 
-    if (dictSize(db->watched_keys) == 0) return;
+    if (dictSize(db->watched_keys) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     clients = dictFetchValue(db->watched_keys, key);
-    if (!clients) return;
+    if (!clients) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
     /* Check if we are already watching for this key */
@@ -307,6 +333,7 @@ void touchWatchedKey(redisDb *db, robj *key) {
 
         c->flags |= CLIENT_DIRTY_CAS;
     }
+    __A_VARIABLE = 1;
 }
 
 /* On FLUSHDB or FLUSHALL all the watched keys that are present before the
@@ -334,6 +361,7 @@ void touchWatchedKeysOnFlush(int dbid) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void watchCommand(client *c) {
@@ -341,15 +369,18 @@ void watchCommand(client *c) {
 
     if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"WATCH inside MULTI is not allowed");
+        __A_VARIABLE = 1;
         return;
     }
     for (j = 1; j < c->argc; j++)
         watchForKey(c,c->argv[j]);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void unwatchCommand(client *c) {
     unwatchAllKeys(c);
     c->flags &= (~CLIENT_DIRTY_CAS);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
diff --git a/src/networking.c b/src/networking.c
index a30a447..b2eb952 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -43,6 +44,7 @@ static void setProtocolError(const char *errstr, client *c);
  * the client output buffer size. */
 size_t sdsZmallocSize(sds s) {
     void *sh = sdsAllocPtr(s);
+    __A_VARIABLE = 1;
     return zmalloc_size(sh);
 }
 
@@ -51,9 +53,12 @@ size_t sdsZmallocSize(sds s) {
 size_t getStringObjectSdsUsedMemory(robj *o) {
     serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
     switch(o->encoding) {
-    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
-    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
-    default: return 0; /* Just integer encoding for now. */
+    case OBJ_ENCODING_RAW: __A_VARIABLE = 1;
+        return sdsZmallocSize(o->ptr);
+    case OBJ_ENCODING_EMBSTR: __A_VARIABLE = 1;
+        return zmalloc_size(o)-sizeof(robj);
+    default: __A_VARIABLE = 1;
+        return 0; /* Just integer encoding for now. */
     }
 }
 
@@ -62,14 +67,17 @@ void *dupClientReplyValue(void *o) {
     clientReplyBlock *old = o;
     clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
     memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
+    __A_VARIABLE = 1;
     return buf;
 }
 
 void freeClientReplyValue(void *o) {
     zfree(o);
+    __A_VARIABLE = 1;
 }
 
 int listMatchObjects(void *a, void *b) {
+    __A_VARIABLE = 1;
     return equalStringObjects(a,b);
 }
 
@@ -83,6 +91,7 @@ void linkClient(client *c) {
     c->client_list_node = listLast(server.clients);
     uint64_t id = htonu64(c->id);
     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
+    __A_VARIABLE = 1;
 }
 
 client *createClient(int fd) {
@@ -105,6 +114,7 @@ client *createClient(int fd) {
         {
             close(fd);
             zfree(c);
+            __A_VARIABLE = 1;
             return NULL;
         }
     }
@@ -163,6 +173,7 @@ client *createClient(int fd) {
     listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
     if (fd != -1) linkClient(c);
     initClientMultiState(c);
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -190,6 +201,7 @@ void clientInstallWriteHandler(client *c) {
         c->flags |= CLIENT_PENDING_WRITE;
         listAddNodeHead(server.clients_pending_write,c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called every time we are going to transmit new data
@@ -217,23 +229,36 @@ void clientInstallWriteHandler(client *c) {
 int prepareClientToWrite(client *c) {
     /* If it's the Lua client we always return ok without installing any
      * handler since there is no socket at all. */
-    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
+    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* CLIENT REPLY OFF / SKIP handling: don't send replies. */
-    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
+    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
      * is set. */
     if ((c->flags & CLIENT_MASTER) &&
-        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
+        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    }
 
-    if (c->fd <= 0) return C_ERR; /* Fake client for AOF loading. */
+    if (c->fd <= 0) {
+    	__A_VARIABLE = 1;
+    	return C_ERR;
+    } /* Fake client for AOF loading. */
 
     /* Schedule the client to write the output buffers to the socket, unless
      * it should already be setup to do so (it has already pending data). */
     if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);
 
     /* Authorize the caller to queue in the output buffer of this client. */
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -244,22 +269,35 @@ int prepareClientToWrite(client *c) {
 int _addReplyToBuffer(client *c, const char *s, size_t len) {
     size_t available = sizeof(c->buf)-c->bufpos;
 
-    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* If there already are entries in the reply list, we cannot
      * add anything more to the static buffer. */
-    if (listLength(c->reply) > 0) return C_ERR;
+    if (listLength(c->reply) > 0) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Check that the buffer has enough space available for this string. */
-    if (len > available) return C_ERR;
+    if (len > available) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     memcpy(c->buf+c->bufpos,s,len);
     c->bufpos+=len;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 void _addReplyStringToList(client *c, const char *s, size_t len) {
-    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listNode *ln = listLast(c->reply);
     clientReplyBlock *tail = ln? listNodeValue(ln): NULL;
@@ -292,6 +330,7 @@ void _addReplyStringToList(client *c, const char *s, size_t len) {
         c->reply_bytes += tail->size;
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
+    __A_VARIABLE = 1;
 }
 
 /* -----------------------------------------------------------------------------
@@ -301,7 +340,10 @@ void _addReplyStringToList(client *c, const char *s, size_t len) {
 
 /* Add the object 'obj' string representation to the client output buffer. */
 void addReply(client *c, robj *obj) {
-    if (prepareClientToWrite(c) != C_OK) return;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (sdsEncodedObject(obj)) {
         if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
@@ -317,6 +359,7 @@ void addReply(client *c, robj *obj) {
     } else {
         serverPanic("Wrong obj->encoding in addReply()");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add the SDS 's' string to the client output buffer, as a side effect
@@ -325,11 +368,13 @@ void addReplySds(client *c, sds s) {
     if (prepareClientToWrite(c) != C_OK) {
         /* The caller expects the sds to be free'd. */
         sdsfree(s);
+        __A_VARIABLE = 1;
         return;
     }
     if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)
         _addReplyStringToList(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* This low level function just adds whatever protocol you send it to the
@@ -341,9 +386,13 @@ void addReplySds(client *c, sds s) {
  * _addReplyStringToList() if we fail to extend the existing tail object
  * in the list of objects. */
 void addReplyString(client *c, const char *s, size_t len) {
-    if (prepareClientToWrite(c) != C_OK) return;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (_addReplyToBuffer(c,s,len) != C_OK)
         _addReplyStringToList(c,s,len);
+    __A_VARIABLE = 1;
 }
 
 /* Low level function called by the addReplyError...() functions.
@@ -379,10 +428,12 @@ void addReplyErrorLength(client *c, const char *s, size_t len) {
                              "to its %s: '%s' after processing the command "
                              "'%s'", from, to, s, cmdname);
     }
+    __A_VARIABLE = 1;
 }
 
 void addReplyError(client *c, const char *err) {
     addReplyErrorLength(c,err,strlen(err));
+    __A_VARIABLE = 1;
 }
 
 void addReplyErrorFormat(client *c, const char *fmt, ...) {
@@ -399,16 +450,19 @@ void addReplyErrorFormat(client *c, const char *fmt, ...) {
     }
     addReplyErrorLength(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatusLength(client *c, const char *s, size_t len) {
     addReplyString(c,"+",1);
     addReplyString(c,s,len);
     addReplyString(c,"\r\n",2);
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatus(client *c, const char *status) {
     addReplyStatusLength(c,status,strlen(status));
+    __A_VARIABLE = 1;
 }
 
 void addReplyStatusFormat(client *c, const char *fmt, ...) {
@@ -418,6 +472,7 @@ void addReplyStatusFormat(client *c, const char *fmt, ...) {
     va_end(ap);
     addReplyStatusLength(c,s,sdslen(s));
     sdsfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* Adds an empty object to the reply list that will contain the multi bulk
@@ -426,8 +481,12 @@ void *addDeferredMultiBulkLength(client *c) {
     /* Note that we install the write event here even if the object is not
      * ready to be sent, since we are sure that before returning to the
      * event loop setDeferredMultiBulkLength() will be called. */
-    if (prepareClientToWrite(c) != C_OK) return NULL;
+    if (prepareClientToWrite(c) != C_OK) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     listAddNodeTail(c->reply,NULL); /* NULL is our placeholder. */
+    __A_VARIABLE = 1;
     return listLast(c->reply);
 }
 
@@ -440,7 +499,10 @@ void setDeferredMultiBulkLength(client *c, void *node, long length) {
 
     /* Abort when *node is NULL: when the client should not accept writes
      * we return NULL in addDeferredMultiBulkLength() */
-    if (node == NULL) return;
+    if (node == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     serverAssert(!listNodeValue(ln));
 
     /* Normally we fill this dummy NULL node, added by addDeferredMultiBulkLength(),
@@ -471,6 +533,7 @@ void setDeferredMultiBulkLength(client *c, void *node, long length) {
         c->reply_bytes += buf->size;
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
+    __A_VARIABLE = 1;
 }
 
 /* Add a double as a bulk reply */
@@ -486,6 +549,7 @@ void addReplyDouble(client *c, double d) {
         slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
         addReplyString(c,sbuf,slen);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add a long double as a bulk reply, but uses a human readable formatting
@@ -495,6 +559,7 @@ void addReplyHumanLongDouble(client *c, long double d) {
     robj *o = createStringObjectFromLongDouble(d,1);
     addReplyBulk(c,o);
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* Add a long long as integer reply or bulk len / multi bulk count.
@@ -528,6 +593,7 @@ void addReplyLongLong(client *c, long long ll) {
         addReply(c,shared.cone);
     else
         addReplyLongLongWithPrefix(c,ll,':');
+    __A_VARIABLE = 1;
 }
 
 void addReplyMultiBulkLen(client *c, long length) {
@@ -535,6 +601,7 @@ void addReplyMultiBulkLen(client *c, long length) {
         addReply(c,shared.mbulkhdr[length]);
     else
         addReplyLongLongWithPrefix(c,length,'*');
+    __A_VARIABLE = 1;
 }
 
 /* Create the length prefix of a bulk reply, example: $2234 */
@@ -561,6 +628,7 @@ void addReplyBulkLen(client *c, robj *obj) {
         addReply(c,shared.bulkhdr[len]);
     else
         addReplyLongLongWithPrefix(c,len,'$');
+    __A_VARIABLE = 1;
 }
 
 /* Add a Redis Object as a bulk reply */
@@ -568,6 +636,7 @@ void addReplyBulk(client *c, robj *obj) {
     addReplyBulkLen(c,obj);
     addReply(c,obj);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add a C buffer as bulk reply */
@@ -575,6 +644,7 @@ void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
     addReplyLongLongWithPrefix(c,len,'$');
     addReplyString(c,p,len);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add sds to reply (takes ownership of sds and frees it) */
@@ -582,6 +652,7 @@ void addReplyBulkSds(client *c, sds s)  {
     addReplyLongLongWithPrefix(c,sdslen(s),'$');
     addReplySds(c,s);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 /* Add a C null term string as bulk reply */
@@ -591,6 +662,7 @@ void addReplyBulkCString(client *c, const char *s) {
     } else {
         addReplyBulkCBuffer(c,s,strlen(s));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Add a long long as a bulk reply */
@@ -600,6 +672,7 @@ void addReplyBulkLongLong(client *c, long long ll) {
 
     len = ll2string(buf,64,ll);
     addReplyBulkCBuffer(c,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* Add an array of C strings as status replies with a heading.
@@ -620,6 +693,7 @@ void addReplyHelp(client *c, const char **help) {
 
     blen++;  /* Account for the header line(s). */
     setDeferredMultiBulkLength(c,blenp,blen);
+    __A_VARIABLE = 1;
 }
 
 /* Add a suggestive error reply.
@@ -632,19 +706,23 @@ void addReplySubcommandSyntaxError(client *c) {
         "Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.",
         (char*)c->argv[1]->ptr,cmd);
     sdsfree(cmd);
+    __A_VARIABLE = 1;
 }
 
 /* Append 'src' client output buffers into 'dst' client output buffers. 
  * This function clears the output buffers of 'src' */
 void AddReplyFromClient(client *dst, client *src) {
-    if (prepareClientToWrite(dst) != C_OK)
+    if (prepareClientToWrite(dst) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     addReplyString(dst,src->buf, src->bufpos);
     if (listLength(src->reply))
         listJoin(dst->reply,src->reply);
     dst->reply_bytes += src->reply_bytes;
     src->reply_bytes = 0;
     src->bufpos = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Copy 'src' client output buffers into 'dst' client output buffers.
@@ -657,11 +735,13 @@ void copyClientOutputBuffer(client *dst, client *src) {
     memcpy(dst->buf,src->buf,src->bufpos);
     dst->bufpos = src->bufpos;
     dst->reply_bytes = src->reply_bytes;
+    __A_VARIABLE = 1;
 }
 
 /* Return true if the specified client has pending reply buffers to write to
  * the socket. */
 int clientHasPendingReplies(client *c) {
+    __A_VARIABLE = 1;
     return c->bufpos || listLength(c->reply);
 }
 
@@ -695,6 +775,7 @@ static void acceptCommonHandler(int fd, int flags, char *ip) {
             "Error registering fd event for the new client: %s (fd=%d)",
             strerror(errno),fd);
         close(fd); /* May be already closed, just ignore errors */
+        __A_VARIABLE = 1;
         return;
     }
     /* If maxclient directive is set and this is one client more... close the
@@ -710,6 +791,7 @@ static void acceptCommonHandler(int fd, int flags, char *ip) {
         }
         server.stat_rejected_conn++;
         freeClient(c);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -729,12 +811,14 @@ static void acceptCommonHandler(int fd, int flags, char *ip) {
             }
             server.stat_rejected_conn++;
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
     }
 
     server.stat_numconnections++;
     c->flags |= flags;
+    __A_VARIABLE = 1;
 }
 
 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -750,11 +834,13 @@ void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
         acceptCommonHandler(cfd,0,cip);
     }
+    __A_VARIABLE = 1;
 }
 
 void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -769,11 +855,13 @@ void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EWOULDBLOCK)
                 serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
+            __A_VARIABLE = 1;
             return;
         }
         serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
         acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 static void freeClientArgv(client *c) {
@@ -782,6 +870,7 @@ static void freeClientArgv(client *c) {
         decrRefCount(c->argv[j]);
     c->argc = 0;
     c->cmd = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Close all the slaves connections. This is useful in chained replication
@@ -792,6 +881,7 @@ void disconnectSlaves(void) {
         listNode *ln = listFirst(server.slaves);
         freeClient((client*)ln->value);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Remove the specified client from global lists where the client could
@@ -848,6 +938,7 @@ void unlinkClient(client *c) {
         listDelNode(server.unblocked_clients,ln);
         c->flags &= ~CLIENT_UNBLOCKED;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeClient(client *c) {
@@ -857,6 +948,7 @@ void freeClient(client *c) {
      * to at least use asynchronous freeing. */
     if (c->flags & CLIENT_PROTECTED) {
         freeClientAsync(c);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -872,6 +964,7 @@ void freeClient(client *c) {
                           CLIENT_BLOCKED)))
         {
             replicationCacheMaster(c);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -948,6 +1041,7 @@ void freeClient(client *c) {
     freeClientMultiState(c);
     sdsfree(c->peerid);
     flexos_free_whitelist(c);
+    __A_VARIABLE = 1;
 }
 
 /* Schedule a client to free it at a safe time in the serverCron() function.
@@ -955,9 +1049,13 @@ void freeClient(client *c) {
  * a context where calling freeClient() is not possible, because the client
  * should be valid for the continuation of the flow of the program. */
 void freeClientAsync(client *c) {
-    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
+    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) {
+        __A_VARIABLE = 1;
+        return;
+    }
     c->flags |= CLIENT_CLOSE_ASAP;
     listAddNodeTail(server.clients_to_close,c);
+    __A_VARIABLE = 1;
 }
 
 void freeClientsInAsyncFreeQueue(void) {
@@ -969,6 +1067,7 @@ void freeClientsInAsyncFreeQueue(void) {
         freeClient(c);
         listDelNode(server.clients_to_close,ln);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return a client by ID, or NULL if the client ID is not in the set
@@ -977,6 +1076,7 @@ void freeClientsInAsyncFreeQueue(void) {
 client *lookupClientByID(uint64_t id) {
     id = htonu64(id);
     client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
+    __A_VARIABLE = 1;
     return (c == raxNotFound) ? NULL : c;
 }
 
@@ -1079,6 +1179,7 @@ void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
     UNUSED(el);
     UNUSED(mask);
     writeToClient(fd,privdata,1);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called just before entering the event loop, in the hope
@@ -1124,6 +1225,7 @@ int handleClientsWithPendingWrites(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return processed;
 }
 
@@ -1149,6 +1251,7 @@ void resetClient(client *c) {
         c->flags |= CLIENT_REPLY_SKIP;
         c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This funciton is used when we want to re-enter the event loop but there
@@ -1168,6 +1271,7 @@ void protectClient(client *c) {
     c->flags |= CLIENT_PROTECTED;
     aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
     aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    __A_VARIABLE = 1;
 }
 
 /* This will undo the client protection done by protectClient() */
@@ -1177,6 +1281,7 @@ void unprotectClient(client *c) {
         aeCreateFileEvent(server.el,c->fd,AE_READABLE,readQueryFromClient,c);
         if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,
@@ -1201,6 +1306,7 @@ int processInlineBuffer(client *c) {
             addReplyError(c,"Protocol error: too big inline request");
             setProtocolError("too big inline request",c);
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1216,6 +1322,7 @@ int processInlineBuffer(client *c) {
     if (argv == NULL) {
         addReplyError(c,"Protocol error: unbalanced quotes in request");
         setProtocolError("unbalanced quotes in inline request",c);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1244,6 +1351,7 @@ int processInlineBuffer(client *c) {
         }
     }
     s_free(argv);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1275,6 +1383,7 @@ static void setProtocolError(const char *errstr, client *c) {
         sdsfree(client);
     }
     c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+    __A_VARIABLE = 1;
 }
 
 /* Process the query buffer for client 'c', setting up the client argument
@@ -1304,12 +1413,15 @@ int processMultibulkBuffer(client *c) {
                 addReplyError(c,"Protocol error: too big mbulk count string");
                 setProtocolError("too big mbulk count string",c);
             }
+            __A_VARIABLE = 1;
             return C_ERR;
         }
 
         /* Buffer should also contain \n */
-        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
+        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2)) {
+            __A_VARIABLE = 1;
             return C_ERR;
+        }
 
         /* We know for sure there is a whole line since newline != NULL,
          * so go ahead and find out the multi bulk length. */
@@ -1318,12 +1430,16 @@ int processMultibulkBuffer(client *c) {
         if (!ok || ll > 1024*1024) {
             addReplyError(c,"Protocol error: invalid multibulk length");
             setProtocolError("invalid mbulk count",c);
+            __A_VARIABLE = 1;
             return C_ERR;
         }
 
         c->qb_pos = (newline-c->querybuf)+2;
 
-        if (ll <= 0) return C_OK;
+        if (ll <= 0) {
+            __A_VARIABLE = 1;
+            return C_OK;
+        }
 
         c->multibulklen = ll;
 
@@ -1342,6 +1458,7 @@ int processMultibulkBuffer(client *c) {
                     addReplyError(c,
                         "Protocol error: too big bulk count string");
                     setProtocolError("too big bulk count string",c);
+                    __A_VARIABLE = 1;
                     return C_ERR;
                 }
                 break;
@@ -1356,6 +1473,7 @@ int processMultibulkBuffer(client *c) {
                     "Protocol error: expected '$', got '%c'",
                     c->querybuf[c->qb_pos]);
                 setProtocolError("expected $ but got something else",c);
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
 
@@ -1363,6 +1481,7 @@ int processMultibulkBuffer(client *c) {
             if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
                 addReplyError(c,"Protocol error: invalid bulk length");
                 setProtocolError("invalid bulk length",c);
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
 
@@ -1417,9 +1536,13 @@ int processMultibulkBuffer(client *c) {
     }
 
     /* We're done when c->multibulk == 0 */
-    if (c->multibulklen == 0) return C_OK;
+    if (c->multibulklen == 0) {
+        __A_VARIABLE = 1;
+        return C_OK;
+    }
 
     /* Still not ready to process the command */
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1500,6 +1623,7 @@ void processInputBuffer(client *c) {
     }
 
     server.current_client = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* This is a wrapper for processInputBuffer that also cares about handling
@@ -1519,6 +1643,7 @@ void processInputBufferAndReplicate(client *c) {
             sdsrange(c->pending_querybuf,applied,-1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -1609,6 +1734,7 @@ void getClientsMaxBuffers(unsigned long *longest_output_list,
     }
     *longest_output_list = lol;
     *biggest_input_buffer = bib;
+    __A_VARIABLE = 1;
 }
 
 /* A Redis "Peer ID" is a colon separated ip:port pair.
@@ -1644,6 +1770,7 @@ char *getClientPeerId(client *c) {
         genClientPeerId(c,peerid,sizeof(peerid));
         c->peerid = sdsnew(peerid);
     }
+    __A_VARIABLE = 1;
     return c->peerid;
 }
 
@@ -1713,6 +1840,7 @@ sds getAllClientsInfoString(int type) {
         o = catClientInfoString(o,client);
         o = sdscatlen(o,"\n",1);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -1954,6 +2082,7 @@ void securityWarningCommand(client *c) {
         logged_time = now;
     }
     freeClientAsync(c);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite the command vector of the client. All the new objects ref count
@@ -1984,6 +2113,7 @@ void rewriteClientCommandVector(client *c, int argc, ...) {
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
     serverAssertWithInfo(c,NULL,c->cmd != NULL);
     va_end(ap);
+    __A_VARIABLE = 1;
 }
 
 /* Completely replace the client command vector with the provided one. */
@@ -1994,6 +2124,7 @@ void replaceClientCommandVector(client *c, int argc, robj **argv) {
     c->argc = argc;
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
     serverAssertWithInfo(c,NULL,c->cmd != NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Rewrite a single item in the command vector.
@@ -2025,6 +2156,7 @@ void rewriteClientCommandArgument(client *c, int i, robj *newval) {
         c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
         serverAssertWithInfo(c,NULL,c->cmd != NULL);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function returns the number of bytes that Redis is
@@ -2035,6 +2167,7 @@ void rewriteClientCommandArgument(client *c, int i, robj *newval) {
  * enforcing the client output length limits. */
 unsigned long getClientOutputBufferMemoryUsage(client *c) {
     unsigned long list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
+    __A_VARIABLE = 1;
     return c->reply_bytes + (list_item_size*listLength(c->reply));
 }
 
@@ -2048,10 +2181,19 @@ unsigned long getClientOutputBufferMemoryUsage(client *c) {
  * CLIENT_TYPE_MASTER -> The client representing our replication master.
  */
 int getClientType(client *c) {
-    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
-    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
+    if (c->flags & CLIENT_MASTER) {
+        __A_VARIABLE = 1;
+        return CLIENT_TYPE_MASTER;
+    }
+    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
+        __A_VARIABLE = 1;
         return CLIENT_TYPE_SLAVE;
-    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
+    }
+    if (c->flags & CLIENT_PUBSUB) {
+        __A_VARIABLE = 1;
+        return CLIENT_TYPE_PUBSUB;
+    }
+    __A_VARIABLE = 1;
     return CLIENT_TYPE_NORMAL;
 }
 
@@ -2066,11 +2208,16 @@ int getClientTypeByName(char *name) {
 
 char *getClientTypeName(int class) {
     switch(class) {
-    case CLIENT_TYPE_NORMAL: return "normal";
-    case CLIENT_TYPE_SLAVE:  return "slave";
-    case CLIENT_TYPE_PUBSUB: return "pubsub";
-    case CLIENT_TYPE_MASTER: return "master";
-    default:                       return NULL;
+    case CLIENT_TYPE_NORMAL: __A_VARIABLE = 1;
+        return "normal";
+    case CLIENT_TYPE_SLAVE:  __A_VARIABLE = 1;
+        return "slave";
+    case CLIENT_TYPE_PUBSUB: __A_VARIABLE = 1;
+        return "pubsub";
+    case CLIENT_TYPE_MASTER: __A_VARIABLE = 1;
+        return "master";
+    default:                       __A_VARIABLE = 1;
+        return NULL;
     }
 }
 
@@ -2115,6 +2262,7 @@ int checkClientOutputBufferLimits(client *c) {
     } else {
         c->obuf_soft_limit_reached_time = 0;
     }
+    __A_VARIABLE = 1;
     return soft || hard;
 }
 
@@ -2126,9 +2274,15 @@ int checkClientOutputBufferLimits(client *c) {
  * called from contexts where the client can't be freed safely, i.e. from the
  * lower level functions pushing data inside the client output buffers. */
 void asyncCloseClientOnOutputBufferLimitReached(client *c) {
-    if (c->fd == -1) return; /* It is unsafe to free fake clients. */
+    if (c->fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    } /* It is unsafe to free fake clients. */
     serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
-    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
+    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (checkClientOutputBufferLimits(c)) {
         sds client = catClientInfoString(sdsempty(),c);
 
@@ -2136,6 +2290,7 @@ void asyncCloseClientOnOutputBufferLimitReached(client *c) {
         serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
         sdsfree(client);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Helper function used by freeMemoryIfNeeded() in order to flush slaves
@@ -2175,6 +2330,7 @@ void flushSlavesOutputBuffers(void) {
             writeToClient(slave->fd,slave,0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Pause clients up to the specified unixtime (in ms). While clients
@@ -2198,6 +2354,7 @@ void pauseClients(mstime_t end) {
     if (!server.clients_paused || end > server.clients_pause_end_time)
         server.clients_pause_end_time = end;
     server.clients_paused = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if clients are currently paused. As a side effect the
@@ -2224,6 +2381,7 @@ int clientsArePaused(void) {
             queueClientForReprocessing(c);
         }
     }
+    __A_VARIABLE = 1;
     return server.clients_paused;
 }
 
@@ -2249,5 +2407,6 @@ int processEventsWhileBlocked(void) {
         if (!events) break;
         count += events;
     }
+    __A_VARIABLE = 1;
     return count;
 }
diff --git a/src/notify.c b/src/notify.c
index 1afb36f..f25d691 100644
--- a/src/notify.c
+++ b/src/notify.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2013, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -55,9 +56,11 @@ int keyspaceEventsStringToFlags(char *classes) {
         case 'K': flags |= NOTIFY_KEYSPACE; break;
         case 'E': flags |= NOTIFY_KEYEVENT; break;
         case 't': flags |= NOTIFY_STREAM; break;
-        default: return -1;
+        default: __A_VARIABLE = 1;
+            return -1;
         }
     }
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -84,6 +87,7 @@ sds keyspaceEventsFlagsToString(int flags) {
     }
     if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,"K",1);
     if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,"E",1);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -107,7 +111,10 @@ void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
      moduleNotifyKeyspaceEvent(type, event, key, dbid);
     
     /* If notifications for this class of events are off, return ASAP. */
-    if (!(server.notify_keyspace_events & type)) return;
+    if (!(server.notify_keyspace_events & type)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     eventobj = createStringObject(event,strlen(event));
 
@@ -135,4 +142,5 @@ void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
         decrRefCount(chanobj);
     }
     decrRefCount(eventobj);
+    __A_VARIABLE = 1;
 }
diff --git a/src/object.c b/src/object.c
index 58f9162..57b07b4 100644
--- a/src/object.c
+++ b/src/object.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis Object implementation.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -52,6 +53,7 @@ robj *createObject(int type, void *ptr) {
     } else {
         o->lru = LRU_CLOCK();
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -69,12 +71,14 @@ robj *createObject(int type, void *ptr) {
 robj *makeObjectShared(robj *o) {
     serverAssert(o->refcount == 1);
     o->refcount = OBJ_SHARED_REFCOUNT;
+    __A_VARIABLE = 1;
     return o;
 }
 
 /* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
  * string object where o->ptr points to a proper sds string. */
 robj *createRawStringObject(const char *ptr, size_t len) {
+    __A_VARIABLE = 1;
     return createObject(OBJ_STRING, sdsnewlen(ptr,len));
 }
 
@@ -106,6 +110,7 @@ robj *createEmbeddedStringObject(const char *ptr, size_t len) {
     } else {
         memset(sh->buf,0,len+1);
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -153,12 +158,14 @@ robj *createStringObjectFromLongLongWithOptions(long long value, int valueobj) {
             o = createObject(OBJ_STRING,sdsfromlonglong(value));
         }
     }
+    __A_VARIABLE = 1;
     return o;
 }
 
 /* Wrapper for createStringObjectFromLongLongWithOptions() always demanding
  * to create a shared object if possible. */
 robj *createStringObjectFromLongLong(long long value) {
+    __A_VARIABLE = 1;
     return createStringObjectFromLongLongWithOptions(value,0);
 }
 
@@ -167,6 +174,7 @@ robj *createStringObjectFromLongLong(long long value) {
  * as a value in the key space, and Redis is configured to evict based on
  * LFU/LRU. */
 robj *createStringObjectFromLongLongForValue(long long value) {
+    __A_VARIABLE = 1;
     return createStringObjectFromLongLongWithOptions(value,1);
 }
 
@@ -179,6 +187,7 @@ robj *createStringObjectFromLongLongForValue(long long value) {
 robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
     char buf[MAX_LONG_DOUBLE_CHARS];
     int len = ld2string(buf,sizeof(buf),value,humanfriendly);
+    __A_VARIABLE = 1;
     return createStringObject(buf,len);
 }
 
@@ -197,24 +206,29 @@ robj *dupStringObject(const robj *o) {
 
     switch(o->encoding) {
     case OBJ_ENCODING_RAW:
+        __A_VARIABLE = 1;
         return createRawStringObject(o->ptr,sdslen(o->ptr));
     case OBJ_ENCODING_EMBSTR:
+        __A_VARIABLE = 1;
         return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
     case OBJ_ENCODING_INT:
         d = createObject(OBJ_STRING, NULL);
         d->encoding = OBJ_ENCODING_INT;
         d->ptr = o->ptr;
+        __A_VARIABLE = 1;
         return d;
     default:
         serverPanic("Wrong encoding.");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 robj *createQuicklistObject(void) {
     quicklist *l = quicklistCreate();
     robj *o = createObject(OBJ_LIST,l);
     o->encoding = OBJ_ENCODING_QUICKLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -222,6 +236,7 @@ robj *createZiplistObject(void) {
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_LIST,zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -229,6 +244,7 @@ robj *createSetObject(void) {
     dict *d = dictCreate(&setDictType,NULL);
     robj *o = createObject(OBJ_SET,d);
     o->encoding = OBJ_ENCODING_HT;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -236,6 +252,7 @@ robj *createIntsetObject(void) {
     intset *is = intsetNew();
     robj *o = createObject(OBJ_SET,is);
     o->encoding = OBJ_ENCODING_INTSET;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -243,6 +260,7 @@ robj *createHashObject(void) {
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_HASH, zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -254,6 +272,7 @@ robj *createZsetObject(void) {
     zs->zsl = zslCreate();
     o = createObject(OBJ_ZSET,zs);
     o->encoding = OBJ_ENCODING_SKIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -261,6 +280,7 @@ robj *createZsetZiplistObject(void) {
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_ZSET,zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -268,6 +288,7 @@ robj *createStreamObject(void) {
     stream *s = streamNew();
     robj *o = createObject(OBJ_STREAM,s);
     o->encoding = OBJ_ENCODING_STREAM;
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -275,6 +296,7 @@ robj *createModuleObject(moduleType *mt, void *value) {
     moduleValue *mv = zmalloc(sizeof(*mv));
     mv->type = mt;
     mv->value = value;
+    __A_VARIABLE = 1;
     return createObject(OBJ_MODULE,mv);
 }
 
@@ -282,6 +304,7 @@ void freeStringObject(robj *o) {
     if (o->encoding == OBJ_ENCODING_RAW) {
         sdsfree(o->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 void freeListObject(robj *o) {
@@ -290,6 +313,7 @@ void freeListObject(robj *o) {
     } else {
         serverPanic("Unknown list encoding type");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeSetObject(robj *o) {
@@ -303,6 +327,7 @@ void freeSetObject(robj *o) {
     default:
         serverPanic("Unknown set encoding type");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeZsetObject(robj *o) {
@@ -320,6 +345,7 @@ void freeZsetObject(robj *o) {
     default:
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void freeHashObject(robj *o) {
@@ -334,20 +360,24 @@ void freeHashObject(robj *o) {
         serverPanic("Unknown hash encoding type");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeModuleObject(robj *o) {
     moduleValue *mv = o->ptr;
     mv->type->free(mv->value);
     zfree(mv);
+    __A_VARIABLE = 1;
 }
 
 void freeStreamObject(robj *o) {
     freeStream(o->ptr);
+    __A_VARIABLE = 1;
 }
 
 void incrRefCount(robj *o) {
     if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount++;
+    __A_VARIABLE = 1;
 }
 
 void decrRefCount(robj *o) {
@@ -367,6 +397,7 @@ void decrRefCount(robj *o) {
         if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
         if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This variant of decrRefCount() gets its argument as void, and is useful
@@ -374,6 +405,7 @@ void decrRefCount(robj *o) {
  * prototype for the free method. */
 void decrRefCountVoid(void *o) {
     decrRefCount(o);
+    __A_VARIABLE = 1;
 }
 
 /* This function set the ref count to zero without freeing the object.
@@ -390,18 +422,22 @@ void decrRefCountVoid(void *o) {
  */
 robj *resetRefCount(robj *obj) {
     obj->refcount = 0;
+    __A_VARIABLE = 1;
     return obj;
 }
 
 int checkType(client *c, robj *o, int type) {
     if (o->type != type) {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 int isSdsRepresentableAsLongLong(sds s, long long *llval) {
+    __A_VARIABLE = 1;
     return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
 }
 
@@ -425,6 +461,7 @@ void trimStringObjectIfNeeded(robj *o) {
     {
         o->ptr = sdsRemoveFreeSpace(o->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Try to encode a string object in order to save space */
@@ -572,11 +609,13 @@ int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {
 
 /* Wrapper for compareStringObjectsWithFlags() using binary comparison. */
 int compareStringObjects(robj *a, robj *b) {
+    __A_VARIABLE = 1;
     return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
 }
 
 /* Wrapper for compareStringObjectsWithFlags() using collation. */
 int collateStringObjects(robj *a, robj *b) {
+    __A_VARIABLE = 1;
     return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
 }
 
@@ -640,9 +679,11 @@ int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *m
         } else {
             addReplyError(c,"value is not a valid float");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -682,9 +723,11 @@ int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, cons
         } else {
             addReplyError(c,"value is not a valid float");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -715,39 +758,55 @@ int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const ch
         } else {
             addReplyError(c,"value is not an integer or out of range");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
     long long value;
 
-    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
+    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     if (value < LONG_MIN || value > LONG_MAX) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is out of range");
         }
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     *target = value;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
 char *strEncoding(int encoding) {
     switch(encoding) {
-    case OBJ_ENCODING_RAW: return "raw";
-    case OBJ_ENCODING_INT: return "int";
-    case OBJ_ENCODING_HT: return "hashtable";
-    case OBJ_ENCODING_QUICKLIST: return "quicklist";
-    case OBJ_ENCODING_ZIPLIST: return "ziplist";
-    case OBJ_ENCODING_INTSET: return "intset";
-    case OBJ_ENCODING_SKIPLIST: return "skiplist";
-    case OBJ_ENCODING_EMBSTR: return "embstr";
-    default: return "unknown";
+    case OBJ_ENCODING_RAW: __A_VARIABLE = 1;
+        return "raw";
+    case OBJ_ENCODING_INT: __A_VARIABLE = 1;
+        return "int";
+    case OBJ_ENCODING_HT: __A_VARIABLE = 1;
+        return "hashtable";
+    case OBJ_ENCODING_QUICKLIST: __A_VARIABLE = 1;
+        return "quicklist";
+    case OBJ_ENCODING_ZIPLIST: __A_VARIABLE = 1;
+        return "ziplist";
+    case OBJ_ENCODING_INTSET: __A_VARIABLE = 1;
+        return "intset";
+    case OBJ_ENCODING_SKIPLIST: __A_VARIABLE = 1;
+        return "skiplist";
+    case OBJ_ENCODING_EMBSTR: __A_VARIABLE = 1;
+        return "embstr";
+    default: __A_VARIABLE = 1;
+        return "unknown";
     }
 }
 
@@ -943,6 +1002,7 @@ size_t objectComputeSize(robj *o, size_t sample_size) {
     } else {
         serverPanic("Unknown object type");
     }
+    __A_VARIABLE = 1;
     return asize;
 }
 
@@ -950,6 +1010,7 @@ size_t objectComputeSize(robj *o, size_t sample_size) {
 void freeMemoryOverheadData(struct redisMemOverhead *mh) {
     zfree(mh->db);
     zfree(mh);
+    __A_VARIABLE = 1;
 }
 
 /* Return a struct redisMemOverhead filled with memory overhead
@@ -1079,6 +1140,7 @@ struct redisMemOverhead *getMemoryOverheadData(void) {
     mh->dataset_perc = (float)mh->dataset*100/net_usage;
     mh->bytes_per_key = mh->total_keys ? (net_usage / mh->total_keys) : 0;
 
+    __A_VARIABLE = 1;
     return mh;
 }
 
@@ -1088,6 +1150,7 @@ void inputCatSds(void *result, const char *str) {
     /* result is actually a (sds *), so re-cast it here */
     sds *info = (sds *)result;
     *info = sdscat(*info, str);
+    __A_VARIABLE = 1;
 }
 
 /* This implements MEMORY DOCTOR. An human readable analysis of the Redis
@@ -1201,6 +1264,7 @@ sds getMemoryDoctorReport(void) {
         s = sdscat(s,"I'm here to keep you safe, Sam. I want to help you.\n");
     }
     freeMemoryOverheadData(mh);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -1232,6 +1296,7 @@ void objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
             lru_abs = (lru_clock+(LRU_CLOCK_MAX/2)) % LRU_CLOCK_MAX;
         val->lru = lru_abs;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ======================= The OBJECT and MEMORY commands =================== */
@@ -1241,7 +1306,11 @@ void objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
 robj *objectCommandLookup(client *c, robj *key) {
     dictEntry *de;
 
-    if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;
+    if ((de = dictFind(c->db->dict,key->ptr)) == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return (robj*) dictGetVal(de);
 }
 
@@ -1249,6 +1318,7 @@ robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
     robj *o = objectCommandLookup(c,key);
 
     if (!o) addReply(c, reply);
+    __A_VARIABLE = 1;
     return o;
 }
 
diff --git a/src/pqsort.c b/src/pqsort.c
index 508c09f..4acae5a 100644
--- a/src/pqsort.c
+++ b/src/pqsort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The following is the NetBSD libc qsort implementation modified in order to
  * support partial sorting of ranges for Redis.
  *
@@ -73,6 +74,7 @@ swapfunc(char *a, char *b, size_t n, int swaptype)
 		swapcode(long, a, b, n)
 	else
 		swapcode(char, a, b, n)
+	__A_VARIABLE = 1;
 }
 
 #define swap(a, b)						\
@@ -90,6 +92,7 @@ med3(char *a, char *b, char *c,
     int (*cmp) (const void *, const void *))
 {
 
+	__A_VARIABLE = 1;
 	return cmp(a, b) < 0 ?
 	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
               :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
@@ -109,6 +112,7 @@ loop:	SWAPINIT(a, es);
 			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 			     pl -= es)
 				swap(pl, pl - es);
+		__A_VARIABLE = 1;
 		return;
 	}
 	pm = (char *) a + (n / 2) * es;
@@ -174,6 +178,7 @@ loop:	SWAPINIT(a, es);
 		    goto loop;
 	}
 /*		qsort(pn - r, r / es, es, cmp);*/
+	__A_VARIABLE = 1;
 }
 
 void
@@ -182,4 +187,5 @@ pqsort(void *a, size_t n, size_t es,
 {
     _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
                        ((unsigned char*)a)+((rrange+1)*es)-1);
+    __A_VARIABLE = 1;
 }
diff --git a/src/pubsub.c b/src/pubsub.c
index 859eb46..b56c81c 100644
--- a/src/pubsub.c
+++ b/src/pubsub.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -38,17 +39,20 @@ void freePubsubPattern(void *p) {
 
     decrRefCount(pat->pattern);
     zfree(pat);
+    __A_VARIABLE = 1;
 }
 
 int listMatchPubsubPattern(void *a, void *b) {
     pubsubPattern *pa = a, *pb = b;
 
+    __A_VARIABLE = 1;
     return (pa->client == pb->client) &&
            (equalStringObjects(pa->pattern,pb->pattern));
 }
 
 /* Return the number of channels + patterns a client is subscribed to. */
 int clientSubscriptionsCount(client *c) {
+    __A_VARIABLE = 1;
     return dictSize(c->pubsub_channels)+
            listLength(c->pubsub_patterns);
 }
@@ -80,6 +84,7 @@ int pubsubSubscribeChannel(client *c, robj *channel) {
     addReply(c,shared.subscribebulk);
     addReplyBulk(c,channel);
     addReplyLongLong(c,clientSubscriptionsCount(c));
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -120,6 +125,7 @@ int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
 
     }
     decrRefCount(channel); /* it is finally safe to release it */
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -142,6 +148,7 @@ int pubsubSubscribePattern(client *c, robj *pattern) {
     addReply(c,shared.psubscribebulk);
     addReplyBulk(c,pattern);
     addReplyLongLong(c,clientSubscriptionsCount(c));
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -170,6 +177,7 @@ int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
                        listLength(c->pubsub_patterns));
     }
     decrRefCount(pattern);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -194,6 +202,7 @@ int pubsubUnsubscribeAllChannels(client *c, int notify) {
                        listLength(c->pubsub_patterns));
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -218,6 +227,7 @@ int pubsubUnsubscribeAllPatterns(client *c, int notify) {
         addReplyLongLong(c,dictSize(c->pubsub_channels)+
                        listLength(c->pubsub_patterns));
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -267,6 +277,7 @@ int pubsubPublishMessage(robj *channel, robj *message) {
         }
         decrRefCount(channel);
     }
+    __A_VARIABLE = 1;
     return receivers;
 }
 
@@ -280,6 +291,7 @@ void subscribeCommand(client *c) {
     for (j = 1; j < c->argc; j++)
         pubsubSubscribeChannel(c,c->argv[j]);
     c->flags |= CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void unsubscribeCommand(client *c) {
@@ -292,6 +304,7 @@ void unsubscribeCommand(client *c) {
             pubsubUnsubscribeChannel(c,c->argv[j],1);
     }
     if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void psubscribeCommand(client *c) {
@@ -300,6 +313,7 @@ void psubscribeCommand(client *c) {
     for (j = 1; j < c->argc; j++)
         pubsubSubscribePattern(c,c->argv[j]);
     c->flags |= CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void punsubscribeCommand(client *c) {
@@ -312,6 +326,7 @@ void punsubscribeCommand(client *c) {
             pubsubUnsubscribePattern(c,c->argv[j],1);
     }
     if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
+    __A_VARIABLE = 1;
 }
 
 void publishCommand(client *c) {
@@ -321,6 +336,7 @@ void publishCommand(client *c) {
     else
         forceCommandPropagation(c,PROPAGATE_REPL);
     addReplyLongLong(c,receivers);
+    __A_VARIABLE = 1;
 }
 
 /* PUBSUB command for Pub/Sub introspection. */
@@ -374,4 +390,5 @@ NULL
     } else {
         addReplySubcommandSyntaxError(c);
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/quicklist.c b/src/quicklist.c
index 49412cf..e80c0d3 100644
--- a/src/quicklist.c
+++ b/src/quicklist.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* quicklist.c - A doubly linked list of ziplists
  *
  * Copyright (c) 2014, Matt Stancliff <matt@genges.com>
@@ -49,6 +50,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -119,6 +121,7 @@ quicklist *quicklistCreate(void) {
     quicklist->count = 0;
     quicklist->compress = 0;
     quicklist->fill = -2;
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
@@ -145,12 +148,14 @@ void quicklistSetFill(quicklist *quicklist, int fill) {
 void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
     quicklistSetFill(quicklist, fill);
     quicklistSetCompressDepth(quicklist, depth);
+    __A_VARIABLE = 1;
 }
 
 /* Create a new quicklist with some default parameters. */
 quicklist *quicklistNew(int fill, int compress) {
     quicklist *quicklist = quicklistCreate();
     quicklistSetOptions(quicklist, fill, compress);
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
@@ -164,11 +169,13 @@ REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
     node->encoding = QUICKLIST_NODE_ENCODING_RAW;
     node->container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
     node->recompress = 0;
+    __A_VARIABLE = 1;
     return node;
 }
 
 /* Return cached quicklist count */
-unsigned long quicklistCount(const quicklist *ql) { return ql->count; }
+unsigned long quicklistCount(const quicklist *ql) { __A_VARIABLE = 1;
+	return ql->count; }
 
 /* Free entire quicklist. */
 void quicklistRelease(quicklist *quicklist) {
@@ -200,8 +207,10 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
 #endif
 
     /* Don't bother compressing small values */
-    if (node->sz < MIN_COMPRESS_BYTES)
+    if (node->sz < MIN_COMPRESS_BYTES) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);
 
@@ -211,6 +220,7 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
         lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
         /* lzf_compress aborts/rejects compression if value not compressable. */
         zfree(lzf);
+        __A_VARIABLE = 1;
         return 0;
     }
     lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
@@ -218,6 +228,7 @@ REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
     node->zl = (unsigned char *)lzf;
     node->encoding = QUICKLIST_NODE_ENCODING_LZF;
     node->recompress = 0;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -241,11 +252,13 @@ REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
     if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
         /* Someone requested decompress, but we can't decompress.  Not good. */
         zfree(decompressed);
+        __A_VARIABLE = 1;
         return 0;
     }
     zfree(lzf);
     node->zl = decompressed;
     node->encoding = QUICKLIST_NODE_ENCODING_RAW;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -272,6 +285,7 @@ REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
 size_t quicklistGetLzf(const quicklistNode *node, void **data) {
     quicklistLZF *lzf = (quicklistLZF *)node->zl;
     *data = lzf->compressed;
+    __A_VARIABLE = 1;
     return lzf->sz;
 }
 
@@ -408,12 +422,14 @@ REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                              quicklistNode *old_node,
                                              quicklistNode *new_node) {
     __quicklistInsertNode(quicklist, old_node, new_node, 0);
+    __A_VARIABLE = 1;
 }
 
 REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
     __quicklistInsertNode(quicklist, old_node, new_node, 1);
+    __A_VARIABLE = 1;
 }
 
 REDIS_STATIC int
@@ -550,6 +566,7 @@ void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {
 
     _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
     quicklist->count += node->count;
+    __A_VARIABLE = 1;
 }
 
 /* Append all values of ziplist 'zl' individually into 'quicklist'.
@@ -576,6 +593,7 @@ quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
         p = ziplistNext(zl, p);
     }
     zfree(zl);
+    __A_VARIABLE = 1;
     return quicklist;
 }
 
@@ -584,6 +602,7 @@ quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,
  * Returns new quicklist.  Frees passed-in ziplist 'zl'. */
 quicklist *quicklistCreateFromZiplist(int fill, int compress,
                                       unsigned char *zl) {
+    __A_VARIABLE = 1;
     return quicklistAppendValuesFromZiplist(quicklistNew(fill, compress), zl);
 }
 
@@ -643,6 +662,7 @@ REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
     }
     quicklist->count--;
     /* If we deleted the node, the original node is no longer valid */
+    __A_VARIABLE = 1;
     return gone ? 1 : 0;
 }
 
@@ -677,6 +697,7 @@ void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
      *  if we deleted the last element at offet N and now
      *  length of this ziplist is N-1, the next call into
      *  quicklistNext() will jump to the next node. */
+    __A_VARIABLE = 1;
 }
 
 /* Replace quicklist entry at offset 'index' by 'data' with length 'sz'.
@@ -841,6 +862,7 @@ REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
     quicklistNodeUpdateSz(new_node);
 
     D("After split lengths: orig (%d), new (%d)", node->count, new_node->count);
+    __A_VARIABLE = 1;
     return new_node;
 }
 
@@ -961,11 +983,13 @@ REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,
 void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,
                            void *value, const size_t sz) {
     _quicklistInsert(quicklist, entry, value, sz, 0);
+    __A_VARIABLE = 1;
 }
 
 void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
                           void *value, const size_t sz) {
     _quicklistInsert(quicklist, entry, value, sz, 1);
+    __A_VARIABLE = 1;
 }
 
 /* Delete a range of elements from the quicklist.
@@ -1059,6 +1083,7 @@ int quicklistDelRange(quicklist *quicklist, const long start,
 
 /* Passthrough to ziplistCompare() */
 int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {
+    __A_VARIABLE = 1;
     return ziplistCompare(p1, p2, p2_len);
 }
 
@@ -1110,6 +1135,7 @@ void quicklistReleaseIterator(quicklistIter *iter) {
         quicklistCompress(iter->quicklist, iter->current);
 
     zfree(iter);
+    __A_VARIABLE = 1;
 }
 
 /* Get next element in iterator.
@@ -1230,6 +1256,7 @@ quicklist *quicklistDup(quicklist *orig) {
     }
 
     /* copy->count must equal orig->count here */
+    __A_VARIABLE = 1;
     return copy;
 }
 
@@ -1393,8 +1420,10 @@ REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {
     if (data) {
         vstr = zmalloc(sz);
         memcpy(vstr, data, sz);
+        __A_VARIABLE = 1;
         return vstr;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1427,6 +1456,7 @@ void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
     } else if (where == QUICKLIST_TAIL) {
         quicklistPushTail(quicklist, value, sz);
     }
+    __A_VARIABLE = 1;
 }
 
 /* The rest of this file is test cases and test helpers. */
@@ -1478,6 +1508,7 @@ static void ql_info(quicklist *ql) {
 #else
     UNUSED(ql);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Return the UNIX time in microseconds */
@@ -1488,11 +1519,13 @@ static long long ustime(void) {
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec) * 1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 /* Return the UNIX time in milliseconds */
-static long long mstime(void) { return ustime() / 1000; }
+static long long mstime(void) { __A_VARIABLE = 1;
+	return ustime() / 1000; }
 
 /* Iterate over an entire quicklist.
  * Print the list if 'print' == 1.
@@ -1518,13 +1551,16 @@ static int _itrprintr(quicklist *ql, int print, int forward) {
         i++;
     }
     quicklistReleaseIterator(iter);
+    __A_VARIABLE = 1;
     return i;
 }
 static int itrprintr(quicklist *ql, int print) {
+    __A_VARIABLE = 1;
     return _itrprintr(ql, print, 1);
 }
 
 static int itrprintr_rev(quicklist *ql, int print) {
+    __A_VARIABLE = 1;
     return _itrprintr(ql, print, 0);
 }
 
@@ -1567,6 +1603,7 @@ static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
 
     if (ql->len == 0 && !errors) {
         OK;
+        __A_VARIABLE = 1;
         return errors;
     }
 
@@ -1617,6 +1654,7 @@ static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
 
     if (!errors)
         OK;
+    __A_VARIABLE = 1;
     return errors;
 }
 
@@ -1624,6 +1662,7 @@ static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,
 static char *genstr(char *prefix, int i) {
     static char result[64] = {0};
     snprintf(result, sizeof(result), "%s%d", prefix, i);
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -2665,6 +2704,7 @@ int quicklistTest(int argc, char *argv[]) {
     else
         ERR("Sorry, not all tests passed!  In fact, %d tests failed.", err);
 
+    __A_VARIABLE = 1;
     return err;
 }
 #endif
diff --git a/src/rand.c b/src/rand.c
index 09b0508..bb6846b 100644
--- a/src/rand.c
+++ b/src/rand.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Pseudo random number generation functions derived from the drand48()
  * function obtained from pysam source code.
  *
@@ -70,11 +71,13 @@ static void next(void);
 
 int32_t redisLrand48() {
     next();
+    __A_VARIABLE = 1;
     return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
 }
 
 void redisSrand48(int32_t seedval) {
     SEED(X0, LOW(seedval), HIGH(seedval));
+    __A_VARIABLE = 1;
 }
 
 static void next(void) {
@@ -90,4 +93,5 @@ static void next(void) {
             a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
     x[1] = LOW(p[1] + r[0]);
     x[0] = LOW(p[0]);
+    __A_VARIABLE = 1;
 }
diff --git a/src/rax.c b/src/rax.c
index fca60f1..c8a59e1 100644
--- a/src/rax.c
+++ b/src/rax.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Rax -- A radix tree implementation.
  *
  * Copyright (c) 2017-2018, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -78,6 +79,7 @@ static int raxDebugMsg = 1;
  * re-enable. */
 void raxSetDebugMsg(int onoff) {
     raxDebugMsg = onoff;
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- raxStack functions --------------------------
@@ -94,6 +96,7 @@ static inline void raxStackInit(raxStack *ts) {
     ts->items = 0;
     ts->maxitems = RAX_STACK_STATIC_ITEMS;
     ts->oom = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Push an item into the stack, returns 1 on success, 0 on out of memory. */
@@ -127,21 +130,30 @@ static inline int raxStackPush(raxStack *ts, void *ptr) {
 /* Pop an item from the stack, the function returns NULL if there are no
  * items to pop. */
 static inline void *raxStackPop(raxStack *ts) {
-    if (ts->items == 0) return NULL;
+    if (ts->items == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     ts->items--;
+    __A_VARIABLE = 1;
     return ts->stack[ts->items];
 }
 
 /* Return the stack item at the top of the stack without actually consuming
  * it. */
 static inline void *raxStackPeek(raxStack *ts) {
-    if (ts->items == 0) return NULL;
+    if (ts->items == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return ts->stack[ts->items-1];
 }
 
 /* Free the stack in case we used heap allocation. */
 static inline void raxStackFree(raxStack *ts) {
     if (ts->stack != ts->static_items) rax_free(ts->stack);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -188,11 +200,15 @@ raxNode *raxNewNode(size_t children, int datafield) {
                       sizeof(raxNode*)*children;
     if (datafield) nodesize += sizeof(void*);
     raxNode *node = rax_malloc(nodesize);
-    if (node == NULL) return NULL;
+    if (node == NULL) {
+    	__A_VARIABLE = 1;
+    	return NULL;
+    }
     node->iskey = 0;
     node->isnull = 0;
     node->iscompr = 0;
     node->size = children;
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -215,8 +231,12 @@ rax *raxNew(void) {
 /* realloc the node to make room for auxiliary data in order
  * to store an item in that node. On out of memory NULL is returned. */
 raxNode *raxReallocForData(raxNode *n, void *data) {
-    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
+    if (data == NULL) {
+        __A_VARIABLE = 1;
+        return n;
+    } /* No reallocation needed, setting isnull=1 */
     size_t curlen = raxNodeCurrentLength(n);
+    __A_VARIABLE = 1;
     return rax_realloc(n,curlen+sizeof(void*));
 }
 
@@ -231,14 +251,19 @@ void raxSetData(raxNode *n, void *data) {
     } else {
         n->isnull = 1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the node auxiliary data. */
 void *raxGetData(raxNode *n) {
-    if (n->isnull) return NULL;
+    if (n->isnull) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
     void *data;
     memcpy(&data,ndata,sizeof(data));
+    __A_VARIABLE = 1;
     return data;
 }
 
@@ -262,12 +287,16 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
 
     /* Alloc the new child we will link to 'n'. */
     raxNode *child = raxNewNode(0,0);
-    if (child == NULL) return NULL;
+    if (child == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make space in the original node. */
     raxNode *newn = rax_realloc(n,newlen);
     if (newn == NULL) {
         rax_free(child);
+        __A_VARIABLE = 1;
         return NULL;
     }
     n = newn;
@@ -381,6 +410,7 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
     memcpy(childfield,&child,sizeof(child));
     *childptr = child;
     *parentlink = childfield;
+    __A_VARIABLE = 1;
     return n;
 }
 
@@ -401,7 +431,10 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
 
     /* Allocate the child to link to this node. */
     *child = raxNewNode(0,0);
-    if (*child == NULL) return NULL;
+    if (*child == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make space in the parent node. */
     newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
@@ -412,6 +445,7 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
     raxNode *newn = rax_realloc(n,newsize);
     if (newn == NULL) {
         rax_free(*child);
+        __A_VARIABLE = 1;
         return NULL;
     }
     n = newn;
@@ -422,6 +456,7 @@ raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **chi
     if (n->iskey) raxSetData(n,data);
     raxNode **childfield = raxNodeLastChildPtr(n);
     memcpy(childfield,child,sizeof(*child));
+    __A_VARIABLE = 1;
     return n;
 }
 
@@ -900,6 +935,7 @@ oom:
 /* Overwriting insert. Just a wrapper for raxGenericInsert() that will
  * update the element if there is already one for the same key. */
 int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
+    __A_VARIABLE = 1;
     return raxGenericInsert(rax,s,len,data,old,1);
 }
 
@@ -907,6 +943,7 @@ int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
  * exists, the value is not updated and the function returns 0.
  * This is a just a wrapper for raxGenericInsert(). */
 int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
+    __A_VARIABLE = 1;
     return raxGenericInsert(rax,s,len,data,old,0);
 }
 
@@ -919,8 +956,11 @@ void *raxFind(rax *rax, unsigned char *s, size_t len) {
     debugf("### Lookup: %.*s\n", (int)len, s);
     int splitpos = 0;
     size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
-    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
+    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
+        __A_VARIABLE = 1;
         return raxNotFound;
+    }
+    __A_VARIABLE = 1;
     return raxGetData(h);
 }
 
@@ -937,6 +977,7 @@ raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
         if (c == child) break;
         cp++;
     }
+    __A_VARIABLE = 1;
     return cp;
 }
 
@@ -957,6 +998,7 @@ raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
         parent->size = 0;
         if (parent->iskey) raxSetData(parent,data);
         debugnode("raxRemoveChild after", parent);
+        __A_VARIABLE = 1;
         return parent;
     }
 
@@ -1012,6 +1054,7 @@ raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
     }
     /* Note: if rax_realloc() fails we just return the old address, which
      * is valid. */
+    __A_VARIABLE = 1;
     return newnode ? newnode : parent;
 }
 
@@ -1233,6 +1276,7 @@ void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
         free_callback(raxGetData(n));
     rax_free(n);
     rax->numnodes--;
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole radix tree, calling the specified callback in order to
@@ -1241,11 +1285,13 @@ void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
     raxRecursiveFree(rax,rax->head,free_callback);
     assert(rax->numnodes == 0);
     rax_free(rax);
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole radix tree. */
 void raxFree(rax *rax) {
     raxFreeWithCallback(rax,NULL);
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------------- Iterator --------------------------------- */
@@ -1262,6 +1308,7 @@ void raxStart(raxIterator *it, rax *rt) {
     it->data = NULL;
     it->node_cb = NULL;
     raxStackInit(&it->stack);
+    __A_VARIABLE = 1;
 }
 
 /* Append characters at the current key string of the iterator 'it'. This
@@ -1276,6 +1323,7 @@ int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
         if (it->key == NULL) {
             it->key = (!old) ? it->key_static_string : old;
             errno = ENOMEM;
+            __A_VARIABLE = 1;
             return 0;
         }
         if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
@@ -1285,6 +1333,7 @@ int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
      * it->key when we use the current key in order to re-seek. */
     memmove(it->key+it->key_len,s,len);
     it->key_len += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1292,6 +1341,7 @@ int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
  * iterator key. */
 void raxIteratorDelChars(raxIterator *it, size_t count) {
     it->key_len -= count;
+    __A_VARIABLE = 1;
 }
 
 /* Do an iteration step towards the next element. At the end of the step the
@@ -1693,12 +1743,15 @@ int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
 int raxNext(raxIterator *it) {
     if (!raxIteratorNextStep(it,0)) {
         errno = ENOMEM;
+        __A_VARIABLE = 1;
         return 0;
     }
     if (it->flags & RAX_ITER_EOF) {
         errno = 0;
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1708,12 +1761,15 @@ int raxNext(raxIterator *it) {
 int raxPrev(raxIterator *it) {
     if (!raxIteratorPrevStep(it,0)) {
         errno = ENOMEM;
+        __A_VARIABLE = 1;
         return 0;
     }
     if (it->flags & RAX_ITER_EOF) {
         errno = 0;
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1802,6 +1858,7 @@ int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key
 void raxStop(raxIterator *it) {
     if (it->key != it->key_static_string) rax_free(it->key);
     raxStackFree(&it->stack);
+    __A_VARIABLE = 1;
 }
 
 /* Return if the iterator is in an EOF state. This happens when raxSeek()
@@ -1809,6 +1866,7 @@ void raxStop(raxIterator *it) {
  * will return zero, or when an EOF condition was reached while iterating
  * with raxNext() and raxPrev(). */
 int raxEOF(raxIterator *it) {
+    __A_VARIABLE = 1;
     return it->flags & RAX_ITER_EOF;
 }
 
@@ -1876,17 +1934,22 @@ void raxRecursiveShow(int level, int lpad, raxNode *n) {
         raxRecursiveShow(level+1,lpad,child);
         cp++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Show a tree, as outlined in the comment above. */
 void raxShow(rax *rax) {
     raxRecursiveShow(0,0,rax->head);
     putchar('\n');
+    __A_VARIABLE = 1;
 }
 
 /* Used by debugnode() macro to show info about a given node. */
 void raxDebugShowNode(const char *msg, raxNode *n) {
-    if (raxDebugMsg == 0) return;
+    if (raxDebugMsg == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     printf("%s: %p [%.*s] key:%d size:%d children:",
         msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
     int numcld = n->iscompr ? 1 : n->size;
@@ -1899,6 +1962,7 @@ void raxDebugShowNode(const char *msg, raxNode *n) {
     }
     printf("\n");
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Touch all the nodes of a tree returning a check sum. This is useful
@@ -1939,5 +2003,6 @@ unsigned long raxTouch(raxNode *n) {
         sum += raxTouch(child);
         cp++;
     }
+    __A_VARIABLE = 1;
     return sum;
 }
diff --git a/src/rdb.c b/src/rdb.c
index acbba4b..a822b81 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -67,11 +68,15 @@ void rdbCheckThenExit(int linenum, char *reason, ...) {
         rdbCheckError("%s",msg);
     }
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
-    if (rdb && rioWrite(rdb,p,len) == 0)
+    if (rdb && rioWrite(rdb,p,len) == 0) {
+        __A_VARIABLE = 1;
         return -1;
+    }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -83,11 +88,14 @@ void rdbLoadRaw(rio *rdb, void *buf, uint64_t len) {
         rdbExitReportCorruptRDB(
             "Impossible to read %llu bytes in rdbLoadRaw()",
             (unsigned long long) len);
+        __A_VARIABLE = 1;
         return; /* Not reached. */
     }
+    __A_VARIABLE = 1;
 }
 
 int rdbSaveType(rio *rdb, unsigned char type) {
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&type,1);
 }
 
@@ -96,7 +104,11 @@ int rdbSaveType(rio *rdb, unsigned char type) {
  * "types" like the end-of-file type, the EXPIRE type, and so forth. */
 int rdbLoadType(rio *rdb) {
     unsigned char type;
-    if (rioRead(rdb,&type,1) == 0) return -1;
+    if (rioRead(rdb,&type,1) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return type;
 }
 
@@ -106,12 +118,14 @@ int rdbLoadType(rio *rdb) {
 time_t rdbLoadTime(rio *rdb) {
     int32_t t32;
     rdbLoadRaw(rdb,&t32,4);
+    __A_VARIABLE = 1;
     return (time_t)t32;
 }
 
 int rdbSaveMillisecondTime(rio *rdb, long long t) {
     int64_t t64 = (int64_t) t;
     memrev64ifbe(&t64); /* Store in little endian. */
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&t64,8);
 }
 
@@ -131,6 +145,7 @@ long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
     rdbLoadRaw(rdb,&t64,8);
     if (rdbver >= 9) /* Check the top comment of this function. */
         memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
+    __A_VARIABLE = 1;
     return (long long)t64;
 }
 
@@ -223,7 +238,11 @@ int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
 uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
     uint64_t len;
 
-    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
+    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) {
+        __A_VARIABLE = 1;
+        return RDB_LENERR;
+    }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -303,13 +322,20 @@ int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
 
     /* Check if it's possible to encode this value as a number */
     value = strtoll(s, &endptr, 10);
-    if (endptr[0] != '\0') return 0;
+    if (endptr[0] != '\0') {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     ll2string(buf,32,value);
 
     /* If the number converted back into a string is not identical
      * then it's not possible to encode the string as integer */
-    if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
+    if (strlen(buf) != len || memcmp(buf,s,len)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
+    __A_VARIABLE = 1;
     return rdbEncodeInteger(value,enc);
 }
 
@@ -332,9 +358,11 @@ ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
     if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
     nwritten += n;
 
+    __A_VARIABLE = 1;
     return nwritten;
 
 writeerr:
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -343,16 +371,24 @@ ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
     void *out;
 
     /* We require at least four bytes compression for this to be worth it */
-    if (len <= 4) return 0;
+    if (len <= 4) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     outlen = len-4;
-    if ((out = zmalloc(outlen+1)) == NULL) return 0;
+    if ((out = zmalloc(outlen+1)) == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     comprlen = lzf_compress(s, len, out, outlen);
     if (comprlen == 0) {
         zfree(out);
+        __A_VARIABLE = 1;
         return 0;
     }
     ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
     zfree(out);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -410,7 +446,11 @@ ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
     if (len <= 11) {
         unsigned char buf[5];
         if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
-            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
+            if (rdbWriteRaw(rdb,buf,enclen) == -1) {
+                __A_VARIABLE = 1;
+                return -1;
+            }
+            __A_VARIABLE = 1;
             return enclen;
         }
     }
@@ -419,18 +459,31 @@ ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
      * aaaaaaaaaaaaaaaaaa so skip it */
     if (server.rdb_compression && len > 20) {
         n = rdbSaveLzfStringObject(rdb,s,len);
-        if (n == -1) return -1;
-        if (n > 0) return n;
+        if (n == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (n > 0) {
+            __A_VARIABLE = 1;
+            return n;
+        }
         /* Return value of 0 means data can't be compressed, save the old way */
     }
 
     /* Store verbatim */
-    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,len)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
     if (len > 0) {
-        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
+        if (rdbWriteRaw(rdb,s,len) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += len;
     }
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -523,10 +576,12 @@ void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
 }
 
 robj *rdbLoadStringObject(rio *rdb) {
+    __A_VARIABLE = 1;
     return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
 }
 
 robj *rdbLoadEncodedStringObject(rio *rdb) {
+    __A_VARIABLE = 1;
     return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
 }
 
@@ -569,6 +624,7 @@ int rdbSaveDoubleValue(rio *rdb, double val) {
         buf[0] = strlen((char*)buf+1);
         len = buf[0]+1;
     }
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,buf,len);
 }
 
@@ -577,15 +633,25 @@ int rdbLoadDoubleValue(rio *rdb, double *val) {
     char buf[256];
     unsigned char len;
 
-    if (rioRead(rdb,&len,1) == 0) return -1;
+    if (rioRead(rdb,&len,1) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     switch(len) {
-    case 255: *val = R_NegInf; return 0;
-    case 254: *val = R_PosInf; return 0;
-    case 253: *val = R_Nan; return 0;
+    case 255: *val = R_NegInf; __A_VARIABLE = 1;
+        return 0;
+    case 254: *val = R_PosInf; __A_VARIABLE = 1;
+        return 0;
+    case 253: *val = R_Nan; __A_VARIABLE = 1;
+        return 0;
     default:
-        if (rioRead(rdb,buf,len) == 0) return -1;
+        if (rioRead(rdb,buf,len) == 0) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         buf[len] = '\0';
         sscanf(buf, "%lg", val);
+        __A_VARIABLE = 1;
         return 0;
     }
 }
@@ -597,27 +663,37 @@ int rdbLoadDoubleValue(rio *rdb, double *val) {
  * Return -1 on error, the size of the serialized value on success. */
 int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
     memrev64ifbe(&val);
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&val,sizeof(val));
 }
 
 /* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for
  * more info. On error -1 is returned, otherwise 0. */
 int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
-    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    if (rioRead(rdb,val,sizeof(*val)) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     memrev64ifbe(val);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Like rdbSaveBinaryDoubleValue() but single precision. */
 int rdbSaveBinaryFloatValue(rio *rdb, float val) {
     memrev32ifbe(&val);
+    __A_VARIABLE = 1;
     return rdbWriteRaw(rdb,&val,sizeof(val));
 }
 
 /* Like rdbLoadBinaryDoubleValue() but single precision. */
 int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
-    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    if (rioRead(rdb,val,sizeof(*val)) == 0) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     memrev32ifbe(val);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -666,8 +742,15 @@ int rdbSaveObjectType(rio *rdb, robj *o) {
  * type is not specifically a valid Object Type. */
 int rdbLoadObjectType(rio *rdb) {
     int type;
-    if ((type = rdbLoadType(rdb)) == -1) return -1;
-    if (!rdbIsObjectType(type)) return -1;
+    if ((type = rdbLoadType(rdb)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (!rdbIsObjectType(type)) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return type;
 }
 
@@ -682,7 +765,10 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
     ssize_t n, nwritten = 0;
 
     /* Number of entries in the PEL. */
-    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
 
     /* Save each entry. */
@@ -692,15 +778,23 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
     while(raxNext(&ri)) {
         /* We store IDs in raw form as 128 big big endian numbers, like
          * they are inside the radix tree key. */
-        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
+        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += n;
 
         if (nacks) {
             streamNACK *nack = ri.data;
-            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
+            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {
+                __A_VARIABLE = 1;
                 return -1;
+            }
             nwritten += n;
-            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
+            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {
+                __A_VARIABLE = 1;
+                return -1;
+            }
             nwritten += n;
             /* We don't save the consumer name: we'll save the pending IDs
              * for each consumer in the consumer PEL, and resolve the consumer
@@ -708,6 +802,7 @@ ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
         }
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -718,7 +813,10 @@ size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
     ssize_t n, nwritten = 0;
 
     /* Number of consumers in this consumer group. */
-    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
+    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     nwritten += n;
 
     /* Save each consumer. */
@@ -729,23 +827,31 @@ size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
         streamConsumer *consumer = ri.data;
 
         /* Consumer name. */
-        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
+        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
         nwritten += n;
 
         /* Last seen time. */
-        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
+        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         nwritten += n;
 
         /* Consumer PEL, without the ACKs (see last parameter of the function
          * passed with value of 0), at loading time we'll lookup the ID
          * in the consumer group global PEL and will put a reference in the
          * consumer local PEL. */
-        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
+        if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1) {
+            __A_VARIABLE = 1;
             return -1;
+        }
         nwritten += n;
     }
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return nwritten;
 }
 
@@ -1000,6 +1106,7 @@ ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
 size_t rdbSavedObjectLen(robj *o) {
     ssize_t len = rdbSaveObject(NULL,o,NULL);
     serverAssertWithInfo(NULL,o,len != -1);
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -1013,16 +1120,28 @@ int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {
 
     /* Save the expire time */
     if (expiretime != -1) {
-        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
-        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save the LRU info. */
     if (savelru) {
         uint64_t idletime = estimateObjectIdleTime(val);
         idletime /= 1000; /* Using seconds is enough and requires less space.*/
-        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
-        if (rdbSaveLen(rdb,idletime) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbSaveLen(rdb,idletime) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save the LFU info. */
@@ -1033,32 +1152,59 @@ int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime) {
          * bit counter, since the frequency is logarithmic with a 0-255 range.
          * Note that we do not store the halving time because to reset it
          * a single time when loading does not affect the frequency much. */
-        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
-        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
+        if (rdbWriteRaw(rdb,buf,1) == -1) {
+            __A_VARIABLE = 1;
+            return -1;
+        }
     }
 
     /* Save type, key, value */
-    if (rdbSaveObjectType(rdb,val) == -1) return -1;
-    if (rdbSaveStringObject(rdb,key) == -1) return -1;
-    if (rdbSaveObject(rdb,val,key) == -1) return -1;
+    if (rdbSaveObjectType(rdb,val) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveStringObject(rdb,key) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveObject(rdb,val,key) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Save an AUX field. */
 ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
     ssize_t ret, len = 0;
-    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
+    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
-    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
+    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
-    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
+    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     len += ret;
+    __A_VARIABLE = 1;
     return len;
 }
 
 /* Wrapper for rdbSaveAuxField() used when key/val length can be obtained
  * with strlen(). */
 ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
+    __A_VARIABLE = 1;
     return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
 }
 
@@ -1066,6 +1212,7 @@ ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
 ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
     char buf[LONG_STR_SIZE];
     int vlen = ll2string(buf,sizeof(buf),val);
+    __A_VARIABLE = 1;
     return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
 }
 
@@ -1075,21 +1222,46 @@ int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
     int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
 
     /* Add a few fields about the state when the RDB was created. */
-    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
-    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
+    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
 
     /* Handle saving options that generate aux fields. */
     if (rsi) {
         if (rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
         if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
         if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset)
-            == -1) return -1;
+            == -1) {
+        	__A_VARIABLE = 1;
+        	return -1;
+        }
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) {
+        __A_VARIABLE = 1;
+        return -1;
     }
-    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -1101,17 +1273,26 @@ ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
     /* Write the "module" identifier as prefix, so that we'll be able
      * to call the right module during loading. */
     retval = rdbSaveLen(rdb,mt->id);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
 
     /* write the 'when' so that we can provide it on loading. add a UINT opcode
      * for backwards compatibility, everything after the MT needs to be prefixed
      * by an opcode. */
     retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
     retval = rdbSaveLen(rdb,when);
-    if (retval == -1) return -1;
+    if (retval == -1) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     io.bytes += retval;
 
     /* Then write the module-specific representation + EOF marker. */
@@ -1127,8 +1308,11 @@ ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
         moduleFreeContext(io.ctx);
         zfree(io.ctx);
     }
-    if (io.error)
+    if (io.error) {
+        __A_VARIABLE = 1;
         return -1;
+    }
+    __A_VARIABLE = 1;
     return io.bytes;
 }
 
@@ -1225,11 +1409,13 @@ int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
     cksum = rdb->cksum;
     memrev64ifbe(&cksum);
     if (rioWrite(rdb,&cksum,8) == 0) goto werr;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     if (error) *error = errno;
     if (di) dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1251,11 +1437,13 @@ int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
     if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
     if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
     if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr: /* Write error. */
     /* Set 'error' only if not already set by rdbSaveRio() call. */
     if (error && *error == 0) *error = errno;
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1277,6 +1465,7 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
             filename,
             cwdp ? cwdp : "unknown",
             strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1307,6 +1496,7 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
             cwdp ? cwdp : "unknown",
             strerror(errno));
         unlink(tmpfile);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1314,12 +1504,14 @@ int rdbSave(char *filename, rdbSaveInfo *rsi) {
     server.dirty = 0;
     server.lastsave = time(NULL);
     server.lastbgsave_status = C_OK;
+    __A_VARIABLE = 1;
     return C_OK;
 
 werr:
     serverLog(LL_WARNING,"Write error saving DB on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1381,6 +1573,7 @@ void rdbRemoveTempFile(pid_t childpid) {
 
     snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
     unlink(tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by rdbLoadObject() when the code is in RDB-check
@@ -1419,6 +1612,7 @@ robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return createStringObject("module-dummy-value",18);
 }
 
@@ -1856,6 +2050,7 @@ void startLoading(FILE *fp) {
     } else {
         server.loading_total_bytes = sb.st_size;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Refresh the loading progress info */
@@ -1863,11 +2058,13 @@ void loadingProgress(off_t pos) {
     server.loading_loaded_bytes = pos;
     if (server.stat_peak_memory < zmalloc_used_memory())
         server.stat_peak_memory = zmalloc_used_memory();
+    __A_VARIABLE = 1;
 }
 
 /* Loading finished */
 void stopLoading(void) {
     server.loading = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Track loading progress in order to serve client's from time to time
@@ -1887,6 +2084,7 @@ void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
         loadingProgress(r->processed_bytes);
         processEventsWhileBlocked();
     }
+    __A_VARIABLE = 1;
 }
 
 /* Load an RDB file from the rio stream 'rdb'. On success C_OK is returned,
@@ -1904,12 +2102,14 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
     if (memcmp(buf,"REDIS",5) != 0) {
         serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return C_ERR;
     }
     rdbver = atoi(buf+5);
     if (rdbver < 1 || rdbver > RDB_VERSION) {
         serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -2117,11 +2317,13 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return C_OK;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
     serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
     rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
+    __A_VARIABLE = 1;
     return C_ERR; /* Just to avoid warning */
 }
 
@@ -2137,12 +2339,16 @@ int rdbLoad(char *filename, rdbSaveInfo *rsi) {
     rio rdb;
     int retval;
 
-    if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
+    if ((fp = fopen(filename,"r")) == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     startLoading(fp);
     rioInitWithFile(&rdb,fp);
     retval = rdbLoadRio(&rdb,rsi,0);
     fclose(fp);
     stopLoading();
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -2179,6 +2385,7 @@ void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
     /* Possibly there are slaves waiting for a BGSAVE in order to be served
      * (the first stage of SYNC is a bulk transfer of dump.rdb) */
     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
+    __A_VARIABLE = 1;
 }
 
 /* A background saving child (BGSAVE) terminated its work. Handle this.
@@ -2274,6 +2481,7 @@ void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
     zfree(ok_slaves);
 
     updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
+    __A_VARIABLE = 1;
 }
 
 /* When a background RDB saving/transfer terminates, call the right handler. */
@@ -2289,6 +2497,7 @@ void backgroundSaveDoneHandler(int exitcode, int bysignal) {
         serverPanic("Unknown RDB child type.");
         break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Spawn an RDB child that writes the RDB to the sockets of the slaves
@@ -2455,6 +2664,7 @@ int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
 void saveCommand(client *c) {
     if (server.rdb_child_pid != -1) {
         addReplyError(c,"Background save already in progress");
+        __A_VARIABLE = 1;
         return;
     }
     rdbSaveInfo rsi, *rsiptr;
@@ -2464,6 +2674,7 @@ void saveCommand(client *c) {
     } else {
         addReply(c,shared.err);
     }
+    __A_VARIABLE = 1;
 }
 
 /* BGSAVE [SCHEDULE] */
@@ -2530,6 +2741,7 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
          * to reload replication ID/offset, it's safe because the next write
          * command must generate a SELECT statement. */
         rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
+        __A_VARIABLE = 1;
         return rsi;
     }
 
@@ -2537,6 +2749,7 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
      * in order to fetch the currently selected DB. */
     if (server.master) {
         rsi->repl_stream_db = server.master->db->id;
+        __A_VARIABLE = 1;
         return rsi;
     }
 
@@ -2547,7 +2760,9 @@ rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
      * is valid. */
     if (server.cached_master) {
         rsi->repl_stream_db = server.cached_master->db->id;
+        __A_VARIABLE = 1;
         return rsi;
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
diff --git a/src/redis-benchmark.c b/src/redis-benchmark.c
index d30879d..71730a6 100644
--- a/src/redis-benchmark.c
+++ b/src/redis-benchmark.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis benchmark utility.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -109,6 +110,7 @@ static long long ustime(void) {
     gettimeofday(&tv, NULL);
     ust = ((long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
@@ -119,6 +121,7 @@ static long long mstime(void) {
     gettimeofday(&tv, NULL);
     mst = ((long long)tv.tv_sec)*1000;
     mst += tv.tv_usec/1000;
+    __A_VARIABLE = 1;
     return mst;
 }
 
@@ -134,6 +137,7 @@ static void freeClient(client c) {
     ln = listSearchKey(config.clients,c);
     assert(ln != NULL);
     listDelNode(config.clients,ln);
+    __A_VARIABLE = 1;
 }
 
 static void freeAllClients(void) {
@@ -144,6 +148,7 @@ static void freeAllClients(void) {
         freeClient(ln->value);
         ln = next;
     }
+    __A_VARIABLE = 1;
 }
 
 static void resetClient(client c) {
@@ -152,6 +157,7 @@ static void resetClient(client c) {
     aeCreateFileEvent(config.el,c->context->fd,AE_WRITABLE,writeHandler,c);
     c->written = 0;
     c->pending = config.pipeline;
+    __A_VARIABLE = 1;
 }
 
 static void randomizeClientKey(client c) {
@@ -168,12 +174,14 @@ static void randomizeClientKey(client c) {
             p--;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static void clientDone(client c) {
     if (config.requests_finished == config.requests) {
         freeClient(c);
         aeStop(config.el);
+        __A_VARIABLE = 1;
         return;
     }
     if (config.keepalive) {
@@ -184,6 +192,7 @@ static void clientDone(client c) {
         config.liveclients++;
         freeClient(c);
     }
+    __A_VARIABLE = 1;
 }
 
 static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -253,6 +262,7 @@ static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -266,6 +276,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
         /* Enforce upper bound to number of requests. */
         if (config.requests_issued++ >= config.requests) {
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -282,6 +293,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             if (errno != EPIPE)
                 fprintf(stderr, "Writing to socket: %s\n", strerror(errno));
             freeClient(c);
+            __A_VARIABLE = 1;
             return;
         }
         c->written += nwritten;
@@ -290,6 +302,7 @@ static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             aeCreateFileEvent(config.el,c->context->fd,AE_READABLE,readHandler,c);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create a benchmark client, configured to send the command passed as 'cmd' of
@@ -407,6 +420,7 @@ static client createClient(char *cmd, size_t len, client from) {
         aeCreateFileEvent(config.el,c->context->fd,AE_WRITABLE,writeHandler,c);
     listAddNodeTail(config.clients,c);
     config.liveclients++;
+    __A_VARIABLE = 1;
     return c;
 }
 
@@ -422,9 +436,11 @@ static void createMissingClients(client c) {
             n = 0;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 static int compareLatency(const void *a, const void *b) {
+    __A_VARIABLE = 1;
     return (*(long long*)a)-(*(long long*)b);
 }
 
@@ -456,6 +472,7 @@ static void showLatencyReport(void) {
     } else {
         printf("%s: %.2f requests per second\n", config.title, reqpersec);
     }
+    __A_VARIABLE = 1;
 }
 
 static void benchmark(char *title, char *cmd, int len) {
@@ -474,6 +491,7 @@ static void benchmark(char *title, char *cmd, int len) {
 
     showLatencyReport();
     freeAllClients();
+    __A_VARIABLE = 1;
 }
 
 /* Returns number of consumed options. */
@@ -618,16 +636,21 @@ int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData
         fprintf(stderr,"All clients disconnected... aborting.\n");
         exit(1);
     }
-    if (config.csv) return 250;
+    if (config.csv) {
+        __A_VARIABLE = 1;
+        return 250;
+    }
     if (config.idlemode == 1) {
         printf("clients: %d\r", config.liveclients);
         fflush(stdout);
+	__A_VARIABLE = 1;
 	return 250;
     }
     float dt = (float)(mstime()-config.start)/1000.0;
     float rps = (float)config.requests_finished/dt;
     printf("%s: %.2f\r", config.title, rps);
     fflush(stdout);
+    __A_VARIABLE = 1;
     return 250; /* every 250ms */
 }
 
@@ -637,11 +660,15 @@ int test_is_selected(char *name) {
     char buf[256];
     int l = strlen(name);
 
-    if (config.tests == NULL) return 1;
+    if (config.tests == NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     buf[0] = ',';
     memcpy(buf+1,name,l);
     buf[l+1] = ',';
     buf[l+2] = '\0';
+    __A_VARIABLE = 1;
     return strstr(config.tests,buf) != NULL;
 }
 
@@ -712,6 +739,7 @@ int main(int argc, const char **argv) {
             free(cmd);
         } while(config.loop);
 
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -842,5 +870,6 @@ int main(int argc, const char **argv) {
         if (!config.csv) printf("\n");
     } while(config.loop);
 
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/src/redis-check-aof.c b/src/redis-check-aof.c
index eedb09d..17ecf04 100644
--- a/src/redis-check-aof.c
+++ b/src/redis-check-aof.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -43,8 +44,10 @@ static off_t epos;
 int consumeNewline(char *buf) {
     if (strncmp(buf,"\r\n",2) != 0) {
         ERROR("Expected \\r\\n, got: %02x%02x",buf[0],buf[1]);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -52,13 +55,16 @@ int readLong(FILE *fp, char prefix, long *target) {
     char buf[128], *eptr;
     epos = ftello(fp);
     if (fgets(buf,sizeof(buf),fp) == NULL) {
+        __A_VARIABLE = 1;
         return 0;
     }
     if (buf[0] != prefix) {
         ERROR("Expected prefix '%c', got: '%c'",prefix,buf[0]);
+        __A_VARIABLE = 1;
         return 0;
     }
     *target = strtol(buf+1,&eptr,10);
+    __A_VARIABLE = 1;
     return consumeNewline(eptr);
 }
 
@@ -68,8 +74,10 @@ int readBytes(FILE *fp, char *target, long length) {
     real = fread(target,1,length,fp);
     if (real != length) {
         ERROR("Expected to read %ld bytes, got %ld bytes",length,real);
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -77,6 +85,7 @@ int readString(FILE *fp, char** target) {
     long len;
     *target = NULL;
     if (!readLong(fp,'$',&len)) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -84,16 +93,20 @@ int readString(FILE *fp, char** target) {
     len += 2;
     *target = (char*)zmalloc(len);
     if (!readBytes(fp,*target,len)) {
+        __A_VARIABLE = 1;
         return 0;
     }
     if (!consumeNewline(*target+len-2)) {
+        __A_VARIABLE = 1;
         return 0;
     }
     (*target)[len-2] = '\0';
+    __A_VARIABLE = 1;
     return 1;
 }
 
 int readArgc(FILE *fp, long *target) {
+    __A_VARIABLE = 1;
     return readLong(fp,'*',target);
 }
 
@@ -138,6 +151,7 @@ off_t process(FILE *fp) {
     if (strlen(error) > 0) {
         printf("%s\n", error);
     }
+    __A_VARIABLE = 1;
     return pos;
 }
 
@@ -230,4 +244,5 @@ int redis_check_aof_main(int argc, char **argv) {
 
     fclose(fp);
     exit(0);
+    __A_VARIABLE = 1;
 }
diff --git a/src/redis-check-rdb.c b/src/redis-check-rdb.c
index ec00ee7..eb1e1c2 100644
--- a/src/redis-check-rdb.c
+++ b/src/redis-check-rdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -93,6 +94,7 @@ void rdbShowGenericInfo(void) {
     printf("[info] %lu keys read\n", rdbstate.keys);
     printf("[info] %lu expires\n", rdbstate.expires);
     printf("[info] %lu already expired\n", rdbstate.already_expired);
+    __A_VARIABLE = 1;
 }
 
 /* Called on RDB errors. Provides details about the RDB and the offset
@@ -121,6 +123,7 @@ void rdbCheckError(const char *fmt, ...) {
              sizeof(rdb_type_string)/sizeof(char*)) ?
                 rdb_type_string[rdbstate.key_type] : "unknown");
     rdbShowGenericInfo();
+    __A_VARIABLE = 1;
 }
 
 /* Print informations during RDB checking. */
@@ -135,6 +138,7 @@ void rdbCheckInfo(const char *fmt, ...) {
     printf("[offset %llu] %s\n",
         (unsigned long long) (rdbstate.rio ?
             rdbstate.rio->processed_bytes : 0), msg);
+    __A_VARIABLE = 1;
 }
 
 /* Used inside rdb.c in order to log specific errors happening inside
@@ -146,6 +150,7 @@ void rdbCheckSetError(const char *fmt, ...) {
     vsnprintf(rdbstate.error, sizeof(rdbstate.error), fmt, ap);
     va_end(ap);
     rdbstate.error_set = 1;
+    __A_VARIABLE = 1;
 }
 
 /* During RDB check we setup a special signal handler for memory violations
@@ -158,6 +163,7 @@ void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {
 
     rdbCheckError("Server crash checking the specified RDB file!");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 void rdbCheckSetupSignals(void) {
@@ -170,6 +176,7 @@ void rdbCheckSetupSignals(void) {
     sigaction(SIGBUS, &act, NULL);
     sigaction(SIGFPE, &act, NULL);
     sigaction(SIGILL, &act, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* Check the specified RDB file. Return 0 if the RDB looks sane, otherwise
@@ -184,7 +191,10 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
     static rio rdb; /* Pointed by global struct riostate. */
 
     int closefile = (fp == NULL);
-    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) return 1;
+    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
 
     rioInitWithFile(&rdb,fp);
     rdbstate.rio = &rdb;
@@ -314,6 +324,7 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
     }
 
     if (closefile) fclose(fp);
+    __A_VARIABLE = 1;
     return 0;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
@@ -324,6 +335,7 @@ eoferr: /* unexpected end of file is handled here with a fatal exit */
     }
 err:
     if (closefile) fclose(fp);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -358,6 +370,10 @@ int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
         rdbCheckInfo("\\o/ RDB looks OK! \\o/");
         rdbShowGenericInfo();
     }
-    if (fp) return (retval == 0) ? C_OK : C_ERR;
+    if (fp) {
+        __A_VARIABLE = 1;
+        return (retval == 0) ? C_OK : C_ERR;
+    }
     exit(retval);
+    __A_VARIABLE = 1;
 }
diff --git a/src/redis-cli.c b/src/redis-cli.c
index ed9355c..4ec300f 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis CLI (command line interface)
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -261,15 +262,20 @@ static long long ustime(void) {
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 static long long mstime(void) {
+    __A_VARIABLE = 1;
     return ustime()/1000;
 }
 
 static void cliRefreshPrompt(void) {
-    if (config.eval_ldb) return;
+    if (config.eval_ldb) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     sds prompt = sdsempty();
     if (config.hostsocket != NULL) {
@@ -288,6 +294,7 @@ static void cliRefreshPrompt(void) {
     prompt = sdscatlen(prompt,"> ",2);
     snprintf(config.prompt,sizeof(config.prompt),"%s",prompt);
     sdsfree(prompt);
+    __A_VARIABLE = 1;
 }
 
 /* Return the name of the dotfile for the specified 'dotfilename'.
@@ -352,6 +359,7 @@ static sds percentDecode(const char *pe, size_t len) {
         }
     }
 
+    __A_VARIABLE = 1;
     return ret;
 }
 
@@ -376,7 +384,10 @@ static void parseRedisUri(const char *uri) {
         exit(1);
     }
     curr += strlen(scheme);
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract user info. */
     if ((userinfo = strchr(curr,'@'))) {
@@ -388,7 +399,10 @@ static void parseRedisUri(const char *uri) {
         config.auth = percentDecode(curr, userinfo - curr);
         curr = userinfo + 1;
     }
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract host and port. */
     path = strchr(curr, '/');
@@ -401,13 +415,18 @@ static void parseRedisUri(const char *uri) {
         config.hostip = sdsnewlen(curr, host - curr + 1);
     }
     curr = path ? path + 1 : end;
-    if (curr == end) return;
+    if (curr == end) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Extract database number. */
     config.dbnum = atoi(curr);
+    __A_VARIABLE = 1;
 }
 
 static uint64_t dictSdsHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
@@ -419,7 +438,11 @@ static int dictSdsKeyCompare(void *privdata, const void *key1,
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
@@ -427,12 +450,14 @@ static void dictSdsDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 void dictListDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
     listRelease((list*)val);
+    __A_VARIABLE = 1;
 }
 
 #ifndef CONFIG_LIBREDIS_SERVER
@@ -441,6 +466,7 @@ void _serverAssert(const char *estr, const char *file, int line) {
     fprintf(stderr, "=== ASSERTION FAILED ===");
     fprintf(stderr, "==> %s:%d '%s' is not true",file,line,estr);
     *((char*)-1) = 'x';
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -475,6 +501,7 @@ static sds cliVersion(void) {
             version = sdscatprintf(version, "-dirty");
         version = sdscat(version, ")");
     }
+    __A_VARIABLE = 1;
     return version;
 }
 
@@ -504,6 +531,7 @@ static void cliInitHelp(void) {
         tmp.org = &commandHelp[i];
         helpEntries[pos++] = tmp;
     }
+    __A_VARIABLE = 1;
 }
 
 /* cliInitHelp() setups the helpEntries array with the command and group
@@ -512,10 +540,16 @@ static void cliInitHelp(void) {
  * entries with additional entries obtained using the COMMAND command
  * available in recent versions of Redis. */
 static void cliIntegrateHelp(void) {
-    if (cliConnect(CC_QUIET) == REDIS_ERR) return;
+    if (cliConnect(CC_QUIET) == REDIS_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     redisReply *reply = redisCommand(context, "COMMAND");
-    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;
+    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Scan the array reported by COMMAND and fill only the entries that
      * don't already match what we have. */
@@ -524,7 +558,10 @@ static void cliIntegrateHelp(void) {
         if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
             entry->element[0]->type != REDIS_REPLY_STRING ||
             entry->element[1]->type != REDIS_REPLY_INTEGER ||
-            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
+            entry->element[3]->type != REDIS_REPLY_INTEGER) {
+            __A_VARIABLE = 1;
+            return;
+        }
         char *cmdname = entry->element[0]->str;
         int i;
 
@@ -564,6 +601,7 @@ static void cliIntegrateHelp(void) {
         new->org = ch;
     }
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
 }
 
 /* Output command help to stdout. */
@@ -574,6 +612,7 @@ static void cliOutputCommandHelp(struct commandHelp *help, int group) {
     if (group) {
         printf("  \x1b[33mgroup:\x1b[0m %s\r\n", commandGroups[help->group]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Print generic help. */
@@ -594,6 +633,7 @@ static void cliOutputGenericHelp(void) {
         version
     );
     sdsfree(version);
+    __A_VARIABLE = 1;
 }
 
 /* Output all command help, filtering by group or command name. */
@@ -668,11 +708,15 @@ static void completionCallback(const char *buf, linenoiseCompletions *lc) {
             sdsfree(tmp);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Linenoise hints callback. */
 static char *hintsCallback(const char *buf, int *color, int *bold) {
-    if (!pref.hints) return NULL;
+    if (!pref.hints) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     int i, argc, buflen = strlen(buf);
     sds *argv = sdssplitargs(buf,&argc);
@@ -681,6 +725,7 @@ static char *hintsCallback(const char *buf, int *color, int *bold) {
     /* Check if the argument list is empty and return ASAP. */
     if (argc == 0) {
         sdsfreesplitres(argv,argc);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -711,15 +756,18 @@ static char *hintsCallback(const char *buf, int *color, int *bold) {
             }
 
             sdsfreesplitres(argv,argc);
+            __A_VARIABLE = 1;
             return hint;
         }
     }
     sdsfreesplitres(argv,argc);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
 static void freeHintsCallback(void *ptr) {
     sdsfree(ptr);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -729,28 +777,38 @@ static void freeHintsCallback(void *ptr) {
 /* Send AUTH command to the server */
 static int cliAuth(void) {
     redisReply *reply;
-    if (config.auth == NULL) return REDIS_OK;
+    if (config.auth == NULL) {
+        __A_VARIABLE = 1;
+        return REDIS_OK;
+    }
 
     reply = redisCommand(context,"AUTH %s",config.auth);
     if (reply != NULL) {
         freeReplyObject(reply);
+        __A_VARIABLE = 1;
         return REDIS_OK;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
 /* Send SELECT dbnum to the server */
 static int cliSelect(void) {
     redisReply *reply;
-    if (config.dbnum == 0) return REDIS_OK;
+    if (config.dbnum == 0) {
+        __A_VARIABLE = 1;
+        return REDIS_OK;
+    }
 
     reply = redisCommand(context,"SELECT %d",config.dbnum);
     if (reply != NULL) {
         int result = REDIS_OK;
         if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;
         freeReplyObject(reply);
+        __A_VARIABLE = 1;
         return result;
     }
+    __A_VARIABLE = 1;
     return REDIS_ERR;
 }
 
@@ -782,6 +840,7 @@ static int cliConnect(int flags) {
             }
             redisFree(context);
             context = NULL;
+            __A_VARIABLE = 1;
             return REDIS_ERR;
         }
 
@@ -792,17 +851,26 @@ static int cliConnect(int flags) {
         anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
 
         /* Do AUTH and select the right DB. */
-        if (cliAuth() != REDIS_OK)
+        if (cliAuth() != REDIS_OK) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
-        if (cliSelect() != REDIS_OK)
+        }
+        if (cliSelect() != REDIS_OK) {
+            __A_VARIABLE = 1;
             return REDIS_ERR;
+        }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static void cliPrintContextError(void) {
-    if (context == NULL) return;
+    if (context == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     fprintf(stderr,"Error: %s\n",context->errstr);
+    __A_VARIABLE = 1;
 }
 
 static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
@@ -869,18 +937,23 @@ static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
 int isColorTerm(void) {
     char *t = getenv("TERM");
+    __A_VARIABLE = 1;
     return t != NULL && strstr(t,"xterm") != NULL;
 }
 
 /* Helper  function for sdsCatColorizedLdbReply() appending colorize strings
  * to an SDS string. */
 sds sdscatcolor(sds o, char *s, size_t len, char *color) {
-    if (!isColorTerm()) return sdscatlen(o,s,len);
+    if (!isColorTerm()) {
+        __A_VARIABLE = 1;
+        return sdscatlen(o,s,len);
+    }
 
     int bold = strstr(color,"bold") != NULL;
     int ccode = 37; /* Defaults to white. */
@@ -895,6 +968,7 @@ sds sdscatcolor(sds o, char *s, size_t len, char *color) {
     o = sdscatfmt(o,"\033[%i;%i;49m",bold,ccode);
     o = sdscatlen(o,s,len);
     o = sdscat(o,"\033[0m");
+    __A_VARIABLE = 1;
     return o;
 }
 
@@ -913,6 +987,7 @@ sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
         if (s[1] == '>') color = "yellow"; /* Current line. */
         else if (s[2] == '#') color = "bold"; /* Break point. */
     }
+    __A_VARIABLE = 1;
     return sdscatcolor(o,s,len,color);
 }
 
@@ -964,6 +1039,7 @@ static sds cliFormatReplyRaw(redisReply *r) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
@@ -1000,6 +1076,7 @@ static sds cliFormatReplyCSV(redisReply *r) {
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return out;
 }
 
@@ -1013,18 +1090,24 @@ static int cliReadReply(int output_raw_strings) {
         if (config.shutdown) {
             redisFree(context);
             context = NULL;
+            __A_VARIABLE = 1;
             return REDIS_OK;
         }
         if (config.interactive) {
             /* Filter cases where we should reconnect */
             if (context->err == REDIS_ERR_IO &&
-                (errno == ECONNRESET || errno == EPIPE))
+                (errno == ECONNRESET || errno == EPIPE)) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
-            if (context->err == REDIS_ERR_EOF)
+            }
+            if (context->err == REDIS_ERR_EOF) {
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
+            }
         }
         cliPrintContextError();
         exit(1);
+        __A_VARIABLE = 1;
         return REDIS_ERR; /* avoid compiler warning */
     }
 
@@ -1080,6 +1163,7 @@ static int cliReadReply(int output_raw_strings) {
         sdsfree(out);
     }
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
@@ -1223,6 +1307,7 @@ static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ..
     }
 
     context = c;
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -1435,6 +1520,7 @@ static int parseOptions(int argc, char **argv) {
               " line interface may not be safe.\n", stderr);
     }
 
+    __A_VARIABLE = 1;
     return i;
 }
 
@@ -1449,6 +1535,7 @@ static void parseEnv() {
     if (cluster_yes != NULL && !strcmp(cluster_yes, "1")) {
         config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
     }
+    __A_VARIABLE = 1;
 }
 
 static sds readArgFromStdin(void) {
@@ -1465,6 +1552,7 @@ static sds readArgFromStdin(void) {
         }
         arg = sdscatlen(arg,buf,nread);
     }
+    __A_VARIABLE = 1;
     return arg;
 }
 
@@ -1557,10 +1645,12 @@ static void usage(void) {
 "\n");
     sdsfree(version);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 static int confirmWithYes(char *msg) {
     if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES) {
+        __A_VARIABLE = 1;
         return 1;
     }
     printf("%s (type 'yes' to accept): ", msg);
@@ -1568,6 +1658,7 @@ static int confirmWithYes(char *msg) {
     char buf[4];
     int nread = read(fileno(stdin),buf,4);
     buf[3] = '\0';
+    __A_VARIABLE = 1;
     return (nread != 0 && !strcmp("yes", buf));
 }
 
@@ -1579,6 +1670,7 @@ static char **convertToSds(int count, char** args) {
   for(j = 0; j < count; j++)
     sds[j] = sdsnew(args[j]);
 
+  __A_VARIABLE = 1;
   return sds;
 }
 
@@ -1592,6 +1684,7 @@ static int issueCommandRepeat(int argc, char **argv, long repeat) {
              * We'll try to reconnect the next time. */
             if (cliSendCommand(argc,argv,repeat) != REDIS_OK) {
                 cliPrintContextError();
+                __A_VARIABLE = 1;
                 return REDIS_ERR;
             }
          }
@@ -1602,10 +1695,12 @@ static int issueCommandRepeat(int argc, char **argv, long repeat) {
              break;
         }
     }
+    __A_VARIABLE = 1;
     return REDIS_OK;
 }
 
 static int issueCommand(int argc, char **argv) {
+    __A_VARIABLE = 1;
     return issueCommandRepeat(argc, argv, config.repeat);
 }
 
@@ -1648,12 +1743,16 @@ void cliSetPreferences(char **argv, int argc, int interactive) {
             interactive ? "" : ".redisclirc: ",
             argv[0]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Load the ~/.redisclirc file if any. */
 void cliLoadPreferences(void) {
     sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
-    if (rcfile == NULL) return;
+    if (rcfile == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     FILE *fp = fopen(rcfile,"r");
     char buf[1024];
 
@@ -1669,6 +1768,7 @@ void cliLoadPreferences(void) {
         fclose(fp);
     }
     sdsfree(rcfile);
+    __A_VARIABLE = 1;
 }
 
 static void repl(void) {
@@ -1804,6 +1904,7 @@ static int noninteractive(int argc, char **argv) {
     } else {
         retval = issueCommand(argc, argv);
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1891,6 +1992,7 @@ static int evalMode(int argc, char **argv) {
             break; /* Return to the caller. */
         }
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -2049,6 +2151,7 @@ static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
     cmd->argc = argc;
     cmd->argv = argc ? argv : NULL;
     if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
+    __A_VARIABLE = 1;
 }
 
 
@@ -2065,12 +2168,14 @@ static clusterManagerCommandProc *validateClusterManagerCommand(void) {
                 (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
                 fprintf(stderr, "[ERR] Wrong number of arguments for "
                                 "specified --cluster sub command\n");
+                __A_VARIABLE = 1;
                 return NULL;
             }
             proc = cmddef.proc;
         }
     }
     if (!proc) fprintf(stderr, "Unknown --cluster subcommand\n");
+    __A_VARIABLE = 1;
     return proc;
 }
 
@@ -2115,6 +2220,7 @@ static void freeClusterManagerNodeFlags(list *flags) {
         sdsfree(flag);
     }
     listRelease(flags);
+    __A_VARIABLE = 1;
 }
 
 static void freeClusterManagerNode(clusterManagerNode *node) {
@@ -2148,6 +2254,7 @@ static void freeClusterManagerNode(clusterManagerNode *node) {
         node->flags_str = NULL;
     }
     zfree(node);
+    __A_VARIABLE = 1;
 }
 
 static void freeClusterManager(void) {
@@ -2173,6 +2280,7 @@ static void freeClusterManager(void) {
     }
     if (clusterManagerUncoveredSlots != NULL)
         dictRelease(clusterManagerUncoveredSlots);
+    __A_VARIABLE = 1;
 }
 
 static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
@@ -2197,6 +2305,7 @@ static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
     node->weight = 1.0f;
     node->balance = 0;
     clusterManagerNodeResetSlots(node);
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -2215,8 +2324,10 @@ static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                 strcpy(*err, r->str);
             } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
         }
+        __A_VARIABLE = 1;
         return 0;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -2225,6 +2336,7 @@ static int clusterManagerStartTransaction(clusterManagerNode *node) {
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "MULTI");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2255,6 +2367,7 @@ static int clusterManagerExecTransaction(clusterManagerNode *node,
     }
 cleanup:
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2267,6 +2380,7 @@ static int clusterManagerNodeConnect(clusterManagerNode *node) {
                 node->context->errstr);
         redisFree(node->context);
         node->context = NULL;
+        __A_VARIABLE = 1;
         return 0;
     }
     /* Set aggressive KEEP_ALIVE socket option in the Redis context socket
@@ -2278,8 +2392,12 @@ static int clusterManagerNodeConnect(clusterManagerNode *node) {
         redisReply *reply = redisCommand(node->context,"AUTH %s",config.auth);
         int ok = clusterManagerCheckRedisReply(node, reply, NULL);
         if (reply != NULL) freeReplyObject(reply);
-        if (!ok) return 0;
+        if (!ok) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -2294,11 +2412,15 @@ static void clusterManagerRemoveNodeFromList(list *nodelist,
             break;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the node with the specified name (ID) or NULL. */
 static clusterManagerNode *clusterManagerNodeByName(const char *name) {
-    if (cluster_manager.nodes == NULL) return NULL;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     clusterManagerNode *found = NULL;
     sds lcname = sdsempty();
     lcname = sdscpy(lcname, name);
@@ -2314,6 +2436,7 @@ static clusterManagerNode *clusterManagerNodeByName(const char *name) {
         }
     }
     sdsfree(lcname);
+    __A_VARIABLE = 1;
     return found;
 }
 
@@ -2323,7 +2446,10 @@ static clusterManagerNode *clusterManagerNodeByName(const char *name) {
  */
 static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
 {
-    if (cluster_manager.nodes == NULL) return NULL;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     clusterManagerNode *found = NULL;
     sds lcname = sdsempty();
     lcname = sdscpy(lcname, name);
@@ -2340,12 +2466,14 @@ static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
         }
     }
     sdsfree(lcname);
+    __A_VARIABLE = 1;
     return found;
 }
 
 static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
     memset(node->slots, 0, sizeof(node->slots));
     node->slots_count = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Call "INFO" redis command on the specified node and return the reply. */
@@ -2354,23 +2482,32 @@ static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
 {
     redisReply *info = CLUSTER_MANAGER_COMMAND(node, "INFO");
     if (err != NULL) *err = NULL;
-    if (info == NULL) return NULL;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (info->type == REDIS_REPLY_ERROR) {
         if (err != NULL) {
             *err = zmalloc((info->len + 1) * sizeof(char));
             strcpy(*err, info->str);
         }
         freeReplyObject(info);
+        __A_VARIABLE = 1;
         return  NULL;
     }
+    __A_VARIABLE = 1;
     return info;
 }
 
 static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
     redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
-    if (info == NULL) return 0;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int is_cluster = (int) getLongInfoField(info->str, "cluster_enabled");
     freeReplyObject(info);
+    __A_VARIABLE = 1;
     return is_cluster;
 }
 
@@ -2379,7 +2516,10 @@ static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
 static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
     redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
     int is_empty = 1;
-    if (info == NULL) return 0;
+    if (info == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (strstr(info->str, "db0:") != NULL) {
         is_empty = 0;
         goto result;
@@ -2395,6 +2535,7 @@ static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
     is_empty = (known_nodes == 1);
 result:
     freeReplyObject(info);
+    __A_VARIABLE = 1;
     return is_empty;
 }
 
@@ -2491,6 +2632,7 @@ static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
         dictReleaseIterator(iter);
         dictRelease(related);
     }
+    __A_VARIABLE = 1;
     return score;
 }
 
@@ -2570,12 +2712,16 @@ static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
     clusterManagerLog(log_level, "%s\n", msg);
 cleanup:
     zfree(offenders);
+    __A_VARIABLE = 1;
 }
 
 /* Return a representable string of the node's flags */
 static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
     sds flags = sdsempty();
-    if (!node->flags_str) return flags;
+    if (!node->flags_str) {
+        __A_VARIABLE = 1;
+        return flags;
+    }
     int empty = 1;
     listIter li;
     listNode *ln;
@@ -2587,6 +2733,7 @@ static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
         flags = sdscatfmt(flags, "%S", flag);
         empty = 0;
     }
+    __A_VARIABLE = 1;
     return flags;
 }
 
@@ -2617,6 +2764,7 @@ static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
         if (first_range_idx == last_slot_idx) slots = sdscat(slots, "]");
         else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
     }
+    __A_VARIABLE = 1;
     return slots;
 }
 
@@ -2637,17 +2785,24 @@ static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
         if (key[s] == '{') break;
 
     /* No '{' ? Hash the whole key. This is the base case. */
-    if (s == keylen) return crc16(key,keylen) & 0x3FFF;
+    if (s == keylen) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* '{' found? Check if we have the corresponding '}'. */
     for (e = s+1; e < keylen; e++)
         if (key[e] == '}') break;
 
     /* No '}' or nothing between {} ? Hash the whole key. */
-    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
+    if (e == keylen || e == s+1) {
+        __A_VARIABLE = 1;
+        return crc16(key,keylen) & 0x3FFF;
+    }
 
     /* If we are here there is both a { and a } on its right. Hash
      * what is in the middle between { and }. */
+    __A_VARIABLE = 1;
     return crc16(key+s+1,e-s-1) & 0x3FFF;
 }
 
@@ -2680,6 +2835,7 @@ static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
         info = sdscatfmt(info, "\n%s   %U additional replica(s)",
                          spaces, node->replicas_count);
     sdsfree(spaces);
+    __A_VARIABLE = 1;
     return info;
 }
 
@@ -2693,6 +2849,7 @@ static void clusterManagerShowNodes(void) {
         printf("%s\n", (char *) info);
         sdsfree(info);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerShowClusterInfo(void) {
@@ -2729,6 +2886,7 @@ static void clusterManagerShowClusterInfo(void) {
                     err = reply->str;
                 CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
                 if (reply != NULL) freeReplyObject(reply);
+                __A_VARIABLE = 1;
                 return;
             };
             if (reply != NULL) freeReplyObject(reply);
@@ -2742,6 +2900,7 @@ static void clusterManagerShowClusterInfo(void) {
     clusterManagerLogOk("[OK] %d keys in %d masters.\n", keys, masters);
     float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
     printf("%.2f keys per slot on average.\n", keys_per_slot);
+    __A_VARIABLE = 1;
 }
 
 /* Flush dirty slots configuration of the node by calling CLUSTER ADDSLOTS */
@@ -2786,6 +2945,7 @@ cleanup:
         zfree(argv);
     }
     if (reply != NULL) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2798,7 +2958,10 @@ static int clusterManagerSetSlot(clusterManagerNode *node1,
                                                 slot, status,
                                                 (char *) node2->name);
     if (err != NULL) *err = NULL;
-    if (!reply) return 0;
+    if (!reply) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int success = 1;
     if (reply->type == REDIS_REPLY_ERROR) {
         success = 0;
@@ -2810,6 +2973,7 @@ static int clusterManagerSetSlot(clusterManagerNode *node1,
     }
 cleanup:
     freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2818,6 +2982,7 @@ static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
         "CLUSTER SETSLOT %d %s", slot, "STABLE");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2836,6 +3001,7 @@ static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
         zfree(err);
     }
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2844,6 +3010,7 @@ static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
         "CLUSTER ADDSLOTS %d", slot);
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2856,6 +3023,7 @@ static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -2863,14 +3031,18 @@ static int clusterManagerBumpEpoch(clusterManagerNode *node) {
     redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER BUMPEPOCH");
     int success = clusterManagerCheckRedisReply(node, reply, NULL);
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
     if (bulk_idx == 0 && reply) {
-        if (reply->type == REDIS_REPLY_ERROR)
+        if (reply->type == REDIS_REPLY_ERROR) {
+            __A_VARIABLE = 1;
             return strstr(reply->str, "already unassigned") != NULL;
+        }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -2879,7 +3051,10 @@ static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
                                       int do_clear)
 {
     int success = clusterManagerStartTransaction(owner);
-    if (!success) return 0;
+    if (!success) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     /* Ensure the slot is not already assigned. */
     clusterManagerDelSlot(owner, slot, 1);
     /* Add the slot and bump epoch. */
@@ -2888,6 +3063,7 @@ static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
     clusterManagerBumpEpoch(owner);
     success = clusterManagerExecTransaction(owner,
         clusterManagerIgnoreUnassignedErr);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -2960,6 +3136,7 @@ static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
 cleanup:
     zfree(argv);
     zfree(argv_len);
+    __A_VARIABLE = 1;
     return migrate_reply;
 }
 
@@ -2980,7 +3157,10 @@ static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                         "GETKEYSINSLOT %d %d", slot,
                                         pipeline);
         success = (reply != NULL);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (reply->type == REDIS_REPLY_ERROR) {
             success = 0;
             if (err != NULL) {
@@ -3047,6 +3227,7 @@ next:
         if (dots) zfree(dots);
         if (!success) break;
     }
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -3077,15 +3258,24 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
     if (!option_cold) {
         success = clusterManagerSetSlot(target, source, slot,
                                         "importing", err);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         success = clusterManagerSetSlot(source, target, slot,
                                         "migrating", err);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
     success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
                                               pipeline, print_dots, err);
     if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) printf("\n");
-    if (!success) return 0;
+    if (!success) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     /* Set the new node as the owner of the slot in all the known nodes. */
     if (!option_cold) {
         listIter li;
@@ -3099,7 +3289,10 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                                                     slot, "node",
                                                     target->name);
             success = (r != NULL);
-            if (!success) return 0;
+            if (!success) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
             if (r->type == REDIS_REPLY_ERROR) {
                 success = 0;
                 if (err != NULL) {
@@ -3109,7 +3302,10 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                 }
             }
             freeReplyObject(r);
-            if (!success) return 0;
+            if (!success) {
+                __A_VARIABLE = 1;
+                return 0;
+            }
         }
     }
     /* Update the node logical config */
@@ -3117,13 +3313,17 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
         source->slots[slot] = 0;
         target->slots[slot] = 1;
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Flush the dirty node configuration by calling replicate for slaves or
  * adding the slots defined in the masters. */
 static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
-    if (!node->dirty) return 0;
+    if (!node->dirty) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     redisReply *reply = NULL;
     int is_err = 0, success = 1;
     if (err != NULL) *err = NULL;
@@ -3149,6 +3349,7 @@ static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
     node->dirty = 0;
 cleanup:
     if (reply != NULL) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -3161,6 +3362,7 @@ static void clusterManagerWaitForClusterJoin(void) {
         sleep(1);
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* Load node's cluster configuration by calling "CLUSTER NODES" command.
@@ -3341,6 +3543,7 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
     }
 cleanup:
     if (reply) freeReplyObject(reply);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -3351,6 +3554,7 @@ cleanup:
 static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
     if (node->context == NULL && !clusterManagerNodeConnect(node)) {
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
@@ -3359,6 +3563,7 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
         clusterManagerPrintNotClusterNodeError(node, e);
         if (e) zfree(e);
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     e = NULL;
@@ -3368,6 +3573,7 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
             zfree(e);
         }
         freeClusterManagerNode(node);
+        __A_VARIABLE = 1;
         return 0;
     }
     listIter li;
@@ -3420,6 +3626,7 @@ invalid_friend:
             } else master->replicas_count++;
         }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -3427,18 +3634,21 @@ invalid_friend:
 int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
     const char **i1 = (const char **)slot1;
     const char **i2 = (const char **)slot2;
+    __A_VARIABLE = 1;
     return strcmp(*i1, *i2);
 }
 
 int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
     clusterManagerNode *node1 = *((clusterManagerNode **) n1);
     clusterManagerNode *node2 = *((clusterManagerNode **) n2);
+    __A_VARIABLE = 1;
     return node2->slots_count - node1->slots_count;
 }
 
 int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
     clusterManagerNode *node1 = *((clusterManagerNode **) n1);
     clusterManagerNode *node2 = *((clusterManagerNode **) n2);
+    __A_VARIABLE = 1;
     return node1->balance - node2->balance;
 }
 
@@ -3532,14 +3742,21 @@ cleanup:
         for (i = 0; i < node_count; i++) zfree(node_configs[i]);
         zfree(node_configs);
     }
+    __A_VARIABLE = 1;
     return signature;
 }
 
 static int clusterManagerIsConfigConsistent(void) {
-    if (cluster_manager.nodes == NULL) return 0;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int consistent = (listLength(cluster_manager.nodes) <= 1);
     // If the Cluster has only one node, it's always consistent
-    if (consistent) return 1;
+    if (consistent) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     sds first_cfg = NULL;
     listIter li;
     listNode *ln;
@@ -3559,6 +3776,7 @@ static int clusterManagerIsConfigConsistent(void) {
         }
     }
     if (first_cfg != NULL) sdsfree(first_cfg);
+    __A_VARIABLE = 1;
     return consistent;
 }
 
@@ -3568,13 +3786,17 @@ static void clusterManagerOnError(sds err) {
         cluster_manager.errors = listCreate();
     listAddNodeTail(cluster_manager.errors, err);
     clusterManagerLogErr("%s\n", (char *) err);
+    __A_VARIABLE = 1;
 }
 
 /* Check the slots coverage of the cluster. The 'all_slots' argument must be
  * and array of 16384 bytes. Every covered slot will be set to 1 in the
  * 'all_slots' array. The function returns the total number if covered slots.*/
 static int clusterManagerGetCoveredSlots(char *all_slots) {
-    if (cluster_manager.nodes == NULL) return 0;
+    if (cluster_manager.nodes == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     listIter li;
     listNode *ln;
     listRewind(cluster_manager.nodes, &li);
@@ -3588,6 +3810,7 @@ static int clusterManagerGetCoveredSlots(char *all_slots) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return totslots;
 }
 
@@ -3603,6 +3826,7 @@ static void clusterManagerPrintSlotsList(list *slots) {
         printf("%s", slot);
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 /* Return the node, among 'nodes' with the greatest number of keys
@@ -3639,6 +3863,7 @@ static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
             break;
         }
     }
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -3660,6 +3885,7 @@ static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
             lowest_count = n->replicas_count;
         }
     }
+    __A_VARIABLE = 1;
     return node;
 }
 
@@ -3684,10 +3910,12 @@ static clusterManagerNode *clusterManagerNodeMasterRandom() {
         clusterManagerNode *n = ln->value;
         if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
         if (!idx--) {
+            __A_VARIABLE = 1;
             return n;
         }
     }
     /* Can not be reached */
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -3882,6 +4110,7 @@ cleanup:
     if (none) listRelease(none);
     if (single) listRelease(single);
     if (multi) listRelease(multi);
+    __A_VARIABLE = 1;
     return fixed;
 }
 
@@ -4195,6 +4424,7 @@ cleanup:
     listRelease(importing);
     sdsfree(migrating_str);
     sdsfree(importing_str);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -4209,7 +4439,10 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
     clusterManagerLogInfo(">>> Setting slot %d owner: %s:%d\n",
                           slot, owner->ip, owner->port);
     /* Set the slot owner. */
-    if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
+    if (!clusterManagerSetSlotOwner(owner, slot, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     listIter li;
     listNode *ln;
     listRewind(cluster_manager.nodes, &li);
@@ -4224,7 +4457,10 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
         success = (count >= 0);
         if (!success) break;
         clusterManagerDelSlot(n, slot, 1);
-        if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) return 0;
+        if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
         if (count > 0) {
             int opts = CLUSTER_MANAGER_OPT_VERBOSE |
                        CLUSTER_MANAGER_OPT_COLD;
@@ -4232,12 +4468,16 @@ static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
             if (!success) break;
         }
     }
+    __A_VARIABLE = 1;
     return success;
 }
 
 static int clusterManagerCheckCluster(int quiet) {
     listNode *ln = listFirst(cluster_manager.nodes);
-    if (!ln) return 0;
+    if (!ln) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerNode *node = ln->value;
     clusterManagerLogInfo(">>> Performing Cluster Check (using node %s:%d)\n",
                           node->ip, node->port);
@@ -4393,6 +4633,7 @@ static int clusterManagerCheckCluster(int quiet) {
             listRelease(owners);
         }
     }
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -4452,6 +4693,7 @@ static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
         }
     }
     zfree(sorted);
+    __A_VARIABLE = 1;
     return moved;
 }
 
@@ -4464,6 +4706,7 @@ static void clusterManagerShowReshardTable(list *table) {
         clusterManagerNode *n = item->source;
         printf("    Moving slot %d from %s\n", item->slot, (char *) n->name);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerReleaseReshardTable(list *table) {
@@ -4477,6 +4720,7 @@ static void clusterManagerReleaseReshardTable(list *table) {
         }
         listRelease(table);
     }
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerLog(int level, const char* fmt, ...) {
@@ -4497,6 +4741,7 @@ static void clusterManagerLog(int level, const char* fmt, ...) {
     vprintf(fmt, ap);
     va_end(ap);
     if (use_colors) printf("\033[" LOG_COLOR_RESET);
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
@@ -4506,6 +4751,7 @@ static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
     array->alloc = array->nodes;
     array->len = alloc_len;
     array->count = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Reset array->nodes to the original array allocation and re-count non-NULL
@@ -4520,6 +4766,7 @@ static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
             if (array->nodes[i] != NULL) array->count++;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Shift array->nodes and store the shifted node into 'nodeptr'. */
@@ -4534,6 +4781,7 @@ static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
     /* Shift the nodes array and decrement length. */
     array->nodes++;
     array->len--;
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
@@ -4543,6 +4791,7 @@ static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
     assert(node != NULL);
     assert(array->count < array->len);
     array->nodes[array->count++] = node;
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
@@ -4556,6 +4805,7 @@ static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
               "key in database 0.";
     }
     clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
+    __A_VARIABLE = 1;
 }
 
 static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
@@ -4563,6 +4813,7 @@ static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
 {
     char *msg = (err ? err : "is not configured as a cluster node.");
     clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
+    __A_VARIABLE = 1;
 }
 
 /* Execute redis-cli in Cluster Manager mode */
@@ -4578,6 +4829,7 @@ cluster_manager_err:
     sdsfree(config.hostip);
     sdsfree(config.mb_delim);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 /* Cluster Manager Commands */
@@ -4592,6 +4844,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
         c = strrchr(addr, ':');
         if (c == NULL) {
             fprintf(stderr, "Invalid address format: %s\n", addr);
+            __A_VARIABLE = 1;
             return 0;
         }
         *c = '\0';
@@ -4600,6 +4853,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
         clusterManagerNode *node = clusterManagerNewNode(ip, port);
         if (!clusterManagerNodeConnect(node)) {
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         char *err = NULL;
@@ -4607,6 +4861,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             clusterManagerPrintNotClusterNodeError(node, err);
             if (err) zfree(err);
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         err = NULL;
@@ -4616,6 +4871,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
                 zfree(err);
             }
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         err = NULL;
@@ -4623,6 +4879,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             clusterManagerPrintNotEmptyNodeError(node, err);
             if (err) zfree(err);
             freeClusterManagerNode(node);
+            __A_VARIABLE = 1;
             return 0;
         }
         listAddNodeTail(cluster_manager.nodes, node);
@@ -4638,6 +4895,7 @@ static int clusterManagerCommandCreate(int argc, char **argv) {
             node_len, replicas);
         clusterManagerLogErr("\n*** At least %d nodes are required.\n",
                              3 * (replicas + 1));
+        __A_VARIABLE = 1;
         return 0;
     }
     clusterManagerLogInfo(">>> Performing hash slots allocation "
@@ -4854,6 +5112,7 @@ cleanup:
         CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
     }
     zfree(ip_nodes);
+    __A_VARIABLE = 1;
     return success;
 }
 
@@ -4967,17 +5226,22 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
     clusterManagerNode *node = NULL;
 
     // Load cluster information
-    if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(ref_node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     // Check if the node exists and is not empty
     node = clusterManagerNodeByName(node_id);
     if (node == NULL) {
         clusterManagerLogErr("[ERR] No such node ID %s\n", node_id);
+        __A_VARIABLE = 1;
         return 0;
     }
     if (node->slots_count != 0) {
         clusterManagerLogErr("[ERR] Node %s:%d is not empty! Reshard data "
                              "away and try again.\n", node->ip, node->port);
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -5000,13 +5264,19 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
                                                     master->name);
             success = clusterManagerCheckRedisReply(n, r, NULL);
             if (r) freeReplyObject(r);
-            if (!success) return 0;
+            if (!success) {
+            	__A_VARIABLE = 1;
+            	return 0;
+            }
         }
         redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER FORGET %s",
                                                 node_id);
         success = clusterManagerCheckRedisReply(n, r, NULL);
         if (r) freeReplyObject(r);
-        if (!success) return 0;
+        if (!success) {
+            __A_VARIABLE = 1;
+            return 0;
+        }
     }
 
     // Finally shutdown the node
@@ -5014,9 +5284,11 @@ static int clusterManagerCommandDeleteNode(int argc, char **argv) {
     redisReply *r = redisCommand(node->context, "SHUTDOWN");
     success = clusterManagerCheckRedisReply(node, r, NULL);
     if (r) freeReplyObject(r);
+    __A_VARIABLE = 1;
     return success;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5025,11 +5297,16 @@ static int clusterManagerCommandInfo(int argc, char **argv) {
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerShowClusterInfo();
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5038,16 +5315,22 @@ static int clusterManagerCommandCheck(int argc, char **argv) {
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerShowClusterInfo();
+    __A_VARIABLE = 1;
     return clusterManagerCheckCluster(0);
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
 static int clusterManagerCommandFix(int argc, char **argv) {
     config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
+    __A_VARIABLE = 1;
     return clusterManagerCommandCheck(argc, argv);
 }
 
@@ -5056,12 +5339,16 @@ static int clusterManagerCommandReshard(int argc, char **argv) {
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     clusterManagerCheckCluster(0);
     if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
         fflush(stdout);
         fprintf(stderr,
                 "*** Please fix your cluster problems before resharding\n");
+        __A_VARIABLE = 1;
         return 0;
     }
     int slots = config.cluster_manager_command.slots;
@@ -5100,7 +5387,10 @@ static int clusterManagerCommandReshard(int argc, char **argv) {
     }
     int raise_err = 0;
     clusterManagerNode *target = clusterNodeForResharding(to, NULL, &raise_err);
-    if (target == NULL) return 0;
+    if (target == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     list *sources = listCreate();
     list *table = NULL;
     int all = 0, result = 1;
@@ -5232,9 +5522,11 @@ static int clusterManagerCommandReshard(int argc, char **argv) {
 cleanup:
     listRelease(sources);
     clusterManagerReleaseReshardTable(table);
+    __A_VARIABLE = 1;
     return result;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5245,7 +5537,10 @@ static int clusterManagerCommandRebalance(int argc, char **argv) {
     list *involved = NULL;
     if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int result = 1, i;
     if (config.cluster_manager_command.weight != NULL) {
         for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
@@ -5421,9 +5716,11 @@ end_move:
 cleanup:
     if (involved != NULL) listRelease(involved);
     if (weightedNodes != NULL) zfree(weightedNodes);
+    __A_VARIABLE = 1;
     return result;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5436,11 +5733,15 @@ static int clusterManagerCommandSetTimeout(int argc, char **argv) {
     if (timeout < 100) {
         fprintf(stderr, "Setting a node timeout of less than 100 "
                 "milliseconds is a bad idea.\n");
+        __A_VARIABLE = 1;
         return 0;
     }
     // Load cluster information
     clusterManagerNode *node = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(node, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int ok_count = 0, err_count = 0;
 
     clusterManagerLogInfo(">>> Reconfiguring node timeout in every "
@@ -5479,9 +5780,11 @@ reply_err:;
     }
     clusterManagerLogInfo(">>> New node timeout set. %d OK, %d ERR.\n",
                           ok_count, err_count);
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5509,8 +5812,14 @@ static int clusterManagerCommandImport(int argc, char **argv) {
                           src_ip, src_port, ip, port);
 
     clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
-    if (!clusterManagerCheckCluster(0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(refnode, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (!clusterManagerCheckCluster(0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     char *reply_err = NULL;
     redisReply *src_reply = NULL;
     // Connect to the source node.
@@ -5618,9 +5927,11 @@ cleanup:
                              src_ip, src_port, reply_err);
     if (src_ctx) redisFree(src_ctx);
     if (src_reply) freeReplyObject(src_reply);
+    __A_VARIABLE = 1;
     return success;
 invalid_args:
     fprintf(stderr, "%s", invalid_args_msg);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5629,7 +5940,10 @@ static int clusterManagerCommandCall(int argc, char **argv) {
     char *ip = NULL;
     if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
     clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
-    if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
+    if (!clusterManagerLoadInfoFromNode(refnode, 0)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     argc--;
     argv++;
     size_t *argvlen = zmalloc(argc*sizeof(size_t));
@@ -5658,9 +5972,11 @@ static int clusterManagerCommandCall(int argc, char **argv) {
         if (reply != NULL) freeReplyObject(reply);
     }
     zfree(argvlen);
+    __A_VARIABLE = 1;
     return 1;
 invalid_args:
     fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5701,6 +6017,7 @@ static int clusterManagerCommandHelp(int argc, char **argv) {
     fprintf(stderr, "\nFor check, fix, reshard, del-node, set-timeout you "
                     "can specify the host and port of any working node in "
                     "the cluster.\n\n");
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -5718,6 +6035,7 @@ static void latencyModePrint(long long min, long long max, double avg, long long
     } else if (config.output == OUTPUT_RAW) {
         printf("%lld %lld %.2f %lld\n", min, max, avg, count);
     }
+    __A_VARIABLE = 1;
 }
 
 #define LATENCY_SAMPLE_RATE 10 /* milliseconds. */
@@ -5780,6 +6098,7 @@ static void latencyMode(void) {
         }
         usleep(LATENCY_SAMPLE_RATE * 1000);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -5825,6 +6144,7 @@ void showLatencyDistSamples(struct distsamples *samples, long long tot) {
     }
     printf("\033[0m\n");
     fflush(stdout);
+    __A_VARIABLE = 1;
 }
 
 /* Show the legend: different buckets values and colors meaning, so
@@ -5844,6 +6164,7 @@ void showLatencyDistLegend(void) {
     }
     printf("\033[0m\n");
     printf("---------------------------------------------\n");
+    __A_VARIABLE = 1;
 }
 
 static void latencyDistMode(void) {
@@ -5922,6 +6243,7 @@ static void latencyDistMode(void) {
         }
         usleep(LATENCY_SAMPLE_RATE * 1000);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -5960,6 +6282,7 @@ unsigned long long sendSync(int fd) {
         printf("SYNC with master failed: %s\n", buf);
         exit(1);
     }
+    __A_VARIABLE = 1;
     return strtoull(buf+1,NULL,10);
 }
 
@@ -5989,6 +6312,7 @@ static void slaveMode(void) {
     config.output = OUTPUT_CSV;
     while (cliReadReply(0) == REDIS_OK);
     config.output = original_output;
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6039,6 +6363,7 @@ static void getRDB(void) {
     close(fd);
     fprintf(stderr,"Transfer finished with success.\n");
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6206,6 +6531,7 @@ static void pipeMode(void) {
         exit(1);
     else
         exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6237,6 +6563,7 @@ static redisReply *sendScan(unsigned long long *it) {
     /* Update iterator */
     *it = strtoull(reply->element[0]->str, NULL, 10);
 
+    __A_VARIABLE = 1;
     return reply;
 }
 
@@ -6255,6 +6582,7 @@ static int getDbSize(void) {
     size = reply->integer;
     freeReplyObject(reply);
 
+    __A_VARIABLE = 1;
     return size;
 }
 
@@ -6281,6 +6609,7 @@ static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template)
     *info = *type_template;
     info->name = sdsnew(name);
     dictAdd(types, info->name, info);
+    __A_VARIABLE = 1;
     return info;
 }
 
@@ -6291,6 +6620,7 @@ void type_free(void* priv_data, void* val) {
         sdsfree(info->biggest_key);
     sdsfree(info->name);
     zfree(info);
+    __A_VARIABLE = 1;
 }
 
 static dictType typeinfoDictType = {
@@ -6339,6 +6669,7 @@ static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
         types[i] = type;
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 static void getKeySizes(redisReply *keys, typeinfo **types,
@@ -6392,6 +6723,7 @@ static void getKeySizes(redisReply *keys, typeinfo **types,
 
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 static void findBigKeys(int memkeys, unsigned memkeys_samples) {
@@ -6527,6 +6859,7 @@ static void findBigKeys(int memkeys, unsigned memkeys_samples) {
 
     /* Success! */
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
@@ -6557,6 +6890,7 @@ static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
         }
         freeReplyObject(reply);
     }
+    __A_VARIABLE = 1;
 }
 
 #define HOTKEYS_SAMPLE 16
@@ -6650,6 +6984,7 @@ static void findHotKeys(void) {
     }
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6664,7 +6999,10 @@ static char *getInfoField(char *info, char *field) {
     char *n1, *n2;
     char *result;
 
-    if (!p) return NULL;
+    if (!p) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     p += strlen(field)+1;
     n1 = strchr(p,'\r');
     n2 = strchr(p,',');
@@ -6672,6 +7010,7 @@ static char *getInfoField(char *info, char *field) {
     result = zmalloc(sizeof(char)*(n1-p)+1);
     memcpy(result,p,(n1-p));
     result[n1-p] = '\0';
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -6681,9 +7020,13 @@ static long getLongInfoField(char *info, char *field) {
     char *value = getInfoField(info,field);
     long l;
 
-    if (!value) return LONG_MIN;
+    if (!value) {
+        __A_VARIABLE = 1;
+        return LONG_MIN;
+    }
     l = strtol(value,NULL,10);
     zfree(value);
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -6797,6 +7140,7 @@ static void statMode(void) {
         freeReplyObject(reply);
         usleep(config.interval);
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6830,6 +7174,7 @@ static void scanMode(void) {
     } while(cur != 0);
 
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6850,6 +7195,7 @@ long long powerLawRand(long long min, long long max, double alpha) {
     pl = pow(
         ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
         (1.0/(alpha+1)));
+    __A_VARIABLE = 1;
     return (max-1-(long long)pl)+min;
 }
 
@@ -6858,6 +7204,7 @@ long long powerLawRand(long long min, long long max, double alpha) {
 void LRUTestGenKey(char *buf, size_t buflen) {
     snprintf(buf, buflen, "lru:%lld",
         powerLawRand(1, config.lru_test_sample_size, 6.2));
+    __A_VARIABLE = 1;
 }
 
 #define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */
@@ -6921,6 +7268,7 @@ static void LRUTestMode(void) {
             misses, (double)misses/(hits+misses)*100);
     }
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
@@ -6951,12 +7299,14 @@ unsigned long compute_something_fast(void) {
         s[j] = t;
         output += s[(s[i]+s[j])&255];
     }
+    __A_VARIABLE = 1;
     return output;
 }
 
 static void intrinsicLatencyModeStop(int s) {
     UNUSED(s);
     force_cancel_loop = 1;
+    __A_VARIABLE = 1;
 }
 
 static void intrinsicLatencyMode(void) {
@@ -6994,6 +7344,7 @@ static void intrinsicLatencyMode(void) {
             exit(0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /*------------------------------------------------------------------------------
diff --git a/src/release.c b/src/release.c
index 4e59c74..275f0af 100644
--- a/src/release.c
+++ b/src/release.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -38,10 +39,12 @@
 #include "crc64.h"
 
 char *redisGitSHA1(void) {
+    __A_VARIABLE = 1;
     return REDIS_GIT_SHA1;
 }
 
 char *redisGitDirty(void) {
+    __A_VARIABLE = 1;
     return REDIS_GIT_DIRTY;
 }
 
diff --git a/src/replication.c b/src/replication.c
index f8951ad..6aee472 100644
--- a/src/replication.c
+++ b/src/replication.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Asynchronous replication implementation.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -70,6 +71,7 @@ char *replicationGetSlaveName(client *c) {
         snprintf(buf,sizeof(buf),"client id #%llu",
             (unsigned long long) c->id);
     }
+    __A_VARIABLE = 1;
     return buf;
 }
 
@@ -85,6 +87,7 @@ void createReplicationBacklog(void) {
      * byte we have is the next byte that will be generated for the
      * replication stream. */
     server.repl_backlog_off = server.master_repl_offset+1;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the user modifies the replication backlog
@@ -96,7 +99,10 @@ void createReplicationBacklog(void) {
 void resizeReplicationBacklog(long long newsize) {
     if (newsize < CONFIG_REPL_BACKLOG_MIN_SIZE)
         newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
-    if (server.repl_backlog_size == newsize) return;
+    if (server.repl_backlog_size == newsize) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     server.repl_backlog_size = newsize;
     if (server.repl_backlog != NULL) {
@@ -112,12 +118,14 @@ void resizeReplicationBacklog(long long newsize) {
         /* Next byte we have is... the next since the buffer is empty. */
         server.repl_backlog_off = server.master_repl_offset+1;
     }
+    __A_VARIABLE = 1;
 }
 
 void freeReplicationBacklog(void) {
     serverAssert(listLength(server.slaves) == 0);
     zfree(server.repl_backlog);
     server.repl_backlog = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Add data to the replication backlog.
@@ -147,6 +155,7 @@ void feedReplicationBacklog(void *ptr, size_t len) {
     /* Set the offset of the first byte we have in the backlog. */
     server.repl_backlog_off = server.master_repl_offset -
                               server.repl_backlog_histlen + 1;
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for feedReplicationBacklog() that takes Redis string objects
@@ -164,6 +173,7 @@ void feedReplicationBacklogWithObject(robj *o) {
         p = o->ptr;
     }
     feedReplicationBacklog(p,len);
+    __A_VARIABLE = 1;
 }
 
 /* Propagate write commands to slaves, and populate the replication backlog
@@ -182,11 +192,17 @@ void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
      * propagate *identical* replication stream. In this way this slave can
      * advertise the same replication ID as the master (since it shares the
      * master replication history and has the same backlog and offsets). */
-    if (server.masterhost != NULL) return;
+    if (server.masterhost != NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If there aren't slaves, and there is no backlog buffer to populate,
      * we can return ASAP. */
-    if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
+    if (server.repl_backlog == NULL && listLength(slaves) == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* We can't have slaves attached and no backlog. */
     serverAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
@@ -271,6 +287,7 @@ void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
         for (j = 0; j < argc; j++)
             addReplyBulk(slave,argv[j]);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is used in order to proxy what we receive from our master
@@ -299,6 +316,7 @@ void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t bufle
         if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
         addReplyString(slave,buf,buflen);
     }
+    __A_VARIABLE = 1;
 }
 
 void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
@@ -338,6 +356,7 @@ void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv,
         addReply(monitor,cmdobj);
     }
     decrRefCount(cmdobj);
+    __A_VARIABLE = 1;
 }
 
 /* Feed the slave 'c' with the replication backlog starting from the
@@ -349,6 +368,7 @@ long long addReplyReplicationBacklog(client *c, long long offset) {
 
     if (server.repl_backlog_histlen == 0) {
         serverLog(LL_DEBUG, "[PSYNC] Backlog history len is zero");
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -389,6 +409,7 @@ long long addReplyReplicationBacklog(client *c, long long offset) {
         len -= thislen;
         j = 0;
     }
+    __A_VARIABLE = 1;
     return server.repl_backlog_histlen - skip;
 }
 
@@ -397,6 +418,7 @@ long long addReplyReplicationBacklog(client *c, long long offset) {
  * the BGSAVE process started and before executing any other command
  * from clients. */
 long long getPsyncInitialOffset(void) {
+    __A_VARIABLE = 1;
     return server.master_repl_offset;
 }
 
@@ -434,9 +456,11 @@ int replicationSetupSlaveForFullResync(client *slave, long long offset) {
                           server.replid,offset);
         if (write(slave->fd,buf,buflen) != buflen) {
             freeClientAsync(slave);
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -521,6 +545,7 @@ int masterTryPartialResynchronization(client *c) {
     }
     if (write(c->fd,buf,buflen) != buflen) {
         freeClientAsync(c);
+        __A_VARIABLE = 1;
         return C_OK;
     }
     psync_len = addReplyReplicationBacklog(c,psync_offset);
@@ -533,6 +558,7 @@ int masterTryPartialResynchronization(client *c) {
      * has this state from the previous connection with the master. */
 
     refreshGoodSlavesCount();
+    __A_VARIABLE = 1;
     return C_OK; /* The caller can return, no full resync needed. */
 
 need_full_resync:
@@ -540,6 +566,7 @@ need_full_resync:
      * reply to PSYNC right now if a full SYNC is needed. The reply
      * must include the master offset at the time the RDB file we transfer
      * is generated, so we need to delay the reply to that moment. */
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -602,6 +629,7 @@ int startBgsaveForReplication(int mincapa) {
                 slave->flags |= CLIENT_CLOSE_AFTER_REPLY;
             }
         }
+        __A_VARIABLE = 1;
         return retval;
     }
 
@@ -622,6 +650,7 @@ int startBgsaveForReplication(int mincapa) {
     /* Flush the script cache, since we need that slave differences are
      * accumulated without requiring slaves to match our cached scripts. */
     if (retval == C_OK) replicationScriptCacheFlush();
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -866,11 +895,13 @@ void putSlaveOnline(client *slave) {
         sendReplyToClient, slave) == AE_ERR) {
         serverLog(LL_WARNING,"Unable to register writable event for replica bulk transfer: %s", strerror(errno));
         freeClient(slave);
+        __A_VARIABLE = 1;
         return;
     }
     refreshGoodSlavesCount();
     serverLog(LL_NOTICE,"Synchronization with replica %s succeeded",
         replicationGetSlaveName(slave));
+    __A_VARIABLE = 1;
 }
 
 void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -1024,6 +1055,7 @@ void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
         }
     }
     if (startbgsave) startBgsaveForReplication(mincapa);
+    __A_VARIABLE = 1;
 }
 
 /* Change the current instance replication ID with a new, random one.
@@ -1033,6 +1065,7 @@ void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
 void changeReplicationId(void) {
     getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
     server.replid[CONFIG_RUN_ID_SIZE] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Clear (invalidate) the secondary replication ID. This happens, for
@@ -1042,6 +1075,7 @@ void clearReplicationId2(void) {
     memset(server.replid2,'0',sizeof(server.replid));
     server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
     server.second_replid_offset = -1;
+    __A_VARIABLE = 1;
 }
 
 /* Use the current replication ID / offset as secondary replication
@@ -1061,6 +1095,7 @@ void shiftReplicationId(void) {
     server.second_replid_offset = server.master_repl_offset+1;
     changeReplicationId();
     serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------- SLAVE -------------------------------- */
@@ -1068,6 +1103,7 @@ void shiftReplicationId(void) {
 /* Returns 1 if the given replication state is a handshake state,
  * 0 otherwise. */
 int slaveIsInHandshakeState(void) {
+    __A_VARIABLE = 1;
     return server.repl_state >= REPL_STATE_RECEIVE_PONG &&
            server.repl_state <= REPL_STATE_RECEIVE_PSYNC;
 }
@@ -1088,6 +1124,7 @@ void replicationSendNewlineToMaster(void) {
             /* Pinging back in this stage is best-effort. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Callback used by emptyDb() while flushing away old data to load
@@ -1095,6 +1132,7 @@ void replicationSendNewlineToMaster(void) {
 void replicationEmptyDbCallback(void *privdata) {
     UNUSED(privdata);
     replicationSendNewlineToMaster();
+    __A_VARIABLE = 1;
 }
 
 /* Once we have a link with the master and the synchroniziation was
@@ -1113,6 +1151,7 @@ void replicationCreateMasterClient(int fd, int dbid) {
     if (server.master->reploff == -1)
         server.master->flags |= CLIENT_PRE_PSYNC;
     if (dbid != -1) selectDb(server.master,dbid);
+    __A_VARIABLE = 1;
 }
 
 /* This function will try to re-enable the AOF file after the
@@ -1134,6 +1173,7 @@ void restartAOFAfterSYNC() {
             "its master, but the AOF can't be turned on. Exiting now.");
         exit(1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Asynchronously read the SYNC payload we receive from a master */
@@ -1393,6 +1433,7 @@ char *sendSynchronousCommand(int flags, int fd, ...) {
             == -1)
         {
             sdsfree(cmd);
+            __A_VARIABLE = 1;
             return sdscatprintf(sdsempty(),"-Writing to master: %s",
                     strerror(errno));
         }
@@ -1406,12 +1447,15 @@ char *sendSynchronousCommand(int flags, int fd, ...) {
         if (syncReadLine(fd,buf,sizeof(buf),server.repl_syncio_timeout*1000)
             == -1)
         {
+            __A_VARIABLE = 1;
             return sdscatprintf(sdsempty(),"-Reading from master: %s",
                     strerror(errno));
         }
         server.repl_transfer_lastio = server.unixtime;
+        __A_VARIABLE = 1;
         return sdsnew(buf);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1499,8 +1543,10 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
             serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
             sdsfree(reply);
             aeDeleteFileEvent(server.el,fd,AE_READABLE);
+            __A_VARIABLE = 1;
             return PSYNC_WRITE_ERROR;
         }
+        __A_VARIABLE = 1;
         return PSYNC_WAIT_REPLY;
     }
 
@@ -1510,6 +1556,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
         /* The master may send empty newlines after it receives PSYNC
          * and before to reply, just to keep the connection alive. */
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_WAIT_REPLY;
     }
 
@@ -1545,6 +1592,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
         /* We are going to full resync, discard the cached master structure. */
         replicationDiscardCachedMaster();
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_FULLRESYNC;
     }
 
@@ -1593,6 +1641,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
          * PSYNC from the persistence file, our replication backlog could
          * be still not initialized. Create it. */
         if (server.repl_backlog == NULL) createReplicationBacklog();
+        __A_VARIABLE = 1;
         return PSYNC_CONTINUE;
     }
 
@@ -1610,6 +1659,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
             "Master is currently unable to PSYNC "
             "but should be in the future: %s", reply);
         sdsfree(reply);
+        __A_VARIABLE = 1;
         return PSYNC_TRY_LATER;
     }
 
@@ -1624,6 +1674,7 @@ int slaveTryPartialResynchronization(int fd, int read_reply) {
     }
     sdsfree(reply);
     replicationDiscardCachedMaster();
+    __A_VARIABLE = 1;
     return PSYNC_NOT_SUPPORTED;
 }
 
@@ -1915,6 +1966,7 @@ int connectWithMaster(void) {
     if (fd == -1) {
         serverLog(LL_WARNING,"Unable to connect to MASTER: %s",
             strerror(errno));
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1923,12 +1975,14 @@ int connectWithMaster(void) {
     {
         close(fd);
         serverLog(LL_WARNING,"Can't create readable event for SYNC");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
     server.repl_transfer_lastio = server.unixtime;
     server.repl_transfer_s = fd;
     server.repl_state = REPL_STATE_CONNECTING;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1942,6 +1996,7 @@ void undoConnectWithMaster(void) {
     aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
     close(fd);
     server.repl_transfer_s = -1;
+    __A_VARIABLE = 1;
 }
 
 /* Abort the async download of the bulk dataset while SYNC-ing with master.
@@ -1953,6 +2008,7 @@ void replicationAbortSyncTransfer(void) {
     close(server.repl_transfer_fd);
     unlink(server.repl_transfer_tmpfile);
     zfree(server.repl_transfer_tmpfile);
+    __A_VARIABLE = 1;
 }
 
 /* This function aborts a non blocking replication attempt if there is one
@@ -1998,11 +2054,15 @@ void replicationSetMaster(char *ip, int port) {
      * our own parameters, to later PSYNC with the new master. */
     if (was_master) replicationCacheMasterUsingMyself();
     server.repl_state = REPL_STATE_CONNECT;
+    __A_VARIABLE = 1;
 }
 
 /* Cancel replication, setting the instance as a master itself. */
 void replicationUnsetMaster(void) {
-    if (server.masterhost == NULL) return; /* Nothing to do. */
+    if (server.masterhost == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Nothing to do. */
     sdsfree(server.masterhost);
     server.masterhost = NULL;
     /* When a slave is turned into a master, the current replication ID
@@ -2031,6 +2091,7 @@ void replicationUnsetMaster(void) {
      * starting from now. Otherwise the backlog will be freed after a
      * failover if slaves do not connect immediately. */
     server.repl_no_slaves_since = server.unixtime;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the slave lose the connection with the
@@ -2042,6 +2103,7 @@ void replicationHandleMasterDisconnection(void) {
     /* We lost connection with our master, don't disconnect slaves yet,
      * maybe we'll be able to PSYNC with our master later. We'll disconnect
      * the slaves only if we'll have to do a full resync with our master. */
+    __A_VARIABLE = 1;
 }
 
 void replicaofCommand(client *c) {
@@ -2150,6 +2212,7 @@ void roleCommand(client *c) {
         addReplyBulkCString(c,slavestate);
         addReplyLongLong(c,server.master ? server.master->reploff : -1);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send a REPLCONF ACK command to the master to inform it about the current
@@ -2166,6 +2229,7 @@ void replicationSendAck(void) {
         addReplyBulkLongLong(c,c->reploff);
         c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */
@@ -2223,6 +2287,7 @@ void replicationCacheMaster(client *c) {
      * so make sure to adjust the replication state. This function will
      * also set server.master to NULL. */
     replicationHandleMasterDisconnection();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when a master is turend into a slave, in order to
@@ -2248,17 +2313,22 @@ void replicationCacheMasterUsingMyself(void) {
     server.cached_master = server.master;
     server.master = NULL;
     serverLog(LL_NOTICE,"Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.");
+    __A_VARIABLE = 1;
 }
 
 /* Free a cached master, called when there are no longer the conditions for
  * a partial resync on reconnection. */
 void replicationDiscardCachedMaster(void) {
-    if (server.cached_master == NULL) return;
+    if (server.cached_master == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     serverLog(LL_NOTICE,"Discarding previously cached master state.");
     server.cached_master->flags &= ~CLIENT_MASTER;
     freeClient(server.cached_master);
     server.cached_master = NULL;
+    __A_VARIABLE = 1;
 }
 
 /* Turn the cached master into the current master, using the file descriptor
@@ -2294,6 +2364,7 @@ void replicationResurrectCachedMaster(int newfd) {
             freeClientAsync(server.master); /* Close ASAP. */
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */
@@ -2307,7 +2378,10 @@ void refreshGoodSlavesCount(void) {
     int good = 0;
 
     if (!server.repl_min_slaves_to_write ||
-        !server.repl_min_slaves_max_lag) return;
+        !server.repl_min_slaves_max_lag) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
@@ -2318,6 +2392,7 @@ void refreshGoodSlavesCount(void) {
             lag <= server.repl_min_slaves_max_lag) good++;
     }
     server.repl_good_slaves_count = good;
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------- REPLICATION SCRIPT CACHE --------------------------
@@ -2356,6 +2431,7 @@ void replicationScriptCacheInit(void) {
     server.repl_scriptcache_size = 10000;
     server.repl_scriptcache_dict = dictCreate(&replScriptCacheDictType,NULL);
     server.repl_scriptcache_fifo = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Empty the script cache. Should be called every time we are no longer sure
@@ -2373,6 +2449,7 @@ void replicationScriptCacheFlush(void) {
     dictEmpty(server.repl_scriptcache_dict,NULL);
     listRelease(server.repl_scriptcache_fifo);
     server.repl_scriptcache_fifo = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Add an entry into the script cache, if we reach max number of entries the
@@ -2396,11 +2473,13 @@ void replicationScriptCacheAdd(sds sha1) {
     retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
     listAddNodeHead(server.repl_scriptcache_fifo,key);
     serverAssert(retval == DICT_OK);
+    __A_VARIABLE = 1;
 }
 
 /* Returns non-zero if the specified entry exists inside the cache, that is,
  * if all the slaves are aware of this script SHA1. */
 int replicationScriptCacheExists(sds sha1) {
+    __A_VARIABLE = 1;
     return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
 }
 
@@ -2436,6 +2515,7 @@ int replicationScriptCacheExists(sds sha1) {
  * in a given event loop iteration, and send a single GETACK for them all. */
 void replicationRequestAckFromSlaves(void) {
     server.get_ack_from_slaves = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Return the number of slaves that already acknowledged the specified
@@ -2452,6 +2532,7 @@ int replicationCountAcksByOffset(long long offset) {
         if (slave->replstate != SLAVE_STATE_ONLINE) continue;
         if (slave->repl_ack_off >= offset) count++;
     }
+    __A_VARIABLE = 1;
     return count;
 }
 
@@ -2464,19 +2545,26 @@ void waitCommand(client *c) {
 
     if (server.masterhost) {
         addReplyError(c,"WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated.");
+        __A_VARIABLE = 1;
         return;
     }
 
     /* Argument parsing. */
-    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
+    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
-        != C_OK) return;
+        != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* First try without blocking at all. */
     ackreplicas = replicationCountAcksByOffset(c->woff);
     if (ackreplicas >= numreplicas || c->flags & CLIENT_MULTI) {
         addReplyLongLong(c,ackreplicas);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2491,6 +2579,7 @@ void waitCommand(client *c) {
     /* Make sure that the server will send an ACK request to all the slaves
      * before returning to the event loop. */
     replicationRequestAckFromSlaves();
+    __A_VARIABLE = 1;
 }
 
 /* This is called by unblockClient() to perform the blocking op type
@@ -2501,6 +2590,7 @@ void unblockClientWaitingReplicas(client *c) {
     listNode *ln = listSearchKey(server.clients_waiting_acks,c);
     serverAssert(ln != NULL);
     listDelNode(server.clients_waiting_acks,ln);
+    __A_VARIABLE = 1;
 }
 
 /* Check if there are clients blocked in WAIT that can be unblocked since
@@ -2536,6 +2626,7 @@ void processClientsWaitingReplicas(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the slave replication offset for this instance, that is
@@ -2555,6 +2646,7 @@ long long replicationGetSlaveOffset(void) {
      * amount of data processed by the master, so we return a positive
      * integer. */
     if (offset < 0) offset = 0;
+    __A_VARIABLE = 1;
     return offset;
 }
 
@@ -2771,4 +2863,5 @@ void replicationCron(void) {
     /* Refresh the number of slaves with lag <= min-slaves-max-lag. */
     refreshGoodSlavesCount();
     replication_cron_loops++; /* Incremented with frequency 1 HZ. */
+    __A_VARIABLE = 1;
 }
diff --git a/src/rio.c b/src/rio.c
index c9c76b8..b20bfa6 100644
--- a/src/rio.c
+++ b/src/rio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* rio.c is a simple stream-oriented I/O abstraction that provides an interface
  * to write code that can consume/produce data using different concrete input
  * and output devices. For instance the same rdb.c code using the rio
@@ -61,20 +62,25 @@
 static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
     r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
     r->io.buffer.pos += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioBufferRead(rio *r, void *buf, size_t len) {
-    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
-        return 0; /* not enough buffer to return len bytes. */
+    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* not enough buffer to return len bytes. */
     memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
     r->io.buffer.pos += len;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Returns read/write position in buffer. */
 static off_t rioBufferTell(rio *r) {
+    __A_VARIABLE = 1;
     return r->io.buffer.pos;
 }
 
@@ -82,6 +88,7 @@ static off_t rioBufferTell(rio *r) {
  * and 0 on failures. */
 static int rioBufferFlush(rio *r) {
     UNUSED(r);
+    __A_VARIABLE = 1;
     return 1; /* Nothing to do, our write just appends to the buffer. */
 }
 
@@ -101,6 +108,7 @@ void rioInitWithBuffer(rio *r, sds s) {
     *r = rioBufferIO;
     r->io.buffer.ptr = s;
     r->io.buffer.pos = 0;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------- Stdio file pointer implementation ------------------- */
@@ -119,22 +127,26 @@ static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
         redis_fsync(fileno(r->io.file.fp));
         r->io.file.buffered = 0;
     }
+    __A_VARIABLE = 1;
     return retval;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioFileRead(rio *r, void *buf, size_t len) {
+    __A_VARIABLE = 1;
     return fread(buf,len,1,r->io.file.fp);
 }
 
 /* Returns read/write position in file. */
 static off_t rioFileTell(rio *r) {
+    __A_VARIABLE = 1;
     return ftello(r->io.file.fp);
 }
 
 /* Flushes any buffer to target device if applicable. Returns 1 on success
  * and 0 on failures. */
 static int rioFileFlush(rio *r) {
+    __A_VARIABLE = 1;
     return (fflush(r->io.file.fp) == 0) ? 1 : 0;
 }
 
@@ -155,6 +167,7 @@ void rioInitWithFile(rio *r, FILE *fp) {
     r->io.file.fp = fp;
     r->io.file.buffered = 0;
     r->io.file.autosync = 0;
+    __A_VARIABLE = 1;
 }
 
 /* ------------------- File descriptors set implementation ------------------- */
@@ -220,13 +233,17 @@ static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {
                 if (r->io.fdset.state[j] == 0) r->io.fdset.state[j] = EIO;
             }
         }
-        if (broken == r->io.fdset.numfds) return 0; /* All the FDs in error. */
+        if (broken == r->io.fdset.numfds) {
+            __A_VARIABLE = 1;
+            return 0;
+        } /* All the FDs in error. */
         p += count;
         len -= count;
         r->io.fdset.pos += count;
     }
 
     if (doflush) sdsclear(r->io.fdset.buf);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -235,11 +252,13 @@ static size_t rioFdsetRead(rio *r, void *buf, size_t len) {
     UNUSED(r);
     UNUSED(buf);
     UNUSED(len);
+    __A_VARIABLE = 1;
     return 0; /* Error, this target does not support reading. */
 }
 
 /* Returns read/write position in file. */
 static off_t rioFdsetTell(rio *r) {
+    __A_VARIABLE = 1;
     return r->io.fdset.pos;
 }
 
@@ -248,6 +267,7 @@ static off_t rioFdsetTell(rio *r) {
 static int rioFdsetFlush(rio *r) {
     /* Our flush is implemented by the write method, that recognizes a
      * buffer set to NULL with a count of zero as a flush request. */
+    __A_VARIABLE = 1;
     return rioFdsetWrite(r,NULL,0);
 }
 
@@ -274,6 +294,7 @@ void rioInitWithFdset(rio *r, int *fds, int numfds) {
     r->io.fdset.numfds = numfds;
     r->io.fdset.pos = 0;
     r->io.fdset.buf = sdsempty();
+    __A_VARIABLE = 1;
 }
 
 /* release the rio stream. */
@@ -281,6 +302,7 @@ void rioFreeFdset(rio *r) {
     zfree(r->io.fdset.fds);
     zfree(r->io.fdset.state);
     sdsfree(r->io.fdset.buf);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------- Generic functions ---------------------------- */
@@ -289,6 +311,7 @@ void rioFreeFdset(rio *r) {
  * computation is needed. */
 void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
     r->cksum = crc64(r->cksum,buf,len);
+    __A_VARIABLE = 1;
 }
 
 /* Set the file-based rio object to auto-fsync every 'bytes' file written.
@@ -302,6 +325,7 @@ void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
 void rioSetAutoSync(rio *r, off_t bytes) {
     serverAssert(r->read == rioFileIO.read);
     r->io.file.autosync = bytes;
+    __A_VARIABLE = 1;
 }
 
 /* --------------------------- Higher level interface --------------------------
@@ -318,7 +342,11 @@ size_t rioWriteBulkCount(rio *r, char prefix, long count) {
     clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
     cbuf[clen++] = '\r';
     cbuf[clen++] = '\n';
-    if (rioWrite(r,cbuf,clen) == 0) return 0;
+    if (rioWrite(r,cbuf,clen) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return clen;
 }
 
@@ -326,9 +354,19 @@ size_t rioWriteBulkCount(rio *r, char prefix, long count) {
 size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
     size_t nwritten;
 
-    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) return 0;
-    if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
-    if (rioWrite(r,"\r\n",2) == 0) return 0;
+    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (len > 0 && rioWrite(r,buf,len) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (rioWrite(r,"\r\n",2) == 0) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return nwritten+len+2;
 }
 
@@ -338,6 +376,7 @@ size_t rioWriteBulkLongLong(rio *r, long long l) {
     unsigned int llen;
 
     llen = ll2string(lbuf,sizeof(lbuf),l);
+    __A_VARIABLE = 1;
     return rioWriteBulkString(r,lbuf,llen);
 }
 
@@ -347,5 +386,6 @@ size_t rioWriteBulkDouble(rio *r, double d) {
     unsigned int dlen;
 
     dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
+    __A_VARIABLE = 1;
     return rioWriteBulkString(r,dbuf,dlen);
 }
diff --git a/src/scripting.c b/src/scripting.c
index bfe5c5c..1caec34 100644
--- a/src/scripting.c
+++ b/src/scripting.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -101,6 +102,7 @@ void sha1hex(char *digest, char *script, size_t len) {
         digest[j*2+1] = cset[(hash[j]&0xF)];
     }
     digest[40] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -134,6 +136,7 @@ char *redisProtocolToLuaType(lua_State *lua, char* reply) {
     case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
     case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -143,6 +146,7 @@ char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {
 
     string2ll(reply+1,p-reply-1,&value);
     lua_pushnumber(lua,(lua_Number)value);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -167,6 +171,7 @@ char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {
     lua_pushstring(lua,"ok");
     lua_pushlstring(lua,reply+1,p-reply-1);
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -177,6 +182,7 @@ char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {
     lua_pushstring(lua,"err");
     lua_pushlstring(lua,reply+1,p-reply-1);
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -189,6 +195,7 @@ char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
     p += 2;
     if (mbulklen == -1) {
         lua_pushboolean(lua,0);
+        __A_VARIABLE = 1;
         return p;
     }
     lua_newtable(lua);
@@ -197,6 +204,7 @@ char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {
         p = redisProtocolToLuaType(lua,p);
         lua_settable(lua,-3);
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -227,6 +235,7 @@ void luaPushError(lua_State *lua, char *error) {
         lua_pushstring(lua, error);
     }
     lua_settable(lua,-3);
+    __A_VARIABLE = 1;
 }
 
 /* In case the error set into the Lua stack by luaPushError() was generated
@@ -236,6 +245,7 @@ void luaPushError(lua_State *lua, char *error) {
 int luaRaiseError(lua_State *lua) {
     lua_pushstring(lua,"err");
     lua_gettable(lua,-2);
+    __A_VARIABLE = 1;
     return lua_error(lua);
 }
 
@@ -268,6 +278,7 @@ void luaSortArray(lua_State *lua) {
     }
     /* Stack: array (sorted), table */
     lua_pop(lua,1);             /* Stack: array (sorted) */
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -301,6 +312,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
             addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
             sdsfree(err);
             lua_pop(lua,2);
+            __A_VARIABLE = 1;
             return;
         }
 
@@ -337,6 +349,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
         addReply(c,shared.nullbulk);
     }
     lua_pop(lua,1);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -375,6 +388,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
             "Are you doing funny stuff with Lua debug hooks?";
         serverLog(LL_WARNING,"%s",recursion_warning);
         luaPushError(lua,recursion_warning);
+        __A_VARIABLE = 1;
         return 1;
     }
     inuse++;
@@ -384,6 +398,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
         luaPushError(lua,
             "Please specify at least one argument for redis.call()");
         inuse--;
+        __A_VARIABLE = 1;
         return raise_error ? luaRaiseError(lua) : 1;
     }
 
@@ -436,6 +451,7 @@ int luaRedisGenericCommand(lua_State *lua, int raise_error) {
         luaPushError(lua,
             "Lua redis() command arguments must be strings or integers");
         inuse--;
+        __A_VARIABLE = 1;
         return raise_error ? luaRaiseError(lua) : 1;
     }
 
@@ -647,19 +663,23 @@ cleanup:
          * form of a table with an "err" field. Extract the string to
          * return the plain error. */
         inuse--;
+        __A_VARIABLE = 1;
         return luaRaiseError(lua);
     }
     inuse--;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* redis.call() */
 int luaRedisCallCommand(lua_State *lua) {
+    __A_VARIABLE = 1;
     return luaRedisGenericCommand(lua,1);
 }
 
 /* redis.pcall() */
 int luaRedisPCallCommand(lua_State *lua) {
+    __A_VARIABLE = 1;
     return luaRedisGenericCommand(lua,0);
 }
 
@@ -673,12 +693,14 @@ int luaRedisSha1hexCommand(lua_State *lua) {
 
     if (argc != 1) {
         lua_pushstring(lua, "wrong number of arguments");
+        __A_VARIABLE = 1;
         return lua_error(lua);
     }
 
     s = (char*)lua_tolstring(lua,1,&len);
     sha1hex(digest,s,len);
     lua_pushstring(lua,digest);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -692,6 +714,7 @@ int luaRedisSha1hexCommand(lua_State *lua) {
 int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
     if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
         luaPushError(lua, "wrong number or type of arguments");
+        __A_VARIABLE = 1;
         return 1;
     }
 
@@ -699,16 +722,19 @@ int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
     lua_pushstring(lua, field);
     lua_pushvalue(lua, -3);
     lua_settable(lua, -3);
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* redis.error_reply() */
 int luaRedisErrorReplyCommand(lua_State *lua) {
+    __A_VARIABLE = 1;
     return luaRedisReturnSingleFieldTable(lua,"err");
 }
 
 /* redis.status_reply() */
 int luaRedisStatusReplyCommand(lua_State *lua) {
+    __A_VARIABLE = 1;
     return luaRedisReturnSingleFieldTable(lua,"ok");
 }
 
@@ -729,6 +755,7 @@ int luaRedisReplicateCommandsCommand(lua_State *lua) {
         redisSrand48(rand());
         lua_pushboolean(lua,1);
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -744,6 +771,7 @@ int luaRedisBreakpointCommand(lua_State *lua) {
     } else {
         lua_pushboolean(lua,0);
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -753,7 +781,10 @@ int luaRedisBreakpointCommand(lua_State *lua) {
  * Can take multiple arguments that will be separated by commas.
  * Nothing is returned to the caller. */
 int luaRedisDebugCommand(lua_State *lua) {
-    if (!ldb.active) return 0;
+    if (!ldb.active) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     int argc = lua_gettop(lua);
     sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);
     while(argc--) {
@@ -761,6 +792,7 @@ int luaRedisDebugCommand(lua_State *lua) {
         if (argc != 0) log = sdscatlen(log,", ",2);
     }
     ldbLog(log);
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -833,6 +865,7 @@ void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
   lua_pushcfunction(lua, luafunc);
   lua_pushstring(lua, libname);
   lua_call(lua, 1, 0);
+  __A_VARIABLE = 1;
 }
 
 LUALIB_API int (luaopen_cjson) (lua_State *L);
@@ -855,6 +888,7 @@ void luaLoadLibraries(lua_State *lua) {
     luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
     luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /* Remove a functions that we don't want to expose to the Redis scripting
@@ -864,6 +898,7 @@ void luaRemoveUnsupportedFunctions(lua_State *lua) {
     lua_setglobal(lua,"loadfile");
     lua_pushnil(lua);
     lua_setglobal(lua,"dofile");
+    __A_VARIABLE = 1;
 }
 
 /* This function installs metamethods in the global table _G that prevent
@@ -903,6 +938,7 @@ void scriptingEnableGlobalsProtection(lua_State *lua) {
     luaL_loadbuffer(lua,code,sdslen(code),"@enable_strict_lua");
     lua_pcall(lua,0,0,0);
     sdsfree(code);
+    __A_VARIABLE = 1;
 }
 
 /* Initialize the scripting environment.
@@ -1085,6 +1121,7 @@ void scriptingInit(int setup) {
     scriptingEnableGlobalsProtection(lua);
 
     server.lua = lua;
+    __A_VARIABLE = 1;
 }
 
 /* Release resources related to Lua scripting.
@@ -1093,11 +1130,13 @@ void scriptingRelease(void) {
     dictRelease(server.lua_scripts);
     server.lua_scripts_mem = 0;
     lua_close(server.lua);
+    __A_VARIABLE = 1;
 }
 
 void scriptingReset(void) {
     scriptingRelease();
     scriptingInit(0);
+    __A_VARIABLE = 1;
 }
 
 /* Set an array of Redis String Objects as a Lua array (table) stored into a
@@ -1111,6 +1150,7 @@ void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
         lua_rawseti(lua,-2,j+1);
     }
     lua_setglobal(lua,var);
+    __A_VARIABLE = 1;
 }
 
 /* ---------------------------------------------------------------------------
@@ -1146,13 +1186,16 @@ int redis_math_random (lua_State *L) {
       lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
       break;
     }
-    default: return luaL_error(L, "wrong number of arguments");
+    default: __A_VARIABLE = 1;
+    return luaL_error(L, "wrong number of arguments");
   }
+  __A_VARIABLE = 1;
   return 1;
 }
 
 int redis_math_randomseed (lua_State *L) {
   redisSrand48(luaL_checkint(L, 1));
+  __A_VARIABLE = 1;
   return 0;
 }
 
@@ -1188,6 +1231,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
     sds sha = sdsnewlen(funcname+2,40);
     if ((de = dictFind(server.lua_scripts,sha)) != NULL) {
         sdsfree(sha);
+        __A_VARIABLE = 1;
         return dictGetKey(de);
     }
 
@@ -1207,6 +1251,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
         lua_pop(lua,1);
         sdsfree(sha);
         sdsfree(funcdef);
+        __A_VARIABLE = 1;
         return NULL;
     }
     sdsfree(funcdef);
@@ -1218,6 +1263,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
         }
         lua_pop(lua,1);
         sdsfree(sha);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1228,6 +1274,7 @@ sds luaCreateFunction(client *c, lua_State *lua, robj *body) {
     serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);
     server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);
     incrRefCount(body);
+    __A_VARIABLE = 1;
     return sha;
 }
 
@@ -1255,6 +1302,7 @@ void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
         lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
         lua_error(lua);
     }
+    __A_VARIABLE = 1;
 }
 
 void evalGenericCommand(client *c, int evalsha) {
@@ -1468,6 +1516,7 @@ void evalCommand(client *c) {
         evalGenericCommand(c,0);
     else
         evalGenericCommandWithDebugging(c,0);
+    __A_VARIABLE = 1;
 }
 
 void evalShaCommand(client *c) {
@@ -1567,6 +1616,7 @@ void ldbInit(void) {
     ldb.src = NULL;
     ldb.lines = 0;
     ldb.cbuf = sdsempty();
+    __A_VARIABLE = 1;
 }
 
 /* Remove all the pending messages in the specified list. */
@@ -1575,6 +1625,7 @@ void ldbFlushLog(list *log) {
 
     while((ln = listFirst(log)) != NULL)
         listDelNode(log,ln);
+    __A_VARIABLE = 1;
 }
 
 /* Enable debug mode of Lua scripts for this client. */
@@ -1589,6 +1640,7 @@ void ldbEnable(client *c) {
     ldb.cbuf = sdsempty();
     ldb.maxlen = LDB_MAX_LEN_DEFAULT;
     ldb.maxlen_hint_sent = 0;
+    __A_VARIABLE = 1;
 }
 
 /* Exit debugging mode from the POV of client. This function is not enough
@@ -1596,11 +1648,13 @@ void ldbEnable(client *c) {
  * for more information. */
 void ldbDisable(client *c) {
     c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
+    __A_VARIABLE = 1;
 }
 
 /* Append a log entry to the specified LDB log. */
 void ldbLog(sds entry) {
     listAddNodeTail(ldb.logs,entry);
+    __A_VARIABLE = 1;
 }
 
 /* A version of ldbLog() which prevents producing logs greater than
@@ -1620,6 +1674,7 @@ void ldbLogWithMaxLen(sds entry) {
         ldbLog(sdsnew(
         "<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send ldb.logs to the debugging client as a multi-bulk reply
@@ -1642,6 +1697,7 @@ void ldbSendLogs(void) {
          * close the debugging session. */
     }
     sdsfree(proto);
+    __A_VARIABLE = 1;
 }
 
 /* Start a debugging session before calling EVAL implementation.
@@ -1737,6 +1793,7 @@ void ldbEndSession(client *c) {
     sdsfreesplitres(ldb.src,ldb.lines);
     ldb.lines = 0;
     ldb.active = 0;
+    __A_VARIABLE = 1;
 }
 
 /* If the specified pid is among the list of children spawned for
@@ -1746,14 +1803,17 @@ int ldbRemoveChild(pid_t pid) {
     listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
     if (ln) {
         listDelNode(ldb.children,ln);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
 /* Return the number of children we still did not receive termination
  * acknowledge via wait() in the parent process. */
 int ldbPendingChildren(void) {
+    __A_VARIABLE = 1;
     return listLength(ldb.children);
 }
 
@@ -1770,6 +1830,7 @@ void ldbKillForkedSessions(void) {
     }
     listRelease(ldb.children);
     ldb.children = listCreate();
+    __A_VARIABLE = 1;
 }
 
 /* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure
@@ -1781,13 +1842,18 @@ void evalGenericCommandWithDebugging(client *c, int evalsha) {
     } else {
         ldbDisable(c);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return a pointer to ldb.src source code line, considering line to be
  * one-based, and returning a special string for out of range lines. */
 char *ldbGetSourceLine(int line) {
     int idx = line-1;
-    if (idx < 0 || idx >= ldb.lines) return "<out of range source code line>";
+    if (idx < 0 || idx >= ldb.lines) {
+        __A_VARIABLE = 1;
+        return "<out of range source code line>";
+    }
+    __A_VARIABLE = 1;
     return ldb.src[idx];
 }
 
@@ -1796,7 +1862,11 @@ int ldbIsBreakpoint(int line) {
     int j;
 
     for (j = 0; j < ldb.bpcount; j++)
-        if (ldb.bp[j] == line) return 1;
+        if (ldb.bp[j] == line) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1804,11 +1874,16 @@ int ldbIsBreakpoint(int line) {
  * Returns 1 if the breakpoint was added (or was already set). 0 if there is
  * no space for the breakpoint or if the line is invalid. */
 int ldbAddBreakpoint(int line) {
-    if (line <= 0 || line > ldb.lines) return 0;
+    if (line <= 0 || line > ldb.lines) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
         ldb.bp[ldb.bpcount++] = line;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1821,9 +1896,11 @@ int ldbDelBreakpoint(int line) {
         if (ldb.bp[j] == line) {
             ldb.bpcount--;
             memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
+            __A_VARIABLE = 1;
             return 1;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -1833,7 +1910,10 @@ int ldbDelBreakpoint(int line) {
 sds *ldbReplParseCommand(int *argcp) {
     sds *argv = NULL;
     int argc = 0;
-    if (sdslen(ldb.cbuf) == 0) return NULL;
+    if (sdslen(ldb.cbuf) == 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Working on a copy is simpler in this case. We can modify it freely
      * for the sake of simpler parsing. */
@@ -1868,11 +1948,13 @@ sds *ldbReplParseCommand(int *argcp) {
         p += 2; /* Skip \r\n. */
     }
     sdsfree(copy);
+    __A_VARIABLE = 1;
     return argv;
 
 protoerr:
     sdsfreesplitres(argv,argc);
     sdsfree(copy);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1893,6 +1975,7 @@ void ldbLogSourceLine(int lnum) {
         prefix = "   ";
     sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);
     ldbLog(thisline);
+    __A_VARIABLE = 1;
 }
 
 /* Implement the "list" command of the Lua debugger. If around is 0
@@ -1907,6 +1990,7 @@ void ldbList(int around, int context) {
         if (around != 0 && abs(around-j) > context) continue;
         ldbLogSourceLine(j);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Append an human readable representation of the Lua value at position 'idx'
@@ -1920,8 +2004,10 @@ void ldbList(int around, int context) {
 sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
     int t = lua_type(lua,idx);
 
-    if (level++ == LDB_MAX_VALUES_DEPTH)
+    if (level++ == LDB_MAX_VALUES_DEPTH) {
+        __A_VARIABLE = 1;
         return sdscat(s,"<max recursion level reached! Nested table?>");
+    }
 
     switch(t) {
     case LUA_TSTRING:
@@ -1997,12 +2083,14 @@ sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
         s = sdscat(s,"\"<unknown-lua-type>\"");
         break;
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Higher level wrapper for ldbCatStackValueRec() that just uses an initial
  * recursion level of '0'. */
 sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
+    __A_VARIABLE = 1;
     return ldbCatStackValueRec(s,lua,idx,0);
 }
 
@@ -2013,6 +2101,7 @@ void ldbLogStackValue(lua_State *lua, char *prefix) {
     sds s = sdsnew(prefix);
     s = ldbCatStackValue(s,lua,-1);
     ldbLogWithMaxLen(s);
+    __A_VARIABLE = 1;
 }
 
 char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
@@ -2034,6 +2123,7 @@ char *ldbRedisProtocolToHuman(sds *o, char *reply) {
     case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
     case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
     }
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -2043,6 +2133,7 @@ char *ldbRedisProtocolToHuman(sds *o, char *reply) {
 char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
     char *p = strchr(reply+1,'\r');
     *o = sdscatlen(*o,reply+1,p-reply-1);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -2064,6 +2155,7 @@ char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
     char *p = strchr(reply+1,'\r');
 
     *o = sdscatrepr(*o,reply,p-reply);
+    __A_VARIABLE = 1;
     return p+2;
 }
 
@@ -2076,6 +2168,7 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
     p += 2;
     if (mbulklen == -1) {
         *o = sdscatlen(*o,"NULL",4);
+        __A_VARIABLE = 1;
         return p;
     }
     *o = sdscatlen(*o,"[",1);
@@ -2084,6 +2177,7 @@ char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
         if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
     }
     *o = sdscatlen(*o,"]",1);
+    __A_VARIABLE = 1;
     return p;
 }
 
@@ -2094,6 +2188,7 @@ void ldbLogRedisReply(char *reply) {
     sds log = sdsnew("<reply> ");
     ldbRedisProtocolToHuman(&log,reply);
     ldbLogWithMaxLen(log);
+    __A_VARIABLE = 1;
 }
 
 /* Implements the "print <var>" command of the Lua debugger. It scans for Lua
@@ -2153,6 +2248,7 @@ void ldbPrintAll(lua_State *lua) {
     if (vars == 0) {
         ldbLog(sdsnew("No local variables in the current context."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Implements the break command to list, add and remove breakpoints. */
@@ -2213,6 +2309,7 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
             ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
             lua_pop(lua,1);
             sdsfree(code);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -2223,10 +2320,12 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
     if (lua_pcall(lua,0,1,0)) {
         ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
         lua_pop(lua,1);
+        __A_VARIABLE = 1;
         return;
     }
     ldbLogStackValue(lua,"<retval> ");
     lua_pop(lua,1);
+    __A_VARIABLE = 1;
 }
 
 /* Implement the debugger "redis" command. We use a trick in order to make
@@ -2247,6 +2346,7 @@ void ldbRedis(lua_State *lua, sds *argv, int argc) {
     ldb.step = 0;               /* Disable logging. */
     server.lua_replicate_commands = saved_rc;
     lua_pop(lua,2);             /* Discard the result and clean the stack. */
+    __A_VARIABLE = 1;
 }
 
 /* Implements "trace" command of the Lua debugger. It just prints a backtrace
@@ -2268,6 +2368,7 @@ void ldbTrace(lua_State *lua) {
     if (level == 0) {
         ldbLog(sdsnew("<error> Can't retrieve Lua stack."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Impleemnts the debugger "maxlen" command. It just queries or sets the
@@ -2284,6 +2385,7 @@ void ldbMaxlen(sds *argv, int argc) {
     } else {
         ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));
     }
+    __A_VARIABLE = 1;
 }
 
 /* Read debugging commands from client.
@@ -2304,6 +2406,7 @@ int ldbRepl(lua_State *lua) {
                  * client is no longer connected. */
                 ldb.step = 0;
                 ldb.bpcount = 0;
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
@@ -2401,6 +2504,7 @@ ldbLog(sdsnew("                     in the next line of code."));
 
     /* Free the current command argv if we break inside the while loop. */
     sdsfreesplitres(argv,argc);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
diff --git a/src/sds.c b/src/sds.c
index cd60946..aa10fff 100644
--- a/src/sds.c
+++ b/src/sds.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* SDSLib 2.0 -- A C dynamic strings library
  *
  * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -44,16 +45,22 @@ const char *SDS_NOINIT = "SDS_NOINIT";
 static inline int sdsHdrSize(char type) {
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr5);
         case SDS_TYPE_8:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr8);
         case SDS_TYPE_16:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr16);
         case SDS_TYPE_32:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr32);
         case SDS_TYPE_64:
+            __A_VARIABLE = 1;
             return sizeof(struct sdshdr64);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -101,7 +108,10 @@ sds sdsnewlen(const void *init, size_t initlen) {
         init = NULL;
     else if (!init)
         memset(sh, 0, hdrlen+initlen+1);
-    if (sh == NULL) return NULL;
+    if (sh == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     s = (char*)sh+hdrlen;
     fp = ((unsigned char*)s)-1;
     switch(type) {
@@ -141,30 +151,38 @@ sds sdsnewlen(const void *init, size_t initlen) {
     if (initlen && init)
         memcpy(s, init, initlen);
     s[initlen] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
+    __A_VARIABLE = 1;
     return sdsnewlen("",0);
 }
 
 /* Create a new sds string starting from a null terminated C string. */
 sds sdsnew(const char *init) {
     size_t initlen = (init == NULL) ? 0 : strlen(init);
+    __A_VARIABLE = 1;
     return sdsnewlen(init, initlen);
 }
 
 /* Duplicate an sds string. */
 sds sdsdup(const sds s) {
+    __A_VARIABLE = 1;
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
-    if (s == NULL) return;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     s_free((char*)s-sdsHdrSize(s[-1]));
+    __A_VARIABLE = 1;
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
@@ -184,6 +202,7 @@ void sdsfree(sds s) {
 void sdsupdatelen(sds s) {
     size_t reallen = strlen(s);
     sdssetlen(s, reallen);
+    __A_VARIABLE = 1;
 }
 
 /* Modify an sds string in-place to make it empty (zero length).
@@ -193,6 +212,7 @@ void sdsupdatelen(sds s) {
 void sdsclear(sds s) {
     sdssetlen(s, 0);
     s[0] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
@@ -298,12 +318,14 @@ sds sdsRemoveFreeSpace(sds s) {
  */
 size_t sdsAllocSize(sds s) {
     size_t alloc = sdsalloc(s);
+    __A_VARIABLE = 1;
     return sdsHdrSize(s[-1])+alloc+1;
 }
 
 /* Return the pointer of the actual SDS allocation (normally SDS strings
  * are referenced by the start of the string buffer). */
 void *sdsAllocPtr(sds s) {
+    __A_VARIABLE = 1;
     return (void*) (s-sdsHdrSize(s[-1]));
 }
 
@@ -369,6 +391,7 @@ void sdsIncrLen(sds s, ssize_t incr) {
         default: len = 0; /* Just to avoid compilation warnings. */
     }
     s[len] = '\0';
+    __A_VARIABLE = 1;
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
@@ -379,13 +402,20 @@ void sdsIncrLen(sds s, ssize_t incr) {
 sds sdsgrowzero(sds s, size_t len) {
     size_t curlen = sdslen(s);
 
-    if (len <= curlen) return s;
+    if (len <= curlen) {
+        __A_VARIABLE = 1;
+        return s;
+    }
     s = sdsMakeRoomFor(s,len-curlen);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* Make sure added region doesn't contain garbage */
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -398,10 +428,14 @@ sds sdscatlen(sds s, const void *t, size_t len) {
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
-    if (s == NULL) return NULL;
+    if (s == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     memcpy(s+curlen, t, len);
     sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -410,6 +444,7 @@ sds sdscatlen(sds s, const void *t, size_t len) {
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, strlen(t));
 }
 
@@ -418,6 +453,7 @@ sds sdscat(sds s, const char *t) {
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatsds(sds s, const sds t) {
+    __A_VARIABLE = 1;
     return sdscatlen(s, t, sdslen(t));
 }
 
@@ -426,17 +462,22 @@ sds sdscatsds(sds s, const sds t) {
 sds sdscpylen(sds s, const char *t, size_t len) {
     if (sdsalloc(s) < len) {
         s = sdsMakeRoomFor(s,len-sdslen(s));
-        if (s == NULL) return NULL;
+        if (s == NULL) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
     }
     memcpy(s, t, len);
     s[len] = '\0';
     sdssetlen(s, len);
+    __A_VARIABLE = 1;
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
+    __A_VARIABLE = 1;
     return sdscpylen(s, t, strlen(t));
 }
 
@@ -475,6 +516,7 @@ int sdsll2str(char *s, long long value) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -504,6 +546,7 @@ int sdsull2str(char *s, unsigned long long v) {
         s++;
         p--;
     }
+    __A_VARIABLE = 1;
     return l;
 }
 
@@ -515,6 +558,7 @@ sds sdsfromlonglong(long long value) {
     char buf[SDS_LLSTR_SIZE];
     int len = sdsll2str(buf,value);
 
+    __A_VARIABLE = 1;
     return sdsnewlen(buf,len);
 }
 
@@ -578,6 +622,7 @@ sds sdscatprintf(sds s, const char *fmt, ...) {
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
+    __A_VARIABLE = 1;
     return t;
 }
 
@@ -684,6 +729,7 @@ sds sdscatfmt(sds s, char const *fmt, ...) {
 
     /* Add null-term */
     s[i] = '\0';
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -713,6 +759,7 @@ sds sdstrim(sds s, const char *cset) {
     if (s != sp) memmove(s, sp, len);
     s[len] = '\0';
     sdssetlen(s,len);
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -735,7 +782,10 @@ sds sdstrim(sds s, const char *cset) {
 void sdsrange(sds s, ssize_t start, ssize_t end) {
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return;
+    if (len == 0) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -758,6 +808,7 @@ void sdsrange(sds s, ssize_t start, ssize_t end) {
     if (start && newlen) memmove(s, s+start, newlen);
     s[newlen] = 0;
     sdssetlen(s,newlen);
+    __A_VARIABLE = 1;
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
@@ -765,6 +816,7 @@ void sdstolower(sds s) {
     size_t len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Apply toupper() to every character of the sds string 's'. */
@@ -772,6 +824,7 @@ void sdstoupper(sds s) {
     size_t len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two sds strings s1 and s2 with memcmp().
@@ -793,7 +846,11 @@ int sdscmp(const sds s1, const sds s2) {
     l2 = sdslen(s2);
     minlen = (l1 < l2) ? l1 : l2;
     cmp = memcmp(s1,s2,minlen);
-    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return l1>l2? 1: (l1<l2? -1: 0);
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -818,13 +875,20 @@ sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *c
     long start = 0, j;
     sds *tokens;
 
-    if (seplen < 1 || len < 0) return NULL;
+    if (seplen < 1 || len < 0) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     tokens = s_malloc(sizeof(sds)*slots);
-    if (tokens == NULL) return NULL;
+    if (tokens == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     if (len == 0) {
         *count = 0;
+        __A_VARIABLE = 1;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
@@ -851,6 +915,7 @@ sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *c
     if (tokens[elements] == NULL) goto cleanup;
     elements++;
     *count = elements;
+    __A_VARIABLE = 1;
     return tokens;
 
 cleanup:
@@ -859,16 +924,21 @@ cleanup:
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
         s_free(tokens);
         *count = 0;
+        __A_VARIABLE = 1;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
-    if (!tokens) return;
+    if (!tokens) {
+        __A_VARIABLE = 1;
+        return;
+    }
     while(count--)
         sdsfree(tokens[count]);
     s_free(tokens);
+    __A_VARIABLE = 1;
 }
 
 /* Append to the sds string "s" an escaped string representation where
@@ -899,12 +969,14 @@ sds sdscatrepr(sds s, const char *p, size_t len) {
         }
         p++;
     }
+    __A_VARIABLE = 1;
     return sdscatlen(s,"\"",1);
 }
 
 /* Helper function for sdssplitargs() that returns non zero if 'c'
  * is a valid hex digit. */
 int is_hex_digit(char c) {
+    __A_VARIABLE = 1;
     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
            (c >= 'A' && c <= 'F');
 }
@@ -913,23 +985,40 @@ int is_hex_digit(char c) {
  * integer from 0 to 15 */
 int hex_digit_to_int(char c) {
     switch(c) {
-    case '0': return 0;
-    case '1': return 1;
-    case '2': return 2;
-    case '3': return 3;
-    case '4': return 4;
-    case '5': return 5;
-    case '6': return 6;
-    case '7': return 7;
-    case '8': return 8;
-    case '9': return 9;
-    case 'a': case 'A': return 10;
-    case 'b': case 'B': return 11;
-    case 'c': case 'C': return 12;
-    case 'd': case 'D': return 13;
-    case 'e': case 'E': return 14;
-    case 'f': case 'F': return 15;
-    default: return 0;
+    case '0': __A_VARIABLE = 1;
+        return 0;
+    case '1': __A_VARIABLE = 1;
+        return 1;
+    case '2': __A_VARIABLE = 1;
+        return 2;
+    case '3': __A_VARIABLE = 1;
+        return 3;
+    case '4': __A_VARIABLE = 1;
+        return 4;
+    case '5': __A_VARIABLE = 1;
+        return 5;
+    case '6': __A_VARIABLE = 1;
+        return 6;
+    case '7': __A_VARIABLE = 1;
+        return 7;
+    case '8': __A_VARIABLE = 1;
+        return 8;
+    case '9': __A_VARIABLE = 1;
+        return 9;
+    case 'a': case 'A': __A_VARIABLE = 1;
+        return 10;
+    case 'b': case 'B': __A_VARIABLE = 1;
+        return 11;
+    case 'c': case 'C': __A_VARIABLE = 1;
+        return 12;
+    case 'd': case 'D': __A_VARIABLE = 1;
+        return 13;
+    case 'e': case 'E': __A_VARIABLE = 1;
+        return 14;
+    case 'f': case 'F': __A_VARIABLE = 1;
+        return 15;
+    default: __A_VARIABLE = 1;
+        return 0;
     }
 }
 
@@ -1082,6 +1171,7 @@ sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -1095,6 +1185,7 @@ sds sdsjoin(char **argv, int argc, char *sep) {
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1107,6 +1198,7 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
         join = sdscatsds(join, argv[j]);
         if (j != argc-1) join = sdscatlen(join,sep,seplen);
     }
+    __A_VARIABLE = 1;
     return join;
 }
 
@@ -1115,9 +1207,12 @@ sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
  * the overhead of function calls. Here we define these wrappers only for
  * the programs SDS is linked to, if they want to touch the SDS internals
  * even if they use a different allocator. */
-void *sds_malloc(size_t size) { return s_malloc(size); }
-void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
-void sds_free(void *ptr) { s_free(ptr); }
+void *sds_malloc(size_t size) { __A_VARIABLE = 1;
+	return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) { __A_VARIABLE = 1;
+	return s_realloc(ptr,size); }
+void sds_free(void *ptr) { s_free(ptr); __A_VARIABLE = 1;
+}
 
 #if defined(SDS_TEST_MAIN)
 #include <stdio.h>
@@ -1291,6 +1386,7 @@ int sdsTest(void) {
 
 #ifdef SDS_TEST_MAIN
 int main(void) {
+    __A_VARIABLE = 1;
     return sdsTest();
 }
 #endif
diff --git a/src/sentinel.c b/src/sentinel.c
index adff9d4..ba6f5fe 100644
--- a/src/sentinel.c
+++ b/src/sentinel.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Redis Sentinel implementation
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -280,6 +281,7 @@ static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask)
 
     redisAeEvents *e = (redisAeEvents*)privdata;
     redisAsyncHandleRead(e->context);
+    __A_VARIABLE = 1;
 }
 
 static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
@@ -287,6 +289,7 @@ static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask)
 
     redisAeEvents *e = (redisAeEvents*)privdata;
     redisAsyncHandleWrite(e->context);
+    __A_VARIABLE = 1;
 }
 
 static void redisAeAddRead(void *privdata) {
@@ -296,6 +299,7 @@ static void redisAeAddRead(void *privdata) {
         e->reading = 1;
         aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeDelRead(void *privdata) {
@@ -305,6 +309,7 @@ static void redisAeDelRead(void *privdata) {
         e->reading = 0;
         aeDeleteFileEvent(loop,e->fd,AE_READABLE);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeAddWrite(void *privdata) {
@@ -314,6 +319,7 @@ static void redisAeAddWrite(void *privdata) {
         e->writing = 1;
         aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeDelWrite(void *privdata) {
@@ -323,6 +329,7 @@ static void redisAeDelWrite(void *privdata) {
         e->writing = 0;
         aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);
     }
+    __A_VARIABLE = 1;
 }
 
 static void redisAeCleanup(void *privdata) {
@@ -330,6 +337,7 @@ static void redisAeCleanup(void *privdata) {
     redisAeDelRead(privdata);
     redisAeDelWrite(privdata);
     zfree(e);
+    __A_VARIABLE = 1;
 }
 
 static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
@@ -337,8 +345,10 @@ static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
     redisAeEvents *e;
 
     /* Nothing should be attached when something is already attached */
-    if (ac->ev.data != NULL)
+    if (ac->ev.data != NULL) {
+        __A_VARIABLE = 1;
         return C_ERR;
+    }
 
     /* Create container for context and r/w events */
     e = (redisAeEvents*)zmalloc(sizeof(*e));
@@ -355,6 +365,7 @@ static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
     ac->ev.cleanup = redisAeCleanup;
     ac->ev.data = e;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -395,6 +406,7 @@ void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
 void dictInstancesValDestructor (void *privdata, void *obj) {
     UNUSED(privdata);
     releaseSentinelRedisInstance(obj);
+    __A_VARIABLE = 1;
 }
 
 /* Instance name (sds) -> instance (sentinelRedisInstance pointer)
@@ -461,6 +473,7 @@ struct redisCommand sentinelcmds[] = {
 void initSentinelConfig(void) {
     server.port = REDIS_SENTINEL_PORT;
     server.protected_mode = 0; /* Sentinel must be exposed. */
+    __A_VARIABLE = 1;
 }
 
 /* Perform the Sentinel mode initialization. */
@@ -491,6 +504,7 @@ void initSentinel(void) {
     sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
     sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
     memset(sentinel.myid,0,sizeof(sentinel.myid));
+    __A_VARIABLE = 1;
 }
 
 /* This function gets called when the server is in Sentinel mode, started,
@@ -527,6 +541,7 @@ void sentinelIsRunning(void) {
     /* We want to generate a +monitor event for every configured master
      * at startup. */
     sentinelGenerateInitialMonitorEvents();
+    __A_VARIABLE = 1;
 }
 
 /* ============================== sentinelAddr ============================== */
@@ -542,15 +557,18 @@ sentinelAddr *createSentinelAddr(char *hostname, int port) {
 
     if (port < 0 || port > 65535) {
         errno = EINVAL;
+        __A_VARIABLE = 1;
         return NULL;
     }
     if (anetResolve(NULL,hostname,ip,sizeof(ip)) == ANET_ERR) {
         errno = ENOENT;
+        __A_VARIABLE = 1;
         return NULL;
     }
     sa = zmalloc(sizeof(*sa));
     sa->ip = sdsnew(ip);
     sa->port = port;
+    __A_VARIABLE = 1;
     return sa;
 }
 
@@ -561,6 +579,7 @@ sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
     sa = zmalloc(sizeof(*sa));
     sa->ip = sdsnew(src->ip);
     sa->port = src->port;
+    __A_VARIABLE = 1;
     return sa;
 }
 
@@ -568,10 +587,12 @@ sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
 void releaseSentinelAddr(sentinelAddr *sa) {
     sdsfree(sa->ip);
     zfree(sa);
+    __A_VARIABLE = 1;
 }
 
 /* Return non-zero if two addresses are equal. */
 int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
+    __A_VARIABLE = 1;
     return a->port == b->port && !strcasecmp(a->ip,b->ip);
 }
 
@@ -656,6 +677,7 @@ void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                 type,msg,NULL);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function is called only at startup and is used to generate a
@@ -672,6 +694,7 @@ void sentinelGenerateInitialMonitorEvents(void) {
         sentinelEvent(LL_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* ============================ script execution ============================ */
@@ -683,6 +706,7 @@ void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
     while(sj->argv[j]) sdsfree(sj->argv[j++]);
     zfree(sj->argv);
     zfree(sj);
+    __A_VARIABLE = 1;
 }
 
 #define SENTINEL_SCRIPT_MAX_ARGS 16
@@ -730,6 +754,7 @@ void sentinelScheduleScriptExecution(char *path, ...) {
         serverAssert(listLength(sentinel.scripts_queue) <=
                     SENTINEL_SCRIPT_MAX_QUEUE);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Lookup a script in the scripts queue via pid, and returns the list node
@@ -742,9 +767,12 @@ listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
     while ((ln = listNext(&li)) != NULL) {
         sentinelScriptJob *sj = ln->value;
 
-        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid)
+        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid) {
+            __A_VARIABLE = 1;
             return ln;
+        }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -794,6 +822,7 @@ void sentinelRunPendingScripts(void) {
             sentinelEvent(LL_DEBUG,"+script-child",NULL,"%ld",(long)pid);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* How much to delay the execution of a script that we need to retry after
@@ -807,6 +836,7 @@ mstime_t sentinelScriptRetryDelay(int retry_num) {
     mstime_t delay = SENTINEL_SCRIPT_RETRY_DELAY;
 
     while (retry_num-- > 1) delay *= 2;
+    __A_VARIABLE = 1;
     return delay;
 }
 
@@ -857,6 +887,7 @@ void sentinelCollectTerminatedScripts(void) {
             sentinel.running_scripts--;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Kill scripts in timeout, they'll be collected by the
@@ -878,6 +909,7 @@ void sentinelKillTimedoutScripts(void) {
             kill(sj->pid,SIGKILL);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Implements SENTINEL PENDING-SCRIPTS command. */
@@ -919,6 +951,7 @@ void sentinelPendingScriptsCommand(client *c) {
         addReplyBulkCString(c,"retry-num");
         addReplyBulkLongLong(c,sj->retry_num);
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function calls, if any, the client reconfiguration script with the
@@ -936,13 +969,17 @@ void sentinelPendingScriptsCommand(client *c) {
 void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
     char fromport[32], toport[32];
 
-    if (master->client_reconfig_script == NULL) return;
+    if (master->client_reconfig_script == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ll2string(fromport,sizeof(fromport),from->port);
     ll2string(toport,sizeof(toport),to->port);
     sentinelScheduleScriptExecution(master->client_reconfig_script,
         master->name,
         (role == SENTINEL_LEADER) ? "leader" : "observer",
         state, from->ip, fromport, to->ip, toport, NULL);
+    __A_VARIABLE = 1;
 }
 
 /* =============================== instanceLink ============================= */
@@ -968,12 +1005,16 @@ instanceLink *createInstanceLink(void) {
     link->last_ping_time = 0;
     link->last_avail_time = mstime();
     link->last_pong_time = mstime();
+    __A_VARIABLE = 1;
     return link;
 }
 
 /* Disconnect an hiredis connection in the context of an instance link. */
 void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
-    if (c == NULL) return;
+    if (c == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (link->cc == c) {
         link->cc = NULL;
@@ -983,6 +1024,7 @@ void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
     c->data = NULL;
     link->disconnected = 1;
     redisAsyncFree(c);
+    __A_VARIABLE = 1;
 }
 
 /* Decrement the refcount of a link object, if it drops to zero, actually
@@ -1016,12 +1058,14 @@ instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
                 cb = cb->next;
             }
         }
+        __A_VARIABLE = 1;
         return link; /* Other active users. */
     }
 
     instanceLinkCloseConnection(link,link->cc);
     instanceLinkCloseConnection(link,link->pc);
     zfree(link);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1042,8 +1086,14 @@ int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
     dictIterator *di;
     dictEntry *de;
 
-    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
-    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */
+    if (ri->runid == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* No way to identify it. */
+    if (ri->link->refcount > 1) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    } /* Already shared. */
 
     di = dictGetIterator(sentinel.masters);
     while((de = dictNext(di)) != NULL) {
@@ -1061,9 +1111,11 @@ int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
         releaseInstanceLink(ri->link,NULL);
         ri->link = match->link;
         match->link->refcount++;
+        __A_VARIABLE = 1;
         return C_OK;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return C_ERR;
 }
 
@@ -1106,6 +1158,7 @@ int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
     if (reconfigured)
         sentinelEvent(LL_NOTICE,"+sentinel-address-update", ri,
                     "%@ %d additional matching instances", reconfigured);
+    __A_VARIABLE = 1;
     return reconfigured;
 }
 
@@ -1119,7 +1172,10 @@ void instanceLinkConnectionError(const redisAsyncContext *c) {
     instanceLink *link = c->data;
     int pubsub;
 
-    if (!link) return;
+    if (!link) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     pubsub = (link->pc == c);
     if (pubsub)
@@ -1127,17 +1183,20 @@ void instanceLinkConnectionError(const redisAsyncContext *c) {
     else
         link->cc = NULL;
     link->disconnected = 1;
+    __A_VARIABLE = 1;
 }
 
 /* Hiredis connection established / disconnected callbacks. We need them
  * just to cleanup our link state. */
 void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
     if (status != C_OK) instanceLinkConnectionError(c);
+    __A_VARIABLE = 1;
 }
 
 void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
     UNUSED(status);
     instanceLinkConnectionError(c);
+    __A_VARIABLE = 1;
 }
 
 /* ========================== sentinelRedisInstance ========================= */
@@ -1175,7 +1234,10 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
 
     /* Check address validity. */
     addr = createSentinelAddr(hostname,port);
-    if (addr == NULL) return NULL;
+    if (addr == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     /* For slaves use ip:port as name. */
     if (flags & SRI_SLAVE) {
@@ -1195,6 +1257,7 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
         releaseSentinelAddr(addr);
         sdsfree(sdsname);
         errno = EBUSY;
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -1252,6 +1315,7 @@ sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *
 
     /* Add into the right table. */
     dictAdd(table, ri->name, ri);
+    __A_VARIABLE = 1;
     return ri;
 }
 
@@ -1284,6 +1348,7 @@ void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
         ri->master->promoted_slave = NULL;
 
     zfree(ri);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup a slave in a master Redis instance, by ip and port. */
@@ -1299,6 +1364,7 @@ sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
     key = sdsnew(buf);
     slave = dictFetchValue(ri->slaves,key);
     sdsfree(key);
+    __A_VARIABLE = 1;
     return slave;
 }
 
@@ -1326,7 +1392,10 @@ int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid)
     dictEntry *de;
     int removed = 0;
 
-    if (runid == NULL) return 0;
+    if (runid == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     di = dictGetSafeIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
@@ -1338,6 +1407,7 @@ int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid)
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -1367,6 +1437,7 @@ sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, c
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return instance;
 }
 
@@ -1377,6 +1448,7 @@ sentinelRedisInstance *sentinelGetMasterByName(char *name) {
 
     ri = dictFetchValue(sentinel.masters,sdsname);
     sdsfree(sdsname);
+    __A_VARIABLE = 1;
     return ri;
 }
 
@@ -1391,6 +1463,7 @@ void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {
         ri->flags |= flags;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Remove the specified flags to all the instances in the specified
@@ -1405,6 +1478,7 @@ void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {
         ri->flags &= ~flags;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Reset the state of a monitored master:
@@ -1450,6 +1524,7 @@ void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
     ri->role_reported = SRI_MASTER;
     if (flags & SENTINEL_GENERATE_EVENT)
         sentinelEvent(LL_WARNING,"+reset-master",ri,"%@");
+    __A_VARIABLE = 1;
 }
 
 /* Call sentinelResetMaster() on every master with a name matching the specified
@@ -1471,6 +1546,7 @@ int sentinelResetMastersByPattern(char *pattern, int flags) {
         }
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
     return reset;
 }
 
@@ -1489,7 +1565,10 @@ int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip,
     dictEntry *de;
 
     newaddr = createSentinelAddr(ip,port);
-    if (newaddr == NULL) return C_ERR;
+    if (newaddr == NULL) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Make a list of slaves to add back after the reset.
      * Don't include the one having the address we are switching to. */
@@ -1535,6 +1614,7 @@ int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip,
      * gets the master->addr->ip and master->addr->port as arguments. */
     releaseSentinelAddr(oldaddr);
     sentinelFlushConfig();
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -1546,6 +1626,7 @@ int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
     most_recent = ri->s_down_since_time;
     if (ri->o_down_since_time > most_recent)
         most_recent = ri->o_down_since_time;
+    __A_VARIABLE = 1;
     return most_recent == 0 || (mstime() - most_recent) > ms;
 }
 
@@ -1583,6 +1664,7 @@ void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
@@ -1604,6 +1686,7 @@ char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
     if (ri->master) ri = ri->master;
     char *retval = dictFetchValue(ri->renamed_commands, sc);
     sdsfree(sc);
+    __A_VARIABLE = 1;
     return retval ? retval : command;
 }
 
@@ -1909,6 +1992,7 @@ void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
     }
 
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function uses the config rewriting Redis engine in order to persist
@@ -1931,11 +2015,13 @@ void sentinelFlushConfig(void) {
     if ((fd = open(server.configfile,O_RDONLY)) == -1) goto werr;
     if (fsync(fd) == -1) goto werr;
     if (close(fd) == EOF) goto werr;
+    __A_VARIABLE = 1;
     return;
 
 werr:
     if (fd != -1) close(fd);
     serverLog(LL_WARNING,"WARNING: Sentinel was not able to save the new configuration on disk!!!: %s", strerror(errno));
+    __A_VARIABLE = 1;
 }
 
 /* ====================== hiredis connection handling ======================= */
@@ -1968,6 +2054,7 @@ void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
             sentinelInstanceMapCommand(ri,"AUTH"),
             auth_pass) == C_OK) ri->link->pending_commands++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Use CLIENT SETNAME to name the connection in the Redis instance as
@@ -1987,6 +2074,7 @@ void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char
     {
         ri->link->pending_commands++;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create the async connections for the instance link if the link
@@ -2070,7 +2158,8 @@ void sentinelReconnectInstance(sentinelRedisInstance *ri) {
  * 3) It is not SDOWN or ODOWN.
  * 4) We obtained last INFO no more than two times the INFO period time ago. */
 int sentinelMasterLooksSane(sentinelRedisInstance *master) {
-    return
+    __A_VARIABLE = 1;
+        return
         master->flags & SRI_MASTER &&
         master->role_reported == SRI_MASTER &&
         (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
@@ -2224,7 +2313,10 @@ void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
 
     /* None of the following conditions are processed when in tilt mode, so
      * return asap. */
-    if (sentinel.tilt) return;
+    if (sentinel.tilt) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* Handle master -> slave role switch. */
     if ((ri->flags & SRI_MASTER) && role == SRI_SLAVE) {
@@ -2328,6 +2420,7 @@ void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
             sentinelEvent(LL_NOTICE,"+slave-reconf-done",ri,"%@");
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
@@ -2335,12 +2428,16 @@ void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
     if (r->type == REDIS_REPLY_STRING)
         sentinelRefreshInstanceInfo(ri,r->str);
+    __A_VARIABLE = 1;
 }
 
 /* Just discard the reply. We use this when we are not monitoring the return
@@ -2351,6 +2448,7 @@ void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privd
     UNUSED(privdata);
 
     if (link) link->pending_commands--;
+    __A_VARIABLE = 1;
 }
 
 void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
@@ -2358,7 +2456,10 @@ void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -2391,6 +2492,7 @@ void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata
         }
     }
     link->last_pong_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* This is called when we get the reply about the PUBLISH command we send
@@ -2400,7 +2502,10 @@ void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privd
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -2408,6 +2513,7 @@ void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privd
      * we'll retry again in 100 milliseconds. */
     if (r->type != REDIS_REPLY_ERROR)
         ri->last_pub_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* Process an hello message received via Pub/Sub in master or slave instance,
@@ -2514,6 +2620,7 @@ void sentinelProcessHelloMessage(char *hello, int hello_len) {
 
 cleanup:
     sdsfreesplitres(token,numtokens);
+    __A_VARIABLE = 1;
 }
 
 
@@ -2524,7 +2631,10 @@ void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privd
     redisReply *r;
     UNUSED(c);
 
-    if (!reply || !ri) return;
+    if (!reply || !ri) {
+        __A_VARIABLE = 1;
+        return;
+    }
     r = reply;
 
     /* Update the last activity in the pubsub channel. Note that since we
@@ -2539,12 +2649,19 @@ void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privd
         r->element[0]->type != REDIS_REPLY_STRING ||
         r->element[1]->type != REDIS_REPLY_STRING ||
         r->element[2]->type != REDIS_REPLY_STRING ||
-        strcmp(r->element[0]->str,"message") != 0) return;
+        strcmp(r->element[0]->str,"message") != 0) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     /* We are not interested in meeting ourselves */
-    if (strstr(r->element[2]->str,sentinel.myid) != NULL) return;
+    if (strstr(r->element[2]->str,sentinel.myid) != NULL) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     sentinelProcessHelloMessage(r->element[2]->str, r->element[2]->len);
+    __A_VARIABLE = 1;
 }
 
 /* Send an "Hello" message via Pub/Sub to the specified 'ri' Redis
@@ -2612,6 +2729,7 @@ void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
             ri->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function forces the delivery of an "Hello" message (see
@@ -2623,11 +2741,15 @@ void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
  * Sentinel upgrades a configuration it is a good idea to deliever an update
  * to the other Sentinels ASAP. */
 int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
-    if (!(master->flags & SRI_MASTER)) return C_ERR;
+    if (!(master->flags & SRI_MASTER)) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
     if (master->last_pub_time >= (SENTINEL_PUBLISH_PERIOD+1))
         master->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
     sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
     sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2663,7 +2785,10 @@ void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
 
     /* Return ASAP if we have already a PING or INFO already pending, or
      * in the case the instance is not properly connected. */
-    if (ri->link->disconnected) return;
+    if (ri->link->disconnected) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* For INFO, PING, PUBLISH that are not critical commands to send we
      * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
@@ -2672,7 +2797,10 @@ void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
      * that is, the link will be disconnected and reconnected if a long
      * timeout condition is detected. */
     if (ri->link->pending_commands >=
-        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;
+        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If this is a slave of a master in O_DOWN condition we start sending
      * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
@@ -2718,20 +2846,29 @@ void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
     if ((now - ri->last_pub_time) > SENTINEL_PUBLISH_PERIOD) {
         sentinelSendHello(ri);
     }
+    __A_VARIABLE = 1;
 }
 
 /* =========================== SENTINEL command ============================= */
 
 const char *sentinelFailoverStateStr(int state) {
     switch(state) {
-    case SENTINEL_FAILOVER_STATE_NONE: return "none";
-    case SENTINEL_FAILOVER_STATE_WAIT_START: return "wait_start";
-    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return "select_slave";
-    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return "send_slaveof_noone";
-    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return "wait_promotion";
-    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return "reconf_slaves";
-    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return "update_config";
-    default: return "unknown";
+    case SENTINEL_FAILOVER_STATE_NONE: __A_VARIABLE = 1;
+        return "none";
+    case SENTINEL_FAILOVER_STATE_WAIT_START: __A_VARIABLE = 1;
+        return "wait_start";
+    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: __A_VARIABLE = 1;
+        return "select_slave";
+    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: __A_VARIABLE = 1;
+        return "send_slaveof_noone";
+    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: __A_VARIABLE = 1;
+        return "wait_promotion";
+    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: __A_VARIABLE = 1;
+        return "reconf_slaves";
+    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: __A_VARIABLE = 1;
+        return "update_config";
+    default: __A_VARIABLE = 1;
+        return "unknown";
     }
 }
 
@@ -2923,6 +3060,7 @@ void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
     }
 
     setDeferredMultiBulkLength(c,mbl,fields*2);
+    __A_VARIABLE = 1;
 }
 
 /* Output a number of instances contained inside a dictionary as
@@ -2939,6 +3077,7 @@ void addReplyDictOfRedisInstances(client *c, dict *instances) {
         addReplySentinelRedisInstance(c,ri);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup the named master into sentinel.masters.
@@ -2952,8 +3091,10 @@ sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
     ri = dictFetchValue(sentinel.masters,name->ptr);
     if (!ri) {
         addReplyError(c,"No such master with that name");
+        __A_VARIABLE = 1;
         return NULL;
     }
+    __A_VARIABLE = 1;
     return ri;
 }
 
@@ -2979,6 +3120,7 @@ int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
     if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
     if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
     if (usableptr) *usableptr = usable;
+    __A_VARIABLE = 1;
     return result;
 }
 
@@ -3316,6 +3458,7 @@ numargserr:
 void sentinelInfoCommand(client *c) {
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3374,6 +3517,7 @@ void sentinelInfoCommand(client *c) {
     }
 
     addReplyBulkSds(c, info);
+    __A_VARIABLE = 1;
 }
 
 /* Implements Sentinel version of the ROLE command. The output is
@@ -3393,6 +3537,7 @@ void sentinelRoleCommand(client *c) {
         addReplyBulkCString(c,ri->name);
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* SENTINEL SET <mastername> [<option> <value> ...] */
@@ -3561,10 +3706,12 @@ badfmt: /* Bad format errors */
 void sentinelPublishCommand(client *c) {
     if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
         addReplyError(c, "Only HELLO messages are accepted by Sentinel instances.");
+        __A_VARIABLE = 1;
         return;
     }
     sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
     addReplyLongLong(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* ===================== SENTINEL availability checks ======================= */
@@ -3634,6 +3781,7 @@ void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
             ri->flags &= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Is this instance down according to the configured quorum?
@@ -3675,6 +3823,7 @@ void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
             master->flags &= ~SRI_O_DOWN;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Receive the SENTINEL is-master-down-by-addr reply, see the
@@ -3684,7 +3833,10 @@ void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *p
     instanceLink *link = c->data;
     redisReply *r;
 
-    if (!reply || !link) return;
+    if (!reply || !link) {
+        __A_VARIABLE = 1;
+        return;
+    }
     link->pending_commands--;
     r = reply;
 
@@ -3715,6 +3867,7 @@ void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *p
             ri->leader_epoch = r->element[2]->integer;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* If we think the master is down, we start sending
@@ -3764,6 +3917,7 @@ void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int f
         if (retval == C_OK) ri->link->pending_commands++;
     }
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* =============================== FAILOVER ================================= */
@@ -3773,6 +3927,7 @@ void sentinelSimFailureCrash(void) {
     serverLog(LL_WARNING,
         "Sentinel CRASH because of SENTINEL simulate-failure");
     exit(99);
+    __A_VARIABLE = 1;
 }
 
 /* Vote for the sentinel with 'req_runid' or return the old vote if already
@@ -3804,6 +3959,7 @@ char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char
     }
 
     *leader_epoch = master->leader_epoch;
+    __A_VARIABLE = 1;
     return master->leader ? sdsnew(master->leader) : NULL;
 }
 
@@ -3898,6 +4054,7 @@ char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
     winner = winner ? sdsnew(winner) : NULL;
     sdsfree(myvote);
     dictRelease(counters);
+    __A_VARIABLE = 1;
     return winner;
 }
 
@@ -3937,20 +4094,29 @@ int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s",
         sentinelInstanceMapCommand(ri,"MULTI"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s %s %s",
         sentinelInstanceMapCommand(ri,"SLAVEOF"),
         host, portstr);
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s REWRITE",
         sentinelInstanceMapCommand(ri,"CONFIG"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     /* CLIENT KILL TYPE <type> is only supported starting from Redis 2.8.12,
@@ -3961,15 +4127,22 @@ int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s KILL TYPE normal",
         sentinelInstanceMapCommand(ri,"CLIENT"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
     retval = redisAsyncCommand(ri->link->cc,
         sentinelDiscardReplyCallback, ri, "%s",
         sentinelInstanceMapCommand(ri,"EXEC"));
-    if (retval == C_ERR) return retval;
+    if (retval == C_ERR) {
+        __A_VARIABLE = 1;
+        return retval;
+    }
     ri->link->pending_commands++;
 
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -3985,6 +4158,7 @@ void sentinelStartFailover(sentinelRedisInstance *master) {
     sentinelEvent(LL_WARNING,"+try-failover",master,"%@");
     master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
     master->failover_state_change_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* This function checks if there are the conditions to start the failover,
@@ -4000,10 +4174,16 @@ void sentinelStartFailover(sentinelRedisInstance *master) {
  * Return non-zero if a failover was started. */
 int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
     /* We can't failover if the master is not in O_DOWN state. */
-    if (!(master->flags & SRI_O_DOWN)) return 0;
+    if (!(master->flags & SRI_O_DOWN)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Failover already in progress? */
-    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;
+    if (master->flags & SRI_FAILOVER_IN_PROGRESS) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Last failover attempt started too little time ago? */
     if (mstime() - master->failover_start_time <
@@ -4021,10 +4201,12 @@ int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
                 "Next failover delay: I will not start a failover before %s",
                 ctimebuf);
         }
+        __A_VARIABLE = 1;
         return 0;
     }
 
     sentinelStartFailover(master);
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -4129,6 +4311,7 @@ sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
         selected = instance[0];
     }
     zfree(instance);
+    __A_VARIABLE = 1;
     return selected;
 }
 
@@ -4156,6 +4339,7 @@ void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
             sentinelEvent(LL_WARNING,"-failover-abort-not-elected",ri,"%@");
             sentinelAbortFailover(ri);
         }
+        __A_VARIABLE = 1;
         return;
     }
     sentinelEvent(LL_WARNING,"+elected-leader",ri,"%@");
@@ -4164,6 +4348,7 @@ void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
     ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
     ri->failover_state_change_time = mstime();
     sentinelEvent(LL_WARNING,"+failover-state-select-slave",ri,"%@");
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
@@ -4183,6 +4368,7 @@ void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
         sentinelEvent(LL_NOTICE,"+failover-state-send-slaveof-noone",
             slave, "%@");
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
@@ -4196,6 +4382,7 @@ void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
             sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
             sentinelAbortFailover(ri);
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -4204,11 +4391,15 @@ void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
      * really care about the reply. We check if it worked indirectly observing
      * if INFO returns a different role (master instead of slave). */
     retval = sentinelSendSlaveOf(ri->promoted_slave,NULL,0);
-    if (retval != C_OK) return;
+    if (retval != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     sentinelEvent(LL_NOTICE, "+failover-state-wait-promotion",
         ri->promoted_slave,"%@");
     ri->failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
     ri->failover_state_change_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 /* We actually wait for promotion indirectly checking with INFO when the
@@ -4220,6 +4411,7 @@ void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
         sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
         sentinelAbortFailover(ri);
     }
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
@@ -4231,7 +4423,10 @@ void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
     /* We can't consider failover finished if the promoted slave is
      * not reachable. */
     if (master->promoted_slave == NULL ||
-        master->promoted_slave->flags & SRI_S_DOWN) return;
+        master->promoted_slave->flags & SRI_S_DOWN) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* The failover terminates once all the reachable slaves are properly
      * configured. */
@@ -4283,6 +4478,7 @@ void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
         }
         dictReleaseIterator(di);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Send SLAVE OF <new master address> to all the remaining slaves that
@@ -4344,6 +4540,7 @@ void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
 
     /* Check if all the slaves are reconfigured and handle timeout. */
     sentinelFailoverDetectEnd(master);
+    __A_VARIABLE = 1;
 }
 
 /* This function is called when the slave is in
@@ -4358,12 +4555,16 @@ void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
         ref->addr->ip, ref->addr->port);
 
     sentinelResetMasterAndChangeAddress(master,ref->addr->ip,ref->addr->port);
+    __A_VARIABLE = 1;
 }
 
 void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
     serverAssert(ri->flags & SRI_MASTER);
 
-    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;
+    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) {
+            __A_VARIABLE = 1;
+            return;
+    }
 
     switch(ri->failover_state) {
         case SENTINEL_FAILOVER_STATE_WAIT_START:
@@ -4382,6 +4583,7 @@ void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
             sentinelFailoverReconfNextSlave(ri);
             break;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Abort a failover in progress:
@@ -4400,6 +4602,7 @@ void sentinelAbortFailover(sentinelRedisInstance *ri) {
         ri->promoted_slave->flags &= ~SRI_PROMOTED;
         ri->promoted_slave = NULL;
     }
+    __A_VARIABLE = 1;
 }
 
 /* ======================== SENTINEL timer handler ==========================
@@ -4419,7 +4622,10 @@ void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
      * TILT happens when we find something odd with the time, like a
      * sudden change in the clock. */
     if (sentinel.tilt) {
-        if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) return;
+        if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) {
+            __A_VARIABLE = 1;
+            return;
+        }
         sentinel.tilt = 0;
         sentinelEvent(LL_WARNING,"-tilt",NULL,"#tilt mode exited");
     }
@@ -4440,6 +4646,7 @@ void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
         sentinelFailoverStateMachine(ri);
         sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Perform scheduled operations for all the instances in the dictionary.
@@ -4466,6 +4673,7 @@ void sentinelHandleDictOfRedisInstances(dict *instances) {
     if (switch_to_promoted)
         sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
     dictReleaseIterator(di);
+    __A_VARIABLE = 1;
 }
 
 /* This function checks if we need to enter the TITL mode.
@@ -4497,6 +4705,7 @@ void sentinelCheckTiltCondition(void) {
         sentinelEvent(LL_WARNING,"+tilt",NULL,"#tilt mode entered");
     }
     sentinel.previous_time = mstime();
+    __A_VARIABLE = 1;
 }
 
 void sentinelTimer(void) {
@@ -4513,5 +4722,6 @@ void sentinelTimer(void) {
      * same time again and again (resulting in nobody likely winning the
      * election because of split brain voting). */
     server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
+    __A_VARIABLE = 1;
 }
 
diff --git a/src/server.c b/src/server.c
index ecc7325..4665dd5 100644
--- a/src/server.c
+++ b/src/server.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -70,6 +71,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -363,10 +365,16 @@ void serverLogRaw(int level, const char *msg) {
     int log_to_stdout = server.logfile[0] == '\0';
 
     level &= 0xff; /* clear flags */
-    if (level < server.verbosity) return;
+    if (level < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     fp = log_to_stdout ? stdout : fopen(server.logfile,"a");
-    if (!fp) return;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (rawmode) {
         fprintf(fp,"%s",msg);
@@ -395,6 +403,7 @@ void serverLogRaw(int level, const char *msg) {
 
     if (!log_to_stdout) fclose(fp);
     if (server.syslog_enabled) syslog(syslogLevelMap[level], "%s", msg);
+    __A_VARIABLE = 1;
 }
 
 /* Like serverLogRaw() but with printf-alike support. This is the function that
@@ -404,13 +413,17 @@ void serverLog(int level, const char *fmt, ...) {
     va_list ap;
     char msg[LOG_MAX_LEN];
 
-    if ((level&0xff) < server.verbosity) return;
+    if ((level&0xff) < server.verbosity) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     va_start(ap, fmt);
     vsnprintf(msg, sizeof(msg), fmt, ap);
     va_end(ap);
 
     serverLogRaw(level,msg);
+    __A_VARIABLE = 1;
 }
 
 /* Log a fixed message without printf-alike capabilities, in a way that is
@@ -424,11 +437,16 @@ void serverLogFromHandler(int level, const char *msg) {
     int log_to_stdout = server.logfile[0] == '\0';
     char buf[64];
 
-    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
+    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize)) {
+        __A_VARIABLE = 1;
         return;
+    }
     fd = log_to_stdout ? STDOUT_FILENO :
                          open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
-    if (fd == -1) return;
+    if (fd == -1) {
+        __A_VARIABLE = 1;
+        return;
+    }
     ll2string(buf,sizeof(buf),getpid());
     if (write(fd,buf,strlen(buf)) == -1) goto err;
     if (write(fd,":signal-handler (",17) == -1) goto err;
@@ -439,6 +457,7 @@ void serverLogFromHandler(int level, const char *msg) {
     if (write(fd,"\n",1) == -1) goto err;
 err:
     if (!log_to_stdout) close(fd);
+    __A_VARIABLE = 1;
 }
 
 /* Return the UNIX time in microseconds */
@@ -449,11 +468,13 @@ long long ustime(void) {
     gettimeofday(&tv, NULL);
     ust = ((long long)tv.tv_sec)*1000000;
     ust += tv.tv_usec;
+    __A_VARIABLE = 1;
     return ust;
 }
 
 /* Return the UNIX time in milliseconds */
 mstime_t mstime(void) {
+    __A_VARIABLE = 1;
     return ustime()/1000;
 }
 
@@ -467,6 +488,7 @@ void exitFromChild(int retcode) {
 #else
     _exit(retcode);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /*====================== Hash table type implementation  ==================== */
@@ -479,12 +501,14 @@ void dictVanillaFree(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
     zfree(val);
+    __A_VARIABLE = 1;
 }
 
 void dictListDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
     listRelease((list*)val);
+    __A_VARIABLE = 1;
 }
 
 int dictSdsKeyCompare(void *privdata, const void *key1,
@@ -495,7 +519,11 @@ int dictSdsKeyCompare(void *privdata, const void *key1,
 
     l1 = sdslen((sds)key1);
     l2 = sdslen((sds)key2);
-    if (l1 != l2) return 0;
+    if (l1 != l2) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return memcmp(key1, key2, l1) == 0;
 }
 
@@ -506,6 +534,7 @@ int dictSdsKeyCaseCompare(void *privdata, const void *key1,
 {
     DICT_NOTUSED(privdata);
 
+    __A_VARIABLE = 1;
     return strcasecmp(key1, key2) == 0;
 }
 
@@ -513,8 +542,12 @@ void dictObjectDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
 
-    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
+    if (val == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Lazy freeing will set value to NULL. */
     decrRefCount(val);
+    __A_VARIABLE = 1;
 }
 
 void dictSdsDestructor(void *privdata, void *val)
@@ -522,25 +555,30 @@ void dictSdsDestructor(void *privdata, void *val)
     DICT_NOTUSED(privdata);
 
     sdsfree(val);
+    __A_VARIABLE = 1;
 }
 
 int dictObjKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
     const robj *o1 = key1, *o2 = key2;
+    __A_VARIABLE = 1;
     return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
 }
 
 uint64_t dictObjHash(const void *key) {
     const robj *o = key;
+    __A_VARIABLE = 1;
     return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
 }
 
 uint64_t dictSdsHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 uint64_t dictSdsCaseHash(const void *key) {
+    __A_VARIABLE = 1;
     return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
@@ -551,14 +589,17 @@ int dictEncObjKeyCompare(void *privdata, const void *key1,
     int cmp;
 
     if (o1->encoding == OBJ_ENCODING_INT &&
-        o2->encoding == OBJ_ENCODING_INT)
+        o2->encoding == OBJ_ENCODING_INT) {
+            __A_VARIABLE = 1;
             return o1->ptr == o2->ptr;
+    }
 
     o1 = getDecodedObject(o1);
     o2 = getDecodedObject(o2);
     cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
     decrRefCount(o1);
     decrRefCount(o2);
+    __A_VARIABLE = 1;
     return cmp;
 }
 
@@ -751,6 +792,7 @@ int htNeedsResize(dict *dict) {
 
     size = dictSlots(dict);
     used = dictSize(dict);
+    __A_VARIABLE = 1;
     return (size > DICT_HT_INITIAL_SIZE &&
             (used*100/size < HASHTABLE_MIN_FILL));
 }
@@ -762,6 +804,7 @@ void tryResizeHashTables(int dbid) {
         dictResize(server.db[dbid].dict);
     if (htNeedsResize(server.db[dbid].expires))
         dictResize(server.db[dbid].expires);
+    __A_VARIABLE = 1;
 }
 
 /* Our hash table implementation performs rehashing incrementally while
@@ -775,13 +818,16 @@ int incrementallyRehash(int dbid) {
     /* Keys dictionary */
     if (dictIsRehashing(server.db[dbid].dict)) {
         dictRehashMilliseconds(server.db[dbid].dict,1);
+        __A_VARIABLE = 1;
         return 1; /* already used our millisecond for this loop... */
     }
     /* Expires */
     if (dictIsRehashing(server.db[dbid].expires)) {
         dictRehashMilliseconds(server.db[dbid].expires,1);
+        __A_VARIABLE = 1;
         return 1; /* already used our millisecond for this loop... */
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -796,6 +842,7 @@ void updateDictResizePolicy(void) {
         dictEnableResize();
     else
         dictDisableResize();
+    __A_VARIABLE = 1;
 }
 
 /* ======================= Cron: called every 100 ms ======================== */
@@ -815,6 +862,7 @@ void trackInstantaneousMetric(int metric, long long current_reading) {
     server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
     server.inst_metric[metric].last_sample_time = mstime();
     server.inst_metric[metric].last_sample_count = current_reading;
+    __A_VARIABLE = 1;
 }
 
 /* Return the mean of all the samples. */
@@ -824,6 +872,7 @@ long long getInstantaneousMetric(int metric) {
 
     for (j = 0; j < STATS_METRIC_SAMPLES; j++)
         sum += server.inst_metric[metric].samples[j];
+    __A_VARIABLE = 1;
     return sum / STATS_METRIC_SAMPLES;
 }
 
@@ -904,6 +953,7 @@ int clientsCronResizeQueryBuffer(client *c) {
             c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -947,6 +997,7 @@ int clientsCronTrackExpansiveClients(client *c) {
     if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;
     if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;
 
+    __A_VARIABLE = 1;
     return 0; /* This function never terminates the client. */
 }
 
@@ -960,6 +1011,7 @@ void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
     }
     *in_usage = i;
     *out_usage = o;
+    __A_VARIABLE = 1;
 }
 
 /* This function is called by serverCron() and is used in order to perform
@@ -1011,6 +1063,7 @@ void clientsCron(void) {
         if (clientsCronResizeQueryBuffer(c)) continue;
         if (clientsCronTrackExpansiveClients(c)) continue;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This function handles 'background' operations we are required to do
@@ -1068,6 +1121,7 @@ void databasesCron(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* We take a cached value of the unix time in the global state because with
@@ -1086,6 +1140,7 @@ void updateCachedTime(void) {
     struct tm tm;
     localtime_r(&server.unixtime,&tm);
     server.daylight_active = tm.tm_isdst;
+    __A_VARIABLE = 1;
 }
 
 /* This is our timer interrupt, called server.hz times per second.
@@ -1428,6 +1483,7 @@ void beforeSleep(struct aeEventLoop *eventLoop) {
      * releasing the GIL. Redis main thread will not touch anything at this
      * time. */
     if (moduleCount()) moduleReleaseGIL();
+    __A_VARIABLE = 1;
 }
 
 /* This function is called immadiately after the event loop multiplexing
@@ -1436,6 +1492,7 @@ void beforeSleep(struct aeEventLoop *eventLoop) {
 void afterSleep(struct aeEventLoop *eventLoop) {
     UNUSED(eventLoop);
     if (moduleCount()) moduleAcquireGIL();
+    __A_VARIABLE = 1;
 }
 
 /* =========================== Server initialization ======================== */
@@ -1533,6 +1590,7 @@ void createSharedObjects(void) {
      * string in string comparisons for the ZRANGEBYLEX command. */
     shared.minstring = sdsnew("minstring");
     shared.maxstring = sdsnew("maxstring");
+    __A_VARIABLE = 1;
 }
 
 void initServerConfig(void) {
@@ -1745,6 +1803,7 @@ void initServerConfig(void) {
      * script to the slave / AOF. This is the new way starting from
      * Redis 5. However it is possible to revert it via redis.conf. */
     server.lua_always_replicate_commands = 1;
+    __A_VARIABLE = 1;
 }
 
 extern char **environ;
@@ -1772,6 +1831,7 @@ int restartServer(int flags, mstime_t delay) {
     if (access(server.executable,X_OK) == -1) {
         serverLog(LL_WARNING,"Can't restart: this process has no "
                              "permissions to execute %s", server.executable);
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1782,6 +1842,7 @@ int restartServer(int flags, mstime_t delay) {
     {
         serverLog(LL_WARNING,"Can't restart: configuration rewrite process "
                              "failed");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1790,6 +1851,7 @@ int restartServer(int flags, mstime_t delay) {
         prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)
     {
         serverLog(LL_WARNING,"Can't restart: error preparing for shutdown");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 
@@ -1810,6 +1872,7 @@ int restartServer(int flags, mstime_t delay) {
     /* If an error occurred here, there is nothing we can do, but exit. */
     _exit(1);
 
+    __A_VARIABLE = 1;
     return C_ERR; /* Never reached. */
 }
 
@@ -1894,6 +1957,7 @@ void adjustOpenFilesLimit(void) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Check that server.tcp_backlog can be actually enforced in Linux according
@@ -1986,11 +2050,13 @@ int listenToPort(int port, int *fds, int *count) {
                     errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||
                     errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)
                     continue;
+            __A_VARIABLE = 1;
             return C_ERR;
         }
         anetNonBlock(NULL,fds[*count]);
         (*count)++;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2029,6 +2095,7 @@ void resetServerStats(void) {
     server.stat_net_input_bytes = 0;
     server.stat_net_output_bytes = 0;
     server.aof_delayed_fsync = 0;
+    __A_VARIABLE = 1;
 }
 
 void initServer(void) {
@@ -2200,6 +2267,7 @@ void initServer(void) {
     latencyMonitorInit();
     bioInit();
     server.initial_memory_usage = zmalloc_used_memory();
+    __A_VARIABLE = 1;
 }
 
 /* Populates the Redis Command Table starting from the hard coded list
@@ -2239,6 +2307,7 @@ void populateCommandTable(void) {
         retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);
         serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
     }
+    __A_VARIABLE = 1;
 }
 
 void resetCommandTableStats(void) {
@@ -2254,6 +2323,7 @@ void resetCommandTableStats(void) {
     }
     dictReleaseIterator(di);
 
+    __A_VARIABLE = 1;
 }
 
 /* ========================== Redis OP Array API ============================ */
@@ -2261,6 +2331,7 @@ void resetCommandTableStats(void) {
 void redisOpArrayInit(redisOpArray *oa) {
     oa->ops = NULL;
     oa->numops = 0;
+    __A_VARIABLE = 1;
 }
 
 int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
@@ -2276,6 +2347,7 @@ int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
     op->argc = argc;
     op->target = target;
     oa->numops++;
+    __A_VARIABLE = 1;
     return oa->numops;
 }
 
@@ -2291,11 +2363,13 @@ void redisOpArrayFree(redisOpArray *oa) {
         zfree(op->argv);
     }
     zfree(oa->ops);
+    __A_VARIABLE = 1;
 }
 
 /* ====================== Commands lookup and execution ===================== */
 
 struct redisCommand *lookupCommand(sds name) {
+    __A_VARIABLE = 1;
     return dictFetchValue(server.commands, name);
 }
 
@@ -2305,6 +2379,7 @@ struct redisCommand *lookupCommandByCString(char *s) {
 
     cmd = dictFetchValue(server.commands, name);
     sdsfree(name);
+    __A_VARIABLE = 1;
     return cmd;
 }
 
@@ -2319,6 +2394,7 @@ struct redisCommand *lookupCommandOrOriginal(sds name) {
     struct redisCommand *cmd = dictFetchValue(server.commands, name);
 
     if (!cmd) cmd = dictFetchValue(server.orig_commands,name);
+    __A_VARIABLE = 1;
     return cmd;
 }
 
@@ -2340,6 +2416,7 @@ void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
         feedAppendOnlyFile(cmd,dbid,argv,argc);
     if (flags & PROPAGATE_REPL)
         replicationFeedSlaves(server.slaves,dbid,argv,argc);
+    __A_VARIABLE = 1;
 }
 
 /* Used inside commands to schedule the propagation of additional commands
@@ -2360,7 +2437,10 @@ void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
     robj **argvcopy;
     int j;
 
-    if (server.loading) return; /* No propagation during loading. */
+    if (server.loading) {
+        __A_VARIABLE = 1;
+        return;
+    } /* No propagation during loading. */
 
     argvcopy = zmalloc(sizeof(robj*)*argc);
     for (j = 0; j < argc; j++) {
@@ -2368,6 +2448,7 @@ void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
         incrRefCount(argv[j]);
     }
     redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);
+    __A_VARIABLE = 1;
 }
 
 /* It is possible to call the function forceCommandPropagation() inside a
@@ -2376,6 +2457,7 @@ void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
 void forceCommandPropagation(client *c, int flags) {
     if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
     if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
+    __A_VARIABLE = 1;
 }
 
 /* Avoid that the executed command is propagated at all. This way we
@@ -2383,16 +2465,19 @@ void forceCommandPropagation(client *c, int flags) {
  * API. */
 void preventCommandPropagation(client *c) {
     c->flags |= CLIENT_PREVENT_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* AOF specific version of preventCommandPropagation(). */
 void preventCommandAOF(client *c) {
     c->flags |= CLIENT_PREVENT_AOF_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* Replication specific version of preventCommandPropagation(). */
 void preventCommandReplication(client *c) {
     c->flags |= CLIENT_PREVENT_REPL_PROP;
+    __A_VARIABLE = 1;
 }
 
 /* Call() is the core of Redis execution of a command.
@@ -2551,6 +2636,7 @@ void call(client *c, int flags) {
     }
     server.also_propagate = prev_also_propagate;
     server.stat_numcommands++;
+    __A_VARIABLE = 1;
 }
 
 /* If this function gets called we already read a whole
@@ -2772,6 +2858,7 @@ void closeListeningSockets(int unlink_unix_socket) {
         serverLog(LL_NOTICE,"Removing the unix socket file.");
         unlink(server.unixsocket); /* don't care if this fails */
     }
+    __A_VARIABLE = 1;
 }
 
 int prepareForShutdown(int flags) {
@@ -2800,6 +2887,7 @@ int prepareForShutdown(int flags) {
              * shutdown or else the dataset will be lost. */
             if (server.aof_state == AOF_WAIT_REWRITE) {
                 serverLog(LL_WARNING, "Writing initial AOF, can't exit.");
+                __A_VARIABLE = 1;
                 return C_ERR;
             }
             serverLog(LL_WARNING,
@@ -2825,6 +2913,7 @@ int prepareForShutdown(int flags) {
              * saving aborted, handling special stuff like slaves pending for
              * synchronization... */
             serverLog(LL_WARNING,"Error trying to save the DB, can't exit.");
+            __A_VARIABLE = 1;
             return C_ERR;
         }
     }
@@ -2843,6 +2932,7 @@ int prepareForShutdown(int flags) {
     closeListeningSockets(1);
     serverLog(LL_WARNING,"%s is now ready to exit, bye bye...",
         server.sentinel_mode ? "Sentinel" : "Redis");
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -2897,7 +2987,10 @@ int time_independent_strcmp(char *a, char *b) {
     /* We can't compare strings longer than our static buffers.
      * Note that this will never pass the first test in practical circumstances
      * so there is no info leak. */
-    if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;
+    if (alen > sizeof(bufa) || blen > sizeof(bufb)) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
 
     memset(bufa,0,sizeof(bufa));        /* Constant time. */
     memset(bufb,0,sizeof(bufb));        /* Constant time. */
@@ -2913,6 +3006,7 @@ int time_independent_strcmp(char *a, char *b) {
     }
     /* Length must be equal as well. */
     diff |= alen ^ blen;
+    __A_VARIABLE = 1;
     return diff; /* If zero strings are the same. */
 }
 
@@ -2926,6 +3020,7 @@ void authCommand(client *c) {
       c->authenticated = 0;
       addReplyError(c,"invalid password");
     }
+    __A_VARIABLE = 1;
 }
 
 /* The PING command. It works in a different way if the client is in
@@ -2935,6 +3030,7 @@ void pingCommand(client *c) {
     if (c->argc > 2) {
         addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
             c->cmd->name);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -2951,10 +3047,12 @@ void pingCommand(client *c) {
         else
             addReplyBulk(c,c->argv[1]);
     }
+    __A_VARIABLE = 1;
 }
 
 void echoCommand(client *c) {
     addReplyBulk(c,c->argv[1]);
+    __A_VARIABLE = 1;
 }
 
 void timeCommand(client *c) {
@@ -2966,14 +3064,17 @@ void timeCommand(client *c) {
     addReplyMultiBulkLen(c,2);
     addReplyBulkLongLong(c,tv.tv_sec);
     addReplyBulkLongLong(c,tv.tv_usec);
+    __A_VARIABLE = 1;
 }
 
 /* Helper function for addReplyCommand() to output flags. */
 int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {
     if (cmd->flags & f) {
         addReplyStatus(c, reply);
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -3014,6 +3115,7 @@ void addReplyCommand(client *c, struct redisCommand *cmd) {
         addReplyLongLong(c, cmd->lastkey);
         addReplyLongLong(c, cmd->keystep);
     }
+    __A_VARIABLE = 1;
 }
 
 /* COMMAND <subcommand> <args> */
@@ -3102,6 +3204,7 @@ static void bytesToHuman(char *s, unsigned long long n) {
         /* Let's hope we never need this */
         sprintf(s,"%lluB",n);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create the string returned by the INFO command. This is decoupled
@@ -3660,6 +3763,7 @@ sds genRedisInfoString(char *section) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return info;
 }
 
@@ -3668,18 +3772,24 @@ void infoCommand(client *c) {
 
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     addReplyBulkSds(c, genRedisInfoString(section));
+    __A_VARIABLE = 1;
 }
 
 void monitorCommand(client *c) {
     /* ignore MONITOR if already slave or in monitor mode */
-    if (c->flags & CLIENT_SLAVE) return;
+    if (c->flags & CLIENT_SLAVE) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
     listAddNodeTail(server.monitors,c);
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* =================================== Main! ================================ */
@@ -3689,13 +3799,18 @@ int linuxOvercommitMemoryValue(void) {
     FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
     char buf[64];
 
-    if (!fp) return -1;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
     if (fgets(buf,64,fp) == NULL) {
         fclose(fp);
+        __A_VARIABLE = 1;
         return -1;
     }
     fclose(fp);
 
+    __A_VARIABLE = 1;
     return atoi(buf);
 }
 
@@ -3706,6 +3821,7 @@ void linuxMemoryWarnings(void) {
     if (THPIsEnabled()) {
         serverLog(LL_WARNING,"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.");
     }
+    __A_VARIABLE = 1;
 }
 #endif /* __linux__ */
 
@@ -3720,6 +3836,7 @@ void createPidFile(void) {
         fprintf(fp,"%d\n",(int)getpid());
         fclose(fp);
     }
+    __A_VARIABLE = 1;
 }
 
 void daemonize(void) {
@@ -3737,6 +3854,7 @@ void daemonize(void) {
         dup2(fd, STDERR_FILENO);
         if (fd > STDERR_FILENO) close(fd);
     }
+    __A_VARIABLE = 1;
 }
 
 void version(void) {
@@ -3748,6 +3866,7 @@ void version(void) {
         sizeof(long) == 4 ? 32 : 64,
         (unsigned long long) redisBuildId());
     exit(0);
+    __A_VARIABLE = 1;
 }
 
 void usage(void) {
@@ -3765,6 +3884,7 @@ void usage(void) {
     fprintf(stderr,"Sentinel mode:\n");
     fprintf(stderr,"       ./redis-server /etc/sentinel.conf --sentinel\n");
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 void redisAsciiArt(void) {
@@ -3801,6 +3921,7 @@ void redisAsciiArt(void) {
         serverLogRaw(LL_NOTICE|LL_RAW,buf);
     }
     zfree(buf);
+    __A_VARIABLE = 1;
 }
 
 static void sigShutdownHandler(int sig) {
@@ -3832,6 +3953,7 @@ static void sigShutdownHandler(int sig) {
 
     serverLogFromHandler(LL_WARNING, msg);
     server.shutdown_asap = 1;
+    __A_VARIABLE = 1;
 }
 
 void setupSignalHandlers(void) {
@@ -3854,6 +3976,7 @@ void setupSignalHandlers(void) {
     sigaction(SIGFPE, &act, NULL);
     sigaction(SIGILL, &act, NULL);
 #endif
+    __A_VARIABLE = 1;
     return;
 }
 
@@ -3864,9 +3987,16 @@ void memtest(size_t megabytes, int passes);
 int checkForSentinelMode(int argc, char **argv) {
     int j;
 
-    if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
+    if (strstr(argv[0],"redis-sentinel") != NULL) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
     for (j = 1; j < argc; j++)
-        if (!strcmp(argv[j],"--sentinel")) return 1;
+        if (!strcmp(argv[j],"--sentinel")) {
+            __A_VARIABLE = 1;
+            return 1;
+        }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -3904,12 +4034,14 @@ void loadDataFromDisk(void) {
             exit(1);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void redisOutOfMemoryHandler(size_t allocation_size) {
     serverLog(LL_WARNING,"Out Of Memory allocating %zu bytes!",
         allocation_size);
     serverPanic("Redis aborting for OUT OF MEMORY");
+    __A_VARIABLE = 1;
 }
 
 void redisSetProcTitle(char *title) {
@@ -3926,6 +4058,7 @@ void redisSetProcTitle(char *title) {
 #else
     UNUSED(title);
 #endif
+    __A_VARIABLE = 1;
 }
 
 /*
@@ -3938,12 +4071,14 @@ int redisSupervisedUpstart(void) {
     if (!upstart_job) {
         serverLog(LL_WARNING,
                 "upstart supervision requested, but UPSTART_JOB not found");
+        __A_VARIABLE = 1;
         return 0;
     }
 
     serverLog(LL_NOTICE, "supervised by upstart, will stop to signal readiness");
     raise(SIGSTOP);
     unsetenv("UPSTART_JOB");
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -3958,10 +4093,12 @@ int redisSupervisedSystemd(void) {
     if (!notify_socket) {
         serverLog(LL_WARNING,
                 "systemd supervision requested, but NOTIFY_SOCKET not found");
+        __A_VARIABLE = 1;
         return 0;
     }
 
     if ((strchr("@/", notify_socket[0])) == NULL || strlen(notify_socket) < 2) {
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -3969,6 +4106,7 @@ int redisSupervisedSystemd(void) {
     if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
         serverLog(LL_WARNING,
                 "Can't connect to systemd socket %s", notify_socket);
+        __A_VARIABLE = 1;
         return 0;
     }
 
@@ -4000,9 +4138,11 @@ int redisSupervisedSystemd(void) {
     if (ret < 0) {
         serverLog(LL_WARNING, "Can't send notification to systemd");
         close(fd);
+        __A_VARIABLE = 1;
         return 0;
     }
     close(fd);
+    __A_VARIABLE = 1;
     return 1;
 }
 
diff --git a/src/setproctitle.c b/src/setproctitle.c
index 5f91d7b..1cd75e4 100644
--- a/src/setproctitle.c
+++ b/src/setproctitle.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* ==========================================================================
  * setproctitle.c - Linux/Darwin setproctitle.
  * --------------------------------------------------------------------------
@@ -72,6 +73,7 @@ static struct {
 #endif
 
 static inline size_t spt_min(size_t a, size_t b) {
+	__A_VARIABLE = 1;
 	return SPT_MIN(a, b);
 } /* spt_min() */
 
@@ -105,8 +107,10 @@ static int spt_copyenv(char *oldenv[]) {
 	char *eq;
 	int i, error;
 
-	if (environ != oldenv)
+	if (environ != oldenv) {
+		__A_VARIABLE = 1;
 		return 0;
+	}
 
 	if ((error = spt_clearenv()))
 		goto error;
@@ -123,10 +127,12 @@ static int spt_copyenv(char *oldenv[]) {
 			goto error;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 error:
 	environ = oldenv;
 
+	__A_VARIABLE = 1;
 	return error;
 } /* spt_copyenv() */
 
@@ -139,12 +145,15 @@ static int spt_copyargs(int argc, char *argv[]) {
 		if (!argv[i])
 			continue;
 
-		if (!(tmp = strdup(argv[i])))
+		if (!(tmp = strdup(argv[i]))) {
+			__A_VARIABLE = 1;
 			return errno;
+		}
 
 		argv[i] = tmp;
 	}
 
+	__A_VARIABLE = 1;
 	return 0;
 } /* spt_copyargs() */
 
@@ -154,8 +163,10 @@ void spt_init(int argc, char *argv[]) {
 	char *base, *end, *nul, *tmp;
 	int i, error;
 
-	if (!(base = argv[0]))
+	if (!(base = argv[0])) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	nul = &base[strlen(base)];
 	end = nul + 1;
@@ -205,11 +216,13 @@ void spt_init(int argc, char *argv[]) {
 	SPT.base = base;
 	SPT.end  = end;
 
+	__A_VARIABLE = 1;
 	return;
 syerr:
 	error = errno;
 error:
 	SPT.error = error;
+	__A_VARIABLE = 1;
 } /* spt_init() */
 
 
@@ -223,8 +236,10 @@ void setproctitle(const char *fmt, ...) {
 	char *nul;
 	int len, error;
 
-	if (!SPT.base)
+	if (!SPT.base) {
+		__A_VARIABLE = 1;
 		return;
+	}
 
 	if (fmt) {
 		va_start(ap, fmt);
@@ -255,9 +270,11 @@ void setproctitle(const char *fmt, ...) {
 		*++nul = '\0';
 	}
 
+	__A_VARIABLE = 1;
 	return;
 error:
 	SPT.error = error;
+	__A_VARIABLE = 1;
 } /* setproctitle() */
 
 
diff --git a/src/sha1.c b/src/sha1.c
index ce487e3..f456ddc 100644
--- a/src/sha1.c
+++ b/src/sha1.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 
 /* from valgrind tests */
 
@@ -109,6 +110,7 @@ void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
 #ifdef SHA1HANDSOFF
     memset(block, '\0', sizeof(block));
 #endif
+    __A_VARIABLE = 1;
 }
 
 
@@ -123,6 +125,7 @@ void SHA1Init(SHA1_CTX* context)
     context->state[3] = 0x10325476;
     context->state[4] = 0xC3D2E1F0;
     context->count[0] = context->count[1] = 0;
+    __A_VARIABLE = 1;
 }
 
 
@@ -147,6 +150,7 @@ void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
     }
     else i = 0;
     memcpy(&context->buffer[j], &data[i], len - i);
+    __A_VARIABLE = 1;
 }
 
 
@@ -194,6 +198,7 @@ void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
     /* Wipe variables */
     memset(context, '\0', sizeof(*context));
     memset(&finalcount, '\0', sizeof(finalcount));
+    __A_VARIABLE = 1;
 }
 /* ================ end of sha1.c ================ */
 
@@ -222,6 +227,7 @@ int sha1Test(int argc, char **argv)
     for(i=0;i<20;i++)
         printf("%02x", hash[i]);
     printf("\n");
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/siphash.c b/src/siphash.c
index 6b94190..c51265f 100644
--- a/src/siphash.c
+++ b/src/siphash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
    SipHash reference C implementation
 
@@ -343,7 +344,11 @@ int siphash_test(void) {
     h2 = siphash_nocase((uint8_t*)"HELLO world",11,(uint8_t*)"1234567812345678");
     if (h1 == h2) fails++;
 
-    if (!fails) return 0;
+    if (!fails) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
diff --git a/src/slowlog.c b/src/slowlog.c
index 8e183fc..3b2ba1c 100644
--- a/src/slowlog.c
+++ b/src/slowlog.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Slowlog implements a system that is able to remember the latest N
  * queries that took more than M microseconds to execute.
  *
@@ -90,6 +91,7 @@ slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long dur
     se->id = server.slowlog_entry_id++;
     se->peerid = sdsnew(getClientPeerId(c));
     se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();
+    __A_VARIABLE = 1;
     return se;
 }
 
@@ -107,6 +109,7 @@ void slowlogFreeEntry(void *septr) {
     sdsfree(se->peerid);
     sdsfree(se->cname);
     zfree(se);
+    __A_VARIABLE = 1;
 }
 
 /* Initialize the slow log. This function should be called a single time
@@ -115,13 +118,17 @@ void slowlogInit(void) {
     server.slowlog = listCreate();
     server.slowlog_entry_id = 0;
     listSetFreeMethod(server.slowlog,slowlogFreeEntry);
+    __A_VARIABLE = 1;
 }
 
 /* Push a new entry into the slow log.
  * This function will make sure to trim the slow log accordingly to the
  * configured max length. */
 void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
-    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
+    if (server.slowlog_log_slower_than < 0) {
+        __A_VARIABLE = 1;
+        return;
+    } /* Slowlog disabled */
     if (duration >= server.slowlog_log_slower_than)
         listAddNodeHead(server.slowlog,
                         slowlogCreateEntry(c,argv,argc,duration));
@@ -129,12 +136,14 @@ void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long durati
     /* Remove old entries if needed. */
     while (listLength(server.slowlog) > server.slowlog_max_len)
         listDelNode(server.slowlog,listLast(server.slowlog));
+    __A_VARIABLE = 1;
 }
 
 /* Remove all the entries from the current slow log. */
 void slowlogReset(void) {
     while (listLength(server.slowlog) > 0)
         listDelNode(server.slowlog,listLast(server.slowlog));
+    __A_VARIABLE = 1;
 }
 
 /* The SLOWLOG command. Implements all the subcommands needed to handle the
diff --git a/src/sort.c b/src/sort.c
index 4b300d8..94c4b39 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* SORT command and helper functions.
  *
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -39,6 +40,7 @@ redisSortOperation *createSortOperation(int type, robj *pattern) {
     redisSortOperation *so = zmalloc(sizeof(*so));
     so->type = type;
     so->pattern = pattern;
+    __A_VARIABLE = 1;
     return so;
 }
 
@@ -69,6 +71,7 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     spat = pattern->ptr;
     if (spat[0] == '#' && spat[1] == '\0') {
         incrRefCount(subst);
+        __A_VARIABLE = 1;
         return subst;
     }
 
@@ -83,6 +86,7 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     p = strchr(spat,'*');
     if (!p) {
         decrRefCount(subst);
+        __A_VARIABLE = 1;
         return NULL;
     }
 
@@ -124,11 +128,13 @@ robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
     }
     decrRefCount(keyobj);
     if (fieldobj) decrRefCount(fieldobj);
+    __A_VARIABLE = 1;
     return o;
 
 noobj:
     decrRefCount(keyobj);
     if (fieldlen) decrRefCount(fieldobj);
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -181,6 +187,7 @@ int sortCompare(const void *s1, const void *s2) {
             }
         }
     }
+    __A_VARIABLE = 1;
     return server.sort_desc ? -cmp : cmp;
 }
 
@@ -205,6 +212,7 @@ void sortCommand(client *c) {
                    sortval->type != OBJ_ZSET)
     {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -282,6 +290,7 @@ void sortCommand(client *c) {
     if (syntax_error) {
         decrRefCount(sortval);
         listRelease(operations);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -587,4 +596,5 @@ void sortCommand(client *c) {
             decrRefCount(vector[j].u.cmpobj);
     }
     zfree(vector);
+    __A_VARIABLE = 1;
 }
diff --git a/src/sparkline.c b/src/sparkline.c
index 0a98688..511c999 100644
--- a/src/sparkline.c
+++ b/src/sparkline.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* sparkline.c -- ASCII Sparklines
  * This code is modified from http://github.com/antirez/aspark and adapted
  * in order to return SDS strings instead of outputting directly to
@@ -58,6 +59,7 @@ struct sequence *createSparklineSequence(void) {
     struct sequence *seq = zmalloc(sizeof(*seq));
     seq->length = 0;
     seq->samples = NULL;
+    __A_VARIABLE = 1;
     return seq;
 }
 
@@ -75,6 +77,7 @@ void sparklineSequenceAddSample(struct sequence *seq, double value, char *label)
     seq->samples[seq->length].label = label;
     seq->length++;
     if (label) seq->labels++;
+    __A_VARIABLE = 1;
 }
 
 /* Free a sequence. */
@@ -85,6 +88,7 @@ void freeSparklineSequence(struct sequence *seq) {
         zfree(seq->samples[j].label);
     zfree(seq->samples);
     zfree(seq);
+    __A_VARIABLE = 1;
 }
 
 /* ----------------------------------------------------------------------------
@@ -158,6 +162,7 @@ sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset,
         }
     }
     zfree(chars);
+    __A_VARIABLE = 1;
     return output;
 }
 
@@ -171,6 +176,7 @@ sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int
         if (j != 0) output = sdscatlen(output,"\n",1);
         output = sparklineRenderRange(output, seq, rows, j, sublen, flags);
     }
+    __A_VARIABLE = 1;
     return output;
 }
 
diff --git a/src/syncio.c b/src/syncio.c
index b2843d5..8188025 100644
--- a/src/syncio.c
+++ b/src/syncio.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Synchronous socket and file I/O operations useful across the core.
  *
  * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
diff --git a/src/t_hash.c b/src/t_hash.c
index 0ca152d..8a52710 100644
--- a/src/t_hash.c
+++ b/src/t_hash.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -40,7 +41,10 @@
 void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
     int i;
 
-    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;
+    if (o->encoding != OBJ_ENCODING_ZIPLIST) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (i = start; i <= end; i++) {
         if (sdsEncodedObject(argv[i]) &&
@@ -50,6 +54,7 @@ void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
             break;
         }
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the value from a ziplist encoded hash, identified by field.
@@ -78,9 +83,11 @@ int hashTypeGetFromZiplist(robj *o, sds field,
     if (vptr != NULL) {
         ret = ziplistGet(vptr, vstr, vlen, vll);
         serverAssert(ret);
+        __A_VARIABLE = 1;
         return 0;
     }
 
+    __A_VARIABLE = 1;
     return -1;
 }
 
@@ -93,7 +100,11 @@ sds hashTypeGetFromHashTable(robj *o, sds field) {
     serverAssert(o->encoding == OBJ_ENCODING_HT);
 
     de = dictFind(o->ptr, field);
-    if (de == NULL) return NULL;
+    if (de == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return dictGetVal(de);
 }
 
@@ -158,6 +169,7 @@ size_t hashTypeGetValueLength(robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -271,6 +283,7 @@ int hashTypeSet(robj *o, sds field, sds value, int flags) {
      * want this function to be responsible. */
     if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);
     if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);
+    __A_VARIABLE = 1;
     return update;
 }
 
@@ -304,6 +317,7 @@ int hashTypeDelete(robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -318,6 +332,7 @@ unsigned long hashTypeLength(const robj *o) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return length;
 }
 
@@ -334,6 +349,7 @@ hashTypeIterator *hashTypeInitIterator(robj *subject) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
     return hi;
 }
 
@@ -341,6 +357,7 @@ void hashTypeReleaseIterator(hashTypeIterator *hi) {
     if (hi->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(hi->di);
     zfree(hi);
+    __A_VARIABLE = 1;
 }
 
 /* Move to the next entry in the hash. Return C_OK when the next entry
@@ -398,6 +415,7 @@ void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
         ret = ziplistGet(hi->vptr, vstr, vlen, vll);
         serverAssert(ret);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Get the field or value at iterator cursor, for an iterator on a hash value
@@ -434,6 +452,7 @@ void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr,
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Return the key or value at the current iterator position as a new
@@ -444,7 +463,11 @@ sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
     long long vll;
 
     hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
-    if (vstr) return sdsnewlen(vstr,vlen);
+    if (vstr) {
+        __A_VARIABLE = 1;
+        return sdsnewlen(vstr,vlen);
+    }
+    __A_VARIABLE = 1;
     return sdsfromlonglong(vll);
 }
 
@@ -495,6 +518,7 @@ void hashTypeConvertZiplist(robj *o, int enc) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void hashTypeConvert(robj *o, int enc) {
@@ -505,6 +529,7 @@ void hashTypeConvert(robj *o, int enc) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -513,7 +538,10 @@ void hashTypeConvert(robj *o, int enc) {
 
 void hsetnxCommand(client *c) {
     robj *o;
-    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     hashTypeTryConversion(o,c->argv,2,3);
 
     if (hashTypeExists(o, c->argv[2]->ptr)) {
@@ -525,6 +553,7 @@ void hsetnxCommand(client *c) {
         notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
         server.dirty++;
     }
+    __A_VARIABLE = 1;
 }
 
 void hsetCommand(client *c) {
@@ -533,10 +562,14 @@ void hsetCommand(client *c) {
 
     if ((c->argc % 2) == 1) {
         addReplyError(c,"wrong number of arguments for HMSET");
+        __A_VARIABLE = 1;
         return;
     }
 
-    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
+    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     hashTypeTryConversion(o,c->argv,2,c->argc-1);
 
     for (i = 2; i < c->argc; i += 2)
@@ -554,6 +587,7 @@ void hsetCommand(client *c) {
     signalModifiedKey(c->db,c->argv[1]);
     notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 void hincrbyCommand(client *c) {
@@ -646,6 +680,7 @@ static void addHashFieldToReply(client *c, robj *o, sds field) {
 
     if (o == NULL) {
         addReply(c, shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -674,15 +709,20 @@ static void addHashFieldToReply(client *c, robj *o, sds field) {
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void hgetCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addHashFieldToReply(c, o, c->argv[2]->ptr);
+    __A_VARIABLE = 1;
 }
 
 void hmgetCommand(client *c) {
@@ -694,6 +734,7 @@ void hmgetCommand(client *c) {
     o = lookupKeyRead(c->db, c->argv[1]);
     if (o != NULL && o->type != OBJ_HASH) {
         addReply(c, shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -701,6 +742,7 @@ void hmgetCommand(client *c) {
     for (i = 2; i < c->argc; i++) {
         addHashFieldToReply(c, o, c->argv[i]->ptr);
     }
+    __A_VARIABLE = 1;
 }
 
 void hdelCommand(client *c) {
@@ -708,7 +750,10 @@ void hdelCommand(client *c) {
     int j, deleted = 0, keyremoved = 0;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (hashTypeDelete(o,c->argv[j]->ptr)) {
@@ -729,23 +774,32 @@ void hdelCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 void hlenCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,hashTypeLength(o));
+    __A_VARIABLE = 1;
 }
 
 void hstrlenCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
+    __A_VARIABLE = 1;
 }
 
 static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
@@ -765,6 +819,7 @@ static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int wh
     } else {
         serverPanic("Unknown hash encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void genericHgetallCommand(client *c, int flags) {
@@ -774,7 +829,10 @@ void genericHgetallCommand(client *c, int flags) {
     int length, count = 0;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-        || checkType(c,o,OBJ_HASH)) return;
+        || checkType(c,o,OBJ_HASH)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (flags & OBJ_HASH_KEY) multiplier++;
     if (flags & OBJ_HASH_VALUE) multiplier++;
@@ -796,34 +854,49 @@ void genericHgetallCommand(client *c, int flags) {
 
     hashTypeReleaseIterator(hi);
     serverAssert(count == length);
+    __A_VARIABLE = 1;
 }
 
 void hkeysCommand(client *c) {
     genericHgetallCommand(c,OBJ_HASH_KEY);
+    __A_VARIABLE = 1;
 }
 
 void hvalsCommand(client *c) {
     genericHgetallCommand(c,OBJ_HASH_VALUE);
+    __A_VARIABLE = 1;
 }
 
 void hgetallCommand(client *c) {
     genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);
+    __A_VARIABLE = 1;
 }
 
 void hexistsCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void hscanCommand(client *c) {
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,OBJ_HASH)) return;
+        checkType(c,o,OBJ_HASH)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,o,cursor);
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_list.c b/src/t_list.c
index de417f4..b458aaf 100644
--- a/src/t_list.c
+++ b/src/t_list.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -48,9 +49,11 @@ void listTypePush(robj *subject, robj *value, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void *listPopSaver(unsigned char *data, unsigned int sz) {
+    __A_VARIABLE = 1;
     return createStringObject((char*)data,sz);
 }
 
@@ -68,6 +71,7 @@ robj *listTypePop(robj *subject, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -97,6 +101,7 @@ listTypeIterator *listTypeInitIterator(robj *subject, long index,
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return li;
 }
 
@@ -104,6 +109,7 @@ listTypeIterator *listTypeInitIterator(robj *subject, long index,
 void listTypeReleaseIterator(listTypeIterator *li) {
     zfree(li->iter);
     zfree(li);
+    __A_VARIABLE = 1;
 }
 
 /* Stores pointer to current the entry in the provided entry structure
@@ -135,6 +141,7 @@ robj *listTypeGet(listTypeEntry *entry) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
     return value;
 }
 
@@ -154,6 +161,7 @@ void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Compare the given object with the entry at the current position. */
@@ -173,6 +181,7 @@ void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Create a quicklist from a single ziplist */
@@ -188,6 +197,7 @@ void listTypeConvert(robj *subject, int enc) {
     } else {
         serverPanic("Unsupported list conversion");
     }
+    __A_VARIABLE = 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -200,6 +210,7 @@ void pushGenericCommand(client *c, int where) {
 
     if (lobj && lobj->type != OBJ_LIST) {
         addReply(c,shared.wrongtypeerr);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -221,14 +232,17 @@ void pushGenericCommand(client *c, int where) {
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
     server.dirty += pushed;
+    __A_VARIABLE = 1;
 }
 
 void lpushCommand(client *c) {
     pushGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpushCommand(client *c) {
     pushGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void pushxGenericCommand(client *c, int where) {
@@ -236,7 +250,10 @@ void pushxGenericCommand(client *c, int where) {
     robj *subject;
 
     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,subject,OBJ_LIST)) return;
+        checkType(c,subject,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         listTypePush(subject,c->argv[j],where);
@@ -251,14 +268,17 @@ void pushxGenericCommand(client *c, int where) {
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
     server.dirty += pushed;
+    __A_VARIABLE = 1;
 }
 
 void lpushxCommand(client *c) {
     pushxGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpushxCommand(client *c) {
     pushxGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void linsertCommand(client *c) {
@@ -307,18 +327,27 @@ void linsertCommand(client *c) {
 
 void llenCommand(client *c) {
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     addReplyLongLong(c,listTypeLength(o));
+    __A_VARIABLE = 1;
 }
 
 void lindexCommand(client *c) {
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     long index;
     robj *value = NULL;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklistEntry entry;
@@ -336,16 +365,22 @@ void lindexCommand(client *c) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void lsetCommand(client *c) {
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     long index;
     robj *value = c->argv[3];
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklist *ql = o->ptr;
@@ -362,11 +397,15 @@ void lsetCommand(client *c) {
     } else {
         serverPanic("Unknown list encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 void popGenericCommand(client *c, int where) {
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     robj *value = listTypePop(o,where);
     if (value == NULL) {
@@ -385,14 +424,17 @@ void popGenericCommand(client *c, int where) {
         signalModifiedKey(c->db,c->argv[1]);
         server.dirty++;
     }
+    __A_VARIABLE = 1;
 }
 
 void lpopCommand(client *c) {
     popGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void rpopCommand(client *c) {
     popGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void lrangeCommand(client *c) {
@@ -400,10 +442,16 @@ void lrangeCommand(client *c) {
     long start, end, llen, rangelen;
 
     if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-         || checkType(c,o,OBJ_LIST)) return;
+         || checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     llen = listTypeLength(o);
 
     /* convert negative indexes */
@@ -415,6 +463,7 @@ void lrangeCommand(client *c) {
      * The range is empty when start > end or start >= length. */
     if (start > end || start >= llen) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
     if (end >= llen) end = llen-1;
@@ -439,6 +488,7 @@ void lrangeCommand(client *c) {
     } else {
         serverPanic("List encoding is not QUICKLIST!");
     }
+    __A_VARIABLE = 1;
 }
 
 void ltrimCommand(client *c) {
@@ -446,10 +496,16 @@ void ltrimCommand(client *c) {
     long start, end, llen, ltrim, rtrim;
 
     if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
-        checkType(c,o,OBJ_LIST)) return;
+        checkType(c,o,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     llen = listTypeLength(o);
 
     /* convert negative indexes */
@@ -485,6 +541,7 @@ void ltrimCommand(client *c) {
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
     addReply(c,shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void lremCommand(client *c) {
@@ -493,11 +550,16 @@ void lremCommand(client *c) {
     long toremove;
     long removed = 0;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK)) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
-    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;
+    if (subject == NULL || checkType(c,subject,OBJ_LIST)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     listTypeIterator *li;
     if (toremove < 0) {
@@ -529,6 +591,7 @@ void lremCommand(client *c) {
     }
 
     addReplyLongLong(c,removed);
+    __A_VARIABLE = 1;
 }
 
 /* This is the semantic of this command:
@@ -560,6 +623,7 @@ void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {
     notifyKeyspaceEvent(NOTIFY_LIST,"lpush",dstkey,c->db->id);
     /* Always send the pushed value to the client. */
     addReplyBulk(c,value);
+    __A_VARIABLE = 1;
 }
 
 void rpoplpushCommand(client *c) {
@@ -741,17 +805,22 @@ void blockingPopGenericCommand(client *c, int where) {
 
 void blpopCommand(client *c) {
     blockingPopGenericCommand(c,LIST_HEAD);
+    __A_VARIABLE = 1;
 }
 
 void brpopCommand(client *c) {
     blockingPopGenericCommand(c,LIST_TAIL);
+    __A_VARIABLE = 1;
 }
 
 void brpoplpushCommand(client *c) {
     mstime_t timeout;
 
     if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
-        != C_OK) return;
+        != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     robj *key = lookupKeyWrite(c->db, c->argv[1]);
 
@@ -774,4 +843,5 @@ void brpoplpushCommand(client *c) {
             rpoplpushCommand(c);
         }
     }
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_set.c b/src/t_set.c
index f67073f..443c23b 100644
--- a/src/t_set.c
+++ b/src/t_set.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -40,8 +41,11 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
  * an integer-encodable value, an intset will be returned. Otherwise a regular
  * hash table. */
 robj *setTypeCreate(sds value) {
-    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
+    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK) {
+        __A_VARIABLE = 1;
         return createIntsetObject();
+    }
+    __A_VARIABLE = 1;
     return createSetObject();
 }
 
@@ -129,6 +133,7 @@ setTypeIterator *setTypeInitIterator(robj *subject) {
     } else {
         serverPanic("Unknown set encoding");
     }
+    __A_VARIABLE = 1;
     return si;
 }
 
@@ -136,6 +141,7 @@ void setTypeReleaseIterator(setTypeIterator *si) {
     if (si->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(si->di);
     zfree(si);
+    __A_VARIABLE = 1;
 }
 
 /* Move to the next entry in the set. Returns the object at the current
@@ -181,14 +187,18 @@ sds setTypeNextObject(setTypeIterator *si) {
 
     encoding = setTypeNext(si,&sdsele,&intele);
     switch(encoding) {
-        case -1:    return NULL;
+        case -1:    __A_VARIABLE = 1;
+            return NULL;
         case OBJ_ENCODING_INTSET:
+            __A_VARIABLE = 1;
             return sdsfromlonglong(intele);
         case OBJ_ENCODING_HT:
+            __A_VARIABLE = 1;
             return sdsdup(sdsele);
         default:
             serverPanic("Unsupported encoding");
     }
+    __A_VARIABLE = 1;
     return NULL; /* just to suppress warnings */
 }
 
@@ -216,6 +226,7 @@ int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
     } else {
         serverPanic("Unknown set encoding");
     }
+    __A_VARIABLE = 1;
     return setobj->encoding;
 }
 
@@ -259,6 +270,7 @@ void setTypeConvert(robj *setobj, int enc) {
     } else {
         serverPanic("Unsupported set conversion");
     }
+    __A_VARIABLE = 1;
 }
 
 void saddCommand(client *c) {
@@ -292,7 +304,10 @@ void sremCommand(client *c) {
     int j, deleted = 0, keyremoved = 0;
 
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (setTypeRemove(set,c->argv[j]->ptr)) {
@@ -313,6 +328,7 @@ void sremCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 void smoveCommand(client *c) {
@@ -324,24 +340,30 @@ void smoveCommand(client *c) {
     /* If the source key does not exist return 0 */
     if (srcset == NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* If the source key has the wrong type, or the destination key
      * is set and has the wrong type, return with an error. */
     if (checkType(c,srcset,OBJ_SET) ||
-        (dstset && checkType(c,dstset,OBJ_SET))) return;
+        (dstset && checkType(c,dstset,OBJ_SET))) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If srcset and dstset are equal, SMOVE is a no-op */
     if (srcset == dstset) {
         addReply(c,setTypeIsMember(srcset,ele->ptr) ?
             shared.cone : shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
     /* If the element cannot be removed from the src set, return 0. */
     if (!setTypeRemove(srcset,ele->ptr)) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
     notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
@@ -368,27 +390,36 @@ void smoveCommand(client *c) {
         notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
     }
     addReply(c,shared.cone);
+    __A_VARIABLE = 1;
 }
 
 void sismemberCommand(client *c) {
     robj *set;
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (setTypeIsMember(set,c->argv[2]->ptr))
         addReply(c,shared.cone);
     else
         addReply(c,shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void scardCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_SET)) return;
+        checkType(c,o,OBJ_SET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,setTypeSize(o));
+    __A_VARIABLE = 1;
 }
 
 /* Handle the "SPOP key <count>" variant. The normal version of the
@@ -622,7 +653,10 @@ void srandmemberWithCountCommand(client *c) {
 
     dict *d;
 
-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
+    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (l >= 0) {
         count = (unsigned long) l;
     } else {
@@ -633,12 +667,16 @@ void srandmemberWithCountCommand(client *c) {
     }
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
-        == NULL || checkType(c,set,OBJ_SET)) return;
+        == NULL || checkType(c,set,OBJ_SET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     size = setTypeSize(set);
 
     /* If count is zero, serve it ASAP to avoid special cases later. */
     if (count == 0) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -656,6 +694,7 @@ void srandmemberWithCountCommand(client *c) {
                 addReplyBulkCBuffer(c,ele,sdslen(ele));
             }
         }
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -664,6 +703,7 @@ void srandmemberWithCountCommand(client *c) {
      * elements inside the set: simply return the whole set. */
     if (count >= size) {
         sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -743,6 +783,7 @@ void srandmemberWithCountCommand(client *c) {
             addReplyBulk(c,dictGetKey(de));
         dictReleaseIterator(di);
         dictRelease(d);
+        __A_VARIABLE = 1;
     }
 }
 
@@ -772,8 +813,15 @@ void srandmemberCommand(client *c) {
 }
 
 int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
-    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
-    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
+    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -784,8 +832,15 @@ int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
     unsigned long first = o1 ? setTypeSize(o1) : 0;
     unsigned long second = o2 ? setTypeSize(o2) : 0;
 
-    if (first < second) return 1;
-    if (first > second) return -1;
+    if (first < second) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (first > second) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -815,10 +870,12 @@ void sinterGenericCommand(client *c, robj **setkeys,
             } else {
                 addReply(c,shared.emptymultibulk);
             }
+            __A_VARIABLE = 1;
             return;
         }
         if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
+            __A_VARIABLE = 1;
             return;
         }
         sets[j] = setobj;
@@ -914,14 +971,17 @@ void sinterGenericCommand(client *c, robj **setkeys,
         setDeferredMultiBulkLength(c,replylen,cardinality);
     }
     zfree(sets);
+    __A_VARIABLE = 1;
 }
 
 void sinterCommand(client *c) {
     sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
+    __A_VARIABLE = 1;
 }
 
 void sinterstoreCommand(client *c) {
     sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
+    __A_VARIABLE = 1;
 }
 
 #define SET_OP_UNION 0
@@ -947,6 +1007,7 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
         }
         if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
+            __A_VARIABLE = 1;
             return;
         }
         sets[j] = setobj;
@@ -1086,30 +1147,42 @@ void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
         server.dirty++;
     }
     zfree(sets);
+    __A_VARIABLE = 1;
 }
 
 void sunionCommand(client *c) {
     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void sunionstoreCommand(client *c) {
     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void sdiffCommand(client *c) {
     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
+    __A_VARIABLE = 1;
 }
 
 void sdiffstoreCommand(client *c) {
     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
+    __A_VARIABLE = 1;
 }
 
 void sscanCommand(client *c) {
     robj *set;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,set,OBJ_SET)) return;
+        checkType(c,set,OBJ_SET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,set,cursor);
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_stream.c b/src/t_stream.c
index d3d7006..01ae63b 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2017, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -56,6 +57,7 @@ stream *streamNew(void) {
     s->last_id.ms = 0;
     s->last_id.seq = 0;
     s->cgroups = NULL; /* Created on demand to save memory when not used. */
+    __A_VARIABLE = 1;
     return s;
 }
 
@@ -65,6 +67,7 @@ void freeStream(stream *s) {
     if (s->cgroups)
         raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
     zfree(s);
+    __A_VARIABLE = 1;
 }
 
 /* Generate the next stream item ID given the previous one. If the current
@@ -80,6 +83,7 @@ void streamNextID(streamID *last_id, streamID *new_id) {
         new_id->ms = last_id->ms;
         new_id->seq = last_id->seq+1;
     }
+    __A_VARIABLE = 1;
 }
 
 /* This is just a wrapper for lpAppend() to directly use a 64 bit integer
@@ -87,6 +91,7 @@ void streamNextID(streamID *last_id, streamID *new_id) {
 unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
     char buf[LONG_STR_SIZE];
     int slen = ll2string(buf,sizeof(buf),value);
+    __A_VARIABLE = 1;
     return lpAppend(lp,(unsigned char*)buf,slen);
 }
 
@@ -97,6 +102,7 @@ unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
 unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {
     char buf[LONG_STR_SIZE];
     int slen = ll2string(buf,sizeof(buf),value);
+    __A_VARIABLE = 1;
     return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);
 }
 
@@ -106,7 +112,10 @@ unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t
 int64_t lpGetInteger(unsigned char *ele) {
     int64_t v;
     unsigned char *e = lpGet(ele,&v,NULL);
-    if (e == NULL) return v;
+    if (e == NULL) {
+        __A_VARIABLE = 1;
+        return v;
+    }
     /* The following code path should never be used for how listpacks work:
      * they should always be able to store an int64_t value in integer
      * encoded form. However the implementation may change. */
@@ -114,6 +123,7 @@ int64_t lpGetInteger(unsigned char *ele) {
     int retval = string2ll((char*)e,v,&ll);
     serverAssert(retval != 0);
     v = ll;
+    __A_VARIABLE = 1;
     return v;
 }
 
@@ -128,6 +138,7 @@ void streamLogListpackContent(unsigned char *lp) {
         serverLog(LL_WARNING,"- [%d] '%.*s'", (int)v, (int)v, ele);
         p = lpNext(lp,p);
     }
+    __A_VARIABLE = 1;
 }
 
 /* Convert the specified stream entry ID as a 128 bit big endian number, so
@@ -137,6 +148,7 @@ void streamEncodeID(void *buf, streamID *id) {
     e[0] = htonu64(id->ms);
     e[1] = htonu64(id->seq);
     memcpy(buf,e,sizeof(e));
+    __A_VARIABLE = 1;
 }
 
 /* This is the reverse of streamEncodeID(): the decoded ID will be stored
@@ -147,6 +159,7 @@ void streamDecodeID(void *buf, streamID *id) {
     memcpy(e,buf,sizeof(e));
     id->ms = ntohu64(e[0]);
     id->seq = ntohu64(e[1]);
+    __A_VARIABLE = 1;
 }
 
 /* Compare two stream IDs. Return -1 if a < b, 0 if a == b, 1 if a > b. */
@@ -175,7 +188,10 @@ int streamCompareID(streamID *a, streamID *b) {
 int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {
     /* If an ID was given, check that it's greater than the last entry ID
      * or return an error. */
-    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) return C_ERR;
+    if (use_id && streamCompareID(use_id,&s->last_id) <= 0) {
+        __A_VARIABLE = 1;
+        return C_ERR;
+    }
 
     /* Add the new entry. */
     raxIterator ri;
@@ -354,6 +370,7 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_
     s->length++;
     s->last_id = id;
     if (added_id) *added_id = id;
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -372,7 +389,10 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_
  *    to be deleted, leaving the stream with a number of elements >= maxlen.
  */
 int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
-    if (s->length <= maxlen) return 0;
+    if (s->length <= maxlen) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     raxIterator ri;
     raxStart(&ri,s->rax);
@@ -461,6 +481,7 @@ int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
     }
 
     raxStop(&ri);
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -525,6 +546,7 @@ void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamI
     si->lp = NULL; /* There is no current listpack right now. */
     si->lp_ele = NULL; /* Current listpack cursor. */
     si->rev = rev;  /* Direction, if non-zero reversed, from end to start. */
+    __A_VARIABLE = 1;
 }
 
 /* Return 1 and store the current item ID at 'id' if there are still
@@ -685,6 +707,7 @@ void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsign
     }
     *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
     si->lp_ele = lpNext(si->lp,si->lp_ele);
+    __A_VARIABLE = 1;
 }
 
 /* Remove the current entry from the stream: can be called after the
@@ -748,6 +771,7 @@ void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
 
     /* TODO: perform a garbage collection here if the ration between
      * deleted and valid goes over a certain limit. */
+    __A_VARIABLE = 1;
 }
 
 /* Stop the stream iterator. The only cleanup we need is to free the rax
@@ -755,6 +779,7 @@ void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
  * allocated. */
 void streamIteratorStop(streamIterator *si) {
     raxStop(&si->ri);
+    __A_VARIABLE = 1;
 }
 
 /* Delete the specified item ID from the stream, returning 1 if the item
@@ -770,6 +795,7 @@ int streamDeleteItem(stream *s, streamID *id) {
         deleted = 1;
     }
     streamIteratorStop(&si);
+    __A_VARIABLE = 1;
     return deleted;
 }
 
@@ -779,11 +805,13 @@ int streamDeleteItem(stream *s, streamID *id) {
 void addReplyStreamID(client *c, streamID *id) {
     sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
     addReplyBulkSds(c,replyid);
+    __A_VARIABLE = 1;
 }
 
 /* Similar to the above function, but just creates an object, usually useful
  * for replication purposes to create arguments. */
 robj *createObjectFromStreamID(streamID *id) {
+    __A_VARIABLE = 1;
     return createObject(OBJ_STRING, sdscatfmt(sdsempty(),"%U-%U",
                         id->ms,id->seq));
 }
@@ -826,6 +854,7 @@ void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupnam
     decrRefCount(argv[11]);
     decrRefCount(argv[12]);
     decrRefCount(argv[13]);
+    __A_VARIABLE = 1;
 }
 
 /* We need this when we want to propoagate the new last-id of a consumer group
@@ -845,6 +874,7 @@ void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupna
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
     decrRefCount(argv[4]);
+    __A_VARIABLE = 1;
 }
 
 /* Send the stream items in the specified range to the client 'c'. The range
@@ -909,6 +939,7 @@ size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end
      * the history of messages delivered to it and not yet confirmed
      * as delivered. */
     if (group && (flags & STREAM_RWR_HISTORY)) {
+        __A_VARIABLE = 1;
         return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
                                                    consumer);
     }
@@ -994,6 +1025,7 @@ size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end
     }
     streamIteratorStop(&si);
     if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
+    __A_VARIABLE = 1;
     return arraylen;
 }
 
@@ -1046,6 +1078,7 @@ size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start
     }
     raxStop(&ri);
     setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
+    __A_VARIABLE = 1;
     return arraylen;
 }
 
@@ -1077,15 +1110,22 @@ robj *streamTypeLookupWriteOrCreate(client *c, robj *key) {
 int string2ull(const char *s, unsigned long long *value) {
     long long ll;
     if (string2ll(s,strlen(s),&ll)) {
-        if (ll < 0) return 0; /* Negative values are out of range. */
+        if (ll < 0) {
+            __A_VARIABLE = 1;
+            return 0;
+        } /* Negative values are out of range. */
         *value = ll;
+        __A_VARIABLE = 1;
         return 1;
     }
     errno = 0;
     char *endptr = NULL;
     *value = strtoull(s,&endptr,10);
-    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
-        return 0; /* strtoull() failed. */
+    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0')) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* strtoull() failed. */
+    __A_VARIABLE = 1;
     return 1; /* Conversion done! */
 }
 
@@ -1140,6 +1180,7 @@ invalid:
 /* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to
  * 0, to be used when - and + are accetable IDs. */
 int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
+    __A_VARIABLE = 1;
     return streamGenericParseIDOrReply(c,o,id,missing_seq,0);
 }
 
@@ -1147,6 +1188,7 @@ int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq)
  * 1, to be used when we want to return an error if the special IDs + or -
  * are provided. */
 int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
+    __A_VARIABLE = 1;
     return streamGenericParseIDOrReply(c,o,id,missing_seq,1);
 }
 
@@ -1161,6 +1203,7 @@ void streamRewriteApproxMaxlen(client *c, stream *s, int maxlen_arg_idx) {
 
     decrRefCount(equal_obj);
     decrRefCount(maxlen_obj);
+    __A_VARIABLE = 1;
 }
 
 /* XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ... */
@@ -1301,20 +1344,26 @@ void xrangeGenericCommand(client *c, int rev) {
 /* XRANGE key start end [COUNT <n>] */
 void xrangeCommand(client *c) {
     xrangeGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 /* XREVRANGE key end start [COUNT <n>] */
 void xrevrangeCommand(client *c) {
     xrangeGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* XLEN */
 void xlenCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
-        || checkType(c,o,OBJ_STREAM)) return;
+        || checkType(c,o,OBJ_STREAM)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     stream *s = o->ptr;
     addReplyLongLong(c,s->length);
+    __A_VARIABLE = 1;
 }
 
 /* XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N
@@ -1594,12 +1643,14 @@ streamNACK *streamCreateNACK(streamConsumer *consumer) {
     nack->delivery_time = mstime();
     nack->delivery_count = 1;
     nack->consumer = consumer;
+    __A_VARIABLE = 1;
     return nack;
 }
 
 /* Free a NACK entry. */
 void streamFreeNACK(streamNACK *na) {
     zfree(na);
+    __A_VARIABLE = 1;
 }
 
 /* Free a consumer and associated data structures. Note that this function
@@ -1612,6 +1663,7 @@ void streamFreeConsumer(streamConsumer *sc) {
                          between the consumer and the main stream PEL. */
     sdsfree(sc->name);
     zfree(sc);
+    __A_VARIABLE = 1;
 }
 
 /* Create a new consumer group in the context of the stream 's', having the
@@ -1620,14 +1672,17 @@ void streamFreeConsumer(streamConsumer *sc) {
  * group is returned. */
 streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {
     if (s->cgroups == NULL) s->cgroups = raxNew();
-    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)
+    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound) {
+        __A_VARIABLE = 1;
         return NULL;
+    }
 
     streamCG *cg = zmalloc(sizeof(*cg));
     cg->pel = raxNew();
     cg->consumers = raxNew();
     cg->last_id = *id;
     raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);
+    __A_VARIABLE = 1;
     return cg;
 }
 
@@ -1636,14 +1691,19 @@ void streamFreeCG(streamCG *cg) {
     raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
     raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
     zfree(cg);
+    __A_VARIABLE = 1;
 }
 
 /* Lookup the consumer group in the specified stream and returns its
  * pointer, otherwise if there is no such group, NULL is returned. */
 streamCG *streamLookupCG(stream *s, sds groupname) {
-    if (s->cgroups == NULL) return NULL;
+    if (s->cgroups == NULL) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,
                            sdslen(groupname));
+    __A_VARIABLE = 1;
     return (cg == raxNotFound) ? NULL : cg;
 }
 
@@ -1655,7 +1715,10 @@ streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
     streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,
                                sdslen(name));
     if (consumer == raxNotFound) {
-        if (!create) return NULL;
+        if (!create) {
+            __A_VARIABLE = 1;
+            return NULL;
+        }
         consumer = zmalloc(sizeof(*consumer));
         consumer->name = sdsdup(name);
         consumer->pel = raxNew();
@@ -1663,6 +1726,7 @@ streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
                   consumer,NULL);
     }
     consumer->seen_time = mstime();
+    __A_VARIABLE = 1;
     return consumer;
 }
 
@@ -1671,7 +1735,10 @@ streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {
  * of pending messages "lost" is returned. */
 uint64_t streamDelConsumer(streamCG *cg, sds name) {
     streamConsumer *consumer = streamLookupConsumer(cg,name,0);
-    if (consumer == NULL) return 0;
+    if (consumer == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     uint64_t retval = raxSize(consumer->pel);
 
@@ -1690,6 +1757,7 @@ uint64_t streamDelConsumer(streamCG *cg, sds name) {
     /* Deallocate the consumer. */
     raxRemove(cg->consumers,(unsigned char*)name,sdslen(name),NULL);
     streamFreeConsumer(consumer);
+    __A_VARIABLE = 1;
     return retval;
 }
 
@@ -1836,11 +1904,17 @@ NULL
  * Set the internal "last ID" of a stream. */
 void xsetidCommand(client *c) {
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
-    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
+    if (o == NULL || checkType(c,o,OBJ_STREAM)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     stream *s = o->ptr;
     streamID id;
-    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0) != C_OK) return;
+    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     /* If the stream has at least one item, we want to check that the user
      * is setting a last ID that is equal or greater than the current top
@@ -1856,6 +1930,7 @@ void xsetidCommand(client *c) {
         if (streamCompareID(&id,&maxid) < 0) {
             addReplyError(c,"The ID specified in XSETID is smaller than the "
                             "target stream top item");
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -1863,6 +1938,7 @@ void xsetidCommand(client *c) {
     addReply(c,shared.ok);
     server.dirty++;
     notifyKeyspaceEvent(NOTIFY_STREAM,"xsetid",c->argv[1],c->db->id);
+    __A_VARIABLE = 1;
 }
 
 /* XACK <key> <group> <id> <id> ... <id>
@@ -1878,13 +1954,17 @@ void xackCommand(client *c) {
     streamCG *group = NULL;
     robj *o = lookupKeyRead(c->db,c->argv[1]);
     if (o) {
-        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
+        if (checkType(c,o,OBJ_STREAM)) {
+            __A_VARIABLE = 1;
+            return;
+        } /* Type error. */
         group = streamLookupCG(o->ptr,c->argv[2]->ptr);
     }
 
     /* No key or group? Nothing to ack. */
     if (o == NULL || group == NULL) {
         addReply(c,shared.czero);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1892,7 +1972,10 @@ void xackCommand(client *c) {
     for (int j = 3; j < c->argc; j++) {
         streamID id;
         unsigned char buf[sizeof(streamID)];
-        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
+        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
         streamEncodeID(buf,&id);
 
         /* Lookup the ID in the group PEL: it will have a reference to the
@@ -1908,6 +1991,7 @@ void xackCommand(client *c) {
         }
     }
     addReplyLongLong(c,acknowledged);
+    __A_VARIABLE = 1;
 }
 
 /* XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]
@@ -2319,7 +2403,10 @@ void xdelCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
-        || checkType(c,o,OBJ_STREAM)) return;
+        || checkType(c,o,OBJ_STREAM)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     stream *s = o->ptr;
 
     /* We need to sanity check the IDs passed to start. Even if not
@@ -2327,7 +2414,10 @@ void xdelCommand(client *c) {
      * executed because at some point an invalid ID is parsed. */
     streamID id;
     for (int j = 2; j < c->argc; j++) {
-        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
+        if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) {
+            __A_VARIABLE = 1;
+            return;
+        }
     }
 
     /* Actually apply the command. */
@@ -2344,6 +2434,7 @@ void xdelCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 /* General form: XTRIM <key> [... options ...]
diff --git a/src/t_string.c b/src/t_string.c
index db6f7aa..3df979d 100644
--- a/src/t_string.c
+++ b/src/t_string.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -37,8 +38,10 @@
 static int checkStringLength(client *c, long long size) {
     if (size > 512*1024*1024) {
         addReplyError(c,"string exceeds maximum allowed size (512MB)");
+        __A_VARIABLE = 1;
         return C_ERR;
     }
+    __A_VARIABLE = 1;
     return C_OK;
 }
 
@@ -68,10 +71,13 @@ void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire,
     long long milliseconds = 0; /* initialized to avoid any harmness warning */
 
     if (expire) {
-        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)
+        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         if (milliseconds <= 0) {
             addReplyErrorFormat(c,"invalid expire time in %s",c->cmd->name);
+            __A_VARIABLE = 1;
             return;
         }
         if (unit == UNIT_SECONDS) milliseconds *= 1000;
@@ -81,6 +87,7 @@ void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire,
         (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))
     {
         addReply(c, abort_reply ? abort_reply : shared.nullbulk);
+        __A_VARIABLE = 1;
         return;
     }
     setKey(c->db,key,val);
@@ -90,6 +97,7 @@ void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire,
     if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
         "expire",key,c->db->id);
     addReply(c, ok_reply ? ok_reply : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 /* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */
@@ -142,16 +150,19 @@ void setCommand(client *c) {
 void setnxCommand(client *c) {
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
+    __A_VARIABLE = 1;
 }
 
 void setexCommand(client *c) {
     c->argv[3] = tryObjectEncoding(c->argv[3]);
     setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 void psetexCommand(client *c) {
     c->argv[3] = tryObjectEncoding(c->argv[3]);
     setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
+    __A_VARIABLE = 1;
 }
 
 int getGenericCommand(client *c) {
@@ -171,14 +182,19 @@ int getGenericCommand(client *c) {
 
 void getCommand(client *c) {
     getGenericCommand(c);
+    __A_VARIABLE = 1;
 }
 
 void getsetCommand(client *c) {
-    if (getGenericCommand(c) == C_ERR) return;
+    if (getGenericCommand(c) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setKey(c->db,c->argv[1],c->argv[2]);
     notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
     server.dirty++;
+    __A_VARIABLE = 1;
 }
 
 void setrangeCommand(client *c) {
@@ -247,12 +263,19 @@ void getrangeCommand(client *c) {
     char *str, llbuf[32];
     size_t strlen;
 
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
-    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
+    }
+    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (o->encoding == OBJ_ENCODING_INT) {
         str = llbuf;
@@ -265,6 +288,7 @@ void getrangeCommand(client *c) {
     /* Convert negative indexes */
     if (start < 0 && end < 0 && start > end) {
         addReply(c,shared.emptybulk);
+        __A_VARIABLE = 1;
         return;
     }
     if (start < 0) start = strlen+start;
@@ -280,6 +304,7 @@ void getrangeCommand(client *c) {
     } else {
         addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
     }
+    __A_VARIABLE = 1;
 }
 
 void mgetCommand(client *c) {
@@ -298,6 +323,7 @@ void mgetCommand(client *c) {
             }
         }
     }
+    __A_VARIABLE = 1;
 }
 
 void msetGenericCommand(client *c, int nx) {
@@ -305,6 +331,7 @@ void msetGenericCommand(client *c, int nx) {
 
     if ((c->argc % 2) == 0) {
         addReplyError(c,"wrong number of arguments for MSET");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -314,6 +341,7 @@ void msetGenericCommand(client *c, int nx) {
         for (j = 1; j < c->argc; j += 2) {
             if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
                 addReply(c, shared.czero);
+                __A_VARIABLE = 1;
                 return;
             }
         }
@@ -326,14 +354,17 @@ void msetGenericCommand(client *c, int nx) {
     }
     server.dirty += (c->argc-1)/2;
     addReply(c, nx ? shared.cone : shared.ok);
+    __A_VARIABLE = 1;
 }
 
 void msetCommand(client *c) {
     msetGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void msetnxCommand(client *c) {
     msetGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void incrDecrCommand(client *c, long long incr) {
@@ -341,13 +372,20 @@ void incrDecrCommand(client *c, long long incr) {
     robj *o, *new;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
-    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;
+    if (o != NULL && checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
+    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     oldvalue = value;
     if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
         (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
         addReplyError(c,"increment or decrement would overflow");
+        __A_VARIABLE = 1;
         return;
     }
     value += incr;
@@ -372,28 +410,39 @@ void incrDecrCommand(client *c, long long incr) {
     addReply(c,shared.colon);
     addReply(c,new);
     addReply(c,shared.crlf);
+    __A_VARIABLE = 1;
 }
 
 void incrCommand(client *c) {
     incrDecrCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void decrCommand(client *c) {
     incrDecrCommand(c,-1);
+    __A_VARIABLE = 1;
 }
 
 void incrbyCommand(client *c) {
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     incrDecrCommand(c,incr);
+    __A_VARIABLE = 1;
 }
 
 void decrbyCommand(client *c) {
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) {
+        __A_VARIABLE = 1;
+        return;
+    }
     incrDecrCommand(c,-incr);
+    __A_VARIABLE = 1;
 }
 
 void incrbyfloatCommand(client *c) {
@@ -401,14 +450,20 @@ void incrbyfloatCommand(client *c) {
     robj *o, *new, *aux;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
+    if (o != NULL && checkType(c,o,OBJ_STRING)) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
-        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
+        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     value += incr;
     if (isnan(value) || isinf(value)) {
         addReplyError(c,"increment would produce NaN or Infinity");
+        __A_VARIABLE = 1;
         return;
     }
     new = createStringObjectFromLongDouble(value,1);
@@ -428,6 +483,7 @@ void incrbyfloatCommand(client *c) {
     rewriteClientCommandArgument(c,0,aux);
     decrRefCount(aux);
     rewriteClientCommandArgument(c,2,new);
+    __A_VARIABLE = 1;
 }
 
 void appendCommand(client *c) {
@@ -466,6 +522,10 @@ void appendCommand(client *c) {
 void strlenCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,OBJ_STRING)) return;
+        checkType(c,o,OBJ_STRING)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     addReplyLongLong(c,stringObjectLen(o));
+    __A_VARIABLE = 1;
 }
diff --git a/src/t_zset.c b/src/t_zset.c
index 56ea396..f0f231b 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
@@ -73,6 +74,7 @@ zskiplistNode *zslCreateNode(int level, double score, sds ele) {
         zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
     zn->score = score;
     zn->ele = ele;
+    __A_VARIABLE = 1;
     return zn;
 }
 
@@ -91,6 +93,7 @@ zskiplist *zslCreate(void) {
     }
     zsl->header->backward = NULL;
     zsl->tail = NULL;
+    __A_VARIABLE = 1;
     return zsl;
 }
 
@@ -100,6 +103,7 @@ zskiplist *zslCreate(void) {
 void zslFreeNode(zskiplistNode *node) {
     sdsfree(node->ele);
     zfree(node);
+    __A_VARIABLE = 1;
 }
 
 /* Free a whole skiplist. */
@@ -113,6 +117,7 @@ void zslFree(zskiplist *zsl) {
         node = next;
     }
     zfree(zsl);
+    __A_VARIABLE = 1;
 }
 
 /* Returns a random level for the new skiplist node we are going to create.
@@ -123,6 +128,7 @@ int zslRandomLevel(void) {
     int level = 1;
     while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
         level += 1;
+    __A_VARIABLE = 1;
     return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
 }
 
@@ -183,6 +189,7 @@ zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
     else
         zsl->tail = x;
     zsl->length++;
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -205,6 +212,7 @@ void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
     while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
         zsl->level--;
     zsl->length--;
+    __A_VARIABLE = 1;
 }
 
 /* Delete an element with matching score/element from the skiplist.
@@ -239,8 +247,10 @@ int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
             zslFreeNode(x);
         else
             *node = x;
+        __A_VARIABLE = 1;
         return 1;
     }
+    __A_VARIABLE = 1;
     return 0; /* not found */
 }
 
@@ -285,6 +295,7 @@ zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double n
         (x->level[0].forward == NULL || x->level[0].forward->score > newscore))
     {
         x->score = newscore;
+        __A_VARIABLE = 1;
         return x;
     }
 
@@ -296,14 +307,17 @@ zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double n
      * since zslInsert created a new one. */
     x->ele = NULL;
     zslFreeNode(x);
+    __A_VARIABLE = 1;
     return newnode;
 }
 
 int zslValueGteMin(double value, zrangespec *spec) {
+    __A_VARIABLE = 1;
     return spec->minex ? (value > spec->min) : (value >= spec->min);
 }
 
 int zslValueLteMax(double value, zrangespec *spec) {
+    __A_VARIABLE = 1;
     return spec->maxex ? (value < spec->max) : (value <= spec->max);
 }
 
@@ -313,14 +327,21 @@ int zslIsInRange(zskiplist *zsl, zrangespec *range) {
 
     /* Test for ranges that will always be empty. */
     if (range->min > range->max ||
-            (range->min == range->max && (range->minex || range->maxex)))
+            (range->min == range->max && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->tail;
-    if (x == NULL || !zslValueGteMin(x->score,range))
+    if (x == NULL || !zslValueGteMin(x->score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->header->level[0].forward;
-    if (x == NULL || !zslValueLteMax(x->score,range))
+    if (x == NULL || !zslValueLteMax(x->score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -331,7 +352,10 @@ zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInRange(zsl,range)) return NULL;
+    if (!zslIsInRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -346,7 +370,11 @@ zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score <= max. */
-    if (!zslValueLteMax(x->score,range)) return NULL;
+    if (!zslValueLteMax(x->score,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -357,7 +385,10 @@ zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInRange(zsl,range)) return NULL;
+    if (!zslIsInRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -371,7 +402,11 @@ zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score >= min. */
-    if (!zslValueGteMin(x->score,range)) return NULL;
+    if (!zslValueGteMin(x->score,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -407,6 +442,7 @@ unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dic
         removed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -436,6 +472,7 @@ unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *di
         removed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -466,6 +503,7 @@ unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned
         traversed++;
         x = next;
     }
+    __A_VARIABLE = 1;
     return removed;
 }
 
@@ -490,9 +528,11 @@ unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
 
         /* x might be equal to zsl->header, so test if obj is non-NULL */
         if (x->ele && sdscmp(x->ele,ele) == 0) {
+            __A_VARIABLE = 1;
             return rank;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -510,9 +550,11 @@ zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
             x = x->level[i].forward;
         }
         if (traversed == rank) {
+            __A_VARIABLE = 1;
             return x;
         }
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -573,24 +615,35 @@ int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
 
     switch(c[0]) {
     case '+':
-        if (c[1] != '\0') return C_ERR;
+        if (c[1] != '\0') {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
         *ex = 1;
         *dest = shared.maxstring;
+        __A_VARIABLE = 1;
         return C_OK;
     case '-':
-        if (c[1] != '\0') return C_ERR;
+        if (c[1] != '\0') {
+            __A_VARIABLE = 1;
+            return C_ERR;
+        }
         *ex = 1;
         *dest = shared.minstring;
+        __A_VARIABLE = 1;
         return C_OK;
     case '(':
         *ex = 1;
         *dest = sdsnewlen(c+1,sdslen(c)-1);
+        __A_VARIABLE = 1;
         return C_OK;
     case '[':
         *ex = 0;
         *dest = sdsnewlen(c+1,sdslen(c)-1);
+        __A_VARIABLE = 1;
         return C_OK;
     default:
+        __A_VARIABLE = 1;
         return C_ERR;
     }
 }
@@ -602,6 +655,7 @@ void zslFreeLexRange(zlexrangespec *spec) {
         spec->min != shared.maxstring) sdsfree(spec->min);
     if (spec->max != shared.minstring &&
         spec->max != shared.maxstring) sdsfree(spec->max);
+    __A_VARIABLE = 1;
 }
 
 /* Populate the lex rangespec according to the objects min and max.
@@ -629,19 +683,31 @@ int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
  * handle shared.minstring and shared.maxstring as the equivalent of
  * -inf and +inf for strings */
 int sdscmplex(sds a, sds b) {
-    if (a == b) return 0;
-    if (a == shared.minstring || b == shared.maxstring) return -1;
-    if (a == shared.maxstring || b == shared.minstring) return 1;
+    if (a == b) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
+    if (a == shared.minstring || b == shared.maxstring) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    if (a == shared.maxstring || b == shared.minstring) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    __A_VARIABLE = 1;
     return sdscmp(a,b);
 }
 
 int zslLexValueGteMin(sds value, zlexrangespec *spec) {
+    __A_VARIABLE = 1;
     return spec->minex ?
         (sdscmplex(value,spec->min) > 0) :
         (sdscmplex(value,spec->min) >= 0);
 }
 
 int zslLexValueLteMax(sds value, zlexrangespec *spec) {
+    __A_VARIABLE = 1;
     return spec->maxex ?
         (sdscmplex(value,spec->max) < 0) :
         (sdscmplex(value,spec->max) <= 0);
@@ -653,14 +719,21 @@ int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
 
     /* Test for ranges that will always be empty. */
     int cmp = sdscmplex(range->min,range->max);
-    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
+    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->tail;
-    if (x == NULL || !zslLexValueGteMin(x->ele,range))
+    if (x == NULL || !zslLexValueGteMin(x->ele,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     x = zsl->header->level[0].forward;
-    if (x == NULL || !zslLexValueLteMax(x->ele,range))
+    if (x == NULL || !zslLexValueLteMax(x->ele,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -671,7 +744,10 @@ zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInLexRange(zsl,range)) return NULL;
+    if (!zslIsInLexRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -686,7 +762,11 @@ zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score <= max. */
-    if (!zslLexValueLteMax(x->ele,range)) return NULL;
+    if (!zslLexValueLteMax(x->ele,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -697,7 +777,10 @@ zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
     int i;
 
     /* If everything is out of range, return early. */
-    if (!zslIsInLexRange(zsl,range)) return NULL;
+    if (!zslIsInLexRange(zsl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
@@ -711,7 +794,11 @@ zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
     serverAssert(x != NULL);
 
     /* Check if score >= min. */
-    if (!zslLexValueGteMin(x->ele,range)) return NULL;
+    if (!zslLexValueGteMin(x->ele,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
+    __A_VARIABLE = 1;
     return x;
 }
 
@@ -737,6 +824,7 @@ double zzlGetScore(unsigned char *sptr) {
         score = vlong;
     }
 
+    __A_VARIABLE = 1;
     return score;
 }
 
@@ -773,11 +861,16 @@ int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int cl
 
     minlen = (vlen < clen) ? vlen : clen;
     cmp = memcmp(vstr,cstr,minlen);
-    if (cmp == 0) return vlen-clen;
+    if (cmp == 0) {
+        __A_VARIABLE = 1;
+        return vlen-clen;
+    }
+    __A_VARIABLE = 1;
     return cmp;
 }
 
 unsigned int zzlLength(unsigned char *zl) {
+    __A_VARIABLE = 1;
     return ziplistLen(zl)/2;
 }
 
@@ -798,6 +891,7 @@ void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
 
     *eptr = _eptr;
     *sptr = _sptr;
+    __A_VARIABLE = 1;
 }
 
 /* Move to the previous entry based on the values in eptr and sptr. Both are
@@ -817,6 +911,7 @@ void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
 
     *eptr = _eptr;
     *sptr = _sptr;
+    __A_VARIABLE = 1;
 }
 
 /* Returns if there is a part of the zset is in range. Should only be used
@@ -827,21 +922,31 @@ int zzlIsInRange(unsigned char *zl, zrangespec *range) {
 
     /* Test for ranges that will always be empty. */
     if (range->min > range->max ||
-            (range->min == range->max && (range->minex || range->maxex)))
+            (range->min == range->max && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,-1); /* Last score. */
-    if (p == NULL) return 0; /* Empty sorted set */
+    if (p == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    } /* Empty sorted set */
     score = zzlGetScore(p);
-    if (!zslValueGteMin(score,range))
+    if (!zslValueGteMin(score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,1); /* First score. */
     serverAssert(p != NULL);
     score = zzlGetScore(p);
-    if (!zslValueLteMax(score,range))
+    if (!zslValueLteMax(score,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -852,7 +957,10 @@ unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
     double score;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInRange(zl,range)) return NULL;
+    if (!zzlIsInRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
@@ -861,8 +969,11 @@ unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
         score = zzlGetScore(sptr);
         if (zslValueGteMin(score,range)) {
             /* Check if score <= max. */
-            if (zslValueLteMax(score,range))
+            if (zslValueLteMax(score,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -870,6 +981,7 @@ unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
         eptr = ziplistNext(zl,sptr);
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -880,7 +992,10 @@ unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
     double score;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInRange(zl,range)) return NULL;
+    if (!zzlIsInRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
@@ -889,8 +1004,11 @@ unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
         score = zzlGetScore(sptr);
         if (zslValueLteMax(score,range)) {
             /* Check if score >= min. */
-            if (zslValueGteMin(score,range))
+            if (zslValueGteMin(score,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -903,6 +1021,7 @@ unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
             eptr = NULL;
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -910,6 +1029,7 @@ int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
     sds value = ziplistGetObject(p);
     int res = zslLexValueGteMin(value,spec);
     sdsfree(value);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -917,6 +1037,7 @@ int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
     sds value = ziplistGetObject(p);
     int res = zslLexValueLteMax(value,spec);
     sdsfree(value);
+    __A_VARIABLE = 1;
     return res;
 }
 
@@ -927,19 +1048,29 @@ int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
 
     /* Test for ranges that will always be empty. */
     int cmp = sdscmplex(range->min,range->max);
-    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
+    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex))) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     p = ziplistIndex(zl,-2); /* Last element. */
-    if (p == NULL) return 0;
-    if (!zzlLexValueGteMin(p,range))
+    if (p == NULL) {
+        __A_VARIABLE = 1;
         return 0;
+    }
+    if (!zzlLexValueGteMin(p,range)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     p = ziplistIndex(zl,0); /* First element. */
     serverAssert(p != NULL);
-    if (!zzlLexValueLteMax(p,range))
+    if (!zzlLexValueLteMax(p,range)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -949,13 +1080,19 @@ unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInLexRange(zl,range)) return NULL;
+    if (!zzlIsInLexRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         if (zzlLexValueGteMin(eptr,range)) {
             /* Check if score <= max. */
-            if (zzlLexValueLteMax(eptr,range))
+            if (zzlLexValueLteMax(eptr,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -965,6 +1102,7 @@ unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
         eptr = ziplistNext(zl,sptr); /* Next element. */
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -974,13 +1112,19 @@ unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
     unsigned char *eptr = ziplistIndex(zl,-2), *sptr;
 
     /* If everything is out of range, return early. */
-    if (!zzlIsInLexRange(zl,range)) return NULL;
+    if (!zzlIsInLexRange(zl,range)) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
 
     while (eptr != NULL) {
         if (zzlLexValueLteMax(eptr,range)) {
             /* Check if score >= min. */
-            if (zzlLexValueGteMin(eptr,range))
+            if (zzlLexValueGteMin(eptr,range)) {
+                __A_VARIABLE = 1;
                 return eptr;
+            }
+            __A_VARIABLE = 1;
             return NULL;
         }
 
@@ -993,6 +1137,7 @@ unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
             eptr = NULL;
     }
 
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1006,12 +1151,14 @@ unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
         if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele))) {
             /* Matching element, pull out score. */
             if (score != NULL) *score = zzlGetScore(sptr);
+            __A_VARIABLE = 1;
             return eptr;
         }
 
         /* Move to next element. */
         eptr = ziplistNext(zl,sptr);
     }
+    __A_VARIABLE = 1;
     return NULL;
 }
 
@@ -1023,6 +1170,7 @@ unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
     /* TODO: add function to ziplist API to delete N elements from offset. */
     zl = ziplistDelete(zl,&p);
     zl = ziplistDelete(zl,&p);
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1046,6 +1194,7 @@ unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, doub
         serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
         zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
     }
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1081,6 +1230,7 @@ unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
     /* Push on tail of list when it was not yet inserted. */
     if (eptr == NULL)
         zl = zzlInsertAt(zl,NULL,ele,score);
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1092,7 +1242,10 @@ unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsig
     if (deleted != NULL) *deleted = 0;
 
     eptr = zzlFirstInRange(zl,range);
-    if (eptr == NULL) return zl;
+    if (eptr == NULL) {
+        __A_VARIABLE = 1;
+        return zl;
+    }
 
     /* When the tail of the ziplist is deleted, eptr will point to the sentinel
      * byte and ziplistNext will return NULL. */
@@ -1110,6 +1263,7 @@ unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsig
     }
 
     if (deleted != NULL) *deleted = num;
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1120,7 +1274,10 @@ unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsi
     if (deleted != NULL) *deleted = 0;
 
     eptr = zzlFirstInLexRange(zl,range);
-    if (eptr == NULL) return zl;
+    if (eptr == NULL) {
+        __A_VARIABLE = 1;
+        return zl;
+    }
 
     /* When the tail of the ziplist is deleted, eptr will point to the sentinel
      * byte and ziplistNext will return NULL. */
@@ -1137,6 +1294,7 @@ unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsi
     }
 
     if (deleted != NULL) *deleted = num;
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1146,6 +1304,7 @@ unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsig
     unsigned int num = (end-start)+1;
     if (deleted) *deleted = num;
     zl = ziplistDeleteRange(zl,2*(start-1),2*num);
+    __A_VARIABLE = 1;
     return zl;
 }
 
@@ -1162,6 +1321,7 @@ unsigned long zsetLength(const robj *zobj) {
     } else {
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
     return length;
 }
 
@@ -1171,7 +1331,10 @@ void zsetConvert(robj *zobj, int encoding) {
     sds ele;
     double score;
 
-    if (zobj->encoding == encoding) return;
+    if (zobj->encoding == encoding) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
@@ -1234,18 +1397,23 @@ void zsetConvert(robj *zobj, int encoding) {
     } else {
         serverPanic("Unknown sorted set encoding");
     }
+    __A_VARIABLE = 1;
 }
 
 /* Convert the sorted set object into a ziplist if it is not already a ziplist
  * and if the number of elements and the maximum element size is within the
  * expected ranges. */
 void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
-    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+            __A_VARIABLE = 1;
+            return;
+    }
     zset *zset = zobj->ptr;
 
     if (zset->zsl->length <= server.zset_max_ziplist_entries &&
         maxelelen <= server.zset_max_ziplist_value)
             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
+    __A_VARIABLE = 1;
 }
 
 /* Return (by reference) the score of the specified member of the sorted set
@@ -1569,6 +1737,7 @@ void zaddGenericCommand(client *c, int flags) {
     elements = c->argc-scoreidx;
     if (elements % 2 || !elements) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     elements /= 2; /* Now this holds the number of score-element pairs. */
@@ -1577,12 +1746,14 @@ void zaddGenericCommand(client *c, int flags) {
     if (nx && xx) {
         addReplyError(c,
             "XX and NX options at the same time are not compatible");
+        __A_VARIABLE = 1;
         return;
     }
 
     if (incr && elements > 1) {
         addReplyError(c,
             "INCR option supports a single increment-element pair");
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -1649,14 +1820,17 @@ cleanup:
         notifyKeyspaceEvent(NOTIFY_ZSET,
             incr ? "zincr" : "zadd", key, c->db->id);
     }
+    __A_VARIABLE = 1;
 }
 
 void zaddCommand(client *c) {
     zaddGenericCommand(c,ZADD_NONE);
+    __A_VARIABLE = 1;
 }
 
 void zincrbyCommand(client *c) {
     zaddGenericCommand(c,ZADD_INCR);
+    __A_VARIABLE = 1;
 }
 
 void zremCommand(client *c) {
@@ -1665,7 +1839,10 @@ void zremCommand(client *c) {
     int deleted = 0, keyremoved = 0, j;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     for (j = 2; j < c->argc; j++) {
         if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
@@ -1684,6 +1861,7 @@ void zremCommand(client *c) {
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
+    __A_VARIABLE = 1;
 }
 
 /* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */
@@ -1792,14 +1970,17 @@ cleanup:
 
 void zremrangebyrankCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_RANK);
+    __A_VARIABLE = 1;
 }
 
 void zremrangebyscoreCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_SCORE);
+    __A_VARIABLE = 1;
 }
 
 void zremrangebylexCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_LEX);
+    __A_VARIABLE = 1;
 }
 
 typedef struct {
@@ -1862,8 +2043,10 @@ typedef union _iterset iterset;
 typedef union _iterzset iterzset;
 
 void zuiInitIterator(zsetopsrc *op) {
-    if (op->subject == NULL)
+    if (op->subject == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
@@ -1895,11 +2078,14 @@ void zuiInitIterator(zsetopsrc *op) {
     } else {
         serverPanic("Unsupported type");
     }
+    __A_VARIABLE = 1;
 }
 
 void zuiClearIterator(zsetopsrc *op) {
-    if (op->subject == NULL)
+    if (op->subject == NULL) {
+        __A_VARIABLE = 1;
         return;
+    }
 
     if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
@@ -1922,6 +2108,7 @@ void zuiClearIterator(zsetopsrc *op) {
     } else {
         serverPanic("Unsupported type");
     }
+    __A_VARIABLE = 1;
 }
 
 unsigned long zuiLength(zsetopsrc *op) {
@@ -2029,6 +2216,7 @@ int zuiLongLongFromValue(zsetopval *val) {
             val->flags |= OPVAL_VALID_LL;
         }
     }
+    __A_VARIABLE = 1;
     return val->flags & OPVAL_VALID_LL;
 }
 
@@ -2041,6 +2229,7 @@ sds zuiSdsFromValue(zsetopval *val) {
         }
         val->flags |= OPVAL_DIRTY_SDS;
     }
+    __A_VARIABLE = 1;
     return val->ele;
 }
 
@@ -2072,6 +2261,7 @@ int zuiBufferFromValue(zsetopval *val) {
             val->estr = val->_buf;
         }
     }
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -2133,8 +2323,15 @@ int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
 int zuiCompareByCardinality(const void *s1, const void *s2) {
     unsigned long first = zuiLength((zsetopsrc*)s1);
     unsigned long second = zuiLength((zsetopsrc*)s2);
-    if (first > second) return 1;
-    if (first < second) return -1;
+    if (first > second) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (first < second) {
+        __A_VARIABLE = 1;
+        return -1;
+    }
+    __A_VARIABLE = 1;
     return 0;
 }
 
@@ -2158,6 +2355,7 @@ inline static void zunionInterAggregate(double *target, double val, int aggregat
         /* safety net */
         serverPanic("Unknown ZUNION/INTER aggregate type");
     }
+    __A_VARIABLE = 1;
 }
 
 uint64_t dictSdsHash(const void *key);
@@ -2401,10 +2599,12 @@ void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
 
 void zunionstoreCommand(client *c) {
     zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
+    __A_VARIABLE = 1;
 }
 
 void zinterstoreCommand(client *c) {
     zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
+    __A_VARIABLE = 1;
 }
 
 void zrangeGenericCommand(client *c, int reverse) {
@@ -2511,10 +2711,12 @@ void zrangeGenericCommand(client *c, int reverse) {
 
 void zrangeCommand(client *c) {
     zrangeGenericCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangeCommand(client *c) {
     zrangeGenericCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 /* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */
@@ -2711,10 +2913,12 @@ void genericZrangebyscoreCommand(client *c, int reverse) {
 
 void zrangebyscoreCommand(client *c) {
     genericZrangebyscoreCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangebyscoreCommand(client *c) {
     genericZrangebyscoreCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void zcountCommand(client *c) {
@@ -3055,10 +3259,12 @@ void genericZrangebylexCommand(client *c, int reverse) {
 
 void zrangebylexCommand(client *c) {
     genericZrangebylexCommand(c,0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrangebylexCommand(client *c) {
     genericZrangebylexCommand(c,1);
+    __A_VARIABLE = 1;
 }
 
 void zcardCommand(client *c) {
@@ -3066,9 +3272,13 @@ void zcardCommand(client *c) {
     robj *zobj;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
 
     addReplyLongLong(c,zsetLength(zobj));
+    __A_VARIABLE = 1;
 }
 
 void zscoreCommand(client *c) {
@@ -3077,13 +3287,17 @@ void zscoreCommand(client *c) {
     double score;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
         addReply(c,shared.nullbulk);
     } else {
         addReplyDouble(c,score);
     }
+    __A_VARIABLE = 1;
 }
 
 void zrankGenericCommand(client *c, int reverse) {
@@ -3093,7 +3307,10 @@ void zrankGenericCommand(client *c, int reverse) {
     long rank;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,OBJ_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) {
+        __A_VARIABLE = 1;
+        return;
+    }
 
     serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
     rank = zsetRank(zobj,ele->ptr,reverse);
@@ -3102,24 +3319,34 @@ void zrankGenericCommand(client *c, int reverse) {
     } else {
         addReply(c,shared.nullbulk);
     }
+    __A_VARIABLE = 1;
 }
 
 void zrankCommand(client *c) {
     zrankGenericCommand(c, 0);
+    __A_VARIABLE = 1;
 }
 
 void zrevrankCommand(client *c) {
     zrankGenericCommand(c, 1);
+    __A_VARIABLE = 1;
 }
 
 void zscanCommand(client *c) {
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) {
+        __A_VARIABLE = 1;
+        return;
+    }
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,OBJ_ZSET)) return;
+        checkType(c,o,OBJ_ZSET)) {
+    	__A_VARIABLE = 1;
+    	return;
+    }
     scanGenericCommand(c,o,cursor);
+    __A_VARIABLE = 1;
 }
 
 /* This command implements the generic zpop operation, used by:
@@ -3141,10 +3368,13 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
 
     /* If a count argument as passed, parse it or return an error. */
     if (countarg) {
-        if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK)
+        if (getLongFromObjectOrReply(c,countarg,&count,NULL) != C_OK) {
+            __A_VARIABLE = 1;
             return;
+        }
         if (count <= 0) {
             addReply(c,shared.emptymultibulk);
+            __A_VARIABLE = 1;
             return;
         }
     }
@@ -3155,13 +3385,17 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
         key = keyv[idx++];
         zobj = lookupKeyWrite(c->db,key);
         if (!zobj) continue;
-        if (checkType(c,zobj,OBJ_ZSET)) return;
+        if (checkType(c,zobj,OBJ_ZSET)) {
+            __A_VARIABLE = 1;
+            return;
+        }
         break;
     }
 
     /* No candidate for zpopping, return empty. */
     if (!zobj) {
         addReply(c,shared.emptymultibulk);
+        __A_VARIABLE = 1;
         return;
     }
 
@@ -3233,26 +3467,31 @@ void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey
     } while(--count);
 
     setDeferredMultiBulkLength(c,arraylen_ptr,arraylen + (emitkey != 0));
+    __A_VARIABLE = 1;
 }
 
 /* ZPOPMIN key [<count>] */
 void zpopminCommand(client *c) {
     if (c->argc > 3) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     genericZpopCommand(c,&c->argv[1],1,ZSET_MIN,0,
         c->argc == 3 ? c->argv[2] : NULL);
+    __A_VARIABLE = 1;
 }
 
 /* ZMAXPOP key [<count>] */
 void zpopmaxCommand(client *c) {
     if (c->argc > 3) {
         addReply(c,shared.syntaxerr);
+        __A_VARIABLE = 1;
         return;
     }
     genericZpopCommand(c,&c->argv[1],1,ZSET_MAX,0,
         c->argc == 3 ? c->argv[2] : NULL);
+    __A_VARIABLE = 1;
 }
 
 /* BZPOPMIN / BZPOPMAX actual implementation. */
@@ -3298,9 +3537,11 @@ void blockingGenericZpopCommand(client *c, int where) {
 // BZPOPMIN key [key ...] timeout
 void bzpopminCommand(client *c) {
     blockingGenericZpopCommand(c,ZSET_MIN);
+    __A_VARIABLE = 1;
 }
 
 // BZPOPMAX key [key ...] timeout
 void bzpopmaxCommand(client *c) {
     blockingGenericZpopCommand(c,ZSET_MAX);
+    __A_VARIABLE = 1;
 }
diff --git a/src/util.c b/src/util.c
index 0854254..65f9dd4 100644
--- a/src/util.c
+++ b/src/util.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /*
  * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
@@ -58,6 +59,7 @@ static inline int gettimeofday_wrapper(struct timeval *tv, void *tz)
 	tv->tv_sec = _ptimeval.tv_sec;
 	tv->tv_usec = _ptimeval.tv_usec;
 
+	__A_VARIABLE = 1;
 	return now;
 }
 
@@ -187,6 +189,7 @@ int stringmatchlen(const char *pattern, int patternLen,
 }
 
 int stringmatch(const char *pattern, const char *string, int nocase) {
+    __A_VARIABLE = 1;
     return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
 }
 
@@ -203,6 +206,7 @@ int stringmatchlen_fuzz_test(void) {
         for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
         total_matches += stringmatchlen(pat, patlen, str, strlen, 0);
     }
+    __A_VARIABLE = 1;
     return total_matches;
 }
 
@@ -268,22 +272,39 @@ long long memtoll(const char *p, int *err) {
 /* Return the number of digits of 'v' when converted to string in radix 10.
  * See ll2string() for more information. */
 uint32_t digits10(uint64_t v) {
-    if (v < 10) return 1;
-    if (v < 100) return 2;
-    if (v < 1000) return 3;
+    if (v < 10) {
+        __A_VARIABLE = 1;
+        return 1;
+    }
+    if (v < 100) {
+        __A_VARIABLE = 1;
+        return 2;
+    }
+    if (v < 1000) {
+        __A_VARIABLE = 1;
+        return 3;
+    }
     if (v < 1000000000000UL) {
         if (v < 100000000UL) {
             if (v < 1000000) {
-                if (v < 10000) return 4;
+                if (v < 10000) {
+                    __A_VARIABLE = 1;
+                    return 4;
+                }
+                __A_VARIABLE = 1;
                 return 5 + (v >= 100000);
             }
+            __A_VARIABLE = 1;
             return 7 + (v >= 10000000UL);
         }
         if (v < 10000000000UL) {
+            __A_VARIABLE = 1;
             return 9 + (v >= 1000000000UL);
         }
+        __A_VARIABLE = 1;
         return 11 + (v >= 100000000000UL);
     }
+    __A_VARIABLE = 1;
     return 12 + digits10(v / 1000000000000UL);
 }
 
@@ -336,7 +357,10 @@ int ll2string(char *dst, size_t dstlen, long long svalue) {
 
     /* Check length. */
     uint32_t const length = digits10(value)+negative;
-    if (length >= dstlen) return 0;
+    if (length >= dstlen) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
 
     /* Null term. */
     uint32_t next = length;
@@ -361,6 +385,7 @@ int ll2string(char *dst, size_t dstlen, long long svalue) {
 
     /* Add sign. */
     if (negative) dst[0] = '-';
+    __A_VARIABLE = 1;
     return length;
 }
 
@@ -448,13 +473,18 @@ int string2ll(const char *s, size_t slen, long long *value) {
 int string2l(const char *s, size_t slen, long *lval) {
     long long llval;
 
-    if (!string2ll(s,slen,&llval))
+    if (!string2ll(s,slen,&llval)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
-    if (llval < LONG_MIN || llval > LONG_MAX)
+    if (llval < LONG_MIN || llval > LONG_MAX) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     *lval = (long)llval;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -470,7 +500,10 @@ int string2ld(const char *s, size_t slen, long double *dp) {
     long double value;
     char *eptr;
 
-    if (slen >= sizeof(buf)) return 0;
+    if (slen >= sizeof(buf)) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     memcpy(buf,s,slen);
     buf[slen] = '\0';
 
@@ -480,10 +513,13 @@ int string2ld(const char *s, size_t slen, long double *dp) {
         (errno == ERANGE &&
             (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
         errno == EINVAL ||
-        isnan(value))
+        isnan(value)) {
+        __A_VARIABLE = 1;
         return 0;
+    }
 
     if (dp) *dp = value;
+    __A_VARIABLE = 1;
     return 1;
 }
 
@@ -526,6 +562,7 @@ int d2string(char *buf, size_t len, double value) {
             len = snprintf(buf,len,"%.17g",value);
     }
 
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -622,6 +659,7 @@ void getRandomBytes(unsigned char *p, size_t len) {
         len -= copylen;
         p += copylen;
     }
+    __A_VARIABLE = 1;
 }
 
 /* Generate the Redis "Run ID", a SHA1-sized random number that identifies a
@@ -634,6 +672,7 @@ void getRandomHexChars(char *p, size_t len) {
 
     getRandomBytes((unsigned char*)p,len);
     for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];
+    __A_VARIABLE = 1;
 }
 
 /* Given the filename, return the absolute path as an SDS string, or NULL
@@ -649,11 +688,15 @@ sds getAbsolutePath(char *filename) {
     sds relpath = sdsnew(filename);
 
     relpath = sdstrim(relpath," \r\n\t");
-    if (relpath[0] == '/') return relpath; /* Path is already absolute. */
+    if (relpath[0] == '/') {
+        __A_VARIABLE = 1;
+        return relpath;
+    } /* Path is already absolute. */
 
     /* If path is relative, join cwd and relative path. */
     if (getcwd(cwd,sizeof(cwd)) == NULL) {
         sdsfree(relpath);
+        __A_VARIABLE = 1;
         return NULL;
     }
     abspath = sdsnew(cwd);
@@ -685,6 +728,7 @@ sds getAbsolutePath(char *filename) {
     /* Finally glue the two parts together. */
     abspath = sdscatsds(abspath,relpath);
     sdsfree(relpath);
+    __A_VARIABLE = 1;
     return abspath;
 }
 
@@ -711,6 +755,7 @@ unsigned long getTimeZone(void) {
  * character exists inside the specified path, that's enough in the
  * environments where Redis runs. */
 int pathIsBaseName(char *path) {
+    __A_VARIABLE = 1;
     return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
 }
 
@@ -770,6 +815,7 @@ static void test_string2ll(void) {
 
     strcpy(buf,"9223372036854775808"); /* overflow */
     assert(string2ll(buf,strlen(buf),&v) == 0);
+    __A_VARIABLE = 1;
 }
 
 static void test_string2l(void) {
@@ -819,6 +865,7 @@ static void test_string2l(void) {
     strcpy(buf,"2147483648"); /* overflow */
     assert(string2l(buf,strlen(buf),&v) == 0);
 #endif
+    __A_VARIABLE = 1;
 }
 
 static void test_ll2string(void) {
@@ -860,6 +907,7 @@ static void test_ll2string(void) {
     sz = ll2string(buf, sizeof buf, v);
     assert(sz == 19);
     assert(!strcmp(buf, "9223372036854775807"));
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
@@ -870,6 +918,7 @@ int utilTest(int argc, char **argv) {
     test_string2ll();
     test_string2l();
     test_ll2string();
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/ziplist.c b/src/ziplist.c
index ef40d6a..842cbee 100644
--- a/src/ziplist.c
+++ b/src/ziplist.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* The ziplist is a specially encoded dually linked list that is designed
  * to be very memory efficient. It stores both strings and integer values,
  * where integers are encoded as actual integers instead of a series of
diff --git a/src/zipmap.c b/src/zipmap.c
index 22bfa1a..491ac6a 100644
--- a/src/zipmap.c
+++ b/src/zipmap.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* String -> String Map data structure optimized for size.
  * This file implements a data structure mapping strings to other strings
  * implementing an O(n) lookup data structure designed to be very memory
@@ -98,6 +99,7 @@ unsigned char *zipmapNew(void) {
 
     zm[0] = 0; /* Length */
     zm[1] = ZIPMAP_END;
+    __A_VARIABLE = 1;
     return zm;
 }
 
@@ -105,9 +107,13 @@ unsigned char *zipmapNew(void) {
 static unsigned int zipmapDecodeLength(unsigned char *p) {
     unsigned int len = *p;
 
-    if (len < ZIPMAP_BIGLEN) return len;
+    if (len < ZIPMAP_BIGLEN) {
+        __A_VARIABLE = 1;
+        return len;
+    }
     memcpy(&len,p+1,sizeof(unsigned int));
     memrev32ifbe(&len);
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -171,12 +177,14 @@ static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen)
     l = klen+vlen+3;
     if (klen >= ZIPMAP_BIGLEN) l += 4;
     if (vlen >= ZIPMAP_BIGLEN) l += 4;
+    __A_VARIABLE = 1;
     return l;
 }
 
 /* Return the total amount used by a key (encoded length + payload) */
 static unsigned int zipmapRawKeyLength(unsigned char *p) {
     unsigned int l = zipmapDecodeLength(p);
+    __A_VARIABLE = 1;
     return zipmapEncodeLength(NULL,l) + l;
 }
 
@@ -188,6 +196,7 @@ static unsigned int zipmapRawValueLength(unsigned char *p) {
 
     used = zipmapEncodeLength(NULL,l);
     used += p[used] + 1 + l;
+    __A_VARIABLE = 1;
     return used;
 }
 
@@ -196,12 +205,14 @@ static unsigned int zipmapRawValueLength(unsigned char *p) {
  * free space if any). */
 static unsigned int zipmapRawEntryLength(unsigned char *p) {
     unsigned int l = zipmapRawKeyLength(p);
+    __A_VARIABLE = 1;
     return l + zipmapRawValueLength(p+l);
 }
 
 static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
     zm = zrealloc(zm, len);
     zm[len-1] = ZIPMAP_END;
+    __A_VARIABLE = 1;
     return zm;
 }
 
@@ -273,6 +284,7 @@ unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int kle
     p += zipmapEncodeLength(p,vlen);
     *p++ = vempty;
     memcpy(p,val,vlen);
+    __A_VARIABLE = 1;
     return zm;
 }
 
@@ -293,11 +305,13 @@ unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int kle
     } else {
         if (deleted) *deleted = 0;
     }
+    __A_VARIABLE = 1;
     return zm;
 }
 
 /* Call before iterating through elements via zipmapNext() */
 unsigned char *zipmapRewind(unsigned char *zm) {
+    __A_VARIABLE = 1;
     return zm+1;
 }
 
@@ -313,7 +327,10 @@ unsigned char *zipmapRewind(unsigned char *zm) {
  * }
  */
 unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
-    if (zm[0] == ZIPMAP_END) return NULL;
+    if (zm[0] == ZIPMAP_END) {
+        __A_VARIABLE = 1;
+        return NULL;
+    }
     if (key) {
         *key = zm;
         *klen = zipmapDecodeLength(zm);
@@ -326,6 +343,7 @@ unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *
         *value += ZIPMAP_LEN_BYTES(*vlen);
     }
     zm += zipmapRawValueLength(zm);
+    __A_VARIABLE = 1;
     return zm;
 }
 
@@ -334,15 +352,20 @@ unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *
 int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
     unsigned char *p;
 
-    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
+    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     p += zipmapRawKeyLength(p);
     *vlen = zipmapDecodeLength(p);
     *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
+    __A_VARIABLE = 1;
     return 1;
 }
 
 /* Return 1 if the key exists, otherwise 0 is returned. */
 int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
+    __A_VARIABLE = 1;
     return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
 }
 
@@ -358,6 +381,7 @@ unsigned int zipmapLen(unsigned char *zm) {
         /* Re-store length if small enough */
         if (len < ZIPMAP_BIGLEN) zm[0] = len;
     }
+    __A_VARIABLE = 1;
     return len;
 }
 
@@ -367,6 +391,7 @@ unsigned int zipmapLen(unsigned char *zm) {
 size_t zipmapBlobLen(unsigned char *zm) {
     unsigned int totlen;
     zipmapLookupRaw(zm,NULL,0,&totlen);
+    __A_VARIABLE = 1;
     return totlen;
 }
 
@@ -402,6 +427,7 @@ static void zipmapRepr(unsigned char *p) {
         }
     }
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 #define UNUSED(x) (void)(x)
@@ -464,6 +490,7 @@ int zipmapTest(int argc, char *argv[]) {
             printf("  %d:%.*s => %d:%.*s\n", klen, klen, key, vlen, vlen, value);
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/src/zmalloc.c b/src/zmalloc.c
index 2482f51..9423a52 100644
--- a/src/zmalloc.c
+++ b/src/zmalloc.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* zmalloc - total amount of allocated memory aware version of malloc()
  *
  * Copyright (c) 2009-2010, Salvatore Sanfilippo <antirez at gmail dot com>
@@ -38,6 +39,7 @@
  * free implementation if we use jemalloc or another non standard allocator. */
 void zlibc_free(void *ptr) {
     free(ptr);
+    __A_VARIABLE = 1;
 }
 
 #include <string.h>
@@ -91,6 +93,7 @@ static void zmalloc_default_oom(size_t size) {
         size);
     fflush(stderr);
     abort();
+    __A_VARIABLE = 1;
 }
 
 static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;
@@ -117,13 +120,18 @@ void *zmalloc_no_tcache(size_t size) {
     void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);
     if (!ptr) zmalloc_oom_handler(size);
     update_zmalloc_stat_alloc(zmalloc_size(ptr));
+    __A_VARIABLE = 1;
     return ptr;
 }
 
 void zfree_no_tcache(void *ptr) {
-    if (ptr == NULL) return;
+    if (ptr == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
     update_zmalloc_stat_free(zmalloc_size(ptr));
     dallocx(ptr, MALLOCX_TCACHE_NONE);
+    __A_VARIABLE = 1;
 }
 #endif
 
@@ -180,9 +188,11 @@ size_t zmalloc_size(void *ptr) {
     /* Assume at least that all the allocations are padded at sizeof(long) by
      * the underlying allocator. */
     if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));
+    __A_VARIABLE = 1;
     return size+PREFIX_SIZE;
 }
 size_t zmalloc_usable(void *ptr) {
+    __A_VARIABLE = 1;
     return zmalloc_size(ptr)-PREFIX_SIZE;
 }
 #endif
@@ -193,7 +203,10 @@ void zfree(void *ptr) {
     size_t oldsize;
 #endif
 
-    if (ptr == NULL) return;
+    if (ptr == NULL) {
+        __A_VARIABLE = 1;
+        return;
+    }
 #ifdef HAVE_MALLOC_SIZE
     update_zmalloc_stat_free(zmalloc_size(ptr));
     free(ptr);
@@ -203,6 +216,7 @@ void zfree(void *ptr) {
     update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
     free(realptr);
 #endif
+    __A_VARIABLE = 1;
 }
 
 char *zstrdup(const char *s) {
@@ -210,17 +224,20 @@ char *zstrdup(const char *s) {
     char *p = zmalloc(l);
 
     memcpy(p,s,l);
+    __A_VARIABLE = 1;
     return p;
 }
 
 size_t zmalloc_used_memory(void) {
     size_t um;
     atomicGet(used_memory,um);
+    __A_VARIABLE = 1;
     return um;
 }
 
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
     zmalloc_oom_handler = oom_handler;
+    __A_VARIABLE = 1;
 }
 
 /* Get the RSS information in an OS-specific way.
@@ -248,9 +265,13 @@ size_t zmalloc_get_rss(void) {
     char *p, *x;
 
     snprintf(filename,256,"/proc/%d/stat",getpid());
-    if ((fd = open(filename,O_RDONLY)) == -1) return 0;
+    if ((fd = open(filename,O_RDONLY)) == -1) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     if (read(fd,buf,4096) <= 0) {
         close(fd);
+        __A_VARIABLE = 1;
         return 0;
     }
     close(fd);
@@ -261,13 +282,20 @@ size_t zmalloc_get_rss(void) {
         p = strchr(p,' ');
         if (p) p++;
     }
-    if (!p) return 0;
+    if (!p) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     x = strchr(p,' ');
-    if (!x) return 0;
+    if (!x) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     *x = '\0';
 
     rss = strtoll(p,NULL,10);
     rss *= page;
+    __A_VARIABLE = 1;
     return rss;
 }
 #elif defined(HAVE_TASKINFO)
@@ -284,10 +312,13 @@ size_t zmalloc_get_rss(void) {
     struct task_basic_info t_info;
     mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;
 
-    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)
+    if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS) {
+        __A_VARIABLE = 1;
         return 0;
+    }
     task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);
 
+    __A_VARIABLE = 1;
     return t_info.resident_size;
 }
 #else
@@ -297,6 +328,7 @@ size_t zmalloc_get_rss(void) {
      *
      * Fragmentation will appear to be always 1 (no fragmentation)
      * of course... */
+    __A_VARIABLE = 1;
     return zmalloc_used_memory();
 }
 #endif
@@ -321,6 +353,7 @@ int zmalloc_get_allocator_info(size_t *allocated,
     /* Unlike zmalloc_used_memory, this matches the stats.resident by taking
      * into account all allocations done by this process (not only zmalloc). */
     je_mallctl("stats.allocated", allocated, &sz, NULL, 0);
+    __A_VARIABLE = 1;
     return 1;
 }
 #else
@@ -328,6 +361,7 @@ int zmalloc_get_allocator_info(size_t *allocated,
                                size_t *active,
                                size_t *resident) {
     *allocated = *resident = *active = 0;
+    __A_VARIABLE = 1;
     return 1;
 }
 #endif
@@ -357,7 +391,10 @@ size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
         fp = fopen(filename,"r");
     }
 
-    if (!fp) return 0;
+    if (!fp) {
+        __A_VARIABLE = 1;
+        return 0;
+    }
     while(fgets(line,sizeof(line),fp) != NULL) {
         if (strncmp(line,field,flen) == 0) {
             char *p = strchr(line,'k');
@@ -368,17 +405,20 @@ size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
         }
     }
     fclose(fp);
+    __A_VARIABLE = 1;
     return bytes;
 }
 #else
 size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
     ((void) field);
     ((void) pid);
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
 
 size_t zmalloc_get_private_dirty(long pid) {
+    __A_VARIABLE = 1;
     return zmalloc_get_smap_bytes_by_field("Private_Dirty:",pid);
 }
 
@@ -452,6 +492,7 @@ int zmalloc_test(int argc, char **argv) {
     printf("Reallocated to 456 bytes; used: %zu\n", zmalloc_used_memory());
     zfree(ptr);
     printf("Freed pointer; used: %zu\n", zmalloc_used_memory());
+    __A_VARIABLE = 1;
     return 0;
 }
 #endif
diff --git a/tests/modules/commandfilter.c b/tests/modules/commandfilter.c
index d25d49c..c0f5e4c 100644
--- a/tests/modules/commandfilter.c
+++ b/tests/modules/commandfilter.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #define REDISMODULE_EXPERIMENTAL_API
 #include "redismodule.h"
 
@@ -20,6 +21,7 @@ int CommandFilter_UnregisterCommand(RedisModuleCtx *ctx, RedisModuleString **arg
     RedisModule_ReplyWithLongLong(ctx,
             RedisModule_UnregisterCommandFilter(ctx, filter));
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -36,6 +38,7 @@ int CommandFilter_PingCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
         RedisModule_ReplyWithSimpleString(ctx, "Unknown command or invalid arguments");
     }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -71,12 +74,16 @@ int CommandFilter_LogCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int
 
     in_log_command = 0;
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void CommandFilter_CommandFilter(RedisModuleCommandFilterCtx *filter)
 {
-    if (in_log_command) return;  /* don't process our own RM_Call() from CommandFilter_LogCommand() */
+    if (in_log_command) {
+        __A_VARIABLE = 1;
+        return;
+    }  /* don't process our own RM_Call() from CommandFilter_LogCommand() */
 
     /* Fun manipulations:
      * - Remove @delme
@@ -114,14 +121,19 @@ void CommandFilter_CommandFilter(RedisModuleCommandFilterCtx *filter)
 
     if (log) RedisModule_CommandFilterArgInsert(filter, 0,
             RedisModule_CreateString(NULL, log_command_name, sizeof(log_command_name)-1));
+    __A_VARIABLE = 1;
 }
 
 int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     if (RedisModule_Init(ctx,"commandfilter",1,REDISMODULE_APIVER_1)
-            == REDISMODULE_ERR) return REDISMODULE_ERR;
+            == REDISMODULE_ERR) {
+        __A_VARIABLE = 1;
+        return REDISMODULE_ERR;
+    }
 
     if (argc != 2) {
         RedisModule_Log(ctx, "warning", "Log key name not specified");
+        __A_VARIABLE = 1;
         return REDISMODULE_ERR;
     }
 
@@ -130,20 +142,30 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_StringToLongLong(argv[1], &noself);
 
     if (RedisModule_CreateCommand(ctx,log_command_name,
-                CommandFilter_LogCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_LogCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,ping_command_name,
-                CommandFilter_PingCommand,"deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_PingCommand,"deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if (RedisModule_CreateCommand(ctx,unregister_command_name,
-                CommandFilter_UnregisterCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+                CommandFilter_UnregisterCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR) {
+            __A_VARIABLE = 1;
             return REDISMODULE_ERR;
+    }
 
     if ((filter = RedisModule_RegisterCommandFilter(ctx, CommandFilter_CommandFilter, 
                     noself ? REDISMODULE_CMDFILTER_NOSELF : 0))
-            == NULL) return REDISMODULE_ERR;
+            == NULL) {
+            __A_VARIABLE = 1;
+            return REDISMODULE_ERR;
+    }
 
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
diff --git a/tests/modules/testrdb.c b/tests/modules/testrdb.c
index 415497a..154690e 100644
--- a/tests/modules/testrdb.c
+++ b/tests/modules/testrdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include "redismodule.h"
 
 #include <string.h>
@@ -18,6 +19,7 @@ void *testrdb_type_load(RedisModuleIO *rdb, int encver) {
     assert(count==1);
     assert(encver==1);
     RedisModuleString *str = RedisModule_LoadString(rdb);
+    __A_VARIABLE = 1;
     return str;
 }
 
@@ -25,6 +27,7 @@ void testrdb_type_save(RedisModuleIO *rdb, void *value) {
     RedisModuleString *str = (RedisModuleString*)value;
     RedisModule_SaveSigned(rdb, 1);
     RedisModule_SaveString(rdb, str);
+    __A_VARIABLE = 1;
 }
 
 void testrdb_aux_save(RedisModuleIO *rdb, int when) {
@@ -45,6 +48,7 @@ void testrdb_aux_save(RedisModuleIO *rdb, int when) {
             RedisModule_SaveSigned(rdb, 0);
         }
     }
+    __A_VARIABLE = 1;
 }
 
 int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
@@ -67,17 +71,20 @@ int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
         if (count)
             after_str = RedisModule_LoadString(rdb);
     }
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
 void testrdb_type_free(void *value) {
     RedisModule_FreeString(NULL, (RedisModuleString*)value);
+    __A_VARIABLE = 1;
 }
 
 int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
     if (argc != 2) {
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -86,6 +93,7 @@ int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     before_str = argv[1];
     RedisModule_RetainString(ctx, argv[1]);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -94,12 +102,14 @@ int testrdb_get_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argv);
     if (argc != 1){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
     if (before_str)
         RedisModule_ReplyWithString(ctx, before_str);
     else
         RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -107,6 +117,7 @@ int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
     if (argc != 2){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -115,6 +126,7 @@ int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     after_str = argv[1];
     RedisModule_RetainString(ctx, argv[1]);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -123,12 +135,14 @@ int testrdb_get_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     REDISMODULE_NOT_USED(argv);
     if (argc != 1){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
     if (after_str)
         RedisModule_ReplyWithString(ctx, after_str);
     else
         RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -136,6 +150,7 @@ int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
     if (argc != 3){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -147,6 +162,7 @@ int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModule_RetainString(ctx, argv[2]);
     RedisModule_CloseKey(key);
     RedisModule_ReplyWithLongLong(ctx, 1);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
@@ -154,6 +170,7 @@ int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 {
     if (argc != 2){
         RedisModule_WrongArity(ctx);
+        __A_VARIABLE = 1;
         return REDISMODULE_OK;
     }
 
@@ -161,6 +178,7 @@ int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
     RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
     RedisModule_CloseKey(key);
     RedisModule_ReplyWithString(ctx, str);
+    __A_VARIABLE = 1;
     return REDISMODULE_OK;
 }
 
diff --git a/utils/corrupt_rdb.c b/utils/corrupt_rdb.c
index df9c93e..04ad8cf 100644
--- a/utils/corrupt_rdb.c
+++ b/utils/corrupt_rdb.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 /* Trivia program to corrupt an RDB file in order to check the RDB check
  * program behavior and effectiveness.
  *
@@ -41,5 +42,6 @@ int main(int argc, char **argv) {
         printf("Writing %d bytes at offset %lu\n", writelen, offset);
         write(fd,buf,writelen);
     }
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/utils/hashtable/rehashing.c b/utils/hashtable/rehashing.c
index b57a904..d10c6a0 100644
--- a/utils/hashtable/rehashing.c
+++ b/utils/hashtable/rehashing.c
@@ -1,9 +1,11 @@
+static volatile int __A_VARIABLE;
 #include "redis.h"
 #include "dict.h"
 
 void _redisAssert(char *x, char *y, int l) {
     printf("ASSERT: %s %s %d\n",x,y,l);
     exit(1);
+    __A_VARIABLE = 1;
 }
 
 unsigned int dictKeyHash(const void *keyp) {
@@ -15,12 +17,14 @@ unsigned int dictKeyHash(const void *keyp) {
     key ^=  (key >> 6);
     key += ~(key << 11);
     key ^=  (key >> 16);
+    __A_VARIABLE = 1;
     return key;
 }
 
 int dictKeyCompare(void *privdata, const void *key1, const void *key2) {
     unsigned long k1 = (unsigned long)key1;
     unsigned long k2 = (unsigned long)key2;
+    __A_VARIABLE = 1;
     return k1 == k2;
 }
 
@@ -43,6 +47,7 @@ void showBuckets(dictht ht) {
         }
         printf("\n");
     }
+    __A_VARIABLE = 1;
 }
 
 void show(dict *d) {
@@ -58,6 +63,7 @@ void show(dict *d) {
     printf("ht[1]: ");
     showBuckets(d->ht[1]);
     printf("\n");
+    __A_VARIABLE = 1;
 }
 
 int sortPointers(const void *a, const void *b) {
@@ -65,6 +71,7 @@ int sortPointers(const void *a, const void *b) {
 
     la = (long) (*((dictEntry**)a));
     lb = (long) (*((dictEntry**)b));
+    __A_VARIABLE = 1;
     return la-lb;
 }
 
@@ -94,6 +101,7 @@ void stressGetKeys(dict *d, int times, int *perfect_run, int *approx_run) {
         }
     }
     zfree(des);
+    __A_VARIABLE = 1;
 }
 
 #define MAX1 120
@@ -138,5 +146,6 @@ int main(void) {
     dictRelease(d);
 
     printf("TEST PASSED!\n");
+    __A_VARIABLE = 1;
     return 0;
 }
diff --git a/utils/lru/lfu-simulation.c b/utils/lru/lfu-simulation.c
index 6aa5911..cb15d0c 100644
--- a/utils/lru/lfu-simulation.c
+++ b/utils/lru/lfu-simulation.c
@@ -1,3 +1,4 @@
+static volatile int __A_VARIABLE;
 #include <stdio.h>
 #include <time.h>
 #include <stdint.h>
@@ -26,7 +27,11 @@ struct entry {
  * we detect the overflow we account for it as if the counter wrapped
  * a single time. */
 uint16_t minutes_diff(uint16_t now, uint16_t prev) {
-    if (now >= prev) return now-prev;
+    if (now >= prev) {
+        __A_VARIABLE = 1;
+        return now-prev;
+    }
+    __A_VARIABLE = 1;
     return 65535-prev+now;
 }
 
@@ -34,12 +39,16 @@ uint16_t minutes_diff(uint16_t now, uint16_t prev) {
  * less likely is that the counter is really incremented.
  * The maximum value of the counter is saturated at 255. */
 uint8_t log_incr(uint8_t counter) {
-    if (counter == 255) return counter;
+    if (counter == 255) {
+        __A_VARIABLE = 1;
+        return counter;
+    }
     double r = (double)rand()/RAND_MAX;
     double baseval = counter-COUNTER_INIT_VAL;
     if (baseval < 0) baseval = 0;
     double limit = 1.0/(baseval*10+1);
     if (r < limit) counter++;
+    __A_VARIABLE = 1;
     return counter;
 }
 
@@ -47,6 +56,7 @@ uint8_t log_incr(uint8_t counter) {
 void access_entry(struct entry *e) {
     e->counter = log_incr(e->counter);
     e->hits++;
+    __A_VARIABLE = 1;
 }
 
 /* Return the entry LFU value and as a side effect decrement the
@@ -64,6 +74,7 @@ uint8_t scan_entry(struct entry *e) {
         }
         e->decrtime = to_16bit_minutes(time(NULL));
     }
+    __A_VARIABLE = 1;
     return e->counter;
 }
 
@@ -78,6 +89,7 @@ void show_entry(long pos, struct entry *e) {
     printf("%ld] <%s> frequency:%d decrtime:%d [%lu hits | age:%ld sec]\n",
         pos, tag, e->counter, e->decrtime, (unsigned long)e->hits,
             time(NULL) - e->ctime);
+    __A_VARIABLE = 1;
 }
 
 int main(void) {
@@ -153,6 +165,7 @@ int main(void) {
             display_time = now;
         }
     }
+    __A_VARIABLE = 1;
     return 0;
 }
 
-- 
2.34.1

